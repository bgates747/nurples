PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000 C3 45 00 04 0003       jp start
040004 FF FF FF FF 0004       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005       db "MOS"
040043 00          0006       db 00h
040044 01          0007       db 01h
040045             0008   start:
040045 F5          0009       push af
040046 C5          0010       push bc
040047 D5          0011       push de
040048 DD E5       0012       push ix
04004A FD E5       0013       push iy
04004C CD 27 0C 04 0014       call init
040050 CD 28 0C 04 0015       call main
040054             0016   exit:
040054 FD E1       0017       pop iy
040056 DD E1       0018       pop ix
040058 D1          0019       pop de
040059 C1          0020       pop bc
04005A F1          0021       pop af
04005B 21 00 00 00 0022       ld hl,0
04005F C9          0023       ret
040060             0024   
040060             0025   ; API INCLUDES
040060             0026       include "mos_api.inc"
040060             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*  ; Title:	AGON MOS - API for user projects
040060             0003*  ; Author:	Dean Belfield
040060             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*  ;			Added MOS error codes for return in HL
040060             0006*  ; Created:	03/08/2022
040060             0007*  ; Last Updated:	10/08/2023
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 05/08/2022:	Added mos_feof
040060             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*  ; 13/10/2022:	Added mos_oscli
040060             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*  ; 19/05/2023:	Added sysvar_scrMode
040060             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*  ; 03/08/2023:	Added mos_setkbvector
040060             0028*  ; 10/08/2023:	Added mos_getkbmap
040060             0029*  
040060             0030*  ; VDP control (VDU 23, 0, n)
040060             0031*  ;
040060             0032*  vdp_gp:				EQU 80h
040060             0033*  vdp_keycode:		EQU 81h
040060             0034*  vdp_cursor:			EQU	82h
040060             0035*  vdp_scrchar:		EQU	83h
040060             0036*  vdp_scrpixel:		EQU	84h
040060             0037*  vdp_audio:			EQU	85h
040060             0038*  vdp_mode:			EQU	86h
040060             0039*  vdp_rtc:			EQU	87h
040060             0040*  vdp_keystate:		EQU	88h
040060             0041*  vdp_logicalcoords:	EQU	C0h
040060             0042*  vdp_terminalmode:	EQU	FFh
040060             0043*  
040060             0044*  ; MOS high level functions
040060             0045*  ;
040060             0046*  mos_getkey:			EQU	00h
040060             0047*  mos_load:			EQU	01h
040060             0048*  mos_save:			EQU	02h
040060             0049*  mos_cd:				EQU	03h
040060             0050*  mos_dir:			EQU	04h
040060             0051*  mos_del:			EQU	05h
040060             0052*  mos_ren:			EQU	06h
040060             0053*  mos_mkdir:			EQU	07h
040060             0054*  mos_sysvars:		EQU	08h
040060             0055*  mos_editline:		EQU	09h
040060             0056*  mos_fopen:			EQU	0Ah
040060             0057*  mos_fclose:			EQU	0Bh
040060             0058*  mos_fgetc:			EQU	0Ch
040060             0059*  mos_fputc:			EQU	0Dh
040060             0060*  mos_feof:			EQU	0Eh
040060             0061*  mos_getError:		EQU	0Fh
040060             0062*  mos_oscli:			EQU	10h
040060             0063*  mos_copy:			EQU	11h
040060             0064*  mos_getrtc:			EQU	12h
040060             0065*  mos_setrtc:			EQU	13h
040060             0066*  mos_setintvector:	EQU	14h
040060             0067*  mos_uopen:			EQU	15h
040060             0068*  mos_uclose:			EQU	16h
040060             0069*  mos_ugetc:			EQU	17h
040060             0070*  mos_uputc:			EQU	18h
040060             0071*  mos_getfil:			EQU	19h
040060             0072*  mos_fread:			EQU	1Ah
040060             0073*  mos_fwrite:			EQU	1Bh
040060             0074*  mos_flseek:			EQU	1Ch
040060             0075*  mos_setkbvector:	EQU	1Dh
040060             0076*  mos_getkbmap:		EQU	1Eh
040060             0077*  
040060             0078*  ; MOS program exit codes
040060             0079*  ;
040060             0080*  EXIT_OK:				EQU  0;	"OK",
040060             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*  ; FatFS file access functions
040060             0103*  ;
040060             0104*  ffs_fopen:			EQU	80h
040060             0105*  ffs_fclose:			EQU	81h
040060             0106*  ffs_fread:			EQU	82h
040060             0107*  ffs_fwrite:			EQU	83h
040060             0108*  ffs_flseek:			EQU	84h
040060             0109*  ffs_ftruncate:		EQU	85h
040060             0110*  ffs_fsync:			EQU	86h
040060             0111*  ffs_fforward:		EQU	87h
040060             0112*  ffs_fexpand:		EQU	88h
040060             0113*  ffs_fgets:			EQU	89h
040060             0114*  ffs_fputc:			EQU	8Ah
040060             0115*  ffs_fputs:			EQU	8Bh
040060             0116*  ffs_fprintf:		EQU	8Ch
040060             0117*  ffs_ftell:			EQU	8Dh
040060             0118*  ffs_feof:			EQU	8Eh
040060             0119*  ffs_fsize:			EQU	8Fh
040060             0120*  ffs_ferror:			EQU	90h
040060             0121*  
040060             0122*  ; FatFS directory access functions
040060             0123*  ;
040060             0124*  ffs_dopen:			EQU	91h
040060             0125*  ffs_dclose:			EQU	92h
040060             0126*  ffs_dread:			EQU	93h
040060             0127*  ffs_dfindfirst:		EQU	94h
040060             0128*  ffs_dfindnext:		EQU	95h
040060             0129*  
040060             0130*  ; FatFS file and directory management functions
040060             0131*  ;
040060             0132*  ffs_stat:			EQU	96h
040060             0133*  ffs_unlink:			EQU	97h
040060             0134*  ffs_rename:			EQU	98h
040060             0135*  ffs_chmod:			EQU	99h
040060             0136*  ffs_utime:			EQU	9Ah
040060             0137*  ffs_mkdir:			EQU	9Bh
040060             0138*  ffs_chdir:			EQU	9Ch
040060             0139*  ffs_chdrive:		EQU	9Dh
040060             0140*  ffs_getcwd:			EQU	9Eh
040060             0141*  
040060             0142*  ; FatFS volume management and system configuration functions
040060             0143*  ;
040060             0144*  ffs_mount:			EQU	9Fh
040060             0145*  ffs_mkfs:			EQU	A0h
040060             0146*  ffs_fdisk:			EQU	A1h
040060             0147*  ffs_getfree:		EQU	A2h
040060             0148*  ffs_getlabel:		EQU	A3h
040060             0149*  ffs_setlabel:		EQU	A4h
040060             0150*  ffs_setcp:			EQU	A5h
040060             0151*  
040060             0152*  ; File access modes
040060             0153*  ;
040060             0154*  fa_read:			EQU	01h
040060             0155*  fa_write:			EQU	02h
040060             0156*  fa_open_existing:	EQU	00h
040060             0157*  fa_create_new:		EQU	04h
040060             0158*  fa_create_always:	EQU	08h
040060             0159*  fa_open_always:		EQU	10h
040060             0160*  fa_open_append:		EQU	30h
040060             0161*  
040060             0162*  ; System variable indexes for api_sysvars
040060             0163*  ; Index into _sysvars in globals.inc
040060             0164*  ;
040060             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*  
040060             0192*  ; Flags for the VPD protocol
040060             0193*  ;
040060             0194*  vdp_pflag_cursor:		EQU	00000001b
040060             0195*  vdp_pflag_scrchar:		EQU	00000010b
040060             0196*  vdp_pflag_point:		EQU	00000100b
040060             0197*  vdp_pflag_audio:		EQU	00001000b
040060             0198*  vdp_pflag_mode:			EQU	00010000b
040060             0199*  vdp_pflag_rtc:			EQU	00100000b
040060             0200*  
040060             0201*  ;
040060             0202*  ; FatFS structures
040060             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*  ;
040060             0205*  ; Object ID and allocation information (FFOBJID)
040060             0206*  ;
040060             0207*  ; Indexes into FFOBJID structure
040060             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*  ;
040060             0215*  ; File object structure (FIL)
040060             0216*  ;
040060             0217*  ; Indexes into FIL structure
040060             0218*  fil_obj:		EQU 0	; 15: Object identifier
040060             0219*  fil_flag:		EQU	15 	;  1: File status flags
040060             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*  ;
040060             0227*  ; Directory object structure (DIR)
040060             0228*  ; Indexes into DIR structure
040060             0229*  dir_obj:		EQU  0	; 15: Object identifier
040060             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*  dir_clust:		EQU	19	;  4: Current cluster
040060             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*  ;
040060             0237*  ; File information structure (FILINFO)
040060             0238*  ;
040060             0239*  ; Indexes into FILINFO structure
040060             0240*  filinfo_fsize:		EQU 0	;   4: File size
040060             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*  ;
040060             0247*  ; Macro for calling the API
040060             0248*  ; Parameters:
040060             0249*  ; - function: One of the function numbers listed above
040060             0250*  ;
040060             0251*  	MACRO	MOSCALL	function
040060             0252*  			LD	A, function
040060             0253*  			RST.LIL	08h
040060             0254*  	ENDMACRO
040060             0027       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,@F ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*  @@:
040060             0016*      ENDMACRO
040060             0017*  
040060             0018*  ; Simulated call to subroutine at IX
040060             0019*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0020*  ; outputs: whatever the subroutine does, including IX and BC
040060             0021*  ; destroys: only what the subroutine does, but always BC
040060             0022*      MACRO callIX
040060             0023*      ld bc,@F ; Address of first instruction after the jump
040060             0024*      push bc ; which constitutes the return address
040060             0025*      jp (ix) ; Jump to the address in IX
040060             0026*  @@:
040060             0027*      ENDMACRO
040060             0028*  
040060             0029*  ; Simulated call to soubroutinte at IY
040060             0030*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0031*  ; outputs: whatever the subroutine does, including IY and BC
040060             0032*  ; destroys: only what the subroutine does, but always BC
040060             0033*      MACRO callIY
040060             0034*      ld bc,@F ; Address of first instruction after the jump
040060             0035*      push bc ; which constitutes the return address
040060             0036*      jp (iy) ; Jump to the address in IY
040060             0037*  @@:
040060             0038*      ENDMACRO
040060             0039*  
040060             0040*  ; put the value in HLU into the accumulator
040060             0041*  ; destroys: af
040060             0042*      MACRO HLU_TO_A
040060             0043*      push hl ; 4 cycles
040060             0044*      inc sp ; 1 cycle
040060             0045*      pop af ; 4 cycles
040060             0046*      dec sp ; 1 cycle
040060             0047*      ; 10 cycles total
040060             0048*      ENDMACRO
040060             0049*  
040060             0050*  A_TO_HLU:
040060             0051*      ; call is 7 cycles
040060 22 6D 00 04 0052*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0053*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0054*      ld hl,(@scratch) ; 7 cycles
04006C C9          0055*      ret ; 6 cycles
04006D             0056*      ; 25 cycles total
04006D 00 00 00    0057*  @scratch: dl 0
040070             0058*  
040070             0059*      ; TODO: implement this
040070             0060*      ; MACRO A_TO_HLU
040070             0061*      ;     push.s af
040070             0062*      ;     inc sp
040070             0063*      ;     push.s hl
040070             0064*      ;     pop hl
040070             0065*      ;     inc sp
040070             0066*      ;     inc sp
040070             0067*      ; ENDMACRO
040070             0068*  
040070             0069*      MACRO PUSH_ALL
040070             0070*      ex af,af'
040070             0071*      exx
040070             0072*      push af
040070             0073*      push hl
040070             0074*      push bc
040070             0075*      push de
040070             0076*  
040070             0077*      ex af,af'
040070             0078*      exx
040070             0079*      push af
040070             0080*      push hl
040070             0081*      push bc
040070             0082*      push de
040070             0083*      push ix
040070             0084*      push iy
040070             0085*      ENDMACRO
040070             0086*  
040070             0087*      MACRO POP_ALL
040070             0088*      pop iy
040070             0089*      pop ix
040070             0090*      pop de
040070             0091*      pop bc
040070             0092*      pop hl
040070             0093*      pop af
040070             0094*      ex af,af'
040070             0095*      exx
040070             0096*  
040070             0097*      pop de
040070             0098*      pop bc
040070             0099*      pop hl
040070             0100*      pop af
040070             0101*      ex af,af'
040070             0102*      exx
040070             0103*      ENDMACRO
040070             0104*  
040070             0105*  ; Print a zero-terminated string inline with code, e.g.:
040070             0106*  ;
040070             0107*  ;    call printInline
040070             0108*  ;    ASCIZ "Hello, world!\r\n"
040070             0109*  ;
040070             0110*  ; Destroys: HL,AF
040070             0111*  printInline:
040070 E1          0112*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0113*      call printString ; HL advances to end of string
040075 E5          0114*      push hl ; restore the return address = pointer to end of string
040076 C9          0115*      ret
040077             0116*  
040077             0117*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0118*  ; Print a zero-terminated string
040077             0119*  ; HL: Pointer to string
040077             0120*  printString:
040077 C5          0121*      PUSH BC
040078 01 00 00 00 0122*      LD BC,0
04007C 3E 00       0123*      LD A,0
04007E 5B DF       0124*      RST.LIL 18h
040080 C1          0125*      POP BC
040081 C9          0126*      RET
040082             0127*  ; print a VDU sequence
040082             0128*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0129*  sendVDUsequence:
040082 C5          0130*      PUSH BC
040083 01 00 00 00 0131*      LD BC, 0
040087 4E          0132*      LD C, (HL)
040088 5B DF       0133*      RST.LIL 18h
04008A C1          0134*      POP BC
04008B C9          0135*      RET
04008C             0136*  ; Print Newline sequence to VDP
04008C             0137*  printNewLine:
04008C F5          0138*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0139*      LD A, '\r'
04008F 5B D7       0140*      RST.LIL 10h
040091 3E 0A       0141*      LD A, '\n'
040093 5B D7       0142*      RST.LIL 10h
040095 F1          0143*      pop af
040096 C9          0144*      RET
040097             0145*  
040097             0146*  ; Print a 24-bit HEX number
040097             0147*  ; HLU: Number to print
040097             0148*  printHex24:
040097             0149*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0150*      CALL printHex8
04009F             0151*  ; Print a 16-bit HEX number
04009F             0152*  ; HL: Number to print
04009F             0153*  printHex16:
04009F 7C          0154*      LD A,H
0400A0 CD A5 00 04 0155*      CALL printHex8
0400A4 7D          0156*      LD A,L
0400A5             0157*  ; Print an 8-bit HEX number
0400A5             0158*  ; A: Number to print
0400A5             0159*  printHex8:
0400A5 4F          0160*      LD C,A
0400A6 1F          0161*      RRA
0400A7 1F          0162*      RRA
0400A8 1F          0163*      RRA
0400A9 1F          0164*      RRA
0400AA CD AF 00 04 0165*      CALL @F
0400AE 79          0166*      LD A,C
0400AF             0167*  @@:
0400AF E6 0F       0168*      AND 0Fh
0400B1 C6 90       0169*      ADD A,90h
0400B3 27          0170*      DAA
0400B4 CE 40       0171*      ADC A,40h
0400B6 27          0172*      DAA
0400B7 5B D7       0173*      RST.LIL 10h
0400B9 C9          0174*      RET
0400BA             0175*  
0400BA             0176*  printHexA:
0400BA F5          0177*      push af
0400BB C5          0178*      push bc
0400BC CD A5 00 04 0179*      call printHex8
0400C0 3E 20       0180*      ld a,' '
0400C2 5B D7       0181*      rst.lil 10h
0400C4 C1          0182*      pop bc
0400C5 F1          0183*      pop af
0400C6 C9          0184*      ret
0400C7             0185*  
0400C7             0186*  printHexHL:
0400C7 F5          0187*      push af
0400C8 C5          0188*      push bc
0400C9 CD 9F 00 04 0189*      call printHex16
0400CD 3E 20       0190*      ld a,' '
0400CF 5B D7       0191*      rst.lil 10h
0400D1 C1          0192*      pop bc
0400D2 F1          0193*      pop af
0400D3 C9          0194*      ret
0400D4             0195*  
0400D4             0196*  printHexUHL:
0400D4 F5          0197*      push af
0400D5 C5          0198*      push bc
0400D6 CD 97 00 04 0199*      call printHex24
0400DA 3E 20       0200*      ld a,' '
0400DC 5B D7       0201*      rst.lil 10h
0400DE C1          0202*      pop bc
0400DF F1          0203*      pop af
0400E0 C9          0204*      ret
0400E1             0205*  
0400E1             0206*  printHexAUHL:
0400E1 F5          0207*      push af
0400E2 C5          0208*      push bc
0400E3 CD A5 00 04 0209*      call printHex8
0400E7 3E 2E       0210*      ld a,'.'
0400E9 5B D7       0211*      rst.lil 10h
0400EB CD 97 00 04 0212*      call printHex24
0400EF 3E 20       0213*      ld a,' '
0400F1 5B D7       0214*      rst.lil 10h
0400F3 C1          0215*      pop bc
0400F4 F1          0216*      pop af
0400F5 C9          0217*      ret
0400F6             0218*  
0400F6             0219*  printHexABHL:
0400F6             0220*  ; preserve registers
0400F6 C5          0221*      push bc ; b will be ok c will not
0400F7 F5          0222*      push af ; will get totally destroyed
0400F8             0223*  ; print a
0400F8 CD A5 00 04 0224*      call printHex8
0400FC             0225*  ; print b
0400FC 78          0226*      ld a,b
0400FD CD A5 00 04 0227*      call printHex8
040101             0228*  ; print hl
040101 CD 9F 00 04 0229*      call printHex16
040105             0230*  ; restore registers
040105 F1          0231*      pop af
040106 C1          0232*      pop bc
040107 C9          0233*      ret
040108             0234*  
040108             0235*  printHexBHL:
040108             0236*  ; preserve registers
040108 C5          0237*      push bc ; b will be ok c will not
040109 F5          0238*      push af ; will get totally destroyed
04010A             0239*  ; print b
04010A 78          0240*      ld a,b
04010B CD A5 00 04 0241*      call printHex8
04010F             0242*  ; print hl
04010F CD 9F 00 04 0243*      call printHex16
040113             0244*  ; restore registers
040113 F1          0245*      pop af
040114 C1          0246*      pop bc
040115 C9          0247*      ret
040116             0248*  
040116             0249*  printHexCDE:
040116             0250*  ; preserve registers
040116 C5          0251*      push bc ; b will be ok c will not
040117 F5          0252*      push af ; will get totally destroyed
040118             0253*  ; print c
040118 79          0254*      ld a,c
040119 CD A5 00 04 0255*      call printHex8
04011D             0256*  ; print de
04011D EB          0257*      ex de,hl
04011E CD 9F 00 04 0258*      call printHex16
040122 EB          0259*      ex de,hl
040123             0260*  ; restore registers
040123 F1          0261*      pop af
040124 C1          0262*      pop bc
040125 C9          0263*      ret
040126             0264*  
040126             0265*  printHexUIX:
040126             0266*  ; store everything in scratch
040126 22 9F 05 04 0267*      ld (uhl),hl
04012A ED 43 A2 05 0268*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0269*      ld (ude),de
       04          
040134 DD 22 A8 05 0270*      ld (uix),ix
       04          
040139 FD 22 AB 05 0271*      ld (uiy),iy
       04          
04013E F5          0272*      push af ; fml
04013F             0273*  
04013F 21 36 05 04 0274*      ld hl,str_ixu
040143 CD 77 00 04 0275*      call printString
040147 2A A8 05 04 0276*      ld hl,(uix)
04014B CD 97 00 04 0277*      call printHex24
04014F CD 8C 00 04 0278*      call printNewLine
040153             0279*  
040153             0280*  ; restore everything
040153 2A 9F 05 04 0281*      ld hl, (uhl)
040157 ED 4B A2 05 0282*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0283*      ld de, (ude)
       04          
040161 DD 2A A8 05 0284*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0285*      ld iy, (uiy)
       04          
04016B F1          0286*      pop af
04016C             0287*  ; all done
04016C C9          0288*      ret
04016D             0289*  
04016D             0290*  ; Print a 0x HEX prefix
04016D             0291*  DisplayHexPrefix:
04016D 3E 30       0292*      LD A, '0'
04016F 5B D7       0293*      RST.LIL 10h
040171 3E 78       0294*      LD A, 'x'
040173 5B D7       0295*      RST.LIL 10h
040175 C9          0296*      RET
040176             0297*  
040176             0298*      MACRO printDecBC
040176             0299*      push hl
040176             0300*      push bc
040176             0301*      pop hl
040176             0302*      call printDec
040176             0303*      pop hl
040176             0304*      ENDMACRO
040176             0305*  
040176             0306*      MACRO printDecDE
040176             0307*      push hl
040176             0308*      push de
040176             0309*      pop hl
040176             0310*      call printDec
040176             0311*      pop hl
040176             0312*      ENDMACRO
040176             0313*  
040176             0314*      MACRO printDecHL
040176             0315*      call printDec
040176             0316*      ENDMACRO
040176             0317*  
040176             0318*      MACRO printDecIX
040176             0319*      push hl
040176             0320*      push ix
040176             0321*      pop hl
040176             0322*      call printDec
040176             0323*      pop hl
040176             0324*      ENDMACRO
040176             0325*  
040176             0326*      MACRO printDecIY
040176             0327*      push hl
040176             0328*      push iy
040176             0329*      pop hl
040176             0330*      call printDec
040176             0331*      pop hl
040176             0332*      ENDMACRO
040176             0333*  
040176             0334*  
040176             0335*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0336*  ; HL : Value to print
040176             0337*  ; preserves all registers and flags
040176             0338*  printDec:
040176             0339*  ; BEGIN MY CODE
040176             0340*  ; back up all the things
040176 F5          0341*      push af
040177 C5          0342*      push bc
040178 D5          0343*      push de
040179 E5          0344*      push hl
04017A             0345*  ; END MY CODE
04017A 11 A2 01 04 0346*      LD DE, _printDecBuffer
04017E CD B2 01 04 0347*      CALL u24_to_ascii
040182             0348*  ; BEGIN MY CODE
040182             0349*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0350*      LD HL, _printDecBuffer
040186 06 07       0351*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0352*  @loop:
040188 7E          0353*      LD A, (HL)
040189 FE 30       0354*      CP '0'
04018B C2 95 01 04 0355*      JP NZ, @done
04018F 3E 20       0356*      LD A, ' '
040191 77          0357*      LD (HL), A
040192 23          0358*      INC HL
040193             0359*      ; CALL vdu_cursor_forward
040193 10 F3       0360*      DJNZ @loop
040195             0361*  @done:
040195             0362*  ; END MY CODE
040195 21 A2 01 04 0363*      LD HL, _printDecBuffer
040199 CD 77 00 04 0364*      CALL printString
04019D             0365*  ; BEGIN MY CODE
04019D             0366*  ; restore all the things
04019D E1          0367*      pop hl
04019E D1          0368*      pop de
04019F C1          0369*      pop bc
0401A0 F1          0370*      pop af
0401A1             0371*  ; END MY CODE
0401A1 C9          0372*      RET
0401A2 00 00 00 00 0373*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0374*  
0401B2             0375*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0376*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0377*  ; so it will allways be 8 characters length
0401B2             0378*  ; HL : Value to convert to string
0401B2             0379*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0380*  u24_to_ascii:
0401B2 01 80 69 67 0381*      LD BC,-10000000
0401B6 CD E9 01 04 0382*      CALL @one_digit
0401BA 01 C0 BD F0 0383*      LD BC,-1000000
0401BE CD E9 01 04 0384*      CALL @one_digit
0401C2 01 60 79 FE 0385*      LD BC,-100000
0401C6 CD E9 01 04 0386*      CALL @one_digit
0401CA 01 F0 D8 FF 0387*      LD BC,-10000
0401CE CD E9 01 04 0388*      CALL @one_digit
0401D2 01 18 FC FF 0389*      LD BC,-1000
0401D6 CD E9 01 04 0390*      CALL @one_digit
0401DA 01 9C FF FF 0391*      LD BC,-100
0401DE CD E9 01 04 0392*      CALL @one_digit
0401E2 0E F6       0393*      LD C,-10
0401E4 CD E9 01 04 0394*      CALL @one_digit
0401E8 48          0395*      LD C,B
0401E9             0396*  @one_digit:
0401E9 3E 2F       0397*      LD A,'0'-1
0401EB             0398*  @divide_me:
0401EB 3C          0399*      INC A
0401EC 09          0400*      ADD HL,BC
0401ED 38 FC       0401*      JR C,@divide_me
0401EF ED 42       0402*      SBC HL,BC
0401F1 12          0403*      LD (DE),A
0401F2 13          0404*      INC DE
0401F3 C9          0405*      RET
0401F4             0406*  
0401F4             0407*  print_u24:
0401F4 D5          0408*      push de
0401F5 E5          0409*      push hl
0401F6 11 A2 01 04 0410*      ld de,_printDecBuffer
0401FA CD B2 01 04 0411*      call u24_to_ascii
0401FE 21 A2 01 04 0412*      ld hl,_printDecBuffer
040202 CD 77 00 04 0413*      call printString
040206 3E 20       0414*      ld a,' '
040208 5B D7       0415*      rst.lil 10h
04020A E1          0416*      pop hl
04020B D1          0417*      pop de
04020C C9          0418*      ret
04020D             0419*  
04020D             0420*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0421*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0422*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0423*  u168_to_ascii:
04020D             0424*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0425*      ld a,' '
04020F 12          0426*      ld (de),a
040210 13          0427*      inc de
040211             0428*  ; Convert integer part
040211 E5          0429*      push hl ; Save HL (weâ€™ll need the fractional part later)
040212 CD FB 06 04 0430*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0431*      ld bc, -10000
04021A CD 3D 02 04 0432*      call @one_int
04021E 01 18 FC FF 0433*      ld bc, -1000
040222 CD 3D 02 04 0434*      call @one_int
040226 01 9C FF FF 0435*      ld bc, -100
04022A CD 3D 02 04 0436*      call @one_int
04022E 0E F6       0437*      ld c, -10
040230 CD 3D 02 04 0438*      call @one_int
040234 48          0439*      ld c, b
040235 CD 3D 02 04 0440*      call @one_int
040239 C3 48 02 04 0441*      jp @frac ; Jump to fractional part conversion
04023D             0442*  @one_int:
04023D 3E 2F       0443*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0444*  @divide_me:
04023F 3C          0445*      inc a
040240 09          0446*      add hl, bc ; Accumulate until overflow
040241 38 FC       0447*      jr c, @divide_me
040243 ED 42       0448*      sbc hl, bc ; Remove excess after overflow
040245 12          0449*      ld (de), a ; Store ASCII digit
040246 13          0450*      inc de
040247 C9          0451*      ret
040248             0452*  ; Convert fractional part
040248             0453*  @frac:
040248 3E 2E       0454*      ld a, '.' ; Decimal point
04024A 12          0455*      ld (de), a
04024B 13          0456*      inc de
04024C E1          0457*      pop hl ; Restore HL with original fraction
04024D 06 03       0458*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0459*  @frac_loop:
04024F 26 0A       0460*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0461*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0462*      ld a, '0'
040255 84          0463*      add a, h ; Convert integer part to ASCII
040256 12          0464*      ld (de), a
040257 13          0465*      inc de
040258 10 F5       0466*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0467*  ; Add null terminator
04025A AF          0468*      xor a ; Null terminator
04025B 12          0469*      ld (de), a
04025C C9          0470*      ret
04025D             0471*  
04025D             0472*  print_u168:
04025D D5          0473*      push de
04025E E5          0474*      push hl
04025F 11 A2 01 04 0475*      ld de,_printDecBuffer
040263 CD 0D 02 04 0476*      call u168_to_ascii
040267 21 A2 01 04 0477*      ld hl,_printDecBuffer
04026B CD 77 00 04 0478*      call printString
04026F E1          0479*      pop hl
040270 D1          0480*      pop de
040271 C9          0481*      ret
040272             0482*  
040272             0483*  ; signed version of u168_to_ascii
040272             0484*  s168_to_ascii:
040272 D5          0485*      push de ; save starting address of buffer
040273 CD 94 06 04 0486*      call hlu_abs
040277 F5          0487*      push af ; save sign flag
040278 CD 0D 02 04 0488*      call u168_to_ascii
04027C F1          0489*      pop af ; restore sign flag
04027D D1          0490*      pop de ; restore starting address of buffer
04027E F0          0491*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0492*      ld a,'-'
040281 12          0493*      ld (de),a
040282 C9          0494*      ret
040283             0495*  
040283             0496*  print_s168:
040283 D5          0497*      push de
040284 E5          0498*      push hl
040285 11 A2 01 04 0499*      ld de,_printDecBuffer
040289 CD 72 02 04 0500*      call s168_to_ascii
04028D 21 A2 01 04 0501*      ld hl,_printDecBuffer
040291 CD 77 00 04 0502*      call printString
040295 E1          0503*      pop hl
040296 D1          0504*      pop de
040297 C9          0505*      ret
040298             0506*  
040298             0507*  print_s168_hl:
040298 F5          0508*      push af
040299 E5          0509*      push hl
04029A CD 83 02 04 0510*      call print_s168
04029E 3E 20       0511*      ld a,' '
0402A0 5B D7       0512*      rst.lil 10h
0402A2 E1          0513*      pop hl
0402A3 F1          0514*      pop af
0402A4 C9          0515*      ret
0402A5             0516*  
0402A5             0517*  print_s168_bc:
0402A5 F5          0518*      push af
0402A6 C5          0519*      push bc
0402A7 E5          0520*      push hl
0402A8 C5          0521*      push bc
0402A9 E1          0522*      pop hl
0402AA CD 83 02 04 0523*      call print_s168
0402AE 3E 20       0524*      ld a,' '
0402B0 5B D7       0525*      rst.lil 10h
0402B2 E1          0526*      pop hl
0402B3 C1          0527*      pop bc
0402B4 F1          0528*      pop af
0402B5 C9          0529*      ret
0402B6             0530*  
0402B6             0531*  print_s168_de:
0402B6 F5          0532*      push af
0402B7 D5          0533*      push de
0402B8 E5          0534*      push hl
0402B9 EB          0535*      ex de,hl
0402BA CD 83 02 04 0536*      call print_s168
0402BE 3E 20       0537*      ld a,' '
0402C0 5B D7       0538*      rst.lil 10h
0402C2 E1          0539*      pop hl
0402C3 D1          0540*      pop de
0402C4 F1          0541*      pop af
0402C5 C9          0542*      ret
0402C6             0543*  
0402C6             0544*  print_s168_hl_bc_de:
0402C6 F5          0545*      push af
0402C7 C5          0546*      push bc
0402C8 D5          0547*      push de
0402C9 E5          0548*      push hl
0402CA CD 83 02 04 0549*      call print_s168
0402CE 3E 20       0550*      ld a,' '
0402D0 5B D7       0551*      rst.lil 10h
0402D2 C5          0552*      push bc
0402D3 E1          0553*      pop hl
0402D4 CD 83 02 04 0554*      call print_s168
0402D8 3E 20       0555*      ld a,' '
0402DA 5B D7       0556*      rst.lil 10h
0402DC EB          0557*      ex de,hl
0402DD CD 83 02 04 0558*      call print_s168
0402E1 3E 20       0559*      ld a,' '
0402E3 5B D7       0560*      rst.lil 10h
0402E5 E1          0561*      pop hl
0402E6 D1          0562*      pop de
0402E7 C1          0563*      pop bc
0402E8 F1          0564*      pop af
0402E9 C9          0565*      ret
0402EA             0566*  
0402EA             0567*  print_s168_bc_de:
0402EA F5          0568*      push af
0402EB C5          0569*      push bc
0402EC D5          0570*      push de
0402ED C5          0571*      push bc
0402EE E1          0572*      pop hl
0402EF CD 83 02 04 0573*      call print_s168
0402F3 3E 20       0574*      ld a,' '
0402F5 5B D7       0575*      rst.lil 10h
0402F7 EB          0576*      ex de,hl
0402F8 CD 83 02 04 0577*      call print_s168
0402FC 3E 20       0578*      ld a,' '
0402FE 5B D7       0579*      rst.lil 10h
040300 E1          0580*      pop hl
040301 D1          0581*      pop de
040302 C1          0582*      pop bc
040303 F1          0583*      pop af
040304 C9          0584*      ret
040305             0585*  
040305             0586*  print_s168_a:
040305 F5          0587*      push af
040306 C5          0588*      push bc
040307 E5          0589*      push hl
040308 21 00 00 00 0590*      ld hl,0
04030C 6F          0591*      ld l,a
04030D CD 98 02 04 0592*      call print_s168_hl
040311 E1          0593*      pop hl
040312 C1          0594*      pop bc
040313 F1          0595*      pop af
040314 C9          0596*      ret
040315             0597*  
040315             0598*  ; #### new functions added by Brandon R. Gates ####
040315             0599*  
040315             0600*  ; print the binary representation of the 8-bit value in a
040315             0601*  ; destroys a, hl, bc
040315             0602*  printBin8:
040315 06 08       0603*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0604*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0605*      ; (which will be the high bit of the value in a)
04031B             0606*  @loop:
04031B 07          0607*      rlca ; put the next highest bit into carry
04031C 38 04       0608*      jr c,@one
04031E 36 30       0609*      ld (hl),'0'
040320 18 02       0610*      jr @next_bit
040322             0611*  @one:
040322 36 31       0612*      ld (hl),'1'
040324             0613*  @next_bit:
040324 23          0614*      inc hl
040325 10 F4       0615*      djnz @loop
040327             0616*  ; print it
040327 21 32 03 04 0617*      ld hl,@cmd
04032B 01 08 00 00 0618*      ld bc,@end-@cmd
04032F 5B DF       0619*      rst.lil $18
040331 C9          0620*      ret
040332             0621*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0622*  @end:
04033A             0623*  
04033A             0624*  ; print the binary representation of the 8-bit value in a
04033A             0625*  ; in reverse order (lsb first)
04033A             0626*  ; destroys a, hl, bc
04033A             0627*  printBin8Rev:
04033A 06 08       0628*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0629*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0630*      ; (which will be the high bit of the value in a)
040340             0631*  @loop:
040340 0F          0632*      rrca ; put the next lowest bit into carry
040341 38 04       0633*      jr c,@one
040343 36 30       0634*      ld (hl),'0'
040345 18 02       0635*      jr @next_bit
040347             0636*  @one:
040347 36 31       0637*      ld (hl),'1'
040349             0638*  @next_bit:
040349 23          0639*      inc hl
04034A 10 F4       0640*      djnz @loop
04034C             0641*  ; print it
04034C 21 57 03 04 0642*      ld hl,@cmd
040350 01 08 00 00 0643*      ld bc,@end-@cmd
040354 5B DF       0644*      rst.lil $18
040356 C9          0645*      ret
040357             0646*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0647*  @end:
04035F             0648*  
04035F             0649*  ; print registers to screen in hexidecimal format
04035F             0650*  ; inputs: none
04035F             0651*  ; outputs: values of every register printed to screen
04035F             0652*  ;    values of each register in global scratch memory
04035F             0653*  ; destroys: nothing
04035F             0654*  stepRegistersHex:
04035F             0655*  ; store everything in scratch
04035F 22 9F 05 04 0656*      ld (uhl),hl
040363 ED 43 A2 05 0657*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0658*      ld (ude),de
       04          
04036D DD 22 A8 05 0659*      ld (uix),ix
       04          
040372 FD 22 AB 05 0660*      ld (uiy),iy
       04          
040377 F5          0661*      push af ; fml
040378 E1          0662*      pop hl ; thanks, zilog
040379 22 9C 05 04 0663*      ld (uaf),hl
04037D F5          0664*      push af ; dammit
04037E             0665*  
04037E             0666*  ; home the cursor
04037E             0667*      ; call vdu_home_cursor
04037E             0668*  
04037E             0669*  ; print each register
04037E 21 22 05 04 0670*      ld hl,str_afu
040382 CD 77 00 04 0671*      call printString
040386 2A 9C 05 04 0672*      ld hl,(uaf)
04038A CD 97 00 04 0673*      call printHex24
04038E CD 8C 00 04 0674*      call printNewLine
040392             0675*  
040392 21 27 05 04 0676*      ld hl,str_hlu
040396 CD 77 00 04 0677*      call printString
04039A 2A 9F 05 04 0678*      ld hl,(uhl)
04039E CD 97 00 04 0679*      call printHex24
0403A2 CD 8C 00 04 0680*      call printNewLine
0403A6             0681*  
0403A6 21 2C 05 04 0682*      ld hl,str_bcu
0403AA CD 77 00 04 0683*      call printString
0403AE 2A A2 05 04 0684*      ld hl,(ubc)
0403B2 CD 97 00 04 0685*      call printHex24
0403B6 CD 8C 00 04 0686*      call printNewLine
0403BA             0687*  
0403BA 21 31 05 04 0688*      ld hl,str_deu
0403BE CD 77 00 04 0689*      call printString
0403C2 2A A5 05 04 0690*      ld hl,(ude)
0403C6 CD 97 00 04 0691*      call printHex24
0403CA CD 8C 00 04 0692*      call printNewLine
0403CE             0693*  
0403CE 21 36 05 04 0694*      ld hl,str_ixu
0403D2 CD 77 00 04 0695*      call printString
0403D6 2A A8 05 04 0696*      ld hl,(uix)
0403DA CD 97 00 04 0697*      call printHex24
0403DE CD 8C 00 04 0698*      call printNewLine
0403E2             0699*  
0403E2 21 3B 05 04 0700*      ld hl,str_iyu
0403E6 CD 77 00 04 0701*      call printString
0403EA 2A AB 05 04 0702*      ld hl,(uiy)
0403EE CD 97 00 04 0703*      call printHex24
0403F2 CD 8C 00 04 0704*      call printNewLine
0403F6             0705*  
0403F6             0706*      ; call vsync
0403F6             0707*  
0403F6 CD 8C 00 04 0708*      call printNewLine
0403FA             0709*  
0403FA             0710*  ; check for right shift key and quit if pressed
0403FA             0711*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0712*  @stayhere:
0403FE             0713*  ; 7 RightShift
0403FE DD CB 00 76 0714*      bit 6,(ix+0)
040402 20 02       0715*      jr nz,@RightShift
040404 18 F8       0716*      jr @stayhere
040406             0717*  @RightShift:
040406 DD CB 0E 86 0718*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0719*      ld a,%10000000
04040C             0720*      ; call multiPurposeDelay
04040C             0721*  
04040C             0722*  ; restore everything
04040C 2A 9F 05 04 0723*      ld hl, (uhl)
040410 ED 4B A2 05 0724*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0725*      ld de, (ude)
       04          
04041A DD 2A A8 05 0726*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0727*      ld iy, (uiy)
       04          
040424 F1          0728*      pop af
040425             0729*  ; all done
040425 C9          0730*      ret
040426             0731*  
040426             0732*  ; print registers to screen in hexidecimal format
040426             0733*  ; inputs: none
040426             0734*  ; outputs: values of every register printed to screen
040426             0735*  ;    values of each register in global scratch memory
040426             0736*  ; destroys: nothing
040426             0737*  dumpRegistersHex:
040426             0738*  ; store everything in scratch
040426 22 9F 05 04 0739*      ld (uhl),hl
04042A ED 43 A2 05 0740*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0741*      ld (ude),de
       04          
040434 DD 22 A8 05 0742*      ld (uix),ix
       04          
040439 FD 22 AB 05 0743*      ld (uiy),iy
       04          
04043E F5          0744*      push af ; fml
04043F E1          0745*      pop hl ; thanks, zilog
040440 22 9C 05 04 0746*      ld (uaf),hl
040444 F5          0747*      push af ; dammit
040445             0748*  
040445             0749*  ; home the cursor
040445             0750*      ; call vdu_home_cursor
040445             0751*      ; call printNewLine
040445             0752*  
040445             0753*  ; print each register
040445 21 22 05 04 0754*      ld hl,str_afu
040449 CD 77 00 04 0755*      call printString
04044D 2A 9C 05 04 0756*      ld hl,(uaf)
040451 CD 97 00 04 0757*      call printHex24
040455             0758*      ; call printNewLine
040455             0759*  
040455 21 27 05 04 0760*      ld hl,str_hlu
040459 CD 77 00 04 0761*      call printString
04045D 2A 9F 05 04 0762*      ld hl,(uhl)
040461 CD 97 00 04 0763*      call printHex24
040465             0764*      ; call printNewLine
040465             0765*  
040465 21 2C 05 04 0766*      ld hl,str_bcu
040469 CD 77 00 04 0767*      call printString
04046D 2A A2 05 04 0768*      ld hl,(ubc)
040471 CD 97 00 04 0769*      call printHex24
040475             0770*      ; call printNewLine
040475             0771*  
040475 21 31 05 04 0772*      ld hl,str_deu
040479 CD 77 00 04 0773*      call printString
04047D 2A A5 05 04 0774*      ld hl,(ude)
040481 CD 97 00 04 0775*      call printHex24
040485             0776*      ; call printNewLine
040485             0777*  
040485 21 36 05 04 0778*      ld hl,str_ixu
040489 CD 77 00 04 0779*      call printString
04048D 2A A8 05 04 0780*      ld hl,(uix)
040491 CD 97 00 04 0781*      call printHex24
040495             0782*      ; call printNewLine
040495             0783*  
040495 21 3B 05 04 0784*      ld hl,str_iyu
040499 CD 77 00 04 0785*      call printString
04049D 2A AB 05 04 0786*      ld hl,(uiy)
0404A1 CD 97 00 04 0787*      call printHex24
0404A5             0788*      ; call printNewLine
0404A5             0789*  
0404A5             0790*      ; call vdu_vblank
0404A5             0791*  
0404A5 CD 8C 00 04 0792*      call printNewLine
0404A9             0793*  ; restore everything
0404A9 2A 9F 05 04 0794*      ld hl, (uhl)
0404AD ED 4B A2 05 0795*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0796*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0797*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0798*      ld iy, (uiy)
       04          
0404C1 F1          0799*      pop af
0404C2             0800*  ; all done
0404C2 C9          0801*      ret
0404C3             0802*  
0404C3             0803*  dumpRegistersHexPrime:
0404C3 D9          0804*      exx
0404C4 08          0805*      ex af,af'
0404C5 CD 26 04 04 0806*      call dumpRegistersHex
0404C9 08          0807*      ex af,af'
0404CA D9          0808*      exx
0404CB C9          0809*      ret
0404CC             0810*  
0404CC             0811*  ; additionally dump prime registers
0404CC             0812*  ; inputs: none
0404CC             0813*  ; outputs: values of every register printed to screen
0404CC             0814*  ; destroys: nothing
0404CC             0815*  dumpRegistersHexAll:
0404CC CD 26 04 04 0816*      call dumpRegistersHex
0404D0 08          0817*      ex af,af'
0404D1 D9          0818*      exx
0404D2 CD 26 04 04 0819*      call dumpRegistersHex
0404D6 08          0820*      ex af,af'
0404D7 D9          0821*      exx
0404D8 C9          0822*      ret
0404D9             0823*  
0404D9             0824*  ; print hlu to screen in hexidecimal format
0404D9             0825*  ; inputs: none
0404D9             0826*  ; destroys: nothing
0404D9             0827*  print_hex_hl:
0404D9 F5          0828*      push af
0404DA E5          0829*      push hl
0404DB 21 27 05 04 0830*      ld hl,str_hlu
0404DF CD 77 00 04 0831*      call printString
0404E3 E1          0832*      pop hl
0404E4 E5          0833*      push hl
0404E5 CD 97 00 04 0834*      call printHex24
0404E9 3E 20       0835*      ld a,' '
0404EB 5B D7       0836*      rst.lil 10h
0404ED E1          0837*      pop hl
0404EE F1          0838*      pop af
0404EF C9          0839*      ret
0404F0             0840*  
0404F0             0841*  ; print bcu to screen in hexidecimal format
0404F0             0842*  ; inputs: none
0404F0             0843*  ; destroys: nothing
0404F0             0844*  print_hex_bc:
0404F0 F5          0845*      push af
0404F1 E5          0846*      push hl
0404F2 C5          0847*      push bc
0404F3 21 2C 05 04 0848*      ld hl,str_bcu
0404F7 CD 77 00 04 0849*      call printString
0404FB E1          0850*      pop hl
0404FC E5          0851*      push hl
0404FD CD 97 00 04 0852*      call printHex24
040501 3E 20       0853*      ld a,' '
040503 5B D7       0854*      rst.lil 10h
040505 C1          0855*      pop bc
040506 E1          0856*      pop hl
040507 F1          0857*      pop af
040508 C9          0858*      ret
040509             0859*  
040509             0860*  ; print deu to screen in hexidecimal format
040509             0861*  ; inputs: none
040509             0862*  ; destroys: nothing
040509             0863*  print_hex_de:
040509 F5          0864*      push af
04050A E5          0865*      push hl
04050B D5          0866*      push de
04050C 21 31 05 04 0867*      ld hl,str_deu
040510 CD 77 00 04 0868*      call printString
040514 E1          0869*      pop hl
040515 E5          0870*      push hl
040516 CD 97 00 04 0871*      call printHex24
04051A 3E 20       0872*      ld a,' '
04051C 5B D7       0873*      rst.lil 10h
04051E D1          0874*      pop de
04051F E1          0875*      pop hl
040520 F1          0876*      pop af
040521 C9          0877*      ret
040522             0878*  
040522 20 61 66 3D 0879*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0880*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0881*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0882*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0883*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0884*  str_iyu: db " iy=",0
       00          
040540             0885*  
040540             0886*  ; print udeuhl to screen in hexidecimal format
040540             0887*  ; inputs: none
040540             0888*  ; outputs: concatenated hexidecimal udeuhl
040540             0889*  ; destroys: nothing
040540             0890*  dumpUDEUHLHex:
040540             0891*  ; store everything in scratch
040540 22 9F 05 04 0892*      ld (uhl),hl
040544 ED 43 A2 05 0893*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0894*      ld (ude),de
       04          
04054E DD 22 A8 05 0895*      ld (uix),ix
       04          
040553 FD 22 AB 05 0896*      ld (uiy),iy
       04          
040558 F5          0897*      push af
040559             0898*  
040559             0899*  ; print each register
040559             0900*  
040559 21 93 05 04 0901*      ld hl,str_udeuhl
04055D CD 77 00 04 0902*      call printString
040561 2A A5 05 04 0903*      ld hl,(ude)
040565 CD 97 00 04 0904*      call printHex24
040569 3E 2E       0905*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0906*      rst.lil 10h
04056D 2A 9F 05 04 0907*      ld hl,(uhl)
040571 CD 97 00 04 0908*      call printHex24
040575 CD 8C 00 04 0909*      call printNewLine
040579             0910*  
040579             0911*  ; restore everything
040579 2A 9F 05 04 0912*      ld hl, (uhl)
04057D ED 4B A2 05 0913*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0914*      ld de, (ude)
       04          
040587 DD 2A A8 05 0915*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0916*      ld iy, (uiy)
       04          
040591 F1          0917*      pop af
040592             0918*  ; all done
040592 C9          0919*      ret
040593             0920*  
040593 75 64 65 2E 0921*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0922*  
04059C             0923*  ; global scratch memory for registers
04059C 00 00 00    0924*  uaf: dl 0
04059F 00 00 00    0925*  uhl: dl 0
0405A2 00 00 00    0926*  ubc: dl 0
0405A5 00 00 00    0927*  ude: dl 0
0405A8 00 00 00    0928*  uix: dl 0
0405AB 00 00 00    0929*  uiy: dl 0
0405AE 00 00 00    0930*  usp: dl 0
0405B1 00 00 00    0931*  upc: dl 0
0405B4             0932*  
0405B4             0933*  ; inputs: whatever is in the flags register
0405B4             0934*  ; outputs: binary representation of flags
0405B4             0935*  ;          with a header so we know which is what
0405B4             0936*  ; destroys: nothing
0405B4             0937*  ; preserves: everything
0405B4             0938*  dumpFlags:
0405B4             0939*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0940*      push af ; this is so we can send it back unharmed
0405B5 F5          0941*      push af ; this is so we can pop it to hl
0405B6             0942*  ; store everything in scratch
0405B6 22 9F 05 04 0943*      ld (uhl),hl
0405BA ED 43 A2 05 0944*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0945*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0946*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0947*      ld (uiy),iy
       04          
0405CE             0948*  ; next we print the header
0405CE 21 FA 05 04 0949*      ld hl,@header
0405D2 CD 77 00 04 0950*      call printString
0405D6 E1          0951*      pop hl ; flags are now in l
0405D7 7D          0952*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0953*      call printBin8
0405DC CD 8C 00 04 0954*      call printNewLine
0405E0             0955*  ; restore everything
0405E0 2A 9F 05 04 0956*      ld hl, (uhl)
0405E4 ED 4B A2 05 0957*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0958*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0959*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0960*      ld iy, (uiy)
       04          
0405F8 F1          0961*      pop af ; send her home the way she came
0405F9 C9          0962*      ret
0405FA             0963*  ; Bit 7 (S): Sign flag
0405FA             0964*  ; Bit 6 (Z): Zero flag
0405FA             0965*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0966*  ; Bit 4 (H): Half Carry flag
0405FA             0967*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0968*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0969*  ; Bit 1 (N): Subtract flag
0405FA             0970*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0971*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0972*  
040605             0973*  ; set all the bits in the flag register
040605             0974*  ; more of an academic exercise than anything useful
040605             0975*  ; inputs; none
040605             0976*  ; outputs; a=0,f=255
040605             0977*  ; destroys: flags, hl
040605             0978*  ; preserves: a, because why not
040605             0979*  setAllFlags:
040605 21 FF 00 00 0980*      ld hl,255
040609 67          0981*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0982*      push hl
04060B F1          0983*      pop af
04060C C9          0984*      ret
04060D             0985*  
04060D             0986*  ; reset all the bits in the flag register
04060D             0987*  ; unlike its inverse counterpart, this may actually be useful
04060D             0988*  ; inputs; none
04060D             0989*  ; outputs; a=0,f=0
04060D             0990*  ; destroys: flags, hl
04060D             0991*  ; preserves: a, because why not
04060D             0992*  resetAllFlags:
04060D 21 00 00 00 0993*      ld hl,0
040611 67          0994*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0995*      push hl
040613 F1          0996*      pop af
040614 C9          0997*      ret
040615             0998*  
040615             0999*  ; wait until user presses a key
040615             1000*  ; inputs: none
040615             1001*  ; outputs: ascii code of key pressed in a
040615             1002*  ; destroys: af,ix
040615             1003*  waitKeypress:
040615             1004*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1005*      ret
04061A             1006*  
04061A             1007*  ; print bytes from an address to the screen in hexidecimal format
04061A             1008*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1009*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1010*  ; destroys: nothing
04061A             1011*  dumpMemoryHex:
04061A             1012*  ; save registers to the stack
04061A C5          1013*      push bc
04061B E5          1014*      push hl
04061C F5          1015*      push af
04061D             1016*  
04061D             1017*  ; print the address and separator
04061D CD 97 00 04 1018*      call printHex24
040621 3E 3A       1019*      ld a,':'
040623 5B D7       1020*      rst.lil 10h
040625 3E 20       1021*      ld a,' '
040627 5B D7       1022*      rst.lil 10h
040629             1023*  
040629             1024*  ; set b to be our loop counter
040629 F1          1025*      pop af
04062A 47          1026*      ld b,a
04062B E1          1027*      pop hl
04062C E5          1028*      push hl
04062D F5          1029*      push af
04062E             1030*  @loop:
04062E             1031*  ; print the byte
04062E 7E          1032*      ld a,(hl)
04062F CD A5 00 04 1033*      call printHex8
040633             1034*  ; print a space
040633 3E 20       1035*      ld a,' '
040635 5B D7       1036*      rst.lil 10h
040637 23          1037*      inc hl
040638 10 F4       1038*      djnz @loop
04063A CD 8C 00 04 1039*      call printNewLine
04063E             1040*  
04063E             1041*  ; restore everything
04063E F1          1042*      pop af
04063F E1          1043*      pop hl
040640 C1          1044*      pop bc
040641             1045*  
040641             1046*  ; all done
040641 C9          1047*      ret
040642             1048*  
040642             1049*  
040642             1050*  ; print bytes from an address to the screen in binary format
040642             1051*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1052*  ; outputs: values of each byte printed to screen separated by spaces
040642             1053*  ; destroys: nothing
040642             1054*  dumpMemoryBin:
040642             1055*  ; save all registers to the stack
040642 F5          1056*      push af
040643 C5          1057*      push bc
040644 D5          1058*      push de
040645 E5          1059*      push hl
040646 DD E5       1060*      push ix
040648 FD E5       1061*      push iy
04064A             1062*  
04064A             1063*  ; set b to be our loop counter
04064A 47          1064*      ld b,a
04064B             1065*  @loop:
04064B             1066*  ; print the byte
04064B 7E          1067*      ld a,(hl)
04064C E5          1068*      push hl
04064D C5          1069*      push bc
04064E CD 15 03 04 1070*      call printBin8
040652 C1          1071*      pop bc
040653             1072*  ; print a space
040653 3E 20       1073*      ld a,' '
040655 5B D7       1074*      rst.lil 10h
040657 E1          1075*      pop hl
040658 23          1076*      inc hl
040659 10 F0       1077*      djnz @loop
04065B CD 8C 00 04 1078*      call printNewLine
04065F             1079*  
04065F             1080*  ; restore everything
04065F FD E1       1081*      pop iy
040661 DD E1       1082*      pop ix
040663 E1          1083*      pop hl
040664 D1          1084*      pop de
040665 C1          1085*      pop bc
040666 F1          1086*      pop af
040667             1087*  ; all done
040667 C9          1088*      ret
040668             1089*  
040668             1090*  ; print bytes from an address to the screen in binary format
040668             1091*  ; with the bits of each byte in reverse order (lsb first)
040668             1092*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1093*  ; outputs: values of each byte printed to screen separated by spaces
040668             1094*  ; destroys: nothing
040668             1095*  dumpMemoryBinRev:
040668             1096*  ; save all registers to the stack
040668 F5          1097*      push af
040669 C5          1098*      push bc
04066A D5          1099*      push de
04066B E5          1100*      push hl
04066C DD E5       1101*      push ix
04066E FD E5       1102*      push iy
040670             1103*  
040670             1104*  ; set b to be our loop counter
040670 47          1105*      ld b,a
040671             1106*  @loop:
040671             1107*  ; print the byte
040671 7E          1108*      ld a,(hl)
040672 E5          1109*      push hl
040673 C5          1110*      push bc
040674 CD 3A 03 04 1111*      call printBin8Rev
040678 C1          1112*      pop bc
040679             1113*  ; print a space
040679 3E 20       1114*      ld a,' '
04067B 5B D7       1115*      rst.lil 10h
04067D E1          1116*      pop hl
04067E 23          1117*      inc hl
04067F 10 F0       1118*      djnz @loop
040681 CD 8C 00 04 1119*      call printNewLine
040685             1120*  
040685             1121*  ; restore everything
040685 FD E1       1122*      pop iy
040687 DD E1       1123*      pop ix
040689 E1          1124*      pop hl
04068A D1          1125*      pop de
04068B C1          1126*      pop bc
04068C F1          1127*      pop af
04068D             1128*  ; all done
04068D C9          1129*      ret
04068E             0028       include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*      add hl,de
04068E             0007*      or a
04068E             0008*      sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de ; save de
0406A5 EB          0045*      ex de,hl ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0 ; clear hl
0406AA AF          0047*      xor a ; clear carry
0406AB ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
0406AD D1          0049*      pop de ; get de back
0406AE C9          0050*      ret ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*      ld (scratch1),hl
0406B3 21 90 06 04 0057*      ld hl,scratch1+2
0406B7 CB 1E       0058*      rr (hl)
0406B9 2B          0059*      dec hl
0406BA CB 1E       0060*      rr (hl)
0406BC 2B          0061*      dec hl
0406BD CB 1E       0062*      rr (hl)
0406BF 23          0063*      inc hl
0406C0 23          0064*      inc hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M     add hl,de
0406E6 B7          0002*M     or a
0406E7 ED 52       0003*M     sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*      xor a
0406FC 32 0D 07 04 0105*      ld (@buffer+3),a
040700 7D          0106*      ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*      ld (@buffer),hl
040705 2A 0B 07 04 0108*      ld hl,(@buffer+1)
040709 C9          0109*      ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*      add hl,hl ; * 2
04070E             0114*      add hl,hl ; * 4
04070E             0115*      add hl,hl ; * 8
04070E             0116*      add hl,hl ; * 16
04070E             0117*      add hl,hl ; * 32
04070E             0118*      add hl,hl ; * 64
04070E             0119*      add hl,hl ; * 128
04070E             0120*      add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*      or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*      ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0029       include "files.inc"
040785             0001*  ; load to onboard 8k sram
040785             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
040785             0030       include "vdu.inc"
040785             0001*  
040785             0002*  ; VDU 30: Home cursor
040785             0003*  vdu_home_cursor:
040785 3E 1E       0004*      ld a,30
040787 5B D7       0005*  	rst.lil $10
040789 C9          0006*  	ret
04078A             0007*  
04078A             0008*  vdu_cursor_on:
04078A 21 95 07 04 0009*  	ld hl,@cmd
04078E 01 03 00 00 0010*  	ld bc,@end-@cmd
040792 5B DF       0011*  	rst.lil $18
040794 C9          0012*  	ret
040795             0013*  @cmd:
040795 17 01 01    0014*  	db 23,1,1
040798             0015*  @end:
040798             0016*  
040798             0017*  vdu_cursor_off:
040798 21 A3 07 04 0018*  	ld hl,@cmd
04079C 01 03 00 00 0019*  	ld bc,@end-@cmd
0407A0 5B DF       0020*  	rst.lil $18
0407A2 C9          0021*  	ret
0407A3             0022*  @cmd:
0407A3 17 01 00    0023*  	db 23,1,0
0407A6             0024*  @end:
0407A6             0025*  
0407A6             0026*  ; VDU 5: Write text at graphics cursor
0407A6             0027*  ; inputs: a is the character to write to the screen
0407A6             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0407A6             0029*  ; outputs: see the name of the function
0407A6             0030*  ; destroys: a, hl, bc
0407A6             0031*  vdu_char_to_gfx_cursor:
0407A6 32 B6 07 04 0032*  	ld (@arg),a
0407AA 21 B5 07 04 0033*  	ld hl,@cmd
0407AE 01 02 00 00 0034*  	ld bc,@end-@cmd
0407B2 5B DF       0035*  	rst.lil $18
0407B4 C9          0036*  	ret
0407B5 05          0037*  @cmd: db 5
0407B6 00          0038*  @arg: db 0
0407B7             0039*  @end:
0407B7             0040*  ; VDU 9: Move cursor forward one character
0407B7             0041*  vdu_cursor_forward:
0407B7 3E 09       0042*      ld a,9
0407B9 5B D7       0043*  	rst.lil $10
0407BB C9          0044*  	ret
0407BC             0045*  
0407BC             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0407BC             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0407BC             0048*  vdu_move_cursor:
0407BC ED 43 CD 07 0049*      ld (@x0),bc
       04          
0407C1 21 CC 07 04 0050*  	ld hl,@cmd
0407C5 01 03 00 00 0051*  	ld bc,@end-@cmd
0407C9 5B DF       0052*  	rst.lil $18
0407CB C9          0053*  	ret
0407CC 1F          0054*  @cmd: 	db 31
0407CD 00          0055*  @x0:	db 0
0407CE 00          0056*  @y0: 	db 0
0407CF 00          0057*  @end: 	db 0 ; padding
0407D0             0058*  
0407D0             0059*  ; VDU 12: Clear text area (CLS)
0407D0             0060*  vdu_cls:
0407D0 3E 0C       0061*      ld a,12
0407D2 5B D7       0062*  	rst.lil $10
0407D4 C9          0063*  	ret
0407D5             0064*  
0407D5             0065*  vdu_flip:
0407D5 21 E0 07 04 0066*  	ld hl,@cmd
0407D9 01 03 00 00 0067*  	ld bc,@end-@cmd
0407DD 5B DF       0068*  	rst.lil $18
0407DF C9          0069*  	ret
0407E0 17 00 C3    0070*  @cmd: db 23,0,0xC3
0407E3             0071*  @end:
0407E3             0072*  
0407E3             0073*  ; VDU 16: Clear graphics area (CLG)
0407E3             0074*  vdu_clg:
0407E3 3E 10       0075*      ld a,16
0407E5 5B D7       0076*  	rst.lil $10
0407E7 C9          0077*  	ret
0407E8             0078*  
0407E8             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0407E8             0080*  ; VDU 23, 7: Scrolling
0407E8             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0407E8             0082*  ; inputs: a, extent; l, direction; h; speed
0407E8             0083*  vdu_scroll_down:
0407E8 32 FD 07 04 0084*  	ld (@extent),a
0407EC 22 FE 07 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0407F0 21 FB 07 04 0086*  	ld hl,@cmd
0407F4 01 05 00 00 0087*  	ld bc,@end-@cmd
0407F8 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
0407FA C9          0089*  	ret
0407FB 17 07       0090*  @cmd:       db 23,7
0407FD 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0407FE 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0407FF 00          0093*  @speed:     db 0x00 ; pixels
040800 00          0094*  @end:		db 0x00 ; padding
040801             0095*  
040801             0096*  ; COLOUR MODES
040801             0097*  ; Mode	Effect
040801             0098*  ; 0	Set on-screen pixel to target colour value
040801             0099*  ; 1	OR value with the on-screen pixel
040801             0100*  ; 2	AND value with the on-screen pixel
040801             0101*  ; 3	XOR value with the on-screen pixel
040801             0102*  ; 4	Invert the on-screen pixel
040801             0103*  ; 5	No operation
040801             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
040801             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
040801             0106*  
040801             0107*  ; VDU 17, colour: Define text colour (COLOUR)
040801             0108*  vdu_colour_text:
040801 32 11 08 04 0109*  	ld (@arg),a
040805 21 10 08 04 0110*  	ld hl,@cmd
040809 01 02 00 00 0111*  	ld bc,@end-@cmd
04080D 5B DF       0112*  	rst.lil $18
04080F C9          0113*  	ret
040810 11          0114*  @cmd: db 17
040811 00          0115*  @arg: db 0
040812             0116*  @end:
040812             0117*  
040812             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
040812             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
040812             0120*  vdu_gcol:
040812 32 27 08 04 0121*  	ld (@mode),a
040816 79          0122*      ld a,c
040817 32 28 08 04 0123*      ld (@col),a
04081B 21 26 08 04 0124*  	ld hl,@cmd
04081F 01 03 00 00 0125*  	ld bc,@end-@cmd
040823 5B DF       0126*  	rst.lil $18
040825 C9          0127*  	ret
040826 12          0128*  @cmd:  db 18
040827 00          0129*  @mode: db 0
040828 00          0130*  @col:  db 0
040829             0131*  @end:
040829             0132*  
040829             0133*  
040829             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
040829             0135*  ; MIND THE LITTLE-ENDIANESS
040829             0136*  ; inputs: c=left,b=bottom,e=right,d=top
040829             0137*  ; outputs; nothing
040829             0138*  ; destroys: a might make it out alive
040829             0139*  vdu_set_txt_viewport:
040829 ED 43 3F 08 0140*      ld (@lb),bc
       04          
04082E ED 53 41 08 0141*  	ld (@rt),de
       04          
040833 21 3E 08 04 0142*  	ld hl,@cmd
040837 01 05 00 00 0143*  	ld bc,@end-@cmd
04083B 5B DF       0144*  	rst.lil $18
04083D C9          0145*  	ret
04083E 1C          0146*  @cmd:   db 28 ; set text viewport command
04083F 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
040841 00 00       0148*  @rt: 	dw 0x0000 ; set by de
040843 00          0149*  @end:   db 0x00	  ; padding
040844             0150*  
040844             0151*  ; Wait for VBLANK interrupt
040844             0152*  vdu_vblank:
040844 DD E5       0153*      PUSH 	IX
040846             0154*  	MOSCALL	mos_sysvars
040846 3E 08       0001*M 			LD	A, function
040848 5B CF       0002*M 			RST.LIL	08h
04084A DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
04084D             0156*  @wait:
04084D DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
040850 28 FB       0158*      JR	Z, @wait
040852 DD E1       0159*      POP	IX
040854 C9          0160*      RET
040855             0161*  
040855             0162*  ; VDU 29, x; y;: Set graphics origin
040855             0163*  ; This command sets the graphics origin.
040855             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
040855             0165*  ; inputs: bc=x0,de=y0
040855             0166*  ; outputs; nothing
040855             0167*  ; destroys: a might make it out alive
040855             0168*  vdu_set_gfx_origin:
040855 ED 43 6B 08 0169*      ld (@x0),bc
       04          
04085A ED 53 6D 08 0170*      ld (@y0),de
       04          
04085F 21 6A 08 04 0171*      ld hl,@cmd
040863 01 05 00 00 0172*      ld bc,@end-@cmd
040867 5B DF       0173*      rst.lil $18
040869 C9          0174*      ret
04086A 1D          0175*  @cmd:   db 29 ; set graphics origin command
04086B 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
04086D 00 00       0177*  @y0: 	dw 0x0000 ; set by de
04086F 00          0178*  @end:   db 0x00	  ; padding
040870             0179*  
040870             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040870             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
040870             0182*  ; 	because we have turned off logical screen scaling
040870             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040870             0184*  ; outputs; nothing
040870             0185*  ; destroys: a might make it out alive
040870             0186*  vdu_set_gfx_viewport:
040870 ED 43 90 08 0187*      ld (@x0),bc
       04          
040875 FD 22 92 08 0188*      ld (@y1),iy
       04          
04087A DD 22 94 08 0189*  	ld (@x1),ix
       04          
04087F ED 53 96 08 0190*  	ld (@y0),de
       04          
040884 21 8F 08 04 0191*  	ld hl,@cmd
040888 01 09 00 00 0192*  	ld bc,@end-@cmd
04088C 5B DF       0193*  	rst.lil $18
04088E C9          0194*  	ret
04088F 18          0195*  @cmd:   db 24 ; set graphics viewport command
040890 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
040892 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
040894 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
040896 00 00       0199*  @y0: 	dw 0x0000 ; set by de
040898 00          0200*  @end:   db 0x00	  ; padding
040899             0201*  
040899             0202*  ; SCREEN MODES
040899             0203*  ; ===============================
040899             0204*  ; Mode  Horz  Vert  Cols  Refresh
040899             0205*  ; ---   ----  ----  ----  -------
040899             0206*  ; 11    320   240   2     60hz
040899             0207*  ; 139   320   240   2     60hz
040899             0208*  ; 23    512   384   2     60hz
040899             0209*  ; 151   512   384   2     60hz
040899             0210*  ; 6     640   240   2     60hz
040899             0211*  ; 134   640   240   2     60hz
040899             0212*  ; 2     640   480   2     60hz
040899             0213*  ; 130   640   480   2     60hz
040899             0214*  ; 17    800   600   2     60hz
040899             0215*  ; 145   800   600   2     60hz
040899             0216*  ; 18    1024  768   2     60hz
040899             0217*  ; 146   1024  768   2     60hz
040899             0218*  ; ---   ----  ----  ----  -------
040899             0219*  ; 10    320   240   4     60hz
040899             0220*  ; 138   320   240   4     60hz
040899             0221*  ; 22    512   384   4     60hz
040899             0222*  ; 150   512   384   4     60hz
040899             0223*  ; 5     640   240   4     60hz
040899             0224*  ; 133   640   240   4     60hz
040899             0225*  ; 1     640   480   4     60hz
040899             0226*  ; 129   640   480   4     60hz
040899             0227*  ; 16    800   600   4     60hz
040899             0228*  ; 19    1024  768   4     60hz
040899             0229*  ; ---   ----  ----  ----  -------
040899             0230*  ; 9     320   240   16    60hz
040899             0231*  ; 137   320   240   16    60hz
040899             0232*  ; 21    512   384   16    60hz
040899             0233*  ; 149   512   384   16    60hz
040899             0234*  ; 4     640   240   16    60hz
040899             0235*  ; 132   640   240   16    60hz
040899             0236*  ; 0     640   480   16    60hz
040899             0237*  ; 7     n/a   n/a   16    60hz
040899             0238*  ; ---   ----  ----  ----  -------
040899             0239*  ; 8     320   240   64    60hz
040899             0240*  ; 136   320   240   64    60hz
040899             0241*  ; 20    512   384   64    60hz
040899             0242*  ; 3     640   240   64    60hz
040899             0243*  ; ---   ----  ----  ----  -------
040899             0244*  vdu_set_screen_mode:
040899 32 A9 08 04 0245*  	ld (@arg),a
04089D 21 A8 08 04 0246*  	ld hl,@cmd
0408A1 01 02 00 00 0247*  	ld bc,@end-@cmd
0408A5 5B DF       0248*  	rst.lil $18
0408A7 C9          0249*  	ret
0408A8 16          0250*  @cmd: db 22 ; set screen mode
0408A9 00          0251*  @arg: db 0  ; screen mode parameter
0408AA             0252*  @end:
0408AA             0253*  
0408AA             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0408AA             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0408AA             0256*  ; note: default setting on boot is scaling ON
0408AA             0257*  vdu_set_scaling:
0408AA 32 BC 08 04 0258*  	ld (@arg),a
0408AE 21 B9 08 04 0259*  	ld hl,@cmd
0408B2 01 04 00 00 0260*  	ld bc,@end-@cmd
0408B6 5B DF       0261*  	rst.lil $18
0408B8 C9          0262*  	ret
0408B9 17 00 C0    0263*  @cmd: db 23,0,0xC0
0408BC 00          0264*  @arg: db 0  ; scaling on/off
0408BD             0265*  @end:
0408BD             0266*  
0408BD             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0408BD             0268*  ; inputs: hl=bufferId
0408BD             0269*  vdu_buff_select:
0408BD 22 CF 08 04 0270*  	ld (@bufferId),hl
0408C1 21 CC 08 04 0271*  	ld hl,@cmd
0408C5 01 05 00 00 0272*  	ld bc,@end-@cmd
0408C9 5B DF       0273*  	rst.lil $18
0408CB C9          0274*  	ret
0408CC 17 1B 20    0275*  @cmd: db 23,27,0x20
0408CF 00 00       0276*  @bufferId: dw 0x0000
0408D1 00          0277*  @end: db 0x00 ; padding
0408D2             0278*  
0408D2             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0408D2             0280*  ; inputs: a=format; bc=width; de=height
0408D2             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0408D2             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0408D2             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0408D2             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0408D2             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0408D2             0286*  ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
0408D2             0287*  vdu_bmp_create:
0408D2 ED 43 EE 08 0288*      ld (@width),bc
       04          
0408D7 ED 53 F0 08 0289*      ld (@height),de
       04          
0408DC 32 F2 08 04 0290*      ld (@fmt),a
0408E0 21 EB 08 04 0291*  	ld hl,@cmd
0408E4 01 08 00 00 0292*  	ld bc,@end-@cmd
0408E8 5B DF       0293*  	rst.lil $18
0408EA C9          0294*  	ret
0408EB 17 1B 21    0295*  @cmd:       db 23,27,0x21
0408EE 00 00       0296*  @width:     dw 0x0000
0408F0 00 00       0297*  @height:    dw 0x0000
0408F2 00          0298*  @fmt:       db 0x00
0408F3             0299*  @end:
0408F3             0300*  
0408F3             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0408F3             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0408F3             0303*  vdu_load_img_rgba2_to_8:
0408F3             0304*  ; backup the target buffer id and image dimensions
0408F3 E5          0305*      push hl
0408F4 D5          0306*      push de
0408F5 C5          0307*      push bc
0408F6             0308*  ; load the rgba2 image to working buffer 65534
0408F6 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
0408FA CD FD 09 04 0310*  	call vdu_load_buffer_from_file
0408FE             0311*  ; restore the image dimensions and target buffer id
0408FE C1          0312*      pop bc
0408FF D1          0313*      pop de
040900 E1          0314*      pop hl
040901             0315*  ; fall through to vdu_rgba2_to_8
040901             0316*  
040901             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
040901             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
040901             0319*  ; the "expand bitmap" command is:
040901             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040901             0321*  ; and then to reverse the byte order to fix endian-ness:
040901             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040901             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040901             0324*  ; VDU 23,27,&20,targetBufferID%;
040901             0325*  ; VDU 23,27,&21,width%;height%;0
040901             0326*  ; -------------------------------------------------------------------
040901             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
040901             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
040901             0329*  vdu_rgba2_to_8:
040901             0330*  ; load the image dimensions and buffer id parameters
040901 ED 43 5D 09 0331*      ld (@width),bc
       04          
040906 ED 53 5F 09 0332*      ld (@height),de
       04          
04090B 22 42 09 04 0333*      ld (@bufferId0),hl
04090F 22 4F 09 04 0334*      ld (@bufferId2),hl
040913 22 58 09 04 0335*      ld (@bufferId1),hl
040917             0336*  ; clean up bytes that got stomped on by the ID loads
040917 3E 48       0337*      ld a,0x48
040919 32 44 09 04 0338*      ld (@bufferId0+2),a
04091D 3E 17       0339*      ld a,23
04091F 32 5A 09 04 0340*      ld (@bufferId1+2),a
040923 3E 18       0341*      ld a,24
040925 32 51 09 04 0342*      ld (@bufferId2+2),a
040929 AF          0343*      xor a
04092A 32 61 09 04 0344*      ld (@height+2),a
04092E             0345*  ; send the vdu command strings
04092E 21 39 09 04 0346*      ld hl,@beg
040932 01 29 00 00 0347*      ld bc,@end-@beg
040936 5B DF       0348*      rst.lil $18
040938 C9          0349*      ret
040939             0350*  @beg:
040939             0351*  ; Command 14: Consolidate blocks in a buffer
040939             0352*  ; VDU 23, 0, &A0, bufferId; 14
040939 17 00 A0    0353*      db 23,0,0xA0
04093C FE FF       0354*      dw 65534 ; workingBufferId
04093E 0E          0355*      db 14 ; consolidate blocks
04093F             0356*  ; the "expand bitmap" command is:
04093F             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04093F 17 00 A0    0358*      db 23,0,0xA0
040942 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
040944 48          0360*      db 0x48 ; given as decimal command 72 in the docs
040945 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
040946 FE FF       0362*      dw 65534 ; sourceBufferId
040948 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04094C             0364*  ; reverse the byte order to fix endian-ness:
04094C             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
04094C             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04094C             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04094C 17 00 A0    0368*      db 23,0,0xA0
04094F 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
040951 18          0370*      db 24 ; reverse byte order
040952 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
040953 04 00       0372*      dw 4 ; size (4 bytes)
040955             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040955             0374*  ; VDU 23,27,&20,targetBufferID%;
040955 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
040958 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
04095A             0377*  ; VDU 23,27,&21,width%;height%;0
04095A 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
04095D 00 00       0379*  @width: dw 0x0000
04095F 00 00       0380*  @height: dw 0x0000
040961 00          0381*      db 0x00 ; rgba8888 format
040962             0382*  @end:
040962             0383*  
040962             0384*  ; scratch variables
040962 00 00 00    0385*  bufferId0: dl 0x000000
040965 00 00 00    0386*  bufferId1: dl 0x000000
040968             0387*  
040968             0388*  ; load a vdu buffer from local memory
040968             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040968             0390*  vdu_load_buffer:
040968 ED 43 91 09 0391*      ld (@length),bc
       04          
04096D D5          0392*      push de ; save data pointer
04096E             0393*  ; send the vdu command string
04096E 7D          0394*      ld a,l
04096F 32 8E 09 04 0395*      ld (@bufferId),a
040973 7C          0396*      ld a,h
040974 32 8F 09 04 0397*      ld (@bufferId+1),a
040978 21 8B 09 04 0398*      ld hl,@cmd
04097C 01 08 00 00 0399*      ld bc,@end-@cmd
040980 5B DF       0400*      rst.lil $18
040982             0401*  ; send the buffer data
040982 E1          0402*      pop hl ; pointer to data
040983 ED 4B 91 09 0403*      ld bc,(@length)
       04          
040988 5B DF       0404*      rst.lil $18 ; send it
04098A C9          0405*      ret
04098B             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04098B 17 00 A0    0407*  @cmd:       db 23,0,0xA0
04098E 00 00       0408*  @bufferId:	dw 0x0000
040990 00          0409*  		    db 0 ; load buffer
040991 00 00       0410*  @length:	dw 0x0000
040993 00          0411*  @end: db 0 ; padding
040994             0412*  
040994             0413*  ; clear a buffer
040994             0414*  ; inputs: hl = bufferId
040994             0415*  vdu_clear_buffer:
040994 7D          0416*      ld a,l
040995 32 AC 09 04 0417*      ld (@bufferId),a
040999 7C          0418*      ld a,h
04099A 32 AD 09 04 0419*      ld (@bufferId+1),a
04099E 21 A9 09 04 0420*      ld hl,@cmd
0409A2 01 06 00 00 0421*      ld bc,@end-@cmd
0409A6 5B DF       0422*      rst.lil $18
0409A8 C9          0423*      ret
0409A9 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0409AC 00 00       0425*  @bufferId:	dw 0x0000
0409AE 02          0426*  		    db 2 ; clear buffer
0409AF             0427*  @end:
0409AF             0428*  
0409AF             0429*  vdu_clear_all_buffers:
0409AF             0430*  ; clear all buffers
0409AF 21 BA 09 04 0431*      ld hl,@beg
0409B3 01 06 00 00 0432*      ld bc,@end-@beg
0409B7 5B DF       0433*      rst.lil $18
0409B9 C9          0434*      ret
0409BA 17 00 A0    0435*  @beg: db 23,0,$A0
0409BD FF FF       0436*        dw -1 ; clear all buffers
0409BF 02          0437*        db 2  ; command 2: clear a buffer
0409C0             0438*  @end:
0409C0             0439*  
0409C0             0440*  ; Command 14: Consolidate blocks in a buffer
0409C0             0441*  vdu_consolidate_buffer:
0409C0             0442*  ; set parameters for vdu call
0409C0 7D          0443*      ld a,l
0409C1 32 D8 09 04 0444*      ld (@bufferId),a
0409C5 7C          0445*      ld a,h
0409C6 32 D9 09 04 0446*      ld (@bufferId+1),a
0409CA 21 D5 09 04 0447*      ld hl,@beg
0409CE 01 06 00 00 0448*      ld bc,@end-@beg
0409D2 5B DF       0449*      rst.lil $18
0409D4 C9          0450*      ret
0409D5             0451*  ; VDU 23, 0, &A0, bufferId; 14
0409D5 17 00 A0    0452*  @beg: db 23,0,0xA0
0409D8 00 00       0453*  @bufferId: dw 0x0000
0409DA 0E          0454*             db 14
0409DB             0455*  @end:
0409DB             0456*  
0409DB             0457*  ; load an image file to a buffer and make it a bitmap
0409DB             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0409DB             0459*  vdu_load_img:
0409DB             0460*  ; back up image type and dimension parameters
0409DB 22 62 09 04 0461*      ld (bufferId0),hl
0409DF F5          0462*      push af
0409E0 C5          0463*  	push bc
0409E1 D5          0464*  	push de
0409E2             0465*  ; load the image
0409E2 CD FD 09 04 0466*  	call vdu_load_buffer_from_file
0409E6             0467*  ; now make it a bitmap
0409E6 2A 62 09 04 0468*      ld hl,(bufferId0)
0409EA CD C0 09 04 0469*      call vdu_consolidate_buffer
0409EE 2A 62 09 04 0470*      ld hl,(bufferId0)
0409F2 CD BD 08 04 0471*      call vdu_buff_select
0409F6 D1          0472*  	pop de ; image height
0409F7 C1          0473*  	pop bc ; image width
0409F8 F1          0474*  	pop af ; image type
0409F9 C3 D2 08 04 0475*  	jp vdu_bmp_create ; will return to caller from there
0409FD             0476*  
0409FD             0477*  ; inputs: hl = bufferId; iy = pointer to filename
0409FD             0478*  vdu_load_buffer_from_file:
0409FD 22 62 09 04 0479*      ld (bufferId0),hl
040A01             0480*  
040A01             0481*  ; clear target buffer
040A01 CD 94 09 04 0482*      call vdu_clear_buffer
040A05             0483*  
040A05             0484*  ; open the file in read mode
040A05             0485*  ; Open a file
040A05             0486*  ; HLU: Filename
040A05             0487*  ;   C: Mode
040A05             0488*  ; Returns:
040A05             0489*  ;   A: Filehandle, or 0 if couldn't open
040A05 FD E5       0490*  	push iy ; pointer to filename
040A07 E1          0491*  	pop hl
040A08 0E 01       0492*  	ld c,fa_read
040A0A             0493*      MOSCALL mos_fopen
040A0A 3E 0A       0001*M 			LD	A, function
040A0C 5B CF       0002*M 			RST.LIL	08h
040A0E 32 49 0A 04 0494*      ld (@filehandle),a
040A12             0495*  
040A12             0496*  @read_file:
040A12             0497*  ; Read a block of data from a file
040A12             0498*  ;   C: Filehandle
040A12             0499*  ; HLU: Pointer to where to write the data to
040A12             0500*  ; DEU: Number of bytes to read
040A12             0501*  ; Returns:
040A12             0502*  ; DEU: Number of bytes read
040A12 3A 49 0A 04 0503*      ld a,(@filehandle)
040A16 4F          0504*      ld c,a
040A17 21 00 E0 B7 0505*      ld hl,filedata
040A1B 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
040A1F             0507*      MOSCALL mos_fread
040A1F 3E 1A       0001*M 			LD	A, function
040A21 5B CF       0002*M 			RST.LIL	08h
040A23             0508*  
040A23             0509*  ; test de for zero bytes read
040A23 21 00 00 00 0510*      ld hl,0
040A27 AF          0511*      xor a ; clear carry
040A28 ED 52       0512*      sbc hl,de
040A2A CA 40 0A 04 0513*      jp z,@close_file
040A2E             0514*  
040A2E             0515*  ; load a vdu buffer from local memory
040A2E             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040A2E 2A 62 09 04 0517*      ld hl,(bufferId0)
040A32 D5          0518*      push de ; chunksize
040A33 C1          0519*      pop bc
040A34 11 00 E0 B7 0520*      ld de,filedata
040A38 CD 68 09 04 0521*      call vdu_load_buffer
040A3C             0522*  
040A3C             0523*  ; read the next block
040A3C C3 12 0A 04 0524*      jp @read_file
040A40             0525*  
040A40             0526*  ; close the file
040A40             0527*  @close_file:
040A40 3A 49 0A 04 0528*      ld a,(@filehandle)
040A44             0529*      MOSCALL mos_fclose
040A44 3E 0B       0001*M 			LD	A, function
040A46 5B CF       0002*M 			RST.LIL	08h
040A48 C9          0530*      ret ; vdu_load_buffer_from_file
040A49             0531*  
040A49 00          0532*  @filehandle: db 0 ; file handle
040A4A 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
040A4D             0534*  
040A4D 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
040A50             0536*  
040A50             0537*  ; File information structure (FILINFO)
040A50             0538*  @filinfo:
040A50 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
040A54 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
040A56 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040A58 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040A59 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
040A66 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B66             0031       include "vdu_plot.inc"
040B66             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040B66             0002*  ; PLOT code 	(Decimal) 	Effect
040B66             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
040B66             0004*  plot_sl_both: equ 0x00
040B66             0005*  
040B66             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
040B66             0007*  plot_sl_first: equ 0x08
040B66             0008*  
040B66             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
040B66             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
040B66             0011*  
040B66             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
040B66             0013*  plot_sl_last: equ 0x20
040B66             0014*  
040B66             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
040B66             0016*  plot_sl_none: equ 0x28
040B66             0017*  
040B66             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
040B66             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
040B66             0020*  
040B66             0021*  ; &40-&47 	64-71 	Point plot
040B66             0022*  plot_pt: equ 0x40
040B66             0023*  
040B66             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
040B66             0025*  plot_lf_lr_non_bg: equ 0x48
040B66             0026*  
040B66             0027*  ; &50-&57 	80-87 	Triangle fill
040B66             0028*  plot_tf: equ 0x50
040B66             0029*  
040B66             0030*  ; &58-&5F 	88-95 	Line fill right to background Â§Â§
040B66             0031*  plot_lf_r_bg: equ 0x58
040B66             0032*  
040B66             0033*  ; &60-&67 	96-103 	Rectangle fill
040B66             0034*  plot_rf: equ 0x60
040B66             0035*  
040B66             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
040B66             0037*  plot_lf_lr_fg: equ 0x60
040B66             0038*  
040B66             0039*  ; &70-&77 	112-119 	Parallelogram fill
040B66             0040*  plot_pf: equ 0x70
040B66             0041*  
040B66             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
040B66             0043*  plot_lf_r_non_fg: equ 0x78
040B66             0044*  
040B66             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
040B66             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
040B66             0047*  
040B66             0048*  ; &90-&97 	144-151 	Circle outline
040B66             0049*  plot_co: equ 0x90
040B66             0050*  
040B66             0051*  ; &98-&9F 	152-159 	Circle fill
040B66             0052*  plot_cf: equ 0x98
040B66             0053*  
040B66             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
040B66             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
040B66             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
040B66             0057*  
040B66             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
040B66             0059*  plot_rcm: equ 0xB8
040B66             0060*  
040B66             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
040B66             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
040B66             0063*  ; &D0-&D7 	208-215 	Not defined
040B66             0064*  ; &D8-&DF 	216-223 	Not defined
040B66             0065*  ; &E0-&E7 	224-231 	Not defined
040B66             0066*  
040B66             0067*  ; &E8-&EF 	232-239 	Bitmap plot Â§
040B66             0068*  plot_bmp: equ 0xE8
040B66             0069*  
040B66             0070*  ; &F0-&F7 	240-247 	Not defined
040B66             0071*  ; &F8-&FF 	248-255 	Not defined
040B66             0072*  
040B66             0073*  ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
040B66             0074*  ; Agon Console8 VDP 2.2.0
040B66             0075*  
040B66             0076*  ; Within each group of eight plot codes, the effects are as follows:
040B66             0077*  ; Plot code 	Effect
040B66             0078*  ; 0 	Move relative
040B66             0079*  mv_rel: equ 0
040B66             0080*  
040B66             0081*  ; 1 	Plot relative in current foreground colour
040B66             0082*  dr_rel_fg: equ 1
040B66             0083*  
040B66             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
040B66             0085*  ; 3 	Plot relative in current background colour
040B66             0086*  dr_rel_bg: equ 3
040B66             0087*  
040B66             0088*  ; 4 	Move absolute
040B66             0089*  mv_abs: equ 4
040B66             0090*  
040B66             0091*  ; 5 	Plot absolute in current foreground colour
040B66             0092*  dr_abs_fg: equ 5
040B66             0093*  
040B66             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
040B66             0095*  ; 7 	Plot absolute in current background colour
040B66             0096*  dr_abs_bg: equ 7
040B66             0097*  
040B66             0098*  ; Codes 0-3 use the position data provided as part of the command
040B66             0099*  ; as a relative position, adding the position given to the current
040B66             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
040B66             0101*  ; as part of the command as an absolute position, setting the current
040B66             0102*  ; graphical cursor position to the position given.
040B66             0103*  
040B66             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
040B66             0105*  ; current pixel colour. These operations cannot currently be supported
040B66             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
040B66             0107*  ; supported. Support for these codes may be added in a future version
040B66             0108*  ; of the VDP firmware.
040B66             0109*  
040B66             0110*  ; 16 colour palette constants
040B66             0111*  c_black: equ 0
040B66             0112*  c_red_dk: equ 1
040B66             0113*  c_green_dk: equ 2
040B66             0114*  c_yellow_dk: equ 3
040B66             0115*  c_blue_dk: equ 4
040B66             0116*  c_magenta_dk: equ 5
040B66             0117*  c_cyan_dk: equ 6
040B66             0118*  c_grey: equ 7
040B66             0119*  c_grey_dk: equ 8
040B66             0120*  c_red: equ 9
040B66             0121*  c_green: equ 10
040B66             0122*  c_yellow: equ 11
040B66             0123*  c_blue: equ 12
040B66             0124*  c_magenta: equ 13
040B66             0125*  c_cyan: equ 14
040B66             0126*  c_white: equ 15
040B66             0127*  
040B66             0128*  ; VDU 25, mode, x; y;: PLOT command
040B66             0129*  ; inputs: a=mode, bc=x0, de=y0
040B66             0130*  vdu_plot:
040B66 32 80 0B 04 0131*      ld (@mode),a
040B6A ED 43 81 0B 0132*      ld (@x0),bc
       04          
040B6F ED 53 83 0B 0133*      ld (@y0),de
       04          
040B74 21 7F 0B 04 0134*  	ld hl,@cmd
040B78 01 06 00 00 0135*  	ld bc,@end-@cmd
040B7C 5B DF       0136*  	rst.lil $18
040B7E C9          0137*  	ret
040B7F 19          0138*  @cmd:   db 25
040B80 00          0139*  @mode:  db 0
040B81 00 00       0140*  @x0: 	dw 0
040B83 00 00       0141*  @y0: 	dw 0
040B85 00          0142*  @end:   db 0 ; extra byte to soak up deu
040B86             0143*  
040B86             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040B86             0145*  ; &E8-&EF 	232-239 	Bitmap plot Â§
040B86             0146*  ; VDU 25, mode, x; y;: PLOT command
040B86             0147*  ; inputs: bc=x0, de=y0
040B86             0148*  ; prerequisites: vdu_buff_select
040B86             0149*  vdu_plot_bmp:
040B86 ED 43 9D 0B 0150*      ld (@x0),bc
       04          
040B8B ED 53 9F 0B 0151*      ld (@y0),de
       04          
040B90 21 9B 0B 04 0152*  	ld hl,@cmd
040B94 01 06 00 00 0153*  	ld bc,@end-@cmd
040B98 5B DF       0154*  	rst.lil $18
040B9A C9          0155*  	ret
040B9B 19          0156*  @cmd:   db 25
040B9C ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040B9D 00 00       0158*  @x0: 	dw 0x0000
040B9F 00 00       0159*  @y0: 	dw 0x0000
040BA1 00          0160*  @end:   db 0x00 ; padding
040BA2             0161*  
040BA2             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040BA2             0163*  ; &E8-&EF 	232-239 	Bitmap plot Â§
040BA2             0164*  ; VDU 25, mode, x; y;: PLOT command
040BA2             0165*  ; inputs: bc=x0, de=y0
040BA2             0166*  ; USING 16.8 FIXED POINT COORDINATES
040BA2             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040BA2             0168*  ;   the fractional portiion of the inputs are truncated
040BA2             0169*  ;   leaving only the 16-bit integer portion
040BA2             0170*  ; prerequisites: vdu_buff_select
040BA2             0171*  vdu_plot_bmp168:
040BA2             0172*  ; populate in the reverse of normal to keep the
040BA2             0173*  ; inputs from stomping on each other
040BA2 ED 53 C0 0B 0174*      ld (@y0-1),de
       04          
040BA7 ED 43 BE 0B 0175*      ld (@x0-1),bc
       04          
040BAC 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
040BAE 32 BE 0B 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040BB2 21 BD 0B 04 0178*  	ld hl,@cmd
040BB6 01 06 00 00 0179*  	ld bc,@end-@cmd
040BBA 5B DF       0180*  	rst.lil $18
040BBC C9          0181*  	ret
040BBD 19          0182*  @cmd:   db 25
040BBE ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040BBF 00 00       0184*  @x0: 	dw 0x0000
040BC1 00 00       0185*  @y0: 	dw 0x0000
040BC3             0186*  @end:  ; no padding required b/c we shifted de right
040BC3             0187*  
040BC3             0188*  ; draw a filled rectangle
040BC3             0189*  vdu_plot_rf:
040BC3 ED 43 EA 0B 0190*      ld (@x0),bc
       04          
040BC8 ED 53 EC 0B 0191*      ld (@y0),de
       04          
040BCD DD 22 F0 0B 0192*      ld (@x1),ix
       04          
040BD2 FD 22 F2 0B 0193*      ld (@y1),iy
       04          
040BD7 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
040BD9 32 EE 0B 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040BDD 21 E8 0B 04 0196*  	ld hl,@cmd0
040BE1 01 0C 00 00 0197*  	ld bc,@end-@cmd0
040BE5 5B DF       0198*  	rst.lil $18
040BE7 C9          0199*      ret
040BE8 19          0200*  @cmd0:  db 25 ; plot
040BE9 04          0201*  @arg0:  db plot_sl_both+mv_abs
040BEA 00 00       0202*  @x0:    dw 0x0000
040BEC 00 00       0203*  @y0:    dw 0x0000
040BEE 19          0204*  @cmd1:  db 25 ; plot
040BEF 65          0205*  @arg1:  db plot_rf+dr_abs_fg
040BF0 00 00       0206*  @x1:    dw 0x0000
040BF2 00 00       0207*  @y1:    dw 0x0000
040BF4 00          0208*  @end:   db 0x00 ; padding
040BF5             0209*  
040BF5             0210*  ; draw a filled circle
040BF5             0211*  vdu_plot_cf:
040BF5 ED 43 1C 0C 0212*      ld (@x0),bc
       04          
040BFA ED 53 1E 0C 0213*      ld (@y0),de
       04          
040BFF DD 22 22 0C 0214*      ld (@x1),ix
       04          
040C04 FD 22 24 0C 0215*      ld (@y1),iy
       04          
040C09 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
040C0B 32 20 0C 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040C0F 21 1A 0C 04 0218*  	ld hl,@cmd0
040C13 01 0C 00 00 0219*  	ld bc,@end-@cmd0
040C17 5B DF       0220*  	rst.lil $18
040C19 C9          0221*      ret
040C1A 19          0222*  @cmd0:  db 25 ; plot
040C1B 04          0223*  @arg0:  db plot_sl_both+mv_abs
040C1C 00 00       0224*  @x0:    dw 0x0000
040C1E 00 00       0225*  @y0:    dw 0x0000
040C20 19          0226*  @cmd1:  db 25 ; plot
040C21 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
040C22 00 00       0228*  @x1:    dw 0x0000
040C24 00 00       0229*  @y1:    dw 0x0000
040C26 00          0230*  @end:   db 0x00 ; padding
040C27             0032   
040C27             0033   ; APPLICATION INCLUDES
040C27             0034       macro get_label name
040C27             0035           ld hl,name
040C27             0036       endmacro
040C27             0037   
040C27             0038   ; --- INITIALIZATION ---
040C27             0039   init:
040C27             0040   
040C27 C9          0041       ret
040C28             0042   
040C28             0043   ; --- MAIN PROGRAM ---
040C28             0044   main:
040C28             0045       get_label some_label
040C28 21 35 0C 04 0001M          ld hl,name
040C2C CD 77 00 04 0046       call printString
040C30 CD 8C 00 04 0047       call printNewLine
040C34 C9          0048       ret
040C35             0049   
040C35 73 6F 6D 65 0050   some_label: asciz "some string"
       20 73 74 72 
       69 6E 67 00 
040C41             0051   
040C41             0052   tbl0.field0.s: equ 1
040C41             0053   tbl0.field1.s: equ 3
040C41             0054   tbl0.field2.s: equ 6
040C41             0055   tbl0.field3.s: equ 3
040C41             0056   tbl0.field4.s: equ 1
040C41             0057   
040C41             0058   tbl0.field0: equ 0
040C41             0059   tbl0.field1: equ tbl0.field0.s
040C41             0060   tbl0.field2: equ tbl0.field1 + tbl0.field1.s
040C41             0061   tbl0.field3: equ tbl0.field2 + tbl0.field2.s
040C41             0062   tbl0.field4: equ tbl0.field3 + tbl0.field3.s
040C41             0063   
040C41             0064   tbl0.struct:
040C41 00          0065       blkb tbl0.field0.s,0 ; field0
040C42 00 00 00    0066       blkb tbl0.field1.s,0 ; field1
040C45 00 00 00 00 0067       blkb tbl0.field2.s,0 ; field2
       00 00       
040C4B 00 00 00    0068       blkb tbl0.field3.s,0 ; field3
040C4E 00          0069       blkb tbl0.field4.s,0 ; field4
