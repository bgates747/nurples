PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD E2 48 04 0030   	call	init			; Initialization code
040050 CD B4 49 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041842             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041842             0033*  
041842             0034*  ; pointer to top address of current record, initialized to table_base
041842 E2 15 04    0035*  table_pointer: dl table_base
041845             0036*  ; how many active sprites
041845 00          0037*  table_active_sprites: db 0x00
041846             0038*  ; flag indicating collision with screen edge
041846             0039*  ; uses orientation codes to specify which edge(s)
041846 00          0040*  sprite_screen_edge: db #00
041847             0041*  ; next sprite id to use
041847 00          0042*  sprite_next_id: db 0
041848             0043*  
041848             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041848             0045*  ; integer coordinates are all that are needed for collision calculations
041848 00          0046*  collision_x: db 0x00
041849 00          0047*  collision_y: db 0x00
04184A 00          0048*  collision_dim_x: db 0x00
04184B 00          0049*  collision_dim_y: db 0x00
04184C             0050*  
04184C             0051*  ; scratch variables
04184C 00          0052*  x: db 0x00 ; 8-bit signed integer
04184D 00          0053*  y: db 0x00 ; 8-bit signed integer
04184E 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041851 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
041854 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
041857 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
04185A 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
04185D 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041860             0060*  
041860             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041860 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041863 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
041866 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
041869             0065*  
041869             0066*  ; gets the next available sprite id
041869             0067*  ; inputs; none
041869             0068*  ; returns: if new sprite available, a = sprite id,
041869             0069*  ;           ix pointing to new sprite vars, carry set
041869             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
041869             0071*  ; destroys: a,b,hl,ix
041869             0072*  ; affects: bumps table_active_sprites by one
041869             0073*  table_get_next_id:
041869 DD 21 E2 15 0074*      ld ix,table_base
       04          
04186E 11 26 00 00 0075*      ld de,table_bytes_per_record
041872 06 10       0076*      ld b,table_max_records
041874             0077*  @loop:
041874 DD 7E 01    0078*      ld a,(ix+sprite_type)
041877 A7          0079*      and a
041878 28 06       0080*      jr z,@found
04187A DD 19       0081*      add ix,de
04187C 10 F6       0082*      djnz @loop
04187E             0083*  @notfound:
04187E AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
04187F C9          0085*      ret
041880             0086*  @found:
041880             0087*  ; bump number of active sprites
041880 21 45 18 04 0088*      ld hl,table_active_sprites
041884 34          0089*      inc (hl)
041885             0090*  ; return sprite id
041885 3E 10       0091*      ld a,table_max_records
041887 90          0092*      sub b
041888 32 47 18 04 0093*      ld (sprite_next_id),a
04188C 37          0094*      scf ; sets carry flag indicating we found a free sprite
04188D C9          0095*      ret ; done
04188E             0096*  
04188E             0097*  ; deactivate the sprite with the given id
04188E             0098*  ; inputs: a = sprite id
04188E             0099*  ; outputs: nothing
04188E             0100*  ; destroys: a,ix,de
04188E             0101*  ; affects: decrements table_active_sprites by one
04188E             0102*  table_deactivate_sprite:
04188E F5          0103*      push af ; save sprite id bc we need it later
04188F CD C6 23 04 0104*      call vdu_sprite_select
041893 CD 4A 24 04 0105*      call vdu_sprite_hide
041897 F1          0106*      pop af ; restore sprite id
041898 11 00 00 00 0107*      ld de,0 ; clear deu
04189C 57          0108*      ld d,a
04189D 1E 26       0109*      ld e,table_bytes_per_record
04189F ED 5C       0110*      mlt de
0418A1 DD 21 E2 15 0111*      ld ix,table_base
       04          
0418A6 DD 19       0112*      add ix,de
0418A8 AF          0113*      xor a
0418A9 DD 77 01    0114*      ld (ix+sprite_type),a
0418AC DD 21 45 18 0115*      ld ix,table_active_sprites
       04          
0418B1 DD 35 00    0116*      dec (ix)
0418B4 C9          0117*      ret
0418B5             0118*  
0418B5             0119*  sprites_init:
0418B5             0120*  ; initialize sprites
0418B5 CD FA 24 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0418B9 AF          0122*  	xor a
0418BA             0123*  @sprite_loop:
0418BA F5          0124*  	push af
0418BB CD C6 23 04 0125*  	call vdu_sprite_select
0418BF 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0418C3 CD 1B 25 04 0127*  	call vdu_sprite_add_buff
0418C7 F1          0128*  	pop af
0418C8 3C          0129*  	inc a
0418C9 FE 12       0130*  	cp table_max_records+2 ; tack on sprites for player and laser
0418CB 20 ED       0131*  	jr nz,@sprite_loop
0418CD 3C          0132*  	inc a
0418CE CD FA 23 04 0133*  	call vdu_sprite_activate
0418D2             0134*  
0418D2             0135*  ; define player sprite
0418D2 3A 45 30 04 0136*  	ld a,(player_id)
0418D6 CD C6 23 04 0137*  	call vdu_sprite_select
0418DA CD D9 23 04 0138*  	call vdu_sprite_clear_frames
0418DE 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0418E2 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0418E6             0141*  @sprite_player_loop:
0418E6 C5          0142*  	push bc
0418E7 E5          0143*  	push hl
0418E8 CD 1B 25 04 0144*  	call vdu_sprite_add_buff
0418EC E1          0145*  	pop hl
0418ED 23          0146*  	inc hl
0418EE C1          0147*  	pop bc
0418EF 10 F5       0148*  	djnz @sprite_player_loop
0418F1 CD 3C 24 04 0149*  	call vdu_sprite_show
0418F5             0150*  
0418F5             0151*  ; all done
0418F5 C9          0152*      ret
0418F6             0050   ; API includes
0418F6             0051       include "mos_api.inc"
0418F6             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0418F6             0002*  ; Title:	AGON MOS - API for user projects
0418F6             0003*  ; Author:	Dean Belfield
0418F6             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0418F6             0005*  ;			Added MOS error codes for return in HL
0418F6             0006*  ; Created:	03/08/2022
0418F6             0007*  ; Last Updated:	10/08/2023
0418F6             0008*  ;
0418F6             0009*  ; Modinfo:
0418F6             0010*  ; 05/08/2022:	Added mos_feof
0418F6             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0418F6             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0418F6             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0418F6             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0418F6             0015*  ; 13/10/2022:	Added mos_oscli
0418F6             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0418F6             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0418F6             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0418F6             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0418F6             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0418F6             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0418F6             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0418F6             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0418F6             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0418F6             0025*  ; 19/05/2023:	Added sysvar_scrMode
0418F6             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0418F6             0027*  ; 03/08/2023:	Added mos_setkbvector
0418F6             0028*  ; 10/08/2023:	Added mos_getkbmap
0418F6             0029*  
0418F6             0030*  ; VDP control (VDU 23, 0, n)
0418F6             0031*  ;
0418F6             0032*  vdp_gp:				EQU 80h
0418F6             0033*  vdp_keycode:		EQU 81h
0418F6             0034*  vdp_cursor:			EQU	82h
0418F6             0035*  vdp_scrchar:		EQU	83h
0418F6             0036*  vdp_scrpixel:		EQU	84h
0418F6             0037*  vdp_audio:			EQU	85h
0418F6             0038*  vdp_mode:			EQU	86h
0418F6             0039*  vdp_rtc:			EQU	87h
0418F6             0040*  vdp_keystate:		EQU	88h
0418F6             0041*  vdp_logicalcoords:	EQU	C0h
0418F6             0042*  vdp_terminalmode:	EQU	FFh
0418F6             0043*  
0418F6             0044*  ; MOS high level functions
0418F6             0045*  ;
0418F6             0046*  mos_getkey:			EQU	00h
0418F6             0047*  mos_load:			EQU	01h
0418F6             0048*  mos_save:			EQU	02h
0418F6             0049*  mos_cd:				EQU	03h
0418F6             0050*  mos_dir:			EQU	04h
0418F6             0051*  mos_del:			EQU	05h
0418F6             0052*  mos_ren:			EQU	06h
0418F6             0053*  mos_mkdir:			EQU	07h
0418F6             0054*  mos_sysvars:		EQU	08h
0418F6             0055*  mos_editline:		EQU	09h
0418F6             0056*  mos_fopen:			EQU	0Ah
0418F6             0057*  mos_fclose:			EQU	0Bh
0418F6             0058*  mos_fgetc:			EQU	0Ch
0418F6             0059*  mos_fputc:			EQU	0Dh
0418F6             0060*  mos_feof:			EQU	0Eh
0418F6             0061*  mos_getError:		EQU	0Fh
0418F6             0062*  mos_oscli:			EQU	10h
0418F6             0063*  mos_copy:			EQU	11h
0418F6             0064*  mos_getrtc:			EQU	12h
0418F6             0065*  mos_setrtc:			EQU	13h
0418F6             0066*  mos_setintvector:	EQU	14h
0418F6             0067*  mos_uopen:			EQU	15h
0418F6             0068*  mos_uclose:			EQU	16h
0418F6             0069*  mos_ugetc:			EQU	17h
0418F6             0070*  mos_uputc:			EQU	18h
0418F6             0071*  mos_getfil:			EQU	19h
0418F6             0072*  mos_fread:			EQU	1Ah
0418F6             0073*  mos_fwrite:			EQU	1Bh
0418F6             0074*  mos_flseek:			EQU	1Ch
0418F6             0075*  mos_setkbvector:	EQU	1Dh
0418F6             0076*  mos_getkbmap:		EQU	1Eh
0418F6             0077*  
0418F6             0078*  ; MOS program exit codes
0418F6             0079*  ;
0418F6             0080*  EXIT_OK:				EQU  0;	"OK",
0418F6             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0418F6             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0418F6             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0418F6             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0418F6             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0418F6             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0418F6             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0418F6             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0418F6             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0418F6             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0418F6             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0418F6             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0418F6             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0418F6             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0418F6             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0418F6             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0418F6             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0418F6             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0418F6             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0418F6             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0418F6             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0418F6             0102*  ; FatFS file access functions
0418F6             0103*  ;
0418F6             0104*  ffs_fopen:			EQU	80h
0418F6             0105*  ffs_fclose:			EQU	81h
0418F6             0106*  ffs_fread:			EQU	82h
0418F6             0107*  ffs_fwrite:			EQU	83h
0418F6             0108*  ffs_flseek:			EQU	84h
0418F6             0109*  ffs_ftruncate:		EQU	85h
0418F6             0110*  ffs_fsync:			EQU	86h
0418F6             0111*  ffs_fforward:		EQU	87h
0418F6             0112*  ffs_fexpand:		EQU	88h
0418F6             0113*  ffs_fgets:			EQU	89h
0418F6             0114*  ffs_fputc:			EQU	8Ah
0418F6             0115*  ffs_fputs:			EQU	8Bh
0418F6             0116*  ffs_fprintf:		EQU	8Ch
0418F6             0117*  ffs_ftell:			EQU	8Dh
0418F6             0118*  ffs_feof:			EQU	8Eh
0418F6             0119*  ffs_fsize:			EQU	8Fh
0418F6             0120*  ffs_ferror:			EQU	90h
0418F6             0121*  
0418F6             0122*  ; FatFS directory access functions
0418F6             0123*  ;
0418F6             0124*  ffs_dopen:			EQU	91h
0418F6             0125*  ffs_dclose:			EQU	92h
0418F6             0126*  ffs_dread:			EQU	93h
0418F6             0127*  ffs_dfindfirst:		EQU	94h
0418F6             0128*  ffs_dfindnext:		EQU	95h
0418F6             0129*  
0418F6             0130*  ; FatFS file and directory management functions
0418F6             0131*  ;
0418F6             0132*  ffs_stat:			EQU	96h
0418F6             0133*  ffs_unlink:			EQU	97h
0418F6             0134*  ffs_rename:			EQU	98h
0418F6             0135*  ffs_chmod:			EQU	99h
0418F6             0136*  ffs_utime:			EQU	9Ah
0418F6             0137*  ffs_mkdir:			EQU	9Bh
0418F6             0138*  ffs_chdir:			EQU	9Ch
0418F6             0139*  ffs_chdrive:		EQU	9Dh
0418F6             0140*  ffs_getcwd:			EQU	9Eh
0418F6             0141*  
0418F6             0142*  ; FatFS volume management and system configuration functions
0418F6             0143*  ;
0418F6             0144*  ffs_mount:			EQU	9Fh
0418F6             0145*  ffs_mkfs:			EQU	A0h
0418F6             0146*  ffs_fdisk:			EQU	A1h
0418F6             0147*  ffs_getfree:		EQU	A2h
0418F6             0148*  ffs_getlabel:		EQU	A3h
0418F6             0149*  ffs_setlabel:		EQU	A4h
0418F6             0150*  ffs_setcp:			EQU	A5h
0418F6             0151*  
0418F6             0152*  ; File access modes
0418F6             0153*  ;
0418F6             0154*  fa_read:			EQU	01h
0418F6             0155*  fa_write:			EQU	02h
0418F6             0156*  fa_open_existing:	EQU	00h
0418F6             0157*  fa_create_new:		EQU	04h
0418F6             0158*  fa_create_always:	EQU	08h
0418F6             0159*  fa_open_always:		EQU	10h
0418F6             0160*  fa_open_append:		EQU	30h
0418F6             0161*  
0418F6             0162*  ; System variable indexes for api_sysvars
0418F6             0163*  ; Index into _sysvars in globals.inc
0418F6             0164*  ;
0418F6             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0418F6             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0418F6             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0418F6             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0418F6             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0418F6             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0418F6             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0418F6             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0418F6             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0418F6             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0418F6             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0418F6             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0418F6             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0418F6             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0418F6             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0418F6             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0418F6             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0418F6             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0418F6             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0418F6             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0418F6             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0418F6             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0418F6             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0418F6             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0418F6             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0418F6             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0418F6             0191*  
0418F6             0192*  ; Flags for the VPD protocol
0418F6             0193*  ;
0418F6             0194*  vdp_pflag_cursor:		EQU	00000001b
0418F6             0195*  vdp_pflag_scrchar:		EQU	00000010b
0418F6             0196*  vdp_pflag_point:		EQU	00000100b
0418F6             0197*  vdp_pflag_audio:		EQU	00001000b
0418F6             0198*  vdp_pflag_mode:			EQU	00010000b
0418F6             0199*  vdp_pflag_rtc:			EQU	00100000b
0418F6             0200*  
0418F6             0201*  ;
0418F6             0202*  ; FatFS structures
0418F6             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0418F6             0204*  ;
0418F6             0205*  ; Object ID and allocation information (FFOBJID)
0418F6             0206*  ;
0418F6             0207*  ; Indexes into FFOBJID structure
0418F6             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0418F6             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0418F6             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0418F6             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0418F6             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0418F6             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0418F6             0214*  ;
0418F6             0215*  ; File object structure (FIL)
0418F6             0216*  ;
0418F6             0217*  ; Indexes into FIL structure
0418F6             0218*  fil_obj:		EQU 0	; 15: Object identifier
0418F6             0219*  fil_flag:		EQU	15 	;  1: File status flags
0418F6             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0418F6             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0418F6             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0418F6             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0418F6             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0418F6             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0418F6             0226*  ;
0418F6             0227*  ; Directory object structure (DIR)
0418F6             0228*  ; Indexes into DIR structure
0418F6             0229*  dir_obj:		EQU  0	; 15: Object identifier
0418F6             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0418F6             0231*  dir_clust:		EQU	19	;  4: Current cluster
0418F6             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0418F6             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0418F6             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0418F6             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0418F6             0236*  ;
0418F6             0237*  ; File information structure (FILINFO)
0418F6             0238*  ;
0418F6             0239*  ; Indexes into FILINFO structure
0418F6             0240*  filinfo_fsize:		EQU 0	;   4: File size
0418F6             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0418F6             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0418F6             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0418F6             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0418F6             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0418F6             0246*  ;
0418F6             0247*  ; Macro for calling the API
0418F6             0248*  ; Parameters:
0418F6             0249*  ; - function: One of the function numbers listed above
0418F6             0250*  ;
0418F6             0251*  	MACRO	MOSCALL	function
0418F6             0252*  			LD	A, function
0418F6             0253*  			RST.LIL	08h
0418F6             0254*  	ENDMACRO
0418F6             0052       include "functions.inc"
0418F6             0001*  
0418F6             0002*      MACRO printChar char
0418F6             0003*          LD A, char
0418F6             0004*          RST.LIL 10h
0418F6             0005*      ENDMACRO
0418F6             0006*  
0418F6             0007*  ; Simulated call to subroutine at HL
0418F6             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0418F6             0009*  ; outputs: whatever the subroutine does, including HL and BC
0418F6             0010*  ; destroys: only what the subroutine does, but always BC
0418F6             0011*      MACRO callHL
0418F6             0012*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0013*          push bc       ; which constitutes the return address
0418F6             0014*          jp   (hl)     ; Jump to the address in HL
0418F6             0015*      ENDMACRO
0418F6             0016*  
0418F6             0017*  ; Simulated call to subroutine at IX
0418F6             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0418F6             0019*  ; outputs: whatever the subroutine does, including IX and BC
0418F6             0020*  ; destroys: only what the subroutine does, but always BC
0418F6             0021*      MACRO callIX
0418F6             0022*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0023*          push bc       ; which constitutes the return address
0418F6             0024*          jp   (ix)     ; Jump to the address in IX
0418F6             0025*      ENDMACRO
0418F6             0026*  
0418F6             0027*  ; Simulated call to soubroutinte at IY
0418F6             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0418F6             0029*  ; outputs: whatever the subroutine does, including IY and BC
0418F6             0030*  ; destroys: only what the subroutine does, but always BC
0418F6             0031*      MACRO callIY
0418F6             0032*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0033*          push bc       ; which constitutes the return address
0418F6             0034*          jp   (iy)     ; Jump to the address in IY
0418F6             0035*      ENDMACRO
0418F6             0036*  
0418F6             0037*  ; put the value in HLU into the accumulator
0418F6             0038*  ; destroys: af
0418F6             0039*      MACRO HLU_TO_A
0418F6             0040*          push hl ; 4 cycles
0418F6             0041*          inc sp ; 1 cycle
0418F6             0042*          pop af  ; 4 cycles
0418F6             0043*          dec sp ; 1 cycle
0418F6             0044*                 ; 10 cycles total
0418F6             0045*      ENDMACRO
0418F6             0046*  
0418F6             0047*  A_TO_HLU:
0418F6             0048*      ; call is 7 cycles
0418F6 22 03 19 04 0049*      ld (@scratch),hl ; 7 cycles
0418FA 32 05 19 04 0050*      ld (@scratch+2),a ; 5 cycles
0418FE 2A 03 19 04 0051*      ld hl,(@scratch) ; 7 cycles
041902 C9          0052*      ret ; 6 cycles
041903             0053*          ; 25 cycles total
041903 00 00 00    0054*  @scratch: dl 0
041906             0055*  
041906             0056*      ; TODO: implement this
041906             0057*      ; MACRO A_TO_HLU
041906             0058*      ;     push.s af
041906             0059*      ;     inc sp
041906             0060*      ;     push.s hl
041906             0061*      ;     pop hl
041906             0062*      ;     inc sp
041906             0063*      ;     inc sp
041906             0064*      ; ENDMACRO
041906             0065*  
041906             0066*      MACRO PUSH_ALL
041906             0067*          ex af,af'
041906             0068*          exx
041906             0069*          push af
041906             0070*          push hl
041906             0071*          push bc
041906             0072*          push de
041906             0073*  
041906             0074*          ex af,af'
041906             0075*          exx
041906             0076*          push af
041906             0077*          push hl
041906             0078*          push bc
041906             0079*          push de
041906             0080*          push ix
041906             0081*          push iy
041906             0082*      ENDMACRO
041906             0083*  
041906             0084*      MACRO POP_ALL
041906             0085*          pop iy
041906             0086*          pop ix
041906             0087*          pop de
041906             0088*          pop bc
041906             0089*          pop hl
041906             0090*          pop af
041906             0091*          ex af,af'
041906             0092*          exx
041906             0093*  
041906             0094*          pop de
041906             0095*          pop bc
041906             0096*          pop hl
041906             0097*          pop af
041906             0098*          ex af,af'
041906             0099*          exx
041906             0100*      ENDMACRO
041906             0101*  
041906             0102*  ; Print a zero-terminated string inline with code, e.g.:
041906             0103*  ;
041906             0104*  ;    call printInline
041906             0105*  ;    ASCIZ "Hello, world!\r\n"
041906             0106*  ;
041906             0107*  ; Destroys: HL,AF
041906             0108*  printInline:
041906 E1          0109*      pop hl ; get the return address = pointer to start of string
041907 CD 0D 19 04 0110*      call printString ; HL advances to end of string
04190B E5          0111*      push hl ; restore the return address = pointer to end of string
04190C C9          0112*      ret
04190D             0113*  
04190D             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04190D             0115*  ; Print a zero-terminated string
04190D             0116*  ; HL: Pointer to string
04190D             0117*  printString:
04190D C5          0118*  	PUSH	BC
04190E 01 00 00 00 0119*  	LD		BC,0
041912 3E 00       0120*  	LD 	 	A,0
041914 5B DF       0121*  	RST.LIL 18h
041916 C1          0122*  	POP		BC
041917 C9          0123*  	RET
041918             0124*  ; print a VDU sequence
041918             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
041918             0126*  sendVDUsequence:
041918 C5          0127*  	PUSH	BC
041919 01 00 00 00 0128*  	LD		BC, 0
04191D 4E          0129*  	LD		C, (HL)
04191E 5B DF       0130*  	RST.LIL	18h
041920 C1          0131*  	POP		BC
041921 C9          0132*  	RET
041922             0133*  ; Print Newline sequence to VDP
041922             0134*  printNewLine:
041922 F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
041923 3E 0D       0136*  	LD	A, '\r'
041925 5B D7       0137*  	RST.LIL 10h
041927 3E 0A       0138*  	LD	A, '\n'
041929 5B D7       0139*  	RST.LIL 10h
04192B F1          0140*      pop af
04192C C9          0141*  	RET
04192D             0142*  
04192D             0143*  ; Print a 24-bit HEX number
04192D             0144*  ; HLU: Number to print
04192D             0145*  printHex24:
04192D             0146*      HLU_TO_A
04192D E5          0001*M         push hl ; 4 cycles
04192E 33          0002*M         inc sp ; 1 cycle
04192F F1          0003*M         pop af  ; 4 cycles
041930 3B          0004*M         dec sp ; 1 cycle
041931             0005*M                ; 10 cycles total
041931 CD 3B 19 04 0147*  	CALL	printHex8
041935             0148*  ; Print a 16-bit HEX number
041935             0149*  ; HL: Number to print
041935             0150*  printHex16:
041935 7C          0151*  	LD		A,H
041936 CD 3B 19 04 0152*  	CALL	printHex8
04193A 7D          0153*  	LD		A,L
04193B             0154*  ; Print an 8-bit HEX number
04193B             0155*  ; A: Number to print
04193B             0156*  printHex8:
04193B 4F          0157*  	LD		C,A
04193C 1F          0158*  	RRA
04193D 1F          0159*  	RRA
04193E 1F          0160*  	RRA
04193F 1F          0161*  	RRA
041940 CD 45 19 04 0162*  	CALL	@F
041944 79          0163*  	LD		A,C
041945             0164*  @@:
041945 E6 0F       0165*  	AND		0Fh
041947 C6 90       0166*  	ADD		A,90h
041949 27          0167*  	DAA
04194A CE 40       0168*  	ADC		A,40h
04194C 27          0169*  	DAA
04194D 5B D7       0170*  	RST.LIL	10h
04194F C9          0171*  	RET
041950             0172*  
041950             0173*  printHexA:
041950 F5          0174*      push af
041951 C5          0175*      push bc
041952 CD 3B 19 04 0176*      call printHex8
041956 3E 20       0177*      ld a,' '
041958 5B D7       0178*      rst.lil 10h
04195A C1          0179*      pop bc
04195B F1          0180*      pop af
04195C C9          0181*      ret
04195D             0182*  
04195D             0183*  printHexHL:
04195D F5          0184*      push af
04195E C5          0185*      push bc
04195F CD 35 19 04 0186*      call printHex16
041963 3E 20       0187*      ld a,' '
041965 5B D7       0188*      rst.lil 10h
041967 C1          0189*      pop bc
041968 F1          0190*      pop af
041969 C9          0191*      ret
04196A             0192*  
04196A             0193*  printHexUHL:
04196A F5          0194*      push af
04196B C5          0195*      push bc
04196C CD 2D 19 04 0196*      call printHex24
041970 3E 20       0197*      ld a,' '
041972 5B D7       0198*      rst.lil 10h
041974 C1          0199*      pop bc
041975 F1          0200*      pop af
041976 C9          0201*      ret
041977             0202*  
041977             0203*  printHexAUHL:
041977 F5          0204*      push af
041978 C5          0205*      push bc
041979 CD 3B 19 04 0206*      call printHex8
04197D 3E 2E       0207*      ld a,'.'
04197F 5B D7       0208*      rst.lil 10h
041981 CD 2D 19 04 0209*      call printHex24
041985 3E 20       0210*      ld a,' '
041987 5B D7       0211*      rst.lil 10h
041989 C1          0212*      pop bc
04198A F1          0213*      pop af
04198B C9          0214*      ret
04198C             0215*  
04198C             0216*  printHexABHL:
04198C             0217*  ; preserve registers
04198C C5          0218*      push bc ; b will be ok c will not
04198D F5          0219*      push af ; will get totally destroyed
04198E             0220*  ; print a
04198E CD 3B 19 04 0221*      call printHex8
041992             0222*  ; print b
041992 78          0223*      ld a,b
041993 CD 3B 19 04 0224*      call printHex8
041997             0225*  ; print hl
041997 CD 35 19 04 0226*      call printHex16
04199B             0227*  ; restore registers
04199B F1          0228*      pop af
04199C C1          0229*      pop bc
04199D C9          0230*      ret
04199E             0231*  
04199E             0232*  printHexBHL:
04199E             0233*  ; preserve registers
04199E C5          0234*      push bc ; b will be ok c will not
04199F F5          0235*      push af ; will get totally destroyed
0419A0             0236*  ; print b
0419A0 78          0237*      ld a,b
0419A1 CD 3B 19 04 0238*      call printHex8
0419A5             0239*  ; print hl
0419A5 CD 35 19 04 0240*      call printHex16
0419A9             0241*  ; restore registers
0419A9 F1          0242*      pop af
0419AA C1          0243*      pop bc
0419AB C9          0244*      ret
0419AC             0245*  
0419AC             0246*  printHexCDE:
0419AC             0247*  ; preserve registers
0419AC C5          0248*      push bc ; b will be ok c will not
0419AD F5          0249*      push af ; will get totally destroyed
0419AE             0250*  ; print c
0419AE 79          0251*      ld a,c
0419AF CD 3B 19 04 0252*      call printHex8
0419B3             0253*  ; print de
0419B3 EB          0254*      ex de,hl
0419B4 CD 35 19 04 0255*      call printHex16
0419B8 EB          0256*      ex de,hl
0419B9             0257*  ; restore registers
0419B9 F1          0258*      pop af
0419BA C1          0259*      pop bc
0419BB C9          0260*      ret
0419BC             0261*  
0419BC             0262*  printHexUIX:
0419BC             0263*  ; store everything in scratch
0419BC 22 35 1E 04 0264*      ld (uhl),hl
0419C0 ED 43 38 1E 0265*      ld (ubc),bc
       04          
0419C5 ED 53 3B 1E 0266*      ld (ude),de
       04          
0419CA DD 22 3E 1E 0267*      ld (uix),ix
       04          
0419CF FD 22 41 1E 0268*      ld (uiy),iy
       04          
0419D4 F5          0269*      push af ; fml
0419D5             0270*  
0419D5 21 CC 1D 04 0271*      ld hl,str_ixu
0419D9 CD 0D 19 04 0272*      call printString
0419DD 2A 3E 1E 04 0273*      ld hl,(uix)
0419E1 CD 2D 19 04 0274*      call printHex24
0419E5 CD 22 19 04 0275*      call printNewLine
0419E9             0276*  
0419E9             0277*  ; restore everything
0419E9 2A 35 1E 04 0278*      ld hl, (uhl)
0419ED ED 4B 38 1E 0279*      ld bc, (ubc)
       04          
0419F2 ED 5B 3B 1E 0280*      ld de, (ude)
       04          
0419F7 DD 2A 3E 1E 0281*      ld ix, (uix)
       04          
0419FC FD 2A 41 1E 0282*      ld iy, (uiy)
       04          
041A01 F1          0283*      pop af
041A02             0284*  ; all done
041A02 C9          0285*      ret
041A03             0286*  
041A03             0287*  ; Print a 0x HEX prefix
041A03             0288*  DisplayHexPrefix:
041A03 3E 30       0289*  	LD	A, '0'
041A05 5B D7       0290*  	RST.LIL 10h
041A07 3E 78       0291*  	LD	A, 'x'
041A09 5B D7       0292*  	RST.LIL 10h
041A0B C9          0293*  	RET
041A0C             0294*  
041A0C             0295*      MACRO printDecBC
041A0C             0296*          push hl
041A0C             0297*          push bc
041A0C             0298*          pop hl
041A0C             0299*          call printDec
041A0C             0300*          pop hl
041A0C             0301*      ENDMACRO
041A0C             0302*  
041A0C             0303*      MACRO printDecDE
041A0C             0304*          push hl
041A0C             0305*          push de
041A0C             0306*          pop hl
041A0C             0307*          call printDec
041A0C             0308*          pop hl
041A0C             0309*      ENDMACRO
041A0C             0310*  
041A0C             0311*      MACRO printDecHL
041A0C             0312*          call printDec
041A0C             0313*      ENDMACRO
041A0C             0314*  
041A0C             0315*      MACRO printDecIX
041A0C             0316*          push hl
041A0C             0317*          push ix
041A0C             0318*          pop hl
041A0C             0319*          call printDec
041A0C             0320*          pop hl
041A0C             0321*      ENDMACRO
041A0C             0322*  
041A0C             0323*      MACRO printDecIY
041A0C             0324*          push hl
041A0C             0325*          push iy
041A0C             0326*          pop hl
041A0C             0327*          call printDec
041A0C             0328*          pop hl
041A0C             0329*      ENDMACRO
041A0C             0330*  
041A0C             0331*  
041A0C             0332*  ; Prints the right justified decimal value in HL without leading zeroes
041A0C             0333*  ; HL : Value to print
041A0C             0334*  ; preserves all registers and flags
041A0C             0335*  printDec:
041A0C             0336*  ; BEGIN MY CODE
041A0C             0337*  ; back up all the things
041A0C F5          0338*      push af
041A0D C5          0339*      push bc
041A0E D5          0340*      push de
041A0F E5          0341*      push hl
041A10             0342*  ; END MY CODE
041A10 11 38 1A 04 0343*  	LD	 DE, _printDecBuffer
041A14 CD 48 1A 04 0344*  	CALL u24_to_ascii
041A18             0345*  ; BEGIN MY CODE
041A18             0346*  ; replace leading zeroes with spaces
041A18 21 38 1A 04 0347*      LD	 HL, _printDecBuffer
041A1C 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
041A1E             0349*  @loop:
041A1E 7E          0350*      LD	 A, (HL)
041A1F FE 30       0351*      CP	 '0'
041A21 C2 2B 1A 04 0352*      JP	 NZ, @done
041A25 3E 20       0353*      LD   A, ' '
041A27 77          0354*      LD	 (HL), A
041A28 23          0355*      INC	 HL
041A29             0356*      ; CALL vdu_cursor_forward
041A29 10 F3       0357*      DJNZ @loop
041A2B             0358*  @done:
041A2B             0359*  ; END MY CODE
041A2B 21 38 1A 04 0360*  	LD	 HL, _printDecBuffer
041A2F CD 0D 19 04 0361*  	CALL printString
041A33             0362*  ; BEGIN MY CODE
041A33             0363*  ; restore all the things
041A33 E1          0364*      pop hl
041A34 D1          0365*      pop de
041A35 C1          0366*      pop bc
041A36 F1          0367*      pop af
041A37             0368*  ; END MY CODE
041A37 C9          0369*  	RET
041A38 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A48             0371*  
041A48             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
041A48             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041A48             0374*  ; so it will allways be 8 characters length
041A48             0375*  ; HL : Value to convert to string
041A48             0376*  ; DE : pointer to buffer, at least 8 byte + 0
041A48             0377*  u24_to_ascii:
041A48 01 80 69 67 0378*  	LD	 BC,-10000000
041A4C CD 7F 1A 04 0379*  	CALL @one_digit
041A50 01 C0 BD F0 0380*  	LD	 BC,-1000000
041A54 CD 7F 1A 04 0381*  	CALL @one_digit
041A58 01 60 79 FE 0382*  	LD	 BC,-100000
041A5C CD 7F 1A 04 0383*  	CALL @one_digit
041A60 01 F0 D8 FF 0384*  	LD   BC,-10000
041A64 CD 7F 1A 04 0385*  	CALL @one_digit
041A68 01 18 FC FF 0386*  	LD   BC,-1000
041A6C CD 7F 1A 04 0387*  	CALL @one_digit
041A70 01 9C FF FF 0388*  	LD   BC,-100
041A74 CD 7F 1A 04 0389*  	CALL @one_digit
041A78 0E F6       0390*  	LD   C,-10
041A7A CD 7F 1A 04 0391*  	CALL @one_digit
041A7E 48          0392*  	LD   C,B
041A7F             0393*  @one_digit:
041A7F 3E 2F       0394*  	LD   A,'0'-1
041A81             0395*  @divide_me:
041A81 3C          0396*  	INC  A
041A82 09          0397*  	ADD  HL,BC
041A83 38 FC       0398*  	JR   C,@divide_me
041A85 ED 42       0399*  	SBC  HL,BC
041A87 12          0400*  	LD   (DE),A
041A88 13          0401*  	INC  DE
041A89 C9          0402*  	RET
041A8A             0403*  
041A8A             0404*  print_u24:
041A8A D5          0405*      push de
041A8B E5          0406*      push hl
041A8C 11 38 1A 04 0407*      ld de,_printDecBuffer
041A90 CD 48 1A 04 0408*      call u24_to_ascii
041A94 21 38 1A 04 0409*      ld hl,_printDecBuffer
041A98 CD 0D 19 04 0410*      call printString
041A9C 3E 20       0411*      ld a,' '
041A9E 5B D7       0412*      rst.lil 10h
041AA0 E1          0413*      pop hl
041AA1 D1          0414*      pop de
041AA2 C9          0415*      ret
041AA3             0416*  
041AA3             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
041AA3             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
041AA3             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
041AA3             0420*  u168_to_ascii:
041AA3             0421*  ; add a leading space to make room for sign flag if needed
041AA3 3E 20       0422*      ld a,' '
041AA5 12          0423*      ld (de),a
041AA6 13          0424*      inc de
041AA7             0425*  ; Convert integer part
041AA7 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
041AA8 CD 9D 25 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
041AAC 01 F0 D8 FF 0428*      ld   bc, -10000
041AB0 CD D3 1A 04 0429*      call @one_int
041AB4 01 18 FC FF 0430*      ld   bc, -1000
041AB8 CD D3 1A 04 0431*      call @one_int
041ABC 01 9C FF FF 0432*      ld   bc, -100
041AC0 CD D3 1A 04 0433*      call @one_int
041AC4 0E F6       0434*      ld   c, -10
041AC6 CD D3 1A 04 0435*      call @one_int
041ACA 48          0436*      ld   c, b
041ACB CD D3 1A 04 0437*      call @one_int
041ACF C3 DE 1A 04 0438*      jp   @frac            ; Jump to fractional part conversion
041AD3             0439*  @one_int:
041AD3 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
041AD5             0441*  @divide_me:
041AD5 3C          0442*      inc  a
041AD6 09          0443*      add  hl, bc           ; Accumulate until overflow
041AD7 38 FC       0444*      jr   c, @divide_me
041AD9 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
041ADB 12          0446*      ld   (de), a          ; Store ASCII digit
041ADC 13          0447*      inc  de
041ADD C9          0448*      ret
041ADE             0449*  ; Convert fractional part
041ADE             0450*  @frac:
041ADE 3E 2E       0451*      ld   a, '.'           ; Decimal point
041AE0 12          0452*      ld   (de), a
041AE1 13          0453*      inc  de
041AE2 E1          0454*      pop  hl               ; Restore HL with original fraction
041AE3 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
041AE5             0456*  @frac_loop:
041AE5 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
041AE7 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
041AE9 3E 30       0459*      ld   a, '0'
041AEB 84          0460*      add  a, h             ; Convert integer part to ASCII
041AEC 12          0461*      ld   (de), a
041AED 13          0462*      inc  de
041AEE 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
041AF0             0464*  ; Add null terminator
041AF0 AF          0465*      xor  a                ; Null terminator
041AF1 12          0466*      ld   (de), a
041AF2 C9          0467*      ret
041AF3             0468*  
041AF3             0469*  print_u168:
041AF3 D5          0470*      push de
041AF4 E5          0471*      push hl
041AF5 11 38 1A 04 0472*      ld de,_printDecBuffer
041AF9 CD A3 1A 04 0473*      call u168_to_ascii
041AFD 21 38 1A 04 0474*      ld hl,_printDecBuffer
041B01 CD 0D 19 04 0475*      call printString
041B05 E1          0476*      pop hl
041B06 D1          0477*      pop de
041B07 C9          0478*      ret
041B08             0479*  
041B08             0480*  ; signed version of u168_to_ascii
041B08             0481*  s168_to_ascii:
041B08 D5          0482*      push de ; save starting address of buffer
041B09 CD 36 25 04 0483*      call hlu_abs
041B0D F5          0484*      push af ; save sign flag
041B0E CD A3 1A 04 0485*      call u168_to_ascii
041B12 F1          0486*      pop af ; restore sign flag
041B13 D1          0487*      pop de ; restore starting address of buffer
041B14 F0          0488*      ret p ; hlu was positive so nothing to do
041B15 3E 2D       0489*      ld a,'-'
041B17 12          0490*      ld (de),a
041B18 C9          0491*      ret
041B19             0492*  
041B19             0493*  print_s168:
041B19 D5          0494*      push de
041B1A E5          0495*      push hl
041B1B 11 38 1A 04 0496*      ld de,_printDecBuffer
041B1F CD 08 1B 04 0497*      call s168_to_ascii
041B23 21 38 1A 04 0498*      ld hl,_printDecBuffer
041B27 CD 0D 19 04 0499*      call printString
041B2B E1          0500*      pop hl
041B2C D1          0501*      pop de
041B2D C9          0502*      ret
041B2E             0503*  
041B2E             0504*  print_s168_hl:
041B2E F5          0505*      push af
041B2F E5          0506*      push hl
041B30 CD 19 1B 04 0507*      call print_s168
041B34 3E 20       0508*      ld a,' '
041B36 5B D7       0509*      rst.lil 10h
041B38 E1          0510*      pop hl
041B39 F1          0511*      pop af
041B3A C9          0512*      ret
041B3B             0513*  
041B3B             0514*  print_s168_bc:
041B3B F5          0515*      push af
041B3C C5          0516*      push bc
041B3D E5          0517*      push hl
041B3E C5          0518*      push bc
041B3F E1          0519*      pop hl
041B40 CD 19 1B 04 0520*      call print_s168
041B44 3E 20       0521*      ld a,' '
041B46 5B D7       0522*      rst.lil 10h
041B48 E1          0523*      pop hl
041B49 C1          0524*      pop bc
041B4A F1          0525*      pop af
041B4B C9          0526*      ret
041B4C             0527*  
041B4C             0528*  print_s168_de:
041B4C F5          0529*      push af
041B4D D5          0530*      push de
041B4E E5          0531*      push hl
041B4F EB          0532*      ex de,hl
041B50 CD 19 1B 04 0533*      call print_s168
041B54 3E 20       0534*      ld a,' '
041B56 5B D7       0535*      rst.lil 10h
041B58 E1          0536*      pop hl
041B59 D1          0537*      pop de
041B5A F1          0538*      pop af
041B5B C9          0539*      ret
041B5C             0540*  
041B5C             0541*  print_s168_hl_bc_de:
041B5C F5          0542*      push af
041B5D C5          0543*      push bc
041B5E D5          0544*      push de
041B5F E5          0545*      push hl
041B60 CD 19 1B 04 0546*      call print_s168
041B64 3E 20       0547*      ld a,' '
041B66 5B D7       0548*      rst.lil 10h
041B68 C5          0549*      push bc
041B69 E1          0550*      pop hl
041B6A CD 19 1B 04 0551*      call print_s168
041B6E 3E 20       0552*      ld a,' '
041B70 5B D7       0553*      rst.lil 10h
041B72 EB          0554*      ex de,hl
041B73 CD 19 1B 04 0555*      call print_s168
041B77 3E 20       0556*      ld a,' '
041B79 5B D7       0557*      rst.lil 10h
041B7B E1          0558*      pop hl
041B7C D1          0559*      pop de
041B7D C1          0560*      pop bc
041B7E F1          0561*      pop af
041B7F C9          0562*      ret
041B80             0563*  
041B80             0564*  print_s168_bc_de:
041B80 F5          0565*      push af
041B81 C5          0566*      push bc
041B82 D5          0567*      push de
041B83 C5          0568*      push bc
041B84 E1          0569*      pop hl
041B85 CD 19 1B 04 0570*      call print_s168
041B89 3E 20       0571*      ld a,' '
041B8B 5B D7       0572*      rst.lil 10h
041B8D EB          0573*      ex de,hl
041B8E CD 19 1B 04 0574*      call print_s168
041B92 3E 20       0575*      ld a,' '
041B94 5B D7       0576*      rst.lil 10h
041B96 E1          0577*      pop hl
041B97 D1          0578*      pop de
041B98 C1          0579*      pop bc
041B99 F1          0580*      pop af
041B9A C9          0581*      ret
041B9B             0582*  
041B9B             0583*  print_s168_a:
041B9B F5          0584*      push af
041B9C C5          0585*      push bc
041B9D E5          0586*      push hl
041B9E 21 00 00 00 0587*      ld hl,0
041BA2 6F          0588*      ld l,a
041BA3 CD 2E 1B 04 0589*      call print_s168_hl
041BA7 E1          0590*      pop hl
041BA8 C1          0591*      pop bc
041BA9 F1          0592*      pop af
041BAA C9          0593*      ret
041BAB             0594*  
041BAB             0595*  ; #### new functions added by Brandon R. Gates ####
041BAB             0596*  
041BAB             0597*  ; print the binary representation of the 8-bit value in a
041BAB             0598*  ; destroys a, hl, bc
041BAB             0599*  printBin8:
041BAB 06 08       0600*      ld b,8      ; loop counter for 8 bits
041BAD 21 C8 1B 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
041BB1             0602*                  ; (which will be the high bit of the value in a)
041BB1             0603*  @loop:
041BB1 07          0604*      rlca ; put the next highest bit into carry
041BB2 38 04       0605*      jr c,@one
041BB4 36 30       0606*      ld (hl),'0'
041BB6 18 02       0607*      jr @next_bit
041BB8             0608*  @one:
041BB8 36 31       0609*      ld (hl),'1'
041BBA             0610*  @next_bit:
041BBA 23          0611*      inc hl
041BBB 10 F4       0612*      djnz @loop
041BBD             0613*  ; print it
041BBD 21 C8 1B 04 0614*  	ld hl,@cmd
041BC1 01 08 00 00 0615*  	ld bc,@end-@cmd
041BC5 5B DF       0616*  	rst.lil $18
041BC7 C9          0617*  	ret
041BC8             0618*  @cmd: ds 8 ; eight bytes for eight bits
041BD0             0619*  @end:
041BD0             0620*  
041BD0             0621*  ; print the binary representation of the 8-bit value in a
041BD0             0622*  ; in reverse order (lsb first)
041BD0             0623*  ; destroys a, hl, bc
041BD0             0624*  printBin8Rev:
041BD0 06 08       0625*      ld b,8      ; loop counter for 8 bits
041BD2 21 ED 1B 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
041BD6             0627*                  ; (which will be the high bit of the value in a)
041BD6             0628*  @loop:
041BD6 0F          0629*      rrca ; put the next lowest bit into carry
041BD7 38 04       0630*      jr c,@one
041BD9 36 30       0631*      ld (hl),'0'
041BDB 18 02       0632*      jr @next_bit
041BDD             0633*  @one:
041BDD 36 31       0634*      ld (hl),'1'
041BDF             0635*  @next_bit:
041BDF 23          0636*      inc hl
041BE0 10 F4       0637*      djnz @loop
041BE2             0638*  ; print it
041BE2 21 ED 1B 04 0639*  	ld hl,@cmd
041BE6 01 08 00 00 0640*  	ld bc,@end-@cmd
041BEA 5B DF       0641*  	rst.lil $18
041BEC C9          0642*  	ret
041BED             0643*  @cmd: ds 8 ; eight bytes for eight bits
041BF5             0644*  @end:
041BF5             0645*  
041BF5             0646*  ; print registers to screen in hexidecimal format
041BF5             0647*  ; inputs: none
041BF5             0648*  ; outputs: values of every register printed to screen
041BF5             0649*  ;    values of each register in global scratch memory
041BF5             0650*  ; destroys: nothing
041BF5             0651*  stepRegistersHex:
041BF5             0652*  ; store everything in scratch
041BF5 22 35 1E 04 0653*      ld (uhl),hl
041BF9 ED 43 38 1E 0654*      ld (ubc),bc
       04          
041BFE ED 53 3B 1E 0655*      ld (ude),de
       04          
041C03 DD 22 3E 1E 0656*      ld (uix),ix
       04          
041C08 FD 22 41 1E 0657*      ld (uiy),iy
       04          
041C0D F5          0658*      push af ; fml
041C0E E1          0659*      pop hl  ; thanks, zilog
041C0F 22 32 1E 04 0660*      ld (uaf),hl
041C13 F5          0661*      push af ; dammit
041C14             0662*  
041C14             0663*  ; home the cursor
041C14             0664*      ; call vdu_home_cursor
041C14             0665*  
041C14             0666*  ; print each register
041C14 21 B8 1D 04 0667*      ld hl,str_afu
041C18 CD 0D 19 04 0668*      call printString
041C1C 2A 32 1E 04 0669*      ld hl,(uaf)
041C20 CD 2D 19 04 0670*      call printHex24
041C24 CD 22 19 04 0671*      call printNewLine
041C28             0672*  
041C28 21 BD 1D 04 0673*      ld hl,str_hlu
041C2C CD 0D 19 04 0674*      call printString
041C30 2A 35 1E 04 0675*      ld hl,(uhl)
041C34 CD 2D 19 04 0676*      call printHex24
041C38 CD 22 19 04 0677*      call printNewLine
041C3C             0678*  
041C3C 21 C2 1D 04 0679*      ld hl,str_bcu
041C40 CD 0D 19 04 0680*      call printString
041C44 2A 38 1E 04 0681*      ld hl,(ubc)
041C48 CD 2D 19 04 0682*      call printHex24
041C4C CD 22 19 04 0683*      call printNewLine
041C50             0684*  
041C50 21 C7 1D 04 0685*      ld hl,str_deu
041C54 CD 0D 19 04 0686*      call printString
041C58 2A 3B 1E 04 0687*      ld hl,(ude)
041C5C CD 2D 19 04 0688*      call printHex24
041C60 CD 22 19 04 0689*      call printNewLine
041C64             0690*  
041C64 21 CC 1D 04 0691*      ld hl,str_ixu
041C68 CD 0D 19 04 0692*      call printString
041C6C 2A 3E 1E 04 0693*      ld hl,(uix)
041C70 CD 2D 19 04 0694*      call printHex24
041C74 CD 22 19 04 0695*      call printNewLine
041C78             0696*  
041C78 21 D1 1D 04 0697*      ld hl,str_iyu
041C7C CD 0D 19 04 0698*      call printString
041C80 2A 41 1E 04 0699*      ld hl,(uiy)
041C84 CD 2D 19 04 0700*      call printHex24
041C88 CD 22 19 04 0701*      call printNewLine
041C8C             0702*  
041C8C             0703*      ; call vsync
041C8C             0704*  
041C8C CD 22 19 04 0705*      call printNewLine
041C90             0706*  
041C90             0707*  ; check for right shift key and quit if pressed
041C90             0708*  	MOSCALL mos_getkbmap
041C90 3E 1E       0001*M 			LD	A, function
041C92 5B CF       0002*M 			RST.LIL	08h
041C94             0709*  @stayhere:
041C94             0710*  ; 7 RightShift
041C94 DD CB 00 76 0711*      bit 6,(ix+0)
041C98 20 02       0712*      jr nz,@RightShift
041C9A 18 F8       0713*      jr @stayhere
041C9C             0714*  @RightShift:
041C9C DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
041CA0 3E 80       0716*      ld a,%10000000
041CA2             0717*      ; call multiPurposeDelay
041CA2             0718*  
041CA2             0719*  ; restore everything
041CA2 2A 35 1E 04 0720*      ld hl, (uhl)
041CA6 ED 4B 38 1E 0721*      ld bc, (ubc)
       04          
041CAB ED 5B 3B 1E 0722*      ld de, (ude)
       04          
041CB0 DD 2A 3E 1E 0723*      ld ix, (uix)
       04          
041CB5 FD 2A 41 1E 0724*      ld iy, (uiy)
       04          
041CBA F1          0725*      pop af
041CBB             0726*  ; all done
041CBB C9          0727*      ret
041CBC             0728*  
041CBC             0729*  ; print registers to screen in hexidecimal format
041CBC             0730*  ; inputs: none
041CBC             0731*  ; outputs: values of every register printed to screen
041CBC             0732*  ;    values of each register in global scratch memory
041CBC             0733*  ; destroys: nothing
041CBC             0734*  dumpRegistersHex:
041CBC             0735*  ; store everything in scratch
041CBC 22 35 1E 04 0736*      ld (uhl),hl
041CC0 ED 43 38 1E 0737*      ld (ubc),bc
       04          
041CC5 ED 53 3B 1E 0738*      ld (ude),de
       04          
041CCA DD 22 3E 1E 0739*      ld (uix),ix
       04          
041CCF FD 22 41 1E 0740*      ld (uiy),iy
       04          
041CD4 F5          0741*      push af ; fml
041CD5 E1          0742*      pop hl  ; thanks, zilog
041CD6 22 32 1E 04 0743*      ld (uaf),hl
041CDA F5          0744*      push af ; dammit
041CDB             0745*  
041CDB             0746*  ; home the cursor
041CDB             0747*      ; call vdu_home_cursor
041CDB             0748*      ; call printNewLine
041CDB             0749*  
041CDB             0750*  ; print each register
041CDB 21 B8 1D 04 0751*      ld hl,str_afu
041CDF CD 0D 19 04 0752*      call printString
041CE3 2A 32 1E 04 0753*      ld hl,(uaf)
041CE7 CD 2D 19 04 0754*      call printHex24
041CEB             0755*      ; call printNewLine
041CEB             0756*  
041CEB 21 BD 1D 04 0757*      ld hl,str_hlu
041CEF CD 0D 19 04 0758*      call printString
041CF3 2A 35 1E 04 0759*      ld hl,(uhl)
041CF7 CD 2D 19 04 0760*      call printHex24
041CFB             0761*      ; call printNewLine
041CFB             0762*  
041CFB 21 C2 1D 04 0763*      ld hl,str_bcu
041CFF CD 0D 19 04 0764*      call printString
041D03 2A 38 1E 04 0765*      ld hl,(ubc)
041D07 CD 2D 19 04 0766*      call printHex24
041D0B             0767*      ; call printNewLine
041D0B             0768*  
041D0B 21 C7 1D 04 0769*      ld hl,str_deu
041D0F CD 0D 19 04 0770*      call printString
041D13 2A 3B 1E 04 0771*      ld hl,(ude)
041D17 CD 2D 19 04 0772*      call printHex24
041D1B             0773*      ; call printNewLine
041D1B             0774*  
041D1B 21 CC 1D 04 0775*      ld hl,str_ixu
041D1F CD 0D 19 04 0776*      call printString
041D23 2A 3E 1E 04 0777*      ld hl,(uix)
041D27 CD 2D 19 04 0778*      call printHex24
041D2B             0779*      ; call printNewLine
041D2B             0780*  
041D2B 21 D1 1D 04 0781*      ld hl,str_iyu
041D2F CD 0D 19 04 0782*      call printString
041D33 2A 41 1E 04 0783*      ld hl,(uiy)
041D37 CD 2D 19 04 0784*      call printHex24
041D3B             0785*      ; call printNewLine
041D3B             0786*  
041D3B             0787*      ; call vdu_vblank
041D3B             0788*  
041D3B CD 22 19 04 0789*      call printNewLine
041D3F             0790*  ; restore everything
041D3F 2A 35 1E 04 0791*      ld hl, (uhl)
041D43 ED 4B 38 1E 0792*      ld bc, (ubc)
       04          
041D48 ED 5B 3B 1E 0793*      ld de, (ude)
       04          
041D4D DD 2A 3E 1E 0794*      ld ix, (uix)
       04          
041D52 FD 2A 41 1E 0795*      ld iy, (uiy)
       04          
041D57 F1          0796*      pop af
041D58             0797*  ; all done
041D58 C9          0798*      ret
041D59             0799*  
041D59             0800*  dumpRegistersHexPrime:
041D59 D9          0801*      exx
041D5A 08          0802*      ex af,af'
041D5B CD BC 1C 04 0803*      call dumpRegistersHex
041D5F 08          0804*      ex af,af'
041D60 D9          0805*      exx
041D61 C9          0806*      ret
041D62             0807*  
041D62             0808*  ; additionally dump prime registers
041D62             0809*  ; inputs: none
041D62             0810*  ; outputs: values of every register printed to screen
041D62             0811*  ; destroys: nothing
041D62             0812*  dumpRegistersHexAll:
041D62 CD BC 1C 04 0813*      call dumpRegistersHex
041D66 08          0814*      ex af,af'
041D67 D9          0815*      exx
041D68 CD BC 1C 04 0816*      call dumpRegistersHex
041D6C 08          0817*      ex af,af'
041D6D D9          0818*      exx
041D6E C9          0819*      ret
041D6F             0820*  
041D6F             0821*  ; print hlu to screen in hexidecimal format
041D6F             0822*  ; inputs: none
041D6F             0823*  ; destroys: nothing
041D6F             0824*  print_hex_hl:
041D6F F5          0825*      push af
041D70 E5          0826*      push hl
041D71 21 BD 1D 04 0827*      ld hl,str_hlu
041D75 CD 0D 19 04 0828*      call printString
041D79 E1          0829*      pop hl
041D7A E5          0830*      push hl
041D7B CD 2D 19 04 0831*      call printHex24
041D7F 3E 20       0832*      ld a,' '
041D81 5B D7       0833*      rst.lil 10h
041D83 E1          0834*      pop hl
041D84 F1          0835*      pop af
041D85 C9          0836*      ret
041D86             0837*  
041D86             0838*  ; print bcu to screen in hexidecimal format
041D86             0839*  ; inputs: none
041D86             0840*  ; destroys: nothing
041D86             0841*  print_hex_bc:
041D86 F5          0842*      push af
041D87 E5          0843*      push hl
041D88 C5          0844*      push bc
041D89 21 C2 1D 04 0845*      ld hl,str_bcu
041D8D CD 0D 19 04 0846*      call printString
041D91 E1          0847*      pop hl
041D92 E5          0848*      push hl
041D93 CD 2D 19 04 0849*      call printHex24
041D97 3E 20       0850*      ld a,' '
041D99 5B D7       0851*      rst.lil 10h
041D9B C1          0852*      pop bc
041D9C E1          0853*      pop hl
041D9D F1          0854*      pop af
041D9E C9          0855*      ret
041D9F             0856*  
041D9F             0857*  ; print deu to screen in hexidecimal format
041D9F             0858*  ; inputs: none
041D9F             0859*  ; destroys: nothing
041D9F             0860*  print_hex_de:
041D9F F5          0861*      push af
041DA0 E5          0862*      push hl
041DA1 D5          0863*      push de
041DA2 21 C7 1D 04 0864*      ld hl,str_deu
041DA6 CD 0D 19 04 0865*      call printString
041DAA E1          0866*      pop hl
041DAB E5          0867*      push hl
041DAC CD 2D 19 04 0868*      call printHex24
041DB0 3E 20       0869*      ld a,' '
041DB2 5B D7       0870*      rst.lil 10h
041DB4 D1          0871*      pop de
041DB5 E1          0872*      pop hl
041DB6 F1          0873*      pop af
041DB7 C9          0874*      ret
041DB8             0875*  
041DB8 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
041DBD 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
041DC2 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
041DC7 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
041DCC 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
041DD1 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
041DD6             0882*  
041DD6             0883*  ; print udeuhl to screen in hexidecimal format
041DD6             0884*  ; inputs: none
041DD6             0885*  ; outputs: concatenated hexidecimal udeuhl
041DD6             0886*  ; destroys: nothing
041DD6             0887*  dumpUDEUHLHex:
041DD6             0888*  ; store everything in scratch
041DD6 22 35 1E 04 0889*      ld (uhl),hl
041DDA ED 43 38 1E 0890*      ld (ubc),bc
       04          
041DDF ED 53 3B 1E 0891*      ld (ude),de
       04          
041DE4 DD 22 3E 1E 0892*      ld (uix),ix
       04          
041DE9 FD 22 41 1E 0893*      ld (uiy),iy
       04          
041DEE F5          0894*      push af
041DEF             0895*  
041DEF             0896*  ; print each register
041DEF             0897*  
041DEF 21 29 1E 04 0898*      ld hl,str_udeuhl
041DF3 CD 0D 19 04 0899*      call printString
041DF7 2A 3B 1E 04 0900*      ld hl,(ude)
041DFB CD 2D 19 04 0901*      call printHex24
041DFF 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
041E01 5B D7       0903*  	rst.lil 10h
041E03 2A 35 1E 04 0904*      ld hl,(uhl)
041E07 CD 2D 19 04 0905*      call printHex24
041E0B CD 22 19 04 0906*      call printNewLine
041E0F             0907*  
041E0F             0908*  ; restore everything
041E0F 2A 35 1E 04 0909*      ld hl, (uhl)
041E13 ED 4B 38 1E 0910*      ld bc, (ubc)
       04          
041E18 ED 5B 3B 1E 0911*      ld de, (ude)
       04          
041E1D DD 2A 3E 1E 0912*      ld ix, (uix)
       04          
041E22 FD 2A 41 1E 0913*      ld iy, (uiy)
       04          
041E27 F1          0914*      pop af
041E28             0915*  ; all done
041E28 C9          0916*      ret
041E29             0917*  
041E29 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041E32             0919*  
041E32             0920*  ; global scratch memory for registers
041E32 00 00 00    0921*  uaf: dl 0
041E35 00 00 00    0922*  uhl: dl 0
041E38 00 00 00    0923*  ubc: dl 0
041E3B 00 00 00    0924*  ude: dl 0
041E3E 00 00 00    0925*  uix: dl 0
041E41 00 00 00    0926*  uiy: dl 0
041E44 00 00 00    0927*  usp: dl 0
041E47 00 00 00    0928*  upc: dl 0
041E4A             0929*  
041E4A             0930*  ; inputs: whatever is in the flags register
041E4A             0931*  ; outputs: binary representation of flags
041E4A             0932*  ;          with a header so we know which is what
041E4A             0933*  ; destroys: nothing
041E4A             0934*  ; preserves: everything
041E4A             0935*  dumpFlags:
041E4A             0936*  ; first we curse zilog for not giving direct access to flags
041E4A F5          0937*      push af ; this is so we can send it back unharmed
041E4B F5          0938*      push af ; this is so we can pop it to hl
041E4C             0939*  ; store everything in scratch
041E4C 22 35 1E 04 0940*      ld (uhl),hl
041E50 ED 43 38 1E 0941*      ld (ubc),bc
       04          
041E55 ED 53 3B 1E 0942*      ld (ude),de
       04          
041E5A DD 22 3E 1E 0943*      ld (uix),ix
       04          
041E5F FD 22 41 1E 0944*      ld (uiy),iy
       04          
041E64             0945*  ; next we print the header
041E64 21 90 1E 04 0946*      ld hl,@header
041E68 CD 0D 19 04 0947*      call printString
041E6C E1          0948*      pop hl ; flags are now in l
041E6D 7D          0949*      ld a,l ; flags are now in a
041E6E CD AB 1B 04 0950*      call printBin8
041E72 CD 22 19 04 0951*  	call printNewLine
041E76             0952*  ; restore everything
041E76 2A 35 1E 04 0953*      ld hl, (uhl)
041E7A ED 4B 38 1E 0954*      ld bc, (ubc)
       04          
041E7F ED 5B 3B 1E 0955*      ld de, (ude)
       04          
041E84 DD 2A 3E 1E 0956*      ld ix, (uix)
       04          
041E89 FD 2A 41 1E 0957*      ld iy, (uiy)
       04          
041E8E F1          0958*      pop af ; send her home the way she came
041E8F C9          0959*      ret
041E90             0960*  ; Bit 7 (S): Sign flag
041E90             0961*  ; Bit 6 (Z): Zero flag
041E90             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041E90             0963*  ; Bit 4 (H): Half Carry flag
041E90             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041E90             0965*  ; Bit 2 (PV): Parity/Overflow flag
041E90             0966*  ; Bit 1 (N): Subtract flag
041E90             0967*  ; Bit 0 (C): Carry flag
041E90 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041E9B             0969*  
041E9B             0970*  ; set all the bits in the flag register
041E9B             0971*  ; more of an academic exercise than anything useful
041E9B             0972*  ; inputs; none
041E9B             0973*  ; outputs; a=0,f=255
041E9B             0974*  ; destroys: flags, hl
041E9B             0975*  ; preserves: a, because why not
041E9B             0976*  setAllFlags:
041E9B 21 FF 00 00 0977*      ld hl,255
041E9F 67          0978*      ld h,a ; four cycles to preserve a is cheap
041EA0 E5          0979*      push hl
041EA1 F1          0980*      pop af
041EA2 C9          0981*      ret
041EA3             0982*  
041EA3             0983*  ; reset all the bits in the flag register
041EA3             0984*  ; unlike its inverse counterpart, this may actually be useful
041EA3             0985*  ; inputs; none
041EA3             0986*  ; outputs; a=0,f=0
041EA3             0987*  ; destroys: flags, hl
041EA3             0988*  ; preserves: a, because why not
041EA3             0989*  resetAllFlags:
041EA3 21 00 00 00 0990*      ld hl,0
041EA7 67          0991*      ld h,a ; four cycles to preserve a is cheap
041EA8 E5          0992*      push hl
041EA9 F1          0993*      pop af
041EAA C9          0994*      ret
041EAB             0995*  
041EAB             0996*  ; wait until user presses a key
041EAB             0997*  ; inputs: none
041EAB             0998*  ; outputs: ascii code of key pressed in a
041EAB             0999*  ; destroys: af,ix
041EAB             1000*  waitKeypress:
041EAB             1001*      MOSCALL mos_getkey
041EAB 3E 00       0001*M 			LD	A, function
041EAD 5B CF       0002*M 			RST.LIL	08h
041EAF C9          1002*      ret
041EB0             1003*  
041EB0             1004*  ; print bytes from an address to the screen in hexidecimal format
041EB0             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EB0             1006*  ; outputs: values of each byte printed to screen separated by spaces
041EB0             1007*  ; destroys: nothing
041EB0             1008*  dumpMemoryHex:
041EB0             1009*  ; save registers to the stack
041EB0 C5          1010*      push bc
041EB1 E5          1011*      push hl
041EB2 F5          1012*      push af
041EB3             1013*  
041EB3             1014*  ; print the address and separator
041EB3 CD 2D 19 04 1015*      call printHex24
041EB7 3E 3A       1016*      ld a,':'
041EB9 5B D7       1017*      rst.lil 10h
041EBB 3E 20       1018*      ld a,' '
041EBD 5B D7       1019*      rst.lil 10h
041EBF             1020*  
041EBF             1021*  ; set b to be our loop counter
041EBF F1          1022*      pop af
041EC0 47          1023*      ld b,a
041EC1 E1          1024*      pop hl
041EC2 E5          1025*      push hl
041EC3 F5          1026*      push af
041EC4             1027*  @loop:
041EC4             1028*  ; print the byte
041EC4 7E          1029*      ld a,(hl)
041EC5 CD 3B 19 04 1030*      call printHex8
041EC9             1031*  ; print a space
041EC9 3E 20       1032*      ld a,' '
041ECB 5B D7       1033*      rst.lil 10h
041ECD 23          1034*      inc hl
041ECE 10 F4       1035*      djnz @loop
041ED0 CD 22 19 04 1036*      call printNewLine
041ED4             1037*  
041ED4             1038*  ; restore everything
041ED4 F1          1039*      pop af
041ED5 E1          1040*      pop hl
041ED6 C1          1041*      pop bc
041ED7             1042*  
041ED7             1043*  ; all done
041ED7 C9          1044*      ret
041ED8             1045*  
041ED8             1046*  
041ED8             1047*  ; print bytes from an address to the screen in binary format
041ED8             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041ED8             1049*  ; outputs: values of each byte printed to screen separated by spaces
041ED8             1050*  ; destroys: nothing
041ED8             1051*  dumpMemoryBin:
041ED8             1052*  ; save all registers to the stack
041ED8 F5          1053*      push af
041ED9 C5          1054*      push bc
041EDA D5          1055*      push de
041EDB E5          1056*      push hl
041EDC DD E5       1057*      push ix
041EDE FD E5       1058*      push iy
041EE0             1059*  
041EE0             1060*  ; set b to be our loop counter
041EE0 47          1061*      ld b,a
041EE1             1062*  @loop:
041EE1             1063*  ; print the byte
041EE1 7E          1064*      ld a,(hl)
041EE2 E5          1065*      push hl
041EE3 C5          1066*      push bc
041EE4 CD AB 1B 04 1067*      call printBin8
041EE8 C1          1068*      pop bc
041EE9             1069*  ; print a space
041EE9 3E 20       1070*      ld a,' '
041EEB 5B D7       1071*      rst.lil 10h
041EED E1          1072*      pop hl
041EEE 23          1073*      inc hl
041EEF 10 F0       1074*      djnz @loop
041EF1 CD 22 19 04 1075*      call printNewLine
041EF5             1076*  
041EF5             1077*  ; restore everything
041EF5 FD E1       1078*      pop iy
041EF7 DD E1       1079*      pop ix
041EF9 E1          1080*      pop hl
041EFA D1          1081*      pop de
041EFB C1          1082*      pop bc
041EFC F1          1083*      pop af
041EFD             1084*  ; all done
041EFD C9          1085*      ret
041EFE             1086*  
041EFE             1087*  ; print bytes from an address to the screen in binary format
041EFE             1088*  ; with the bits of each byte in reverse order (lsb first)
041EFE             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EFE             1090*  ; outputs: values of each byte printed to screen separated by spaces
041EFE             1091*  ; destroys: nothing
041EFE             1092*  dumpMemoryBinRev:
041EFE             1093*  ; save all registers to the stack
041EFE F5          1094*      push af
041EFF C5          1095*      push bc
041F00 D5          1096*      push de
041F01 E5          1097*      push hl
041F02 DD E5       1098*      push ix
041F04 FD E5       1099*      push iy
041F06             1100*  
041F06             1101*  ; set b to be our loop counter
041F06 47          1102*      ld b,a
041F07             1103*  @loop:
041F07             1104*  ; print the byte
041F07 7E          1105*      ld a,(hl)
041F08 E5          1106*      push hl
041F09 C5          1107*      push bc
041F0A CD D0 1B 04 1108*      call printBin8Rev
041F0E C1          1109*      pop bc
041F0F             1110*  ; print a space
041F0F 3E 20       1111*      ld a,' '
041F11 5B D7       1112*      rst.lil 10h
041F13 E1          1113*      pop hl
041F14 23          1114*      inc hl
041F15 10 F0       1115*      djnz @loop
041F17 CD 22 19 04 1116*      call printNewLine
041F1B             1117*  
041F1B             1118*  ; restore everything
041F1B FD E1       1119*      pop iy
041F1D DD E1       1120*      pop ix
041F1F E1          1121*      pop hl
041F20 D1          1122*      pop de
041F21 C1          1123*      pop bc
041F22 F1          1124*      pop af
041F23             1125*  ; all done
041F23 C9          1126*      ret
041F24             0053       include "vdu.inc"
041F24             0001*  
041F24             0002*  ; VDU 30: Home cursor
041F24             0003*  vdu_home_cursor:
041F24 3E 1E       0004*      ld a,30
041F26 5B D7       0005*  	rst.lil $10
041F28 C9          0006*  	ret
041F29             0007*  
041F29             0008*  vdu_cursor_on:
041F29 21 34 1F 04 0009*  	ld hl,@cmd
041F2D 01 03 00 00 0010*  	ld bc,@end-@cmd
041F31 5B DF       0011*  	rst.lil $18
041F33 C9          0012*  	ret
041F34             0013*  @cmd:
041F34 17 01 01    0014*  	db 23,1,1
041F37             0015*  @end:
041F37             0016*  
041F37             0017*  vdu_cursor_off:
041F37 21 42 1F 04 0018*  	ld hl,@cmd
041F3B 01 03 00 00 0019*  	ld bc,@end-@cmd
041F3F 5B DF       0020*  	rst.lil $18
041F41 C9          0021*  	ret
041F42             0022*  @cmd:
041F42 17 01 00    0023*  	db 23,1,0
041F45             0024*  @end:
041F45             0025*  
041F45             0026*  ; VDU 5: Write text at graphics cursor
041F45             0027*  ; inputs: a is the character to write to the screen
041F45             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041F45             0029*  ; outputs: see the name of the function
041F45             0030*  ; destroys: a, hl, bc
041F45             0031*  vdu_char_to_gfx_cursor:
041F45 32 55 1F 04 0032*  	ld (@arg),a
041F49 21 54 1F 04 0033*  	ld hl,@cmd
041F4D 01 02 00 00 0034*  	ld bc,@end-@cmd
041F51 5B DF       0035*  	rst.lil $18
041F53 C9          0036*  	ret
041F54 05          0037*  @cmd: db 5
041F55 00          0038*  @arg: db 0
041F56             0039*  @end:
041F56             0040*  ; VDU 9: Move cursor forward one character
041F56             0041*  vdu_cursor_forward:
041F56 3E 09       0042*      ld a,9
041F58 5B D7       0043*  	rst.lil $10
041F5A C9          0044*  	ret
041F5B             0045*  
041F5B             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041F5B             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041F5B             0048*  vdu_move_cursor:
041F5B ED 43 6C 1F 0049*      ld (@x0),bc
       04          
041F60 21 6B 1F 04 0050*  	ld hl,@cmd
041F64 01 03 00 00 0051*  	ld bc,@end-@cmd
041F68 5B DF       0052*  	rst.lil $18
041F6A C9          0053*  	ret
041F6B 1F          0054*  @cmd: 	db 31
041F6C 00          0055*  @x0:	db 0
041F6D 00          0056*  @y0: 	db 0
041F6E 00          0057*  @end: 	db 0 ; padding
041F6F             0058*  
041F6F             0059*  ; VDU 12: Clear text area (CLS)
041F6F             0060*  vdu_cls:
041F6F 3E 0C       0061*      ld a,12
041F71 5B D7       0062*  	rst.lil $10
041F73 C9          0063*  	ret
041F74             0064*  
041F74             0065*  vdu_flip:
041F74 21 7F 1F 04 0066*  	ld hl,@cmd
041F78 01 03 00 00 0067*  	ld bc,@end-@cmd
041F7C 5B DF       0068*  	rst.lil $18
041F7E C9          0069*  	ret
041F7F 17 00 C3    0070*  @cmd: db 23,0,0xC3
041F82             0071*  @end:
041F82             0072*  
041F82             0073*  ; VDU 16: Clear graphics area (CLG)
041F82             0074*  vdu_clg:
041F82 3E 10       0075*      ld a,16
041F84 5B D7       0076*  	rst.lil $10
041F86 C9          0077*  	ret
041F87             0078*  
041F87             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041F87             0080*  ; VDU 23, 7: Scrolling
041F87             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041F87             0082*  ; inputs: a, extent; l, direction; h; speed
041F87             0083*  vdu_scroll_down:
041F87 32 9C 1F 04 0084*  	ld (@extent),a
041F8B 22 9D 1F 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041F8F 21 9A 1F 04 0086*  	ld hl,@cmd
041F93 01 05 00 00 0087*  	ld bc,@end-@cmd
041F97 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041F99 C9          0089*  	ret
041F9A 17 07       0090*  @cmd:       db 23,7
041F9C 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041F9D 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041F9E 00          0093*  @speed:     db 0x00 ; pixels
041F9F 00          0094*  @end:		db 0x00 ; padding
041FA0             0095*  
041FA0             0096*  ; COLOUR MODES
041FA0             0097*  ; Mode	Effect
041FA0             0098*  ; 0	Set on-screen pixel to target colour value
041FA0             0099*  ; 1	OR value with the on-screen pixel
041FA0             0100*  ; 2	AND value with the on-screen pixel
041FA0             0101*  ; 3	XOR value with the on-screen pixel
041FA0             0102*  ; 4	Invert the on-screen pixel
041FA0             0103*  ; 5	No operation
041FA0             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041FA0             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041FA0             0106*  
041FA0             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041FA0             0108*  vdu_colour_text:
041FA0 32 B0 1F 04 0109*  	ld (@arg),a
041FA4 21 AF 1F 04 0110*  	ld hl,@cmd
041FA8 01 02 00 00 0111*  	ld bc,@end-@cmd
041FAC 5B DF       0112*  	rst.lil $18
041FAE C9          0113*  	ret
041FAF 11          0114*  @cmd: db 17
041FB0 00          0115*  @arg: db 0
041FB1             0116*  @end:
041FB1             0117*  
041FB1             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041FB1             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041FB1             0120*  vdu_gcol:
041FB1 32 C6 1F 04 0121*  	ld (@mode),a
041FB5 79          0122*      ld a,c
041FB6 32 C7 1F 04 0123*      ld (@col),a
041FBA 21 C5 1F 04 0124*  	ld hl,@cmd
041FBE 01 03 00 00 0125*  	ld bc,@end-@cmd
041FC2 5B DF       0126*  	rst.lil $18
041FC4 C9          0127*  	ret
041FC5 12          0128*  @cmd:  db 18
041FC6 00          0129*  @mode: db 0
041FC7 00          0130*  @col:  db 0
041FC8             0131*  @end:
041FC8             0132*  
041FC8             0133*  
041FC8             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041FC8             0135*  ; MIND THE LITTLE-ENDIANESS
041FC8             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041FC8             0137*  ; outputs; nothing
041FC8             0138*  ; destroys: a might make it out alive
041FC8             0139*  vdu_set_txt_viewport:
041FC8 ED 43 DE 1F 0140*      ld (@lb),bc
       04          
041FCD ED 53 E0 1F 0141*  	ld (@rt),de
       04          
041FD2 21 DD 1F 04 0142*  	ld hl,@cmd
041FD6 01 05 00 00 0143*  	ld bc,@end-@cmd
041FDA 5B DF       0144*  	rst.lil $18
041FDC C9          0145*  	ret
041FDD 1C          0146*  @cmd:   db 28 ; set text viewport command
041FDE 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041FE0 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041FE2 00          0149*  @end:   db 0x00	  ; padding
041FE3             0150*  
041FE3             0151*  ; Wait for VBLANK interrupt
041FE3             0152*  vdu_vblank:
041FE3 DD E5       0153*      PUSH 	IX
041FE5             0154*  	MOSCALL	mos_sysvars
041FE5 3E 08       0001*M 			LD	A, function
041FE7 5B CF       0002*M 			RST.LIL	08h
041FE9 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041FEC             0156*  @wait:
041FEC DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041FEF 28 FB       0158*      JR	Z, @wait
041FF1 DD E1       0159*      POP	IX
041FF3 C9          0160*      RET
041FF4             0161*  
041FF4             0162*  ; VDU 29, x; y;: Set graphics origin
041FF4             0163*  ; This command sets the graphics origin.
041FF4             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041FF4             0165*  ; inputs: bc=x0,de=y0
041FF4             0166*  ; outputs; nothing
041FF4             0167*  ; destroys: a might make it out alive
041FF4             0168*  vdu_set_gfx_origin:
041FF4 ED 43 0A 20 0169*      ld (@x0),bc
       04          
041FF9 ED 53 0C 20 0170*      ld (@y0),de
       04          
041FFE 21 09 20 04 0171*      ld hl,@cmd
042002 01 05 00 00 0172*      ld bc,@end-@cmd
042006 5B DF       0173*      rst.lil $18
042008 C9          0174*      ret
042009 1D          0175*  @cmd:   db 29 ; set graphics origin command
04200A 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
04200C 00 00       0177*  @y0: 	dw 0x0000 ; set by de
04200E 00          0178*  @end:   db 0x00	  ; padding
04200F             0179*  
04200F             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04200F             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04200F             0182*  ; 	because we have turned off logical screen scaling
04200F             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04200F             0184*  ; outputs; nothing
04200F             0185*  ; destroys: a might make it out alive
04200F             0186*  vdu_set_gfx_viewport:
04200F ED 43 2F 20 0187*      ld (@x0),bc
       04          
042014 FD 22 31 20 0188*      ld (@y1),iy
       04          
042019 DD 22 33 20 0189*  	ld (@x1),ix
       04          
04201E ED 53 35 20 0190*  	ld (@y0),de
       04          
042023 21 2E 20 04 0191*  	ld hl,@cmd
042027 01 09 00 00 0192*  	ld bc,@end-@cmd
04202B 5B DF       0193*  	rst.lil $18
04202D C9          0194*  	ret
04202E 18          0195*  @cmd:   db 24 ; set graphics viewport command
04202F 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
042031 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
042033 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
042035 00 00       0199*  @y0: 	dw 0x0000 ; set by de
042037 00          0200*  @end:   db 0x00	  ; padding
042038             0201*  
042038             0202*  ; SCREEN MODES
042038             0203*  ; ===============================
042038             0204*  ; Mode  Horz  Vert  Cols  Refresh
042038             0205*  ; ---   ----  ----  ----  -------
042038             0206*  ; 11    320   240   2     60hz
042038             0207*  ; 139   320   240   2     60hz
042038             0208*  ; 23    512   384   2     60hz
042038             0209*  ; 151   512   384   2     60hz
042038             0210*  ; 6     640   240   2     60hz
042038             0211*  ; 134   640   240   2     60hz
042038             0212*  ; 2     640   480   2     60hz
042038             0213*  ; 130   640   480   2     60hz
042038             0214*  ; 17    800   600   2     60hz
042038             0215*  ; 145   800   600   2     60hz
042038             0216*  ; 18    1024  768   2     60hz
042038             0217*  ; 146   1024  768   2     60hz
042038             0218*  ; ---   ----  ----  ----  -------
042038             0219*  ; 10    320   240   4     60hz
042038             0220*  ; 138   320   240   4     60hz
042038             0221*  ; 22    512   384   4     60hz
042038             0222*  ; 150   512   384   4     60hz
042038             0223*  ; 5     640   240   4     60hz
042038             0224*  ; 133   640   240   4     60hz
042038             0225*  ; 1     640   480   4     60hz
042038             0226*  ; 129   640   480   4     60hz
042038             0227*  ; 16    800   600   4     60hz
042038             0228*  ; 19    1024  768   4     60hz
042038             0229*  ; ---   ----  ----  ----  -------
042038             0230*  ; 9     320   240   16    60hz
042038             0231*  ; 137   320   240   16    60hz
042038             0232*  ; 21    512   384   16    60hz
042038             0233*  ; 149   512   384   16    60hz
042038             0234*  ; 4     640   240   16    60hz
042038             0235*  ; 132   640   240   16    60hz
042038             0236*  ; 0     640   480   16    60hz
042038             0237*  ; 7     n/a   n/a   16    60hz
042038             0238*  ; ---   ----  ----  ----  -------
042038             0239*  ; 8     320   240   64    60hz
042038             0240*  ; 136   320   240   64    60hz
042038             0241*  ; 20    512   384   64    60hz
042038             0242*  ; 3     640   240   64    60hz
042038             0243*  ; ---   ----  ----  ----  -------
042038             0244*  vdu_set_screen_mode:
042038 32 48 20 04 0245*  	ld (@arg),a
04203C 21 47 20 04 0246*  	ld hl,@cmd
042040 01 02 00 00 0247*  	ld bc,@end-@cmd
042044 5B DF       0248*  	rst.lil $18
042046 C9          0249*  	ret
042047 16          0250*  @cmd: db 22 ; set screen mode
042048 00          0251*  @arg: db 0  ; screen mode parameter
042049             0252*  @end:
042049             0253*  
042049             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
042049             0255*  ; inputs: a is scaling mode, 1=on, 0=off
042049             0256*  ; note: default setting on boot is scaling ON
042049             0257*  vdu_set_scaling:
042049 32 5B 20 04 0258*  	ld (@arg),a
04204D 21 58 20 04 0259*  	ld hl,@cmd
042051 01 04 00 00 0260*  	ld bc,@end-@cmd
042055 5B DF       0261*  	rst.lil $18
042057 C9          0262*  	ret
042058 17 00 C0    0263*  @cmd: db 23,0,0xC0
04205B 00          0264*  @arg: db 0  ; scaling on/off
04205C             0265*  @end:
04205C             0266*  
04205C             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04205C             0268*  ; inputs: hl=bufferId
04205C             0269*  vdu_buff_select:
04205C 22 6E 20 04 0270*  	ld (@bufferId),hl
042060 21 6B 20 04 0271*  	ld hl,@cmd
042064 01 05 00 00 0272*  	ld bc,@end-@cmd
042068 5B DF       0273*  	rst.lil $18
04206A C9          0274*  	ret
04206B 17 1B 20    0275*  @cmd: db 23,27,0x20
04206E 00 00       0276*  @bufferId: dw 0x0000
042070 00          0277*  @end: db 0x00 ; padding
042071             0278*  
042071             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
042071             0280*  ; inputs: a=format; bc=width; de=height
042071             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
042071             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
042071             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
042071             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
042071             0285*  ; 2 	Mono/Mask (1-bit per pixel)
042071             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
042071             0287*  vdu_bmp_create:
042071 ED 43 8D 20 0288*      ld (@width),bc
       04          
042076 ED 53 8F 20 0289*      ld (@height),de
       04          
04207B 32 91 20 04 0290*      ld (@fmt),a
04207F 21 8A 20 04 0291*  	ld hl,@cmd
042083 01 08 00 00 0292*  	ld bc,@end-@cmd
042087 5B DF       0293*  	rst.lil $18
042089 C9          0294*  	ret
04208A 17 1B 21    0295*  @cmd:       db 23,27,0x21
04208D 00 00       0296*  @width:     dw 0x0000
04208F 00 00       0297*  @height:    dw 0x0000
042091 00          0298*  @fmt:       db 0x00
042092             0299*  @end:
042092             0300*  
042092             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
042092             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
042092             0303*  vdu_load_img_rgba2_to_8:
042092             0304*  ; backup the target buffer id and image dimensions
042092 E5          0305*      push hl
042093 D5          0306*      push de
042094 C5          0307*      push bc
042095             0308*  ; load the rgba2 image to working buffer 65534
042095 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
042099 CD 9C 21 04 0310*  	call vdu_load_buffer_from_file
04209D             0311*  ; restore the image dimensions and target buffer id
04209D C1          0312*      pop bc
04209E D1          0313*      pop de
04209F E1          0314*      pop hl
0420A0             0315*  ; fall through to vdu_rgba2_to_8
0420A0             0316*  
0420A0             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0420A0             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0420A0             0319*  ; the "expand bitmap" command is:
0420A0             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420A0             0321*  ; and then to reverse the byte order to fix endian-ness:
0420A0             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420A0             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420A0             0324*  ; VDU 23,27,&20,targetBufferID%;
0420A0             0325*  ; VDU 23,27,&21,width%;height%;0
0420A0             0326*  ; -------------------------------------------------------------------
0420A0             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0420A0             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0420A0             0329*  vdu_rgba2_to_8:
0420A0             0330*  ; load the image dimensions and buffer id parameters
0420A0 ED 43 FC 20 0331*      ld (@width),bc
       04          
0420A5 ED 53 FE 20 0332*      ld (@height),de
       04          
0420AA 22 E1 20 04 0333*      ld (@bufferId0),hl
0420AE 22 EE 20 04 0334*      ld (@bufferId2),hl
0420B2 22 F7 20 04 0335*      ld (@bufferId1),hl
0420B6             0336*  ; clean up bytes that got stomped on by the ID loads
0420B6 3E 48       0337*      ld a,0x48
0420B8 32 E3 20 04 0338*      ld (@bufferId0+2),a
0420BC 3E 17       0339*      ld a,23
0420BE 32 F9 20 04 0340*      ld (@bufferId1+2),a
0420C2 3E 18       0341*      ld a,24
0420C4 32 F0 20 04 0342*      ld (@bufferId2+2),a
0420C8 AF          0343*      xor a
0420C9 32 00 21 04 0344*      ld (@height+2),a
0420CD             0345*  ; send the vdu command strings
0420CD 21 D8 20 04 0346*      ld hl,@beg
0420D1 01 29 00 00 0347*      ld bc,@end-@beg
0420D5 5B DF       0348*      rst.lil $18
0420D7 C9          0349*      ret
0420D8             0350*  @beg:
0420D8             0351*  ; Command 14: Consolidate blocks in a buffer
0420D8             0352*  ; VDU 23, 0, &A0, bufferId; 14
0420D8 17 00 A0    0353*      db 23,0,0xA0
0420DB FE FF       0354*      dw 65534 ; workingBufferId
0420DD 0E          0355*      db 14 ; consolidate blocks
0420DE             0356*  ; the "expand bitmap" command is:
0420DE             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420DE 17 00 A0    0358*      db 23,0,0xA0
0420E1 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
0420E3 48          0360*      db 0x48 ; given as decimal command 72 in the docs
0420E4 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0420E5 FE FF       0362*      dw 65534 ; sourceBufferId
0420E7 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0420EB             0364*  ; reverse the byte order to fix endian-ness:
0420EB             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
0420EB             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0420EB             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420EB 17 00 A0    0368*      db 23,0,0xA0
0420EE 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
0420F0 18          0370*      db 24 ; reverse byte order
0420F1 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0420F2 04 00       0372*      dw 4 ; size (4 bytes)
0420F4             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420F4             0374*  ; VDU 23,27,&20,targetBufferID%;
0420F4 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
0420F7 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
0420F9             0377*  ; VDU 23,27,&21,width%;height%;0
0420F9 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
0420FC 00 00       0379*  @width: dw 0x0000
0420FE 00 00       0380*  @height: dw 0x0000
042100 00          0381*      db 0x00 ; rgba8888 format
042101             0382*  @end:
042101             0383*  
042101             0384*  ; scratch variables
042101 00 00 00    0385*  bufferId0: dl 0x000000
042104 00 00 00    0386*  bufferId1: dl 0x000000
042107             0387*  
042107             0388*  ; load a vdu buffer from local memory
042107             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042107             0390*  vdu_load_buffer:
042107 ED 43 30 21 0391*      ld (@length),bc
       04          
04210C D5          0392*      push de ; save data pointer
04210D             0393*  ; send the vdu command string
04210D 7D          0394*      ld a,l
04210E 32 2D 21 04 0395*      ld (@bufferId),a
042112 7C          0396*      ld a,h
042113 32 2E 21 04 0397*      ld (@bufferId+1),a
042117 21 2A 21 04 0398*      ld hl,@cmd
04211B 01 08 00 00 0399*      ld bc,@end-@cmd
04211F 5B DF       0400*      rst.lil $18
042121             0401*  ; send the buffer data
042121 E1          0402*      pop hl ; pointer to data
042122 ED 4B 30 21 0403*      ld bc,(@length)
       04          
042127 5B DF       0404*      rst.lil $18 ; send it
042129 C9          0405*      ret
04212A             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04212A 17 00 A0    0407*  @cmd:       db 23,0,0xA0
04212D 00 00       0408*  @bufferId:	dw 0x0000
04212F 00          0409*  		    db 0 ; load buffer
042130 00 00       0410*  @length:	dw 0x0000
042132 00          0411*  @end: db 0 ; padding
042133             0412*  
042133             0413*  ; clear a buffer
042133             0414*  ; inputs: hl = bufferId
042133             0415*  vdu_clear_buffer:
042133 7D          0416*      ld a,l
042134 32 4B 21 04 0417*      ld (@bufferId),a
042138 7C          0418*      ld a,h
042139 32 4C 21 04 0419*      ld (@bufferId+1),a
04213D 21 48 21 04 0420*      ld hl,@cmd
042141 01 06 00 00 0421*      ld bc,@end-@cmd
042145 5B DF       0422*      rst.lil $18
042147 C9          0423*      ret
042148 17 00 A0    0424*  @cmd:       db 23,0,0xA0
04214B 00 00       0425*  @bufferId:	dw 0x0000
04214D 02          0426*  		    db 2 ; clear buffer
04214E             0427*  @end:
04214E             0428*  
04214E             0429*  vdu_clear_all_buffers:
04214E             0430*  ; clear all buffers
04214E 21 59 21 04 0431*      ld hl,@beg
042152 01 06 00 00 0432*      ld bc,@end-@beg
042156 5B DF       0433*      rst.lil $18
042158 C9          0434*      ret
042159 17 00 A0    0435*  @beg: db 23,0,$A0
04215C FF FF       0436*        dw -1 ; clear all buffers
04215E 02          0437*        db 2  ; command 2: clear a buffer
04215F             0438*  @end:
04215F             0439*  
04215F             0440*  ; Command 14: Consolidate blocks in a buffer
04215F             0441*  vdu_consolidate_buffer:
04215F             0442*  ; set parameters for vdu call
04215F 7D          0443*      ld a,l
042160 32 77 21 04 0444*      ld (@bufferId),a
042164 7C          0445*      ld a,h
042165 32 78 21 04 0446*      ld (@bufferId+1),a
042169 21 74 21 04 0447*      ld hl,@beg
04216D 01 06 00 00 0448*      ld bc,@end-@beg
042171 5B DF       0449*      rst.lil $18
042173 C9          0450*      ret
042174             0451*  ; VDU 23, 0, &A0, bufferId; 14
042174 17 00 A0    0452*  @beg: db 23,0,0xA0
042177 00 00       0453*  @bufferId: dw 0x0000
042179 0E          0454*             db 14
04217A             0455*  @end:
04217A             0456*  
04217A             0457*  ; load an image file to a buffer and make it a bitmap
04217A             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
04217A             0459*  vdu_load_img:
04217A             0460*  ; back up image type and dimension parameters
04217A 22 01 21 04 0461*      ld (bufferId0),hl
04217E F5          0462*      push af
04217F C5          0463*  	push bc
042180 D5          0464*  	push de
042181             0465*  ; load the image
042181 CD 9C 21 04 0466*  	call vdu_load_buffer_from_file
042185             0467*  ; now make it a bitmap
042185 2A 01 21 04 0468*      ld hl,(bufferId0)
042189 CD 5F 21 04 0469*      call vdu_consolidate_buffer
04218D 2A 01 21 04 0470*      ld hl,(bufferId0)
042191 CD 5C 20 04 0471*      call vdu_buff_select
042195 D1          0472*  	pop de ; image height
042196 C1          0473*  	pop bc ; image width
042197 F1          0474*  	pop af ; image type
042198 C3 71 20 04 0475*  	jp vdu_bmp_create ; will return to caller from there
04219C             0476*  
04219C             0477*  ; inputs: hl = bufferId; iy = pointer to filename
04219C             0478*  vdu_load_buffer_from_file:
04219C 22 01 21 04 0479*      ld (bufferId0),hl
0421A0             0480*  
0421A0             0481*  ; clear target buffer
0421A0 CD 33 21 04 0482*      call vdu_clear_buffer
0421A4             0483*  
0421A4             0484*  ; open the file in read mode
0421A4             0485*  ; Open a file
0421A4             0486*  ; HLU: Filename
0421A4             0487*  ;   C: Mode
0421A4             0488*  ; Returns:
0421A4             0489*  ;   A: Filehandle, or 0 if couldn't open
0421A4 FD E5       0490*  	push iy ; pointer to filename
0421A6 E1          0491*  	pop hl
0421A7 0E 01       0492*  	ld c,fa_read
0421A9             0493*      MOSCALL mos_fopen
0421A9 3E 0A       0001*M 			LD	A, function
0421AB 5B CF       0002*M 			RST.LIL	08h
0421AD 32 E8 21 04 0494*      ld (@filehandle),a
0421B1             0495*  
0421B1             0496*  @read_file:
0421B1             0497*  ; Read a block of data from a file
0421B1             0498*  ;   C: Filehandle
0421B1             0499*  ; HLU: Pointer to where to write the data to
0421B1             0500*  ; DEU: Number of bytes to read
0421B1             0501*  ; Returns:
0421B1             0502*  ; DEU: Number of bytes read
0421B1 3A E8 21 04 0503*      ld a,(@filehandle)
0421B5 4F          0504*      ld c,a
0421B6 21 00 E0 B7 0505*      ld hl,filedata
0421BA 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0421BE             0507*      MOSCALL mos_fread
0421BE 3E 1A       0001*M 			LD	A, function
0421C0 5B CF       0002*M 			RST.LIL	08h
0421C2             0508*  
0421C2             0509*  ; test de for zero bytes read
0421C2 21 00 00 00 0510*      ld hl,0
0421C6 AF          0511*      xor a ; clear carry
0421C7 ED 52       0512*      sbc hl,de
0421C9 CA DF 21 04 0513*      jp z,@close_file
0421CD             0514*  
0421CD             0515*  ; load a vdu buffer from local memory
0421CD             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0421CD 2A 01 21 04 0517*      ld hl,(bufferId0)
0421D1 D5          0518*      push de ; chunksize
0421D2 C1          0519*      pop bc
0421D3 11 00 E0 B7 0520*      ld de,filedata
0421D7 CD 07 21 04 0521*      call vdu_load_buffer
0421DB             0522*  
0421DB             0523*  ; read the next block
0421DB C3 B1 21 04 0524*      jp @read_file
0421DF             0525*  
0421DF             0526*  ; close the file
0421DF             0527*  @close_file:
0421DF 3A E8 21 04 0528*      ld a,(@filehandle)
0421E3             0529*      MOSCALL mos_fclose
0421E3 3E 0B       0001*M 			LD	A, function
0421E5 5B CF       0002*M 			RST.LIL	08h
0421E7 C9          0530*      ret ; vdu_load_buffer_from_file
0421E8             0531*  
0421E8 00          0532*  @filehandle: db 0 ; file handle
0421E9 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
0421EC             0534*  
0421EC 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
0421EF             0536*  
0421EF             0537*  ; File information structure (FILINFO)
0421EF             0538*  @filinfo:
0421EF 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0421F3 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0421F5 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0421F7 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0421F8 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042205 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042305             0054       include "vdu_plot.inc"
042305             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042305             0002*  ; PLOT code 	(Decimal) 	Effect
042305             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
042305             0004*  plot_sl_both: equ 0x00
042305             0005*  
042305             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
042305             0007*  plot_sl_first: equ 0x08
042305             0008*  
042305             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
042305             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
042305             0011*  
042305             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
042305             0013*  plot_sl_last: equ 0x20
042305             0014*  
042305             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
042305             0016*  plot_sl_none: equ 0x28
042305             0017*  
042305             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
042305             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
042305             0020*  
042305             0021*  ; &40-&47 	64-71 	Point plot
042305             0022*  plot_pt: equ 0x40
042305             0023*  
042305             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
042305             0025*  plot_lf_lr_non_bg: equ 0x48
042305             0026*  
042305             0027*  ; &50-&57 	80-87 	Triangle fill
042305             0028*  plot_tf: equ 0x50
042305             0029*  
042305             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
042305             0031*  plot_lf_r_bg: equ 0x58
042305             0032*  
042305             0033*  ; &60-&67 	96-103 	Rectangle fill
042305             0034*  plot_rf: equ 0x60
042305             0035*  
042305             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
042305             0037*  plot_lf_lr_fg: equ 0x60
042305             0038*  
042305             0039*  ; &70-&77 	112-119 	Parallelogram fill
042305             0040*  plot_pf: equ 0x70
042305             0041*  
042305             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
042305             0043*  plot_lf_r_non_fg: equ 0x78
042305             0044*  
042305             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
042305             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
042305             0047*  
042305             0048*  ; &90-&97 	144-151 	Circle outline
042305             0049*  plot_co: equ 0x90
042305             0050*  
042305             0051*  ; &98-&9F 	152-159 	Circle fill
042305             0052*  plot_cf: equ 0x98
042305             0053*  
042305             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
042305             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
042305             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
042305             0057*  
042305             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
042305             0059*  plot_rcm: equ 0xB8
042305             0060*  
042305             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
042305             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
042305             0063*  ; &D0-&D7 	208-215 	Not defined
042305             0064*  ; &D8-&DF 	216-223 	Not defined
042305             0065*  ; &E0-&E7 	224-231 	Not defined
042305             0066*  
042305             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
042305             0068*  plot_bmp: equ 0xE8
042305             0069*  
042305             0070*  ; &F0-&F7 	240-247 	Not defined
042305             0071*  ; &F8-&FF 	248-255 	Not defined
042305             0072*  
042305             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
042305             0074*  ; Agon Console8 VDP 2.2.0
042305             0075*  
042305             0076*  ; Within each group of eight plot codes, the effects are as follows:
042305             0077*  ; Plot code 	Effect
042305             0078*  ; 0 	Move relative
042305             0079*  mv_rel: equ 0
042305             0080*  
042305             0081*  ; 1 	Plot relative in current foreground colour
042305             0082*  dr_rel_fg: equ 1
042305             0083*  
042305             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
042305             0085*  ; 3 	Plot relative in current background colour
042305             0086*  dr_rel_bg: equ 3
042305             0087*  
042305             0088*  ; 4 	Move absolute
042305             0089*  mv_abs: equ 4
042305             0090*  
042305             0091*  ; 5 	Plot absolute in current foreground colour
042305             0092*  dr_abs_fg: equ 5
042305             0093*  
042305             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
042305             0095*  ; 7 	Plot absolute in current background colour
042305             0096*  dr_abs_bg: equ 7
042305             0097*  
042305             0098*  ; Codes 0-3 use the position data provided as part of the command
042305             0099*  ; as a relative position, adding the position given to the current
042305             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
042305             0101*  ; as part of the command as an absolute position, setting the current
042305             0102*  ; graphical cursor position to the position given.
042305             0103*  
042305             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
042305             0105*  ; current pixel colour. These operations cannot currently be supported
042305             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
042305             0107*  ; supported. Support for these codes may be added in a future version
042305             0108*  ; of the VDP firmware.
042305             0109*  
042305             0110*  ; 16 colour palette constants
042305             0111*  c_black: equ 0
042305             0112*  c_red_dk: equ 1
042305             0113*  c_green_dk: equ 2
042305             0114*  c_yellow_dk: equ 3
042305             0115*  c_blue_dk: equ 4
042305             0116*  c_magenta_dk: equ 5
042305             0117*  c_cyan_dk: equ 6
042305             0118*  c_grey: equ 7
042305             0119*  c_grey_dk: equ 8
042305             0120*  c_red: equ 9
042305             0121*  c_green: equ 10
042305             0122*  c_yellow: equ 11
042305             0123*  c_blue: equ 12
042305             0124*  c_magenta: equ 13
042305             0125*  c_cyan: equ 14
042305             0126*  c_white: equ 15
042305             0127*  
042305             0128*  ; VDU 25, mode, x; y;: PLOT command
042305             0129*  ; inputs: a=mode, bc=x0, de=y0
042305             0130*  vdu_plot:
042305 32 1F 23 04 0131*      ld (@mode),a
042309 ED 43 20 23 0132*      ld (@x0),bc
       04          
04230E ED 53 22 23 0133*      ld (@y0),de
       04          
042313 21 1E 23 04 0134*  	ld hl,@cmd
042317 01 06 00 00 0135*  	ld bc,@end-@cmd
04231B 5B DF       0136*  	rst.lil $18
04231D C9          0137*  	ret
04231E 19          0138*  @cmd:   db 25
04231F 00          0139*  @mode:  db 0
042320 00 00       0140*  @x0: 	dw 0
042322 00 00       0141*  @y0: 	dw 0
042324 00          0142*  @end:   db 0 ; extra byte to soak up deu
042325             0143*  
042325             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042325             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
042325             0146*  ; VDU 25, mode, x; y;: PLOT command
042325             0147*  ; inputs: bc=x0, de=y0
042325             0148*  ; prerequisites: vdu_buff_select
042325             0149*  vdu_plot_bmp:
042325 ED 43 3C 23 0150*      ld (@x0),bc
       04          
04232A ED 53 3E 23 0151*      ld (@y0),de
       04          
04232F 21 3A 23 04 0152*  	ld hl,@cmd
042333 01 06 00 00 0153*  	ld bc,@end-@cmd
042337 5B DF       0154*  	rst.lil $18
042339 C9          0155*  	ret
04233A 19          0156*  @cmd:   db 25
04233B ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04233C 00 00       0158*  @x0: 	dw 0x0000
04233E 00 00       0159*  @y0: 	dw 0x0000
042340 00          0160*  @end:   db 0x00 ; padding
042341             0161*  
042341             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042341             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
042341             0164*  ; VDU 25, mode, x; y;: PLOT command
042341             0165*  ; inputs: bc=x0, de=y0
042341             0166*  ; USING 16.8 FIXED POINT COORDINATES
042341             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042341             0168*  ;   the fractional portiion of the inputs are truncated
042341             0169*  ;   leaving only the 16-bit integer portion
042341             0170*  ; prerequisites: vdu_buff_select
042341             0171*  vdu_plot_bmp168:
042341             0172*  ; populate in the reverse of normal to keep the
042341             0173*  ; inputs from stomping on each other
042341 ED 53 5F 23 0174*      ld (@y0-1),de
       04          
042346 ED 43 5D 23 0175*      ld (@x0-1),bc
       04          
04234B 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
04234D 32 5D 23 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
042351 21 5C 23 04 0178*  	ld hl,@cmd
042355 01 06 00 00 0179*  	ld bc,@end-@cmd
042359 5B DF       0180*  	rst.lil $18
04235B C9          0181*  	ret
04235C 19          0182*  @cmd:   db 25
04235D ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04235E 00 00       0184*  @x0: 	dw 0x0000
042360 00 00       0185*  @y0: 	dw 0x0000
042362             0186*  @end:  ; no padding required b/c we shifted de right
042362             0187*  
042362             0188*  ; draw a filled rectangle
042362             0189*  vdu_plot_rf:
042362 ED 43 89 23 0190*      ld (@x0),bc
       04          
042367 ED 53 8B 23 0191*      ld (@y0),de
       04          
04236C DD 22 8F 23 0192*      ld (@x1),ix
       04          
042371 FD 22 91 23 0193*      ld (@y1),iy
       04          
042376 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
042378 32 8D 23 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04237C 21 87 23 04 0196*  	ld hl,@cmd0
042380 01 0C 00 00 0197*  	ld bc,@end-@cmd0
042384 5B DF       0198*  	rst.lil $18
042386 C9          0199*      ret
042387 19          0200*  @cmd0:  db 25 ; plot
042388 04          0201*  @arg0:  db plot_sl_both+mv_abs
042389 00 00       0202*  @x0:    dw 0x0000
04238B 00 00       0203*  @y0:    dw 0x0000
04238D 19          0204*  @cmd1:  db 25 ; plot
04238E 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04238F 00 00       0206*  @x1:    dw 0x0000
042391 00 00       0207*  @y1:    dw 0x0000
042393 00          0208*  @end:   db 0x00 ; padding
042394             0209*  
042394             0210*  ; draw a filled circle
042394             0211*  vdu_plot_cf:
042394 ED 43 BB 23 0212*      ld (@x0),bc
       04          
042399 ED 53 BD 23 0213*      ld (@y0),de
       04          
04239E DD 22 C1 23 0214*      ld (@x1),ix
       04          
0423A3 FD 22 C3 23 0215*      ld (@y1),iy
       04          
0423A8 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0423AA 32 BF 23 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0423AE 21 B9 23 04 0218*  	ld hl,@cmd0
0423B2 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0423B6 5B DF       0220*  	rst.lil $18
0423B8 C9          0221*      ret
0423B9 19          0222*  @cmd0:  db 25 ; plot
0423BA 04          0223*  @arg0:  db plot_sl_both+mv_abs
0423BB 00 00       0224*  @x0:    dw 0x0000
0423BD 00 00       0225*  @y0:    dw 0x0000
0423BF 19          0226*  @cmd1:  db 25 ; plot
0423C0 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0423C1 00 00       0228*  @x1:    dw 0x0000
0423C3 00 00       0229*  @y1:    dw 0x0000
0423C5 00          0230*  @end:   db 0x00 ; padding
0423C6             0055   	include "vdu_sprites.inc"
0423C6             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
0423C6             0002*  ; the VDP can support up to 256 sprites. They must be defined
0423C6             0003*  ; contiguously, and so the first sprite is sprite 0.
0423C6             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
0423C6             0005*  ; Once a selection of sprites have been defined, you can activate
0423C6             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
0423C6             0007*  ; of sprites to activate. This will activate the first n sprites,
0423C6             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
0423C6             0009*  
0423C6             0010*  ; A single sprite can have multiple "frames", referring to
0423C6             0011*  ; different bitmaps.
0423C6             0012*  ; (These bitmaps do not need to be the same size.)
0423C6             0013*  ; This allows a sprite to include an animation sequence,
0423C6             0014*  ; which can be stepped through one frame at a time, or picked
0423C6             0015*  ; in any order.
0423C6             0016*  
0423C6             0017*  ; Any format of bitmap can be used as a sprite frame. It should
0423C6             0018*  ; be noted however that "native" format bitmaps are not
0423C6             0019*  ; recommended for use as sprite frames, as they cannot get
0423C6             0020*  ; erased from the screen. (As noted above, the "native" bitmap
0423C6             0021*  ; format is not really intended for general use.) This is part
0423C6             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
0423C6             0023*  ; screen are now stored in RGBA2222 format.
0423C6             0024*  
0423C6             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
0423C6             0026*  ; and then later shown again.
0423C6             0027*  
0423C6             0028*  ; Moving sprites around the screen is done by changing the
0423C6             0029*  ; position of the sprite. This can be done either by setting
0423C6             0030*  ; the absolute position of the sprite, or by moving the sprite
0423C6             0031*  ; by a given number of pixels. (Sprites are positioned using
0423C6             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
0423C6             0033*  ; In the current sprite system, sprites will not update their
0423C6             0034*  ; position on-screen until either another drawing operation is
0423C6             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
0423C6             0036*  
0423C6             0037*  ; VDU 23, 27, 4, n: Select sprite n
0423C6             0038*  ; inputs: a is the 8-bit sprite id
0423C6             0039*  vdu_sprite_select:
0423C6 32 D8 23 04 0040*      ld (@sprite),a
0423CA 21 D5 23 04 0041*      ld hl,@cmd
0423CE 01 04 00 00 0042*      ld bc,@end-@cmd
0423D2 5B DF       0043*      rst.lil $18
0423D4 C9          0044*      ret
0423D5 17 1B 04    0045*  @cmd:    db 23,27,4
0423D8 00          0046*  @sprite: db 0x00
0423D9             0047*  @end:
0423D9             0048*  
0423D9             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
0423D9             0050*  ; inputs: none
0423D9             0051*  ; prerequisites: vdu_sprite_select
0423D9             0052*  vdu_sprite_clear_frames:
0423D9 21 E4 23 04 0053*      ld hl,@cmd
0423DD 01 03 00 00 0054*      ld bc,@end-@cmd
0423E1 5B DF       0055*      rst.lil $18
0423E3 C9          0056*      ret
0423E4 17 1B 05    0057*  @cmd: db 23,27,5
0423E7             0058*  @end:
0423E7             0059*  
0423E7             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0423E7             0061*  ; inputs: a is the 8-bit bitmap number
0423E7             0062*  ; prerequisites: vdu_sprite_select
0423E7             0063*  vdu_sprite_add_bmp:
0423E7 32 F9 23 04 0064*      ld (@bmp),a
0423EB 21 F6 23 04 0065*      ld hl,@cmd
0423EF 01 04 00 00 0066*      ld bc,@end-@cmd
0423F3 5B DF       0067*      rst.lil $18
0423F5 C9          0068*      ret
0423F6 17 1B 06    0069*  @cmd: db 23,27,6
0423F9 00          0070*  @bmp: db 0x00
0423FA             0071*  @end:
0423FA             0072*  
0423FA             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0423FA             0074*  ; inputs: a is the number of sprites to activate
0423FA             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0423FA             0076*  vdu_sprite_activate:
0423FA 32 0C 24 04 0077*      ld (@num),a
0423FE 21 09 24 04 0078*      ld hl,@cmd
042402 01 04 00 00 0079*      ld bc,@end-@cmd
042406 5B DF       0080*      rst.lil $18
042408 C9          0081*      ret
042409 17 1B 07    0082*  @cmd: db 23,27,7
04240C 00          0083*  @num: db 0x00
04240D             0084*  @end:
04240D             0085*  
04240D             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
04240D             0087*  ; inputs: none
04240D             0088*  ; prerequisites: vdu_sprite_select
04240D             0089*  vdu_sprite_next_frame:
04240D 21 18 24 04 0090*      ld hl,@cmd
042411 01 03 00 00 0091*      ld bc,@end-@cmd
042415 5B DF       0092*      rst.lil $18
042417 C9          0093*      ret
042418 17 1B 08    0094*  @cmd: db 23,27,8
04241B             0095*  @end:
04241B             0096*  
04241B             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04241B             0098*  ; inputs: none
04241B             0099*  ; prerequisites: vdu_sprite_select
04241B             0100*  vdu_sprite_prev_frame:
04241B 21 26 24 04 0101*      ld hl,@cmd
04241F 01 03 00 00 0102*      ld bc,@end-@cmd
042423 5B DF       0103*      rst.lil $18
042425 C9          0104*      ret
042426 17 1B 09    0105*  @cmd: db 23,27,9
042429             0106*  @end:
042429             0107*  
042429             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
042429             0109*  ; inputs: a is frame number to select
042429             0110*  ; prerequisites: vdu_sprite_select
042429             0111*  vdu_sprite_select_frame:
042429 32 3B 24 04 0112*      ld (@frame),a
04242D 21 38 24 04 0113*      ld hl,@cmd
042431 01 04 00 00 0114*      ld bc,@end-@cmd
042435 5B DF       0115*      rst.lil $18
042437 C9          0116*      ret
042438 17 1B 0A    0117*  @cmd:    db 23,27,10
04243B 00          0118*  @frame:  db 0x00
04243C             0119*  @end:
04243C             0120*  
04243C             0121*  ; VDU 23, 27, 11: Show current sprite
04243C             0122*  ; inputs: none
04243C             0123*  ; prerequisites: vdu_sprite_select
04243C             0124*  vdu_sprite_show:
04243C 21 47 24 04 0125*      ld hl,@cmd
042440 01 03 00 00 0126*      ld bc,@end-@cmd
042444 5B DF       0127*      rst.lil $18
042446 C9          0128*      ret
042447 17 1B 0B    0129*  @cmd: db 23,27,11
04244A             0130*  @end:
04244A             0131*  
04244A             0132*  ; VDU 23, 27, 12: Hide current sprite
04244A             0133*  ; inputs: none
04244A             0134*  ; prerequisites: vdu_sprite_select
04244A             0135*  vdu_sprite_hide:
04244A 21 55 24 04 0136*      ld hl,@cmd
04244E 01 03 00 00 0137*      ld bc,@end-@cmd
042452 5B DF       0138*      rst.lil $18
042454 C9          0139*      ret
042455 17 1B 0C    0140*  @cmd: db 23,27,12
042458             0141*  @end:
042458             0142*  
042458             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042458             0144*  ; inputs: bc is x coordinate, de is y coordinate
042458             0145*  ; prerequisites: vdu_sprite_select
042458             0146*  vdu_sprite_move_abs:
042458 ED 43 70 24 0147*      ld (@xpos),bc
       04          
04245D ED 53 72 24 0148*      ld (@ypos),de
       04          
042462 21 6D 24 04 0149*      ld hl,@cmd
042466 01 07 00 00 0150*      ld bc,@end-@cmd
04246A 5B DF       0151*      rst.lil $18
04246C C9          0152*      ret
04246D 17 1B 0D    0153*  @cmd:  db 23,27,13
042470 00 00       0154*  @xpos: dw 0x0000
042472 00 00       0155*  @ypos: dw 0x0000
042474 00          0156*  @end:  db 0x00 ; padding
042475             0157*  
042475             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042475             0159*  ; inputs: bc is x coordinate, de is y coordinate
042475             0160*  ; prerequisites: vdu_sprite_select
042475             0161*  vdu_sprite_move_rel:
042475 ED 43 8D 24 0162*      ld (@dx),bc
       04          
04247A ED 53 8F 24 0163*      ld (@dy),de
       04          
04247F 21 8A 24 04 0164*      ld hl,@cmd
042483 01 07 00 00 0165*      ld bc,@end-@cmd
042487 5B DF       0166*      rst.lil $18
042489 C9          0167*      ret
04248A 17 1B 0E    0168*  @cmd: db 23,27,14
04248D 00 00       0169*  @dx:  dw 0x0000
04248F 00 00       0170*  @dy:  dw 0x0000
042491 00          0171*  @end: db 0x00 ; padding
042492             0172*  
042492             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042492             0174*  ; USING 16.8 FIXED POINT COORDINATES
042492             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042492             0176*  ;   the fractional portiion of the inputs are truncated
042492             0177*  ;   leaving only the 16-bit integer portion
042492             0178*  ; prerequisites: vdu_sprite_select
042492             0179*  vdu_sprite_move_abs168:
042492             0180*  ; offset inputs by the gfx origin
042492             0181*  ; y coordinate
042492 21 00 30 00 0182*      ld hl,origin_top*256
042496 19          0183*      add hl,de
042497 22 B9 24 04 0184*      ld (@ypos-1),hl
04249B             0185*  ; x coordinate
04249B 21 00 80 00 0186*      ld hl,origin_left*256
04249F 09          0187*      add hl,bc
0424A0 22 B7 24 04 0188*      ld (@xpos-1),hl
0424A4             0189*  ; prepare vdu command
0424A4 3E 0D       0190*      ld a,13       ; restore the final byte of the command
0424A6 32 B7 24 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
0424AA 21 B5 24 04 0192*      ld hl,@cmd
0424AE 01 07 00 00 0193*      ld bc,@end-@cmd
0424B2 5B DF       0194*      rst.lil $18
0424B4 C9          0195*      ret
0424B5 17 1B 0D    0196*  @cmd:  db 23,27,13
0424B8 00 00       0197*  @xpos: dw 0x0000
0424BA 00 00       0198*  @ypos: dw 0x0000
0424BC             0199*  @end:  ; no padding required b/c we shifted de right
0424BC             0200*  
0424BC             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0424BC             0202*  ; USING 16.8 FIXED POINT COORDINATES
0424BC             0203*  ; inputs: ub.c is dx, ud.e is dy
0424BC             0204*  ;   the fractional portiion of the inputs are truncated
0424BC             0205*  ;   leaving only the 16-bit integer portion
0424BC             0206*  ; prerequisites: vdu_sprite_select
0424BC             0207*  vdu_sprite_move_rel168:
0424BC             0208*  ; populate in the reverse of normal to keep the
0424BC             0209*  ; inputs from stomping on each other
0424BC ED 53 DB 24 0210*      ld (@dy-1),de
       04          
0424C1 ED 43 D9 24 0211*      ld (@dx-1),bc
       04          
0424C6 3E 0E       0212*      ld a,14       ; restore the final byte of the command
0424C8 32 D9 24 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
0424CC 21 D7 24 04 0214*      ld hl,@cmd
0424D0 01 07 00 00 0215*      ld bc,@end-@cmd
0424D4 5B DF       0216*      rst.lil $18
0424D6 C9          0217*      ret
0424D7 17 1B 0E    0218*  @cmd:  db 23,27,14
0424DA 00 00       0219*  @dx: dw 0x0000
0424DC 00 00       0220*  @dy: dw 0x0000
0424DE             0221*  @end:  ; no padding required b/c we shifted de right
0424DE             0222*  
0424DE             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
0424DE             0224*  ; inputs: none
0424DE             0225*  vdu_sprite_update:
0424DE 21 E9 24 04 0226*      ld hl,@cmd
0424E2 01 03 00 00 0227*      ld bc,@end-@cmd
0424E6 5B DF       0228*      rst.lil $18
0424E8 C9          0229*      ret
0424E9 17 1B 0F    0230*  @cmd: db 23,27,15
0424EC             0231*  @end:
0424EC             0232*  
0424EC             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0424EC             0234*  ; inputs: none
0424EC             0235*  vdu_sprite_bmp_reset:
0424EC 21 F7 24 04 0236*      ld hl,@cmd
0424F0 01 03 00 00 0237*      ld bc,@end-@cmd
0424F4 5B DF       0238*      rst.lil $18
0424F6 C9          0239*      ret
0424F7 17 1B 10    0240*  @cmd: db 23,27,16
0424FA             0241*  @end:
0424FA             0242*  
0424FA             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0424FA             0244*  ; inputs: none
0424FA             0245*  vdu_sprite_reset:
0424FA 21 05 25 04 0246*      ld hl,@cmd
0424FE 01 03 00 00 0247*      ld bc,@end-@cmd
042502 5B DF       0248*      rst.lil $18
042504 C9          0249*      ret
042505 17 1B 11    0250*  @cmd: db 23,27,17
042508             0251*  @end:
042508             0252*  
042508             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042508             0254*  ; inputs: a is the GCOL paint mode
042508             0255*  ; prerequisites: vdu_sprite_select
042508             0256*  vdu_sprite_set_gcol:
042508 32 1A 25 04 0257*      ld (@mode),a
04250C 21 17 25 04 0258*      ld hl,@cmd
042510 01 04 00 00 0259*      ld bc,@end-@cmd
042514 5B DF       0260*      rst.lil $18
042516 C9          0261*      ret
042517 17 1B 12    0262*  @cmd:  db 23,27,18
04251A 00          0263*  @mode: db 0x00
04251B             0264*  @end:
04251B             0265*  
04251B             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
04251B             0267*  ; inputs: hl=bufferId
04251B             0268*  ; prerequisites: vdu_sprite_select
04251B             0269*  vdu_sprite_add_buff:
04251B 22 2D 25 04 0270*      ld (@bufferId),hl
04251F 21 2A 25 04 0271*      ld hl,@cmd
042523 01 05 00 00 0272*      ld bc,@end-@cmd
042527 5B DF       0273*      rst.lil $18
042529 C9          0274*      ret
04252A 17 1B 26    0275*  @cmd:      db 23,27,0x26
04252D 00 00       0276*  @bufferId: dw 0x0000
04252F 00          0277*  @end:      db 0x00 ; padding
042530             0056   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
042530             0057   	include "maths.inc"
042530             0001*  ; test the sign of HL
042530             0002*  ; inputs: HL obviously
042530             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
042530             0004*  ; destroys: flags
042530             0005*      MACRO sign_hlu
042530             0006*          add hl,de
042530             0007*          or a
042530             0008*          sbc hl,de
042530             0009*      ENDMACRO
042530             0010*  
042530             0011*  
042530             0012*  ;------------------------------------------------------------------------
042530             0013*  ; Scratch area for calculations
042530             0014*  ;------------------------------------------------------------------------
042530 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
042533 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
042536             0017*  
042536             0018*  ; absolute value of hlu
042536             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
042536             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
042536             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
042536             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
042536             0023*  ; destroys: a
042536             0024*  hlu_abs:
042536 19          0025*      add hl,de
042537 B7          0026*      or a
042538 ED 52       0027*      sbc hl,de
04253A FA 3F 25 04 0028*      jp m,@is_neg
04253E C9          0029*      ret         ; hlu is positive or zero so we're done
04253F             0030*  @is_neg:
04253F F5          0031*      push af     ; otherwise, save current flags for return
042540 CD 46 25 04 0032*      call neg_hlu ; negate hlu
042544 F1          0033*      pop af      ; get back flags
042545 C9          0034*      ret
042546             0035*  
042546             0036*  ; flip the sign of hlu
042546             0037*  ; inputs: hlu
042546             0038*  ; returns: 0-hlu, flags set appropriately for the result:
042546             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
042546             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
042546             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
042546             0042*  ; destroys a
042546             0043*  neg_hlu:
042546 D5          0044*      push de     ; save de
042547 EB          0045*      ex de,hl    ; put hl into de
042548 21 00 00 00 0046*      ld hl,0     ; clear hl
04254C AF          0047*      xor a       ; clear carry
04254D ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
04254F D1          0049*      pop de      ; get de back
042550 C9          0050*      ret         ; easy peasy
042551             0051*  
042551             0052*  ;------------------------------------------------------------------------
042551             0053*  ; divide hlu by 2, inspired by above
042551             0054*  ;------------------------------------------------------------------------
042551             0055*  hlu_div2:
042551 22 30 25 04 0056*  	ld		(scratch1),hl
042555 21 32 25 04 0057*  	ld		hl,scratch1+2
042559 CB 1E       0058*  	rr		(hl)
04255B 2B          0059*  	dec		hl
04255C CB 1E       0060*  	rr		(hl)
04255E 2B          0061*  	dec		hl
04255F CB 1E       0062*  	rr		(hl)
042561 23          0063*  	inc		hl
042562 23          0064*  	inc		hl
042563 2A 30 25 04 0065*      ld hl,(scratch1)
042567 C9          0066*      ret
042568             0067*  
042568             0068*  ; this is my little hack to divide by 16
042568             0069*  hlu_div16:
042568 AF          0070*      xor a
042569 29          0071*      add hl,hl
04256A 17          0072*      rla
04256B 29          0073*      add hl,hl
04256C 17          0074*      rla
04256D 29          0075*      add hl,hl
04256E 17          0076*      rla
04256F 29          0077*      add hl,hl
042570 17          0078*      rla
042571 22 7E 25 04 0079*      ld (@scratch),hl
042575 32 81 25 04 0080*      ld (@scratch+3),a
042579 2A 7F 25 04 0081*      ld hl,(@scratch+1)
04257D C9          0082*      ret
04257E             0083*  @scratch: ds 4
042582             0084*  
042582             0085*  ; hlu signed division by 256
042582             0086*  ; returns: hlu / 256
042582             0087*  ; destroys: af
042582             0088*  hlu_sdiv256:
042582 AF          0089*      xor a ; assume hl is positive
042583 22 99 25 04 0090*      ld (@buffer),hl
042587             0091*      sign_hlu
042587 19          0001*M         add hl,de
042588 B7          0002*M         or a
042589 ED 52       0003*M         sbc hl,de
04258B F2 90 25 04 0092*      jp p,@hl_pos
04258F 3D          0093*      dec a
042590             0094*  @hl_pos:
042590 32 9C 25 04 0095*      ld (@buffer+3),a
042594 2A 9A 25 04 0096*      ld hl,(@buffer+1)
042598 C9          0097*      ret
042599             0098*  @buffer: ds 4
04259D             0099*  
04259D             0100*  ; hlu 1 byte right shift, unsigned
04259D             0101*  ; returns: hlu / 256, fractional portion in a
04259D             0102*  ; destroys: af
04259D             0103*  hlu_udiv256:
04259D AF          0104*  	xor a
04259E 32 AF 25 04 0105*  	ld (@buffer+3),a
0425A2 7D          0106*  	ld a,l ; save the fractional portion
0425A3 22 AC 25 04 0107*  	ld (@buffer),hl
0425A7 2A AD 25 04 0108*  	ld hl,(@buffer+1)
0425AB C9          0109*  	ret
0425AC             0110*  @buffer: ds 4
0425B0             0111*  
0425B0             0112*      MACRO hlu_mul256
0425B0             0113*          add hl,hl ; * 2
0425B0             0114*          add hl,hl ; * 4
0425B0             0115*          add hl,hl ; * 8
0425B0             0116*          add hl,hl ; * 16
0425B0             0117*          add hl,hl ; * 32
0425B0             0118*          add hl,hl ; * 64
0425B0             0119*          add hl,hl ; * 128
0425B0             0120*          add hl,hl ; * 256
0425B0             0121*      ENDMACRO
0425B0             0122*  
0425B0             0123*  ; compute the modulo of hlu by deu
0425B0             0124*  ; outputs: hlu = hlu % deu
0425B0             0125*  ; destroys: f, hl
0425B0             0126*  hlu_mod:
0425B0 B7          0127*  	or a ; clear carry
0425B1             0128*  @loop:
0425B1 ED 52       0129*      sbc hl,de
0425B3 DA BB 25 04 0130*      jp c, @end
0425B7 C3 B1 25 04 0131*      jp @loop
0425BB             0132*  @end:
0425BB 19          0133*      add hl,de
0425BC C9          0134*  	ret
0425BD             0135*  
0425BD             0136*  
0425BD 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
0425C1 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
0425C5             0139*  
0425C5             0140*  ; set bcd values in a scratch memory address from registers bcde
0425C5             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
0425C5             0142*  ; destroys ; hl
0425C5             0143*  set_bcd:
0425C5 73          0144*      ld (hl),e
0425C6 23          0145*      inc hl
0425C7 72          0146*      ld (hl),d
0425C8 23          0147*      inc hl
0425C9 71          0148*      ld (hl),c
0425CA 23          0149*      inc hl
0425CB 70          0150*      ld (hl),b
0425CC C9          0151*      ret
0425CD             0152*  
0425CD             0153*  ; load bcd values from a scratch memory address to bcde
0425CD             0154*  ; input: hl; scratch address
0425CD             0155*  ; output: bcde; 8-place bcd number
0425CD             0156*  ; destroys: hl
0425CD             0157*  get_bcd:
0425CD 5E          0158*      ld e,(hl)
0425CE 23          0159*      inc hl
0425CF 56          0160*      ld d,(hl)
0425D0 23          0161*      inc hl
0425D1 4E          0162*      ld c,(hl)
0425D2 23          0163*      inc hl
0425D3 46          0164*      ld b,(hl)
0425D4 C9          0165*      ret
0425D5             0166*  
0425D5             0167*  ; BCD addition
0425D5             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425D5             0169*  ;       a is the number of bytes holding each number (number of places/2)
0425D5             0170*  ; outputs: (hl) + (de) --> (hl)
0425D5             0171*  ; destroys: a,b,de,hl
0425D5             0172*  add_bcd:
0425D5 47          0173*      ld b,a ; loop counter
0425D6 AF          0174*      xor a ; reset a, clear carry flag
0425D7             0175*  adcec:
0425D7 1A          0176*      ld a,(de) ; addend to acc
0425D8 8E          0177*      adc a,(hl) ; add (hl) to acc
0425D9 27          0178*      daa ; adjust result to bcd
0425DA 77          0179*      ld (hl),a ; store result
0425DB 23          0180*      inc hl ; advance memory pointers
0425DC 13          0181*      inc de
0425DD 10 F8       0182*      djnz adcec ; loop until b == 0
0425DF C9          0183*      ret
0425E0             0184*  
0425E0             0185*  ; BCD subtraction
0425E0             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425E0             0187*  ;       a is the number of bytes holding each number (number of places/2)
0425E0             0188*  ; outputs: (hl) - (de) --> (hl)
0425E0             0189*  ; destroys: a,b,de,hl
0425E0             0190*  sub_bcd:
0425E0 47          0191*      ld b,a ; loop counter
0425E1 AF          0192*      xor a ; reset a,clear carry flag
0425E2             0193*  subdec:
0425E2 1A          0194*      ld a,(de) ; subtrahend to acc
0425E3 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0425E4 27          0196*      daa ; adjust result to bcd
0425E5 77          0197*      ld (hl),a ; store result
0425E6 23          0198*      inc hl ; advance memory pointers
0425E7 13          0199*      inc de
0425E8 10 F8       0200*      djnz subdec ; loop until b == 0
0425EA C9          0201*      ret
0425EB             0202*  
0425EB             0203*  ; http://www.z80.info/pseudo-random.txt
0425EB             0204*  rand_8:
0425EB C5          0205*      push bc
0425EC 3A FF 25 04 0206*      ld a,(r_seed)
0425F0 4F          0207*      ld c,a
0425F1             0208*  
0425F1 0F          0209*      rrca ; multiply by 32
0425F2 0F          0210*      rrca
0425F3 0F          0211*      rrca
0425F4 EE 1F       0212*      xor 0x1f
0425F6             0213*  
0425F6 81          0214*      add a,c
0425F7 DE FF       0215*      sbc a,255 ; carry
0425F9             0216*  
0425F9 32 FF 25 04 0217*      ld (r_seed),a
0425FD C1          0218*      pop bc
0425FE C9          0219*      ret
0425FF 50          0220*  r_seed: defb $50
042600             0221*  
042600             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
042600             0223*  prng24:
042600             0224*  ;;Expects ADL mode.
042600             0225*  ;;Output: HL
042600             0226*  ;;50cc
042600             0227*  ;;33 bytes
042600             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
042600 ED 5B 21 26 0229*      ld de,(seed1)
       04          
042605 B7          0230*      or a
042606 ED 62       0231*      sbc hl,hl
042608 19          0232*      add hl,de
042609 29          0233*      add hl,hl
04260A 29          0234*      add hl,hl
04260B 2C          0235*      inc l
04260C 19          0236*      add hl,de
04260D 22 21 26 04 0237*      ld (seed1),hl
042611 2A 24 26 04 0238*      ld hl,(seed2)
042615 29          0239*      add hl,hl
042616 9F          0240*      sbc a,a
042617 E6 1B       0241*      and %00011011
042619 AD          0242*      xor l
04261A 6F          0243*      ld l,a
04261B 22 24 26 04 0244*      ld (seed2),hl
04261F 19          0245*      add hl,de
042620 C9          0246*      ret
042621 00 00 00    0247*  seed1: dl 0
042624 00 00 00    0248*  seed2: dl 0
042627             0058   	include "trig24fast.inc"
042627             0001*  
042627             0002*  ; convert signed angles from a 360 to 256 degree circle
042627             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
042627             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
042627             0005*  ; destroys: TODO
042627             0006*  deg_360_to_256:
042627 D5          0007*  	push de ; preserve de
042628             0008*  ; make angle positive and store sign flag
042628 CD 36 25 04 0009*  	call hlu_abs
04262C F5          0010*  	push af
04262D             0011*  ; multiply by 256 first to keep precision
04262D             0012*  	hlu_mul256 ; uh.l = uh.l * 256
04262D 29          0001*M         add hl,hl ; * 2
04262E 29          0002*M         add hl,hl ; * 4
04262F 29          0003*M         add hl,hl ; * 8
042630 29          0004*M         add hl,hl ; * 16
042631 29          0005*M         add hl,hl ; * 32
042632 29          0006*M         add hl,hl ; * 64
042633 29          0007*M         add hl,hl ; * 128
042634 29          0008*M         add hl,hl ; * 256
042635             0013*  ; divide uh.l by 360
042635 11 68 01 00 0014*  	ld de,360
042639 CD 1B 30 04 0015*  	call udiv24 ; ud.e = degrees / 360
04263D EB          0016*  	ex de,hl    ; uh.l = degrees / 360
04263E             0017*  ; restore sign flag and adjust output accordingly
04263E F1          0018*  	pop af
04263F F2 47 26 04 0019*  	jp p,@pos ; positive number
042643 CD 46 25 04 0020*  	call neg_hlu
042647             0021*  @pos:
042647             0022*  ; restore de and return uh.l as the result
042647 D1          0023*  	pop de
042648 C9          0024*  	ret
042649             0025*  
042649             0026*  ; fixed 16.8 routine
042649             0027*  ; cos(uh.l) --> uh.l
042649             0028*  ; destroys: f, hl
042649             0029*  cos168:
042649 D5          0030*      push de ; preserve de
04264A             0031*  ; for cos we simply increment the angle by 90 degrees
04264A             0032*  ; or 0x004000 in 16.8 degrees256
04264A             0033*  ; which makes it a sin problem
04264A 11 00 40 00 0034*      ld de,0x004000
04264E 19          0035*      add hl,de ; modulo 256 happens below
04264F D1          0036*      pop de ; restore de
042650             0037*  ; fall through to sin168
042650             0038*  
042650             0039*  ; ---------------------
042650             0040*  ; fixed 16.8 routine
042650             0041*  ; sin(uh.l) --> uh.l
042650             0042*  ; destroys: f, hl
042650             0043*  sin168:
042650 D5          0044*  	push de
042651             0045*  ; handle negative angles appropriately
042651 CD 36 25 04 0046*  	call hlu_abs
042655 F2 5E 26 04 0047*  	jp p,@F
042659 11 00 00 FF 0048*  	ld de,-256*256
04265D 19          0049*  	add hl,de
04265E             0050*  @@:
04265E 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
042660 ED 6C       0052*      mlt hl
042662 11 98 28 04 0053*      ld de,sin_lut_168 ; grab the lut address
042666 19          0054*      add hl,de ; bump hl by the index
042667 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
042669 D1          0056*      pop de
04266A C9          0057*      ret
04266B             0058*  
04266B             0059*  ; 16.8 fixed inputs / outputs
04266B             0060*  ; takes: uh.l as angle in degrees 256
04266B             0061*  ;        ud.e as radius
04266B             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
04266B             0063*  ;        displacements from origin (0,0)
04266B             0064*  ; destroys: everything except indexes
04266B             0065*  polar_to_cartesian:
04266B             0066*  ; back up input parameters
04266B 22 9A 26 04 0067*      ld (@angle), hl
04266F ED 53 9D 26 0068*      ld (@radius), de
       04          
042674             0069*  ; compute dx = sin(uh.l) * ud.e
042674 CD 50 26 04 0070*      call sin168 ; uh.l = sin(uh.l)
042678 ED 5B 9D 26 0071*  	ld de,(@radius)
       04          
04267D CD 90 2F 04 0072*  	call smul168 ; uh.l = dx
042681 E5          0073*      push hl
042682             0074*  ; compute dy = -cos(uh.l) * ud.e
042682 2A 9A 26 04 0075*      ld hl,(@angle)
042686 CD 49 26 04 0076*      call cos168 ; uh.l = cos(uh.l)
04268A ED 5B 9D 26 0077*      ld de,(@radius)
       04          
04268F CD 90 2F 04 0078*      call smul168    ; uh.l = dy
042693 CD 46 25 04 0079*      call neg_hlu ; invert dy for screen coords convention
042697 EB          0080*      ex de,hl       ; de = dy for output
042698 C1          0081*      pop bc          ; bc = dx for output
042699             0082*  ; and out
042699 C9          0083*      ret
04269A             0084*  @angle: ds 3
04269D             0085*  @radius: ds 3
0426A0             0086*  
0426A0             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0426A0             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0426A0             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0426A0             0090*  ;         also populates scratch locations dx168 and dy168
0426A0             0091*  ; destroys: a,hl,bc,de
0426A0             0092*  dxy168:
0426A0             0093*  ; compute dx = x1-x0
0426A0 AF          0094*      xor a ; clear carry
0426A1 DD E5       0095*      push ix ; move ix to hl via the stack
0426A3 E1          0096*      pop hl ; hl = x1
0426A4 ED 42       0097*      sbc hl,bc ; hl = dx
0426A6 22 BB 26 04 0098*      ld (dx168),hl ; dx to scratch
0426AA             0099*  ; compute dy = y1-y0
0426AA AF          0100*      xor a ; clear carry
0426AB FD E5       0101*      push iy ; move iy to hl via the stack
0426AD E1          0102*      pop hl ; hl = y1
0426AE ED 52       0103*      sbc hl,de ; hl = dy
0426B0 22 C1 26 04 0104*      ld (dy168),hl ; dy to scratch
0426B4             0105*  ; populate output registers and return
0426B4 EB          0106*      ex de,hl        ; ud.e = dy
0426B5 ED 4B BB 26 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
0426BA C9          0108*      ret
0426BB 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
0426C1 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
0426C7             0111*  
0426C7             0112*  ; compute the euclidian distance between two cartesian coordinates
0426C7             0113*  ; using the formula d = sqrt(dx^2+dy^2
0426C7             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0426C7             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0426C7             0116*  ; output; uh.l is the 16.8 fixed format distance
0426C7             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
0426C7             0118*  ; destroys: a,hl,bc,de
0426C7             0119*  distance168:
0426C7 CD A0 26 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
0426CB             0121*  ; compute dy^2
0426CB EB          0122*  	ex de,hl
0426CC CD 36 25 04 0123*  	call hlu_abs
0426D0 E5          0124*  	push hl
0426D1 D1          0125*  	pop de
0426D2 CD 87 2F 04 0126*  	call umul168 ; hl = dy^2
0426D6 E5          0127*  	push hl ; save dy^2
0426D7             0128*  ; compute dx^2
0426D7 2A BB 26 04 0129*  	ld hl,(dx168)
0426DB CD 36 25 04 0130*  	call hlu_abs
0426DF E5          0131*  	push hl
0426E0 D1          0132*  	pop de
0426E1 CD 87 2F 04 0133*  	call umul168 ; hl = dx^2
0426E5             0134*  ; add dx^2 and dy^2
0426E5 D1          0135*  	pop de ; de = dy^2
0426E6 19          0136*  	add hl,de ; hl = dx^2 + dy^2
0426E7             0137*  ; compute the square root
0426E7 CD AD 27 04 0138*  	call sqrt168
0426EB C9          0139*  	ret
0426EC             0140*  
0426EC             0141*  ; atan2_(ub.c,ud.e) --> uh.l
0426EC             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0426EC             0143*  ;   whether inputs are integers or fractional doesn't matter
0426EC             0144*  ;   so long as the sign bit of the upper byte is correct
0426EC             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0426EC             0146*  ; angles are COMPASS HEADINGS based on
0426EC             0147*  ; screen coordinate conventions,where the y axis is flipped
0426EC             0148*  ; #E0 315      0       45 #20
0426EC             0149*  ;        -x,-y | +x,-y
0426EC             0150*  ; #C0 270------+------ 90 #40
0426EC             0151*  ;        -x,+y | +x,+y
0426EC             0152*  ; #A0 225   180 #80   135 #60
0426EC             0153*  atan2_168fast:
0426EC             0154*  ; get signs and make everything positive
0426EC             0155*  ; get abs(x) and store its original sign
0426EC C5          0156*      push bc
0426ED E1          0157*      pop hl
0426EE CD 36 25 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
0426F2 E5          0159*      push hl ; store abs(x)
0426F3 C1          0160*      pop bc ; bc = abs(x)
0426F4 F5          0161*      push af ; store sign of x
0426F5             0162*  ; get abs(y) and store its original sign
0426F5 EB          0163*      ex de,hl ; hl = y
0426F6 CD 36 25 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
0426FA EB          0165*      ex de,hl ; de = abs(y)
0426FB F5          0166*      push af ; store sign of y
0426FC             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0426FC             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
0426FC AF          0169*      xor a ; clear the carry flag
0426FD D5          0170*      push de
0426FE E1          0171*      pop hl
0426FF ED 42       0172*      sbc hl,bc
042701 F5          0173*      push af ; save sign of de - bc
042702 F2 0B 27 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
042706             0175*  ; otherwise we swap bc and de
042706 C5          0176*      push bc
042707 E1          0177*      pop hl
042708 EB          0178*      ex de,hl
042709 E5          0179*      push hl
04270A C1          0180*      pop bc
04270B             0181*  @1:
04270B             0182*  ; now we're ready to snag our preliminary result
04270B C5          0183*  	push bc
04270C E1          0184*  	pop hl
04270D CD 7B 27 04 0185*      call atan_168fast ; uh.l comes back with prelim result
042711             0186*  ; now we adjust uh.l based on sign of de - bc
042711 F1          0187*      pop af
042712 F2 1E 27 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
042716 EB          0189*      ex de,hl
042717 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
04271B AF          0191*      xor a ; clear the carry flag
04271C ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
04271E             0193*  @2:
04271E             0194*  ; now the fun part of adjusting the result
04271E             0195*  ; based on which quadrant (x,y) is in
04271E             0196*  ; #E0 315      0       45 #20
04271E             0197*  ;        -x,-y | +x,-y
04271E             0198*  ; #C0 270------+------ 90 #40
04271E             0199*  ;        -x,+y | +x,+y
04271E             0200*  ; #A0 225   180 #80   135 #60
04271E F1          0201*      pop af ; sign of y
04271F CA 5C 27 04 0202*      jp z,@y_zero
042723 F2 3C 27 04 0203*      jp p,@y_pos
042727             0204*  ; y neg,check x
042727 F1          0205*      pop af ; sign of x
042728 CA 36 27 04 0206*      jp z,@y_neg_x_zero
04272C F2 3B 27 04 0207*      jp p,@y_neg_x_pos
042730             0208*  ; y neg,x neg
042730             0209*  ; angle is 270-360
042730             0210*  ; negating the intermediate does the trick
042730 CD 46 25 04 0211*      call neg_hlu
042734 18 31       0212*      jr @zero_hlu
042736             0213*  
042736             0214*  @y_neg_x_zero:
042736             0215*  ; y neg,x zero
042736             0216*  ; angle is 0
042736 21 00 00 00 0217*      ld hl,0
04273A C9          0218*      ret
04273B             0219*  @y_neg_x_pos:
04273B             0220*  ; y neg,x pos
04273B             0221*  ; angle is 0 to 90
04273B             0222*  ; so we're good
04273B C9          0223*      ret
04273C             0224*  
04273C             0225*  @y_pos:
04273C F1          0226*      pop af ; sign of x
04273D CA 4C 27 04 0227*      jp z,@y_pos_x_zero
042741 F2 51 27 04 0228*      jp p,@y_pos_x_pos
042745             0229*  ; y pos,x neg
042745             0230*  ; angle is 180-270
042745             0231*  ; so we add 180 to intermediate
042745 11 00 80 00 0232*      ld de,0x008000
042749 19          0233*      add hl,de
04274A 18 1B       0234*      jr @zero_hlu
04274C             0235*  @y_pos_x_zero:
04274C             0236*  ; y pos,x zero
04274C             0237*  ; angle is 180
04274C 21 00 80 00 0238*      ld hl,0x008000
042750 C9          0239*      ret
042751             0240*  @y_pos_x_pos:
042751             0241*  ; y pos,x pos
042751             0242*  ; angle is 90-180
042751             0243*  ; neg the intermediate and add 180 degrees
042751 CD 46 25 04 0244*      call neg_hlu
042755 11 00 80 00 0245*      ld de,0x008000
042759 19          0246*      add hl,de
04275A 18 0B       0247*      jr @zero_hlu
04275C             0248*  
04275C             0249*  @y_zero:
04275C F1          0250*      pop af ; sign of x
04275D FA 62 27 04 0251*      jp m,@y_zero_x_neg
042761             0252*  ; y zero,x pos
042761             0253*  ; angle is 90,nothing to do
042761 C9          0254*      ret
042762             0255*  @y_zero_x_neg:
042762             0256*  ; y zero ,x neg
042762             0257*  ; angle is 270
042762 21 00 C0 00 0258*      ld hl,0x00C000
042766 C9          0259*      ret
042767             0260*  @zero_hlu:
042767 AF          0261*      xor a
042768 22 75 27 04 0262*      ld (@scratch),hl
04276C 32 77 27 04 0263*      ld (@scratch+2),a
042770 2A 75 27 04 0264*      ld hl,(@scratch)
042774 C9          0265*      ret
042775             0266*  @scratch: ds 6
04277B             0267*  
04277B             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04277B             0269*  ; output: uh.l is the 16.8 fixed format angle
04277B             0270*  ; destroys: a,hl,bc,de
04277B             0271*  ; the following note was written by github copilot:
04277B             0272*  ; note: this routine is a bit of a hack
04277B             0273*  ;      but it works
04277B             0274*  ;      and it's fast
04277B             0275*  ;      and it's small
04277B             0276*  ;      and it's accurate
04277B             0277*  ;      and it's easy to understand
04277B             0278*  ;      and it's easy to modify
04277B             0279*  ;      and it's easy to use
04277B             0280*  ;      and it's easy to remember
04277B             0281*  ;      and it's easy to love
04277B             0282*  ;      and it's easy to hate
04277B             0283*  ;      and it's easy to ignore
04277B             0284*  ;      and it's easy to forget
04277B             0285*  ;      and it's easy to remember
04277B             0286*  ;      and it's easy to forget
04277B             0287*  ;      and it's easy to remember
04277B             0288*  ;      (ok the bot is stuck in a loop)
04277B             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
04277B             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
04277B             0291*  atan_168fast:
04277B             0292*  ; because we use compass headings instead of geometric angles
04277B             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
04277B             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
04277B CD B3 2F 04 0295*  	call udiv168 ; ud.e = dx/dy
04277F EB          0296*  	ex de,hl ; uh.l = dx/dy
042780             0297*  ; test uh.l for 0
042780 19          0298*      add hl,de
042781 B7          0299*      or a
042782 ED 52       0300*      sbc hl,de
042784 28 22       0301*      jr z,@is_zero
042786             0302*  ; test uh.l for 1
042786 AF          0303*      xor a ; clear carry
042787 EB          0304*      ex de,hl
042788 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
04278C ED 52       0306*      sbc hl,de
04278E 28 13       0307*      jr z,@is_45
042790 EB          0308*  	ex de,hl
042791             0309*  ; no special cases so we move on
042791             0310*  ; l contains the fractional portion of tan(uh.l)
042791             0311*  ; we multiply it by three to get our lookup table index
042791 26 03       0312*      ld h,3
042793 ED 6C       0313*      mlt hl ; gosh that is handy
042795 11 00 00 00 0314*      ld de,0 ; clear deu
042799 54          0315*      ld d,h ; copy hl to de
04279A 5D          0316*      ld e,l ; de contains our index
04279B 21 9B 2B 04 0317*      ld hl,atan_lut_168 ; grab the lut address
04279F 19          0318*      add hl,de ; bump hl by the index
0427A0 ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
0427A2 C9          0320*      ret ; and out
0427A3             0321*  @is_45:
0427A3 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
0427A7 C9          0323*      ret
0427A8             0324*  ; for the case tan(0)
0427A8             0325*  @is_zero:
0427A8 21 00 00 00 0326*      ld hl,0x000000
0427AC C9          0327*      ret
0427AD             0328*  
0427AD             0329*  ; Expects  ADL mode
0427AD             0330*  ; Inputs:  UH.L
0427AD             0331*  ; Outputs: UH.L is the 16.8 square root
0427AD             0332*  ;          UD.E is the difference inputHL-DE^2
0427AD             0333*  ;          c flag reset
0427AD             0334*  sqrt168:
0427AD CD B7 27 04 0335*      call sqrt24
0427B1 EB          0336*      ex de,hl
0427B2 29          0337*      add hl,hl
0427B3 29          0338*      add hl,hl
0427B4 29          0339*      add hl,hl
0427B5 29          0340*      add hl,hl
0427B6 C9          0341*      ret
0427B7             0342*  
0427B7             0343*  ; Expects  ADL mode
0427B7             0344*  ; Inputs:  HL
0427B7             0345*  ; Outputs: DE is the integer square root
0427B7             0346*  ;          HL is the difference inputHL-DE^2
0427B7             0347*  ;          c flag reset
0427B7             0348*  sqrt24:
0427B7 AF          0349*      xor a
0427B8 45          0350*      ld b,l
0427B9 C5          0351*      push bc
0427BA 47          0352*      ld b,a
0427BB 57          0353*      ld d,a
0427BC 4F          0354*      ld c,a
0427BD 6F          0355*      ld l,a
0427BE 5F          0356*      ld e,a
0427BF             0357*  
0427BF             0358*      ;Iteration 1
0427BF 29          0359*      add hl,hl
0427C0 CB 11       0360*      rl c
0427C2 29          0361*      add hl,hl
0427C3 CB 11       0362*      rl c
0427C5 91          0363*      sub c
0427C6 30 04       0364*      jr nc,$+6
0427C8 1C          0365*      inc e
0427C9 1C          0366*      inc e
0427CA 2F          0367*      cpl
0427CB 4F          0368*      ld c,a
0427CC             0369*  
0427CC             0370*      ;Iteration 2
0427CC 29          0371*      add hl,hl
0427CD CB 11       0372*      rl c
0427CF 29          0373*      add hl,hl
0427D0 CB 11       0374*      rl c
0427D2 CB 13       0375*      rl e
0427D4 7B          0376*      ld a,e
0427D5 91          0377*      sub c
0427D6 30 04       0378*      jr nc,$+6
0427D8 1C          0379*      inc e
0427D9 1C          0380*      inc e
0427DA 2F          0381*      cpl
0427DB 4F          0382*      ld c,a
0427DC             0383*  
0427DC             0384*      ;Iteration 3
0427DC 29          0385*      add hl,hl
0427DD CB 11       0386*      rl c
0427DF 29          0387*      add hl,hl
0427E0 CB 11       0388*      rl c
0427E2 CB 13       0389*      rl e
0427E4 7B          0390*      ld a,e
0427E5 91          0391*      sub c
0427E6 30 04       0392*      jr nc,$+6
0427E8 1C          0393*      inc e
0427E9 1C          0394*      inc e
0427EA 2F          0395*      cpl
0427EB 4F          0396*      ld c,a
0427EC             0397*  
0427EC             0398*      ;Iteration 4
0427EC 29          0399*      add hl,hl
0427ED CB 11       0400*      rl c
0427EF 29          0401*      add hl,hl
0427F0 CB 11       0402*      rl c
0427F2 CB 13       0403*      rl e
0427F4 7B          0404*      ld a,e
0427F5 91          0405*      sub c
0427F6 30 04       0406*      jr nc,$+6
0427F8 1C          0407*      inc e
0427F9 1C          0408*      inc e
0427FA 2F          0409*      cpl
0427FB 4F          0410*      ld c,a
0427FC             0411*  
0427FC             0412*      ;Iteration 5
0427FC 29          0413*      add hl,hl
0427FD CB 11       0414*      rl c
0427FF 29          0415*      add hl,hl
042800 CB 11       0416*      rl c
042802 CB 13       0417*      rl e
042804 7B          0418*      ld a,e
042805 91          0419*      sub c
042806 30 04       0420*      jr nc,$+6
042808 1C          0421*      inc e
042809 1C          0422*      inc e
04280A 2F          0423*      cpl
04280B 4F          0424*      ld c,a
04280C             0425*  
04280C             0426*      ;Iteration 6
04280C 29          0427*      add hl,hl
04280D CB 11       0428*      rl c
04280F 29          0429*      add hl,hl
042810 CB 11       0430*      rl c
042812 CB 13       0431*      rl e
042814 7B          0432*      ld a,e
042815 91          0433*      sub c
042816 30 04       0434*      jr nc,$+6
042818 1C          0435*      inc e
042819 1C          0436*      inc e
04281A 2F          0437*      cpl
04281B 4F          0438*      ld c,a
04281C             0439*  
04281C             0440*      ;Iteration 7
04281C 29          0441*      add hl,hl
04281D CB 11       0442*      rl c
04281F 29          0443*      add hl,hl
042820 CB 11       0444*      rl c
042822 CB 10       0445*      rl b
042824 EB          0446*      ex de,hl
042825 29          0447*      add hl,hl
042826 E5          0448*      push hl
042827 ED 42       0449*      sbc hl,bc
042829 30 06       0450*      jr nc,$+8
04282B 7C          0451*      ld a,h
04282C 2F          0452*      cpl
04282D 47          0453*      ld b,a
04282E 7D          0454*      ld a,l
04282F 2F          0455*      cpl
042830 4F          0456*      ld c,a
042831 E1          0457*      pop hl
042832 30 02       0458*      jr nc,$+4
042834 23          0459*      inc hl
042835 23          0460*      inc hl
042836 EB          0461*      ex de,hl
042837             0462*  
042837             0463*      ;Iteration 8
042837 29          0464*      add hl,hl
042838 69          0465*      ld l,c
042839 60          0466*      ld h,b
04283A ED 6A       0467*      adc hl,hl
04283C ED 6A       0468*      adc hl,hl
04283E EB          0469*      ex de,hl
04283F 29          0470*      add hl,hl
042840 ED 52       0471*      sbc hl,de
042842 19          0472*      add hl,de
042843 EB          0473*      ex de,hl
042844 30 04       0474*      jr nc,$+6
042846 ED 52       0475*      sbc hl,de
042848 13          0476*      inc de
042849 13          0477*      inc de
04284A             0478*  
04284A             0479*      ;Iteration 9
04284A F1          0480*      pop af
04284B 17          0481*      rla
04284C ED 6A       0482*      adc hl,hl
04284E 17          0483*      rla
04284F ED 6A       0484*      adc hl,hl
042851 EB          0485*      ex de,hl
042852 29          0486*      add hl,hl
042853 ED 52       0487*      sbc hl,de
042855 19          0488*      add hl,de
042856 EB          0489*      ex de,hl
042857 30 04       0490*      jr nc,$+6
042859 ED 52       0491*      sbc hl,de
04285B 13          0492*      inc de
04285C 13          0493*      inc de
04285D             0494*  
04285D             0495*      ;Iteration 10
04285D 17          0496*      rla
04285E ED 6A       0497*      adc hl,hl
042860 17          0498*      rla
042861 ED 6A       0499*      adc hl,hl
042863 EB          0500*      ex de,hl
042864 29          0501*      add hl,hl
042865 ED 52       0502*      sbc hl,de
042867 19          0503*      add hl,de
042868 EB          0504*      ex de,hl
042869 30 04       0505*      jr nc,$+6
04286B ED 52       0506*      sbc hl,de
04286D 13          0507*      inc de
04286E 13          0508*      inc de
04286F             0509*  
04286F             0510*      ;Iteration 11
04286F 17          0511*      rla
042870 ED 6A       0512*      adc hl,hl
042872 17          0513*      rla
042873 ED 6A       0514*      adc hl,hl
042875 EB          0515*      ex de,hl
042876 29          0516*      add hl,hl
042877 ED 52       0517*      sbc hl,de
042879 19          0518*      add hl,de
04287A EB          0519*      ex de,hl
04287B 30 04       0520*      jr nc,$+6
04287D ED 52       0521*      sbc hl,de
04287F 13          0522*      inc de
042880 13          0523*      inc de
042881             0524*  
042881             0525*      ;Iteration 11
042881 17          0526*      rla
042882 ED 6A       0527*      adc hl,hl
042884 17          0528*      rla
042885 ED 6A       0529*      adc hl,hl
042887 EB          0530*      ex de,hl
042888 29          0531*      add hl,hl
042889 ED 52       0532*      sbc hl,de
04288B 19          0533*      add hl,de
04288C EB          0534*      ex de,hl
04288D 30 04       0535*      jr nc,$+6
04288F ED 52       0536*      sbc hl,de
042891 13          0537*      inc de
042892 13          0538*      inc de
042893             0539*  
042893 CB 1A       0540*      rr d
042895 CB 1B       0541*      rr e
042897 C9          0542*      ret
042898             0543*  
042898             0544*  sin_lut_168:
042898 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
04289B 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
04289E 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
0428A1 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
0428A4 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
0428A7 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
0428AA 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
0428AD 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
0428B0 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
0428B3 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
0428B6 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
0428B9 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
0428BC 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
0428BF 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
0428C2 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
0428C5 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
0428C8 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
0428CB 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
0428CE 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
0428D1 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
0428D4 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
0428D7 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
0428DA 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
0428DD 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
0428E0 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
0428E3 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
0428E6 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
0428E9 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
0428EC A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
0428EF A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
0428F2 AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
0428F5 B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
0428F8 B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
0428FB B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
0428FE BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
042901 C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
042904 C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
042907 C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
04290A CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
04290D D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
042910 D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
042913 D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
042916 DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
042919 DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
04291C E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
04291F E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
042922 E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
042925 EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
042928 EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
04292B EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
04292E F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
042931 F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
042934 F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
042937 F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
04293A F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
04293D F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
042940 FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
042943 FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
042946 FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
042949 FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
04294C FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
04294F FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
042952 FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
042955 FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
042958 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
04295B FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
04295E FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
042961 FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
042964 FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
042967 FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
04296A FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
04296D FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
042970 FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
042973 F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
042976 F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
042979 F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
04297C F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
04297F F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
042982 F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
042985 EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
042988 EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
04298B EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
04298E E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
042991 E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
042994 E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
042997 DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
04299A DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
04299D D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
0429A0 D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
0429A3 D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
0429A6 CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
0429A9 C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
0429AC C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
0429AF C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
0429B2 BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
0429B5 B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
0429B8 B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
0429BB B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
0429BE AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
0429C1 A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
0429C4 A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
0429C7 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
0429CA 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
0429CD 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
0429D0 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
0429D3 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
0429D6 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
0429D9 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
0429DC 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
0429DF 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
0429E2 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
0429E5 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
0429E8 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
0429EB 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
0429EE 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
0429F1 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
0429F4 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
0429F7 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
0429FA 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
0429FD 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
042A00 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
042A03 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
042A06 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
042A09 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
042A0C 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
042A0F 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
042A12 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
042A15 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
042A18 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
042A1B FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
042A1E F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
042A21 EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
042A24 E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
042A27 E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
042A2A DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
042A2D D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
042A30 CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
042A33 C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
042A36 C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
042A39 BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
042A3C B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
042A3F B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042A42 AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
042A45 A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
042A48 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
042A4B 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
042A4E 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
042A51 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
042A54 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
042A57 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
042A5A 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
042A5D 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
042A60 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
042A63 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
042A66 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042A69 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042A6C 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
042A6F 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042A72 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
042A75 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
042A78 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042A7B 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
042A7E 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
042A81 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042A84 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
042A87 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042A8A 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
042A8D 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
042A90 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
042A93 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042A96 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042A99 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042A9C 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
042A9F 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
042AA2 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042AA5 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042AA8 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042AAB 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
042AAE 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
042AB1 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042AB4 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042AB7 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042ABA 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042ABD 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
042AC0 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042AC3 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042AC6 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042AC9 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042ACC 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
042ACF 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042AD2 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042AD5 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042AD8 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042ADB 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
042ADE 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
042AE1 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
042AE4 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
042AE7 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042AEA 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042AED 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042AF0 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042AF3 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
042AF6 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
042AF9 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042AFC 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042AFF 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042B02 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
042B05 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
042B08 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042B0B 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
042B0E 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
042B11 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
042B14 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
042B17 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
042B1A 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
042B1D 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
042B20 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042B23 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
042B26 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
042B29 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042B2C 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
042B2F 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
042B32 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
042B35 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
042B38 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
042B3B 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
042B3E 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
042B41 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
042B44 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
042B47 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
042B4A 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
042B4D 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
042B50 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
042B53 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
042B56 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
042B59 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
042B5C 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
042B5F 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
042B62 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
042B65 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
042B68 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042B6B A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
042B6E AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
042B71 B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042B74 B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
042B77 BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042B7A C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042B7D C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
042B80 CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
042B83 D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
042B86 DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042B89 E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
042B8C E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
042B8F EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
042B92 F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042B95 FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042B98 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042B9B             0802*  
042B9B             0803*  atan_lut_168:
042B9B 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
042B9E 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
042BA1 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
042BA4 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
042BA7 A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
042BAA CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
042BAD F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
042BB0 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
042BB3 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
042BB6 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
042BB9 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
042BBC BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
042BBF E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
042BC2 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
042BC5 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
042BC8 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
042BCB 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
042BCE B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
042BD1 DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
042BD4 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
042BD7 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
042BDA 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
042BDD 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
042BE0 A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
042BE3 CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
042BE6 F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
042BE9 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
042BEC 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
042BEF 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
042BF2 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
042BF5 C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
042BF8 E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
042BFB 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
042BFE 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
042C01 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
042C04 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
042C07 B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
042C0A D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
042C0D 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
042C10 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
042C13 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
042C16 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
042C19 A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
042C1C C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
042C1F EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
042C22 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
042C25 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
042C28 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
042C2B 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
042C2E B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
042C31 DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
042C34 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
042C37 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
042C3A 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
042C3D 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
042C40 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
042C43 C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
042C46 ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
042C49 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
042C4C 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
042C4F 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
042C52 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
042C55 AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
042C58 D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
042C5B FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
042C5E 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
042C61 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
042C64 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
042C67 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
042C6A BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
042C6D E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
042C70 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
042C73 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
042C76 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
042C79 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
042C7C 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
042C7F C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
042C82 E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
042C85 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
042C88 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
042C8B 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
042C8E 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
042C91 A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
042C94 C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
042C97 EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
042C9A 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
042C9D 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
042CA0 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
042CA3 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
042CA6 A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
042CA9 C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
042CAC EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
042CAF 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
042CB2 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
042CB5 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
042CB8 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
042CBB 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
042CBE C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
042CC1 E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
042CC4 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
042CC7 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
042CCA 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
042CCD 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
042CD0 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
042CD3 B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
042CD6 DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
042CD9 FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
042CDC 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
042CDF 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
042CE2 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
042CE5 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
042CE8 AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
042CEB CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
042CEE EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
042CF1 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
042CF4 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
042CF7 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
042CFA 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
042CFD 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
042D00 BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
042D03 DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
042D06 FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
042D09 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
042D0C 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
042D0F 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
042D12 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
042D15 A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
042D18 C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
042D1B E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
042D1E 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
042D21 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
042D24 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
042D27 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
042D2A 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
042D2D A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
042D30 C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
042D33 E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
042D36 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
042D39 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
042D3C 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
042D3F 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
042D42 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
042D45 A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
042D48 C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
042D4B E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
042D4E FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
042D51 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
042D54 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
042D57 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
042D5A 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
042D5D 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
042D60 B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
042D63 D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
042D66 F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
042D69 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
042D6C 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
042D6F 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
042D72 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
042D75 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
042D78 A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
042D7B C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
042D7E DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
042D81 FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
042D84 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
042D87 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
042D8A 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
042D8D 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
042D90 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
042D93 A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
042D96 C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
042D99 E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
042D9C FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
042D9F 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
042DA2 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
042DA5 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
042DA8 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
042DAB 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
042DAE A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
042DB1 C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
042DB4 DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
042DB7 F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
042DBA 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
042DBD 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
042DC0 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
042DC3 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
042DC6 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
042DC9 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
042DCC B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
042DCF CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
042DD2 E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
042DD5 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
042DD8 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
042DDB 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
042DDE 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
042DE1 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
042DE4 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
042DE7 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
042DEA B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
042DED D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
042DF0 EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
042DF3 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
042DF6 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
042DF9 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
042DFC 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
042DFF 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
042E02 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
042E05 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
042E08 B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
042E0B CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
042E0E E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
042E11 FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
042E14 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
042E17 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
042E1A 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
042E1D 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
042E20 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
042E23 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
042E26 A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
042E29 BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
042E2C D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
042E2F EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
042E32 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
042E35 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
042E38 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
042E3B 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
042E3E 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
042E41 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
042E44 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
042E47 A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
042E4A BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
042E4D D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
042E50 E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
042E53 FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
042E56 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
042E59 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
042E5C 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
042E5F 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
042E62 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
042E65 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
042E68 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
042E6B AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
042E6E C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
042E71 DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
042E74 F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
042E77 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
042E7A 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
042E7D 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
042E80 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
042E83 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
042E86 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
042E89 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
042E8C 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
042E8F AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
042E92 C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
042E95 D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
042E98 EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
042E9B 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042E9E             0059   	include "fixed24.inc"
042E9E             0001*  arith24uaf: ds 6
042EA4             0002*  arith24uhl: ds 6
042EAA             0003*  arith24ubc: ds 6
042EB0             0004*  arith24ude: ds 6
042EB6             0005*  arith24uix: ds 6
042EBC             0006*  arith24uiy: ds 6
042EC2             0007*  arith24usp: ds 6
042EC8             0008*  arith24upc: ds 6
042ECE             0009*  
042ECE             0010*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042ECE             0011*  ; uses EZ80 MLT instruction for speed
042ECE             0012*  ; operation: UHL * A --> UHL
042ECE             0013*  ; destroys: AF, HL
042ECE             0014*  smul24x8:
042ECE             0015*  ; make hl positive and store sign flag
042ECE CD 36 25 04 0016*  	call hlu_abs
042ED2 F5          0017*  	push af
042ED3             0018*  ; do the division
042ED3 CD DE 2E 04 0019*      call umul24x8 ; hl = product
042ED7             0020*  ; adjust sign of result
042ED7 F1          0021*  	pop af ; sign de
042ED8 F0          0022*  	ret p ; hl was positive, nothing to do
042ED9 CD 46 25 04 0023*  	call neg_hlu ; result is negative
042EDD C9          0024*  	ret
042EDE             0025*  
042EDE             0026*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042EDE             0027*  ; uses EZ80 MLT instruction for speed
042EDE             0028*  ; operation: UHL * A --> AUHL
042EDE             0029*  ; destroys: AF, HL
042EDE             0030*  umul24x8:
042EDE D5          0031*  	push de ; preserve de
042EDF             0032*  ; low byte
042EDF 5D          0033*  	ld e,l
042EE0 57          0034*  	ld d,a
042EE1 ED 5C       0035*  	mlt de
042EE3 6B          0036*  	ld l,e ; product low byte
042EE4 08          0037*  	ex af,af' ; save multiplier
042EE5 7A          0038*  	ld a,d ; carry
042EE6 08          0039*  	ex af,af' ; save carry, restore multiplier
042EE7             0040*  ; high byte
042EE7 5C          0041*  	ld e,h
042EE8 57          0042*  	ld d,a
042EE9 ED 5C       0043*  	mlt de
042EEB 08          0044*  	ex af,af' ; save multiplier, restore carry
042EEC 83          0045*  	add a,e ; add carry
042EED 67          0046*  	ld h,a ; product middle byte
042EEE 7A          0047*  	ld a,d ; carry
042EEF 08          0048*  	ex af,af' ; save carry, restore multiplier
042EF0             0049*  ; upper byte
042EF0 22 0B 2F 04 0050*      ld (@scratch),hl ; 7 cycles
042EF4 5F          0051*  	ld e,a
042EF5 3A 0D 2F 04 0052*  	ld a,(@scratch+2)
042EF9 57          0053*  	ld d,a
042EFA ED 5C       0054*  	mlt de
042EFC 08          0055*  	ex af,af' ; restore carry
042EFD 8B          0056*  	adc a,e ; add carry
042EFE 32 0D 2F 04 0057*      ld (@scratch+2),a ; 5 cycles
042F02 2A 0B 2F 04 0058*      ld hl,(@scratch) ; 7 cycles
042F06             0059*  ; highest byte
042F06 3E 00       0060*  	ld a,0 ; preserve carry flag
042F08 8A          0061*  	adc a,d ; product highest byte
042F09 D1          0062*  	pop de ; restore de
042F0A C9          0063*  	ret
042F0B             0064*  @scratch: ds 3
042F0E             0065*  
042F0E 00 00 00    0066*      dl 0 ; padding
042F11 00 00 00 00 0067*  umul24x24out: blkb 6,0
       00 00       
042F17 00 00 00    0068*      dl 0 ; padding
042F1A             0069*  
042F1A             0070*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042F1A             0071*  ; operation: UHL * UDE --> umul24x24out
042F1A             0072*  umul24x24:
042F1A             0073*  	; ld (@ix),ix ; preserve
042F1A DD E5       0074*  	push ix ; preserve
042F1C             0075*  
042F1C DD 21 11 2F 0076*  	ld ix,umul24x24out ; point to output buffer
       04          
042F21 C5          0077*  	push bc
042F22 01 00 00 00 0078*  	ld bc,0
042F26 DD 0F 00    0079*  	ld (ix),bc
042F29 DD 0F 03    0080*  	ld (ix+3),bc
042F2C C1          0081*  	pop bc
042F2D             0082*  
042F2D             0083*  ; STEP 1: UHL * E
042F2D 7B          0084*  	ld a,e
042F2E E5          0085*  	push hl
042F2F CD DE 2E 04 0086*  	call umul24x8
042F33 DD 2F 00    0087*  	ld (ix+0),hl
042F36 DD 77 03    0088*  	ld (ix+3),a
042F39             0089*  
042F39             0090*  ; STEP 2: UHL * D
042F39 E1          0091*  	pop hl
042F3A E5          0092*  	push hl
042F3B 7A          0093*  	ld a,d
042F3C CD DE 2E 04 0094*  	call umul24x8
042F40 CD 52 2F 04 0095*  	call @accumulate
042F44             0096*  
042F44             0097*  ; STEP 3: UHL * DEU
042F44 E1          0098*  	pop hl
042F45             0099*  	; push de
042F45             0100*  	; inc sp
042F45             0101*  	; pop af
042F45             0102*  	; dec sp
042F45 ED 53 84 2F 0103*  	ld (@de),de
       04          
042F4A 3A 86 2F 04 0104*  	ld a,(@de+2)
042F4E CD DE 2E 04 0105*  	call umul24x8
042F52             0106*  
042F52             0107*  @accumulate:
042F52 DD 23       0108*  	inc ix
042F54             0109*  ; highest byte of product to carry
042F54 DD 77 03    0110*  	ld (ix+3),a
042F57             0111*  ; low byte of product
042F57 7D          0112*  	ld a,l
042F58 DD 86 00    0113*  	add a,(ix+0)
042F5B DD 77 00    0114*  	ld (ix+0),a
042F5E             0115*  ; high byte of product
042F5E 7C          0116*  	ld a,h
042F5F DD 8E 01    0117*  	adc a,(ix+1)
042F62 DD 77 01    0118*  	ld (ix+1),a
042F65             0119*  ; uppper byte of product
042F65             0120*  	; push hl ; 4 cc
042F65             0121*  	; inc sp ; 1 cc
042F65             0122*  	; pop hl ; 4 cc
042F65             0123*  	; dec sp ; 1 cc
042F65             0124*  	; ld a,h ; 1 cc
042F65 22 81 2F 04 0125*  	ld (@hl),hl ; 7 cc
042F69 3A 83 2F 04 0126*  	ld a,(@hl+2) ; 5 cc
042F6D DD 8E 02    0127*  	adc a,(ix+2)
042F70 DD 77 02    0128*  	ld (ix+2),a
042F73             0129*  ; carry
042F73 3E 00       0130*  	ld a,0 ; preserve flags
042F75 DD 8E 03    0131*  	adc a,(ix+3)
042F78 DD 77 03    0132*  	ld (ix+3),a
042F7B             0133*  
042F7B             0134*  	; ld ix,(@ix) ; restore
042F7B DD E1       0135*  	pop ix
042F7D C9          0136*  	ret
042F7E             0137*  
042F7E 00 00 00    0138*  @ix: dl 0
042F81 00 00 00    0139*  @hl: dl 0
042F84 00 00 00    0140*  @de: dl 0
042F87             0141*  
042F87             0142*  ; UH.L = UH.L*UD.E (unsigned)
042F87             0143*  umul168:
042F87 CD 1A 2F 04 0144*  	call umul24x24
042F8B 2A 12 2F 04 0145*  	ld hl,(umul24x24out+1)
042F8F C9          0146*  	ret
042F90             0147*  
042F90             0148*  ; UH.L * UD.E --> UH.L (signed)
042F90             0149*  smul168:
042F90             0150*  ; make everything positive and store sign flags
042F90 CD 36 25 04 0151*  	call hlu_abs
042F94 F5          0152*  	push af
042F95 EB          0153*  	ex de,hl
042F96 CD 36 25 04 0154*  	call hlu_abs
042F9A EB          0155*  	ex de,hl
042F9B F5          0156*  	push af
042F9C             0157*  ; do the division
042F9C CD 87 2F 04 0158*      call umul168 ; hl = product
042FA0             0159*  ; adjust sign of result
042FA0 F1          0160*  	pop af ; sign de
042FA1 FA AC 2F 04 0161*  	jp m,@de_neg
042FA5 F1          0162*  	pop af ; sign hl
042FA6 F0          0163*  	ret p ; both positive, nothing to do
042FA7             0164*  @hl_neg:
042FA7 CD 46 25 04 0165*      call neg_hlu ; de pos, hl neg, result is negative
042FAB C9          0166*      ret
042FAC             0167*  @de_neg:
042FAC F1          0168*  	pop af
042FAD F8          0169*  	ret m ; both negative, nothing to do
042FAE CD 46 25 04 0170*  	call neg_hlu ; result is negative
042FB2 C9          0171*  	ret
042FB3             0172*  
042FB3             0173*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
042FB3             0174*  ; perform unsigned division of 16.8 fixed place values
042FB3             0175*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
042FB3             0176*  udiv168:
042FB3             0177*  ; back up divisor
042FB3 ED 53 EA 2F 0178*  	ld (@ude),de
       04          
042FB8             0179*  ; get the 16-bit integer part of the quotient
042FB8 CD 1B 30 04 0180*      call udiv24 ; de = quotient, hl = remainder
042FBC             0181*  ; load quotient to upper three bytes of output
042FBC ED 53 F1 2F 0182*      ld (div168_out+1),de
       04          
042FC1             0183*  @div256:
042FC1             0184*  ; multiply remainder by 256
042FC1             0185*  	hlu_mul256
042FC1 29          0001*M         add hl,hl ; * 2
042FC2 29          0002*M         add hl,hl ; * 4
042FC3 29          0003*M         add hl,hl ; * 8
042FC4 29          0004*M         add hl,hl ; * 16
042FC5 29          0005*M         add hl,hl ; * 32
042FC6 29          0006*M         add hl,hl ; * 64
042FC7 29          0007*M         add hl,hl ; * 128
042FC8 29          0008*M         add hl,hl ; * 256
042FC9             0186*  ; skip fractional computation if remainder is zero
042FC9             0187*      sign_hlu
042FC9 19          0001*M         add hl,de
042FCA B7          0002*M         or a
042FCB ED 52       0003*M         sbc hl,de
042FCD 20 03       0188*      jr nz,@div_frac
042FCF AF          0189*      xor a
042FD0 18 0A       0190*      jr @write_frac
042FD2             0191*  ; now divide the shifted remainder by the divisor
042FD2             0192*  @div_frac:
042FD2 ED 5B EA 2F 0193*  	ld de,(@ude) ; get back divisor
       04          
042FD7 CD 1B 30 04 0194*      call udiv24 ; de = quotient, hl = remainder
042FDB             0195*  ; load low byte of quotient to low byte of output
042FDB 7B          0196*      ld a,e
042FDC             0197*  @write_frac:
042FDC 32 F0 2F 04 0198*      ld (div168_out),a
042FE0             0199*  ; load de with return value
042FE0 ED 5B F0 2F 0200*      ld de,(div168_out)
       04          
042FE5             0201*  ; load a with any overflow
042FE5 3A F3 2F 04 0202*      ld a,(div168_out+3)
042FE9 C9          0203*      ret ; ud.e is the 16.8 result
042FEA             0204*  @ude: ds 6
042FF0             0205*  div168_out: ds 4 ; the extra byte is for overflow
042FF4             0206*  
042FF4             0207*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
042FF4             0208*  ; perform signed division of 16.8 fixed place values
042FF4             0209*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
042FF4             0210*  sdiv168:
042FF4             0211*  ; make everything positive and store sign flags
042FF4 CD 36 25 04 0212*  	call hlu_abs
042FF8 F5          0213*  	push af
042FF9 EB          0214*  	ex de,hl
042FFA CD 36 25 04 0215*  	call hlu_abs
042FFE EB          0216*  	ex de,hl
042FFF F5          0217*  	push af
043000             0218*  ; do the division
043000 CD B3 2F 04 0219*      call udiv168 ; de = quotient, hl = remainder
043004             0220*  ; adjust sign of result
043004 F1          0221*  	pop af ; sign de
043005 FA 12 30 04 0222*  	jp m,@de_neg
043009 F1          0223*  	pop af ; sign hl
04300A F0          0224*  	ret p ; both positive, nothing to do
04300B             0225*  @hl_neg:
04300B EB          0226*      ex de,hl ; hl = quotient, de = remainder
04300C CD 46 25 04 0227*      call neg_hlu ; de pos, hl neg, result is negative
043010 EB          0228*      ex de,hl ; de = negated quotient, hl = remainder
043011 C9          0229*      ret
043012             0230*  @de_neg:
043012 F1          0231*  	pop af
043013 F8          0232*  	ret m ; both negative, nothing to do
043014 EB          0233*      ex de,hl ; hl = quotient, de = remainder
043015 CD 46 25 04 0234*  	call neg_hlu ; result is negative
043019 EB          0235*      ex de,hl ; de = negated quotient, hl = remainder
04301A C9          0236*  	ret
04301B             0237*  
04301B             0238*  ;------------------------------------------------------------------------
04301B             0239*  ;  arith24.asm
04301B             0240*  ;  24-bit ez80 arithmetic routines
04301B             0241*  ;  Copyright (c) Shawn Sijnstra 2024
04301B             0242*  ;  MIT license
04301B             0243*  ;
04301B             0244*  ;  This library was created as a tool to help make ez80
04301B             0245*  ;  24-bit native assembly routines for simple mathematical problems
04301B             0246*  ;  more widely available.
04301B             0247*  ;
04301B             0248*  ;------------------------------------------------------------------------
04301B             0249*  ;
04301B             0250*  ;------------------------------------------------------------------------
04301B             0251*  ; udiv24
04301B             0252*  ; Unsigned 24-bit division
04301B             0253*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04301B             0254*  ;
04301B             0255*  ; Uses AF BC DE HL
04301B             0256*  ; Uses Restoring Division algorithm
04301B             0257*  ;------------------------------------------------------------------------
04301B             0258*  
04301B             0259*  udiv24:
04301B E5          0260*  	push	hl
04301C C1          0261*  	pop		bc	;move dividend to BCU
04301D 21 00 00 00 0262*  	ld		hl,0	;result
043021 A7          0263*  	and		a
043022 ED 52       0264*  	sbc		hl,de	;test for div by 0
043024 C8          0265*  	ret		z		;it's zero, carry flag is clear
043025 19          0266*  	add		hl,de	;HL is 0 again
043026 3E 18       0267*  	ld		a,24	;number of loops through.
043028             0268*  udiv1:
043028 C5          0269*  	push	bc	;complicated way of doing this because of lack of access to top bits
043029 E3          0270*  	ex		(sp),hl
04302A 37          0271*  	scf
04302B ED 6A       0272*  	adc	hl,hl
04302D E3          0273*  	ex	(sp),hl
04302E C1          0274*  	pop	bc		;we now have bc = (bc * 2) + 1
04302F             0275*  
04302F ED 6A       0276*  	adc	hl,hl
043031 A7          0277*  	and	a		;is this the bug
043032 ED 52       0278*  	sbc	hl,de
043034 30 02       0279*  	jr	nc,udiv2
043036 19          0280*  	add	hl,de
043037             0281*  ;	dec	c
043037 0B          0282*  	dec	bc
043038             0283*  udiv2:
043038 3D          0284*  	dec	a
043039 20 ED       0285*  	jr	nz,udiv1
04303B 37          0286*  	scf		;flag used for div0 error
04303C C5          0287*  	push	bc
04303D D1          0288*  	pop		de	;remainder
04303E C9          0289*  	ret
04303F             0060   ; App-specific includes
04303F             0061   	include "player.inc"
04303F             0001*  ; ######## GAME STATE VARIABLES #######
04303F             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
04303F 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
043042             0004*  ; player current shields,binary
043042             0005*  ; when < 0 player splodes
043042             0006*  ; restores to player_max_shields when new ship spawns
043042 10          0007*  player_shields: db 16 ; binary
043043             0008*  ; max player shields,binary
043043             0009*  ; can increase with power-ups (todo)
043043 10          0010*  player_max_shields: db 16 ; binary
043044             0011*  ; when reaches zero,game ends
043044             0012*  ; can increase based on TODO
043044 03          0013*  player_ships: db 0x03 ; binary
043045             0014*  
043045             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
043045             0016*  ; uses the same offsets from its table base as the main sprite table:
043045             0017*  player_start_variables: ; label marking beginning of table
043045 10          0018*  player_id:               db table_max_records
043046 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
043047 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
04304A 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
04304D 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
04304E 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
04304F 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043050 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043053 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043056 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043059 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04305C 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
04305F 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043062 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
043065 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
043066 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
043067 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
043068 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
043069 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
04306A 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
04306B             0038*  player_end_variables: ; for when we want to traverse this table in reverse
04306B             0039*  
04306B             0040*  ; set initial player position
04306B             0041*  ; inputs: none,everything is hardcoded
04306B             0042*  ; outputs: player_x/y set to bottom-left corner of screen
04306B             0043*  ; destroys: a
04306B             0044*  player_init:
04306B 3A 45 30 04 0045*  	ld a,(player_id)
04306F CD C6 23 04 0046*  	call vdu_sprite_select
043073 CD D9 23 04 0047*      call vdu_sprite_clear_frames
043077 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
04307B CD 1B 25 04 0049*      call vdu_sprite_add_buff
04307F 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
043083 CD 1B 25 04 0051*      call vdu_sprite_add_buff
043087 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
04308B CD 1B 25 04 0053*      call vdu_sprite_add_buff
04308F 01 00 00 00 0054*      ld bc,0
043093 ED 43 50 30 0055*      ld (player_x),bc
       04          
043098 11 00 DF 00 0056*      ld de,0x00DF00
04309C ED 53 53 30 0057*      ld (player_y),de
       04          
0430A1 CD 92 24 04 0058*      call vdu_sprite_move_abs168
0430A5 CD 3C 24 04 0059*      call vdu_sprite_show
0430A9 C9          0060*      ret
0430AA             0061*  
0430AA             0062*  ; process player keyboard input, set player bitmap
0430AA             0063*  ; velocities and draw player bitmap at updated coordinates
0430AA             0064*  ; Inputs: player_x/y set at desired position
0430AA             0065*  ; Returns: player bitmap drawn at updated position
0430AA             0066*  ; Destroys: probably everything except maybe iy
0430AA             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
0430AA             0068*  ; TODO: requires sprite implementation
0430AA             0069*  player_input:
0430AA             0070*  ; reset player component velocities to zero as the default
0430AA 21 00 00 00 0071*  	ld hl,0
0430AE 22 56 30 04 0072*  	ld (player_xvel),hl
0430B2 22 59 30 04 0073*  	ld (player_yvel),hl
0430B6             0074*  ; make ship the active sprite
0430B6 3A 45 30 04 0075*      ld a,(player_id)
0430BA CD C6 23 04 0076*      call vdu_sprite_select
0430BE             0077*  ; check for keypresses and branch accordingly
0430BE             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0430BE             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0430BE 3E 1E       0001*M 			LD	A, function
0430C0 5B CF       0002*M 			RST.LIL	08h
0430C2             0080*  ; we test all four arrow keys and add/subract velocities accordingly
0430C2             0081*  ; this handles the case where two opposing movement keys
0430C2             0082*  ; are down simultaneously (velocities will net to zero)
0430C2             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
0430C2             0084*  ; it also allows movement and action keys to be detected simultaneously
0430C2             0085*  ; so we can walk and chew gum at the same time
0430C2 3E 01       0086*      ld a,1 ; set ship's default animation to center
0430C4             0087*          ; if left and right are both down a will net to
0430C4             0088*  
0430C4             0089*  @left:
0430C4 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
0430C8 28 0E       0091*      jr z,@right
0430CA 2A 56 30 04 0092*      ld hl,(player_xvel)
0430CE 01 00 FD FF 0093*      ld bc,-speed_player
0430D2 09          0094*      add hl,bc
0430D3 22 56 30 04 0095*      ld (player_xvel),hl
0430D7 3D          0096*      dec a ; set ship's animation to left
0430D8             0097*  @right:
0430D8 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
0430DC 28 0E       0099*  	jr z,@up
0430DE 2A 56 30 04 0100*      ld hl,(player_xvel)
0430E2 01 00 03 00 0101*      ld bc,speed_player
0430E6 09          0102*      add hl,bc
0430E7 22 56 30 04 0103*      ld (player_xvel),hl
0430EB 3C          0104*      inc a ; set ship's animation to right
0430EC             0105*  @up:
0430EC DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
0430F0 28 0D       0107*  	jr z,@down
0430F2 2A 59 30 04 0108*      ld hl,(player_yvel)
0430F6 01 00 FD FF 0109*      ld bc,-speed_player
0430FA 09          0110*      add hl,bc
0430FB 22 59 30 04 0111*      ld (player_yvel),hl
0430FF             0112*  @down:
0430FF DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
043103 28 0D       0114*  	jr z,@done_keyboard
043105 2A 59 30 04 0115*      ld hl,(player_yvel)
043109 01 00 03 00 0116*      ld bc,speed_player
04310D 09          0117*      add hl,bc
04310E 22 59 30 04 0118*      ld (player_yvel),hl
043112             0119*  @done_keyboard:
043112             0120*  ; move player sprite according to velocities set by keypresses
043112 2A 56 30 04 0121*      ld hl,(player_xvel)
043116             0122*  ; compute new x position
043116 ED 5B 50 30 0123*      ld de,(player_x)
       04          
04311B 19          0124*      add hl,de ; hl = player_x + player_xvel
04311C             0125*      ; check for horizontal screen edge collisions
04311C             0126*      ; and adjust coordinate as necessary
04311C             0127*  ; TODO: make this work using 24-bit registers
04311C             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
04311C             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
04311C             0130*      ; ld a,8 ; set x to leftmost allowable position
04311C             0131*  ; @check_right:
04311C             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
04311C             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
04311C             0134*  ;     ld a,248 ; set x to rightmost allowable position
04311C             0135*  @x_ok:
04311C             0136*  ; save the updated drawing coordinate
04311C 22 50 30 04 0137*      ld (player_x),hl
043120             0138*  ;compute new y position
043120 2A 53 30 04 0139*      ld hl,(player_y)
043124 ED 5B 59 30 0140*      ld de,(player_yvel)
       04          
043129 19          0141*      add hl,de ; hl = player_y + player_yvel
04312A             0142*  ; TODO: make this work using 24-bit registers
04312A             0143*  ;     ; check for vertical screen edge collisions
04312A             0144*  ;     ; and adjust coordinate as necessary
04312A             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
04312A             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
04312A             0147*  ;     ld a,8 ; set y to topmost allowable position
04312A             0148*  ; @check_top:
04312A             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
04312A             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
04312A             0151*  ;     ld a,232 ; set y to bottommost allowable position
04312A             0152*  @y_ok:
04312A 22 53 30 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
04312E             0154*  ; a should land here loaded with the correct frame
04312E CD 29 24 04 0155*      call vdu_sprite_select_frame
043132             0156*  ; draw player at updated position
043132 ED 4B 50 30 0157*      ld bc,(player_x)
       04          
043137 ED 5B 53 30 0158*  	ld de,(player_y)
       04          
04313C             0159*  
04313C             0160*      ; call dumpRegistersHex
04313C             0161*  
04313C CD 92 24 04 0162*  	call vdu_sprite_move_abs168
043140             0163*  
043140             0164*  ; end player_input
043140 C9          0165*  	ret
043141             0166*  
043141             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
043141             0168*  ; ; INSTEAD OF FRACTIONAL
043141             0169*  ; ; ----------------------------------------------------------------
043141             0170*  ; ; process player keyboard input, set player bitmap
043141             0171*  ; ; velocities and draw player bitmap at updated coordinates
043141             0172*  ; ; Inputs: player_x/y set at desired position
043141             0173*  ; ; Returns: player bitmap drawn at updated position
043141             0174*  ; ; Destroys: probably everything except maybe iy
043141             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
043141             0176*  ; ; TODO: requires sprite implementation
043141             0177*  ; player_input:
043141             0178*  ; ; reset player component velocities to zero as the default
043141             0179*  ; 	ld hl,0
043141             0180*  ; 	ld (player_xvel),hl
043141             0181*  ; 	ld (player_yvel),hl
043141             0182*  ; ; check for keypresses and branch accordingly
043141             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043141             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043141             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
043141             0186*  ; ; this handles the case where two opposing movement keys
043141             0187*  ; ; are down simultaneously (velocities will net to zero)
043141             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
043141             0189*  ; ; it also allows movement and action keys to be detected simultaneously
043141             0190*  ; ; so we can walk and chew gum at the same time
043141             0191*  ; @left:
043141             0192*  ;     bit 1,(ix+3) ; keycode 26
043141             0193*  ;     jr z,@right
043141             0194*  ;     ld hl,(player_xvel)
043141             0195*  ;     ld bc,-3
043141             0196*  ;     add hl,bc
043141             0197*  ;     ld (player_xvel),hl
043141             0198*  ; @right:
043141             0199*  ;     bit 1,(ix+15) ; keycode 122
043141             0200*  ; 	jr z,@up
043141             0201*  ;     ld hl,(player_xvel)
043141             0202*  ;     ld bc,3
043141             0203*  ;     add hl,bc
043141             0204*  ;     ld (player_xvel),hl
043141             0205*  ; @up:
043141             0206*  ;     bit 1,(ix+7) ; keycode 58
043141             0207*  ; 	jr z,@down
043141             0208*  ;     ld hl,(player_yvel)
043141             0209*  ;     ld bc,-3
043141             0210*  ;     add hl,bc
043141             0211*  ;     ld (player_yvel),hl
043141             0212*  ; @down:
043141             0213*  ;     bit 1,(ix+5) ; keycode 42
043141             0214*  ; 	jr z,@done_keyboard
043141             0215*  ;     ld hl,(player_yvel)
043141             0216*  ;     ld bc,3
043141             0217*  ;     add hl,bc
043141             0218*  ;     ld (player_yvel),hl
043141             0219*  ; @done_keyboard:
043141             0220*  ; ; move player sprite according to velocities set by keypresses
043141             0221*  ;     ld hl,(player_xvel)
043141             0222*  ; ; compute new x position
043141             0223*  ;     ld de,(player_x)
043141             0224*  ;     add hl,de ; hl = player_x + player_xvel
043141             0225*  ;     ; check for horizontal screen edge collisions
043141             0226*  ;     ; and adjust coordinate as necessary
043141             0227*  ; ; TODO: make this work using 24-bit registers
043141             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
043141             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
043141             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
043141             0231*  ; ; @check_right:
043141             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
043141             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
043141             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
043141             0235*  ; @x_ok:
043141             0236*  ;     ; save the updated drawing coordinate
043141             0237*  ;     ld (player_x),hl
043141             0238*  ; ;compute new y position
043141             0239*  ;     ld hl,(player_y)
043141             0240*  ;     ld de,(player_yvel)
043141             0241*  ;     add hl,de ; hl = player_y + player_yvel
043141             0242*  ; ; TODO: make this work using 24-bit registers
043141             0243*  ; ;     ; check for vertical screen edge collisions
043141             0244*  ; ;     ; and adjust coordinate as necessary
043141             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
043141             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
043141             0247*  ; ;     ld a,8 ; set y to topmost allowable position
043141             0248*  ; ; @check_top:
043141             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
043141             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
043141             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
043141             0252*  ; @y_ok:
043141             0253*  ;     ld (player_y),hl
043141             0254*  ; ; draw player at updated position
043141             0255*  ;     ld a,(player_id)
043141             0256*  ;     call vdu_sprite_select
043141             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
043141             0258*  ;     call get_sign_hlu ; to set the proper animation
043141             0259*  ;     add a,1 ; ...
043141             0260*  ;     call vdu_sprite_select_frame
043141             0261*  ;     ld bc,(player_x)
043141             0262*  ; 	ld de,(player_y)
043141             0263*  ; 	call vdu_sprite_move_abs
043141             0264*  ; ; end player_input
043141             0265*  ; 	ret
043141             0266*  
043141             0267*  
043141             0268*  ; ###################################################################
043141             0269*  ; TODO: the below is all stuff from the original code we need to port
043141             0270*  ; ###################################################################
043141             0271*  
043141             0272*  ; kill_player:
043141             0273*  ; ; set player status to dead
043141             0274*  ;     xor a; sets all player flags to zero
043141             0275*  ;     ld (player_collisions),a
043141             0276*  ; ; deduct a ship from the inventory
043141             0277*  ;     ld a,(player_ships)
043141             0278*  ;     dec a
043141             0279*  ;     ld (player_ships),a
043141             0280*  ; ; are we out of ships?
043141             0281*  ;     jp z,game_over
043141             0282*  ; ; wait a few ticks
043141             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
043141             0284*  ;     ld (player_move_timer),a
043141             0285*  ; kill_player_loop:
043141             0286*  ;     call vdu_vblank
043141             0287*  ;     ld a,(player_move_timer)
043141             0288*  ;     dec a
043141             0289*  ;     ld (player_move_timer),a
043141             0290*  ;     jr nz,kill_player_loop
043141             0291*  ;     call player_init ; player respawn if timer zero
043141             0292*  ;     ret ; and out
043141             0293*  
043141             0294*  
043141             0295*  ; player_move:
043141             0296*  ; ; begin setting player to active sprite
043141             0297*  ;     ld hl,player
043141             0298*  ;     ld (sprite_base_bufferId),hl
043141             0299*  ;     ld hl,0 ; north
043141             0300*  ;     ld (sprite_heading),hl
043141             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
043141             0302*  ;     ld (sprite_animation),a
043141             0303*  ;     ; we set position here for the time being as a default
043141             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
043141             0305*  ;     ld hl,(player_x)
043141             0306*  ;     ld (sprite_x),hl
043141             0307*  ;     ld hl,(player_y)
043141             0308*  ;     ld (sprite_y),hl
043141             0309*  ; ; did we just die?
043141             0310*  ;     ld a,(player_collisions)
043141             0311*  ;     and %00000010 ; zero flag will be set if not dead
043141             0312*  ;     jr z,player_not_dead
043141             0313*  ; ; yes we died
043141             0314*  ;     call kill_player
043141             0315*  ;     ret ; done
043141             0316*  ; ; yay we didn't die
043141             0317*  ; player_not_dead:
043141             0318*  ; ; set player movements to zero by default
043141             0319*  ;     ld hl,0
043141             0320*  ;     ld (player_xvel),hl
043141             0321*  ;     ld (player_yvel),hl
043141             0322*  ; ; do we move it?
043141             0323*  ;     in a,(#82) ; keyboard
043141             0324*  ;     or a ; if zero,don't move
043141             0325*  ;     jr z,player_draw
043141             0326*  ; ; move it
043141             0327*  ;     call player_move_calc
043141             0328*  ; player_draw:
043141             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043141             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043141             0331*  ; player_move_done:
043141             0332*  ;     ; write updated x,y coordinates back to player table
043141             0333*  ;     ld hl,(sprite_x)
043141             0334*  ;     ld (player_x),hl
043141             0335*  ;     ld hl,(sprite_y)
043141             0336*  ;     ld (player_y),hl
043141             0337*  ;     ret
043141             0062   	include "tiles.inc"
043141             0001*  ; ######### TILES #########
043141             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
043141             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
043141 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
043144 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
043145             0006*                          ; initialize to zero for a maximum of 256 rows in a level
043145 00          0007*  cur_level: db 0
043146             0008*  num_levels: equ 2 ; number of levels,duh
043146             0009*  
043146             0010*  ; lookup table for level definitions
043146 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
04314C             0012*  
04314C             0013*  ; tiles_bufferId: dl 0
04314C 00 00 00    0014*  tiles_x_plot: dl 0
04314F F1 FF FF    0015*  tiles_y_plot: dl -15
043152             0016*  
043152 FF FF FF    0017*  bg_y_plot: dl -1
043155 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
043158             0019*  
043158             0020*  bg_plot:
043158             0021*  ; load current bg tile bufferId as default
043158 2A 55 31 04 0022*      ld hl,(bg_bufferId)
04315C             0023*  ; check whether it is time for a new background tile
04315C 3A 52 31 04 0024*      ld a,(bg_y_plot)
043160 3C          0025*      inc a
043161 32 52 31 04 0026*      ld (bg_y_plot),a
043165 C2 7D 31 04 0027*      jp nz,@F ; not time for a new tile so draw current one
043169             0028*  ; load the next background tile
043169 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
04316D CD EB 25 04 0030*      call rand_8
043171 E6 03       0031*      and %0000011
043173 85          0032*      add a,l
043174 6F          0033*      ld l,a
043175 3E 00       0034*      ld a,0
043177 8C          0035*      adc a,h
043178 67          0036*      ld h,a
043179 22 55 31 04 0037*      ld (bg_bufferId),hl
04317D             0038*  @@:
04317D CD 5C 20 04 0039*      call vdu_buff_select
043181 01 00 00 00 0040*      ld bc,0
043185 ED 5B 52 31 0041*      ld de,(bg_y_plot)
       04          
04318A CD 25 23 04 0042*      call vdu_plot_bmp
04318E             0043*  ; all done
04318E C9          0044*      ret
04318F             0045*  
04318F             0046*  tiles_plot:
04318F             0047*  ; set gfx viewport to playing field window
04318F 01 00 00 00 0048*  	ld bc,field_left
043193 11 00 00 00 0049*  	ld de,field_top
043197 DD 21 FF 00 0050*  	ld ix,field_right
       00          
04319C FD 21 4F 01 0051*  	ld iy,field_bottom
       00          
0431A1 CD 0F 20 04 0052*  	call vdu_set_gfx_viewport
0431A5             0053*  ; move the background down one pixel
0431A5 3E 02       0054*  	ld a,2 ; current gfx viewport
0431A7 2E 02       0055*  	ld l,2 ; direction=down
0431A9 26 01       0056*  	ld h,1 ; speed=1 px
0431AB CD 87 1F 04 0057*  	call vdu_scroll_down
0431AF             0058*  ; set gfx viewport to one scanline to optimise plotting tiles
0431AF 01 00 00 00 0059*  	ld bc,0 ; leftmost x-coord
0431B3 11 00 00 00 0060*  	ld de,0 ; topmost y-coord
0431B7 DD 21 FF 00 0061*  	ld ix,255 ; rightmost x-coord
       00          
0431BC FD 21 00 00 0062*  	ld iy,0 ; bottommost y-coord
       00          
0431C1 CD 0F 20 04 0063*  	call vdu_set_gfx_viewport
0431C5             0064*  ; plot the background
0431C5 CD 58 31 04 0065*      call bg_plot
0431C9             0066*  ; initialize tiles loop
0431C9 21 00 00 00 0067*      ld hl,0 ; init plotting x-coordinate
0431CD 22 4C 31 04 0068*      ld (tiles_x_plot),hl
0431D1 2A 41 31 04 0069*      ld hl,(tiles_row_defs)
0431D5 06 10       0070*  	ld b,16 ; loop counter
0431D7             0071*  @loop:
0431D7 C5          0072*  	push bc ; save the loop counter
0431D8             0073*  ; read the tile defintion for the current column
0431D8 7E          0074*      ld a,(hl) ; a has tile definition
0431D9 E5          0075*      push hl  ; save pointer to tile definition
0431DA 21 00 00 00 0076*      ld hl,0 ; hlu is non-zero
0431DE 6F          0077*      ld l,a ; l is tile defintion
0431DF 26 01       0078*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
0431E1 CD 5C 20 04 0079*      call vdu_buff_select ; tile bitmap buffer is now active
0431E5             0080*  ; plot the active bitmap
0431E5 ED 4B 4C 31 0081*      ld bc,(tiles_x_plot)
       04          
0431EA ED 5B 4F 31 0082*      ld de,(tiles_y_plot)
       04          
0431EF CD 25 23 04 0083*      call vdu_plot_bmp
0431F3             0084*  ; bump x-coords the width of one tile and save it
0431F3 2A 4C 31 04 0085*      ld hl,(tiles_x_plot)
0431F7 01 10 00 00 0086*      ld bc,16
0431FB 09          0087*      add hl,bc
0431FC 22 4C 31 04 0088*      ld (tiles_x_plot),hl
043200             0089*  ; prepare to loop to next column
043200 E1          0090*      pop hl ; get back pointer to tile def
043201 23          0091*      inc hl ; bump it to the next column
043202 C1          0092*  	pop bc ; snag our loop counter
043203 10 D2       0093*      djnz @loop
043205             0094*  ; increment tiles plotting y-coordinate
043205             0095*  ; when it hits zero, we go to next row of tiles in the map
043205             0096*  ; (we use ix b/c we want to preserve hl for the next step)
043205 DD 21 4F 31 0097*  	ld ix,tiles_y_plot
       04          
04320A DD 34 00    0098*  	inc (ix)
04320D C0          0099*  	ret nz
04320E             0100*  ; time to bump tiles_row_defs to next row
04320E             0101*  ; (hl was already there at the end of the loop)
04320E 22 41 31 04 0102*      ld (tiles_row_defs),hl
043212             0103*  ; reset coords to plot next row of tiles
043212 21 00 00 00 0104*      ld hl,0
043216 22 4C 31 04 0105*      ld (tiles_x_plot),hl
04321A 21 F1 FF FF 0106*      ld hl,-15
04321E 22 4F 31 04 0107*      ld (tiles_y_plot),hl
043222             0108*  ; decrement tiles row counter
043222 21 44 31 04 0109*      ld hl,tiles_row
043226 35          0110*      dec (hl)
043227 C0          0111*      ret nz
043228             0112*  ; queue up next level
043228 3A 45 31 04 0113*      ld a,(cur_level)
04322C FE 01       0114*      cp num_levels-1
04322E 20 02       0115*      jr nz,@inc_level
043230 3E FF       0116*      ld a,-1 ; will wrap around to zero when we fall through
043232             0117*  @inc_level:
043232 3C          0118*      inc a
043233 32 45 31 04 0119*      ld (cur_level),a
043237             0120*  ; increase the number of enemy sprites
043237 3A 7E 32 04 0121*      ld a,(max_enemy_sprites)
04323B 3C          0122*      inc a
04323C FE 10       0123*      cp table_max_records ; if we're at the global limit,skip ahead at max level
04323E 28 04       0124*      jr z,init_level
043240 32 7E 32 04 0125*      ld (max_enemy_sprites),a ; otherwise save the updated number
043244             0126*  ; fall through to init_level
043244             0127*  
043244             0128*  init_level:
043244             0129*  ; look up address of level's tile defintion
043244 21 46 31 04 0130*      ld hl,tiles_levels
043248 3A 45 31 04 0131*      ld a,(cur_level)
04324C 11 00 00 00 0132*      ld de,0 ; just in case deu is non-zero
043250 57          0133*      ld d,a
043251 1E 03       0134*      ld e,3
043253 ED 5C       0135*      mlt de
043255 19          0136*      add hl,de
043256 ED 37       0137*      ld ix,(hl)
043258 DD 22 41 31 0138*      ld (tiles_row_defs),ix
       04          
04325D             0139*  ; set tiles_row counter
04325D DD 7E 00    0140*      ld a,(ix)
043260 32 44 31 04 0141*      ld (tiles_row),a
043264 DD 23       0142*      inc ix ; now ix points first element of first row tile def
043266 DD 22 41 31 0143*      ld (tiles_row_defs),ix ; ... so we save it
       04          
04326B C9          0144*      ret
04326C             0145*  
04326C             0146*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
04326C             0147*  ; dt_is_active:
04326C             0148*  ; ; a lands here containing a tile index in the low nibble
04326C             0149*  ; ; we test the values for the tiles which are active
04326C             0150*  ;     cp #07
04326C             0151*  ;     call z,ld_act_landing_pad
04326C             0152*  ;     cp #08
04326C             0153*  ;     call z,ld_act_laser_turret
04326C             0154*  ;     ; fall through
04326C             0155*  ;     ret
04326C             0156*  
04326C             0157*  ; ; some tiles become active sprites,so we load those here
04326C             0158*  ; ; sprite_x/y have already been loaded
04326C             0159*  ; ; sprite_dim_x/y are loaded by table_add_record
04326C             0160*  ; ; we don't want sprite drawn to background like other tiles
04326C             0161*  ; ; so this routine only adds them to the sprite table
04326C             0162*  ; dt_ld_act:
04326C             0163*  ;     ld a,#48 ; top of screen + 1/2 tile height
04326C             0164*  ;     ld (sprite_y+1),a ; just the integer part
04326C             0165*  ;     ld (sprite_base_bufferId),hl
04326C             0166*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04326C             0167*  ;     call table_add_record
04326C             0168*  ;     call sprite_variables_from_stack
04326C             0169*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
04326C             0170*  ;     ret ; and back
04326C             0171*  
04326C             0172*  ; ld_act_landing_pad:
04326C             0173*  ;     call sprite_variables_to_stack
04326C             0174*  
04326C             0175*  ;     ld hl,move_landing_pad
04326C             0176*  ;     ld (sprite_move_program),hl
04326C             0177*  
04326C             0178*  ;     xor a
04326C             0179*  ;     ld (sprite_animation),a ; animation 0
04326C             0180*  
04326C             0181*  ;     call rand_8     ; snag a random number
04326C             0182*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04326C             0183*  ;     add a,64 ; range is now 64-127
04326C             0184*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04326C             0185*  
04326C             0186*  ;     ld a,%10 ; collides with laser but not player
04326C             0187*  ;     ld (iy+sprite_collisions),a
04326C             0188*  
04326C             0189*  ;     ld a,#05 ; BCD
04326C             0190*  ;     ld (sprite_points),a
04326C             0191*  ;     ld a,0 ; binary
04326C             0192*  ;     ld (sprite_shield_damage),a
04326C             0193*  
04326C             0194*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
04326C             0195*  ;     jr dt_ld_act
04326C             0196*  
04326C             0197*  ; ld_act_laser_turret:
04326C             0198*  ;     call sprite_variables_to_stack
04326C             0199*  
04326C             0200*  ;     ld hl,move_laser_turret
04326C             0201*  ;     ld (sprite_move_program),hl
04326C             0202*  
04326C             0203*  ;     xor a
04326C             0204*  ;     ld (sprite_animation),a
04326C             0205*  ;     ld (sprite_move_step),a
04326C             0206*  
04326C             0207*  ;     call rand_8     ; snag a random number
04326C             0208*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04326C             0209*  ;     add a,64 ; range is now 64-127
04326C             0210*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04326C             0211*  
04326C             0212*  ;     ld a,%10 ; collides with laser but not player
04326C             0213*  ;     ld (iy+sprite_collisions),a
04326C             0214*  
04326C             0215*  ;     ld a,#10 ; BCD
04326C             0216*  ;     ld (sprite_points),a
04326C             0217*  ;     ld a,0 ; binary
04326C             0218*  ;     ld (sprite_shield_damage),a
04326C             0219*  
04326C             0220*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
04326C             0221*  ;     jp dt_ld_act
04326C             0222*  
04326C             0223*  
04326C             0224*  ; moves active tile sprites down one pixel in sync with tiles movement
04326C             0225*  ; deletes sprites from table when they wrap around to top of screen
04326C             0226*  move_active_tiles:
04326C             0227*  ; get current position
04326C 3A 0F 00 00 0228*      ld a,(sprite_y+1) ; we only need the integer part
043270 3C          0229*      inc a
043271             0230*  ; are we at the bottom of the screen?
043271 20 06       0231*      jr nz,move_active_tiles_draw_sprite ; nope
043273             0232*  ; otherwise kill sprite
043273 3E 80       0233*      ld a,%10000000 ; any bit set in high nibble means sprite will die
043275 FD 77 08    0234*      ld (iy+sprite_collisions),a
043278 C9          0235*      ret ; debug
043279             0236*  move_active_tiles_draw_sprite:
043279 32 0F 00 00 0237*      ld (sprite_y+1),a ; update tile y position integer part
04327D             0238*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04327D             0239*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
04327D C9          0240*      ret ; and done
04327E             0063   	include "enemies.inc"
04327E 10          0001*  max_enemy_sprites: db 16
04327F             0002*  
04327F             0003*  ; sprite_type
04327F             0004*  enemy_dead: equ 0
04327F             0005*  enemy_small: equ 1
04327F             0006*  enemy_medium: equ 2
04327F             0007*  enemy_large: equ 3
04327F             0008*  landing_pad: equ 4
04327F             0009*  laser_turret: equ 5
04327F             0010*  fireballs: equ 6
04327F             0011*  explosion: equ 7
04327F             0012*  
04327F             0013*  
04327F             0014*  respawn_countdown:
04327F 2A A0 32 04 0015*      ld hl,(respawn_timer)
043283 2B          0016*      dec hl
043284 22 A0 32 04 0017*      ld (respawn_timer),hl
043288             0018*  ; check hl for zero
043288 19          0019*      add hl,de
043289 B7          0020*      or a
04328A ED 52       0021*      sbc hl,de
04328C C0          0022*      ret nz
04328D 06 10       0023*      ld b,table_max_records
04328F             0024*  @respawn_loop:
04328F C5          0025*      push bc
043290 CD 22 34 04 0026*      call enemy_init_from_landing_pad
043294 C1          0027*      pop bc
043295 10 F8       0028*      djnz @respawn_loop
043297 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
04329B 22 A0 32 04 0030*      ld (respawn_timer),hl
04329F C9          0031*      ret
0432A0 3C 00 00    0032*  respawn_timer: dl 1*60
0432A3             0033*  
0432A3             0034*  move_enemies:
0432A3             0035*  ; are there any active enemies or explosions?
0432A3 21 00 00 00 0036*      ld hl,0
0432A7 3A 45 18 04 0037*      ld a,(table_active_sprites)
0432AB 6F          0038*      ld l,a
0432AC             0039*      ; call dumpRegistersHex
0432AC A7          0040*      and a ; will be zero if no alive enemies or explosions
0432AD             0041*      ; ret z ; so nothing to do but go back
0432AD             0042*      ; ld hl,(respawn_timer)
0432AD             0043*      ; call dumpRegistersHex
0432AD 20 05       0044*      jr nz,move_enemies_do
0432AF CD 7F 32 04 0045*      call respawn_countdown
0432B3 C9          0046*      ret
0432B4             0047*  move_enemies_do:
0432B4             0048*  ; initialize pointers and loop counter
0432B4 FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
0432B9 06 10       0050*      ld b,table_max_records ; loop counter
0432BB             0051*  move_enemies_loop:
0432BB FD 22 42 18 0052*      ld (table_pointer),iy ; update table pointer
       04          
0432C0 C5          0053*      push bc ; backup loop counter
0432C1             0054*  ; check sprite_type to see if sprite is active
0432C1 FD 7E 01    0055*      ld a,(iy+sprite_type)
0432C4 A7          0056*      and a ; if zero, sprite is dead
0432C5 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
0432C7             0058*  ; otherwise we prepare to move the sprite
0432C7 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
0432CA CD C6 23 04 0060*      call vdu_sprite_select ; select sprite
0432CE FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0432D1 E9          0062*      jp (hl)  ; ... and jump to it
0432D2             0063*  ; we always jp back here from behavior subroutines
0432D2             0064*  move_enemies_loop_return:
0432D2 FD 2A 42 18 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
0432D7             0066*  ; now we check results of all the moves
0432D7 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
0432DA E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
0432DC FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0432DF 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0432E1 CD 8E 18 04 0071*      call table_deactivate_sprite ; otherwise we ded
0432E5 AF          0072*      xor a ; zero a so that we can ...
0432E6 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
0432E9 18 0A       0074*      jr move_enemies_next_record ; and to the next record
0432EB             0075*  move_enemies_draw_sprite:
0432EB             0076*  ; if we got here sprite will have already been activated
0432EB             0077*  ; so all we need to do is set its coordinates and draw it
0432EB FD 07 0B    0078*      ld bc,(iy+sprite_x)
0432EE FD 17 0E    0079*      ld de,(iy+sprite_y)
0432F1 CD 92 24 04 0080*      call vdu_sprite_move_abs168
0432F5             0081*  ; fall through to next record
0432F5             0082*  move_enemies_next_record:
0432F5 11 26 00 00 0083*      ld de,table_bytes_per_record
0432F9 FD 19       0084*      add iy,de ; point to next record
0432FB AF          0085*      xor a ; clears carry flag
0432FC 32 46 18 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
043300 C1          0087*      pop bc ; get back our loop counter
043301 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
043303 C9          0089*      ret ; and we're out
043304             0090*  
043304             0091*  en_nav_zigzag_start:
043304 FD 2A 42 18 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043309 CD EB 25 04 0093*      call rand_8
04330D E6 3F       0094*      and %00111111 ; limit it to 64
04330F CB DF       0095*      set 3,a ; make sure it's at least 8
043311 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
043314             0097*      ; fall through to en_nav_zigzag
043314             0098*  en_nav_zigzag:
043314 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
043317 3D          0100*      dec a
043318 FD 77 22    0101*      ld (iy+sprite_move_timer),a
04331B 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
04331D             0103*      ; otherwise flip direction and restart timer
04331D FD 7E 23    0104*      ld a,(iy+sprite_move_step)
043320 EE 01       0105*      xor %1 ; flips bit one
043322 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
043325 20 09       0107*      jr nz,en_nav_zigzag_right
043327             0108*  ;otherwise zag left
043327 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
04332B FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
04332E 18 D4       0111*      jr en_nav_zigzag_start
043330             0112*  en_nav_zigzag_right:
043330 21 00 60 00 0113*      ld hl,0x006000; southeast heading
043334 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
043337 18 CB       0115*      jr en_nav_zigzag_start
043339             0116*  en_nav_zigzag_no_switch:
043339             0117*      ; ld a,(sprite_orientation)
043339 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
04333C 18 13       0119*      jr en_nav_computevelocities
04333E             0120*  
04333E             0121*  ; contains the logic for how to move the enemy
04333E             0122*  ; and then does the moving
04333E             0123*  ; inputs: a fully-populated active sprite table
04333E             0124*  ;         player position variables
04333E             0125*  ; destroys: everything except index registers
04333E             0126*  ; outputs: moving enemies
04333E             0127*  en_nav:
04333E             0128*  ; set velocity and orientation by player's relative location
04333E             0129*  ; move enemies y-axis
04333E             0130*  ; where is player relative to us?
04333E CD A5 34 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
043342             0132*  ; is player above or below us?
043342 ED 53 3B 1E 0133*      ld (ude),de ; dy
       04          
043347 3A 3D 1E 04 0134*      ld a,(ude+2) ; deu
04334B 17          0135*      rla ; shift sign bit into carry
04334C 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
04334E             0137*  ; player is even or above,so home in on current heading
04334E FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
043351             0139*  
043351             0140*  ; we land here from zig-zag program so as not to
043351             0141*  ; redundantly save orientation and heading
043351             0142*  en_nav_computevelocities:
043351             0143*  ; set x/y component velocities based on bearing to player
043351 FD 2A 42 18 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043356 E5          0145*      push hl ; we need it back to set rotation frame
043357 FD 17 17    0146*      ld de,(iy+sprite_vel)
04335A CD 6B 26 04 0147*      call polar_to_cartesian
04335E FD 2A 42 18 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043363 FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
043366 FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
043369             0151*  ; change the animation frame to match heading
043369             0152*  ; by dividng the heading by 8
043369 E1          0153*      pop hl ; get back Heading
04336A 7C          0154*      ld a,h
04336B CB 3F       0155*      srl a
04336D CB 3F       0156*      srl a
04336F CB 3F       0157*      srl a
043371 CD 29 24 04 0158*      call vdu_sprite_select_frame
043375             0159*  
043375             0160*  move_enemy_sprite:
043375 FD 2A 42 18 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04337A             0162*  ; x-axis movement
04337A FD 27 0B    0163*      ld hl,(iy+sprite_x)
04337D FD 17 11    0164*      ld de,(iy+sprite_xvel)
043380 19          0165*      add hl,de
043381 FD 2F 0B    0166*      ld (iy+sprite_x),hl
043384             0167*  ; y-axis movement
043384 FD 27 0E    0168*      ld hl,(iy+sprite_y)
043387 FD 17 14    0169*      ld de,(iy+sprite_yvel)
04338A 19          0170*      add hl,de
04338B FD 2F 0E    0171*      ld (iy+sprite_y),hl
04338E             0172*  ; detect screen edge collisions
04338E AF          0173*      xor a  ; reset screen edge collision flag and clear carry
04338F 32 46 18 04 0174*      ld (sprite_screen_edge),a
043393             0175*  ; y-axis first since we already have it in hl
043393 11 00 00 00 0176*      ld de,-sprite_top*256
043397 ED 5A       0177*      adc hl,de
043399 FA C3 33 04 0178*      jp m,@top
04339D ED 52       0179*      sbc hl,de ; hl back to original value
04339F 11 00 C1 FE 0180*      ld de,-sprite_bottom*256
0433A3 ED 5A       0181*      adc hl,de
0433A5 F2 CD 33 04 0182*      jp p,@bottom
0433A9             0183*  @xaxis:
0433A9 FD 27 0B    0184*      ld hl,(iy+sprite_x)
0433AC 11 00 00 00 0185*      ld de,-sprite_left*256
0433B0 ED 5A       0186*      adc hl,de
0433B2 FA E8 33 04 0187*      jp m,@left
0433B6 ED 52       0188*      sbc hl,de ; hl back to original value
0433B8 11 00 11 FF 0189*      ld de,-sprite_right*256
0433BC ED 5A       0190*      adc hl,de
0433BE F2 F6 33 04 0191*      jp p,@right
0433C2             0192*  ; no edge collisions so go home
0433C2 C9          0193*      ret
0433C3             0194*  @top:
0433C3 3E 08       0195*      ld a,collide_top
0433C5 21 00 00 00 0196*      ld hl,sprite_top*256
0433C9 C3 D3 33 04 0197*      jp @collide_y
0433CD             0198*  @bottom:
0433CD 3E 04       0199*      ld a,collide_bottom
0433CF 21 00 3F 01 0200*      ld hl,sprite_bottom*256
0433D3             0201*  @collide_y:
0433D3 32 46 18 04 0202*      ld (sprite_screen_edge),a
0433D7 FD 2F 0E    0203*      ld (iy+sprite_y),hl
0433DA             0204*  ; reverse y-axis velocity
0433DA FD 27 14    0205*      ld hl,(iy+sprite_yvel)
0433DD CD 46 25 04 0206*      call neg_hlu
0433E1 FD 2F 14    0207*      ld (iy+sprite_yvel),hl
0433E4             0208*  ; go check for x-axis collisions
0433E4 C3 A9 33 04 0209*      jp @xaxis
0433E8             0210*  @left:
0433E8 3A 46 18 04 0211*      ld a,(sprite_screen_edge)
0433EC F6 02       0212*      or a,collide_left
0433EE 21 00 00 00 0213*      ld hl,sprite_left*256
0433F2 C3 00 34 04 0214*      jp @collide_x
0433F6             0215*  @right:
0433F6 3A 46 18 04 0216*      ld a,(sprite_screen_edge)
0433FA F6 01       0217*      or a,collide_right
0433FC 21 00 EF 00 0218*      ld hl,sprite_right*256
043400             0219*  @collide_x:
043400 32 46 18 04 0220*      ld (sprite_screen_edge),a
043404 FD 2F 0B    0221*      ld (iy+sprite_x),hl
043407             0222*  ; reverse x-axis velocity
043407 FD 27 11    0223*      ld hl,(iy+sprite_xvel)
04340A CD 46 25 04 0224*      call neg_hlu
04340E FD 2F 11    0225*      ld (iy+sprite_xvel),hl
043411             0226*  ; final collision flag to a and return
043411 3A 46 18 04 0227*      ld a,(sprite_screen_edge)
043415 C9          0228*      ret
043416             0229*  
043416             0230*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
043416             0231*  ; ; each sprite in the table must have one of these defined
043416             0232*  ; ; but they need not be unique to a particular sprite
043416             0233*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
043416             0234*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
043416             0235*  ; ; but they can call anything they want between those two endpoints
043416             0236*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
043416             0237*  
043416             0238*  ; move_nop: ; does nothing but burn a few cycles changing the PC
043416             0239*  ;     jp move_enemies_loop_return
043416             0240*  
043416             0241*  ; move_explosion:
043416             0242*  ;     call animate_explosion
043416             0243*  ;     jp move_enemies_loop_return
043416             0244*  
043416             0245*  move_enemy_small:
043416 CD 3E 33 04 0246*      call en_nav
04341A CD 3E 35 04 0247*      call check_collisions
04341E C3 D2 32 04 0248*      jp move_enemies_loop_return
043422             0249*  
043422             0250*  ; move_enemy_medium:
043422             0251*  ;     call en_nav
043422             0252*  ;     call check_collisions
043422             0253*  ;     jp move_enemies_loop_return
043422             0254*  
043422             0255*  ; move_enemy_large:
043422             0256*  ;     call en_nav
043422             0257*  ;     call check_collisions
043422             0258*  ;     jp move_enemies_loop_return
043422             0259*  
043422             0260*  ; move_landing_pad:
043422             0261*  ;     call move_active_tiles
043422             0262*  ;     call check_collisions
043422             0263*  ; ; is it time to launch an enemy?
043422             0264*  ;     ld hl,sprite_move_timer
043422             0265*  ;     dec (hl)
043422             0266*  ;     jp nz,move_enemies_loop_return
043422             0267*  ;     call enemy_init_from_landing_pad
043422             0268*  ;     ; reset move timer so can spawn again if player doesn't take us out
043422             0269*  ;     call rand_8     ; snag a random number
043422             0270*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043422             0271*  ;     add a,64 ; range is now 64-127
043422             0272*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
043422             0273*  ;     jp move_enemies_loop_return
043422             0274*  
043422             0275*  enemy_init_from_landing_pad:
043422             0276*  ; get next available spriteId
043422 CD 69 18 04 0277*      call table_get_next_id
043426 D0          0278*      ret nc ; no carry means no free sprite slots, so we go home
043427             0279*  ; ix comes back with the pointer to the new sprite variables
043427 DD E5       0280*      push ix ; de picks it up when we're ready for the copy to the table
043429             0281*  ; a comes back with the spriteId of the new sprite
043429 32 7F 34 04 0282*      ld (@id),a
04342D             0283*  ; initialize the new sprite
04342D CD C6 23 04 0284*      call vdu_sprite_select
043431 CD D9 23 04 0285*      call vdu_sprite_clear_frames
043435 21 14 01 00 0286*      ld hl,BUF_SEEKER_000
043439 06 20       0287*      ld b,32
04343B             0288*  @load_frames:
04343B C5          0289*      push bc
04343C E5          0290*      push hl
04343D CD 1B 25 04 0291*      call vdu_sprite_add_buff
043441 E1          0292*      pop hl
043442 23          0293*      inc hl
043443 C1          0294*      pop bc
043444 10 F5       0295*      djnz @load_frames
043446             0296*  ; copy coordinates of active sprite to new sprite
043446 FD 2A 42 18 0297*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04344B             0298*      ; ld hl,(iy+sprite_x)
04344B             0299*  	; ld hl,0x008000 ; debug
04344B             0300*  
04344B CD EB 25 04 0301*      call rand_8
04344F 21 00 00 00 0302*      ld hl,0
043453 67          0303*      ld h,a
043454             0304*  
043454 22 8A 34 04 0305*      ld (@x),hl
043458             0306*      ; ld hl,(iy+sprite_y)
043458             0307*      ; ld hl,0x002000 ; debug
043458             0308*  
043458 CD EB 25 04 0309*      call rand_8
04345C 21 00 00 00 0310*      ld hl,0
043460 67          0311*      ld h,a
043461             0312*  
043461 22 8D 34 04 0313*      ld (@y),hl
043465 CD EB 25 04 0314*      call rand_8
043469 E6 01       0315*      and %00000001 ; 50/50 chance of moving left or right on spanw
04346B 32 A2 34 04 0316*      ld (@move_step),a
04346F             0317*  ; now copy to the table
04346F 21 7F 34 04 0318*      ld hl,@id ; address to copy from
043473 D1          0319*      pop de ; address to copy to (was ix)
043474 01 26 00 00 0320*      ld bc,table_bytes_per_record ; number of bytes to copy
043478 ED B0       0321*      ldir ; copy the records from local scratch to sprite table
04347A             0322*  ; finally, make the new sprite visible
04347A CD 3C 24 04 0323*      call vdu_sprite_show
04347E C9          0324*      ret
04347F 00          0325*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
043480 01          0326*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
043481 14 01 00    0327*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
043484 16 34 04    0328*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
043487 03          0329*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
043488 10          0330*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
043489 10          0331*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
04348A 00 00 00    0332*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
04348D 00 00 00    0333*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043490 00 00 00    0334*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043493 00 00 00    0335*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043496 80 02 00    0336*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
043499 00 80 00    0337*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
04349C 00 80 00    0338*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
04349F 00          0339*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
0434A0 00          0340*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
0434A1 01          0341*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
0434A2 00          0342*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
0434A3 20          0343*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
0434A4 02          0344*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
0434A5             0345*  
0434A5             0346*  ; move_laser_turret:
0434A5             0347*  ; ; compute orientation to player
0434A5             0348*  ;     call orientation_to_player
0434A5             0349*  ; ; h.l 8.8 fixed angle256 to player
0434A5             0350*  ; ; bc and de as signed 16-bit integers
0434A5             0351*  ; ; representing delta-x/y *to* target respectively
0434A5             0352*  ;     ld (Bearing_t),hl
0434A5             0353*  ;     ld hl,0x0400
0434A5             0354*  ;     ld (Vp),hl
0434A5             0355*  ;     call targeting_computer
0434A5             0356*  ;     ld (sprite_heading),hl ; store bearing to player
0434A5             0357*  ; ; is it time to launch a fireball?
0434A5             0358*  ;     ld hl,sprite_move_timer
0434A5             0359*  ;     dec (hl)
0434A5             0360*  ;     jp nz,move_laser_turret_boilerplate
0434A5             0361*  ;     call fireballs_init
0434A5             0362*  ;     ; reset move timer so can fire again if player doesn't take us out
0434A5             0363*  ;     call rand_8     ; snag a random number
0434A5             0364*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0434A5             0365*  ;     add a,64 ; range is now 64-127
0434A5             0366*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0434A5             0367*  ; move_laser_turret_boilerplate:
0434A5             0368*  ;     call move_active_tiles
0434A5             0369*  ;     call check_collisions
0434A5             0370*  ;     jp move_enemies_loop_return
0434A5             0371*  
0434A5             0372*  ; fireballs_init:
0434A5             0373*  ;     call sprite_variables_to_stack
0434A5             0374*  
0434A5             0375*  ;     ld hl,fireballs
0434A5             0376*  ;     ld (sprite_base_bufferId),hl
0434A5             0377*  
0434A5             0378*  ;     ld hl,move_fireballs
0434A5             0379*  ;     ld (sprite_move_program),hl
0434A5             0380*  
0434A5             0381*  ;     ld a,%11 ; collides with laser and player
0434A5             0382*  ;     ; ld a,%10 ; collides with laser DEBUG
0434A5             0383*  ;     ld (iy+sprite_collisions),a
0434A5             0384*  
0434A5             0385*  ;     ld hl,(Vp)
0434A5             0386*  ;     ld (sprite_vel),hl
0434A5             0387*  ;     ld hl,(Vp_x)
0434A5             0388*  ;     ld (sprite_xvel),hl
0434A5             0389*  ;     ld hl,(Vp_y)
0434A5             0390*  ;     inc h ; account for ground movement
0434A5             0391*  ;     ld (sprite_yvel),hl
0434A5             0392*  
0434A5             0393*  ;     xor a ; zero a
0434A5             0394*  ;     ld (sprite_animation),a
0434A5             0395*  ;     ld (sprite_move_step),a
0434A5             0396*  ;     ld (sprite_move_timer),a
0434A5             0397*  
0434A5             0398*  ;     ld a,6 ; 1/10th of a second timer
0434A5             0399*  ;     ld (sprite_animation_timer),a
0434A5             0400*  
0434A5             0401*  ;     ld a,0x00 ; BCD
0434A5             0402*  ;     ld (sprite_points),a
0434A5             0403*  ;     ld a,1 ; binary
0434A5             0404*  ;     ld (sprite_shield_damage),a
0434A5             0405*  
0434A5             0406*  ;     call table_add_record ; plops that on the sprite stack for later
0434A5             0407*  ;     call sprite_variables_from_stack ; come back to where we started
0434A5             0408*  ;     ret
0434A5             0409*  
0434A5             0410*  ; move_fireballs:
0434A5             0411*  ;     call move_enemy_sprite ; move sprite
0434A5             0412*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
0434A5             0413*  ;     and a ; if zero we're still within screen bounds
0434A5             0414*  ;     jr z,move_fireballs_alive
0434A5             0415*  ; ; otherwise kill sprite
0434A5             0416*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
0434A5             0417*  ;     ld (iy+sprite_collisions),a
0434A5             0418*  ;     jp move_enemies_loop_return
0434A5             0419*  ; move_fireballs_alive:
0434A5             0420*  ;     ld a,(sprite_animation_timer)
0434A5             0421*  ;     dec a
0434A5             0422*  ;     ld (sprite_animation_timer),a
0434A5             0423*  ;     jr nz,move_fireballs_draw
0434A5             0424*  ;     ld a,(sprite_animation)
0434A5             0425*  ;     xor %1
0434A5             0426*  ;     ld (sprite_animation),a
0434A5             0427*  ;     ld a,6 ; 1/10th of a second timer
0434A5             0428*  ;     ld (sprite_animation_timer),a
0434A5             0429*  ;     ; fall through
0434A5             0430*  
0434A5             0431*  ; move_fireballs_draw:
0434A5             0432*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0434A5             0433*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0434A5             0434*  ;     call check_collisions
0434A5             0435*  ;     jp move_enemies_loop_return
0434A5             0436*  
0434A5             0437*  ; compute orientation to player
0434A5             0438*  ; based on relative positions
0434A5             0439*  ; returns: h.l 16.8 fixed angle256 to player
0434A5             0440*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0434A5             0441*  ;    representing delta-x/y *to* target respectively
0434A5             0442*  orientation_to_player:
0434A5 FD 2A 42 18 0443*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0434AA FD 07 0B    0444*      ld bc,(iy+sprite_x)
0434AD FD 17 0E    0445*      ld de,(iy+sprite_y)
0434B0 DD 2A 50 30 0446*      ld ix,(player_x)
       04          
0434B5 FD 2A 53 30 0447*      ld iy,(player_y)
       04          
0434BA CD A0 26 04 0448*      call dxy168
0434BE C5          0449*      push bc
0434BF D5          0450*      push de
0434C0 CD EC 26 04 0451*      call atan2_168fast
0434C4 D1          0452*      pop de
0434C5 C1          0453*      pop bc
0434C6 FD 2A 42 18 0454*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0434CB C9          0455*      ret
0434CC             0456*  
0434CC             0457*  
0434CC             0458*  ; targeting_computer scratch variables
0434CC 00 00       0459*  Bearing_t: dw #0000 ; 8.8 fixed
0434CE 00 00       0460*  Heading_t: dw #0000 ; 8.8 fixed
0434D0 00 00       0461*  Vp: dw #0000 ; 8.8 fixed
0434D2 00 00       0462*  Vp_x: dw #0000 ; 8.8 fixed
0434D4 00 00       0463*  Vp_y: dw #0000 ; 8.8 fixed
0434D6 00 00       0464*  Vt: dw #0000 ; 8.8 fixed
0434D8 00 00       0465*  Vt_x: dw #0000 ; 8.8 fixed
0434DA 00 00       0466*  Vt_y: dw #0000 ; 8.8 fixed
0434DC             0467*  
0434DC             0468*  
0434DC             0469*  ; ; Inputs:   see scratch variables
0434DC             0470*  ; ; Note:     a call to orientation_to_player provides these inputs
0434DC             0471*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
0434DC             0472*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
0434DC             0473*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
0434DC             0474*  ; targeting_computer:
0434DC             0475*  ; ; compute target velocity from x,y component velocities
0434DC             0476*  ;     ld bc,(player_xvel)
0434DC             0477*  ;     ld de,(player_yvel)
0434DC             0478*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
0434DC             0479*  
0434DC             0480*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
0434DC             0481*  ;     ld (Heading_t),bc
0434DC             0482*  ;     ld (Vt),de
0434DC             0483*  
0434DC             0484*  ; ; compute Heading_t-Bearing_t
0434DC             0485*  ;     ld h,b
0434DC             0486*  ;     ld l,c
0434DC             0487*  ;     ld bc,(Bearing_t)
0434DC             0488*  ;     and a ; clear carry
0434DC             0489*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
0434DC             0490*  
0434DC             0491*  ; ; compute sin(Heading_t-Bearing_t)
0434DC             0492*  ;     ld b,h
0434DC             0493*  ;     ld c,l
0434DC             0494*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
0434DC             0495*  
0434DC             0496*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
0434DC             0497*  ;     ex de,hl
0434DC             0498*  ;     ld bc,(Vt)
0434DC             0499*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
0434DC             0500*  
0434DC             0501*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
0434DC             0502*  ;     ld b,h
0434DC             0503*  ;     ld c,l
0434DC             0504*  ;     ld de,(Vp)
0434DC             0505*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
0434DC             0506*  ; ; answer is in radians, convert to degrees256
0434DC             0507*  ;     ex de,hl
0434DC             0508*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
0434DC             0509*  ;     call BC_Mul_DE_88
0434DC             0510*  
0434DC             0511*  ; ; add lead angle to target bearing
0434DC             0512*  ;     ld de,(Bearing_t)
0434DC             0513*  ;     add hl,de ; h.l=lead angle+target bearing
0434DC             0514*  ;     push hl
0434DC             0515*  
0434DC             0516*  ; ; compute component projectile velocities
0434DC             0517*  ;     ld b,h
0434DC             0518*  ;     ld c,l
0434DC             0519*  ;     ld de,(Vp)
0434DC             0520*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
0434DC             0521*  
0434DC             0522*  ;     ld (Vp_x),bc
0434DC             0523*  ;     ld (Vp_y),de
0434DC             0524*  ;     pop hl ; h.l=lead angle+target bearing
0434DC             0525*  ;     ret
0434DC             0526*  
0434DC             0527*  ; this routine vanquishes the enemy sprite
0434DC             0528*  ; and replaces it with an animated explosion
0434DC             0529*  ; we jump here instead of call because
0434DC             0530*  ; we want to return to differing locations in the loop
0434DC             0531*  ; depending on whether we're still sploding
0434DC             0532*  ; destroys: everything except index registers
0434DC             0533*  ; returns: an incandescent ball of debris and gas
0434DC             0534*  kill_nurple:
0434DC             0535*  ; ; tally up points
0434DC             0536*  ;     ld bc,0
0434DC             0537*  ;     ld a,(sprite_points)
0434DC             0538*  ;     ld e,a
0434DC             0539*  ;     ld d,0
0434DC             0540*  ;     ld hl,add_bcd_arg2
0434DC             0541*  ;     call set_bcd
0434DC             0542*  ;     ld hl,player_score
0434DC             0543*  ;     ld de,add_bcd_arg2
0434DC             0544*  ;     ld a,3 ; number of bytes to add
0434DC             0545*  ;     call add_bcd
0434DC             0546*  ; ; initialize explosion
0434DC             0547*  ; init_explosion:
0434DC             0548*  ;     ld hl,explosion
0434DC             0549*  ;     ld (sprite_base_bufferId),hl
0434DC             0550*  ;     ld hl,move_explosion
0434DC             0551*  ;     ld (sprite_move_program),hl
0434DC             0552*  ;     ld a,%00000000 ; collides with nothing
0434DC             0553*  ;     ld (iy+sprite_collisions),a
0434DC             0554*  ;     ld hl,0 ; north
0434DC             0555*  ;     ld (sprite_heading),hl
0434DC             0556*  ;     ld a,0x04 ; will decrement to 03
0434DC             0557*  ;     ld (sprite_animation),a
0434DC             0558*  ;     ld a,0x07 ; 7/60th of a second timer
0434DC             0559*  ;     ld (sprite_animation_timer),a
0434DC             0560*  ;     xor a
0434DC             0561*  ;     ld (sprite_move_timer),a
0434DC             0562*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0434DC             0563*  ; ; fall through to next_explosion
0434DC             0564*  ; next_explosion:
0434DC             0565*  ;     ld a,(sprite_animation)
0434DC             0566*  ;     dec a ; if rolled negative from zero,we're done sploding
0434DC             0567*  ;     jp m,done_explosion
0434DC             0568*  ;     ld (sprite_animation),a
0434DC             0569*  ;     ld a,0x7 ; 7/60th of a second timer
0434DC             0570*  ;     ld (sprite_animation_timer),a
0434DC             0571*  ; ; fall through to animate_explosion
0434DC             0572*  ; animate_explosion:
0434DC             0573*  ;     ld hl,sprite_y+1
0434DC             0574*  ;     inc (hl) ; move explosion down 1 pixel
0434DC             0575*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
0434DC             0576*  ;     ld hl,sprite_animation_timer
0434DC             0577*  ;     dec (hl) ; if timer is zero,we do next animation
0434DC             0578*  ;     jr z,next_explosion
0434DC             0579*  ;     ;otherwise we fall through to draw the current one
0434DC             0580*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0434DC             0581*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0434DC             0582*  ;     ret ; now we go back to caller
0434DC             0583*  ; done_explosion:
0434DC 3E 80       0584*      ld a,%10000000 ; high bit set is non-specific kill-me flag
0434DE FD 2A 42 18 0585*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
0434E3 FD 77 08    0586*      ld (iy+sprite_collisions),a
0434E6 C9          0587*      ret ; now we go back to caller
0434E7             0588*  
0434E7             0589*  ; game_over:
0434E7             0590*  ;     jp new_game
0434E7             0591*  
0434E7             0592*  ; it's presumed we've already checked that laser is alive
0434E7             0593*  collision_enemy_with_laser:
0434E7 DD 2A 76 35 0594*      ld ix,(laser_x)
       04          
0434EC FD 2A 79 35 0595*      ld iy,(laser_y)
       04          
0434F1 3A 74 35 04 0596*      ld a,(laser_dim_x)
0434F5 CB 2F       0597*      sra a ; divide by 2
0434F7 F5          0598*      push af ; we need this later
0434F8 C3 0D 35 04 0599*      jp collision_enemy
0434FC             0600*  
0434FC             0601*  ; it's presumed we've already checked that player is alive
0434FC             0602*  collision_enemy_with_player:
0434FC DD 2A 50 30 0603*      ld ix,(player_x)
       04          
043501 FD 2A 53 30 0604*      ld iy,(player_y)
       04          
043506 3A 4E 30 04 0605*      ld a,(player_dim_x)
04350A CB 2F       0606*      sra a ; divide by 2
04350C F5          0607*      push af ; we need this later
04350D             0608*      ; fall through to collision_enemy
04350D             0609*  
04350D             0610*  ; compute the distance between the two sprites' centers
04350D             0611*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
04350D             0612*  collision_enemy:
04350D             0613*  ; back up iy because we need it as the sprite table pointer
04350D FD E5       0614*      push iy
04350F FD 2A 42 18 0615*      ld iy,(table_pointer)
       04          
043514 FD 27 0B    0616*      ld hl,(iy+sprite_x)
043517 FD 7E 09    0617*      ld a,(iy+sprite_dim_x)
04351A CB 2F       0618*      sra a
04351C F5          0619*      push af ; we need this later
04351D E5          0620*      push hl
04351E C1          0621*      pop bc ; bc = x0
04351F FD 27 0E    0622*      ld hl,(iy+sprite_y)
043522 FD 7E 0A    0623*      ld a,(iy+sprite_dim_y)
043525 EB          0624*      ex de,hl ; de = y0
043526 F1          0625*      pop af ; TODO: srsly, this is the best way to do this?
043527 FD E1       0626*      pop iy
043529 F5          0627*      push af
04352A CD C7 26 04 0628*      call distance168
04352E             0629*  
04352E             0630*  ; ; subtract sum of radii from distance between centers
04352E             0631*  ;     ld de,0
04352E             0632*  ;     pop af ; radius of enemy sprite
04352E             0633*  ;     ld e,a
04352E             0634*  ;     pop af ; radius of player or laser sprite
04352E             0635*  ;     add a,e
04352E             0636*  ;     ld e,a
04352E             0637*  ;     and a ; clear carry
04352E             0638*  ;     sbc hl,de
04352E             0639*  ;     jr c,collision_enemy_is
04352E             0640*  ;     xor a
04352E             0641*  ;     ret
04352E             0642*  ; temp fix TODO: remove this
04352E F1          0643*      pop af
04352F F1          0644*      pop af
043530 11 00 10 00 0645*      ld de,16*256
043534 A7          0646*      and a
043535 ED 52       0647*      sbc hl,de
043537 38 02       0648*      jr c,collision_enemy_is
043539 AF          0649*      xor a
04353A C9          0650*      ret
04353B             0651*  collision_enemy_is:
04353B AF          0652*      xor a
04353C 3C          0653*      inc a
04353D C9          0654*      ret
04353E             0655*  
04353E             0656*  ; ; looks up what enemy sprite collides with
04353E             0657*  ; ; detects collisions
04353E             0658*  ; ; and sets things to sploding accordingly
04353E             0659*  ; check_collisions:
04353E             0660*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
04353E             0661*  ;     and a ; if this is zero,
04353E             0662*  ;     ret z ; there's nothing to do
04353E             0663*  ;     and %01 ; do we collide with player?
04353E             0664*  ;     jr z,move_enemies_laser ; if not,check laser collision
04353E             0665*  ;     call collision_enemy_with_player ; otherwise see if we hit player
04353E             0666*  ;     and a ; was there a collision?
04353E             0667*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
04353E             0668*  ; ; yes collision with player
04353E             0669*  ;     ; deduct shield damage
04353E             0670*  ;     ld hl,sprite_shield_damage
04353E             0671*  ;     ld a,(player_shields)
04353E             0672*  ;     sub (hl)
04353E             0673*  ;     ld (player_shields),a
04353E             0674*  ; ; if shields >= 0,player survives
04353E             0675*  ;     jp p,check_collisions_kill_nurple
04353E             0676*  ; ; otherwise update player status so it will die
04353E             0677*  ;     ld a,(player_collisions)
04353E             0678*  ;     or %10 ; sets bit 1,meaning player just died
04353E             0679*  ;     ld (player_collisions),a
04353E             0680*  ;     ; fall through
04353E             0681*  ; check_collisions_kill_nurple:
04353E             0682*  ; ; kill enemy and replace with explosion
04353E             0683*  ;     call kill_nurple
04353E             0684*  ;     ret ; and out
04353E             0685*  
04353E             0686*  check_collisions:
04353E CD FC 34 04 0687*      call collision_enemy_with_player ; did we hit the player?
043542 A7          0688*      and a ; was there a collision?
043543 C8          0689*      ret z ; if not,we're done
043544 CD DC 34 04 0690*      call kill_nurple ; otherwise kill enemy
043548 C9          0691*      ret
043549             0692*  
043549             0693*  ; did we hit the laser?
043549             0694*  move_enemies_laser:
043549 FD 7E 08    0695*      ld a,(iy+sprite_collisions) ; snag what we collide with again
04354C E6 02       0696*      and %10 ; do we even collide with laser?
04354E C8          0697*      ret z ; if not,we're out
04354F 3A 73 35 04 0698*      ld a,(laser_collisions) ; is laser alive?
043553 E6 01       0699*      and %1 ; if bit 0 is not set laser is dead
043555 C8          0700*      ret z ; so we're out
043556 CD E7 34 04 0701*      call collision_enemy_with_laser ; otherwise check for collision
04355A A7          0702*      and a ; was there a collision?
04355B C8          0703*      ret z ; if not,we're done
04355C             0704*  ; otherwise we mark laser for termination and kill enemy
04355C             0705*  ; update laser status so it will die
04355C 3A 73 35 04 0706*      ld a,(laser_collisions)
043560 F6 02       0707*      or %10 ; bit 1 set means laser just died
043562 32 73 35 04 0708*      ld (laser_collisions),a
043566 CD DC 34 04 0709*      call kill_nurple ; yes there was a collision,so kill enemy
04356A C9          0710*      ret ; we're outta' here
04356B             0064   	include "laser.inc"
04356B             0001*  ; ##### LASER SPRITE PARAMETERS #####
04356B             0002*  ; uses the same offsets from its table base as the main sprite table:
04356B             0003*  laser_start_variables: ; label marking beginning of table
04356B 11          0004*  laser_id:               db table_max_records+1
04356C 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
04356D 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
043570 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
043573 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
043574 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043575 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043576 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043579 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
04357C 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04357F 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043582 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
043585 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043588 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
04358B 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
04358C 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
04358D 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
04358E 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
04358F 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
043590 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
043591             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
043591             0025*  
043591             0026*  ; laser_control:
043591             0027*  ; ; is laser already active?
043591             0028*  ;     ld a,(laser_collisions)
043591             0029*  ;     and %00000001 ; bit zero is lit if laser is active
043591             0030*  ;     jr nz,laser_move ; move laser if not zero
043591             0031*  ; ; otherwise check if laser fired
043591             0032*  ;     in a,(#82) ; keyboard
043591             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
043591             0034*  ;     ret z ; go back if laser not fired
043591             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
043591             0036*  ; ; set laser status to active (set bit 0)
043591             0037*  ;     ld a,%1
043591             0038*  ;     ld (laser_collisions),a
043591             0039*  ; ; initialize laser position
043591             0040*  ;     ld a,(player_x+1) ; we only need the integer part
043591             0041*  ;     ; add a,6 ; horizontal center with player sprite
043591             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
043591             0043*  ;     ld a,(player_y+1) ; we only need the integer part
043591             0044*  ;     add a,-6 ; set laser y a few pixels above player
043591             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
043591             0046*  ;     ; fall through to laser_move
043591             0047*  
043591             0048*  ; laser_move:
043591             0049*  ; ; begin setting laser to active sprite
043591             0050*  ;     ld hl,lasers
043591             0051*  ;     ld (sprite_base_bufferId),hl
043591             0052*  ;     ld hl,0 ; north
043591             0053*  ;     ld (sprite_heading),hl
043591             0054*  ;     xor a ; laser has no animations yet :-(
043591             0055*  ;     ld (sprite_animation),a
043591             0056*  ;     ; we set position here for the time being as a default
043591             0057*  ;     ; in case the laser is flagged for deletion
043591             0058*  ;     ; load sprite_x with laser x position (we do y further down)
043591             0059*  ;     ld hl,(laser_x)
043591             0060*  ;     ld (sprite_x),hl
043591             0061*  ; ; did laser just die?
043591             0062*  ;     ld a,(laser_collisions)
043591             0063*  ;     bit 1,a ; z if laser didn't just die
043591             0064*  ;     jr z,laser_not_dead_yet
043591             0065*  ; ; yes laser died
043591             0066*  ;     call kill_laser
043591             0067*  ;     ret ; done
043591             0068*  ; laser_not_dead_yet:
043591             0069*  ; ; draw it
043591             0070*  ; ; update laser y position
043591             0071*  ;     ld hl,(laser_y) ; grab laser y position
043591             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
043591             0073*  ;     add hl,de ; add y velocity to y pos
043591             0074*  ;     ld (sprite_y),hl ; update laser y position
043591             0075*  ;     ld (laser_y),hl ; update laser y position
043591             0076*  ; ; are we at top of screen?
043591             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
043591             0078*  ;     sub h ; no carry if above threshold
043591             0079*  ;     jr c,finally_draw_the_frikken_laser
043591             0080*  ;     ; if at top of screen,laser dies
043591             0081*  ;     call kill_laser
043591             0082*  ;     ret
043591             0083*  ; ; otherwise,finally draw the frikken laser
043591             0084*  ; finally_draw_the_frikken_laser:
043591             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043591             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043591             0087*  ; ; all done
043591             0088*  ;     ret
043591             0089*  
043591             0090*  ; kill_laser:
043591             0091*  ; ; update status to inactive
043591             0092*  ;     xor a ; zero out a
043591             0093*  ;     ld (laser_collisions),a
043591             0094*  ;     ret
043591             0065   	include "timer.inc"
043591             0001*  ; Table 32. Timer Control Registers
043591             0002*  ; this constant is the base address of the timer control registers
043591             0003*  ; each timer takes three bytes:
043591             0004*  ;   0: control register
043591             0005*  ;   1: low byte of timer reset value
043591             0006*  ;   2: high byte of timer reset value
043591             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043591             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043591             0009*  TMR_CTL:     equ 80h
043591             0010*  
043591             0011*  ; Timer Control Register Bit Definitions
043591             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043591             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043591             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043591             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043591             0016*                              ; the TMRx_CTL register is read.
043591             0017*  
043591             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043591             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043591             0020*  
043591             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043591             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043591             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043591             0024*                              ; written to the counter when the end-of-count value is reached.
043591             0025*  
043591             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043591             0027*  CLK_DIV_256:  equ %00001100 ;
043591             0028*  CLK_DIV_64:   equ %00001000 ;
043591             0029*  CLK_DIV_16:   equ %00000100 ;
043591             0030*  CLK_DIV_4:    equ %00000000 ;
043591             0031*  
043591             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043591             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043591             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043591             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043591             0036*                              ; programmer must ensure that this bit is set to 1 each time
043591             0037*                              ; SINGLE-PASS mode is used.
043591             0038*  
043591             0039*  ; disable/enable the programmable reload timer
043591             0040*  PRT_EN_0:     equ %00000000 ;
043591             0041*  PRT_EN_1:     equ %00000001 ;
043591             0042*  
043591             0043*  ; Table 37. Timer Input Source Select Register
043591             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043591             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043591             0046*  ;   00: System clock / CLK_DIV
043591             0047*  ;   01: RTC / CLK_DIV
043591             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043591             0049*  ;   10: GPIO port B pin 1.
043591             0050*  ;   11: GPIO port B pin 1.
043591             0051*  TMR_ISS:   equ 92h ; register address
043591             0052*  
043591             0053*  ; Table 51. Real-Time Clock Control Register
043591             0054*  RTC_CTRL: equ EDh ; register address
043591             0055*  
043591             0056*  ; alarm interrupt disable/enable
043591             0057*  RTC_ALARM_0:    equ %00000000
043591             0058*  RTC_ALARM_1:    equ %10000000
043591             0059*  
043591             0060*  ; interrupt on alarm disable/enable
043591             0061*  RTC_INT_ENT_0:  equ %00000000
043591             0062*  RTC_INT_ENT_1:  equ %01000000
043591             0063*  
043591             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043591             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043591             0066*  
043591             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043591             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043591             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043591             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043591             0071*  
043591             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043591             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043591             0074*  
043591             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043591             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043591             0077*  
043591             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043591             0079*                                  ; RTC counter is enabled.
043591             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043591             0081*                                  ; RTC counter is disabled.
043591             0082*  
043591             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043591             0084*  
043591             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043591             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043591 00 00 00    0087*  prt_reload: dl 0x000000
043594             0088*  
043594             0089*  ; set PRT timer
043594             0090*  prt_set:
043594 21 00 00 00 0091*      ld hl,0
043598 22 E2 35 04 0092*      ld (prt_irq_counter),hl
04359C 2A 91 35 04 0093*      ld hl,(prt_reload)
0435A0 ED 29 84    0094*      out0 ($84),l
0435A3 ED 21 85    0095*  	out0 ($85),h
0435A6             0096*  ; disable timer
0435A6 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0435A8 ED 39 83    0098*  	out0 ($83),a
0435AB             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0435AB 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0435AD ED 39 83    0101*  	out0 ($83),a
0435B0 C9          0102*      ret
0435B1             0103*  
0435B1             0104*  ; ===============================================
0435B1             0105*  ; PRT Timer Interrupt Handling
0435B1             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0435B1             0107*  ; -----------------------------------------------
0435B1             0108*  prt_irq_init:
0435B1             0109*      ; set up interrupt vector table 2
0435B1 21 00 00 00 0110*  	ld hl,0
0435B5 3A 0C 01 00 0111*  	ld a,($10c)
0435B9 6F          0112*  	ld l,a
0435BA 3A 0D 01 00 0113*  	ld a,($10d)
0435BE 67          0114*  	ld h,a
0435BF             0115*  
0435BF             0116*  	; skip over CALL ($c3)
0435BF 23          0117*  	inc hl
0435C0             0118*  	; load address of jump into vector table 2 (in ram)
0435C0 ED 27       0119*  	ld hl,(hl)
0435C2             0120*  
0435C2             0121*  	; write CALL prt_irq_handler to vector table 2
0435C2 3E C3       0122*  	ld a,$c3
0435C4 77          0123*  	ld (hl),a
0435C5 23          0124*  	inc hl
0435C6 11 CD 35 04 0125*  	ld de,prt_irq_handler
0435CA ED 1F       0126*  	ld (hl),de
0435CC             0127*  
0435CC C9          0128*      ret
0435CD             0129*  
0435CD             0130*  prt_irq_handler:
0435CD F3          0131*  	di
0435CE F5          0132*  	push af
0435CF E5          0133*      push hl
0435D0 ED 38 83    0134*  	in0 a,($83)
0435D3 2A E2 35 04 0135*  	ld hl,(prt_irq_counter)
0435D7 23          0136*  	inc hl
0435D8 22 E2 35 04 0137*  	ld (prt_irq_counter),hl
0435DC E1          0138*      pop hl
0435DD F1          0139*  	pop af
0435DE FB          0140*  	ei
0435DF 5B ED 4D    0141*  	reti.l
0435E2             0142*  
0435E2             0143*  prt_irq_counter:
0435E2 00 00 00    0144*  	.dl 0
0435E5             0145*  prt_irq_counter_saved:
0435E5 00 00 00    0146*      .dl 0
0435E8             0147*  
0435E8             0148*  prt_loop_reset:
0435E8 E5          0149*      push hl
0435E9 21 00 00 00 0150*  	ld hl,0
0435ED 22 E2 35 04 0151*  	ld (prt_irq_counter),hl
0435F1 22 53 36 04 0152*      ld (prt_loop_counter),hl
0435F5 22 56 36 04 0153*      ld (prt_loops),hl
0435F9 CD 94 35 04 0154*      call prt_set
0435FD E1          0155*      pop hl
0435FE C9          0156*      ret
0435FF             0157*  
0435FF             0158*  prt_loop_start:
0435FF E5          0159*      push hl
043600 21 00 00 00 0160*  	ld hl,0
043604 22 E2 35 04 0161*  	ld (prt_irq_counter),hl
043608 E1          0162*      pop hl
043609 C9          0163*      ret
04360A             0164*  
04360A             0165*  prt_loop_stop:
04360A E5          0166*      push hl
04360B D5          0167*      push de
04360C 2A E2 35 04 0168*      ld hl,(prt_irq_counter)
043610 ED 5B 53 36 0169*      ld de,(prt_loop_counter)
       04          
043615 19          0170*      add hl,de
043616 22 53 36 04 0171*      ld (prt_loop_counter),hl
04361A 21 00 00 00 0172*      ld hl,0
04361E 22 E2 35 04 0173*      ld (prt_irq_counter),hl
043622 2A 56 36 04 0174*      ld hl,(prt_loops)
043626 23          0175*      inc hl
043627 22 56 36 04 0176*      ld (prt_loops),hl
04362B D1          0177*      pop de
04362C E1          0178*      pop hl
04362D C9          0179*      ret
04362E             0180*  
04362E             0181*  ; inputs: bc = y,x text coordinates to print
04362E             0182*  prt_loop_print:
04362E F5          0183*      push af
04362F E5          0184*      push hl
043630 C5          0185*      push bc
043631 D5          0186*      push de
043632 DD E5       0187*      push ix
043634 FD E5       0188*      push iy
043636 CD 5B 1F 04 0189*      call vdu_move_cursor
04363A             0190*  
04363A 2A 53 36 04 0191*      ld hl,(prt_loop_counter)
04363E CD 0C 1A 04 0192*      call printDec
043642             0193*  
043642 2A 56 36 04 0194*      ld hl,(prt_loops)
043646 CD 0C 1A 04 0195*      call printDec
04364A             0196*  
04364A FD E1       0197*      pop iy
04364C DD E1       0198*      pop ix
04364E D1          0199*      pop de
04364F C1          0200*      pop bc
043650 E1          0201*      pop hl
043651 F1          0202*      pop af
043652 C9          0203*      ret
043653             0204*  
043653             0205*  prt_loop_counter:
043653 00 00 00    0206*      .dl 0
043656             0207*  prt_loops:
043656 00 00 00    0208*      .dl 0
043659             0209*  
043659             0210*  ; ===============================================
043659             0211*  ; Timer functions
043659             0212*  ; -----------------------------------------------
043659             0213*  ; set a countdown timer
043659             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043659             0215*  ; returns: hl = current time
043659             0216*  tmr_set:
043659 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
04365C             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
04365C 3E 08       0001*M 			LD	A, function
04365E 5B CF       0002*M 			RST.LIL	08h
043660 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043663 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
043666 C9          0221*      ret
043667             0222*  
043667             0223*  ; gets time remaining on a countdown timer
043667             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043667             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043667             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
043667             0227*  tmr_get:
043667             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
043667 3E 08       0001*M 			LD	A, function
043669 5B CF       0002*M 			RST.LIL	08h
04366B DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
04366E FD 27 00    0230*      ld hl,(iy+0)            ; get start time
043671 AF          0231*      xor a                   ; clear carry
043672 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043674 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
043677 AF          0234*      xor a                   ; clear carry
043678 ED 5A       0235*      adc hl,de               ; hl = time remaining
04367A             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04367A C9          0237*      ret
04367B             0238*  
04367B             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
043681             0240*  
043681 00 00 00    0241*  timestamp_now: dl 0
043684 00 00 00    0242*  timestamp_old: dl 0
043687 00 00 00    0243*  timestamp_chg: dl 0
04368A             0244*  
04368A             0245*  ; update the global timestamp from the system clock
04368A             0246*  ; inputs: none
04368A             0247*  ; returns: hl = time elapsed in 1/120ths of a second
04368A             0248*  ;          de = current time
04368A             0249*  ;          ix = pointer to syvars table
04368A             0250*  ; destroys: af,hl,de,ix
04368A             0251*  timestamp_tick:
04368A ED 5B 81 36 0252*      ld de,(timestamp_now)   ; get previous time
       04          
04368F ED 53 84 36 0253*      ld (timestamp_old),de   ; save previous time
       04          
043694             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043694 3E 08       0001*M 			LD	A, function
043696 5B CF       0002*M 			RST.LIL	08h
043698 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
04369B 22 81 36 04 0256*      ld (timestamp_now),hl   ; save current time
04369F AF          0257*      xor a                   ; clear carry
0436A0 ED 52       0258*      sbc hl,de               ; hl = time elapsed
0436A2 22 87 36 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
0436A6 C9          0260*      ret
0436A7             0261*  
0436A7             0262*  ; set a countdown timer
0436A7             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0436A7             0264*  ; requires: timestamp_tick to be called at least once before this function
0436A7             0265*  ; returns: hl = current time
0436A7             0266*  ; destroys: hl
0436A7             0267*  timestamp_tmr_set:
0436A7 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
0436AA 2A 81 36 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
0436AE FD 2F 00    0270*      ld (iy+0),hl            ; set start time
0436B1 C9          0271*      ret
0436B2             0272*  
0436B2             0273*  ; gets time remaining on a countdown timer following the global timestamp
0436B2             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0436B2             0275*  ; requires: timestamp_tick to be called at least once before this function
0436B2             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0436B2             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
0436B2             0278*  ; destroys: af,hl,de
0436B2             0279*  timestamp_tmr_get:
0436B2 ED 5B 81 36 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
0436B7 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
0436BA AF          0282*      xor a                   ; clear carry
0436BB ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0436BD FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
0436C0 AF          0285*      xor a                   ; clear carry
0436C1 ED 5A       0286*      adc hl,de               ; hl = time remaining
0436C3             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0436C3 C9          0288*      ret
0436C4             0289*  
0436C4             0290*  ; set a stopwatch
0436C4             0291*  ; returns: hl = start time
0436C4             0292*  ; destroys: hl,ix
0436C4             0293*  stopwatch_set:
0436C4             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
0436C4 3E 08       0001*M 			LD	A, function
0436C6 5B CF       0002*M 			RST.LIL	08h
0436C8 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
0436CB 22 E0 36 04 0296*      ld (stopwatch_started),hl            ; set start time
0436CF C9          0297*      ret
0436D0             0298*  
0436D0             0299*  ; gets time elapsed on a stopwatch
0436D0             0300*  ; returns: hl = time elapsed in 1/120ths of a second
0436D0             0301*  ; destroys: af,hl,de,ix
0436D0             0302*  stopwatch_get:
0436D0             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
0436D0 3E 08       0001*M 			LD	A, function
0436D2 5B CF       0002*M 			RST.LIL	08h
0436D4 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
0436D7 ED 5B E0 36 0305*      ld de,(stopwatch_started)            ; get start time
       04          
0436DC AF          0306*      xor a                   ; clear carry
0436DD ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0436DF C9          0308*      ret
0436E0             0309*  
0436E0             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0436E3             0311*  
0436E3             0312*  ; ------------------
0436E3             0313*  ; delay routine
0436E3             0314*  ; Author: Richard Turrnidge
0436E3             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0436E3             0316*  ; routine waits a fixed time,then returns
0436E3             0317*  ; arrive with A =  the delay byte. One bit to be set only.
0436E3             0318*  ; eg. ld A,00000100b
0436E3             0319*  
0436E3             0320*  multiPurposeDelay:
0436E3 F5          0321*      push af
0436E4 C5          0322*      push bc
0436E5 DD E5       0323*      push ix
0436E7 47          0324*      ld b,a
0436E8 3E 08       0325*      ld a,$08
0436EA 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
0436EC             0327*  
0436EC             0328*  waitLoop:
0436EC             0329*  
0436EC DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0436EF             0331*  
0436EF             0332*                                  ;   we check if bit set is same as last time we checked.
0436EF             0333*                                  ;   bit 0 - don't use
0436EF             0334*                                  ;   bit 1 - changes 64 times per second
0436EF             0335*                                  ;   bit 2 - changes 32 times per second
0436EF             0336*                                  ;   bit 3 - changes 16 times per second
0436EF             0337*  
0436EF             0338*                                  ;   bit 4 - changes 8 times per second
0436EF             0339*                                  ;   bit 5 - changes 4 times per second
0436EF             0340*                                  ;   bit 6 - changes 2 times per second
0436EF             0341*                                  ;   bit 7 - changes 1 times per second
0436EF A0          0342*      and b
0436F0 4F          0343*      ld c,a
0436F1 3A 02 37 04 0344*      ld a,(oldTimeStamp)
0436F5 B9          0345*      cp c                        ; is A same as last value?
0436F6 28 F4       0346*      jr z,waitLoop              ; loop here if it is
0436F8 79          0347*      ld a,c
0436F9 32 02 37 04 0348*      ld (oldTimeStamp),a        ; set new value
0436FD             0349*  
0436FD DD E1       0350*      pop ix
0436FF C1          0351*      pop bc
043700 F1          0352*      pop af
043701 C9          0353*      ret
043702             0354*  
043702 00          0355*  oldTimeStamp:   .db 00h
043703             0066   
043703             0067   ; new includes
043703             0068   	include "images.inc"
043703             0001*  image_type: equ 0
043703             0002*  image_width: equ image_type+3
043703             0003*  image_height: equ image_width+3
043703             0004*  image_filesize: equ image_height+3
043703             0005*  image_filename: equ image_filesize+3
043703             0006*  image_bufferId: equ image_filename+3
043703             0007*  image_record_size: equ image_bufferId+3
043703             0008*  
043703 00 00 00    0009*  cur_image_list: dl 0
043706 00 00 00    0010*  cur_file_idx: dl 0
043709 00 00 00    0011*  cur_filename: dl 0
04370C 00 00 00    0012*  cur_buffer_id: dl 0
04370F             0013*  
04370F             0014*  load_ui_images:
04370F             0015*  ; initialize image loading variables
04370F 21 00 00 00 0016*  	ld hl,0
043713 22 06 37 04 0017*  	ld (cur_file_idx),hl
043717 21 01 48 04 0018*  	ld hl,ui_image_list
04371B 22 03 37 04 0019*  	ld (cur_image_list),hl
04371F             0020*  ; load images
04371F 06 04       0021*  	ld b,ui_num_images
043721             0022*  @loop:
043721 C5          0023*  	push bc
043722 CD 80 37 04 0024*  	call load_next_image
043726 C1          0025*  	pop bc
043727 10 F8       0026*  	djnz @loop
043729 C9          0027*  	ret
04372A             0028*  
04372A             0029*  load_sprite_images:
04372A             0030*  ; initialize image loading variables
04372A 21 00 00 00 0031*  	ld hl,0
04372E 22 06 37 04 0032*  	ld (cur_file_idx),hl
043732 21 11 38 04 0033*  	ld hl,sprites_image_list
043736 22 03 37 04 0034*  	ld (cur_image_list),hl
04373A 01 5F 00 00 0035*  	ld bc,sprites_num_images
04373E             0036*  ; load images
04373E CD 43 37 04 0037*  	call img_load_main
043742 C9          0038*  	ret
043743             0039*  
043743             0040*  ; inputs: bc is the number of images to load, cur_image_list set
043743             0041*  img_load_main:
043743 AF          0042*  	xor a
043744 32 06 37 04 0043*      ld (cur_file_idx),a
043748             0044*  
043748             0045*  img_load_main_loop:
043748             0046*  ; back up loop counter
043748 C5          0047*      push bc
043749             0048*  
043749             0049*  ; load the next image
043749 CD 80 37 04 0050*      call load_next_image
04374D             0051*  
04374D             0052*  ; plot the background
04374D CD 6F 1F 04 0053*  	call vdu_cls
043751 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
043755 CD 5C 20 04 0055*      call vdu_buff_select
043759 01 00 00 00 0056*      ld bc,0
04375D 11 00 00 00 0057*      ld de,0
043761 CD 25 23 04 0058*      call vdu_plot_bmp
043765             0059*  
043765             0060*  ; ; draw the most recently loaded image
043765             0061*  ; 	ld hl,(cur_buffer_id)
043765             0062*  ; 	call vdu_buff_select
043765             0063*  ; 	ld bc,0
043765             0064*  ; 	ld de,0
043765             0065*  ; 	call vdu_plot_bmp
043765             0066*  
043765             0067*  ; move logo
043765 CD E0 37 04 0068*  	call move_logo
043769             0069*  
043769             0070*  ; print current filename
043769 2A 09 37 04 0071*  	ld hl,(cur_filename)
04376D CD 0D 19 04 0072*  	call printString
043771             0073*  
043771             0074*  ; flip the framebuffer
043771             0075*  	; call vdu_flip
043771             0076*  
043771             0077*  ; decrement loop counter
043771 C1          0078*      pop bc
043772 0B          0079*  	dec bc
043773 79          0080*      ld a,c
043774 B7          0081*      or a
043775 C2 48 37 04 0082*      jp nz,img_load_main_loop
043779 78          0083*      ld a,b
04377A B7          0084*      or a
04377B C2 48 37 04 0085*      jp nz,img_load_main_loop
04377F C9          0086*      ret
043780             0087*  
043780             0088*  load_next_image:
043780 16 12       0089*      ld d,image_record_size
043782 3A 06 37 04 0090*  	ld a,(cur_file_idx)
043786 5F          0091*  	ld e,a
043787 ED 5C       0092*      mlt de
043789 FD 2A 03 37 0093*      ld iy,(cur_image_list)
       04          
04378E FD 19       0094*      add iy,de
043790             0095*  
043790 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
043793 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
043796 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
043799 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
04379C FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
04379F 22 0C 37 04 0101*  	ld (cur_buffer_id),hl
0437A3 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0437A6 FD 22 09 37 0103*  	ld (cur_filename),iy
       04          
0437AB CD 7A 21 04 0104*      call vdu_load_img
0437AF FD 21 06 37 0105*      ld iy,cur_file_idx
       04          
0437B4 FD 34 00    0106*  	inc (iy)
0437B7 C9          0107*  	ret
0437B8             0108*  
0437B8             0109*  img_load_init:
0437B8             0110*  ; initialize logo's position parameters
0437B8 21 00 00 00 0111*  	ld hl,0
0437BC 22 05 38 04 0112*  	ld (logo_xvel),hl
0437C0 22 08 38 04 0113*  	ld (logo_xpos),hl
0437C4             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0437C4 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
0437C8 22 0E 38 04 0116*  	ld (logo_ypos),hl
0437CC EB          0117*  	ex de,hl
0437CD 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
0437D1 19          0119*  	add hl,de ; distance for logo to travel
0437D2 11 00 A1 FF 0120*  	ld de,-sprites_num_images*256
0437D6 CD F4 2F 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
0437DA ED 53 0B 38 0122*  	ld (logo_yvel),de
       04          
0437DF             0123*  ; all done
0437DF C9          0124*      ret
0437E0             0125*  
0437E0             0126*  move_logo:
0437E0             0127*  ; activate logo bitmap
0437E0 21 03 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
0437E4 CD 5C 20 04 0129*  	call vdu_buff_select
0437E8             0130*  ; update position based on velocity parameters
0437E8 2A 0E 38 04 0131*  	ld hl,(logo_ypos)
0437EC ED 5B 0B 38 0132*  	ld de,(logo_yvel)
       04          
0437F1 19          0133*  	add hl,de
0437F2 22 0E 38 04 0134*  	ld (logo_ypos),hl
0437F6             0135*  ; draw logo
0437F6 ED 4B 08 38 0136*  	ld bc,(logo_xpos)
       04          
0437FB ED 5B 0E 38 0137*  	ld de,(logo_ypos)
       04          
043800 CD 41 23 04 0138*  	call vdu_plot_bmp168
043804 C9          0139*  	ret
043805             0140*  
043805 00 00 00    0141*  logo_xvel: dl 0
043808 00 00 00    0142*  logo_xpos: dl 0
04380B             0143*  
04380B 00 00 00    0144*  logo_yvel: dl 0
04380E 00 00 00    0145*  logo_ypos: dl 0
043811             0069   	include "images_sprites.inc"
043811             0001*  ; Generated by make_images.py
043811             0002*  
043811             0003*  sprites_num_images: equ 95
043811             0004*  
043811             0005*  ; buffer_ids:
043811             0006*  BUF_0TILE_EMPTY: equ 256
043811             0007*  BUF_1TILE_CROSS: equ 257
043811             0008*  BUF_2TILE_HORIZ: equ 258
043811             0009*  BUF_3TILE_VERT: equ 259
043811             0010*  BUF_4TILE_SQUARE: equ 260
043811             0011*  BUF_5TILE_CIRCLE: equ 261
043811             0012*  BUF_6TILE_PAD: equ 262
043811             0013*  BUF_7TILE_TURRET: equ 263
043811             0014*  BUF_CIRCLE: equ 264
043811             0015*  BUF_CRATER: equ 265
043811             0016*  BUF_EXPLOSION_A: equ 266
043811             0017*  BUF_EXPLOSION_B: equ 267
043811             0018*  BUF_EXPLOSION_C: equ 268
043811             0019*  BUF_EXPLOSION_D: equ 269
043811             0020*  BUF_EXPLOSION_E: equ 270
043811             0021*  BUF_FIREBALL_A: equ 271
043811             0022*  BUF_FIREBALL_B: equ 272
043811             0023*  BUF_LASER_A: equ 273
043811             0024*  BUF_LASER_B: equ 274
043811             0025*  BUF_PAD: equ 275
043811             0026*  BUF_SEEKER_000: equ 276
043811             0027*  BUF_SEEKER_008: equ 277
043811             0028*  BUF_SEEKER_016: equ 278
043811             0029*  BUF_SEEKER_024: equ 279
043811             0030*  BUF_SEEKER_032: equ 280
043811             0031*  BUF_SEEKER_040: equ 281
043811             0032*  BUF_SEEKER_048: equ 282
043811             0033*  BUF_SEEKER_056: equ 283
043811             0034*  BUF_SEEKER_064: equ 284
043811             0035*  BUF_SEEKER_072: equ 285
043811             0036*  BUF_SEEKER_080: equ 286
043811             0037*  BUF_SEEKER_088: equ 287
043811             0038*  BUF_SEEKER_096: equ 288
043811             0039*  BUF_SEEKER_104: equ 289
043811             0040*  BUF_SEEKER_112: equ 290
043811             0041*  BUF_SEEKER_120: equ 291
043811             0042*  BUF_SEEKER_128: equ 292
043811             0043*  BUF_SEEKER_136: equ 293
043811             0044*  BUF_SEEKER_144: equ 294
043811             0045*  BUF_SEEKER_152: equ 295
043811             0046*  BUF_SEEKER_160: equ 296
043811             0047*  BUF_SEEKER_168: equ 297
043811             0048*  BUF_SEEKER_176: equ 298
043811             0049*  BUF_SEEKER_184: equ 299
043811             0050*  BUF_SEEKER_192: equ 300
043811             0051*  BUF_SEEKER_200: equ 301
043811             0052*  BUF_SEEKER_208: equ 302
043811             0053*  BUF_SEEKER_216: equ 303
043811             0054*  BUF_SEEKER_224: equ 304
043811             0055*  BUF_SEEKER_232: equ 305
043811             0056*  BUF_SEEKER_240: equ 306
043811             0057*  BUF_SEEKER_248: equ 307
043811             0058*  BUF_SHIP_0L: equ 308
043811             0059*  BUF_SHIP_1C: equ 309
043811             0060*  BUF_SHIP_2R: equ 310
043811             0061*  BUF_SHIP_SMALL: equ 311
043811             0062*  BUF_STAR: equ 312
043811             0063*  BUF_STATION_BG_00: equ 313
043811             0064*  BUF_STATION_BG_01: equ 314
043811             0065*  BUF_STATION_BG_02: equ 315
043811             0066*  BUF_STATION_BG_03: equ 316
043811             0067*  BUF_STATION_BG_04: equ 317
043811             0068*  BUF_STATION_BG_05: equ 318
043811             0069*  BUF_TURRET_000: equ 319
043811             0070*  BUF_TURRET_008: equ 320
043811             0071*  BUF_TURRET_016: equ 321
043811             0072*  BUF_TURRET_024: equ 322
043811             0073*  BUF_TURRET_032: equ 323
043811             0074*  BUF_TURRET_040: equ 324
043811             0075*  BUF_TURRET_048: equ 325
043811             0076*  BUF_TURRET_056: equ 326
043811             0077*  BUF_TURRET_064: equ 327
043811             0078*  BUF_TURRET_072: equ 328
043811             0079*  BUF_TURRET_080: equ 329
043811             0080*  BUF_TURRET_088: equ 330
043811             0081*  BUF_TURRET_096: equ 331
043811             0082*  BUF_TURRET_104: equ 332
043811             0083*  BUF_TURRET_112: equ 333
043811             0084*  BUF_TURRET_120: equ 334
043811             0085*  BUF_TURRET_128: equ 335
043811             0086*  BUF_TURRET_136: equ 336
043811             0087*  BUF_TURRET_144: equ 337
043811             0088*  BUF_TURRET_152: equ 338
043811             0089*  BUF_TURRET_160: equ 339
043811             0090*  BUF_TURRET_168: equ 340
043811             0091*  BUF_TURRET_176: equ 341
043811             0092*  BUF_TURRET_184: equ 342
043811             0093*  BUF_TURRET_192: equ 343
043811             0094*  BUF_TURRET_200: equ 344
043811             0095*  BUF_TURRET_208: equ 345
043811             0096*  BUF_TURRET_216: equ 346
043811             0097*  BUF_TURRET_224: equ 347
043811             0098*  BUF_TURRET_232: equ 348
043811             0099*  BUF_TURRET_240: equ 349
043811             0100*  BUF_TURRET_248: equ 350
043811             0101*  
043811             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
043811 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       BF 3E 04 00 
       01 00       
043823 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       D9 3E 04 01 
       01 00       
043835 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       F3 3E 04 02 
       01 00       
043847 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       0D 3F 04 03 
       01 00       
043859 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       26 3F 04 04 
       01 00       
04386B 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       41 3F 04 05 
       01 00       
04387D 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       5C 3F 04 06 
       01 00       
04388F 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       74 3F 04 07 
       01 00       
0438A1 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       8F 3F 04 08 
       01 00       
0438B3 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       A4 3F 04 09 
       01 00       
0438C5 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       B9 3F 04 0A 
       01 00       
0438D7 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       D3 3F 04 0B 
       01 00       
0438E9 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       ED 3F 04 0C 
       01 00       
0438FB 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       07 40 04 0D 
       01 00       
04390D 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       21 40 04 0E 
       01 00       
04391F 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       3B 40 04 0F 
       01 00       
043931 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       54 40 04 10 
       01 00       
043943 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       6D 40 04 11 
       01 00       
043955 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       83 40 04 12 
       01 00       
043967 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       99 40 04 13 
       01 00       
043979 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       AB 40 04 14 
       01 00       
04398B 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       C4 40 04 15 
       01 00       
04399D 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       DD 40 04 16 
       01 00       
0439AF 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       F6 40 04 17 
       01 00       
0439C1 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       0F 41 04 18 
       01 00       
0439D3 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       28 41 04 19 
       01 00       
0439E5 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       41 41 04 1A 
       01 00       
0439F7 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       5A 41 04 1B 
       01 00       
043A09 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       73 41 04 1C 
       01 00       
043A1B 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       8C 41 04 1D 
       01 00       
043A2D 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       A5 41 04 1E 
       01 00       
043A3F 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       BE 41 04 1F 
       01 00       
043A51 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       D7 41 04 20 
       01 00       
043A63 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       F0 41 04 21 
       01 00       
043A75 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       09 42 04 22 
       01 00       
043A87 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       22 42 04 23 
       01 00       
043A99 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       3B 42 04 24 
       01 00       
043AAB 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       54 42 04 25 
       01 00       
043ABD 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       6D 42 04 26 
       01 00       
043ACF 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       86 42 04 27 
       01 00       
043AE1 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       9F 42 04 28 
       01 00       
043AF3 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       B8 42 04 29 
       01 00       
043B05 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       D1 42 04 2A 
       01 00       
043B17 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       EA 42 04 2B 
       01 00       
043B29 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       03 43 04 2C 
       01 00       
043B3B 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       1C 43 04 2D 
       01 00       
043B4D 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       35 43 04 2E 
       01 00       
043B5F 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       4E 43 04 2F 
       01 00       
043B71 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       67 43 04 30 
       01 00       
043B83 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       80 43 04 31 
       01 00       
043B95 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       99 43 04 32 
       01 00       
043BA7 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       B2 43 04 33 
       01 00       
043BB9 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       CB 43 04 34 
       01 00       
043BCB 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       E1 43 04 35 
       01 00       
043BDD 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       F7 43 04 36 
       01 00       
043BEF 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       0D 44 04 37 
       01 00       
043C01 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       26 44 04 38 
       01 00       
043C13 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       39 44 04 39 
       01 00       
043C25 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       55 44 04 3A 
       01 00       
043C37 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       71 44 04 3B 
       01 00       
043C49 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       8D 44 04 3C 
       01 00       
043C5B 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       A9 44 04 3D 
       01 00       
043C6D 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       C5 44 04 3E 
       01 00       
043C7F 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       E1 44 04 3F 
       01 00       
043C91 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       FA 44 04 40 
       01 00       
043CA3 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       13 45 04 41 
       01 00       
043CB5 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       2C 45 04 42 
       01 00       
043CC7 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       45 45 04 43 
       01 00       
043CD9 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       5E 45 04 44 
       01 00       
043CEB 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       77 45 04 45 
       01 00       
043CFD 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       90 45 04 46 
       01 00       
043D0F 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       A9 45 04 47 
       01 00       
043D21 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       C2 45 04 48 
       01 00       
043D33 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       DB 45 04 49 
       01 00       
043D45 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       F4 45 04 4A 
       01 00       
043D57 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       0D 46 04 4B 
       01 00       
043D69 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       26 46 04 4C 
       01 00       
043D7B 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       3F 46 04 4D 
       01 00       
043D8D 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       58 46 04 4E 
       01 00       
043D9F 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       71 46 04 4F 
       01 00       
043DB1 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       8A 46 04 50 
       01 00       
043DC3 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       A3 46 04 51 
       01 00       
043DD5 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       BC 46 04 52 
       01 00       
043DE7 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       D5 46 04 53 
       01 00       
043DF9 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       EE 46 04 54 
       01 00       
043E0B 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       07 47 04 55 
       01 00       
043E1D 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       20 47 04 56 
       01 00       
043E2F 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       39 47 04 57 
       01 00       
043E41 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       52 47 04 58 
       01 00       
043E53 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       6B 47 04 59 
       01 00       
043E65 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       84 47 04 5A 
       01 00       
043E77 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       9D 47 04 5B 
       01 00       
043E89 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       B6 47 04 5C 
       01 00       
043E9B 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       CF 47 04 5D 
       01 00       
043EAD 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       E8 47 04 5E 
       01 00       
043EBF             0198*  
043EBF             0199*  ; files_list: ; filename:
043EBF 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043ED9 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043EF3 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043F0D 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043F26 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043F41 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043F5C 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043F74 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043F8F 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043FA4 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043FB9 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043FD3 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043FED 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
044007 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
044021 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
04403B 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
044054 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
04406D 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
044083 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
044099 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
0440AB 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0440C4 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0440DD 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0440F6 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
04410F 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
044128 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
044141 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
04415A 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
044173 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
04418C 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0441A5 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0441BE 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0441D7 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0441F0 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044209 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
044222 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
04423B 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
044254 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
04426D 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044286 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
04429F 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0442B8 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0442D1 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0442EA 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044303 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
04431C 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
044335 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04434E 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044367 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
044380 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044399 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0443B2 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0443CB 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0443E1 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0443F7 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
04440D 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
044426 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
044439 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
044455 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
044471 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
04448D 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
0444A9 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
0444C5 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
0444E1 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0444FA 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
044513 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
04452C 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
044545 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
04455E 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
044577 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
044590 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
0445A9 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0445C2 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0445DB 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0445F4 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04460D 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
044626 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
04463F 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
044658 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044671 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04468A 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0446A3 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0446BC 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0446D5 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0446EE 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
044707 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044720 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044739 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
044752 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04476B 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044784 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04479D 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
0447B6 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0447CF 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0447E8 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044801             0070   	include "images_ui.inc"
044801             0001*  ; Generated by make_images.py
044801             0002*  
044801             0003*  ui_num_images: equ 4
044801             0004*  
044801             0005*  ; buffer_ids:
044801             0006*  BUF_BEZEL_L: equ 0
044801             0007*  BUF_BEZEL_R: equ 1
044801             0008*  BUF_SPLASH_BG: equ 2
044801             0009*  BUF_SPLASH_LOGO: equ 3
044801             0010*  
044801             0011*  ui_image_list: ; type; width; height; filename; bufferId:
044801 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       49 48 04 00 
       00 00       
044813 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       5A 48 04 01 
       00 00       
044825 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       6B 48 04 02 
       00 00       
044837 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       7E 48 04 03 
       00 00       
044849             0016*  
044849             0017*  ; files_list: ; filename:
044849 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
04485A 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
04486B 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04487E 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
044893             0071   	include "files.inc"
044893             0001*  ; load to onboard 8k sram
044893             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
044893             0072   
044893 57 65 6C 63 0073   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
0448AE 4C 6F 61 64 0074   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
0448B9 4C 6F 61 64 0075   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0448C7 50 72 65 73 0076   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0448E2             0077   
0448E2             0078   init:
0448E2             0079   ; clear all buffers
0448E2 CD 4E 21 04 0080       call vdu_clear_all_buffers
0448E6             0081   
0448E6             0082   ; set up the display
0448E6 3E 08       0083       ld a,8;+128 ; 136   320   240   64    60hz double-buffered
0448E8 CD 38 20 04 0084       call vdu_set_screen_mode
0448EC AF          0085       xor a
0448ED CD 49 20 04 0086       call vdu_set_scaling
0448F1             0087   
0448F1             0088   ; ; enable additional audio channels
0448F1             0089   ; 	call vdu_enable_channels
0448F1             0090   
0448F1             0091   ; set text background color
0448F1 3E 9A       0092   	ld a,26+128 ; violet
0448F3 CD A0 1F 04 0093   	call vdu_colour_text
0448F7             0094   
0448F7             0095   ; set text foreground color
0448F7 3E 2F       0096   	ld a,47 ; aaaaff lavenderish
0448F9 CD A0 1F 04 0097   	call vdu_colour_text
0448FD             0098   
0448FD             0099   ; set gfx bg color
0448FD AF          0100   	xor a ; plotting mode 0
0448FE 3E 9A       0101   	ld a,26+128 ; violet
044900 CD B1 1F 04 0102   	call vdu_gcol
044904 CD 6F 1F 04 0103   	call vdu_cls
044908             0104   
044908             0105   ; set the cursor off
044908 CD 37 1F 04 0106   	call vdu_cursor_off
04490C             0107   
04490C             0108   ; VDU 28, left, bottom, right, top: Set text viewport **
04490C             0109   ; MIND THE LITTLE-ENDIANESS
04490C             0110   ; inputs: c=left,b=bottom,e=right,d=top
04490C 0E 00       0111   	ld c,0 ; left
04490E 16 1D       0112   	ld d,29 ; top
044910 1E 27       0113   	ld e,39 ; right
044912 06 1D       0114   	ld b,29; bottom
044914 CD C8 1F 04 0115   	call vdu_set_txt_viewport
044918             0116   
044918             0117   ; print loading ui message
044918 21 AE 48 04 0118   	ld hl,loading_ui
04491C CD 0D 19 04 0119   	call printString
044920 CD 74 1F 04 0120   	call vdu_flip
044924             0121   
044924             0122   ; load UI images
044924 CD 0F 37 04 0123   	call load_ui_images
044928             0124   
044928             0125   ; ; load fonts ; TODO
044928             0126   ; 	call load_font_rc
044928             0127   
044928             0128   ; load sprites
044928 CD B8 37 04 0129   	call img_load_init ; sets up the animated load screen
04492C CD 2A 37 04 0130   	call load_sprite_images
044930             0131   
044930             0132   ; ; load sound effects ; TODO
044930             0133   ; 	ld bc,SFX_num_buffers
044930             0134   ; 	ld hl,SFX_buffer_id_lut
044930             0135   ; 	ld (cur_buffer_id_lut),hl
044930             0136   ; 	ld hl,SFX_load_routines_table
044930             0137   ; 	ld (cur_load_jump_table),hl
044930             0138   ; 	call sfx_load_main
044930             0139   
044930             0140   ; print loading complete message and wait for user keypress
044930 CD 6F 1F 04 0141   	call vdu_cls
044934 21 C7 48 04 0142   	ld hl,loading_complete
044938 CD 0D 19 04 0143   	call printString
04493C CD 74 1F 04 0144   	call vdu_flip
044940 CD AB 1E 04 0145   	call waitKeypress
044944             0146   
044944             0147   ; set up display for gameplay
044944             0148       ; ld a,8
044944 3E 14       0149   	ld a,20
044946 CD 38 20 04 0150       call vdu_set_screen_mode
04494A AF          0151       xor a
04494B CD 49 20 04 0152       call vdu_set_scaling
04494F CD 37 1F 04 0153   	call vdu_cursor_off
044953             0154   ; plot bezel art
044953 21 00 00 00 0155   	ld hl,BUF_BEZEL_L
044957 CD 5C 20 04 0156   	call vdu_buff_select
04495B 01 00 00 00 0157   	ld bc,0
04495F 11 00 00 00 0158   	ld de,0
044963 CD 25 23 04 0159   	call vdu_plot_bmp
044967 21 01 00 00 0160   	ld hl,BUF_BEZEL_R
04496B CD 5C 20 04 0161   	call vdu_buff_select
04496F 01 80 01 00 0162   	ld bc,384
044973 11 00 00 00 0163   	ld de,0
044977 CD 25 23 04 0164   	call vdu_plot_bmp
04497B             0165   ; set gfx origin and viewport to playing field window
04497B 01 80 00 00 0166   	ld bc,origin_left
04497F 11 30 00 00 0167   	ld de,origin_top
044983 CD F4 1F 04 0168   	call vdu_set_gfx_origin
044987 01 00 00 00 0169   	ld bc,field_left
04498B 11 00 00 00 0170   	ld de,field_top
04498F DD 21 FF 00 0171   	ld ix,field_right
       00          
044994 FD 21 4F 01 0172   	ld iy,field_bottom
       00          
044999 CD 0F 20 04 0173   	call vdu_set_gfx_viewport
04499D             0174   ; set background color
04499D 3E 9A       0175   	ld a,26+128 ; violet
04499F CD B1 1F 04 0176   	call vdu_gcol
0449A3 CD 82 1F 04 0177   	call vdu_clg
0449A7             0178   ; VDU 28, left, bottom, right, top: Set text viewport **
0449A7 0E 00       0179   	ld c,0 ; left
0449A9 16 00       0180   	ld d,0 ; top
0449AB 1E 3E       0181   	ld e,62 ; right
0449AD 06 07       0182   	ld b,7; bottom
0449AF CD C8 1F 04 0183   	call vdu_set_txt_viewport
0449B3             0184   
0449B3 C9          0185   	ret
0449B4             0186   
0449B4             0187   origin_top: equ 48
0449B4             0188   origin_left: equ 128
0449B4             0189   field_top: equ 0
0449B4             0190   field_bottom: equ 383-origin_top
0449B4             0191   field_left: equ 0
0449B4             0192   field_right: equ 255
0449B4             0193   sprite_top: equ 0
0449B4             0194   sprite_bottom: equ field_bottom-16
0449B4             0195   sprite_left: equ field_left
0449B4             0196   sprite_right: equ field_right-16
0449B4             0197   collide_top: equ %00001000
0449B4             0198   collide_bottom: equ %00000100
0449B4             0199   collide_left: equ %00000010
0449B4             0200   collide_right: equ %00000001
0449B4             0201   
0449B4             0202   ; ; #### BEGIN GAME VARIABLES ####
0449B4             0203   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
0449B4             0204   speed_player: equ 0x000300 ; 3 pixels per frame
0449B4             0205   
0449B4             0206   main:
0449B4             0207   ; start a new game
0449B4 CD DE 49 04 0208   	call new_game
0449B8             0209   
0449B8             0210   main_loop:
0449B8             0211   ; scroll tiles
0449B8 CD 8F 31 04 0212   	call tiles_plot
0449BC             0213   
0449BC             0214   ; get player input and update sprite position
0449BC CD AA 30 04 0215   	call player_input
0449C0             0216   
0449C0             0217   ; move enemies
0449C0 CD A3 32 04 0218   	call move_enemies
0449C4             0219   
0449C4             0220   ; wait for the next vblank mitigate flicker and for loop timing
0449C4 CD E3 1F 04 0221   	call vdu_vblank
0449C8             0222   
0449C8             0223   ; poll keyboard
0449C8 3E 08       0224       ld a, $08                           ; code to send to MOS
0449CA 5B CF       0225       rst.lil $08                         ; get IX pointer to System Variables
0449CC             0226   
0449CC DD 7E 05    0227       ld a, (ix + $05)                    ; get ASCII code of key pressed
0449CF FE 1B       0228       cp 27                               ; check if 27 (ascii code for ESC)
0449D1 CA D9 49 04 0229       jp z, main_end                      ; if pressed, jump to exit
0449D5             0230   
0449D5 C3 B8 49 04 0231       jp main_loop
0449D9             0232   
0449D9             0233   main_end:
0449D9 CD 29 1F 04 0234       call vdu_cursor_on
0449DD C9          0235   	ret
0449DE             0236   
0449DE             0237   new_game:
0449DE             0238   ; initialize sprites
0449DE CD B5 18 04 0239   	call sprites_init
0449E2             0240   
0449E2             0241   ; initialize the first level
0449E2 AF          0242   	xor a
0449E3 32 45 31 04 0243   	ld (cur_level),a
0449E7 CD 44 32 04 0244   	call init_level
0449EB             0245   
0449EB             0246   ; initialize player
0449EB CD 6B 30 04 0247   	call player_init
0449EF             0248   
0449EF             0249   ; spawn an enemy sprite
0449EF 06 10       0250   	ld b,table_max_records
0449F1             0251   @spawn_enemy_loop:
0449F1 C5          0252   	push bc
0449F2 CD 22 34 04 0253   	call enemy_init_from_landing_pad
0449F6 C1          0254   	pop bc
0449F7 10 F8       0255   	djnz @spawn_enemy_loop
0449F9             0256   
0449F9 C9          0257   	ret
0449FA             0258   
0449FA             0259   ; ; ###### INITIALIZE GAME #######
0449FA             0260   ; ; clear the screen
0449FA             0261   ;     ld a,3
0449FA             0262   ;     out (81h),a
0449FA             0263   
0449FA             0264   ; ; reset the sprite table
0449FA             0265   ;     xor a
0449FA             0266   ;     ld (table_active_sprites),a
0449FA             0267   ;     ld hl,table_limit
0449FA             0268   ;     ld (table_base),hl
0449FA             0269   ;     ld (table_pointer),hl
0449FA             0270   
0449FA             0271   ; ; draw a starfield over the entire screen
0449FA             0272   ;     ld b,#50 ; first row of visible screen
0449FA             0273   ; new_game_draw_stars_loop:
0449FA             0274   ;     push bc
0449FA             0275   ;     call draw_stars
0449FA             0276   ;     pop bc
0449FA             0277   ;     ld a,#10
0449FA             0278   ;     add a,b
0449FA             0279   ;     ld b,a
0449FA             0280   ;     jr nz,new_game_draw_stars_loop
0449FA             0281   
0449FA             0282   ; ; ; print a welcome message
0449FA             0283   ; ;     ld de,msg_welcome
0449FA             0284   ; ;     ld hl,#581C
0449FA             0285   ; ;     ld c,218 ; a bright pastel purple d677e3
0449FA             0286   ; ;     call print_string
0449FA             0287   
0449FA             0288   ; ; push all that to frame buffer
0449FA             0289   ;     ld a,#01 ; send video to frame buffer
0449FA             0290   ;     out (81h),a
0449FA             0291   
0449FA             0292   ; ; reset score, lives, shields
0449FA             0293   ;     xor a
0449FA             0294   ;     ld hl,player_score
0449FA             0295   ;     ld (hl),a ; player_score 0
0449FA             0296   ;     inc hl
0449FA             0297   ;     ld (hl),a ; player_score 1
0449FA             0298   ;     inc hl
0449FA             0299   ;     ld (hl),a ; player_score 3
0449FA             0300   ;     inc hl
0449FA             0301   ;     ld a,16
0449FA             0302   ;     ld (hl),a ; player_shields
0449FA             0303   ;     inc hl
0449FA             0304   ;     ld (hl),a ; player_max_shields
0449FA             0305   ;     inc hl
0449FA             0306   ;     ld a,3
0449FA             0307   ;     ld (hl),a ; player_ships
0449FA             0308   ;     inc hl
0449FA             0309   
0449FA             0310   ; ; initialize first level
0449FA             0311   ;     ld a,1 ; levels are zero-based, so this will wrap around
0449FA             0312   ;     ld (cur_level),a
0449FA             0313   ;     ld a,3 ; set max enemy sprites to easy street
0449FA             0314   ;     ld (max_enemy_sprites),a
0449FA             0315   ;     call dt_next_level
0449FA             0316   ;     call dt
0449FA             0317   
0449FA             0318   ; ; spawn our intrepid hero
0449FA             0319   ;     call player_init
0449FA             0320   
0449FA             0321   
0449FA             0322   ; ; #### BEGIN GAME MAIN LOOP ####
0449FA             0323   ; main_loop:
0449FA             0324   ; ; ; debug: start execution counter
0449FA             0325   ; ;     ld a,1
0449FA             0326   ; ;     out (#e0),a ; start counting instructions
0449FA             0327   
0449FA             0328   ; ; refresh background from frame buffer
0449FA             0329   ;     ld a,#02
0449FA             0330   ;     out (81h),a
0449FA             0331   ;     call move_background ; now move it
0449FA             0332   ;     ld a,#01
0449FA             0333   ;     out (81h),a ; save it back to buffer
0449FA             0334   ; ; do all the things
0449FA             0335   ;     call move_enemies
0449FA             0336   ;     call player_move
0449FA             0337   ;     call laser_control
0449FA             0338   ;     call print_score
0449FA             0339   ;     call draw_shields
0449FA             0340   ;     call draw_lives
0449FA             0341   ; ; ; debug: stop execution counter and print results
0449FA             0342   ; ;     ld a,0
0449FA             0343   ; ;     out (#e0),a ; stop counting instructions
0449FA             0344   
0449FA             0345   ; ; ; debug: start execution counter
0449FA             0346   ; ;     ld a,1
0449FA             0347   ; ;     out (#e0),a ; start counting instructions
0449FA             0348   
0449FA             0349   ;     call vdu_vblank
0449FA             0350   ; ; ; debug: stop execution counter and print results
0449FA             0351   ; ;     ld a,0
0449FA             0352   ; ;     out (#e0),a ; stop counting instructions
0449FA             0353   
0449FA             0354   ;     jr main_loop
0449FA             0355   ; #### END GAME MAIN LOOP ####
0449FA             0356   
0449FA             0357   ; draws the player's shields level
0449FA             0358   ; draw_shields:
0449FA             0359   ; TODO: Agonize this routine
0449FA             0360   ; ; prep the loop to draw the bars
0449FA             0361   ;     ld a,(player_shields) ; snag shields
0449FA             0362   ;     and a
0449FA             0363   ;     ret z ; don't draw if zero shields
0449FA             0364   ; ; set loop counter and drawing position
0449FA             0365   ;     ld b,a ; loop counter
0449FA             0366   ;     ld hl,#5300+48+12
0449FA             0367   ; ; set color based on bars remaining
0449FA             0368   ;     ld c,103 ; bright green 28fe0a
0449FA             0369   ;     cp 9
0449FA             0370   ;     jp p,draw_shields_loop
0449FA             0371   ;     ld c,74 ; bright yellow eafe5b
0449FA             0372   ;     cp 3
0449FA             0373   ;     jp p,draw_shields_loop
0449FA             0374   ;     ld c,28 ; bright red fe0a0a
0449FA             0375   ; draw_shields_loop:
0449FA             0376   ;     push bc ; yup,outta
0449FA             0377   ;     push hl ; registers again
0449FA             0378   ;     ; ld a,#A8 ; ▀,168
0449FA             0379   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
0449FA             0380   ;     ; call draw_char
0449FA             0381   ;     call draw_num ; we nuked draw_char for the time being
0449FA             0382   ;     pop hl
0449FA             0383   ;     ld a,8
0449FA             0384   ;     add a,l
0449FA             0385   ;     ld l,a
0449FA             0386   ;     pop bc
0449FA             0387   ;     djnz draw_shields_loop
0449FA             0388       ; ret
0449FA             0389   
0449FA             0390   ; prints the player's score
0449FA             0391   ; print_score:
0449FA             0392   ; TODO: Agonize this
0449FA             0393   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0449FA             0394   ;     ld c,42 ; dark orange b74400
0449FA             0395   ;     ld hl,#5200+1+8+6*6
0449FA             0396   ;     ld a,3 ; print 6 bdc digits
0449FA             0397   ;     ld de,player_score
0449FA             0398   ;     call print_num
0449FA             0399   
0449FA             0400   ;     ld c,58 ; golden yellow fec10a
0449FA             0401   ;     ld hl,#5100+8+6*6
0449FA             0402   ;     ld a,3 ; print 6 bdc digits
0449FA             0403   ;     ld de,player_score
0449FA             0404   ;     call print_num
0449FA             0405       ; ret
0449FA             0406   
0449FA             0407   ; draw_lives:
0449FA             0408   ;     ld hl,player_small ; make small yellow ship the active sprite
0449FA             0409   ;     ld (sprite_base_bufferId),hl
0449FA             0410   ;     ; ld a,#80 ; northern orientation
0449FA             0411   ;     ; ld (sprite_orientation),a
0449FA             0412   ;     ld hl,0 ; north
0449FA             0413   ;     ld (sprite_heading),hl
0449FA             0414   ;     xor a
0449FA             0415   ;     ld (sprite_animation),a
0449FA             0416   ;     ld a,#56 ; top of visible screen
0449FA             0417   ;     ld (sprite_y+1),a
0449FA             0418   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0449FA             0419   ;     ld a,(player_ships)
0449FA             0420   ;     dec a ; we draw one fewer ships than lives
0449FA             0421   ;     ret z ; nothing to draw here, move along
0449FA             0422   ;     ld b,a ; loop counter
0449FA             0423   ;     ld a,256-16 ; initial x position
0449FA             0424   ; draw_lives_loop:
0449FA             0425   ;     ld (sprite_x+1),a
0449FA             0426   ;     push af
0449FA             0427   ;     push bc
0449FA             0428   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0449FA             0429   ;     pop bc
0449FA             0430   ;     pop af
0449FA             0431   ;     sub 10
0449FA             0432   ;     djnz draw_lives_loop
0449FA             0433   ;     ret
