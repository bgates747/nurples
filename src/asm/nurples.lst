PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000 C3 45 00 04 0004       jp start
040004 FF FF FF FF 0005       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0006       db "MOS"
040043 00          0007       db 00h
040044 01          0008       db 01h
040045             0009   
040045             0010   start:
040045 F5          0011       push af
040046 C5          0012       push bc
040047 D5          0013       push de
040048 DD E5       0014       push ix
04004A FD E5       0015       push iy
04004C CD BB 44 04 0016       call init
040050 CD 8D 45 04 0017       call main
040054             0018   
040054             0019   exit:
040054 FD E1       0020       pop iy
040056 DD E1       0021       pop ix
040058 D1          0022       pop de
040059 C1          0023       pop bc
04005A F1          0024       pop af
04005B 21 00 00 00 0025       ld hl,0
04005F             0026   
04005F C9          0027       ret
040060             0028   
040060             0029       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,$+7 ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*      ld bc,$+7 ; Address of first instruction after the jump
040060             0023*      push bc ; which constitutes the return address
040060             0024*      jp (ix) ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*      ld bc,$+7 ; Address of first instruction after the jump
040060             0033*      push bc ; which constitutes the return address
040060             0034*      jp (iy) ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*      push hl ; 4 cycles
040060             0041*      inc sp ; 1 cycle
040060             0042*      pop af ; 4 cycles
040060             0043*      dec sp ; 1 cycle
040060             0044*      ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*      ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*      ex af,af'
040070             0068*      exx
040070             0069*      push af
040070             0070*      push hl
040070             0071*      push bc
040070             0072*      push de
040070             0073*  
040070             0074*      ex af,af'
040070             0075*      exx
040070             0076*      push af
040070             0077*      push hl
040070             0078*      push bc
040070             0079*      push de
040070             0080*      push ix
040070             0081*      push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*      pop iy
040070             0086*      pop ix
040070             0087*      pop de
040070             0088*      pop bc
040070             0089*      pop hl
040070             0090*      pop af
040070             0091*      ex af,af'
040070             0092*      exx
040070             0093*  
040070             0094*      pop de
040070             0095*      pop bc
040070             0096*      pop hl
040070             0097*      pop af
040070             0098*      ex af,af'
040070             0099*      exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*      PUSH BC
040078 01 00 00 00 0119*      LD BC,0
04007C 3E 00       0120*      LD A,0
04007E 5B DF       0121*      RST.LIL 18h
040080 C1          0122*      POP BC
040081 C9          0123*      RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*      PUSH BC
040083 01 00 00 00 0128*      LD BC, 0
040087 4E          0129*      LD C, (HL)
040088 5B DF       0130*      RST.LIL 18h
04008A C1          0131*      POP BC
04008B C9          0132*      RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*      LD A, '\r'
04008F 5B D7       0137*      RST.LIL 10h
040091 3E 0A       0138*      LD A, '\n'
040093 5B D7       0139*      RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*      RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0147*      CALL printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*      LD A,H
0400A0 CD A5 00 04 0152*      CALL printHex8
0400A4 7D          0153*      LD A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*      LD C,A
0400A6 1F          0158*      RRA
0400A7 1F          0159*      RRA
0400A8 1F          0160*      RRA
0400A9 1F          0161*      RRA
0400AA CD AF 00 04 0162*      CALL @F
0400AE 79          0163*      LD A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*      AND 0Fh
0400B1 C6 90       0166*      ADD A,90h
0400B3 27          0167*      DAA
0400B4 CE 40       0168*      ADC A,40h
0400B6 27          0169*      DAA
0400B7 5B D7       0170*      RST.LIL 10h
0400B9 C9          0171*      RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*      LD A, '0'
04016F 5B D7       0290*      RST.LIL 10h
040171 3E 78       0291*      LD A, 'x'
040173 5B D7       0292*      RST.LIL 10h
040175 C9          0293*      RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*      push hl
040176             0297*      push bc
040176             0298*      pop hl
040176             0299*      call printDec
040176             0300*      pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*      push hl
040176             0305*      push de
040176             0306*      pop hl
040176             0307*      call printDec
040176             0308*      pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*      call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*      push hl
040176             0317*      push ix
040176             0318*      pop hl
040176             0319*      call printDec
040176             0320*      pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*      push hl
040176             0325*      push iy
040176             0326*      pop hl
040176             0327*      call printDec
040176             0328*      pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*      LD DE, _printDecBuffer
04017E CD B2 01 04 0344*      CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD HL, _printDecBuffer
040186 06 07       0348*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD A, (HL)
040189 FE 30       0351*      CP '0'
04018B C2 95 01 04 0352*      JP NZ, @done
04018F 3E 20       0353*      LD A, ' '
040191 77          0354*      LD (HL), A
040192 23          0355*      INC HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*      LD HL, _printDecBuffer
040199 CD 77 00 04 0361*      CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*      RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*      LD BC,-10000000
0401B6 CD E9 01 04 0379*      CALL @one_digit
0401BA 01 C0 BD F0 0380*      LD BC,-1000000
0401BE CD E9 01 04 0381*      CALL @one_digit
0401C2 01 60 79 FE 0382*      LD BC,-100000
0401C6 CD E9 01 04 0383*      CALL @one_digit
0401CA 01 F0 D8 FF 0384*      LD BC,-10000
0401CE CD E9 01 04 0385*      CALL @one_digit
0401D2 01 18 FC FF 0386*      LD BC,-1000
0401D6 CD E9 01 04 0387*      CALL @one_digit
0401DA 01 9C FF FF 0388*      LD BC,-100
0401DE CD E9 01 04 0389*      CALL @one_digit
0401E2 0E F6       0390*      LD C,-10
0401E4 CD E9 01 04 0391*      CALL @one_digit
0401E8 48          0392*      LD C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*      LD A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*      INC A
0401EC 09          0397*      ADD HL,BC
0401ED 38 FC       0398*      JR C,@divide_me
0401EF ED 42       0399*      SBC HL,BC
0401F1 12          0400*      LD (DE),A
0401F2 13          0401*      INC DE
0401F3 C9          0402*      RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl ; Save HL (weâ€™ll need the fractional part later)
040212 CD FB 06 04 0427*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp @frac ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc a
040240 09          0443*      add hl, bc ; Accumulate until overflow
040241 38 FC       0444*      jr c, @divide_me
040243 ED 42       0445*      sbc hl, bc ; Remove excess after overflow
040245 12          0446*      ld (de), a ; Store ASCII digit
040246 13          0447*      inc de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld a, '.' ; Decimal point
04024A 12          0452*      ld (de), a
04024B 13          0453*      inc de
04024C E1          0454*      pop hl ; Restore HL with original fraction
04024D 06 03       0455*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld a, '0'
040255 84          0460*      add a, h ; Convert integer part to ASCII
040256 12          0461*      ld (de), a
040257 13          0462*      inc de
040258 10 F5       0463*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor a ; Null terminator
04025B 12          0466*      ld (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 94 06 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0602*      ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*      ld hl,@cmd
04032B 01 08 00 00 0615*      ld bc,@end-@cmd
04032F 5B DF       0616*      rst.lil $18
040331 C9          0617*      ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0627*      ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*      ld hl,@cmd
040350 01 08 00 00 0640*      ld bc,@end-@cmd
040354 5B DF       0641*      rst.lil $18
040356 C9          0642*      ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0903*      rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*      call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0030       include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*      add hl,de
04068E             0007*      or a
04068E             0008*      sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de ; save de
0406A5 EB          0045*      ex de,hl ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0 ; clear hl
0406AA AF          0047*      xor a ; clear carry
0406AB ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
0406AD D1          0049*      pop de ; get de back
0406AE C9          0050*      ret ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*      ld (scratch1),hl
0406B3 21 90 06 04 0057*      ld hl,scratch1+2
0406B7 CB 1E       0058*      rr (hl)
0406B9 2B          0059*      dec hl
0406BA CB 1E       0060*      rr (hl)
0406BC 2B          0061*      dec hl
0406BD CB 1E       0062*      rr (hl)
0406BF 23          0063*      inc hl
0406C0 23          0064*      inc hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M     add hl,de
0406E6 B7          0002*M     or a
0406E7 ED 52       0003*M     sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*      xor a
0406FC 32 0D 07 04 0105*      ld (@buffer+3),a
040700 7D          0106*      ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*      ld (@buffer),hl
040705 2A 0B 07 04 0108*      ld hl,(@buffer+1)
040709 C9          0109*      ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*      add hl,hl ; * 2
04070E             0114*      add hl,hl ; * 4
04070E             0115*      add hl,hl ; * 8
04070E             0116*      add hl,hl ; * 16
04070E             0117*      add hl,hl ; * 32
04070E             0118*      add hl,hl ; * 64
04070E             0119*      add hl,hl ; * 128
04070E             0120*      add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*      or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*      ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0031       include "enemies.inc"
040785 01          0001*  max_enemy_sprites: db 1
040786             0002*  
040786             0003*  ; sprite_type
040786             0004*  enemy_dead: equ 0
040786             0005*  enemy_small: equ 1
040786             0006*  enemy_medium: equ 2
040786             0007*  enemy_large: equ 3
040786             0008*  landing_pad: equ 4
040786             0009*  laser_turret: equ 5
040786             0010*  fireballs: equ 6
040786             0011*  explosion: equ 7
040786             0012*  
040786             0013*  
040786             0014*  respawn_countdown:
040786 2A AA 07 04 0015*      ld hl,(respawn_timer)
04078A 2B          0016*      dec hl
04078B 22 AA 07 04 0017*      ld (respawn_timer),hl
04078F             0018*  ; check hl for zero
04078F 19          0019*      add hl,de
040790 B7          0020*      or a
040791 ED 52       0021*      sbc hl,de
040793 C0          0022*      ret nz
040794 3A 85 07 04 0023*      ld a,(max_enemy_sprites)
040798 47          0024*      ld b,a ; loop counter
040799             0025*  @respawn_loop:
040799 C5          0026*      push bc
04079A CD 8F 08 04 0027*      call enemy_init_from_landing_pad
04079E C1          0028*      pop bc
04079F 10 F8       0029*      djnz @respawn_loop
0407A1 21 3C 00 00 0030*      ld hl,1*60 ; 1 second
0407A5 22 AA 07 04 0031*      ld (respawn_timer),hl
0407A9 C9          0032*      ret
0407AA 3C 00 00    0033*  respawn_timer: dl 1*60
0407AD             0034*  
0407AD             0035*  move_enemies:
0407AD             0036*  ; are there any active enemies or explosions?
0407AD 21 00 00 00 0037*      ld hl,0
0407B1 3A 22 3A 04 0038*      ld a,(table_active_sprites)
0407B5 6F          0039*      ld l,a
0407B6             0040*      ; call dumpRegistersHex
0407B6 A7          0041*      and a ; will be zero if no alive enemies or explosions
0407B7             0042*      ; ret z ; so nothing to do but go back
0407B7             0043*      ; ld hl,(respawn_timer)
0407B7             0044*      ; call dumpRegistersHex
0407B7 20 05       0045*      jr nz,move_enemies_do
0407B9 CD 86 07 04 0046*      call respawn_countdown
0407BD C9          0047*      ret
0407BE             0048*  move_enemies_do:
0407BE             0049*  ; initialize pointers and loop counter
0407BE FD 21 BF 37 0050*      ld iy,table_base ; set iy to first record in table
       04          
0407C3 06 10       0051*      ld b,table_max_records ; loop counter
0407C5             0052*  move_enemies_loop:
0407C5 FD 22 1F 3A 0053*      ld (table_pointer),iy ; update table pointer
       04          
0407CA C5          0054*      push bc ; backup loop counter
0407CB             0055*  ; check sprite_type to see if sprite is active
0407CB FD 7E 01    0056*      ld a,(iy+sprite_type)
0407CE A7          0057*      and a ; if zero, sprite is dead
0407CF 28 2E       0058*      jr z,move_enemies_next_record ; ... and we skip to next record
0407D1             0059*  ; otherwise we prepare to move the sprite
0407D1 FD 7E 00    0060*      ld a,(iy+sprite_id) ; get spriteId
0407D4 CD 02 43 04 0061*      call vdu_sprite_select ; select sprite
0407D8 FD 27 05    0062*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0407DB E9          0063*      jp (hl) ; ... and jump to it
0407DC             0064*  ; we always jp back here from behavior subroutines
0407DC             0065*  move_enemies_loop_return:
0407DC FD 2A 1F 3A 0066*      ld iy,(table_pointer) ; get back table pointer
       04          
0407E1             0067*  ; now we check results of all the moves
0407E1 FD 7E 08    0068*      ld a,(iy+sprite_collisions)
0407E4 E6 F0       0069*      and %11110000 ; any bits set in high nibble means we died
0407E6 FD 7E 00    0070*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0407E9 28 0A       0071*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0407EB CD 6B 3A 04 0072*      call table_deactivate_sprite ; otherwise we ded
0407EF AF          0073*      xor a ; zero a so that we can ...
0407F0 FD 77 08    0074*      ld (iy+sprite_collisions),a ; ... clear collision flags
0407F3 18 0A       0075*      jr move_enemies_next_record ; and to the next record
0407F5             0076*  move_enemies_draw_sprite:
0407F5             0077*  ; if we got here sprite will have already been activated
0407F5             0078*  ; so all we need to do is set its coordinates and draw it
0407F5 FD 07 0B    0079*      ld bc,(iy+sprite_x)
0407F8 FD 17 0E    0080*      ld de,(iy+sprite_y)
0407FB CD CE 43 04 0081*      call vdu_sprite_move_abs168
0407FF             0082*  ; fall through to next record
0407FF             0083*  move_enemies_next_record:
0407FF 11 26 00 00 0084*      ld de,table_bytes_per_record
040803 FD 19       0085*      add iy,de ; point to next record
040805 AF          0086*      xor a ; clears carry flag
040806 32 23 3A 04 0087*      ld (sprite_screen_edge),a ; clear screen edge collision flag
04080A C1          0088*      pop bc ; get back our loop counter
04080B 10 B8       0089*      djnz move_enemies_loop ; loop until we've checked all the records
04080D C9          0090*      ret ; and we're out
04080E             0091*  
04080E             0092*  en_nav_zigzag_start:
04080E FD 2A 1F 3A 0093*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040813 CD 49 07 04 0094*      call rand_8
040817 E6 3F       0095*      and %00111111 ; limit it to 64
040819 CB DF       0096*      set 3,a ; make sure it's at least 8
04081B FD 77 22    0097*      ld (iy+sprite_move_timer),a ; store it
04081E             0098*      ; fall through to en_nav_zigzag
04081E             0099*  en_nav_zigzag:
04081E FD 7E 22    0100*      ld a,(iy+sprite_move_timer)
040821 3D          0101*      dec a
040822 FD 77 22    0102*      ld (iy+sprite_move_timer),a
040825 20 1C       0103*      jr nz,en_nav_zigzag_no_switch
040827             0104*      ; otherwise flip direction and restart timer
040827 FD 7E 23    0105*      ld a,(iy+sprite_move_step)
04082A EE 01       0106*      xor %1 ; flips bit one
04082C FD 77 23    0107*      ld (iy+sprite_move_step),a ; store it
04082F 20 09       0108*      jr nz,en_nav_zigzag_right
040831             0109*  ;otherwise zag left
040831 21 00 A0 00 0110*      ld hl,0x00A000; southwest heading
040835 FD 2F 1A    0111*      ld (iy+sprite_heading),hl ; save sprite heading
040838 18 D4       0112*      jr en_nav_zigzag_start
04083A             0113*  en_nav_zigzag_right:
04083A 21 00 60 00 0114*      ld hl,0x006000; southeast heading
04083E FD 2F 1A    0115*      ld (iy+sprite_heading),hl ; save sprite heading
040841 18 CB       0116*      jr en_nav_zigzag_start
040843             0117*  en_nav_zigzag_no_switch:
040843             0118*      ; ld a,(sprite_orientation)
040843 FD 27 1A    0119*      ld hl,(iy+sprite_heading)
040846 18 13       0120*      jr en_nav_computevelocities
040848             0121*  
040848             0122*  ; contains the logic for how to move the enemy
040848             0123*  ; and then does the moving
040848             0124*  ; inputs: a fully-populated active sprite table
040848             0125*  ;         player position variables
040848             0126*  ; destroys: everything except index registers
040848             0127*  ; outputs: moving enemies
040848             0128*  en_nav:
040848             0129*  ; set velocity and orientation by player's relative location
040848             0130*  ; move enemies y-axis
040848             0131*  ; where is player relative to us?
040848 CD 12 09 04 0132*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
04084C             0133*  ; is player above or below us?
04084C ED 53 A5 05 0134*      ld (ude),de ; dy
       04          
040851 3A A7 05 04 0135*      ld a,(ude+2) ; deu
040855 17          0136*      rla ; shift sign bit into carry
040856 30 C6       0137*      jr nc,en_nav_zigzag ; player is below,evade
040858             0138*  ; player is even or above,so home in on current heading
040858 FD 2F 1A    0139*      ld (iy+sprite_heading),hl ; save sprite heading
04085B             0140*  
04085B             0141*  ; we land here from zig-zag program so as not to
04085B             0142*  ; redundantly save orientation and heading
04085B             0143*  en_nav_computevelocities:
04085B             0144*  ; set x/y component velocities based on bearing to player
04085B FD 2A 1F 3A 0145*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040860 E5          0146*      push hl ; we need it back to set rotation frame
040861 FD 17 17    0147*      ld de,(iy+sprite_vel)
040864 CD CA 0B 04 0148*      call polar_to_cartesian
040868 FD 2A 1F 3A 0149*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04086D FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
040870 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
040873             0152*  ; change the animation frame to match heading
040873             0153*  ; by dividng the heading by 8
040873 E1          0154*      pop hl ; get back Heading
040874 7C          0155*      ld a,h
040875 CB 3F       0156*      srl a
040877 CB 3F       0157*      srl a
040879 CB 3F       0158*      srl a
04087B CD 65 43 04 0159*      call vdu_sprite_select_frame
04087F C3 D3 3A 04 0160*      jp move_sprite ; will return to caller from there
040883             0161*  
040883             0162*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
040883             0163*  ; ; each sprite in the table must have one of these defined
040883             0164*  ; ; but they need not be unique to a particular sprite
040883             0165*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
040883             0166*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
040883             0167*  ; ; but they can call anything they want between those two endpoints
040883             0168*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
040883             0169*  
040883             0170*  ; move_nop: ; does nothing but burn a few cycles changing the PC
040883             0171*  ;     jp move_enemies_loop_return
040883             0172*  
040883             0173*  ; move_explosion:
040883             0174*  ;     call animate_explosion
040883             0175*  ;     jp move_enemies_loop_return
040883             0176*  
040883             0177*  move_enemy_small:
040883 CD 48 08 04 0178*      call en_nav
040887 CD AB 09 04 0179*      call check_collisions
04088B C3 DC 07 04 0180*      jp move_enemies_loop_return
04088F             0181*  
04088F             0182*  ; move_enemy_medium:
04088F             0183*  ;     call en_nav
04088F             0184*  ;     call check_collisions
04088F             0185*  ;     jp move_enemies_loop_return
04088F             0186*  
04088F             0187*  ; move_enemy_large:
04088F             0188*  ;     call en_nav
04088F             0189*  ;     call check_collisions
04088F             0190*  ;     jp move_enemies_loop_return
04088F             0191*  
04088F             0192*  ; move_landing_pad:
04088F             0193*  ;     call move_active_tiles
04088F             0194*  ;     call check_collisions
04088F             0195*  ; ; is it time to launch an enemy?
04088F             0196*  ;     ld hl,sprite_move_timer
04088F             0197*  ;     dec (hl)
04088F             0198*  ;     jp nz,move_enemies_loop_return
04088F             0199*  ;     call enemy_init_from_landing_pad
04088F             0200*  ;     ; reset move timer so can spawn again if player doesn't take us out
04088F             0201*  ;     call rand_8     ; snag a random number
04088F             0202*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04088F             0203*  ;     add a,64 ; range is now 64-127
04088F             0204*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04088F             0205*  ;     jp move_enemies_loop_return
04088F             0206*  
04088F             0207*  speed_seeker: equ 0x000280 ; 2.5 pixels per frame
04088F             0208*  enemy_init_from_landing_pad:
04088F             0209*  ; get next available spriteId
04088F CD 46 3A 04 0210*      call table_get_next_id
040893 D0          0211*      ret nc ; no carry means no free sprite slots, so we go home
040894             0212*  ; ix comes back with the pointer to the new sprite variables
040894 DD E5       0213*      push ix ; de picks it up when we're ready for the copy to the table
040896             0214*  ; a comes back with the spriteId of the new sprite
040896 32 EC 08 04 0215*      ld (@id),a
04089A             0216*  ; initialize the new sprite
04089A CD 02 43 04 0217*      call vdu_sprite_select
04089E CD 15 43 04 0218*      call vdu_sprite_clear_frames
0408A2 21 14 01 00 0219*      ld hl,BUF_SEEKER_000
0408A6 06 20       0220*      ld b,32
0408A8             0221*  @load_frames:
0408A8 C5          0222*      push bc
0408A9 E5          0223*      push hl
0408AA CD 57 44 04 0224*      call vdu_sprite_add_buff
0408AE E1          0225*      pop hl
0408AF 23          0226*      inc hl
0408B0 C1          0227*      pop bc
0408B1 10 F5       0228*      djnz @load_frames
0408B3             0229*  ; copy coordinates of active sprite to new sprite
0408B3 FD 2A 1F 3A 0230*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0408B8             0231*      ; ld hl,(iy+sprite_x)
0408B8             0232*      ; ld hl,0x008000 ; debug
0408B8             0233*  
0408B8 CD 49 07 04 0234*      call rand_8
0408BC 21 00 00 00 0235*      ld hl,0
0408C0 67          0236*      ld h,a
0408C1             0237*  
0408C1 22 F7 08 04 0238*      ld (@x),hl
0408C5             0239*      ; ld hl,(iy+sprite_y)
0408C5             0240*      ; ld hl,0x002000 ; debug
0408C5             0241*  
0408C5 CD 49 07 04 0242*      call rand_8
0408C9 21 00 00 00 0243*      ld hl,0
0408CD 67          0244*      ld h,a
0408CE             0245*  
0408CE 22 FA 08 04 0246*      ld (@y),hl
0408D2 CD 49 07 04 0247*      call rand_8
0408D6 E6 01       0248*      and %00000001 ; 50/50 chance of moving left or right on spanw
0408D8 32 0F 09 04 0249*      ld (@move_step),a
0408DC             0250*  ; now copy to the table
0408DC 21 EC 08 04 0251*      ld hl,@id ; address to copy from
0408E0 D1          0252*      pop de ; address to copy to (was ix)
0408E1 01 26 00 00 0253*      ld bc,table_bytes_per_record ; number of bytes to copy
0408E5 ED B0       0254*      ldir ; copy the records from local scratch to sprite table
0408E7             0255*  ; finally, make the new sprite visible
0408E7 CD 78 43 04 0256*      call vdu_sprite_show
0408EB C9          0257*      ret
0408EC 00          0258*  @id:                    db 0x00 ; 1 bytes unique spriteId, zero-based
0408ED 01          0259*  @type:                  db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
0408EE 14 01 00    0260*  @base_bufferId:         dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0408F1 83 08 04    0261*  @move_program:          dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0408F4 03          0262*  @collisions:            db %00000011 ; 3 bytes collides with enemy and laser
0408F5 10          0263*  @dim_x:                 db 0x10 ; 1 bytes sprite width in pixels
0408F6 10          0264*  @dim_y:                 db 0x10 ; 1 bytes sprite height in pixels
0408F7 00 00 00    0265*  @x:                     dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0408FA 00 00 00    0266*  @y:                     dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0408FD 00 00 00    0267*  @xvel:                  dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
040900 00 00 00    0268*  @yvel:                  dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
040903 80 02 00    0269*  @vel:                   dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
040906 00 80 00    0270*  @heading:               dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
040909 00 80 00    0271*  @orientation:           dl 0x008000 ; 3 bytes orientation bits
04090C 00          0272*  @animation:             db 0x00 ; 1 bytes current animation index, zero-based
04090D 00          0273*  @animation_timer:       db 0x00 ; 1 bytes when hits zero, draw next animation
04090E 01          0274*  @move_timer:            db 0x01 ; 1 bytes when zero, go to next move program, or step
04090F 00          0275*  @move_step:             db 0x00 ; 1 bytes stage in a move program sequence, varies
040910 20          0276*  @points:                db 0x20 ; 1 bytes points awarded for killing this sprite type, BCD
040911 02          0277*  @shield_damage:         db 0x02 ; 1 bytes shield points deducted for collision, binary
040912             0278*  
040912             0279*  ; move_laser_turret:
040912             0280*  ; ; compute orientation to player
040912             0281*  ;     call orientation_to_player
040912             0282*  ; ; h.l 8.8 fixed angle256 to player
040912             0283*  ; ; bc and de as signed 16-bit integers
040912             0284*  ; ; representing delta-x/y *to* target respectively
040912             0285*  ;     ld (Bearing_t),hl
040912             0286*  ;     ld hl,0x0400
040912             0287*  ;     ld (Vp),hl
040912             0288*  ;     call targeting_computer
040912             0289*  ;     ld (sprite_heading),hl ; store bearing to player
040912             0290*  ; ; is it time to launch a fireball?
040912             0291*  ;     ld hl,sprite_move_timer
040912             0292*  ;     dec (hl)
040912             0293*  ;     jp nz,move_laser_turret_boilerplate
040912             0294*  ;     call fireballs_init
040912             0295*  ;     ; reset move timer so can fire again if player doesn't take us out
040912             0296*  ;     call rand_8     ; snag a random number
040912             0297*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
040912             0298*  ;     add a,64 ; range is now 64-127
040912             0299*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
040912             0300*  ; move_laser_turret_boilerplate:
040912             0301*  ;     call move_active_tiles
040912             0302*  ;     call check_collisions
040912             0303*  ;     jp move_enemies_loop_return
040912             0304*  
040912             0305*  ; fireballs_init:
040912             0306*  ;     call sprite_variables_to_stack
040912             0307*  
040912             0308*  ;     ld hl,fireballs
040912             0309*  ;     ld (sprite_base_bufferId),hl
040912             0310*  
040912             0311*  ;     ld hl,move_fireballs
040912             0312*  ;     ld (sprite_move_program),hl
040912             0313*  
040912             0314*  ;     ld a,%11 ; collides with laser and player
040912             0315*  ;     ; ld a,%10 ; collides with laser DEBUG
040912             0316*  ;     ld (iy+sprite_collisions),a
040912             0317*  
040912             0318*  ;     ld hl,(Vp)
040912             0319*  ;     ld (sprite_vel),hl
040912             0320*  ;     ld hl,(Vp_x)
040912             0321*  ;     ld (sprite_xvel),hl
040912             0322*  ;     ld hl,(Vp_y)
040912             0323*  ;     inc h ; account for ground movement
040912             0324*  ;     ld (sprite_yvel),hl
040912             0325*  
040912             0326*  ;     xor a ; zero a
040912             0327*  ;     ld (sprite_animation),a
040912             0328*  ;     ld (sprite_move_step),a
040912             0329*  ;     ld (sprite_move_timer),a
040912             0330*  
040912             0331*  ;     ld a,6 ; 1/10th of a second timer
040912             0332*  ;     ld (sprite_animation_timer),a
040912             0333*  
040912             0334*  ;     ld a,0x00 ; BCD
040912             0335*  ;     ld (sprite_points),a
040912             0336*  ;     ld a,1 ; binary
040912             0337*  ;     ld (sprite_shield_damage),a
040912             0338*  
040912             0339*  ;     call table_add_record ; plops that on the sprite stack for later
040912             0340*  ;     call sprite_variables_from_stack ; come back to where we started
040912             0341*  ;     ret
040912             0342*  
040912             0343*  ; move_fireballs:
040912             0344*  ;     call move_sprite ; move sprite
040912             0345*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
040912             0346*  ;     and a ; if zero we're still within screen bounds
040912             0347*  ;     jr z,move_fireballs_alive
040912             0348*  ; ; otherwise kill sprite
040912             0349*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
040912             0350*  ;     ld (iy+sprite_collisions),a
040912             0351*  ;     jp move_enemies_loop_return
040912             0352*  ; move_fireballs_alive:
040912             0353*  ;     ld a,(sprite_animation_timer)
040912             0354*  ;     dec a
040912             0355*  ;     ld (sprite_animation_timer),a
040912             0356*  ;     jr nz,move_fireballs_draw
040912             0357*  ;     ld a,(sprite_animation)
040912             0358*  ;     xor %1
040912             0359*  ;     ld (sprite_animation),a
040912             0360*  ;     ld a,6 ; 1/10th of a second timer
040912             0361*  ;     ld (sprite_animation_timer),a
040912             0362*  ;     ; fall through
040912             0363*  
040912             0364*  ; move_fireballs_draw:
040912             0365*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
040912             0366*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
040912             0367*  ;     call check_collisions
040912             0368*  ;     jp move_enemies_loop_return
040912             0369*  
040912             0370*  ; compute orientation to player
040912             0371*  ; based on relative positions
040912             0372*  ; returns: h.l 16.8 fixed angle256 to player
040912             0373*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
040912             0374*  ;    representing delta-x/y *to* target respectively
040912             0375*  orientation_to_player:
040912 FD 2A 1F 3A 0376*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040917 FD 07 0B    0377*      ld bc,(iy+sprite_x)
04091A FD 17 0E    0378*      ld de,(iy+sprite_y)
04091D DD 2A DC 36 0379*      ld ix,(player_x)
       04          
040922 FD 2A DF 36 0380*      ld iy,(player_y)
       04          
040927 CD FF 0B 04 0381*      call dxy168
04092B C5          0382*      push bc
04092C D5          0383*      push de
04092D CD 5C 0C 04 0384*      call atan2_168fast
040931 D1          0385*      pop de
040932 C1          0386*      pop bc
040933 FD 2A 1F 3A 0387*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040938 C9          0388*      ret
040939             0389*  
040939             0390*  
040939             0391*  ; targeting_computer scratch variables
040939 00 00       0392*  Bearing_t: dw #0000 ; 8.8 fixed
04093B 00 00       0393*  Heading_t: dw #0000 ; 8.8 fixed
04093D 00 00       0394*  Vp: dw #0000 ; 8.8 fixed
04093F 00 00       0395*  Vp_x: dw #0000 ; 8.8 fixed
040941 00 00       0396*  Vp_y: dw #0000 ; 8.8 fixed
040943 00 00       0397*  Vt: dw #0000 ; 8.8 fixed
040945 00 00       0398*  Vt_x: dw #0000 ; 8.8 fixed
040947 00 00       0399*  Vt_y: dw #0000 ; 8.8 fixed
040949             0400*  
040949             0401*  
040949             0402*  ; ; Inputs:   see scratch variables
040949             0403*  ; ; Note:     a call to orientation_to_player provides these inputs
040949             0404*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
040949             0405*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
040949             0406*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
040949             0407*  ; targeting_computer:
040949             0408*  ; ; compute target velocity from x,y component velocities
040949             0409*  ;     ld bc,(player_xvel)
040949             0410*  ;     ld de,(player_yvel)
040949             0411*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
040949             0412*  
040949             0413*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
040949             0414*  ;     ld (Heading_t),bc
040949             0415*  ;     ld (Vt),de
040949             0416*  
040949             0417*  ; ; compute Heading_t-Bearing_t
040949             0418*  ;     ld h,b
040949             0419*  ;     ld l,c
040949             0420*  ;     ld bc,(Bearing_t)
040949             0421*  ;     and a ; clear carry
040949             0422*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
040949             0423*  
040949             0424*  ; ; compute sin(Heading_t-Bearing_t)
040949             0425*  ;     ld b,h
040949             0426*  ;     ld c,l
040949             0427*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
040949             0428*  
040949             0429*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
040949             0430*  ;     ex de,hl
040949             0431*  ;     ld bc,(Vt)
040949             0432*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
040949             0433*  
040949             0434*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
040949             0435*  ;     ld b,h
040949             0436*  ;     ld c,l
040949             0437*  ;     ld de,(Vp)
040949             0438*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
040949             0439*  ; ; answer is in radians, convert to degrees256
040949             0440*  ;     ex de,hl
040949             0441*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
040949             0442*  ;     call BC_Mul_DE_88
040949             0443*  
040949             0444*  ; ; add lead angle to target bearing
040949             0445*  ;     ld de,(Bearing_t)
040949             0446*  ;     add hl,de ; h.l=lead angle+target bearing
040949             0447*  ;     push hl
040949             0448*  
040949             0449*  ; ; compute component projectile velocities
040949             0450*  ;     ld b,h
040949             0451*  ;     ld c,l
040949             0452*  ;     ld de,(Vp)
040949             0453*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
040949             0454*  
040949             0455*  ;     ld (Vp_x),bc
040949             0456*  ;     ld (Vp_y),de
040949             0457*  ;     pop hl ; h.l=lead angle+target bearing
040949             0458*  ;     ret
040949             0459*  
040949             0460*  ; this routine vanquishes the enemy sprite
040949             0461*  ; and replaces it with an animated explosion
040949             0462*  ; we jump here instead of call because
040949             0463*  ; we want to return to differing locations in the loop
040949             0464*  ; depending on whether we're still sploding
040949             0465*  ; destroys: everything except index registers
040949             0466*  ; returns: an incandescent ball of debris and gas
040949             0467*  kill_nurple:
040949             0468*  ; ; tally up points
040949             0469*  ;     ld bc,0
040949             0470*  ;     ld a,(sprite_points)
040949             0471*  ;     ld e,a
040949             0472*  ;     ld d,0
040949             0473*  ;     ld hl,add_bcd_arg2
040949             0474*  ;     call set_bcd
040949             0475*  ;     ld hl,player_score
040949             0476*  ;     ld de,add_bcd_arg2
040949             0477*  ;     ld a,3 ; number of bytes to add
040949             0478*  ;     call add_bcd
040949             0479*  ; ; initialize explosion
040949             0480*  ; init_explosion:
040949             0481*  ;     ld hl,explosion
040949             0482*  ;     ld (sprite_base_bufferId),hl
040949             0483*  ;     ld hl,move_explosion
040949             0484*  ;     ld (sprite_move_program),hl
040949             0485*  ;     ld a,%00000000 ; collides with nothing
040949             0486*  ;     ld (iy+sprite_collisions),a
040949             0487*  ;     ld hl,0 ; north
040949             0488*  ;     ld (sprite_heading),hl
040949             0489*  ;     ld a,0x04 ; will decrement to 03
040949             0490*  ;     ld (sprite_animation),a
040949             0491*  ;     ld a,0x07 ; 7/60th of a second timer
040949             0492*  ;     ld (sprite_animation_timer),a
040949             0493*  ;     xor a
040949             0494*  ;     ld (sprite_move_timer),a
040949             0495*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
040949             0496*  ; ; fall through to next_explosion
040949             0497*  ; next_explosion:
040949             0498*  ;     ld a,(sprite_animation)
040949             0499*  ;     dec a ; if rolled negative from zero,we're done sploding
040949             0500*  ;     jp m,done_explosion
040949             0501*  ;     ld (sprite_animation),a
040949             0502*  ;     ld a,0x7 ; 7/60th of a second timer
040949             0503*  ;     ld (sprite_animation_timer),a
040949             0504*  ; ; fall through to animate_explosion
040949             0505*  ; animate_explosion:
040949             0506*  ;     ld hl,sprite_y+1
040949             0507*  ;     inc (hl) ; move explosion down 1 pixel
040949             0508*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
040949             0509*  ;     ld hl,sprite_animation_timer
040949             0510*  ;     dec (hl) ; if timer is zero,we do next animation
040949             0511*  ;     jr z,next_explosion
040949             0512*  ;     ;otherwise we fall through to draw the current one
040949             0513*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
040949             0514*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
040949             0515*  ;     ret ; now we go back to caller
040949             0516*  ; done_explosion:
040949 3E 80       0517*      ld a,%10000000 ; high bit set is non-specific kill-me flag
04094B FD 2A 1F 3A 0518*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
040950 FD 77 08    0519*      ld (iy+sprite_collisions),a
040953 C9          0520*      ret ; now we go back to caller
040954             0521*  
040954             0522*  ; game_over:
040954             0523*  ;     jp new_game
040954             0524*  
040954             0525*  ; it's presumed we've already checked that laser is alive
040954             0526*  collision_enemy_with_laser:
040954 DD 2A AE 25 0527*      ld ix,(laser_x)
       04          
040959 FD 2A B1 25 0528*      ld iy,(laser_y)
       04          
04095E 3A AC 25 04 0529*      ld a,(laser_dim_x)
040962 CB 2F       0530*      sra a ; divide by 2
040964 F5          0531*      push af ; we need this later
040965 C3 7A 09 04 0532*      jp collision_enemy
040969             0533*  
040969             0534*  ; it's presumed we've already checked that player is alive
040969             0535*  collision_enemy_with_player:
040969 DD 2A DC 36 0536*      ld ix,(player_x)
       04          
04096E FD 2A DF 36 0537*      ld iy,(player_y)
       04          
040973 3A DA 36 04 0538*      ld a,(player_dim_x)
040977 CB 2F       0539*      sra a ; divide by 2
040979 F5          0540*      push af ; we need this later
04097A             0541*      ; fall through to collision_enemy
04097A             0542*  
04097A             0543*  ; compute the distance between the two sprites' centers
04097A             0544*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
04097A             0545*  collision_enemy:
04097A             0546*  ; back up iy because we need it as the sprite table pointer
04097A FD E5       0547*      push iy
04097C FD 2A 1F 3A 0548*      ld iy,(table_pointer)
       04          
040981 FD 27 0B    0549*      ld hl,(iy+sprite_x)
040984 FD 7E 09    0550*      ld a,(iy+sprite_dim_x)
040987 CB 2F       0551*      sra a
040989 F5          0552*      push af ; we need this later
04098A E5          0553*      push hl
04098B C1          0554*      pop bc ; bc = x0
04098C FD 27 0E    0555*      ld hl,(iy+sprite_y)
04098F FD 7E 0A    0556*      ld a,(iy+sprite_dim_y)
040992 EB          0557*      ex de,hl ; de = y0
040993 F1          0558*      pop af ; TODO: srsly, this is the best way to do this?
040994 FD E1       0559*      pop iy
040996 F5          0560*      push af
040997 CD 26 0C 04 0561*      call distance168
04099B             0562*  
04099B             0563*  ; ; subtract sum of radii from distance between centers
04099B             0564*  ;     ld de,0
04099B             0565*  ;     pop af ; radius of enemy sprite
04099B             0566*  ;     ld e,a
04099B             0567*  ;     pop af ; radius of player or laser sprite
04099B             0568*  ;     add a,e
04099B             0569*  ;     ld e,a
04099B             0570*  ;     and a ; clear carry
04099B             0571*  ;     sbc hl,de
04099B             0572*  ;     jr c,collision_enemy_is
04099B             0573*  ;     xor a
04099B             0574*  ;     ret
04099B             0575*  ; temp fix TODO: remove this
04099B F1          0576*      pop af
04099C F1          0577*      pop af
04099D 11 00 10 00 0578*      ld de,16*256
0409A1 A7          0579*      and a
0409A2 ED 52       0580*      sbc hl,de
0409A4 38 02       0581*      jr c,collision_enemy_is
0409A6 AF          0582*      xor a
0409A7 C9          0583*      ret
0409A8             0584*  collision_enemy_is:
0409A8 AF          0585*      xor a
0409A9 3C          0586*      inc a
0409AA C9          0587*      ret
0409AB             0588*  
0409AB             0589*  ; looks up what enemy sprite collides with
0409AB             0590*  ; detects collisions
0409AB             0591*  ; and sets things to sploding accordingly
0409AB             0592*  check_collisions:
0409AB FD 7E 08    0593*      ld a,(iy+sprite_collisions) ; snag what we collide with
0409AE A7          0594*      and a ; if this is zero,
0409AF C8          0595*      ret z ; there's nothing to do
0409B0 E6 01       0596*      and %01 ; do we collide with player?
0409B2 28 27       0597*      jr z,move_enemies_laser ; if not,check laser collision
0409B4 CD 69 09 04 0598*      call collision_enemy_with_player ; otherwise see if we hit player
0409B8 A7          0599*      and a ; was there a collision?
0409B9 28 20       0600*      jr z,move_enemies_laser ; if not,see if laser smacked us
0409BB             0601*  ; yes collision with player
0409BB             0602*      ; deduct shield damage
0409BB 21 25 00 00 0603*      ld hl,sprite_shield_damage
0409BF 3A CE 36 04 0604*      ld a,(player_shields)
0409C3 96          0605*      sub (hl)
0409C4 32 CE 36 04 0606*      ld (player_shields),a
0409C8             0607*  ; if shields >= 0,player survives
0409C8 F2 D6 09 04 0608*      jp p,check_collisions_kill_nurple
0409CC             0609*  ; otherwise update player status so it will die
0409CC 3A D9 36 04 0610*      ld a,(player_collisions)
0409D0 F6 02       0611*      or %10 ; sets bit 1,meaning player just died
0409D2 32 D9 36 04 0612*      ld (player_collisions),a
0409D6             0613*      ; fall through
0409D6             0614*  check_collisions_kill_nurple:
0409D6             0615*  ; kill enemy and replace with explosion
0409D6 CD 49 09 04 0616*      call kill_nurple
0409DA C9          0617*      ret ; and out
0409DB             0618*  
0409DB             0619*  ; did we hit the laser?
0409DB             0620*  move_enemies_laser:
0409DB FD 7E 08    0621*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0409DE E6 02       0622*      and %10 ; do we even collide with laser?
0409E0 C8          0623*      ret z ; if not,we're out
0409E1 3A AB 25 04 0624*      ld a,(laser_collisions) ; is laser alive?
0409E5 E6 01       0625*      and %1 ; if bit 0 is not set laser is dead
0409E7 C8          0626*      ret z ; so we're out
0409E8 CD 54 09 04 0627*      call collision_enemy_with_laser ; otherwise check for collision
0409EC A7          0628*      and a ; was there a collision?
0409ED C8          0629*      ret z ; if not,we're done
0409EE             0630*  ; otherwise we mark laser for termination and kill enemy
0409EE             0631*  ; update laser status so it will die
0409EE 3A AB 25 04 0632*      ld a,(laser_collisions)
0409F2 F6 02       0633*      or %10 ; bit 1 set means laser just died
0409F4 32 AB 25 04 0634*      ld (laser_collisions),a
0409F8 CD 49 09 04 0635*      call kill_nurple ; yes there was a collision,so kill enemy
0409FC C9          0636*      ret ; we're outta' here
0409FD             0032       include "files.inc"
0409FD             0001*  ; load to onboard 8k sram
0409FD             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0409FD             0033       include "fixed168.inc"
0409FD             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0409FD             0002*  ; uses EZ80 MLT instruction for speed
0409FD             0003*  ; operation: UHL * A --> UHL
0409FD             0004*  ; destroys: AF, HL
0409FD             0005*  smul24x8:
0409FD             0006*  ; make hl positive and store sign flag
0409FD CD 94 06 04 0007*      call hlu_abs
040A01 F5          0008*      push af
040A02             0009*  ; do the division
040A02 CD 0D 0A 04 0010*      call mul24x8 ; hl = product
040A06             0011*  ; adjust sign of result
040A06 F1          0012*      pop af ; sign de
040A07 F0          0013*      ret p ; hl was positive, nothing to do
040A08 CD A4 06 04 0014*      call neg_hlu ; result is negative
040A0C C9          0015*      ret
040A0D             0016*  
040A0D             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A0D             0018*  ; uses EZ80 MLT instruction for speed
040A0D             0019*  ; operation: UHL * A --> AUHL
040A0D             0020*  ; destroys: AF, HL
040A0D             0021*  mul24x8:
040A0D D5          0022*      push de ; preserve de
040A0E             0023*  ; low byte
040A0E 5D          0024*      ld e,l
040A0F 57          0025*      ld d,a
040A10 ED 5C       0026*      mlt de
040A12 6B          0027*      ld l,e ; product low byte
040A13 08          0028*      ex af,af' ; save multiplier
040A14 7A          0029*      ld a,d ; carry
040A15 08          0030*      ex af,af' ; save carry, restore multiplier
040A16             0031*  ; high byte
040A16 5C          0032*      ld e,h
040A17 57          0033*      ld d,a
040A18 ED 5C       0034*      mlt de
040A1A 08          0035*      ex af,af' ; save multiplier, restore carry
040A1B 83          0036*      add a,e ; add carry
040A1C 67          0037*      ld h,a ; product middle byte
040A1D 7A          0038*      ld a,d ; carry
040A1E 08          0039*      ex af,af' ; save carry, restore multiplier
040A1F             0040*  ; upper byte
040A1F 22 3A 0A 04 0041*      ld (@scratch),hl ; 7 cycles
040A23 5F          0042*      ld e,a
040A24 3A 3C 0A 04 0043*      ld a,(@scratch+2)
040A28 57          0044*      ld d,a
040A29 ED 5C       0045*      mlt de
040A2B 08          0046*      ex af,af' ; restore carry
040A2C 8B          0047*      adc a,e ; add carry
040A2D 32 3C 0A 04 0048*      ld (@scratch+2),a ; 5 cycles
040A31 2A 3A 0A 04 0049*      ld hl,(@scratch) ; 7 cycles
040A35             0050*  ; highest byte
040A35 3E 00       0051*      ld a,0 ; preserve carry flag
040A37 8A          0052*      adc a,d ; product highest byte
040A38 D1          0053*      pop de ; restore de
040A39 C9          0054*      ret
040A3A             0055*  @scratch: ds 3
040A3D             0056*  
040A3D 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
040A43             0058*  
040A43             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A43             0060*  ; operation: UHL * UDE --> mul24out
040A43             0061*  mul24:
040A43 DD E5       0062*      push ix ; preserve
040A45             0063*  ; point to output buffer and clear it
040A45 DD 21 3D 0A 0064*      ld ix,mul24out
       04          
040A4A C5          0065*      push bc
040A4B 01 00 00 00 0066*      ld bc,0
040A4F DD 0F 00    0067*      ld (ix),bc
040A52 DD 0F 03    0068*      ld (ix+3),bc
040A55 C1          0069*      pop bc
040A56             0070*  ; STEP 1: UHL * E
040A56 7B          0071*      ld a,e
040A57 E5          0072*      push hl
040A58 CD 0D 0A 04 0073*      call mul24x8
040A5C DD 2F 00    0074*      ld (ix+0),hl
040A5F DD 77 03    0075*      ld (ix+3),a
040A62             0076*  ; STEP 2: UHL * D
040A62 E1          0077*      pop hl
040A63 E5          0078*      push hl
040A64 7A          0079*      ld a,d
040A65 CD 0D 0A 04 0080*      call mul24x8
040A69 CD 82 0A 04 0081*      call @accumulate
040A6D             0082*  ; STEP 3: UHL * DEU
040A6D E1          0083*      pop hl
040A6E ED 53 B2 0A 0084*      ld (@de),de
       04          
040A73 3A B4 0A 04 0085*      ld a,(@de+2)
040A77 CD 0D 0A 04 0086*      call mul24x8
040A7B CD 82 0A 04 0087*      call @accumulate
040A7F             0088*  ; all done
040A7F DD E1       0089*      pop ix ; restore
040A81 C9          0090*      ret
040A82             0091*  @accumulate:
040A82 DD 23       0092*      inc ix
040A84             0093*  ; highest byte of product to carry
040A84 DD 77 03    0094*      ld (ix+3),a
040A87             0095*  ; low byte of product
040A87 7D          0096*      ld a,l
040A88 DD 86 00    0097*      add a,(ix+0)
040A8B DD 77 00    0098*      ld (ix+0),a
040A8E             0099*  ; high byte of product
040A8E 7C          0100*      ld a,h
040A8F DD 8E 01    0101*      adc a,(ix+1)
040A92 DD 77 01    0102*      ld (ix+1),a
040A95             0103*  ; uppper byte of product
040A95 22 AF 0A 04 0104*      ld (@hl),hl
040A99 3A B1 0A 04 0105*      ld a,(@hl+2)
040A9D DD 8E 02    0106*      adc a,(ix+2)
040AA0 DD 77 02    0107*      ld (ix+2),a
040AA3             0108*  ; carry
040AA3 3E 00       0109*      ld a,0 ; preserve flags
040AA5 DD 8E 03    0110*      adc a,(ix+3)
040AA8 DD 77 03    0111*      ld (ix+3),a
040AAB C9          0112*      ret
040AAC             0113*  
040AAC 00 00 00    0114*  @ix: dl 0
040AAF 00 00 00    0115*  @hl: dl 0
040AB2 00 00 00    0116*  @de: dl 0
040AB5             0117*  
040AB5             0118*  ; UHL * UDE --> UHL (unsigned)
040AB5             0119*  umul24:
040AB5 CD 43 0A 04 0120*      call mul24
040AB9 2A 3D 0A 04 0121*      ld hl,(mul24out)
040ABD C9          0122*      ret
040ABE             0123*  
040ABE             0124*  ; UH.L = UH.L*UD.E (unsigned)
040ABE             0125*  umul168:
040ABE CD 43 0A 04 0126*      call mul24
040AC2 2A 3E 0A 04 0127*      ld hl,(mul24out+1)
040AC6 C9          0128*      ret
040AC7             0129*  
040AC7             0130*  ; UH.L * UD.E --> UH.L (signed)
040AC7             0131*  smul168:
040AC7             0132*  ; make everything positive and store sign flags
040AC7 CD 94 06 04 0133*      call hlu_abs
040ACB F5          0134*      push af
040ACC EB          0135*      ex de,hl
040ACD CD 94 06 04 0136*      call hlu_abs
040AD1 EB          0137*      ex de,hl
040AD2 F5          0138*      push af
040AD3             0139*  ; do the division
040AD3 CD BE 0A 04 0140*      call umul168 ; hl = product
040AD7             0141*  ; adjust sign of result
040AD7 F1          0142*      pop af ; sign de
040AD8 FA E3 0A 04 0143*      jp m,@de_neg
040ADC F1          0144*      pop af ; sign hl
040ADD F0          0145*      ret p ; both positive, nothing to do
040ADE             0146*  @hl_neg:
040ADE CD A4 06 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
040AE2 C9          0148*      ret
040AE3             0149*  @de_neg:
040AE3 F1          0150*      pop af
040AE4 F8          0151*      ret m ; both negative, nothing to do
040AE5 CD A4 06 04 0152*      call neg_hlu ; result is negative
040AE9 C9          0153*      ret
040AEA             0154*  
040AEA             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040AEA             0156*  ; perform unsigned division of 16.8 fixed place values
040AEA             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040AEA             0158*  udiv168:
040AEA             0159*  ; back up divisor
040AEA ED 53 21 0B 0160*      ld (@ude),de
       04          
040AEF             0161*  ; get the 16-bit integer part of the quotient
040AEF CD 52 0B 04 0162*      call udiv24 ; de = quotient, hl = remainder
040AF3             0163*  ; load quotient to upper three bytes of output
040AF3 ED 53 28 0B 0164*      ld (div168_out+1),de
       04          
040AF8             0165*  @div256:
040AF8             0166*  ; multiply remainder by 256
040AF8             0167*      hlu_mul256
040AF8 29          0001*M     add hl,hl ; * 2
040AF9 29          0002*M     add hl,hl ; * 4
040AFA 29          0003*M     add hl,hl ; * 8
040AFB 29          0004*M     add hl,hl ; * 16
040AFC 29          0005*M     add hl,hl ; * 32
040AFD 29          0006*M     add hl,hl ; * 64
040AFE 29          0007*M     add hl,hl ; * 128
040AFF 29          0008*M     add hl,hl ; * 256
040B00             0168*  ; skip fractional computation if remainder is zero
040B00             0169*      sign_hlu
040B00 19          0001*M     add hl,de
040B01 B7          0002*M     or a
040B02 ED 52       0003*M     sbc hl,de
040B04 20 03       0170*      jr nz,@div_frac
040B06 AF          0171*      xor a
040B07 18 0A       0172*      jr @write_frac
040B09             0173*  ; now divide the shifted remainder by the divisor
040B09             0174*  @div_frac:
040B09 ED 5B 21 0B 0175*      ld de,(@ude) ; get back divisor
       04          
040B0E CD 52 0B 04 0176*      call udiv24 ; de = quotient, hl = remainder
040B12             0177*  ; load low byte of quotient to low byte of output
040B12 7B          0178*      ld a,e
040B13             0179*  @write_frac:
040B13 32 27 0B 04 0180*      ld (div168_out),a
040B17             0181*  ; load de with return value
040B17 ED 5B 27 0B 0182*      ld de,(div168_out)
       04          
040B1C             0183*  ; load a with any overflow
040B1C 3A 2A 0B 04 0184*      ld a,(div168_out+3)
040B20 C9          0185*      ret ; ud.e is the 16.8 result
040B21             0186*  @ude: ds 6
040B27             0187*  div168_out: ds 4 ; the extra byte is for overflow
040B2B             0188*  
040B2B             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B2B             0190*  ; perform signed division of 16.8 fixed place values
040B2B             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B2B             0192*  sdiv168:
040B2B             0193*  ; make everything positive and store sign flags
040B2B CD 94 06 04 0194*      call hlu_abs
040B2F F5          0195*      push af
040B30 EB          0196*      ex de,hl
040B31 CD 94 06 04 0197*      call hlu_abs
040B35 EB          0198*      ex de,hl
040B36 F5          0199*      push af
040B37             0200*  ; do the division
040B37 CD EA 0A 04 0201*      call udiv168 ; de = quotient, hl = remainder
040B3B             0202*  ; adjust sign of result
040B3B F1          0203*      pop af ; sign de
040B3C FA 49 0B 04 0204*      jp m,@de_neg
040B40 F1          0205*      pop af ; sign hl
040B41 F0          0206*      ret p ; both positive, nothing to do
040B42             0207*  @hl_neg:
040B42 EB          0208*      ex de,hl ; hl = quotient, de = remainder
040B43 CD A4 06 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
040B47 EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
040B48 C9          0211*      ret
040B49             0212*  @de_neg:
040B49 F1          0213*      pop af
040B4A F8          0214*      ret m ; both negative, nothing to do
040B4B EB          0215*      ex de,hl ; hl = quotient, de = remainder
040B4C CD A4 06 04 0216*      call neg_hlu ; result is negative
040B50 EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
040B51 C9          0218*      ret
040B52             0219*  
040B52             0220*  ;------------------------------------------------------------------------
040B52             0221*  ;  arith24.asm
040B52             0222*  ;  24-bit ez80 arithmetic routines
040B52             0223*  ;  Copyright (c) Shawn Sijnstra 2024
040B52             0224*  ;  MIT license
040B52             0225*  ;
040B52             0226*  ;  This library was created as a tool to help make ez80
040B52             0227*  ;  24-bit native assembly routines for simple mathematical problems
040B52             0228*  ;  more widely available.
040B52             0229*  ;
040B52             0230*  ;------------------------------------------------------------------------
040B52             0231*  ;
040B52             0232*  ;------------------------------------------------------------------------
040B52             0233*  ; udiv24
040B52             0234*  ; Unsigned 24-bit division
040B52             0235*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040B52             0236*  ;
040B52             0237*  ; Uses AF BC DE HL
040B52             0238*  ; Uses Restoring Division algorithm
040B52             0239*  ;------------------------------------------------------------------------
040B52             0240*  
040B52             0241*  udiv24:
040B52 E5          0242*      push hl
040B53 C1          0243*      pop bc ;move dividend to BCU
040B54 21 00 00 00 0244*      ld hl,0 ;result
040B58 A7          0245*      and a
040B59 ED 52       0246*      sbc hl,de ;test for div by 0
040B5B C8          0247*      ret z ;it's zero, carry flag is clear
040B5C 19          0248*      add hl,de ;HL is 0 again
040B5D 3E 18       0249*      ld a,24 ;number of loops through.
040B5F             0250*  udiv1:
040B5F C5          0251*      push bc ;complicated way of doing this because of lack of access to top bits
040B60 E3          0252*      ex (sp),hl
040B61 37          0253*      scf
040B62 ED 6A       0254*      adc hl,hl
040B64 E3          0255*      ex (sp),hl
040B65 C1          0256*      pop bc ;we now have bc = (bc * 2) + 1
040B66             0257*  
040B66 ED 6A       0258*      adc hl,hl
040B68 A7          0259*      and a ;is this the bug
040B69 ED 52       0260*      sbc hl,de
040B6B 30 02       0261*      jr nc,udiv2
040B6D 19          0262*      add hl,de
040B6E             0263*  ;	dec	c
040B6E 0B          0264*      dec bc
040B6F             0265*  udiv2:
040B6F 3D          0266*      dec a
040B70 20 ED       0267*      jr nz,udiv1
040B72 37          0268*      scf ;flag used for div0 error
040B73 C5          0269*      push bc
040B74 D1          0270*      pop de ;remainder
040B75 C9          0271*      ret
040B76             0272*  
040B76             0273*  ;------------------------------------------------------------------------
040B76             0274*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
040B76             0275*  ;------------------------------------------------------------------------
040B76             0276*  
040B76             0277*  
040B76             0278*      ; include "trig24fast.inc"
040B76             0279*  
040B76             0280*  
040B76             0281*  ; convert signed angles from a 360 to 256 degree circle
040B76             0282*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B76             0283*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B76             0284*  ; destroys: TODO
040B76             0285*  deg_360_to_256:
040B76 D5          0286*      push de ; preserve de
040B77             0287*  ; make angle positive and store sign flag
040B77 CD 94 06 04 0288*      call hlu_abs
040B7B F5          0289*      push af
040B7C             0290*  ; multiply by coversion factor of 256/360
040B7C 11 B6 00 00 0291*      ld de,0x0000B6 ; 0.711
040B80 CD BE 0A 04 0292*      call umul168 ; uh.l = uh.l * 0.711
040B84             0293*  ; restore sign flag and adjust output accordingly
040B84 F1          0294*      pop af
040B85 F2 8D 0B 04 0295*      jp p,@pos ; positive number
040B89 CD A4 06 04 0296*      call neg_hlu
040B8D             0297*  @pos:
040B8D             0298*  ; restore de and return uh.l as the result
040B8D D1          0299*      pop de
040B8E C9          0300*      ret
040B8F             0301*  
040B8F             0302*  ; convert signed angles from a 256 to 360 degree circle
040B8F             0303*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040B8F             0304*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040B8F             0305*  ; destroys: TODO
040B8F             0306*  deg_256_to_360:
040B8F D5          0307*      push de ; preserve de
040B90             0308*  ; make angle positive and store sign flag
040B90 CD 94 06 04 0309*      call hlu_abs
040B94 F5          0310*      push af
040B95             0311*  ; multiply by coversion factor of 360/256
040B95 11 68 01 00 0312*      ld de,0x000168 ; 1.406
040B99 CD BE 0A 04 0313*      call umul168 ; uh.l = uh.l * 1.406
040B9D             0314*  ; restore sign flag and adjust output accordingly
040B9D F1          0315*      pop af
040B9E F2 A6 0B 04 0316*      jp p,@pos ; positive number
040BA2 CD A4 06 04 0317*      call neg_hlu
040BA6             0318*  @pos:
040BA6             0319*  ; restore de and return uh.l as the result
040BA6 D1          0320*      pop de
040BA7 C9          0321*      ret
040BA8             0322*  
040BA8             0323*  ; fixed 16.8 routine
040BA8             0324*  ; cos(uh.l) --> uh.l
040BA8             0325*  ; destroys: f, hl
040BA8             0326*  cos168:
040BA8 D5          0327*      push de ; preserve de
040BA9             0328*  ; for cos we simply increment the angle by 90 degrees
040BA9             0329*  ; or 0x004000 in 16.8 degrees256
040BA9             0330*  ; which makes it a sin problem
040BA9 11 00 40 00 0331*      ld de,0x004000
040BAD 19          0332*      add hl,de ; modulo 256 happens below
040BAE D1          0333*      pop de ; restore de
040BAF             0334*  ; fall through to sin168
040BAF             0335*  
040BAF             0336*  ; ---------------------
040BAF             0337*  ; fixed 16.8 routine
040BAF             0338*  ; sin(uh.l) --> uh.l
040BAF             0339*  ; destroys: f, hl
040BAF             0340*  sin168:
040BAF D5          0341*      push de
040BB0             0342*  ; handle negative angles appropriately
040BB0 CD 94 06 04 0343*      call hlu_abs
040BB4 F2 BD 0B 04 0344*      jp p,@F
040BB8 11 00 00 FF 0345*      ld de,-256*256
040BBC 19          0346*      add hl,de
040BBD             0347*  @@:
040BBD 2E 03       0348*      ld l,3 ; multiply by 3 to get our lookup index
040BBF ED 6C       0349*      mlt hl
040BC1 11 0D 0E 04 0350*      ld de,sin_lut_168 ; grab the lut address
040BC5 19          0351*      add hl,de ; bump hl by the index
040BC6 ED 27       0352*      ld hl,(hl) ; don't try this on a z80!
040BC8 D1          0353*      pop de
040BC9 C9          0354*      ret
040BCA             0355*  
040BCA             0356*  ; 16.8 fixed inputs / outputs
040BCA             0357*  ; takes: uh.l as angle in degrees 256
040BCA             0358*  ;        ud.e as radius
040BCA             0359*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BCA             0360*  ;        displacements from origin (0,0)
040BCA             0361*  ; destroys: everything except indexes
040BCA             0362*  polar_to_cartesian:
040BCA             0363*  ; back up input parameters
040BCA 22 F9 0B 04 0364*      ld (@angle), hl
040BCE ED 53 FC 0B 0365*      ld (@radius), de
       04          
040BD3             0366*  ; compute dx = sin(uh.l) * ud.e
040BD3 CD AF 0B 04 0367*      call sin168 ; uh.l = sin(uh.l)
040BD7 ED 5B FC 0B 0368*      ld de,(@radius)
       04          
040BDC CD C7 0A 04 0369*      call smul168 ; uh.l = dx
040BE0 E5          0370*      push hl
040BE1             0371*  ; compute dy = -cos(uh.l) * ud.e
040BE1 2A F9 0B 04 0372*      ld hl,(@angle)
040BE5 CD A8 0B 04 0373*      call cos168 ; uh.l = cos(uh.l)
040BE9 ED 5B FC 0B 0374*      ld de,(@radius)
       04          
040BEE CD C7 0A 04 0375*      call smul168 ; uh.l = dy
040BF2 CD A4 06 04 0376*      call neg_hlu ; invert dy for screen coords convention
040BF6 EB          0377*      ex de,hl ; de = dy for output
040BF7 C1          0378*      pop bc ; bc = dx for output
040BF8             0379*  ; and out
040BF8 C9          0380*      ret
040BF9             0381*  @angle: ds 3
040BFC             0382*  @radius: ds 3
040BFF             0383*  
040BFF             0384*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BFF             0385*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BFF             0386*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BFF             0387*  ;         also populates scratch locations dx168 and dy168
040BFF             0388*  ; destroys: a,hl,bc,de
040BFF             0389*  dxy168:
040BFF             0390*  ; compute dx = x1-x0
040BFF AF          0391*      xor a ; clear carry
040C00 DD E5       0392*      push ix ; move ix to hl via the stack
040C02 E1          0393*      pop hl ; hl = x1
040C03 ED 42       0394*      sbc hl,bc ; hl = dx
040C05 22 1A 0C 04 0395*      ld (dx168),hl ; dx to scratch
040C09             0396*  ; compute dy = y1-y0
040C09 AF          0397*      xor a ; clear carry
040C0A FD E5       0398*      push iy ; move iy to hl via the stack
040C0C E1          0399*      pop hl ; hl = y1
040C0D ED 52       0400*      sbc hl,de ; hl = dy
040C0F 22 20 0C 04 0401*      ld (dy168),hl ; dy to scratch
040C13             0402*  ; populate output registers and return
040C13 EB          0403*      ex de,hl ; ud.e = dy
040C14 ED 4B 1A 0C 0404*      ld bc,(dx168) ; ub.c = dx
       04          
040C19 C9          0405*      ret
040C1A 00 00 00 00 0406*  dx168: blkb 6,0
       00 00       
040C20 00 00 00 00 0407*  dy168: blkb 6,0
       00 00       
040C26             0408*  
040C26             0409*  ; compute the euclidian distance between two cartesian coordinates
040C26             0410*  ; using the formula d = sqrt(dx^2+dy^2)
040C26             0411*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C26             0412*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C26             0413*  ; output; uh.l is the 16.8 fixed format distance
040C26             0414*  ;         also populates scratch locations dx168 and dy168
040C26             0415*  ; destroys: a,hl,bc,de
040C26             0416*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C26             0417*  ;       thus the result will always be an integer, albeit in 16.8 format
040C26             0418*  distance168:
040C26 CD FF 0B 04 0419*      call dxy168 ; ub.c = dx, ud.e = dy
040C2A             0420*  ; compute dy^2
040C2A EB          0421*      ex de,hl
040C2B CD 94 06 04 0422*      call hlu_abs
040C2F CD FB 06 04 0423*      call hlu_udiv256 ; make integer to avoid overflow
040C33 E5          0424*      push hl
040C34 D1          0425*      pop de
040C35 CD B5 0A 04 0426*      call umul24 ; hl = dy^2
040C39 E5          0427*      push hl ; save dy^2
040C3A             0428*  ; compute dx^2
040C3A 2A 1A 0C 04 0429*      ld hl,(dx168)
040C3E CD 94 06 04 0430*      call hlu_abs
040C42 CD FB 06 04 0431*      call hlu_udiv256 ; make integer to avoid overflow
040C46 E5          0432*      push hl
040C47 D1          0433*      pop de
040C48 CD B5 0A 04 0434*      call umul24 ; hl = dx^2
040C4C             0435*  ; add dx^2 and dy^2
040C4C D1          0436*      pop de ; de = dy^2 (was hl)
040C4D 19          0437*      add hl,de ; hl = dx^2 + dy^2
040C4E             0438*  ; compute the square root
040C4E CD 27 0D 04 0439*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C52 EB          0440*      ex de,hl ; hl = distance
040C53             0441*      hlu_mul256 ; convert back to 16.8 fixed
040C53 29          0001*M     add hl,hl ; * 2
040C54 29          0002*M     add hl,hl ; * 4
040C55 29          0003*M     add hl,hl ; * 8
040C56 29          0004*M     add hl,hl ; * 16
040C57 29          0005*M     add hl,hl ; * 32
040C58 29          0006*M     add hl,hl ; * 64
040C59 29          0007*M     add hl,hl ; * 128
040C5A 29          0008*M     add hl,hl ; * 256
040C5B C9          0442*      ret
040C5C             0443*  
040C5C             0444*  ; atan2_(ub.c,ud.e) --> uh.l
040C5C             0445*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C5C             0446*  ;   whether inputs are integers or fractional doesn't matter
040C5C             0447*  ;   so long as the sign bit of the upper byte is correct
040C5C             0448*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C5C             0449*  ; angles are COMPASS HEADINGS based on
040C5C             0450*  ; screen coordinate conventions,where the y axis is flipped
040C5C             0451*  ; #E0 224      0       32 #20
040C5C             0452*  ;        -x,-y | +x,-y
040C5C             0453*  ; #C0 192------+------ 64 #40
040C5C             0454*  ;        -x,+y | +x,+y
040C5C             0455*  ; #A0 160   128 #80   96 #60
040C5C             0456*  atan2_168fast:
040C5C             0457*  ; get signs and make everything positive
040C5C             0458*  ; get abs(x) and store its original sign
040C5C C5          0459*      push bc
040C5D E1          0460*      pop hl
040C5E CD 94 06 04 0461*      call hlu_abs ; if x was negative this also sets the sign flag
040C62 E5          0462*      push hl ; store abs(x)
040C63 C1          0463*      pop bc ; bc = abs(x)
040C64 F5          0464*      push af ; store sign of x
040C65             0465*  ; get abs(y) and store its original sign
040C65 EB          0466*      ex de,hl ; hl = y
040C66 CD 94 06 04 0467*      call hlu_abs ; if y was negative this also sets the sign flag
040C6A EB          0468*      ex de,hl ; de = abs(y)
040C6B F5          0469*      push af ; store sign of y
040C6C             0470*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C6C             0471*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C6C AF          0472*      xor a ; clear the carry flag
040C6D D5          0473*      push de
040C6E E1          0474*      pop hl
040C6F ED 42       0475*      sbc hl,bc
040C71 F5          0476*      push af ; save sign of de - bc
040C72 F2 7B 0C 04 0477*      jp p,@1 ; bc <= de, so we skip ahead
040C76             0478*  ; otherwise we swap bc and de
040C76 C5          0479*      push bc
040C77 E1          0480*      pop hl
040C78 EB          0481*      ex de,hl
040C79 E5          0482*      push hl
040C7A C1          0483*      pop bc
040C7B             0484*  @1:
040C7B             0485*  ; now we're ready to snag our preliminary result
040C7B C5          0486*      push bc
040C7C E1          0487*      pop hl
040C7D CD EB 0C 04 0488*      call atan_168fast ; uh.l comes back with prelim result
040C81             0489*  ; now we adjust uh.l based on sign of de - bc
040C81 F1          0490*      pop af
040C82 F2 8E 0C 04 0491*      jp p,@2 ; bc <= de,so we skip ahead
040C86 EB          0492*      ex de,hl
040C87 21 00 40 00 0493*      ld hl,64*256 ; subtract from 64 (90) degrees
040C8B AF          0494*      xor a ; clear the carry flag
040C8C ED 52       0495*      sbc hl,de
040C8E             0496*  @2:
040C8E             0497*  ; adjust the result based on quadrant
040C8E             0498*  ; #E0 224      0       32 #20
040C8E             0499*  ;        -x,-y | +x,-y
040C8E             0500*  ; #C0 192------+------ 64 #40
040C8E             0501*  ;        -x,+y | +x,+y
040C8E             0502*  ; #A0 160   128 #80   96 #60
040C8E F1          0503*      pop af ; sign of y
040C8F CA CC 0C 04 0504*      jp z,@y_zero
040C93 F2 AC 0C 04 0505*      jp p,@y_pos
040C97             0506*  ; y neg,check x
040C97 F1          0507*      pop af ; sign of x
040C98 CA A6 0C 04 0508*      jp z,@y_neg_x_zero
040C9C F2 AB 0C 04 0509*      jp p,@y_neg_x_pos
040CA0             0510*  ; y neg,x neg
040CA0             0511*  ; angle is 128 to 256 (270 to 360)
040CA0             0512*  ; negating the intermediate does the trick
040CA0 CD A4 06 04 0513*      call neg_hlu
040CA4 18 31       0514*      jr @zero_hlu
040CA6             0515*  
040CA6             0516*  @y_neg_x_zero:
040CA6             0517*  ; y neg,x zero
040CA6             0518*  ; angle is 0
040CA6 21 00 00 00 0519*      ld hl,0
040CAA C9          0520*      ret
040CAB             0521*  @y_neg_x_pos:
040CAB             0522*  ; y neg,x pos
040CAB             0523*  ; angle is 0 to 64 (0 to 90)
040CAB             0524*  ; so we're good
040CAB C9          0525*      ret
040CAC             0526*  
040CAC             0527*  @y_pos:
040CAC F1          0528*      pop af ; sign of x
040CAD CA BC 0C 04 0529*      jp z,@y_pos_x_zero
040CB1 F2 C1 0C 04 0530*      jp p,@y_pos_x_pos
040CB5             0531*  ; y pos,x neg
040CB5             0532*  ; angle is 128 to 192 (180-270)
040CB5             0533*  ; so we add 128 to intermediate
040CB5 11 00 80 00 0534*      ld de,128*256
040CB9 19          0535*      add hl,de
040CBA 18 1B       0536*      jr @zero_hlu
040CBC             0537*  @y_pos_x_zero:
040CBC             0538*  ; y pos,x zero
040CBC             0539*  ; angle is 128 (180)
040CBC 21 00 80 00 0540*      ld hl,128*256
040CC0 C9          0541*      ret
040CC1             0542*  @y_pos_x_pos:
040CC1             0543*  ; y pos,x pos
040CC1             0544*  ; angle is 64 to 128 (90 to 180)
040CC1             0545*  ; neg the intermediate and add 180 degrees
040CC1 CD A4 06 04 0546*      call neg_hlu
040CC5 11 00 80 00 0547*      ld de,128*256
040CC9 19          0548*      add hl,de
040CCA 18 0B       0549*      jr @zero_hlu
040CCC             0550*  
040CCC             0551*  @y_zero:
040CCC F1          0552*      pop af ; sign of x
040CCD FA D2 0C 04 0553*      jp m,@y_zero_x_neg
040CD1             0554*  ; y zero,x pos
040CD1             0555*  ; angle is 64 (90),nothing to do
040CD1 C9          0556*      ret
040CD2             0557*  @y_zero_x_neg:
040CD2             0558*  ; y zero ,x neg
040CD2             0559*  ; angle is 192 (270)
040CD2 21 00 C0 00 0560*      ld hl,192*256
040CD6 C9          0561*      ret
040CD7             0562*  @zero_hlu:
040CD7 AF          0563*      xor a
040CD8 22 E5 0C 04 0564*      ld (@scratch),hl
040CDC 32 E7 0C 04 0565*      ld (@scratch+2),a
040CE0 2A E5 0C 04 0566*      ld hl,(@scratch)
040CE4 C9          0567*      ret
040CE5             0568*  @scratch: ds 6
040CEB             0569*  
040CEB             0570*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CEB             0571*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040CEB             0572*  ; destroys: a,hl,bc,de
040CEB             0573*  ; note: only works for angles from 0 to 32 (45) degrees
040CEB             0574*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040CEB             0575*  atan_168fast:
040CEB             0576*  ; because we use compass headings instead of geometric angles
040CEB             0577*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040CEB             0578*  ; we can do faster unsigned division here because we know dx and dy are positive
040CEB CD EA 0A 04 0579*      call udiv168 ; ud.e = dx/dy
040CEF EB          0580*      ex de,hl ; uh.l = dx/dy
040CF0             0581*  ; test uh.l for 0
040CF0 19          0582*      add hl,de
040CF1 B7          0583*      or a
040CF2 ED 52       0584*      sbc hl,de
040CF4 28 22       0585*      jr z,@is_zero
040CF6             0586*  ; test uh.l for 1
040CF6 AF          0587*      xor a ; clear carry
040CF7 EB          0588*      ex de,hl
040CF8 21 00 01 00 0589*      ld hl,1*256 ; 1 in 16.8 fixed format
040CFC ED 52       0590*      sbc hl,de
040CFE 28 13       0591*      jr z,@is_45
040D00 EB          0592*      ex de,hl
040D01             0593*  ; no special cases so we move on
040D01             0594*  ; l contains the fractional portion of tan(uh.l)
040D01             0595*  ; we multiply it by three to get our lookup table index
040D01 26 03       0596*      ld h,3
040D03 ED 6C       0597*      mlt hl ; index into lut
040D05 11 00 00 00 0598*      ld de,0 ; clear deu
040D09 54          0599*      ld d,h ; copy hl to de
040D0A 5D          0600*      ld e,l ; de contains our index
040D0B 21 10 11 04 0601*      ld hl,atan_lut_168 ; grab the lut address
040D0F 19          0602*      add hl,de ; bump hl by the index
040D10 ED 27       0603*      ld hl,(hl) ; don't try this on a z80!
040D12 C9          0604*      ret ; and out
040D13             0605*  @is_45:
040D13 21 00 40 00 0606*      ld hl,64*256
040D17 C9          0607*      ret
040D18             0608*  ; for the case tan(0)
040D18             0609*  @is_zero:
040D18 21 00 00 00 0610*      ld hl,0*256
040D1C C9          0611*      ret
040D1D             0612*  
040D1D             0613*  ; Expects  ADL mode
040D1D             0614*  ; Inputs:  UH.L
040D1D             0615*  ; Outputs: UH.L is the 16.8 square root
040D1D             0616*  ;          UDE is the integer difference inputHL-DE^2
040D1D             0617*  sqrt168:
040D1D CD 27 0D 04 0618*      call sqrt24
040D21 EB          0619*      ex de,hl
040D22 29          0620*      add hl,hl
040D23 29          0621*      add hl,hl
040D24 29          0622*      add hl,hl
040D25 29          0623*      add hl,hl
040D26 C9          0624*      ret
040D27             0625*  
040D27             0626*  ; credit: xeda112358
040D27             0627*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D27             0628*  sqrt24:
040D27             0629*  ; Expects ADL mode
040D27             0630*  ; Inputs: HL
040D27             0631*  ; Outputs: DE is the integer square root
040D27             0632*  ;  HL is the difference inputHL-DE^2
040D27             0633*  ;  c flag reset
040D27 01 00 00 00 0634*      ld bc,0 ; clear bcu
040D2B 11 00 00 00 0635*      ld de,0 ; clear deu
040D2F AF          0636*      xor a
040D30 45          0637*      ld b,l
040D31 C5          0638*      push bc
040D32 47          0639*      ld b,a
040D33 6F          0640*      ld l,a
040D34             0641*  ; Iteration 1
040D34 29          0642*      add hl,hl
040D35 CB 11       0643*      rl c
040D37 29          0644*      add hl,hl
040D38 CB 11       0645*      rl c
040D3A 91          0646*      sub c
040D3B 30 04       0647*      jr nc,$+6
040D3D 1C          0648*      inc e
040D3E 1C          0649*      inc e
040D3F 2F          0650*      cpl
040D40 4F          0651*      ld c,a
040D41             0652*  ; Iteration 2
040D41 29          0653*      add hl,hl
040D42 CB 11       0654*      rl c
040D44 29          0655*      add hl,hl
040D45 CB 11       0656*      rl c
040D47 CB 13       0657*      rl e
040D49 7B          0658*      ld a,e
040D4A 91          0659*      sub c
040D4B 30 04       0660*      jr nc,$+6
040D4D 1C          0661*      inc e
040D4E 1C          0662*      inc e
040D4F 2F          0663*      cpl
040D50 4F          0664*      ld c,a
040D51             0665*  ; Iteration 3
040D51 29          0666*      add hl,hl
040D52 CB 11       0667*      rl c
040D54 29          0668*      add hl,hl
040D55 CB 11       0669*      rl c
040D57 CB 13       0670*      rl e
040D59 7B          0671*      ld a,e
040D5A 91          0672*      sub c
040D5B 30 04       0673*      jr nc,$+6
040D5D 1C          0674*      inc e
040D5E 1C          0675*      inc e
040D5F 2F          0676*      cpl
040D60 4F          0677*      ld c,a
040D61             0678*  ; Iteration 4
040D61 29          0679*      add hl,hl
040D62 CB 11       0680*      rl c
040D64 29          0681*      add hl,hl
040D65 CB 11       0682*      rl c
040D67 CB 13       0683*      rl e
040D69 7B          0684*      ld a,e
040D6A 91          0685*      sub c
040D6B 30 04       0686*      jr nc,$+6
040D6D 1C          0687*      inc e
040D6E 1C          0688*      inc e
040D6F 2F          0689*      cpl
040D70 4F          0690*      ld c,a
040D71             0691*  ; Iteration 5
040D71 29          0692*      add hl,hl
040D72 CB 11       0693*      rl c
040D74 29          0694*      add hl,hl
040D75 CB 11       0695*      rl c
040D77 CB 13       0696*      rl e
040D79 7B          0697*      ld a,e
040D7A 91          0698*      sub c
040D7B 30 04       0699*      jr nc,$+6
040D7D 1C          0700*      inc e
040D7E 1C          0701*      inc e
040D7F 2F          0702*      cpl
040D80 4F          0703*      ld c,a
040D81             0704*  ; Iteration 6
040D81 29          0705*      add hl,hl
040D82 CB 11       0706*      rl c
040D84 29          0707*      add hl,hl
040D85 CB 11       0708*      rl c
040D87 CB 13       0709*      rl e
040D89 7B          0710*      ld a,e
040D8A 91          0711*      sub c
040D8B 30 04       0712*      jr nc,$+6
040D8D 1C          0713*      inc e
040D8E 1C          0714*      inc e
040D8F 2F          0715*      cpl
040D90 4F          0716*      ld c,a
040D91             0717*  ; Iteration 7
040D91 29          0718*      add hl,hl
040D92 CB 11       0719*      rl c
040D94 29          0720*      add hl,hl
040D95 CB 11       0721*      rl c
040D97 CB 10       0722*      rl b
040D99 EB          0723*      ex de,hl
040D9A 29          0724*      add hl,hl
040D9B E5          0725*      push hl
040D9C ED 42       0726*      sbc hl,bc
040D9E 30 06       0727*      jr nc,$+8
040DA0 7C          0728*      ld a,h
040DA1 2F          0729*      cpl
040DA2 47          0730*      ld b,a
040DA3 7D          0731*      ld a,l
040DA4 2F          0732*      cpl
040DA5 4F          0733*      ld c,a
040DA6 E1          0734*      pop hl
040DA7 30 02       0735*      jr nc,$+4
040DA9 23          0736*      inc hl
040DAA 23          0737*      inc hl
040DAB EB          0738*      ex de,hl
040DAC             0739*  ; Iteration 8
040DAC 29          0740*      add hl,hl
040DAD 69          0741*      ld l,c
040DAE 60          0742*      ld h,b
040DAF ED 6A       0743*      adc hl,hl
040DB1 ED 6A       0744*      adc hl,hl
040DB3 EB          0745*      ex de,hl
040DB4 29          0746*      add hl,hl
040DB5 ED 52       0747*      sbc hl,de
040DB7 19          0748*      add hl,de
040DB8 EB          0749*      ex de,hl
040DB9 30 04       0750*      jr nc,$+6
040DBB ED 52       0751*      sbc hl,de
040DBD 13          0752*      inc de
040DBE 13          0753*      inc de
040DBF             0754*  ; Iteration 9
040DBF F1          0755*      pop af
040DC0 17          0756*      rla
040DC1 ED 6A       0757*      adc hl,hl
040DC3 17          0758*      rla
040DC4 ED 6A       0759*      adc hl,hl
040DC6 EB          0760*      ex de,hl
040DC7 29          0761*      add hl,hl
040DC8 ED 52       0762*      sbc hl,de
040DCA 19          0763*      add hl,de
040DCB EB          0764*      ex de,hl
040DCC 30 04       0765*      jr nc,$+6
040DCE ED 52       0766*      sbc hl,de
040DD0 13          0767*      inc de
040DD1 13          0768*      inc de
040DD2             0769*  ; Iteration 10
040DD2 17          0770*      rla
040DD3 ED 6A       0771*      adc hl,hl
040DD5 17          0772*      rla
040DD6 ED 6A       0773*      adc hl,hl
040DD8 EB          0774*      ex de,hl
040DD9 29          0775*      add hl,hl
040DDA ED 52       0776*      sbc hl,de
040DDC 19          0777*      add hl,de
040DDD EB          0778*      ex de,hl
040DDE 30 04       0779*      jr nc,$+6
040DE0 ED 52       0780*      sbc hl,de
040DE2 13          0781*      inc de
040DE3 13          0782*      inc de
040DE4             0783*  ; Iteration 11
040DE4 17          0784*      rla
040DE5 ED 6A       0785*      adc hl,hl
040DE7 17          0786*      rla
040DE8 ED 6A       0787*      adc hl,hl
040DEA EB          0788*      ex de,hl
040DEB 29          0789*      add hl,hl
040DEC ED 52       0790*      sbc hl,de
040DEE 19          0791*      add hl,de
040DEF EB          0792*      ex de,hl
040DF0 30 04       0793*      jr nc,$+6
040DF2 ED 52       0794*      sbc hl,de
040DF4 13          0795*      inc de
040DF5 13          0796*      inc de
040DF6             0797*  ; Iteration 12
040DF6 17          0798*      rla
040DF7 ED 6A       0799*      adc hl,hl
040DF9 17          0800*      rla
040DFA ED 6A       0801*      adc hl,hl
040DFC EB          0802*      ex de,hl
040DFD 29          0803*      add hl,hl
040DFE ED 52       0804*      sbc hl,de
040E00 19          0805*      add hl,de
040E01 EB          0806*      ex de,hl
040E02 30 04       0807*      jr nc,$+6
040E04 ED 52       0808*      sbc hl,de
040E06 13          0809*      inc de
040E07 13          0810*      inc de
040E08 CB 1A       0811*      rr d
040E0A CB 1B       0812*      rr e
040E0C C9          0813*      ret
040E0D             0814*  
040E0D             0815*  sin_lut_168:
040E0D 00 00 00    0816*      dl 0x000000 ; 0.000 00, 0.000
040E10 06 00 00    0817*      dl 0x000006 ; 1.406 01, 0.025
040E13 0C 00 00    0818*      dl 0x00000C ; 2.813 02, 0.049
040E16 12 00 00    0819*      dl 0x000012 ; 4.219 03, 0.074
040E19 19 00 00    0820*      dl 0x000019 ; 5.625 04, 0.098
040E1C 1F 00 00    0821*      dl 0x00001F ; 7.031 05, 0.122
040E1F 25 00 00    0822*      dl 0x000025 ; 8.438 06, 0.147
040E22 2B 00 00    0823*      dl 0x00002B ; 9.844 07, 0.171
040E25 31 00 00    0824*      dl 0x000031 ; 11.250 08, 0.195
040E28 38 00 00    0825*      dl 0x000038 ; 12.656 09, 0.219
040E2B 3E 00 00    0826*      dl 0x00003E ; 14.063 0A, 0.243
040E2E 44 00 00    0827*      dl 0x000044 ; 15.469 0B, 0.267
040E31 4A 00 00    0828*      dl 0x00004A ; 16.875 0C, 0.290
040E34 50 00 00    0829*      dl 0x000050 ; 18.281 0D, 0.314
040E37 56 00 00    0830*      dl 0x000056 ; 19.688 0E, 0.337
040E3A 5C 00 00    0831*      dl 0x00005C ; 21.094 0F, 0.360
040E3D 61 00 00    0832*      dl 0x000061 ; 22.500 10, 0.383
040E40 67 00 00    0833*      dl 0x000067 ; 23.906 11, 0.405
040E43 6D 00 00    0834*      dl 0x00006D ; 25.313 12, 0.428
040E46 73 00 00    0835*      dl 0x000073 ; 26.719 13, 0.450
040E49 78 00 00    0836*      dl 0x000078 ; 28.125 14, 0.471
040E4C 7E 00 00    0837*      dl 0x00007E ; 29.531 15, 0.493
040E4F 83 00 00    0838*      dl 0x000083 ; 30.938 16, 0.514
040E52 88 00 00    0839*      dl 0x000088 ; 32.344 17, 0.535
040E55 8E 00 00    0840*      dl 0x00008E ; 33.750 18, 0.556
040E58 93 00 00    0841*      dl 0x000093 ; 35.156 19, 0.576
040E5B 98 00 00    0842*      dl 0x000098 ; 36.563 1A, 0.596
040E5E 9D 00 00    0843*      dl 0x00009D ; 37.969 1B, 0.615
040E61 A2 00 00    0844*      dl 0x0000A2 ; 39.375 1C, 0.634
040E64 A7 00 00    0845*      dl 0x0000A7 ; 40.781 1D, 0.653
040E67 AB 00 00    0846*      dl 0x0000AB ; 42.188 1E, 0.672
040E6A B0 00 00    0847*      dl 0x0000B0 ; 43.594 1F, 0.690
040E6D B5 00 00    0848*      dl 0x0000B5 ; 45.000 20, 0.707
040E70 B9 00 00    0849*      dl 0x0000B9 ; 46.406 21, 0.724
040E73 BD 00 00    0850*      dl 0x0000BD ; 47.813 22, 0.741
040E76 C1 00 00    0851*      dl 0x0000C1 ; 49.219 23, 0.757
040E79 C5 00 00    0852*      dl 0x0000C5 ; 50.625 24, 0.773
040E7C C9 00 00    0853*      dl 0x0000C9 ; 52.031 25, 0.788
040E7F CD 00 00    0854*      dl 0x0000CD ; 53.438 26, 0.803
040E82 D1 00 00    0855*      dl 0x0000D1 ; 54.844 27, 0.818
040E85 D4 00 00    0856*      dl 0x0000D4 ; 56.250 28, 0.831
040E88 D8 00 00    0857*      dl 0x0000D8 ; 57.656 29, 0.845
040E8B DB 00 00    0858*      dl 0x0000DB ; 59.063 2A, 0.858
040E8E DE 00 00    0859*      dl 0x0000DE ; 60.469 2B, 0.870
040E91 E1 00 00    0860*      dl 0x0000E1 ; 61.875 2C, 0.882
040E94 E4 00 00    0861*      dl 0x0000E4 ; 63.281 2D, 0.893
040E97 E7 00 00    0862*      dl 0x0000E7 ; 64.688 2E, 0.904
040E9A EA 00 00    0863*      dl 0x0000EA ; 66.094 2F, 0.914
040E9D EC 00 00    0864*      dl 0x0000EC ; 67.500 30, 0.924
040EA0 EE 00 00    0865*      dl 0x0000EE ; 68.906 31, 0.933
040EA3 F1 00 00    0866*      dl 0x0000F1 ; 70.313 32, 0.942
040EA6 F3 00 00    0867*      dl 0x0000F3 ; 71.719 33, 0.950
040EA9 F4 00 00    0868*      dl 0x0000F4 ; 73.125 34, 0.957
040EAC F6 00 00    0869*      dl 0x0000F6 ; 74.531 35, 0.964
040EAF F8 00 00    0870*      dl 0x0000F8 ; 75.938 36, 0.970
040EB2 F9 00 00    0871*      dl 0x0000F9 ; 77.344 37, 0.976
040EB5 FB 00 00    0872*      dl 0x0000FB ; 78.750 38, 0.981
040EB8 FC 00 00    0873*      dl 0x0000FC ; 80.156 39, 0.985
040EBB FD 00 00    0874*      dl 0x0000FD ; 81.563 3A, 0.989
040EBE FE 00 00    0875*      dl 0x0000FE ; 82.969 3B, 0.992
040EC1 FE 00 00    0876*      dl 0x0000FE ; 84.375 3C, 0.995
040EC4 FF 00 00    0877*      dl 0x0000FF ; 85.781 3D, 0.997
040EC7 FF 00 00    0878*      dl 0x0000FF ; 87.188 3E, 0.999
040ECA FF 00 00    0879*      dl 0x0000FF ; 88.594 3F, 1.000
040ECD 00 01 00    0880*      dl 0x000100 ; 90.000 40, 1.000
040ED0 FF 00 00    0881*      dl 0x0000FF ; 91.406 41, 1.000
040ED3 FF 00 00    0882*      dl 0x0000FF ; 92.813 42, 0.999
040ED6 FF 00 00    0883*      dl 0x0000FF ; 94.219 43, 0.997
040ED9 FE 00 00    0884*      dl 0x0000FE ; 95.625 44, 0.995
040EDC FE 00 00    0885*      dl 0x0000FE ; 97.031 45, 0.992
040EDF FD 00 00    0886*      dl 0x0000FD ; 98.438 46, 0.989
040EE2 FC 00 00    0887*      dl 0x0000FC ; 99.844 47, 0.985
040EE5 FB 00 00    0888*      dl 0x0000FB ; 101.250 48, 0.981
040EE8 F9 00 00    0889*      dl 0x0000F9 ; 102.656 49, 0.976
040EEB F8 00 00    0890*      dl 0x0000F8 ; 104.063 4A, 0.970
040EEE F6 00 00    0891*      dl 0x0000F6 ; 105.469 4B, 0.964
040EF1 F4 00 00    0892*      dl 0x0000F4 ; 106.875 4C, 0.957
040EF4 F3 00 00    0893*      dl 0x0000F3 ; 108.281 4D, 0.950
040EF7 F1 00 00    0894*      dl 0x0000F1 ; 109.688 4E, 0.942
040EFA EE 00 00    0895*      dl 0x0000EE ; 111.094 4F, 0.933
040EFD EC 00 00    0896*      dl 0x0000EC ; 112.500 50, 0.924
040F00 EA 00 00    0897*      dl 0x0000EA ; 113.906 51, 0.914
040F03 E7 00 00    0898*      dl 0x0000E7 ; 115.313 52, 0.904
040F06 E4 00 00    0899*      dl 0x0000E4 ; 116.719 53, 0.893
040F09 E1 00 00    0900*      dl 0x0000E1 ; 118.125 54, 0.882
040F0C DE 00 00    0901*      dl 0x0000DE ; 119.531 55, 0.870
040F0F DB 00 00    0902*      dl 0x0000DB ; 120.938 56, 0.858
040F12 D8 00 00    0903*      dl 0x0000D8 ; 122.344 57, 0.845
040F15 D4 00 00    0904*      dl 0x0000D4 ; 123.750 58, 0.831
040F18 D1 00 00    0905*      dl 0x0000D1 ; 125.156 59, 0.818
040F1B CD 00 00    0906*      dl 0x0000CD ; 126.563 5A, 0.803
040F1E C9 00 00    0907*      dl 0x0000C9 ; 127.969 5B, 0.788
040F21 C5 00 00    0908*      dl 0x0000C5 ; 129.375 5C, 0.773
040F24 C1 00 00    0909*      dl 0x0000C1 ; 130.781 5D, 0.757
040F27 BD 00 00    0910*      dl 0x0000BD ; 132.188 5E, 0.741
040F2A B9 00 00    0911*      dl 0x0000B9 ; 133.594 5F, 0.724
040F2D B5 00 00    0912*      dl 0x0000B5 ; 135.000 60, 0.707
040F30 B0 00 00    0913*      dl 0x0000B0 ; 136.406 61, 0.690
040F33 AB 00 00    0914*      dl 0x0000AB ; 137.813 62, 0.672
040F36 A7 00 00    0915*      dl 0x0000A7 ; 139.219 63, 0.653
040F39 A2 00 00    0916*      dl 0x0000A2 ; 140.625 64, 0.634
040F3C 9D 00 00    0917*      dl 0x00009D ; 142.031 65, 0.615
040F3F 98 00 00    0918*      dl 0x000098 ; 143.438 66, 0.596
040F42 93 00 00    0919*      dl 0x000093 ; 144.844 67, 0.576
040F45 8E 00 00    0920*      dl 0x00008E ; 146.250 68, 0.556
040F48 88 00 00    0921*      dl 0x000088 ; 147.656 69, 0.535
040F4B 83 00 00    0922*      dl 0x000083 ; 149.063 6A, 0.514
040F4E 7E 00 00    0923*      dl 0x00007E ; 150.469 6B, 0.493
040F51 78 00 00    0924*      dl 0x000078 ; 151.875 6C, 0.471
040F54 73 00 00    0925*      dl 0x000073 ; 153.281 6D, 0.450
040F57 6D 00 00    0926*      dl 0x00006D ; 154.688 6E, 0.428
040F5A 67 00 00    0927*      dl 0x000067 ; 156.094 6F, 0.405
040F5D 61 00 00    0928*      dl 0x000061 ; 157.500 70, 0.383
040F60 5C 00 00    0929*      dl 0x00005C ; 158.906 71, 0.360
040F63 56 00 00    0930*      dl 0x000056 ; 160.313 72, 0.337
040F66 50 00 00    0931*      dl 0x000050 ; 161.719 73, 0.314
040F69 4A 00 00    0932*      dl 0x00004A ; 163.125 74, 0.290
040F6C 44 00 00    0933*      dl 0x000044 ; 164.531 75, 0.267
040F6F 3E 00 00    0934*      dl 0x00003E ; 165.938 76, 0.243
040F72 38 00 00    0935*      dl 0x000038 ; 167.344 77, 0.219
040F75 31 00 00    0936*      dl 0x000031 ; 168.750 78, 0.195
040F78 2B 00 00    0937*      dl 0x00002B ; 170.156 79, 0.171
040F7B 25 00 00    0938*      dl 0x000025 ; 171.563 7A, 0.147
040F7E 1F 00 00    0939*      dl 0x00001F ; 172.969 7B, 0.122
040F81 19 00 00    0940*      dl 0x000019 ; 174.375 7C, 0.098
040F84 12 00 00    0941*      dl 0x000012 ; 175.781 7D, 0.074
040F87 0C 00 00    0942*      dl 0x00000C ; 177.188 7E, 0.049
040F8A 06 00 00    0943*      dl 0x000006 ; 178.594 7F, 0.025
040F8D 00 00 00    0944*      dl 0x000000 ; 180.000 80, 0.000
040F90 FA FF FF    0945*      dl 0xFFFFFA ; 181.406 81, -0.025
040F93 F4 FF FF    0946*      dl 0xFFFFF4 ; 182.813 82, -0.049
040F96 EE FF FF    0947*      dl 0xFFFFEE ; 184.219 83, -0.074
040F99 E7 FF FF    0948*      dl 0xFFFFE7 ; 185.625 84, -0.098
040F9C E1 FF FF    0949*      dl 0xFFFFE1 ; 187.031 85, -0.122
040F9F DB FF FF    0950*      dl 0xFFFFDB ; 188.438 86, -0.147
040FA2 D5 FF FF    0951*      dl 0xFFFFD5 ; 189.844 87, -0.171
040FA5 CF FF FF    0952*      dl 0xFFFFCF ; 191.250 88, -0.195
040FA8 C8 FF FF    0953*      dl 0xFFFFC8 ; 192.656 89, -0.219
040FAB C2 FF FF    0954*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040FAE BC FF FF    0955*      dl 0xFFFFBC ; 195.469 8B, -0.267
040FB1 B6 FF FF    0956*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040FB4 B0 FF FF    0957*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040FB7 AA FF FF    0958*      dl 0xFFFFAA ; 199.688 8E, -0.337
040FBA A4 FF FF    0959*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040FBD 9F FF FF    0960*      dl 0xFFFF9F ; 202.500 90, -0.383
040FC0 99 FF FF    0961*      dl 0xFFFF99 ; 203.906 91, -0.405
040FC3 93 FF FF    0962*      dl 0xFFFF93 ; 205.313 92, -0.428
040FC6 8D FF FF    0963*      dl 0xFFFF8D ; 206.719 93, -0.450
040FC9 88 FF FF    0964*      dl 0xFFFF88 ; 208.125 94, -0.471
040FCC 82 FF FF    0965*      dl 0xFFFF82 ; 209.531 95, -0.493
040FCF 7D FF FF    0966*      dl 0xFFFF7D ; 210.938 96, -0.514
040FD2 78 FF FF    0967*      dl 0xFFFF78 ; 212.344 97, -0.535
040FD5 72 FF FF    0968*      dl 0xFFFF72 ; 213.750 98, -0.556
040FD8 6D FF FF    0969*      dl 0xFFFF6D ; 215.156 99, -0.576
040FDB 68 FF FF    0970*      dl 0xFFFF68 ; 216.563 9A, -0.596
040FDE 63 FF FF    0971*      dl 0xFFFF63 ; 217.969 9B, -0.615
040FE1 5E FF FF    0972*      dl 0xFFFF5E ; 219.375 9C, -0.634
040FE4 59 FF FF    0973*      dl 0xFFFF59 ; 220.781 9D, -0.653
040FE7 55 FF FF    0974*      dl 0xFFFF55 ; 222.188 9E, -0.672
040FEA 50 FF FF    0975*      dl 0xFFFF50 ; 223.594 9F, -0.690
040FED 4B FF FF    0976*      dl 0xFFFF4B ; 225.000 A0, -0.707
040FF0 47 FF FF    0977*      dl 0xFFFF47 ; 226.406 A1, -0.724
040FF3 43 FF FF    0978*      dl 0xFFFF43 ; 227.813 A2, -0.741
040FF6 3F FF FF    0979*      dl 0xFFFF3F ; 229.219 A3, -0.757
040FF9 3B FF FF    0980*      dl 0xFFFF3B ; 230.625 A4, -0.773
040FFC 37 FF FF    0981*      dl 0xFFFF37 ; 232.031 A5, -0.788
040FFF 33 FF FF    0982*      dl 0xFFFF33 ; 233.438 A6, -0.803
041002 2F FF FF    0983*      dl 0xFFFF2F ; 234.844 A7, -0.818
041005 2C FF FF    0984*      dl 0xFFFF2C ; 236.250 A8, -0.831
041008 28 FF FF    0985*      dl 0xFFFF28 ; 237.656 A9, -0.845
04100B 25 FF FF    0986*      dl 0xFFFF25 ; 239.063 AA, -0.858
04100E 22 FF FF    0987*      dl 0xFFFF22 ; 240.469 AB, -0.870
041011 1F FF FF    0988*      dl 0xFFFF1F ; 241.875 AC, -0.882
041014 1C FF FF    0989*      dl 0xFFFF1C ; 243.281 AD, -0.893
041017 19 FF FF    0990*      dl 0xFFFF19 ; 244.688 AE, -0.904
04101A 16 FF FF    0991*      dl 0xFFFF16 ; 246.094 AF, -0.914
04101D 14 FF FF    0992*      dl 0xFFFF14 ; 247.500 B0, -0.924
041020 12 FF FF    0993*      dl 0xFFFF12 ; 248.906 B1, -0.933
041023 0F FF FF    0994*      dl 0xFFFF0F ; 250.313 B2, -0.942
041026 0D FF FF    0995*      dl 0xFFFF0D ; 251.719 B3, -0.950
041029 0C FF FF    0996*      dl 0xFFFF0C ; 253.125 B4, -0.957
04102C 0A FF FF    0997*      dl 0xFFFF0A ; 254.531 B5, -0.964
04102F 08 FF FF    0998*      dl 0xFFFF08 ; 255.938 B6, -0.970
041032 07 FF FF    0999*      dl 0xFFFF07 ; 257.344 B7, -0.976
041035 05 FF FF    1000*      dl 0xFFFF05 ; 258.750 B8, -0.981
041038 04 FF FF    1001*      dl 0xFFFF04 ; 260.156 B9, -0.985
04103B 03 FF FF    1002*      dl 0xFFFF03 ; 261.563 BA, -0.989
04103E 02 FF FF    1003*      dl 0xFFFF02 ; 262.969 BB, -0.992
041041 02 FF FF    1004*      dl 0xFFFF02 ; 264.375 BC, -0.995
041044 01 FF FF    1005*      dl 0xFFFF01 ; 265.781 BD, -0.997
041047 01 FF FF    1006*      dl 0xFFFF01 ; 267.188 BE, -0.999
04104A 01 FF FF    1007*      dl 0xFFFF01 ; 268.594 BF, -1.000
04104D 00 FF FF    1008*      dl 0xFFFF00 ; 270.000 C0, -1.000
041050 01 FF FF    1009*      dl 0xFFFF01 ; 271.406 C1, -1.000
041053 01 FF FF    1010*      dl 0xFFFF01 ; 272.813 C2, -0.999
041056 01 FF FF    1011*      dl 0xFFFF01 ; 274.219 C3, -0.997
041059 02 FF FF    1012*      dl 0xFFFF02 ; 275.625 C4, -0.995
04105C 02 FF FF    1013*      dl 0xFFFF02 ; 277.031 C5, -0.992
04105F 03 FF FF    1014*      dl 0xFFFF03 ; 278.438 C6, -0.989
041062 04 FF FF    1015*      dl 0xFFFF04 ; 279.844 C7, -0.985
041065 05 FF FF    1016*      dl 0xFFFF05 ; 281.250 C8, -0.981
041068 07 FF FF    1017*      dl 0xFFFF07 ; 282.656 C9, -0.976
04106B 08 FF FF    1018*      dl 0xFFFF08 ; 284.063 CA, -0.970
04106E 0A FF FF    1019*      dl 0xFFFF0A ; 285.469 CB, -0.964
041071 0C FF FF    1020*      dl 0xFFFF0C ; 286.875 CC, -0.957
041074 0D FF FF    1021*      dl 0xFFFF0D ; 288.281 CD, -0.950
041077 0F FF FF    1022*      dl 0xFFFF0F ; 289.688 CE, -0.942
04107A 12 FF FF    1023*      dl 0xFFFF12 ; 291.094 CF, -0.933
04107D 14 FF FF    1024*      dl 0xFFFF14 ; 292.500 D0, -0.924
041080 16 FF FF    1025*      dl 0xFFFF16 ; 293.906 D1, -0.914
041083 19 FF FF    1026*      dl 0xFFFF19 ; 295.313 D2, -0.904
041086 1C FF FF    1027*      dl 0xFFFF1C ; 296.719 D3, -0.893
041089 1F FF FF    1028*      dl 0xFFFF1F ; 298.125 D4, -0.882
04108C 22 FF FF    1029*      dl 0xFFFF22 ; 299.531 D5, -0.870
04108F 25 FF FF    1030*      dl 0xFFFF25 ; 300.938 D6, -0.858
041092 28 FF FF    1031*      dl 0xFFFF28 ; 302.344 D7, -0.845
041095 2C FF FF    1032*      dl 0xFFFF2C ; 303.750 D8, -0.831
041098 2F FF FF    1033*      dl 0xFFFF2F ; 305.156 D9, -0.818
04109B 33 FF FF    1034*      dl 0xFFFF33 ; 306.563 DA, -0.803
04109E 37 FF FF    1035*      dl 0xFFFF37 ; 307.969 DB, -0.788
0410A1 3B FF FF    1036*      dl 0xFFFF3B ; 309.375 DC, -0.773
0410A4 3F FF FF    1037*      dl 0xFFFF3F ; 310.781 DD, -0.757
0410A7 43 FF FF    1038*      dl 0xFFFF43 ; 312.188 DE, -0.741
0410AA 47 FF FF    1039*      dl 0xFFFF47 ; 313.594 DF, -0.724
0410AD 4B FF FF    1040*      dl 0xFFFF4B ; 315.000 E0, -0.707
0410B0 50 FF FF    1041*      dl 0xFFFF50 ; 316.406 E1, -0.690
0410B3 55 FF FF    1042*      dl 0xFFFF55 ; 317.813 E2, -0.672
0410B6 59 FF FF    1043*      dl 0xFFFF59 ; 319.219 E3, -0.653
0410B9 5E FF FF    1044*      dl 0xFFFF5E ; 320.625 E4, -0.634
0410BC 63 FF FF    1045*      dl 0xFFFF63 ; 322.031 E5, -0.615
0410BF 68 FF FF    1046*      dl 0xFFFF68 ; 323.438 E6, -0.596
0410C2 6D FF FF    1047*      dl 0xFFFF6D ; 324.844 E7, -0.576
0410C5 72 FF FF    1048*      dl 0xFFFF72 ; 326.250 E8, -0.556
0410C8 78 FF FF    1049*      dl 0xFFFF78 ; 327.656 E9, -0.535
0410CB 7D FF FF    1050*      dl 0xFFFF7D ; 329.063 EA, -0.514
0410CE 82 FF FF    1051*      dl 0xFFFF82 ; 330.469 EB, -0.493
0410D1 88 FF FF    1052*      dl 0xFFFF88 ; 331.875 EC, -0.471
0410D4 8D FF FF    1053*      dl 0xFFFF8D ; 333.281 ED, -0.450
0410D7 93 FF FF    1054*      dl 0xFFFF93 ; 334.688 EE, -0.428
0410DA 99 FF FF    1055*      dl 0xFFFF99 ; 336.094 EF, -0.405
0410DD 9F FF FF    1056*      dl 0xFFFF9F ; 337.500 F0, -0.383
0410E0 A4 FF FF    1057*      dl 0xFFFFA4 ; 338.906 F1, -0.360
0410E3 AA FF FF    1058*      dl 0xFFFFAA ; 340.313 F2, -0.337
0410E6 B0 FF FF    1059*      dl 0xFFFFB0 ; 341.719 F3, -0.314
0410E9 B6 FF FF    1060*      dl 0xFFFFB6 ; 343.125 F4, -0.290
0410EC BC FF FF    1061*      dl 0xFFFFBC ; 344.531 F5, -0.267
0410EF C2 FF FF    1062*      dl 0xFFFFC2 ; 345.938 F6, -0.243
0410F2 C8 FF FF    1063*      dl 0xFFFFC8 ; 347.344 F7, -0.219
0410F5 CF FF FF    1064*      dl 0xFFFFCF ; 348.750 F8, -0.195
0410F8 D5 FF FF    1065*      dl 0xFFFFD5 ; 350.156 F9, -0.171
0410FB DB FF FF    1066*      dl 0xFFFFDB ; 351.563 FA, -0.147
0410FE E1 FF FF    1067*      dl 0xFFFFE1 ; 352.969 FB, -0.122
041101 E7 FF FF    1068*      dl 0xFFFFE7 ; 354.375 FC, -0.098
041104 EE FF FF    1069*      dl 0xFFFFEE ; 355.781 FD, -0.074
041107 F4 FF FF    1070*      dl 0xFFFFF4 ; 357.188 FE, -0.049
04110A FA FF FF    1071*      dl 0xFFFFFA ; 358.594 FF, -0.025
04110D 00 00 00    1072*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
041110             1073*  
041110             1074*  atan_lut_168:
041110 00 00 00    1075*      dl 0x000000 ; 000000, 0.000
041113 28 00 00    1076*      dl 0x000028 ; 000001, 0.224
041116 51 00 00    1077*      dl 0x000051 ; 000002, 0.448
041119 7A 00 00    1078*      dl 0x00007A ; 000003, 0.671
04111C A2 00 00    1079*      dl 0x0000A2 ; 000004, 0.895
04111F CB 00 00    1080*      dl 0x0000CB ; 000005, 1.119
041122 F4 00 00    1081*      dl 0x0000F4 ; 000006, 1.343
041125 1D 01 00    1082*      dl 0x00011D ; 000007, 1.566
041128 45 01 00    1083*      dl 0x000145 ; 000008, 1.790
04112B 6E 01 00    1084*      dl 0x00016E ; 000009, 2.013
04112E 97 01 00    1085*      dl 0x000197 ; 00000A, 2.237
041131 BF 01 00    1086*      dl 0x0001BF ; 00000B, 2.460
041134 E8 01 00    1087*      dl 0x0001E8 ; 00000C, 2.684
041137 11 02 00    1088*      dl 0x000211 ; 00000D, 2.907
04113A 39 02 00    1089*      dl 0x000239 ; 00000E, 3.130
04113D 62 02 00    1090*      dl 0x000262 ; 00000F, 3.353
041140 8B 02 00    1091*      dl 0x00028B ; 000010, 3.576
041143 B3 02 00    1092*      dl 0x0002B3 ; 000011, 3.799
041146 DC 02 00    1093*      dl 0x0002DC ; 000012, 4.022
041149 04 03 00    1094*      dl 0x000304 ; 000013, 4.245
04114C 2D 03 00    1095*      dl 0x00032D ; 000014, 4.467
04114F 55 03 00    1096*      dl 0x000355 ; 000015, 4.690
041152 7E 03 00    1097*      dl 0x00037E ; 000016, 4.912
041155 A6 03 00    1098*      dl 0x0003A6 ; 000017, 5.134
041158 CE 03 00    1099*      dl 0x0003CE ; 000018, 5.356
04115B F7 03 00    1100*      dl 0x0003F7 ; 000019, 5.578
04115E 1F 04 00    1101*      dl 0x00041F ; 00001A, 5.799
041161 48 04 00    1102*      dl 0x000448 ; 00001B, 6.021
041164 70 04 00    1103*      dl 0x000470 ; 00001C, 6.242
041167 98 04 00    1104*      dl 0x000498 ; 00001D, 6.463
04116A C0 04 00    1105*      dl 0x0004C0 ; 00001E, 6.684
04116D E8 04 00    1106*      dl 0x0004E8 ; 00001F, 6.905
041170 11 05 00    1107*      dl 0x000511 ; 000020, 7.125
041173 39 05 00    1108*      dl 0x000539 ; 000021, 7.345
041176 61 05 00    1109*      dl 0x000561 ; 000022, 7.565
041179 89 05 00    1110*      dl 0x000589 ; 000023, 7.785
04117C B1 05 00    1111*      dl 0x0005B1 ; 000024, 8.005
04117F D9 05 00    1112*      dl 0x0005D9 ; 000025, 8.224
041182 01 06 00    1113*      dl 0x000601 ; 000026, 8.443
041185 28 06 00    1114*      dl 0x000628 ; 000027, 8.662
041188 50 06 00    1115*      dl 0x000650 ; 000028, 8.881
04118B 78 06 00    1116*      dl 0x000678 ; 000029, 9.099
04118E A0 06 00    1117*      dl 0x0006A0 ; 00002A, 9.317
041191 C7 06 00    1118*      dl 0x0006C7 ; 00002B, 9.535
041194 EF 06 00    1119*      dl 0x0006EF ; 00002C, 9.752
041197 16 07 00    1120*      dl 0x000716 ; 00002D, 9.970
04119A 3E 07 00    1121*      dl 0x00073E ; 00002E, 10.187
04119D 65 07 00    1122*      dl 0x000765 ; 00002F, 10.403
0411A0 8D 07 00    1123*      dl 0x00078D ; 000030, 10.620
0411A3 B4 07 00    1124*      dl 0x0007B4 ; 000031, 10.836
0411A6 DB 07 00    1125*      dl 0x0007DB ; 000032, 11.051
0411A9 03 08 00    1126*      dl 0x000803 ; 000033, 11.267
0411AC 2A 08 00    1127*      dl 0x00082A ; 000034, 11.482
0411AF 51 08 00    1128*      dl 0x000851 ; 000035, 11.697
0411B2 78 08 00    1129*      dl 0x000878 ; 000036, 11.911
0411B5 9F 08 00    1130*      dl 0x00089F ; 000037, 12.125
0411B8 C6 08 00    1131*      dl 0x0008C6 ; 000038, 12.339
0411BB ED 08 00    1132*      dl 0x0008ED ; 000039, 12.553
0411BE 13 09 00    1133*      dl 0x000913 ; 00003A, 12.766
0411C1 3A 09 00    1134*      dl 0x00093A ; 00003B, 12.978
0411C4 61 09 00    1135*      dl 0x000961 ; 00003C, 13.191
0411C7 87 09 00    1136*      dl 0x000987 ; 00003D, 13.403
0411CA AE 09 00    1137*      dl 0x0009AE ; 00003E, 13.614
0411CD D4 09 00    1138*      dl 0x0009D4 ; 00003F, 13.825
0411D0 FB 09 00    1139*      dl 0x0009FB ; 000040, 14.036
0411D3 21 0A 00    1140*      dl 0x000A21 ; 000041, 14.247
0411D6 47 0A 00    1141*      dl 0x000A47 ; 000042, 14.457
0411D9 6D 0A 00    1142*      dl 0x000A6D ; 000043, 14.666
0411DC 94 0A 00    1143*      dl 0x000A94 ; 000044, 14.876
0411DF BA 0A 00    1144*      dl 0x000ABA ; 000045, 15.085
0411E2 E0 0A 00    1145*      dl 0x000AE0 ; 000046, 15.293
0411E5 05 0B 00    1146*      dl 0x000B05 ; 000047, 15.501
0411E8 2B 0B 00    1147*      dl 0x000B2B ; 000048, 15.709
0411EB 51 0B 00    1148*      dl 0x000B51 ; 000049, 15.916
0411EE 77 0B 00    1149*      dl 0x000B77 ; 00004A, 16.123
0411F1 9C 0B 00    1150*      dl 0x000B9C ; 00004B, 16.329
0411F4 C2 0B 00    1151*      dl 0x000BC2 ; 00004C, 16.535
0411F7 E7 0B 00    1152*      dl 0x000BE7 ; 00004D, 16.740
0411FA 0C 0C 00    1153*      dl 0x000C0C ; 00004E, 16.945
0411FD 32 0C 00    1154*      dl 0x000C32 ; 00004F, 17.150
041200 57 0C 00    1155*      dl 0x000C57 ; 000050, 17.354
041203 7C 0C 00    1156*      dl 0x000C7C ; 000051, 17.558
041206 A1 0C 00    1157*      dl 0x000CA1 ; 000052, 17.761
041209 C6 0C 00    1158*      dl 0x000CC6 ; 000053, 17.964
04120C EB 0C 00    1159*      dl 0x000CEB ; 000054, 18.166
04120F 0F 0D 00    1160*      dl 0x000D0F ; 000055, 18.368
041212 34 0D 00    1161*      dl 0x000D34 ; 000056, 18.569
041215 58 0D 00    1162*      dl 0x000D58 ; 000057, 18.770
041218 7D 0D 00    1163*      dl 0x000D7D ; 000058, 18.970
04121B A1 0D 00    1164*      dl 0x000DA1 ; 000059, 19.170
04121E C6 0D 00    1165*      dl 0x000DC6 ; 00005A, 19.370
041221 EA 0D 00    1166*      dl 0x000DEA ; 00005B, 19.569
041224 0E 0E 00    1167*      dl 0x000E0E ; 00005C, 19.767
041227 32 0E 00    1168*      dl 0x000E32 ; 00005D, 19.965
04122A 56 0E 00    1169*      dl 0x000E56 ; 00005E, 20.163
04122D 7A 0E 00    1170*      dl 0x000E7A ; 00005F, 20.360
041230 9E 0E 00    1171*      dl 0x000E9E ; 000060, 20.556
041233 C1 0E 00    1172*      dl 0x000EC1 ; 000061, 20.752
041236 E5 0E 00    1173*      dl 0x000EE5 ; 000062, 20.947
041239 08 0F 00    1174*      dl 0x000F08 ; 000063, 21.142
04123C 2C 0F 00    1175*      dl 0x000F2C ; 000064, 21.337
04123F 4F 0F 00    1176*      dl 0x000F4F ; 000065, 21.531
041242 72 0F 00    1177*      dl 0x000F72 ; 000066, 21.724
041245 95 0F 00    1178*      dl 0x000F95 ; 000067, 21.917
041248 B8 0F 00    1179*      dl 0x000FB8 ; 000068, 22.109
04124B DB 0F 00    1180*      dl 0x000FDB ; 000069, 22.301
04124E FE 0F 00    1181*      dl 0x000FFE ; 00006A, 22.493
041251 21 10 00    1182*      dl 0x001021 ; 00006B, 22.683
041254 44 10 00    1183*      dl 0x001044 ; 00006C, 22.874
041257 66 10 00    1184*      dl 0x001066 ; 00006D, 23.063
04125A 89 10 00    1185*      dl 0x001089 ; 00006E, 23.253
04125D AB 10 00    1186*      dl 0x0010AB ; 00006F, 23.441
041260 CD 10 00    1187*      dl 0x0010CD ; 000070, 23.629
041263 EF 10 00    1188*      dl 0x0010EF ; 000071, 23.817
041266 11 11 00    1189*      dl 0x001111 ; 000072, 24.004
041269 33 11 00    1190*      dl 0x001133 ; 000073, 24.191
04126C 55 11 00    1191*      dl 0x001155 ; 000074, 24.376
04126F 77 11 00    1192*      dl 0x001177 ; 000075, 24.562
041272 99 11 00    1193*      dl 0x001199 ; 000076, 24.747
041275 BA 11 00    1194*      dl 0x0011BA ; 000077, 24.931
041278 DC 11 00    1195*      dl 0x0011DC ; 000078, 25.115
04127B FD 11 00    1196*      dl 0x0011FD ; 000079, 25.298
04127E 1E 12 00    1197*      dl 0x00121E ; 00007A, 25.481
041281 3F 12 00    1198*      dl 0x00123F ; 00007B, 25.663
041284 60 12 00    1199*      dl 0x001260 ; 00007C, 25.844
041287 81 12 00    1200*      dl 0x001281 ; 00007D, 26.025
04128A A2 12 00    1201*      dl 0x0012A2 ; 00007E, 26.206
04128D C3 12 00    1202*      dl 0x0012C3 ; 00007F, 26.386
041290 E4 12 00    1203*      dl 0x0012E4 ; 000080, 26.565
041293 04 13 00    1204*      dl 0x001304 ; 000081, 26.744
041296 25 13 00    1205*      dl 0x001325 ; 000082, 26.922
041299 45 13 00    1206*      dl 0x001345 ; 000083, 27.100
04129C 65 13 00    1207*      dl 0x001365 ; 000084, 27.277
04129F 85 13 00    1208*      dl 0x001385 ; 000085, 27.453
0412A2 A5 13 00    1209*      dl 0x0013A5 ; 000086, 27.629
0412A5 C5 13 00    1210*      dl 0x0013C5 ; 000087, 27.805
0412A8 E5 13 00    1211*      dl 0x0013E5 ; 000088, 27.979
0412AB 05 14 00    1212*      dl 0x001405 ; 000089, 28.154
0412AE 24 14 00    1213*      dl 0x001424 ; 00008A, 28.327
0412B1 44 14 00    1214*      dl 0x001444 ; 00008B, 28.501
0412B4 63 14 00    1215*      dl 0x001463 ; 00008C, 28.673
0412B7 83 14 00    1216*      dl 0x001483 ; 00008D, 28.845
0412BA A2 14 00    1217*      dl 0x0014A2 ; 00008E, 29.017
0412BD C1 14 00    1218*      dl 0x0014C1 ; 00008F, 29.187
0412C0 E0 14 00    1219*      dl 0x0014E0 ; 000090, 29.358
0412C3 FF 14 00    1220*      dl 0x0014FF ; 000091, 29.527
0412C6 1E 15 00    1221*      dl 0x00151E ; 000092, 29.697
0412C9 3C 15 00    1222*      dl 0x00153C ; 000093, 29.865
0412CC 5B 15 00    1223*      dl 0x00155B ; 000094, 30.033
0412CF 79 15 00    1224*      dl 0x001579 ; 000095, 30.201
0412D2 98 15 00    1225*      dl 0x001598 ; 000096, 30.368
0412D5 B6 15 00    1226*      dl 0x0015B6 ; 000097, 30.534
0412D8 D4 15 00    1227*      dl 0x0015D4 ; 000098, 30.700
0412DB F2 15 00    1228*      dl 0x0015F2 ; 000099, 30.865
0412DE 10 16 00    1229*      dl 0x001610 ; 00009A, 31.030
0412E1 2E 16 00    1230*      dl 0x00162E ; 00009B, 31.194
0412E4 4C 16 00    1231*      dl 0x00164C ; 00009C, 31.357
0412E7 6A 16 00    1232*      dl 0x00166A ; 00009D, 31.520
0412EA 87 16 00    1233*      dl 0x001687 ; 00009E, 31.682
0412ED A5 16 00    1234*      dl 0x0016A5 ; 00009F, 31.844
0412F0 C2 16 00    1235*      dl 0x0016C2 ; 0000A0, 32.005
0412F3 DF 16 00    1236*      dl 0x0016DF ; 0000A1, 32.166
0412F6 FC 16 00    1237*      dl 0x0016FC ; 0000A2, 32.326
0412F9 19 17 00    1238*      dl 0x001719 ; 0000A3, 32.486
0412FC 36 17 00    1239*      dl 0x001736 ; 0000A4, 32.645
0412FF 53 17 00    1240*      dl 0x001753 ; 0000A5, 32.803
041302 70 17 00    1241*      dl 0x001770 ; 0000A6, 32.961
041305 8C 17 00    1242*      dl 0x00178C ; 0000A7, 33.118
041308 A9 17 00    1243*      dl 0x0017A9 ; 0000A8, 33.275
04130B C5 17 00    1244*      dl 0x0017C5 ; 0000A9, 33.431
04130E E2 17 00    1245*      dl 0x0017E2 ; 0000AA, 33.587
041311 FE 17 00    1246*      dl 0x0017FE ; 0000AB, 33.742
041314 1A 18 00    1247*      dl 0x00181A ; 0000AC, 33.896
041317 36 18 00    1248*      dl 0x001836 ; 0000AD, 34.050
04131A 52 18 00    1249*      dl 0x001852 ; 0000AE, 34.203
04131D 6E 18 00    1250*      dl 0x00186E ; 0000AF, 34.356
041320 8A 18 00    1251*      dl 0x00188A ; 0000B0, 34.509
041323 A5 18 00    1252*      dl 0x0018A5 ; 0000B1, 34.660
041326 C1 18 00    1253*      dl 0x0018C1 ; 0000B2, 34.811
041329 DC 18 00    1254*      dl 0x0018DC ; 0000B3, 34.962
04132C F7 18 00    1255*      dl 0x0018F7 ; 0000B4, 35.112
04132F 13 19 00    1256*      dl 0x001913 ; 0000B5, 35.262
041332 2E 19 00    1257*      dl 0x00192E ; 0000B6, 35.410
041335 49 19 00    1258*      dl 0x001949 ; 0000B7, 35.559
041338 64 19 00    1259*      dl 0x001964 ; 0000B8, 35.707
04133B 7F 19 00    1260*      dl 0x00197F ; 0000B9, 35.854
04133E 99 19 00    1261*      dl 0x001999 ; 0000BA, 36.001
041341 B4 19 00    1262*      dl 0x0019B4 ; 0000BB, 36.147
041344 CE 19 00    1263*      dl 0x0019CE ; 0000BC, 36.293
041347 E9 19 00    1264*      dl 0x0019E9 ; 0000BD, 36.438
04134A 03 1A 00    1265*      dl 0x001A03 ; 0000BE, 36.582
04134D 1D 1A 00    1266*      dl 0x001A1D ; 0000BF, 36.726
041350 37 1A 00    1267*      dl 0x001A37 ; 0000C0, 36.870
041353 51 1A 00    1268*      dl 0x001A51 ; 0000C1, 37.013
041356 6B 1A 00    1269*      dl 0x001A6B ; 0000C2, 37.155
041359 85 1A 00    1270*      dl 0x001A85 ; 0000C3, 37.297
04135C 9F 1A 00    1271*      dl 0x001A9F ; 0000C4, 37.439
04135F B9 1A 00    1272*      dl 0x001AB9 ; 0000C5, 37.579
041362 D2 1A 00    1273*      dl 0x001AD2 ; 0000C6, 37.720
041365 EC 1A 00    1274*      dl 0x001AEC ; 0000C7, 37.859
041368 05 1B 00    1275*      dl 0x001B05 ; 0000C8, 37.999
04136B 1E 1B 00    1276*      dl 0x001B1E ; 0000C9, 38.137
04136E 37 1B 00    1277*      dl 0x001B37 ; 0000CA, 38.276
041371 50 1B 00    1278*      dl 0x001B50 ; 0000CB, 38.413
041374 69 1B 00    1279*      dl 0x001B69 ; 0000CC, 38.550
041377 82 1B 00    1280*      dl 0x001B82 ; 0000CD, 38.687
04137A 9B 1B 00    1281*      dl 0x001B9B ; 0000CE, 38.823
04137D B4 1B 00    1282*      dl 0x001BB4 ; 0000CF, 38.959
041380 CC 1B 00    1283*      dl 0x001BCC ; 0000D0, 39.094
041383 E5 1B 00    1284*      dl 0x001BE5 ; 0000D1, 39.228
041386 FD 1B 00    1285*      dl 0x001BFD ; 0000D2, 39.362
041389 16 1C 00    1286*      dl 0x001C16 ; 0000D3, 39.496
04138C 2E 1C 00    1287*      dl 0x001C2E ; 0000D4, 39.629
04138F 46 1C 00    1288*      dl 0x001C46 ; 0000D5, 39.762
041392 5E 1C 00    1289*      dl 0x001C5E ; 0000D6, 39.894
041395 76 1C 00    1290*      dl 0x001C76 ; 0000D7, 40.025
041398 8E 1C 00    1291*      dl 0x001C8E ; 0000D8, 40.156
04139B A5 1C 00    1292*      dl 0x001CA5 ; 0000D9, 40.286
04139E BD 1C 00    1293*      dl 0x001CBD ; 0000DA, 40.416
0413A1 D5 1C 00    1294*      dl 0x001CD5 ; 0000DB, 40.546
0413A4 EC 1C 00    1295*      dl 0x001CEC ; 0000DC, 40.675
0413A7 04 1D 00    1296*      dl 0x001D04 ; 0000DD, 40.803
0413AA 1B 1D 00    1297*      dl 0x001D1B ; 0000DE, 40.931
0413AD 32 1D 00    1298*      dl 0x001D32 ; 0000DF, 41.059
0413B0 49 1D 00    1299*      dl 0x001D49 ; 0000E0, 41.186
0413B3 60 1D 00    1300*      dl 0x001D60 ; 0000E1, 41.312
0413B6 77 1D 00    1301*      dl 0x001D77 ; 0000E2, 41.438
0413B9 8E 1D 00    1302*      dl 0x001D8E ; 0000E3, 41.564
0413BC A5 1D 00    1303*      dl 0x001DA5 ; 0000E4, 41.689
0413BF BB 1D 00    1304*      dl 0x001DBB ; 0000E5, 41.814
0413C2 D2 1D 00    1305*      dl 0x001DD2 ; 0000E6, 41.938
0413C5 E9 1D 00    1306*      dl 0x001DE9 ; 0000E7, 42.061
0413C8 FF 1D 00    1307*      dl 0x001DFF ; 0000E8, 42.184
0413CB 15 1E 00    1308*      dl 0x001E15 ; 0000E9, 42.307
0413CE 2C 1E 00    1309*      dl 0x001E2C ; 0000EA, 42.429
0413D1 42 1E 00    1310*      dl 0x001E42 ; 0000EB, 42.551
0413D4 58 1E 00    1311*      dl 0x001E58 ; 0000EC, 42.672
0413D7 6E 1E 00    1312*      dl 0x001E6E ; 0000ED, 42.793
0413DA 84 1E 00    1313*      dl 0x001E84 ; 0000EE, 42.913
0413DD 99 1E 00    1314*      dl 0x001E99 ; 0000EF, 43.033
0413E0 AF 1E 00    1315*      dl 0x001EAF ; 0000F0, 43.152
0413E3 C5 1E 00    1316*      dl 0x001EC5 ; 0000F1, 43.271
0413E6 DA 1E 00    1317*      dl 0x001EDA ; 0000F2, 43.390
0413E9 F0 1E 00    1318*      dl 0x001EF0 ; 0000F3, 43.508
0413EC 05 1F 00    1319*      dl 0x001F05 ; 0000F4, 43.625
0413EF 1B 1F 00    1320*      dl 0x001F1B ; 0000F5, 43.742
0413F2 30 1F 00    1321*      dl 0x001F30 ; 0000F6, 43.859
0413F5 45 1F 00    1322*      dl 0x001F45 ; 0000F7, 43.975
0413F8 5A 1F 00    1323*      dl 0x001F5A ; 0000F8, 44.091
0413FB 6F 1F 00    1324*      dl 0x001F6F ; 0000F9, 44.206
0413FE 84 1F 00    1325*      dl 0x001F84 ; 0000FA, 44.321
041401 99 1F 00    1326*      dl 0x001F99 ; 0000FB, 44.435
041404 AD 1F 00    1327*      dl 0x001FAD ; 0000FC, 44.549
041407 C2 1F 00    1328*      dl 0x001FC2 ; 0000FD, 44.662
04140A D7 1F 00    1329*      dl 0x001FD7 ; 0000FE, 44.775
04140D EB 1F 00    1330*      dl 0x001FEB ; 0000FF, 44.888
041410 00 20 00    1331*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
041413             0034       include "images.inc"
041413             0001*  image_type: equ 0
041413             0002*  image_width: equ image_type+3
041413             0003*  image_height: equ image_width+3
041413             0004*  image_filesize: equ image_height+3
041413             0005*  image_filename: equ image_filesize+3
041413             0006*  image_bufferId: equ image_filename+3
041413             0007*  image_record_size: equ image_bufferId+3
041413             0008*  
041413 00 00 00    0009*  cur_image_list: dl 0
041416 00 00 00    0010*  cur_file_idx: dl 0
041419 00 00 00    0011*  cur_filename: dl 0
04141C 00 00 00    0012*  cur_buffer_id: dl 0
04141F             0013*  
04141F             0014*  load_ui_images:
04141F             0015*  ; initialize image loading variables
04141F 21 00 00 00 0016*      ld hl,0
041423 22 16 14 04 0017*      ld (cur_file_idx),hl
041427 21 11 25 04 0018*      ld hl,ui_image_list
04142B 22 13 14 04 0019*      ld (cur_image_list),hl
04142F             0020*  ; load images
04142F 06 04       0021*      ld b,ui_num_images
041431             0022*  @loop:
041431 C5          0023*      push bc
041432 CD 90 14 04 0024*      call load_next_image
041436 C1          0025*      pop bc
041437 10 F8       0026*      djnz @loop
041439 C9          0027*      ret
04143A             0028*  
04143A             0029*  load_sprite_images:
04143A             0030*  ; initialize image loading variables
04143A 21 00 00 00 0031*      ld hl,0
04143E 22 16 14 04 0032*      ld (cur_file_idx),hl
041442 21 21 15 04 0033*      ld hl,sprites_image_list
041446 22 13 14 04 0034*      ld (cur_image_list),hl
04144A 01 5F 00 00 0035*      ld bc,sprites_num_images
04144E             0036*  ; load images
04144E CD 53 14 04 0037*      call img_load_main
041452 C9          0038*      ret
041453             0039*  
041453             0040*  ; inputs: bc is the number of images to load, cur_image_list set
041453             0041*  img_load_main:
041453 AF          0042*      xor a
041454 32 16 14 04 0043*      ld (cur_file_idx),a
041458             0044*  
041458             0045*  img_load_main_loop:
041458             0046*  ; back up loop counter
041458 C5          0047*      push bc
041459             0048*  
041459             0049*  ; load the next image
041459 CD 90 14 04 0050*      call load_next_image
04145D             0051*  
04145D             0052*  ; plot the background
04145D CD AB 3E 04 0053*      call vdu_cls
041461 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
041465 CD 98 3F 04 0055*      call vdu_buff_select
041469 01 00 00 00 0056*      ld bc,0
04146D 11 00 00 00 0057*      ld de,0
041471 CD 61 42 04 0058*      call vdu_plot_bmp
041475             0059*  
041475             0060*  ; ; draw the most recently loaded image
041475             0061*  ; 	ld hl,(cur_buffer_id)
041475             0062*  ; 	call vdu_buff_select
041475             0063*  ; 	ld bc,0
041475             0064*  ; 	ld de,0
041475             0065*  ; 	call vdu_plot_bmp
041475             0066*  
041475             0067*  ; move logo
041475 CD F0 14 04 0068*      call move_logo
041479             0069*  
041479             0070*  ; print current filename
041479 2A 19 14 04 0071*      ld hl,(cur_filename)
04147D CD 77 00 04 0072*      call printString
041481             0073*  
041481             0074*  ; flip the framebuffer
041481             0075*      ; call vdu_flip
041481             0076*  
041481             0077*  ; decrement loop counter
041481 C1          0078*      pop bc
041482 0B          0079*      dec bc
041483 79          0080*      ld a,c
041484 B7          0081*      or a
041485 C2 58 14 04 0082*      jp nz,img_load_main_loop
041489 78          0083*      ld a,b
04148A B7          0084*      or a
04148B C2 58 14 04 0085*      jp nz,img_load_main_loop
04148F C9          0086*      ret
041490             0087*  
041490             0088*  load_next_image:
041490 16 12       0089*      ld d,image_record_size
041492 3A 16 14 04 0090*      ld a,(cur_file_idx)
041496 5F          0091*      ld e,a
041497 ED 5C       0092*      mlt de
041499 FD 2A 13 14 0093*      ld iy,(cur_image_list)
       04          
04149E FD 19       0094*      add iy,de
0414A0             0095*  
0414A0 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0414A3 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0414A6 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0414A9 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0414AC FD 27 0F    0100*      ld hl,(iy+image_bufferId) ; get image bufferId
0414AF 22 1C 14 04 0101*      ld (cur_buffer_id),hl
0414B3 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0414B6 FD 22 19 14 0103*      ld (cur_filename),iy
       04          
0414BB CD B6 40 04 0104*      call vdu_load_img
0414BF FD 21 16 14 0105*      ld iy,cur_file_idx
       04          
0414C4 FD 34 00    0106*      inc (iy)
0414C7 C9          0107*      ret
0414C8             0108*  
0414C8             0109*  img_load_init:
0414C8             0110*  ; initialize logo's position parameters
0414C8 21 00 00 00 0111*      ld hl,0
0414CC 22 15 15 04 0112*      ld (logo_xvel),hl
0414D0 22 18 15 04 0113*      ld (logo_xpos),hl
0414D4             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0414D4 21 00 E0 00 0115*      ld hl,240-16*256 ; allow space for text at bottom of screen
0414D8 22 1E 15 04 0116*      ld (logo_ypos),hl
0414DC EB          0117*      ex de,hl
0414DD 21 00 F8 FF 0118*      ld hl,-8*256 ; 8 pixels from top of screen
0414E1 19          0119*      add hl,de ; distance for logo to travel
0414E2 11 00 A1 FF 0120*      ld de,-sprites_num_images*256
0414E6 CD 2B 0B 04 0121*      call sdiv168 ; ud.e = distance / num images = y velocity
0414EA ED 53 1B 15 0122*      ld (logo_yvel),de
       04          
0414EF             0123*  ; all done
0414EF C9          0124*      ret
0414F0             0125*  
0414F0             0126*  move_logo:
0414F0             0127*  ; activate logo bitmap
0414F0 21 03 00 00 0128*      ld hl, BUF_SPLASH_LOGO
0414F4 CD 98 3F 04 0129*      call vdu_buff_select
0414F8             0130*  ; update position based on velocity parameters
0414F8 2A 1E 15 04 0131*      ld hl,(logo_ypos)
0414FC ED 5B 1B 15 0132*      ld de,(logo_yvel)
       04          
041501 19          0133*      add hl,de
041502 22 1E 15 04 0134*      ld (logo_ypos),hl
041506             0135*  ; draw logo
041506 ED 4B 18 15 0136*      ld bc,(logo_xpos)
       04          
04150B ED 5B 1E 15 0137*      ld de,(logo_ypos)
       04          
041510 CD 7D 42 04 0138*      call vdu_plot_bmp168
041514 C9          0139*      ret
041515             0140*  
041515 00 00 00    0141*  logo_xvel: dl 0
041518 00 00 00    0142*  logo_xpos: dl 0
04151B             0143*  
04151B 00 00 00    0144*  logo_yvel: dl 0
04151E 00 00 00    0145*  logo_ypos: dl 0
041521             0035       include "images_sprites.inc"
041521             0001*  ; Generated by make_images.py
041521             0002*  
041521             0003*  sprites_num_images: equ 95
041521             0004*  
041521             0005*  ; buffer_ids:
041521             0006*  BUF_0TILE_EMPTY: equ 256
041521             0007*  BUF_1TILE_CROSS: equ 257
041521             0008*  BUF_2TILE_HORIZ: equ 258
041521             0009*  BUF_3TILE_VERT: equ 259
041521             0010*  BUF_4TILE_SQUARE: equ 260
041521             0011*  BUF_5TILE_CIRCLE: equ 261
041521             0012*  BUF_6TILE_PAD: equ 262
041521             0013*  BUF_7TILE_TURRET: equ 263
041521             0014*  BUF_CIRCLE: equ 264
041521             0015*  BUF_CRATER: equ 265
041521             0016*  BUF_EXPLOSION_A: equ 266
041521             0017*  BUF_EXPLOSION_B: equ 267
041521             0018*  BUF_EXPLOSION_C: equ 268
041521             0019*  BUF_EXPLOSION_D: equ 269
041521             0020*  BUF_EXPLOSION_E: equ 270
041521             0021*  BUF_FIREBALL_A: equ 271
041521             0022*  BUF_FIREBALL_B: equ 272
041521             0023*  BUF_LASER_A: equ 273
041521             0024*  BUF_LASER_B: equ 274
041521             0025*  BUF_PAD: equ 275
041521             0026*  BUF_SEEKER_000: equ 276
041521             0027*  BUF_SEEKER_008: equ 277
041521             0028*  BUF_SEEKER_016: equ 278
041521             0029*  BUF_SEEKER_024: equ 279
041521             0030*  BUF_SEEKER_032: equ 280
041521             0031*  BUF_SEEKER_040: equ 281
041521             0032*  BUF_SEEKER_048: equ 282
041521             0033*  BUF_SEEKER_056: equ 283
041521             0034*  BUF_SEEKER_064: equ 284
041521             0035*  BUF_SEEKER_072: equ 285
041521             0036*  BUF_SEEKER_080: equ 286
041521             0037*  BUF_SEEKER_088: equ 287
041521             0038*  BUF_SEEKER_096: equ 288
041521             0039*  BUF_SEEKER_104: equ 289
041521             0040*  BUF_SEEKER_112: equ 290
041521             0041*  BUF_SEEKER_120: equ 291
041521             0042*  BUF_SEEKER_128: equ 292
041521             0043*  BUF_SEEKER_136: equ 293
041521             0044*  BUF_SEEKER_144: equ 294
041521             0045*  BUF_SEEKER_152: equ 295
041521             0046*  BUF_SEEKER_160: equ 296
041521             0047*  BUF_SEEKER_168: equ 297
041521             0048*  BUF_SEEKER_176: equ 298
041521             0049*  BUF_SEEKER_184: equ 299
041521             0050*  BUF_SEEKER_192: equ 300
041521             0051*  BUF_SEEKER_200: equ 301
041521             0052*  BUF_SEEKER_208: equ 302
041521             0053*  BUF_SEEKER_216: equ 303
041521             0054*  BUF_SEEKER_224: equ 304
041521             0055*  BUF_SEEKER_232: equ 305
041521             0056*  BUF_SEEKER_240: equ 306
041521             0057*  BUF_SEEKER_248: equ 307
041521             0058*  BUF_SHIP_0L: equ 308
041521             0059*  BUF_SHIP_1C: equ 309
041521             0060*  BUF_SHIP_2R: equ 310
041521             0061*  BUF_SHIP_SMALL: equ 311
041521             0062*  BUF_STAR: equ 312
041521             0063*  BUF_STATION_BG_00: equ 313
041521             0064*  BUF_STATION_BG_01: equ 314
041521             0065*  BUF_STATION_BG_02: equ 315
041521             0066*  BUF_STATION_BG_03: equ 316
041521             0067*  BUF_STATION_BG_04: equ 317
041521             0068*  BUF_STATION_BG_05: equ 318
041521             0069*  BUF_TURRET_000: equ 319
041521             0070*  BUF_TURRET_008: equ 320
041521             0071*  BUF_TURRET_016: equ 321
041521             0072*  BUF_TURRET_024: equ 322
041521             0073*  BUF_TURRET_032: equ 323
041521             0074*  BUF_TURRET_040: equ 324
041521             0075*  BUF_TURRET_048: equ 325
041521             0076*  BUF_TURRET_056: equ 326
041521             0077*  BUF_TURRET_064: equ 327
041521             0078*  BUF_TURRET_072: equ 328
041521             0079*  BUF_TURRET_080: equ 329
041521             0080*  BUF_TURRET_088: equ 330
041521             0081*  BUF_TURRET_096: equ 331
041521             0082*  BUF_TURRET_104: equ 332
041521             0083*  BUF_TURRET_112: equ 333
041521             0084*  BUF_TURRET_120: equ 334
041521             0085*  BUF_TURRET_128: equ 335
041521             0086*  BUF_TURRET_136: equ 336
041521             0087*  BUF_TURRET_144: equ 337
041521             0088*  BUF_TURRET_152: equ 338
041521             0089*  BUF_TURRET_160: equ 339
041521             0090*  BUF_TURRET_168: equ 340
041521             0091*  BUF_TURRET_176: equ 341
041521             0092*  BUF_TURRET_184: equ 342
041521             0093*  BUF_TURRET_192: equ 343
041521             0094*  BUF_TURRET_200: equ 344
041521             0095*  BUF_TURRET_208: equ 345
041521             0096*  BUF_TURRET_216: equ 346
041521             0097*  BUF_TURRET_224: equ 347
041521             0098*  BUF_TURRET_232: equ 348
041521             0099*  BUF_TURRET_240: equ 349
041521             0100*  BUF_TURRET_248: equ 350
041521             0101*  
041521             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
041521 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       CF 1B 04 00 
       01 00       
041533 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       E9 1B 04 01 
       01 00       
041545 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       03 1C 04 02 
       01 00       
041557 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       1D 1C 04 03 
       01 00       
041569 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       36 1C 04 04 
       01 00       
04157B 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       51 1C 04 05 
       01 00       
04158D 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       6C 1C 04 06 
       01 00       
04159F 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       84 1C 04 07 
       01 00       
0415B1 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       9F 1C 04 08 
       01 00       
0415C3 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       B4 1C 04 09 
       01 00       
0415D5 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       C9 1C 04 0A 
       01 00       
0415E7 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       E3 1C 04 0B 
       01 00       
0415F9 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       FD 1C 04 0C 
       01 00       
04160B 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       17 1D 04 0D 
       01 00       
04161D 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       31 1D 04 0E 
       01 00       
04162F 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       4B 1D 04 0F 
       01 00       
041641 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       64 1D 04 10 
       01 00       
041653 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       7D 1D 04 11 
       01 00       
041665 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       93 1D 04 12 
       01 00       
041677 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       A9 1D 04 13 
       01 00       
041689 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       BB 1D 04 14 
       01 00       
04169B 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       D4 1D 04 15 
       01 00       
0416AD 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       ED 1D 04 16 
       01 00       
0416BF 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       06 1E 04 17 
       01 00       
0416D1 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       1F 1E 04 18 
       01 00       
0416E3 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       38 1E 04 19 
       01 00       
0416F5 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       51 1E 04 1A 
       01 00       
041707 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       6A 1E 04 1B 
       01 00       
041719 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       83 1E 04 1C 
       01 00       
04172B 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       9C 1E 04 1D 
       01 00       
04173D 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       B5 1E 04 1E 
       01 00       
04174F 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       CE 1E 04 1F 
       01 00       
041761 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       E7 1E 04 20 
       01 00       
041773 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       00 1F 04 21 
       01 00       
041785 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       19 1F 04 22 
       01 00       
041797 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       32 1F 04 23 
       01 00       
0417A9 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       4B 1F 04 24 
       01 00       
0417BB 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       64 1F 04 25 
       01 00       
0417CD 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       7D 1F 04 26 
       01 00       
0417DF 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       96 1F 04 27 
       01 00       
0417F1 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       AF 1F 04 28 
       01 00       
041803 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       C8 1F 04 29 
       01 00       
041815 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       E1 1F 04 2A 
       01 00       
041827 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       FA 1F 04 2B 
       01 00       
041839 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       13 20 04 2C 
       01 00       
04184B 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       2C 20 04 2D 
       01 00       
04185D 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       45 20 04 2E 
       01 00       
04186F 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       5E 20 04 2F 
       01 00       
041881 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       77 20 04 30 
       01 00       
041893 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       90 20 04 31 
       01 00       
0418A5 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       A9 20 04 32 
       01 00       
0418B7 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       C2 20 04 33 
       01 00       
0418C9 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       DB 20 04 34 
       01 00       
0418DB 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       F1 20 04 35 
       01 00       
0418ED 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       07 21 04 36 
       01 00       
0418FF 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       1D 21 04 37 
       01 00       
041911 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       36 21 04 38 
       01 00       
041923 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       49 21 04 39 
       01 00       
041935 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       65 21 04 3A 
       01 00       
041947 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       81 21 04 3B 
       01 00       
041959 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       9D 21 04 3C 
       01 00       
04196B 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       B9 21 04 3D 
       01 00       
04197D 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       D5 21 04 3E 
       01 00       
04198F 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       F1 21 04 3F 
       01 00       
0419A1 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       0A 22 04 40 
       01 00       
0419B3 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       23 22 04 41 
       01 00       
0419C5 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       3C 22 04 42 
       01 00       
0419D7 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       55 22 04 43 
       01 00       
0419E9 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       6E 22 04 44 
       01 00       
0419FB 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       87 22 04 45 
       01 00       
041A0D 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       A0 22 04 46 
       01 00       
041A1F 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       B9 22 04 47 
       01 00       
041A31 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       D2 22 04 48 
       01 00       
041A43 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       EB 22 04 49 
       01 00       
041A55 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       04 23 04 4A 
       01 00       
041A67 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       1D 23 04 4B 
       01 00       
041A79 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       36 23 04 4C 
       01 00       
041A8B 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       4F 23 04 4D 
       01 00       
041A9D 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       68 23 04 4E 
       01 00       
041AAF 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       81 23 04 4F 
       01 00       
041AC1 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       9A 23 04 50 
       01 00       
041AD3 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       B3 23 04 51 
       01 00       
041AE5 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       CC 23 04 52 
       01 00       
041AF7 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       E5 23 04 53 
       01 00       
041B09 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       FE 23 04 54 
       01 00       
041B1B 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       17 24 04 55 
       01 00       
041B2D 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       30 24 04 56 
       01 00       
041B3F 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       49 24 04 57 
       01 00       
041B51 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       62 24 04 58 
       01 00       
041B63 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       7B 24 04 59 
       01 00       
041B75 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       94 24 04 5A 
       01 00       
041B87 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       AD 24 04 5B 
       01 00       
041B99 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       C6 24 04 5C 
       01 00       
041BAB 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       DF 24 04 5D 
       01 00       
041BBD 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       F8 24 04 5E 
       01 00       
041BCF             0198*  
041BCF             0199*  ; files_list: ; filename:
041BCF 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
041BE9 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
041C03 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
041C1D 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
041C36 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
041C51 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
041C6C 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
041C84 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
041C9F 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
041CB4 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
041CC9 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
041CE3 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
041CFD 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
041D17 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
041D31 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
041D4B 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
041D64 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
041D7D 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
041D93 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
041DA9 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
041DBB 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
041DD4 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
041DED 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
041E06 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
041E1F 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
041E38 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
041E51 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
041E6A 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
041E83 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
041E9C 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
041EB5 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
041ECE 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
041EE7 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
041F00 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
041F19 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
041F32 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
041F4B 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
041F64 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
041F7D 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
041F96 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
041FAF 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
041FC8 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
041FE1 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
041FFA 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042013 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
04202C 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
042045 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04205E 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
042077 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042090 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0420A9 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0420C2 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0420DB 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0420F1 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
042107 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
04211D 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
042136 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
042149 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
042165 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
042181 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
04219D 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
0421B9 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
0421D5 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
0421F1 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
04220A 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
042223 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
04223C 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
042255 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
04226E 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
042287 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
0422A0 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
0422B9 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0422D2 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0422EB 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
042304 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04231D 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
042336 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
04234F 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
042368 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042381 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04239A 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0423B3 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0423CC 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0423E5 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0423FE 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
042417 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
042430 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042449 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
042462 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04247B 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042494 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0424AD 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
0424C6 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0424DF 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0424F8 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
042511             0036       include "images_ui.inc"
042511             0001*  ; Generated by make_images.py
042511             0002*  
042511             0003*  ui_num_images: equ 4
042511             0004*  
042511             0005*  ; buffer_ids:
042511             0006*  BUF_BEZEL_L: equ 0
042511             0007*  BUF_BEZEL_R: equ 1
042511             0008*  BUF_SPLASH_BG: equ 2
042511             0009*  BUF_SPLASH_LOGO: equ 3
042511             0010*  
042511             0011*  ui_image_list: ; type; width; height; filename; bufferId:
042511 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       59 25 04 00 
       00 00       
042523 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       6A 25 04 01 
       00 00       
042535 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       7B 25 04 02 
       00 00       
042547 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       8E 25 04 03 
       00 00       
042559             0016*  
042559             0017*  ; files_list: ; filename:
042559 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
04256A 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
04257B 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04258E 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
0425A3             0037       include "laser.inc"
0425A3             0001*  ; ##### LASER SPRITE PARAMETERS #####
0425A3             0002*  ; uses the same offsets from its table base as the main sprite table:
0425A3             0003*  laser_start_variables: ; label marking beginning of table
0425A3 11          0004*  laser_id:               db table_max_records+1
0425A4 00          0005*  laser_type:             db 0x00 ; 1 bytes currently not used
0425A5 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0425A8 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0425AB 00          0008*  laser_collisions:       db 0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0425AC 00          0009*  laser_dim_x:            db 0x00 ; 1 bytes sprite width in pixels
0425AD 00          0010*  laser_dim_y:            db 0x00 ; 1 bytes sprite height in pixels
0425AE 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0425B1 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0425B4 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0425B7 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0425BA 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
0425BD 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0425C0 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
0425C3 00          0018*  laser_animation:        db 0x00 ; 1 bytes current sprite animation frame
0425C4 00          0019*  laser_animation_timer:  db 0x00 ; 1 bytes decremented every frame, when zero, advance animation
0425C5 00          0020*  laser_move_timer:       db 0x00 ; 1 bytes not currently used
0425C6 00          0021*  laser_move_step:        db 0x00 ; 1 bytes not currently used
0425C7 00          0022*  laser_points:           db 0x00 ; 1 bytes not currently used
0425C8 00          0023*  laser_shield_damage:    db 0x00 ; 1 bytes not currently used
0425C9             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
0425C9             0025*  
0425C9             0026*  ; laser_control:
0425C9             0027*  ; ; is laser already active?
0425C9             0028*  ;     ld a,(laser_collisions)
0425C9             0029*  ;     and %00000001 ; bit zero is lit if laser is active
0425C9             0030*  ;     jr nz,laser_move ; move laser if not zero
0425C9             0031*  ; ; otherwise check if laser fired
0425C9             0032*  ;     in a,(#82) ; keyboard
0425C9             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
0425C9             0034*  ;     ret z ; go back if laser not fired
0425C9             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
0425C9             0036*  ; ; set laser status to active (set bit 0)
0425C9             0037*  ;     ld a,%1
0425C9             0038*  ;     ld (laser_collisions),a
0425C9             0039*  ; ; initialize laser position
0425C9             0040*  ;     ld a,(player_x+1) ; we only need the integer part
0425C9             0041*  ;     ; add a,6 ; horizontal center with player sprite
0425C9             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
0425C9             0043*  ;     ld a,(player_y+1) ; we only need the integer part
0425C9             0044*  ;     add a,-6 ; set laser y a few pixels above player
0425C9             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
0425C9             0046*  ;     ; fall through to laser_move
0425C9             0047*  
0425C9             0048*  ; laser_move:
0425C9             0049*  ; ; begin setting laser to active sprite
0425C9             0050*  ;     ld hl,lasers
0425C9             0051*  ;     ld (sprite_base_bufferId),hl
0425C9             0052*  ;     ld hl,0 ; north
0425C9             0053*  ;     ld (sprite_heading),hl
0425C9             0054*  ;     xor a ; laser has no animations yet :-(
0425C9             0055*  ;     ld (sprite_animation),a
0425C9             0056*  ;     ; we set position here for the time being as a default
0425C9             0057*  ;     ; in case the laser is flagged for deletion
0425C9             0058*  ;     ; load sprite_x with laser x position (we do y further down)
0425C9             0059*  ;     ld hl,(laser_x)
0425C9             0060*  ;     ld (sprite_x),hl
0425C9             0061*  ; ; did laser just die?
0425C9             0062*  ;     ld a,(laser_collisions)
0425C9             0063*  ;     bit 1,a ; z if laser didn't just die
0425C9             0064*  ;     jr z,laser_not_dead_yet
0425C9             0065*  ; ; yes laser died
0425C9             0066*  ;     call kill_laser
0425C9             0067*  ;     ret ; done
0425C9             0068*  ; laser_not_dead_yet:
0425C9             0069*  ; ; draw it
0425C9             0070*  ; ; update laser y position
0425C9             0071*  ;     ld hl,(laser_y) ; grab laser y position
0425C9             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
0425C9             0073*  ;     add hl,de ; add y velocity to y pos
0425C9             0074*  ;     ld (sprite_y),hl ; update laser y position
0425C9             0075*  ;     ld (laser_y),hl ; update laser y position
0425C9             0076*  ; ; are we at top of screen?
0425C9             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
0425C9             0078*  ;     sub h ; no carry if above threshold
0425C9             0079*  ;     jr c,finally_draw_the_frikken_laser
0425C9             0080*  ;     ; if at top of screen,laser dies
0425C9             0081*  ;     call kill_laser
0425C9             0082*  ;     ret
0425C9             0083*  ; ; otherwise,finally draw the frikken laser
0425C9             0084*  ; finally_draw_the_frikken_laser:
0425C9             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0425C9             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0425C9             0087*  ; ; all done
0425C9             0088*  ;     ret
0425C9             0089*  
0425C9             0090*  ; kill_laser:
0425C9             0091*  ; ; update status to inactive
0425C9             0092*  ;     xor a ; zero out a
0425C9             0093*  ;     ld (laser_collisions),a
0425C9             0094*  ;     ret
0425C9             0038       include "levels.inc"
0425C9 00          0001*  tiles_level_00: db 0 ; number of rows, 0 is max of 256
0425CA 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0425DA 00 00 00 00 0003*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
0425EA 00 00 00 00 0004*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
0425FA 00 00 00 07 0005*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04260A 00 00 00 03 0006*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
04261A 00 00 00 03 0007*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04262A 00 00 00 01 0008*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04263A 00 00 00 03 0009*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
04264A 00 00 00 03 0010*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
04265A 01 02 02 01 0011*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04266A 03 04 05 03 0012*      db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
04267A 03 05 04 03 0013*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
04268A 01 02 02 01 0014*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
04269A 00 00 00 00 0015*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0426AA 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0426BA 00 00 00 00 0017*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0426CA 00 00 00 00 0018*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0426DA 00 00 00 00 0019*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0426EA 00 00 00 00 0020*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0426FA 00 00 00 00 0021*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
04270A 00 00 00 00 0022*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
04271A 00 00 00 00 0023*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
04272A 00 00 00 00 0024*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
04273A 00 00 00 00 0025*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04274A 00 00 00 00 0026*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
04275A 00 00 00 00 0027*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04276A 00 00 00 01 0028*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
04277A 00 00 00 03 0029*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04278A 00 00 00 03 0030*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04279A 00 00 00 01 0031*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0427AA 00 00 00 03 0032*      db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0427BA 00 00 00 03 0033*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0427CA 00 00 00 01 0034*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0427DA 00 00 00 00 0035*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0427EA 00 00 00 00 0036*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0427FA 00 00 00 00 0037*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
04280A 00 00 00 00 0038*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04281A 00 00 00 00 0039*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04282A 00 00 00 00 0040*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04283A 00 00 00 00 0041*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04284A 00 00 00 00 0042*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04285A 00 00 00 01 0043*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04286A 00 00 00 03 0044*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04287A 00 00 00 03 0045*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04288A 07 02 02 01 0046*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04289A 03 00 00 03 0047*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428AA 03 00 00 03 0048*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428BA 01 02 02 01 0049*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0428CA 00 00 00 03 0050*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428DA 00 00 00 03 0051*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428EA 00 00 00 06 0052*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
0428FA 00 00 00 00 0053*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04290A 00 00 00 00 0054*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04291A 00 00 00 00 0055*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
04292A 00 00 00 00 0056*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04293A 00 00 00 00 0057*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04294A 00 00 00 01 0058*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04295A 00 00 00 03 0059*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04296A 00 00 00 03 0060*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04297A 00 00 00 01 0061*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04298A 00 00 00 03 0062*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04299A 00 00 00 03 0063*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429AA 00 00 00 07 0064*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0429BA 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429CA 00 00 00 00 0066*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429DA 00 00 00 00 0067*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0429EA 00 00 00 00 0068*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429FA 00 00 00 00 0069*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042A0A 00 00 00 00 0070*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042A1A 00 00 00 00 0071*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
042A2A 00 00 00 00 0072*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
042A3A 00 00 00 00 0073*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
042A4A 00 00 00 00 0074*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042A5A 00 00 00 00 0075*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042A6A 00 00 00 00 0076*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042A7A 00 00 00 00 0077*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042A8A 00 00 00 00 0078*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042A9A 00 00 00 07 0079*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
042AAA 00 00 00 03 0080*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042ABA 00 00 00 03 0081*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042ACA 00 00 00 01 0082*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042ADA 00 00 00 03 0083*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042AEA 00 00 00 03 0084*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
042AFA 00 00 00 01 0085*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
042B0A 00 00 00 00 0086*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042B1A 00 00 00 00 0087*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042B2A 00 00 00 00 0088*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042B3A 00 00 00 00 0089*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
042B4A 00 00 00 00 0090*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
042B5A 00 00 00 00 0091*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
042B6A 00 00 00 00 0092*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042B7A 00 00 00 00 0093*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042B8A 00 00 00 00 0094*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
042B9A 00 00 00 00 0095*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
042BAA 00 00 00 00 0096*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
042BBA 00 00 00 01 0097*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
042BCA 00 00 00 03 0098*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042BDA 00 00 00 03 0099*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042BEA 00 00 00 01 0100*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
042BFA 01 02 02 01 0101*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C0A 03 00 00 03 0102*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C1A 03 00 00 03 0103*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C2A 01 02 02 07 0104*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C3A 03 00 00 03 0105*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C4A 03 00 00 03 0106*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C5A 01 02 02 01 0107*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042C6A 03 00 04 03 0108*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C7A 03 04 00 03 0109*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C8A 01 02 02 01 0110*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
042C9A 03 00 00 03 0111*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042CAA 03 00 04 03 0112*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042CBA 01 02 02 01 0113*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
042CCA 00 00 00 03 0114*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042CDA 00 00 00 03 0115*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042CEA 00 00 00 01 0116*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
042CFA 00 00 00 00 0117*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
042D0A 00 00 00 00 0118*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
042D1A 00 00 00 00 0119*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042D2A 00 00 00 00 0120*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D3A 00 00 00 00 0121*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D4A 00 00 00 00 0122*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
042D5A 00 00 00 00 0123*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
042D6A 00 00 00 00 0124*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
042D7A 00 00 00 00 0125*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
042D8A 00 00 00 00 0126*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D9A 00 00 00 00 0127*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042DAA 00 00 00 00 0128*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042DBA 00 00 00 00 0129*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042DCA 00 00 00 00 0130*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042DDA 00 00 00 01 0131*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042DEA 00 00 00 03 0132*      db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
042DFA 00 00 00 03 0133*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
042E0A 01 02 02 07 0134*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042E1A 03 04 00 03 0135*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E2A 03 05 04 03 0136*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E3A 01 02 02 01 0137*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E4A 03 00 00 03 0138*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E5A 03 00 00 03 0139*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E6A 01 02 02 01 0140*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042E7A 03 00 00 03 0141*      db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
042E8A 03 00 00 03 0142*      db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
042E9A 01 02 02 01 0143*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
042EAA 00 00 00 03 0144*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042EBA 00 00 00 03 0145*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042ECA 00 00 00 06 0146*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042EDA 00 00 00 00 0147*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
042EEA 00 00 00 00 0148*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
042EFA 00 00 00 00 0149*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
042F0A 00 00 00 00 0150*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042F1A 00 00 00 00 0151*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042F2A 00 00 00 00 0152*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
042F3A 00 00 00 00 0153*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
042F4A 00 00 00 00 0154*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
042F5A 00 00 00 00 0155*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
042F6A 00 00 00 00 0156*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
042F7A 00 00 00 00 0157*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
042F8A 00 00 00 00 0158*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
042F9A 00 00 00 00 0159*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042FAA 00 00 00 00 0160*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042FBA 00 00 00 00 0161*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
042FCA 00 00 00 00 0162*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
042FDA 00 00 00 00 0163*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
042FEA 00 00 00 00 0164*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
042FFA 00 00 00 00 0165*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04300A 00 00 00 00 0166*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04301A 00 00 00 01 0167*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
04302A 00 00 00 03 0168*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
04303A 00 00 00 03 0169*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
04304A 00 00 00 01 0170*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
04305A 01 02 02 07 0171*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04306A 03 00 00 03 0172*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04307A 03 00 00 03 0173*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04308A 01 02 02 01 0174*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04309A 03 04 04 03 0175*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430AA 03 04 04 03 0176*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430BA 01 02 02 01 0177*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430CA 03 00 00 03 0178*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430DA 03 00 00 03 0179*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430EA 01 02 02 01 0180*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430FA 03 00 00 03 0181*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04310A 03 00 00 03 0182*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04311A 01 02 02 07 0183*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04312A 03 00 00 03 0184*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04313A 03 00 00 03 0185*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04314A 01 02 02 01 0186*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04315A 00 00 00 03 0187*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
04316A 00 00 00 03 0188*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
04317A 00 00 00 01 0189*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04318A 00 00 00 03 0190*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04319A 00 00 00 03 0191*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0431AA 00 00 00 01 0192*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0431BA 00 00 00 03 0193*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431CA 00 00 00 03 0194*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431DA 00 00 00 01 0195*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0431EA 00 00 00 03 0196*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
0431FA 00 00 00 03 0197*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
04320A 00 00 00 01 0198*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04321A 00 00 00 03 0199*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04322A 00 00 00 03 0200*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04323A 00 00 00 07 0201*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04324A 00 00 00 03 0202*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04325A 00 00 00 03 0203*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04326A 00 00 00 01 0204*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04327A 00 00 00 00 0205*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04328A 00 00 00 00 0206*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04329A 00 00 00 00 0207*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0432AA 00 00 00 00 0208*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0432BA 00 00 00 00 0209*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0432CA 00 00 00 00 0210*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0432DA 00 00 00 00 0211*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
0432EA 00 00 00 00 0212*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
0432FA 00 00 00 00 0213*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
04330A 00 00 00 00 0214*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
04331A 00 00 00 00 0215*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
04332A 00 00 00 00 0216*      db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
04333A 00 00 00 00 0217*      db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
04334A 00 00 00 01 0218*      db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
04335A 00 00 01 05 0219*      db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
04336A 01 02 02 07 0220*      db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
04337A 03 00 00 03 0221*      db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
04338A 03 00 00 03 0222*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04339A 01 02 02 01 0223*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0433AA 03 00 00 03 0224*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433BA 03 00 00 03 0225*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433CA 01 02 02 01 0226*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0433DA 00 00 00 03 0227*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433EA 00 00 00 03 0228*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433FA 00 00 00 01 0229*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04340A 00 00 00 03 0230*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04341A 00 00 00 03 0231*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04342A 00 00 00 01 0232*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04343A 00 00 00 03 0233*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04344A 00 00 00 03 0234*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04345A 01 02 02 01 0235*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
04346A 03 00 00 03 0236*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04347A 03 00 00 03 0237*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04348A 07 02 02 01 0238*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04349A 00 00 00 03 0239*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0434AA 00 00 00 03 0240*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0434BA 00 00 00 01 0241*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0434CA 00 00 00 03 0242*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434DA 00 00 00 03 0243*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434EA 00 00 00 01 0244*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
0434FA 00 00 00 00 0245*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04350A 00 00 00 00 0246*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04351A 00 00 00 00 0247*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04352A 00 00 00 00 0248*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
04353A 00 00 00 00 0249*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
04354A 00 00 00 01 0250*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04355A 00 00 00 03 0251*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04356A 00 00 00 03 0252*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04357A 01 02 02 07 0253*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
04358A 03 05 05 03 0254*      db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
04359A 03 04 04 03 0255*      db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0435AA 01 02 02 06 0256*      db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0435BA 00 00 00 00 0257*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435CA             0258*  
0435CA             0259*  
0435CA 10          0260*  tiles_level_01: db 16 ; number of rows, 0 is max of 256
0435CB 00 00 00 00 0261*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435DB 00 00 00 00 0262*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435EB 00 00 00 00 0263*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435FB 00 00 00 00 0264*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04360B 00 00 00 00 0265*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04361B 00 00 00 00 0266*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04362B 00 00 00 00 0267*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04363B 00 00 00 00 0268*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04364B 00 00 00 00 0269*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04365B 00 00 00 00 0270*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04366B 00 00 00 00 0271*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04367B 00 00 00 00 0272*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04368B 00 00 00 00 0273*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04369B 00 00 00 00 0274*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0436AB 00 00 00 00 0275*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0436BB 00 00 00 00 0276*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0436CB             0277*  
0436CB             0039       include "player.inc"
0436CB             0001*  ; ######## GAME STATE VARIABLES #######
0436CB             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
0436CB 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
0436CE             0004*  ; player current shields,binary
0436CE             0005*  ; when < 0 player splodes
0436CE             0006*  ; restores to player_max_shields when new ship spawns
0436CE 10          0007*  player_shields: db 16 ; binary
0436CF             0008*  ; max player shields,binary
0436CF             0009*  ; can increase with power-ups (todo)
0436CF 10          0010*  player_max_shields: db 16 ; binary
0436D0             0011*  ; when reaches zero,game ends
0436D0             0012*  ; can increase based on TODO
0436D0 03          0013*  player_ships: db 0x03 ; binary
0436D1             0014*  
0436D1             0015*  speed_player: equ 0x000300 ; 3 pixels per frame
0436D1             0016*  
0436D1             0017*  ; ######### PLAYER SPRITE PARAMETERS ##########
0436D1             0018*  ; uses the same offsets from its table base as the main sprite table:
0436D1             0019*  player_start_variables: ; label marking beginning of table
0436D1 10          0020*  player_id:               db table_max_records
0436D2 00          0021*  player_type:             db     0x00 ; 1 bytes currently not used
0436D3 34 01 00    0022*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
0436D6 00 00 00    0023*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0436D9 00          0024*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0436DA 00          0025*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0436DB 00          0026*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0436DC 00 00 00    0027*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0436DF 00 00 00    0028*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0436E2 00 00 00    0029*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0436E5 00 00 00    0030*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0436E8 00 00 00    0031*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0436EB 00 00 00    0032*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0436EE 00 00 00    0033*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
0436F1 00          0034*  player_animation:        db     0x00 ; 1 bytes not currently used
0436F2 00          0035*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
0436F3 00          0036*  player_move_timer:       db     0x00 ; 1 bytes not currently used
0436F4 00          0037*  player_move_step:        db     0x00 ; 1 bytes not currently used
0436F5 00          0038*  player_points:           db     0x00 ; 1 bytes not currently used
0436F6 00          0039*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
0436F7             0040*  player_end_variables: ; for when we want to traverse this table in reverse
0436F7             0041*  
0436F7             0042*  ; set initial player position
0436F7             0043*  ; inputs: none,everything is hardcoded
0436F7             0044*  ; outputs: player_x/y set to bottom-left corner of screen
0436F7             0045*  ; destroys: a
0436F7             0046*  player_init:
0436F7 3A D1 36 04 0047*  	ld a,(player_id)
0436FB CD 02 43 04 0048*  	call vdu_sprite_select
0436FF CD 15 43 04 0049*      call vdu_sprite_clear_frames
043703 21 34 01 00 0050*      ld hl,BUF_SHIP_0L
043707 CD 57 44 04 0051*      call vdu_sprite_add_buff
04370B 21 35 01 00 0052*      ld hl,BUF_SHIP_1C
04370F CD 57 44 04 0053*      call vdu_sprite_add_buff
043713 21 36 01 00 0054*      ld hl,BUF_SHIP_2R
043717 CD 57 44 04 0055*      call vdu_sprite_add_buff
04371B 01 00 00 00 0056*      ld bc,0
04371F ED 43 DC 36 0057*      ld (player_x),bc
       04          
043724 11 00 6F 01 0058*      ld de,sprite_bottom*256 ; max sprite y-coordinate
043728 ED 53 DF 36 0059*      ld (player_y),de
       04          
04372D CD CE 43 04 0060*      call vdu_sprite_move_abs168
043731 CD 78 43 04 0061*      call vdu_sprite_show
043735 C9          0062*      ret
043736             0063*  
043736             0064*  ; process player keyboard input, set player bitmap
043736             0065*  ; velocities and draw player bitmap at updated coordinates
043736             0066*  ; Inputs: player_x/y set at desired position
043736             0067*  ; Returns: player bitmap drawn at updated position
043736             0068*  ; Destroys: probably everything except maybe iy
043736             0069*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
043736             0070*  ; TODO: requires sprite implementation
043736             0071*  player_input:
043736             0072*  ; reset player component velocities to zero as the default
043736 21 00 00 00 0073*  	ld hl,0
04373A 22 E2 36 04 0074*  	ld (player_xvel),hl
04373E 22 E5 36 04 0075*  	ld (player_yvel),hl
043742             0076*  ; make ship the active sprite
043742 3A D1 36 04 0077*      ld a,(player_id)
043746 CD 02 43 04 0078*      call vdu_sprite_select
04374A             0079*  ; check for keypresses and branch accordingly
04374A             0080*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04374A             0081*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04374A 3E 1E       0001*M 			LD	A, function
04374C 5B CF       0002*M 			RST.LIL	08h
04374E             0082*  ; we test all four arrow keys and add/subract velocities accordingly
04374E             0083*  ; this handles the case where two opposing movement keys
04374E             0084*  ; are down simultaneously (velocities will net to zero)
04374E             0085*  ; and allows diagonal movement when a vertical and horizontal key are down
04374E             0086*  ; it also allows movement and action keys to be detected simultaneously
04374E             0087*  ; so we can walk and chew gum at the same time
04374E 3E 01       0088*      ld a,1 ; set ship's default animation to center
043750             0089*          ; if left and right are both down a will net to
043750             0090*  
043750             0091*  @left:
043750 DD CB 03 4E 0092*      bit 1,(ix+3) ; keycode 26
043754 28 0E       0093*      jr z,@right
043756 2A E2 36 04 0094*      ld hl,(player_xvel)
04375A 01 00 FD FF 0095*      ld bc,-speed_player
04375E 09          0096*      add hl,bc
04375F 22 E2 36 04 0097*      ld (player_xvel),hl
043763 3D          0098*      dec a ; set ship's animation to left
043764             0099*  @right:
043764 DD CB 0F 4E 0100*      bit 1,(ix+15) ; keycode 122
043768 28 0E       0101*  	jr z,@up
04376A 2A E2 36 04 0102*      ld hl,(player_xvel)
04376E 01 00 03 00 0103*      ld bc,speed_player
043772 09          0104*      add hl,bc
043773 22 E2 36 04 0105*      ld (player_xvel),hl
043777 3C          0106*      inc a ; set ship's animation to right
043778             0107*  @up:
043778 DD CB 07 4E 0108*      bit 1,(ix+7) ; keycode 58
04377C 28 0D       0109*  	jr z,@down
04377E 2A E5 36 04 0110*      ld hl,(player_yvel)
043782 01 00 FD FF 0111*      ld bc,-speed_player
043786 09          0112*      add hl,bc
043787 22 E5 36 04 0113*      ld (player_yvel),hl
04378B             0114*  @down:
04378B DD CB 05 4E 0115*      bit 1,(ix+5) ; keycode 42
04378F 28 0D       0116*  	jr z,@done_keyboard
043791 2A E5 36 04 0117*      ld hl,(player_yvel)
043795 01 00 03 00 0118*      ld bc,speed_player
043799 09          0119*      add hl,bc
04379A 22 E5 36 04 0120*      ld (player_yvel),hl
04379E             0121*  @done_keyboard:
04379E             0122*  ; a should land here loaded with the correct frame
04379E CD 65 43 04 0123*      call vdu_sprite_select_frame
0437A2             0124*  ; draw player at updated position
0437A2 FD 21 D1 36 0125*      ld iy,player_start_variables
       04          
0437A7 FD 22 1F 3A 0126*      ld (table_pointer),iy
       04          
0437AC CD D3 3A 04 0127*      call move_sprite
0437B0 ED 4B DC 36 0128*      ld bc,(player_x)
       04          
0437B5 ED 5B DF 36 0129*      ld de,(player_y)
       04          
0437BA CD CE 43 04 0130*  	call vdu_sprite_move_abs168
0437BE             0131*  ; end player_input
0437BE C9          0132*  	ret
0437BF             0133*  
0437BF             0134*  ; ###################################################################
0437BF             0135*  ; TODO: the below is all stuff from the original code we need to port
0437BF             0136*  ; ###################################################################
0437BF             0137*  
0437BF             0138*  ; kill_player:
0437BF             0139*  ; ; set player status to dead
0437BF             0140*  ;     xor a; sets all player flags to zero
0437BF             0141*  ;     ld (player_collisions),a
0437BF             0142*  ; ; deduct a ship from the inventory
0437BF             0143*  ;     ld a,(player_ships)
0437BF             0144*  ;     dec a
0437BF             0145*  ;     ld (player_ships),a
0437BF             0146*  ; ; are we out of ships?
0437BF             0147*  ;     jp z,game_over
0437BF             0148*  ; ; wait a few ticks
0437BF             0149*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
0437BF             0150*  ;     ld (player_move_timer),a
0437BF             0151*  ; kill_player_loop:
0437BF             0152*  ;     call vdu_vblank
0437BF             0153*  ;     ld a,(player_move_timer)
0437BF             0154*  ;     dec a
0437BF             0155*  ;     ld (player_move_timer),a
0437BF             0156*  ;     jr nz,kill_player_loop
0437BF             0157*  ;     call player_init ; player respawn if timer zero
0437BF             0158*  ;     ret ; and out
0437BF             0159*  
0437BF             0160*  
0437BF             0161*  ; player_move:
0437BF             0162*  ; ; begin setting player to active sprite
0437BF             0163*  ;     ld hl,player
0437BF             0164*  ;     ld (sprite_base_bufferId),hl
0437BF             0165*  ;     ld hl,0 ; north
0437BF             0166*  ;     ld (sprite_heading),hl
0437BF             0167*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
0437BF             0168*  ;     ld (sprite_animation),a
0437BF             0169*  ;     ; we set position here for the time being as a default
0437BF             0170*  ;     ; in case the player doesn't move,or is flagged for deletion
0437BF             0171*  ;     ld hl,(player_x)
0437BF             0172*  ;     ld (sprite_x),hl
0437BF             0173*  ;     ld hl,(player_y)
0437BF             0174*  ;     ld (sprite_y),hl
0437BF             0175*  ; ; did we just die?
0437BF             0176*  ;     ld a,(player_collisions)
0437BF             0177*  ;     and %00000010 ; zero flag will be set if not dead
0437BF             0178*  ;     jr z,player_not_dead
0437BF             0179*  ; ; yes we died
0437BF             0180*  ;     call kill_player
0437BF             0181*  ;     ret ; done
0437BF             0182*  ; ; yay we didn't die
0437BF             0183*  ; player_not_dead:
0437BF             0184*  ; ; set player movements to zero by default
0437BF             0185*  ;     ld hl,0
0437BF             0186*  ;     ld (player_xvel),hl
0437BF             0187*  ;     ld (player_yvel),hl
0437BF             0188*  ; ; do we move it?
0437BF             0189*  ;     in a,(#82) ; keyboard
0437BF             0190*  ;     or a ; if zero,don't move
0437BF             0191*  ;     jr z,player_draw
0437BF             0192*  ; ; move it
0437BF             0193*  ;     call player_move_calc
0437BF             0194*  ; player_draw:
0437BF             0195*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0437BF             0196*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0437BF             0197*  ; player_move_done:
0437BF             0198*  ;     ; write updated x,y coordinates back to player table
0437BF             0199*  ;     ld hl,(sprite_x)
0437BF             0200*  ;     ld (player_x),hl
0437BF             0201*  ;     ld hl,(sprite_y)
0437BF             0202*  ;     ld (player_y),hl
0437BF             0203*  ;     ret
0437BF             0040       include "sprites.inc"
0437BF             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0437BF             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0437BF             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0437BF             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0437BF             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0437BF             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0437BF             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0437BF             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0437BF             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0437BF             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0437BF             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0437BF             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0437BF             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0437BF             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0437BF             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0437BF             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0437BF             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0437BF             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0437BF             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0437BF             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0437BF             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0437BF             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0437BF             0023*  
0437BF             0024*  ; ###### SPRITE TABLE VARIABLES ######
0437BF             0025*  ; maximum number of sprites
0437BF             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
0437BF             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0437BF             0028*  
0437BF             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0437BF             0030*  table_base:
0437BF 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A1F             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
043A1F             0033*  
043A1F             0034*  ; pointer to top address of current record, initialized to table_base
043A1F BF 37 04    0035*  table_pointer: dl table_base
043A22             0036*  ; how many active sprites
043A22 00          0037*  table_active_sprites: db 0x00
043A23             0038*  ; flag indicating collision with screen edge
043A23             0039*  ; uses orientation codes to specify which edge(s)
043A23 00          0040*  sprite_screen_edge: db #00
043A24             0041*  ; next sprite id to use
043A24 00          0042*  sprite_next_id: db 0
043A25             0043*  
043A25             0044*  ; origin_top: equ 48
043A25             0045*  origin_top: equ 0 ; DEBUG
043A25             0046*  origin_left: equ 128
043A25             0047*  field_top: equ 0
043A25             0048*  field_bottom: equ 383-origin_top
043A25             0049*  field_left: equ 0
043A25             0050*  field_right: equ 255
043A25             0051*  sprite_top: equ 0
043A25             0052*  sprite_bottom: equ field_bottom-16
043A25             0053*  sprite_left: equ field_left
043A25             0054*  sprite_right: equ field_right-16
043A25             0055*  collide_top: equ %00001000
043A25             0056*  collide_bottom: equ %00000100
043A25             0057*  collide_left: equ %00000010
043A25             0058*  collide_right: equ %00000001
043A25             0059*  
043A25             0060*  ; ######### COLLISION SPRITE PARAMETERS ##########
043A25             0061*  ; integer coordinates are all that are needed for collision calculations
043A25 00          0062*  collision_x: db 0x00
043A26 00          0063*  collision_y: db 0x00
043A27 00          0064*  collision_dim_x: db 0x00
043A28 00          0065*  collision_dim_y: db 0x00
043A29             0066*  
043A29             0067*  ; scratch variables
043A29 00          0068*  x: db 0x00 ; 8-bit signed integer
043A2A 00          0069*  y: db 0x00 ; 8-bit signed integer
043A2B 00 00 00    0070*  x0: dl 0x000000 ; 16.8 signed fixed place
043A2E 00 00 00    0071*  y0: dl 0x000000 ; 16.8 signed fixed place
043A31 00 00 00    0072*  incx1: dl 0x000000 ; 16.8 signed fixed place
043A34 00 00 00    0073*  incy1: dl 0x000000 ; 16.8 signed fixed place
043A37 00 00 00    0074*  incx2: dl 0x000000 ; 16.8 signed fixed place
043A3A 00 00 00    0075*  incy2: dl 0x000000 ; 16.8 signed fixed place
043A3D             0076*  
043A3D             0077*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
043A3D 00 00 00    0078*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
043A40 00 00 00    0079*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
043A43 00 00 00    0080*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
043A46             0081*  
043A46             0082*  ; gets the next available sprite id
043A46             0083*  ; inputs; none
043A46             0084*  ; returns: if new sprite available, a = sprite id,
043A46             0085*  ;           ix pointing to new sprite vars, carry set
043A46             0086*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
043A46             0087*  ; destroys: a,b,hl,ix
043A46             0088*  ; affects: bumps table_active_sprites by one
043A46             0089*  table_get_next_id:
043A46 DD 21 BF 37 0090*      ld ix,table_base
       04          
043A4B 11 26 00 00 0091*      ld de,table_bytes_per_record
043A4F 06 10       0092*      ld b,table_max_records
043A51             0093*  @loop:
043A51 DD 7E 01    0094*      ld a,(ix+sprite_type)
043A54 A7          0095*      and a
043A55 28 06       0096*      jr z,@found
043A57 DD 19       0097*      add ix,de
043A59 10 F6       0098*      djnz @loop
043A5B             0099*  @notfound:
043A5B AF          0100*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
043A5C C9          0101*      ret
043A5D             0102*  @found:
043A5D             0103*  ; bump number of active sprites
043A5D 21 22 3A 04 0104*      ld hl,table_active_sprites
043A61 34          0105*      inc (hl)
043A62             0106*  ; return sprite id
043A62 3E 10       0107*      ld a,table_max_records
043A64 90          0108*      sub b
043A65 32 24 3A 04 0109*      ld (sprite_next_id),a
043A69 37          0110*      scf ; sets carry flag indicating we found a free sprite
043A6A C9          0111*      ret ; done
043A6B             0112*  
043A6B             0113*  ; deactivate the sprite with the given id
043A6B             0114*  ; inputs: a = sprite id
043A6B             0115*  ; outputs: nothing
043A6B             0116*  ; destroys: a,ix,de
043A6B             0117*  ; affects: decrements table_active_sprites by one
043A6B             0118*  table_deactivate_sprite:
043A6B F5          0119*      push af ; save sprite id bc we need it later
043A6C CD 02 43 04 0120*      call vdu_sprite_select
043A70 CD 86 43 04 0121*      call vdu_sprite_hide
043A74 F1          0122*      pop af ; restore sprite id
043A75 11 00 00 00 0123*      ld de,0 ; clear deu
043A79 57          0124*      ld d,a
043A7A 1E 26       0125*      ld e,table_bytes_per_record
043A7C ED 5C       0126*      mlt de
043A7E DD 21 BF 37 0127*      ld ix,table_base
       04          
043A83 DD 19       0128*      add ix,de
043A85 AF          0129*      xor a
043A86 DD 77 01    0130*      ld (ix+sprite_type),a
043A89 DD 21 22 3A 0131*      ld ix,table_active_sprites
       04          
043A8E DD 35 00    0132*      dec (ix)
043A91 C9          0133*      ret
043A92             0134*  
043A92             0135*  sprites_init:
043A92             0136*  ; initialize sprites
043A92 CD 36 44 04 0137*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
043A96 AF          0138*  	xor a
043A97             0139*  @sprite_loop:
043A97 F5          0140*  	push af
043A98 CD 02 43 04 0141*  	call vdu_sprite_select
043A9C 21 00 01 00 0142*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
043AA0 CD 57 44 04 0143*  	call vdu_sprite_add_buff
043AA4 F1          0144*  	pop af
043AA5 3C          0145*  	inc a
043AA6 FE 12       0146*  	cp table_max_records+2 ; tack on sprites for player and laser
043AA8 20 ED       0147*  	jr nz,@sprite_loop
043AAA 3C          0148*  	inc a
043AAB CD 36 43 04 0149*  	call vdu_sprite_activate
043AAF             0150*  
043AAF             0151*  ; define player sprite
043AAF 3A D1 36 04 0152*  	ld a,(player_id)
043AB3 CD 02 43 04 0153*  	call vdu_sprite_select
043AB7 CD 15 43 04 0154*  	call vdu_sprite_clear_frames
043ABB 21 34 01 00 0155*  	ld hl,BUF_SHIP_0L
043ABF 01 03 00 00 0156*  	ld bc,3 ; three bitmaps for player ship
043AC3             0157*  @sprite_player_loop:
043AC3 C5          0158*  	push bc
043AC4 E5          0159*  	push hl
043AC5 CD 57 44 04 0160*  	call vdu_sprite_add_buff
043AC9 E1          0161*  	pop hl
043ACA 23          0162*  	inc hl
043ACB C1          0163*  	pop bc
043ACC 10 F5       0164*  	djnz @sprite_player_loop
043ACE CD 78 43 04 0165*  	call vdu_sprite_show
043AD2             0166*  
043AD2             0167*  ; all done
043AD2 C9          0168*      ret
043AD3             0169*  
043AD3             0170*  ; compute a sprite's new position based on its component x,y velocities
043AD3             0171*  ; with screen boundary checking and update its sprite table record accordingly
043AD3             0172*  ; inputs: iy pointing to sprite table record
043AD3             0173*  ; returns: updated x, y positions and edge collision flags in sprite table record
043AD3             0174*  ; destroys: everything
043AD3             0175*  ; note: actual rendering of sprite must be handled by caller
043AD3             0176*  move_sprite:
043AD3 FD 2A 1F 3A 0177*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043AD8             0178*  ; x-axis movement
043AD8 FD 27 0B    0179*      ld hl,(iy+sprite_x)
043ADB FD 17 11    0180*      ld de,(iy+sprite_xvel)
043ADE 19          0181*      add hl,de
043ADF FD 2F 0B    0182*      ld (iy+sprite_x),hl
043AE2             0183*  ; y-axis movement
043AE2 FD 27 0E    0184*      ld hl,(iy+sprite_y)
043AE5 FD 17 14    0185*      ld de,(iy+sprite_yvel)
043AE8 19          0186*      add hl,de
043AE9 FD 2F 0E    0187*      ld (iy+sprite_y),hl
043AEC             0188*  ; detect screen edge collisions
043AEC AF          0189*      xor a ; reset screen edge collision flag and clear carry
043AED 32 23 3A 04 0190*      ld (sprite_screen_edge),a
043AF1             0191*  ; y-axis first since we already have it in hl
043AF1 11 00 00 00 0192*      ld de,-sprite_top*256
043AF5 ED 5A       0193*      adc hl,de
043AF7 FA 21 3B 04 0194*      jp m,@top
043AFB ED 52       0195*      sbc hl,de ; hl back to original value
043AFD 11 00 91 FE 0196*      ld de,-sprite_bottom*256
043B01 ED 5A       0197*      adc hl,de
043B03 F2 2B 3B 04 0198*      jp p,@bottom
043B07             0199*  @xaxis:
043B07 FD 27 0B    0200*      ld hl,(iy+sprite_x)
043B0A 11 00 00 00 0201*      ld de,-sprite_left*256
043B0E ED 5A       0202*      adc hl,de
043B10 FA 46 3B 04 0203*      jp m,@left
043B14 ED 52       0204*      sbc hl,de ; hl back to original value
043B16 11 00 11 FF 0205*      ld de,-sprite_right*256
043B1A ED 5A       0206*      adc hl,de
043B1C F2 54 3B 04 0207*      jp p,@right
043B20             0208*  ; no edge collisions so go home
043B20 C9          0209*      ret
043B21             0210*  @top:
043B21 3E 08       0211*      ld a,collide_top
043B23 21 00 00 00 0212*      ld hl,sprite_top*256
043B27 C3 31 3B 04 0213*      jp @collide_y
043B2B             0214*  @bottom:
043B2B 3E 04       0215*      ld a,collide_bottom
043B2D 21 00 6F 01 0216*      ld hl,sprite_bottom*256
043B31             0217*  @collide_y:
043B31 32 23 3A 04 0218*      ld (sprite_screen_edge),a
043B35 FD 2F 0E    0219*      ld (iy+sprite_y),hl
043B38             0220*  ; reverse y-axis velocity
043B38 FD 27 14    0221*      ld hl,(iy+sprite_yvel)
043B3B CD A4 06 04 0222*      call neg_hlu
043B3F FD 2F 14    0223*      ld (iy+sprite_yvel),hl
043B42             0224*  ; go check for x-axis collisions
043B42 C3 07 3B 04 0225*      jp @xaxis
043B46             0226*  @left:
043B46 3A 23 3A 04 0227*      ld a,(sprite_screen_edge)
043B4A F6 02       0228*      or a,collide_left
043B4C 21 00 00 00 0229*      ld hl,sprite_left*256
043B50 C3 5E 3B 04 0230*      jp @collide_x
043B54             0231*  @right:
043B54 3A 23 3A 04 0232*      ld a,(sprite_screen_edge)
043B58 F6 01       0233*      or a,collide_right
043B5A 21 00 EF 00 0234*      ld hl,sprite_right*256
043B5E             0235*  @collide_x:
043B5E 32 23 3A 04 0236*      ld (sprite_screen_edge),a
043B62 FD 2F 0B    0237*      ld (iy+sprite_x),hl
043B65             0238*  ; reverse x-axis velocity
043B65 FD 27 11    0239*      ld hl,(iy+sprite_xvel)
043B68 CD A4 06 04 0240*      call neg_hlu
043B6C FD 2F 11    0241*      ld (iy+sprite_xvel),hl
043B6F             0242*  ; final collision flag to a and return
043B6F 3A 23 3A 04 0243*      ld a,(sprite_screen_edge)
043B73 C9          0244*      ret
043B74             0041       include "state.inc"
043B74             0001*  ; player state variables
043B74 83 3B 04    0002*  player_state: dl player_alive
043B77             0003*  
043B77             0004*  player_do:
043B77 2A 74 3B 04 0005*      ld hl,(player_state)
043B7B             0006*      callHL
043B7B 01 82 3B 04 0001*M     ld bc,$+7 ; Address of first instruction after the jump
043B7F C5          0002*M     push bc ; which constitutes the return address
043B80 E9          0003*M     jp (hl) ; Jump to the address in HL
043B81 C9          0007*      ret
043B82             0008*  player_dead:
043B82 C9          0009*      ret
043B83             0010*  
043B83             0011*  player_alive:
043B83 CD 36 37 04 0012*      call player_input
043B87 C9          0013*      ret
043B88             0014*  
043B88             0042       include "tiles.inc"
043B88             0001*  ; ######### TILES #########
043B88             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
043B88             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
043B88 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
043B8B 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
043B8C             0006*      ; initialize to zero for a maximum of 256 rows in a level
043B8C 00          0007*  cur_level: db 0
043B8D             0008*  num_levels: equ 2 ; number of levels,duh
043B8D             0009*  
043B8D             0010*  ; lookup table for level definitions
043B8D C9 25 04 CA 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       35 04       
043B93             0012*  
043B93             0013*  ; tiles_bufferId: dl 0
043B93 00 00 00    0014*  tiles_x_plot: dl 0
043B96 F1 FF FF    0015*  tiles_y_plot: dl -15
043B99             0016*  
043B99 FF FF FF    0017*  bg_y_plot: dl -1
043B9C 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
043B9F             0019*  
043B9F             0020*  bg_plot:
043B9F             0021*  ; load current bg tile bufferId as default
043B9F 2A 9C 3B 04 0022*      ld hl,(bg_bufferId)
043BA3             0023*  ; check whether it is time for a new background tile
043BA3 3A 99 3B 04 0024*      ld a,(bg_y_plot)
043BA7 3C          0025*      inc a
043BA8 32 99 3B 04 0026*      ld (bg_y_plot),a
043BAC C2 C4 3B 04 0027*      jp nz,@F ; not time for a new tile so draw current one
043BB0             0028*  ; load the next background tile
043BB0 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
043BB4 CD 49 07 04 0030*      call rand_8
043BB8 E6 03       0031*      and %0000011
043BBA 85          0032*      add a,l
043BBB 6F          0033*      ld l,a
043BBC 3E 00       0034*      ld a,0
043BBE 8C          0035*      adc a,h
043BBF 67          0036*      ld h,a
043BC0 22 9C 3B 04 0037*      ld (bg_bufferId),hl
043BC4             0038*  @@:
043BC4 CD 98 3F 04 0039*      call vdu_buff_select
043BC8 01 00 00 00 0040*      ld bc,0
043BCC ED 5B 99 3B 0041*      ld de,(bg_y_plot)
       04          
043BD1 13          0042*      inc de
043BD2 CD 61 42 04 0043*      call vdu_plot_bmp
043BD6             0044*  ; all done
043BD6 C9          0045*      ret
043BD7             0046*  
043BD7             0047*  ; xevious_plot:
043BD7             0048*  ; ; load current bg tile bufferId as default
043BD7             0049*  ;     ld hl,(bg_bufferId)
043BD7             0050*  ; ; check whether it is time for a new background tile
043BD7             0051*  ;     ld a,(bg_y_plot)
043BD7             0052*  ;     inc a
043BD7             0053*  ;     ld (bg_y_plot),a
043BD7             0054*  ;     jp nz,@F ; not time for a new tile so draw current one
043BD7             0055*  ; ; load the next background tile
043BD7             0056*  ;     ld hl,Xevious_tile
043BD7             0057*  ;     inc (hl)
043BD7             0058*  ;     ld a,%00011111 ; 31
043BD7             0059*  ;     and (hl)
043BD7             0060*  ;     ld hl,BUF_XEVIOUS_00
043BD7             0061*  ;     add a,l
043BD7             0062*  ;     ld l,a
043BD7             0063*  ;     ld a,0
043BD7             0064*  ;     adc a,h
043BD7             0065*  ;     ld h,a
043BD7             0066*  ;     ld (bg_bufferId),hl
043BD7             0067*  ; @@:
043BD7             0068*  ;     call vdu_buff_select
043BD7             0069*  ;     ld bc,0
043BD7             0070*  ;     ld de,(bg_y_plot)
043BD7             0071*  ;     inc de
043BD7             0072*  ;     call vdu_plot_bmp
043BD7             0073*  ; ; all done
043BD7             0074*  ;     ret
043BD7             0075*  ; Xevious_tile: db 0
043BD7             0076*  
043BD7             0077*  tiles_plot:
043BD7             0078*  ; set gfx viewport to playing field window
043BD7 01 00 00 00 0079*      ld bc,field_left
043BDB 11 00 00 00 0080*      ld de,field_top
043BDF DD 21 FF 00 0081*      ld ix,field_right
       00          
043BE4 FD 21 7F 01 0082*      ld iy,field_bottom
       00          
043BE9 CD 4B 3F 04 0083*      call vdu_set_gfx_viewport
043BED             0084*  ; move the background down one pixel
043BED 3E 02       0085*      ld a,2 ; current gfx viewport
043BEF 2E 02       0086*      ld l,2 ; direction=down
043BF1 26 01       0087*      ld h,1 ; speed=1 px
043BF3 CD C3 3E 04 0088*      call vdu_scroll_down
043BF7             0089*  ; set gfx viewport to one scanline to optimise plotting tiles
043BF7 01 00 00 00 0090*      ld bc,0 ; leftmost x-coord
043BFB 11 00 00 00 0091*      ld de,0 ; topmost y-coord
043BFF DD 21 FF 00 0092*      ld ix,255 ; rightmost x-coord
       00          
043C04 FD 21 00 00 0093*      ld iy,0 ; bottommost y-coord
       00          
043C09 CD 4B 3F 04 0094*      call vdu_set_gfx_viewport
043C0D             0095*  ; plot the background
043C0D CD 9F 3B 04 0096*      call bg_plot
043C11             0097*      ; call xevious_plot
043C11             0098*      ; ret ; DEBUG
043C11             0099*  ; initialize tiles loop
043C11 21 00 00 00 0100*      ld hl,0 ; init plotting x-coordinate
043C15 22 93 3B 04 0101*      ld (tiles_x_plot),hl
043C19 2A 88 3B 04 0102*      ld hl,(tiles_row_defs)
043C1D 06 10       0103*      ld b,16 ; loop counter
043C1F             0104*  @loop:
043C1F C5          0105*      push bc ; save the loop counter
043C20             0106*  ; read the tile defintion for the current column
043C20 7E          0107*      ld a,(hl) ; a has tile definition
043C21 E5          0108*      push hl ; save pointer to tile definition
043C22 21 00 00 00 0109*      ld hl,0 ; hlu is non-zero
043C26 6F          0110*      ld l,a ; l is tile defintion
043C27 26 01       0111*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
043C29 CD 98 3F 04 0112*      call vdu_buff_select ; tile bitmap buffer is now active
043C2D             0113*  ; plot the active bitmap
043C2D ED 4B 93 3B 0114*      ld bc,(tiles_x_plot)
       04          
043C32 ED 5B 96 3B 0115*      ld de,(tiles_y_plot)
       04          
043C37 CD 61 42 04 0116*      call vdu_plot_bmp
043C3B             0117*  ; bump x-coords the width of one tile and save it
043C3B 2A 93 3B 04 0118*      ld hl,(tiles_x_plot)
043C3F 01 10 00 00 0119*      ld bc,16
043C43 09          0120*      add hl,bc
043C44 22 93 3B 04 0121*      ld (tiles_x_plot),hl
043C48             0122*  ; prepare to loop to next column
043C48 E1          0123*      pop hl ; get back pointer to tile def
043C49 23          0124*      inc hl ; bump it to the next column
043C4A C1          0125*      pop bc ; snag our loop counter
043C4B 10 D2       0126*      djnz @loop
043C4D             0127*  ; increment tiles plotting y-coordinate
043C4D             0128*  ; when it hits zero, we go to next row of tiles in the map
043C4D             0129*  ; (we use ix b/c we want to preserve hl for the next step)
043C4D DD 21 96 3B 0130*      ld ix,tiles_y_plot
       04          
043C52 DD 34 00    0131*      inc (ix)
043C55 C0          0132*      ret nz
043C56             0133*  ; time to bump tiles_row_defs to next row
043C56             0134*  ; (hl was already there at the end of the loop)
043C56 22 88 3B 04 0135*      ld (tiles_row_defs),hl
043C5A             0136*  ; reset coords to plot next row of tiles
043C5A 21 00 00 00 0137*      ld hl,0
043C5E 22 93 3B 04 0138*      ld (tiles_x_plot),hl
043C62 21 F1 FF FF 0139*      ld hl,-15
043C66 22 96 3B 04 0140*      ld (tiles_y_plot),hl
043C6A             0141*  ; decrement tiles row counter
043C6A 21 8B 3B 04 0142*      ld hl,tiles_row
043C6E 35          0143*      dec (hl)
043C6F C0          0144*      ret nz
043C70             0145*  ; queue up next level
043C70 3A 8C 3B 04 0146*      ld a,(cur_level)
043C74 FE 01       0147*      cp num_levels-1
043C76 20 02       0148*      jr nz,@inc_level
043C78 3E FF       0149*      ld a,-1 ; will wrap around to zero when we fall through
043C7A             0150*  @inc_level:
043C7A 3C          0151*      inc a
043C7B 32 8C 3B 04 0152*      ld (cur_level),a
043C7F             0153*  ; increase the number of enemy sprites
043C7F 3A 85 07 04 0154*      ld a,(max_enemy_sprites)
043C83 3C          0155*      inc a
043C84 FE 10       0156*      cp table_max_records ; if we're at the global limit,skip ahead at max level
043C86 28 04       0157*      jr z,init_level
043C88 32 85 07 04 0158*      ld (max_enemy_sprites),a ; otherwise save the updated number
043C8C             0159*  ; fall through to init_level
043C8C             0160*  
043C8C             0161*  init_level:
043C8C             0162*  ; look up address of level's tile defintion
043C8C 21 8D 3B 04 0163*      ld hl,tiles_levels
043C90 3A 8C 3B 04 0164*      ld a,(cur_level)
043C94 11 00 00 00 0165*      ld de,0 ; just in case deu is non-zero
043C98 57          0166*      ld d,a
043C99 1E 03       0167*      ld e,3
043C9B ED 5C       0168*      mlt de
043C9D 19          0169*      add hl,de
043C9E ED 37       0170*      ld ix,(hl)
043CA0 DD 22 88 3B 0171*      ld (tiles_row_defs),ix
       04          
043CA5             0172*  ; set tiles_row counter
043CA5 DD 7E 00    0173*      ld a,(ix)
043CA8 32 8B 3B 04 0174*      ld (tiles_row),a
043CAC DD 23       0175*      inc ix ; now ix points first element of first row tile def
043CAE DD 22 88 3B 0176*      ld (tiles_row_defs),ix ; ... so we save it
       04          
043CB3             0177*  ; draw initial background tiles
043CB3             0178*  ; TODO: make this a stars background
043CB3 21 39 01 00 0179*      ld hl,BUF_STATION_BG_00
043CB7 CD 98 3F 04 0180*      call vdu_buff_select
043CBB 01 00 00 00 0181*      ld bc,0
043CBF 11 00 00 00 0182*      ld de,field_top
043CC3 CD 61 42 04 0183*      call vdu_plot_bmp
043CC7             0184*  
043CC7 21 3A 01 00 0185*      ld hl,BUF_STATION_BG_01
043CCB CD 98 3F 04 0186*      call vdu_buff_select
043CCF 01 00 00 00 0187*      ld bc,0
043CD3 11 00 01 00 0188*      ld de,field_top+256
043CD7 CD 61 42 04 0189*      call vdu_plot_bmp
043CDB             0190*  
043CDB C9          0191*      ret
043CDC             0192*  
043CDC             0193*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
043CDC             0194*  ; dt_is_active:
043CDC             0195*  ; ; a lands here containing a tile index in the low nibble
043CDC             0196*  ; ; we test the values for the tiles which are active
043CDC             0197*  ;     cp #07
043CDC             0198*  ;     call z,ld_act_landing_pad
043CDC             0199*  ;     cp #08
043CDC             0200*  ;     call z,ld_act_laser_turret
043CDC             0201*  ;     ; fall through
043CDC             0202*  ;     ret
043CDC             0203*  
043CDC             0204*  ; ; some tiles become active sprites,so we load those here
043CDC             0205*  ; ; sprite_x/y have already been loaded
043CDC             0206*  ; ; sprite_dim_x/y are loaded by table_add_record
043CDC             0207*  ; ; we don't want sprite drawn to background like other tiles
043CDC             0208*  ; ; so this routine only adds them to the sprite table
043CDC             0209*  ; dt_ld_act:
043CDC             0210*  ;     ld a,#48 ; top of screen + 1/2 tile height
043CDC             0211*  ;     ld (sprite_y+1),a ; just the integer part
043CDC             0212*  ;     ld (sprite_base_bufferId),hl
043CDC             0213*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043CDC             0214*  ;     call table_add_record
043CDC             0215*  ;     call sprite_variables_from_stack
043CDC             0216*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
043CDC             0217*  ;     ret ; and back
043CDC             0218*  
043CDC             0219*  ; ld_act_landing_pad:
043CDC             0220*  ;     call sprite_variables_to_stack
043CDC             0221*  
043CDC             0222*  ;     ld hl,move_landing_pad
043CDC             0223*  ;     ld (sprite_move_program),hl
043CDC             0224*  
043CDC             0225*  ;     xor a
043CDC             0226*  ;     ld (sprite_animation),a ; animation 0
043CDC             0227*  
043CDC             0228*  ;     call rand_8     ; snag a random number
043CDC             0229*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043CDC             0230*  ;     add a,64 ; range is now 64-127
043CDC             0231*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
043CDC             0232*  
043CDC             0233*  ;     ld a,%10 ; collides with laser but not player
043CDC             0234*  ;     ld (iy+sprite_collisions),a
043CDC             0235*  
043CDC             0236*  ;     ld a,#05 ; BCD
043CDC             0237*  ;     ld (sprite_points),a
043CDC             0238*  ;     ld a,0 ; binary
043CDC             0239*  ;     ld (sprite_shield_damage),a
043CDC             0240*  
043CDC             0241*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
043CDC             0242*  ;     jr dt_ld_act
043CDC             0243*  
043CDC             0244*  ; ld_act_laser_turret:
043CDC             0245*  ;     call sprite_variables_to_stack
043CDC             0246*  
043CDC             0247*  ;     ld hl,move_laser_turret
043CDC             0248*  ;     ld (sprite_move_program),hl
043CDC             0249*  
043CDC             0250*  ;     xor a
043CDC             0251*  ;     ld (sprite_animation),a
043CDC             0252*  ;     ld (sprite_move_step),a
043CDC             0253*  
043CDC             0254*  ;     call rand_8     ; snag a random number
043CDC             0255*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043CDC             0256*  ;     add a,64 ; range is now 64-127
043CDC             0257*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043CDC             0258*  
043CDC             0259*  ;     ld a,%10 ; collides with laser but not player
043CDC             0260*  ;     ld (iy+sprite_collisions),a
043CDC             0261*  
043CDC             0262*  ;     ld a,#10 ; BCD
043CDC             0263*  ;     ld (sprite_points),a
043CDC             0264*  ;     ld a,0 ; binary
043CDC             0265*  ;     ld (sprite_shield_damage),a
043CDC             0266*  
043CDC             0267*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
043CDC             0268*  ;     jp dt_ld_act
043CDC             0269*  
043CDC             0270*  
043CDC             0271*  ; moves active tile sprites down one pixel in sync with tiles movement
043CDC             0272*  ; deletes sprites from table when they wrap around to top of screen
043CDC             0273*  move_active_tiles:
043CDC             0274*  ; get current position
043CDC 3A 0F 00 00 0275*      ld a,(sprite_y+1) ; we only need the integer part
043CE0 3C          0276*      inc a
043CE1             0277*  ; are we at the bottom of the screen?
043CE1 20 06       0278*      jr nz,move_active_tiles_draw_sprite ; nope
043CE3             0279*  ; otherwise kill sprite
043CE3 3E 80       0280*      ld a,%10000000 ; any bit set in high nibble means sprite will die
043CE5 FD 77 08    0281*      ld (iy+sprite_collisions),a
043CE8 C9          0282*      ret ; debug
043CE9             0283*  move_active_tiles_draw_sprite:
043CE9 32 0F 00 00 0284*      ld (sprite_y+1),a ; update tile y position integer part
043CED             0285*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043CED             0286*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
043CED C9          0287*      ret ; and done
043CEE             0043       include "timer.inc"
043CEE             0001*  ; Table 32. Timer Control Registers
043CEE             0002*  ; this constant is the base address of the timer control registers
043CEE             0003*  ; each timer takes three bytes:
043CEE             0004*  ;   0: control register
043CEE             0005*  ;   1: low byte of timer reset value
043CEE             0006*  ;   2: high byte of timer reset value
043CEE             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043CEE             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043CEE             0009*  TMR_CTL:     equ 80h
043CEE             0010*  
043CEE             0011*  ; Timer Control Register Bit Definitions
043CEE             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043CEE             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043CEE             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043CEE             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043CEE             0016*                              ; the TMRx_CTL register is read.
043CEE             0017*  
043CEE             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043CEE             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043CEE             0020*  
043CEE             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043CEE             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043CEE             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043CEE             0024*                              ; written to the counter when the end-of-count value is reached.
043CEE             0025*  
043CEE             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043CEE             0027*  CLK_DIV_256:  equ %00001100 ;
043CEE             0028*  CLK_DIV_64:   equ %00001000 ;
043CEE             0029*  CLK_DIV_16:   equ %00000100 ;
043CEE             0030*  CLK_DIV_4:    equ %00000000 ;
043CEE             0031*  
043CEE             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043CEE             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043CEE             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043CEE             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043CEE             0036*                              ; programmer must ensure that this bit is set to 1 each time
043CEE             0037*                              ; SINGLE-PASS mode is used.
043CEE             0038*  
043CEE             0039*  ; disable/enable the programmable reload timer
043CEE             0040*  PRT_EN_0:     equ %00000000 ;
043CEE             0041*  PRT_EN_1:     equ %00000001 ;
043CEE             0042*  
043CEE             0043*  ; Table 37. Timer Input Source Select Register
043CEE             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043CEE             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043CEE             0046*  ;   00: System clock / CLK_DIV
043CEE             0047*  ;   01: RTC / CLK_DIV
043CEE             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043CEE             0049*  ;   10: GPIO port B pin 1.
043CEE             0050*  ;   11: GPIO port B pin 1.
043CEE             0051*  TMR_ISS:   equ 92h ; register address
043CEE             0052*  
043CEE             0053*  ; Table 51. Real-Time Clock Control Register
043CEE             0054*  RTC_CTRL: equ EDh ; register address
043CEE             0055*  
043CEE             0056*  ; alarm interrupt disable/enable
043CEE             0057*  RTC_ALARM_0:    equ %00000000
043CEE             0058*  RTC_ALARM_1:    equ %10000000
043CEE             0059*  
043CEE             0060*  ; interrupt on alarm disable/enable
043CEE             0061*  RTC_INT_ENT_0:  equ %00000000
043CEE             0062*  RTC_INT_ENT_1:  equ %01000000
043CEE             0063*  
043CEE             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043CEE             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043CEE             0066*  
043CEE             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043CEE             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043CEE             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043CEE             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043CEE             0071*  
043CEE             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043CEE             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043CEE             0074*  
043CEE             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043CEE             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043CEE             0077*  
043CEE             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043CEE             0079*                                  ; RTC counter is enabled.
043CEE             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043CEE             0081*                                  ; RTC counter is disabled.
043CEE             0082*  
043CEE             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043CEE             0084*  
043CEE             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043CEE             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043CEE 00 00 00    0087*  prt_reload: dl 0x000000
043CF1             0088*  
043CF1             0089*  ; set PRT timer
043CF1             0090*  prt_set:
043CF1 21 00 00 00 0091*      ld hl,0
043CF5 22 3F 3D 04 0092*      ld (prt_irq_counter),hl
043CF9 2A EE 3C 04 0093*      ld hl,(prt_reload)
043CFD ED 29 84    0094*      out0 ($84),l
043D00 ED 21 85    0095*  	out0 ($85),h
043D03             0096*  ; disable timer
043D03 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043D05 ED 39 83    0098*  	out0 ($83),a
043D08             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043D08 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
043D0A ED 39 83    0101*  	out0 ($83),a
043D0D C9          0102*      ret
043D0E             0103*  
043D0E             0104*  ; ===============================================
043D0E             0105*  ; PRT Timer Interrupt Handling
043D0E             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
043D0E             0107*  ; -----------------------------------------------
043D0E             0108*  prt_irq_init:
043D0E             0109*      ; set up interrupt vector table 2
043D0E 21 00 00 00 0110*  	ld hl,0
043D12 3A 0C 01 00 0111*  	ld a,($10c)
043D16 6F          0112*  	ld l,a
043D17 3A 0D 01 00 0113*  	ld a,($10d)
043D1B 67          0114*  	ld h,a
043D1C             0115*  
043D1C             0116*  	; skip over CALL ($c3)
043D1C 23          0117*  	inc hl
043D1D             0118*  	; load address of jump into vector table 2 (in ram)
043D1D ED 27       0119*  	ld hl,(hl)
043D1F             0120*  
043D1F             0121*  	; write CALL prt_irq_handler to vector table 2
043D1F 3E C3       0122*  	ld a,$c3
043D21 77          0123*  	ld (hl),a
043D22 23          0124*  	inc hl
043D23 11 2A 3D 04 0125*  	ld de,prt_irq_handler
043D27 ED 1F       0126*  	ld (hl),de
043D29             0127*  
043D29 C9          0128*      ret
043D2A             0129*  
043D2A             0130*  prt_irq_handler:
043D2A F3          0131*  	di
043D2B F5          0132*  	push af
043D2C E5          0133*      push hl
043D2D ED 38 83    0134*  	in0 a,($83)
043D30 2A 3F 3D 04 0135*  	ld hl,(prt_irq_counter)
043D34 23          0136*  	inc hl
043D35 22 3F 3D 04 0137*  	ld (prt_irq_counter),hl
043D39 E1          0138*      pop hl
043D3A F1          0139*  	pop af
043D3B FB          0140*  	ei
043D3C 5B ED 4D    0141*  	reti.l
043D3F             0142*  
043D3F             0143*  prt_irq_counter:
043D3F 00 00 00    0144*  	.dl 0
043D42             0145*  prt_irq_counter_saved:
043D42 00 00 00    0146*      .dl 0
043D45             0147*  
043D45             0148*  prt_loop_reset:
043D45 E5          0149*      push hl
043D46 21 00 00 00 0150*  	ld hl,0
043D4A 22 3F 3D 04 0151*  	ld (prt_irq_counter),hl
043D4E 22 B0 3D 04 0152*      ld (prt_loop_counter),hl
043D52 22 B3 3D 04 0153*      ld (prt_loops),hl
043D56 CD F1 3C 04 0154*      call prt_set
043D5A E1          0155*      pop hl
043D5B C9          0156*      ret
043D5C             0157*  
043D5C             0158*  prt_loop_start:
043D5C E5          0159*      push hl
043D5D 21 00 00 00 0160*  	ld hl,0
043D61 22 3F 3D 04 0161*  	ld (prt_irq_counter),hl
043D65 E1          0162*      pop hl
043D66 C9          0163*      ret
043D67             0164*  
043D67             0165*  prt_loop_stop:
043D67 E5          0166*      push hl
043D68 D5          0167*      push de
043D69 2A 3F 3D 04 0168*      ld hl,(prt_irq_counter)
043D6D ED 5B B0 3D 0169*      ld de,(prt_loop_counter)
       04          
043D72 19          0170*      add hl,de
043D73 22 B0 3D 04 0171*      ld (prt_loop_counter),hl
043D77 21 00 00 00 0172*      ld hl,0
043D7B 22 3F 3D 04 0173*      ld (prt_irq_counter),hl
043D7F 2A B3 3D 04 0174*      ld hl,(prt_loops)
043D83 23          0175*      inc hl
043D84 22 B3 3D 04 0176*      ld (prt_loops),hl
043D88 D1          0177*      pop de
043D89 E1          0178*      pop hl
043D8A C9          0179*      ret
043D8B             0180*  
043D8B             0181*  ; inputs: bc = y,x text coordinates to print
043D8B             0182*  prt_loop_print:
043D8B F5          0183*      push af
043D8C E5          0184*      push hl
043D8D C5          0185*      push bc
043D8E D5          0186*      push de
043D8F DD E5       0187*      push ix
043D91 FD E5       0188*      push iy
043D93 CD 97 3E 04 0189*      call vdu_move_cursor
043D97             0190*  
043D97 2A B0 3D 04 0191*      ld hl,(prt_loop_counter)
043D9B CD 76 01 04 0192*      call printDec
043D9F             0193*  
043D9F 2A B3 3D 04 0194*      ld hl,(prt_loops)
043DA3 CD 76 01 04 0195*      call printDec
043DA7             0196*  
043DA7 FD E1       0197*      pop iy
043DA9 DD E1       0198*      pop ix
043DAB D1          0199*      pop de
043DAC C1          0200*      pop bc
043DAD E1          0201*      pop hl
043DAE F1          0202*      pop af
043DAF C9          0203*      ret
043DB0             0204*  
043DB0             0205*  prt_loop_counter:
043DB0 00 00 00    0206*      .dl 0
043DB3             0207*  prt_loops:
043DB3 00 00 00    0208*      .dl 0
043DB6             0209*  
043DB6             0210*  ; ===============================================
043DB6             0211*  ; Timer functions
043DB6             0212*  ; -----------------------------------------------
043DB6             0213*  ; set a countdown timer
043DB6             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043DB6             0215*  ; returns: hl = current time
043DB6             0216*  tmr_set:
043DB6 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
043DB9             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
043DB9 3E 08       0001*M 			LD	A, function
043DBB 5B CF       0002*M 			RST.LIL	08h
043DBD DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043DC0 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
043DC3 C9          0221*      ret
043DC4             0222*  
043DC4             0223*  ; gets time remaining on a countdown timer
043DC4             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043DC4             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043DC4             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
043DC4             0227*  tmr_get:
043DC4             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
043DC4 3E 08       0001*M 			LD	A, function
043DC6 5B CF       0002*M 			RST.LIL	08h
043DC8 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
043DCB FD 27 00    0230*      ld hl,(iy+0)            ; get start time
043DCE AF          0231*      xor a                   ; clear carry
043DCF ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043DD1 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
043DD4 AF          0234*      xor a                   ; clear carry
043DD5 ED 5A       0235*      adc hl,de               ; hl = time remaining
043DD7             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043DD7 C9          0237*      ret
043DD8             0238*  
043DD8             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
043DDE             0240*  
043DDE 00 00 00    0241*  timestamp_now: dl 0
043DE1 00 00 00    0242*  timestamp_old: dl 0
043DE4 00 00 00    0243*  timestamp_chg: dl 0
043DE7             0244*  
043DE7             0245*  ; update the global timestamp from the system clock
043DE7             0246*  ; inputs: none
043DE7             0247*  ; returns: hl = time elapsed in 1/120ths of a second
043DE7             0248*  ;          de = current time
043DE7             0249*  ;          ix = pointer to syvars table
043DE7             0250*  ; destroys: af,hl,de,ix
043DE7             0251*  timestamp_tick:
043DE7 ED 5B DE 3D 0252*      ld de,(timestamp_now)   ; get previous time
       04          
043DEC ED 53 E1 3D 0253*      ld (timestamp_old),de   ; save previous time
       04          
043DF1             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043DF1 3E 08       0001*M 			LD	A, function
043DF3 5B CF       0002*M 			RST.LIL	08h
043DF5 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
043DF8 22 DE 3D 04 0256*      ld (timestamp_now),hl   ; save current time
043DFC AF          0257*      xor a                   ; clear carry
043DFD ED 52       0258*      sbc hl,de               ; hl = time elapsed
043DFF 22 E4 3D 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043E03 C9          0260*      ret
043E04             0261*  
043E04             0262*  ; set a countdown timer
043E04             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043E04             0264*  ; requires: timestamp_tick to be called at least once before this function
043E04             0265*  ; returns: hl = current time
043E04             0266*  ; destroys: hl
043E04             0267*  timestamp_tmr_set:
043E04 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043E07 2A DE 3D 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
043E0B FD 2F 00    0270*      ld (iy+0),hl            ; set start time
043E0E C9          0271*      ret
043E0F             0272*  
043E0F             0273*  ; gets time remaining on a countdown timer following the global timestamp
043E0F             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043E0F             0275*  ; requires: timestamp_tick to be called at least once before this function
043E0F             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043E0F             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
043E0F             0278*  ; destroys: af,hl,de
043E0F             0279*  timestamp_tmr_get:
043E0F ED 5B DE 3D 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043E14 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043E17 AF          0282*      xor a                   ; clear carry
043E18 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043E1A FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
043E1D AF          0285*      xor a                   ; clear carry
043E1E ED 5A       0286*      adc hl,de               ; hl = time remaining
043E20             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043E20 C9          0288*      ret
043E21             0289*  
043E21             0290*  ; set a stopwatch
043E21             0291*  ; returns: hl = start time
043E21             0292*  ; destroys: hl,ix
043E21             0293*  stopwatch_set:
043E21             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043E21 3E 08       0001*M 			LD	A, function
043E23 5B CF       0002*M 			RST.LIL	08h
043E25 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043E28 22 3D 3E 04 0296*      ld (stopwatch_started),hl            ; set start time
043E2C C9          0297*      ret
043E2D             0298*  
043E2D             0299*  ; gets time elapsed on a stopwatch
043E2D             0300*  ; returns: hl = time elapsed in 1/120ths of a second
043E2D             0301*  ; destroys: af,hl,de,ix
043E2D             0302*  stopwatch_get:
043E2D             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
043E2D 3E 08       0001*M 			LD	A, function
043E2F 5B CF       0002*M 			RST.LIL	08h
043E31 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043E34 ED 5B 3D 3E 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043E39 AF          0306*      xor a                   ; clear carry
043E3A ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
043E3C C9          0308*      ret
043E3D             0309*  
043E3D             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043E40             0311*  
043E40             0312*  ; ------------------
043E40             0313*  ; delay routine
043E40             0314*  ; Author: Richard Turrnidge
043E40             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043E40             0316*  ; routine waits a fixed time,then returns
043E40             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043E40             0318*  ; eg. ld A,00000100b
043E40             0319*  
043E40             0320*  multiPurposeDelay:
043E40 F5          0321*      push af
043E41 C5          0322*      push bc
043E42 DD E5       0323*      push ix
043E44 47          0324*      ld b,a
043E45 3E 08       0325*      ld a,$08
043E47 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043E49             0327*  
043E49             0328*  waitLoop:
043E49             0329*  
043E49 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
043E4C             0331*  
043E4C             0332*                                  ;   we check if bit set is same as last time we checked.
043E4C             0333*                                  ;   bit 0 - don't use
043E4C             0334*                                  ;   bit 1 - changes 64 times per second
043E4C             0335*                                  ;   bit 2 - changes 32 times per second
043E4C             0336*                                  ;   bit 3 - changes 16 times per second
043E4C             0337*  
043E4C             0338*                                  ;   bit 4 - changes 8 times per second
043E4C             0339*                                  ;   bit 5 - changes 4 times per second
043E4C             0340*                                  ;   bit 6 - changes 2 times per second
043E4C             0341*                                  ;   bit 7 - changes 1 times per second
043E4C A0          0342*      and b
043E4D 4F          0343*      ld c,a
043E4E 3A 5F 3E 04 0344*      ld a,(oldTimeStamp)
043E52 B9          0345*      cp c                        ; is A same as last value?
043E53 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043E55 79          0347*      ld a,c
043E56 32 5F 3E 04 0348*      ld (oldTimeStamp),a        ; set new value
043E5A             0349*  
043E5A DD E1       0350*      pop ix
043E5C C1          0351*      pop bc
043E5D F1          0352*      pop af
043E5E C9          0353*      ret
043E5F             0354*  
043E5F 00          0355*  oldTimeStamp:   .db 00h
043E60             0044       include "vdu.inc"
043E60             0001*  
043E60             0002*  ; VDU 30: Home cursor
043E60             0003*  vdu_home_cursor:
043E60 3E 1E       0004*      ld a,30
043E62 5B D7       0005*  	rst.lil $10
043E64 C9          0006*  	ret
043E65             0007*  
043E65             0008*  vdu_cursor_on:
043E65 21 70 3E 04 0009*  	ld hl,@cmd
043E69 01 03 00 00 0010*  	ld bc,@end-@cmd
043E6D 5B DF       0011*  	rst.lil $18
043E6F C9          0012*  	ret
043E70             0013*  @cmd:
043E70 17 01 01    0014*  	db 23,1,1
043E73             0015*  @end:
043E73             0016*  
043E73             0017*  vdu_cursor_off:
043E73 21 7E 3E 04 0018*  	ld hl,@cmd
043E77 01 03 00 00 0019*  	ld bc,@end-@cmd
043E7B 5B DF       0020*  	rst.lil $18
043E7D C9          0021*  	ret
043E7E             0022*  @cmd:
043E7E 17 01 00    0023*  	db 23,1,0
043E81             0024*  @end:
043E81             0025*  
043E81             0026*  ; VDU 5: Write text at graphics cursor
043E81             0027*  ; inputs: a is the character to write to the screen
043E81             0028*  ; prerequisites: the graphics cursor at the intended position on screen
043E81             0029*  ; outputs: see the name of the function
043E81             0030*  ; destroys: a, hl, bc
043E81             0031*  vdu_char_to_gfx_cursor:
043E81 32 91 3E 04 0032*  	ld (@arg),a
043E85 21 90 3E 04 0033*  	ld hl,@cmd
043E89 01 02 00 00 0034*  	ld bc,@end-@cmd
043E8D 5B DF       0035*  	rst.lil $18
043E8F C9          0036*  	ret
043E90 05          0037*  @cmd: db 5
043E91 00          0038*  @arg: db 0
043E92             0039*  @end:
043E92             0040*  ; VDU 9: Move cursor forward one character
043E92             0041*  vdu_cursor_forward:
043E92 3E 09       0042*      ld a,9
043E94 5B D7       0043*  	rst.lil $10
043E96 C9          0044*  	ret
043E97             0045*  
043E97             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
043E97             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
043E97             0048*  vdu_move_cursor:
043E97 ED 43 A8 3E 0049*      ld (@x0),bc
       04          
043E9C 21 A7 3E 04 0050*  	ld hl,@cmd
043EA0 01 03 00 00 0051*  	ld bc,@end-@cmd
043EA4 5B DF       0052*  	rst.lil $18
043EA6 C9          0053*  	ret
043EA7 1F          0054*  @cmd: 	db 31
043EA8 00          0055*  @x0:	db 0
043EA9 00          0056*  @y0: 	db 0
043EAA 00          0057*  @end: 	db 0 ; padding
043EAB             0058*  
043EAB             0059*  ; VDU 12: Clear text area (CLS)
043EAB             0060*  vdu_cls:
043EAB 3E 0C       0061*      ld a,12
043EAD 5B D7       0062*  	rst.lil $10
043EAF C9          0063*  	ret
043EB0             0064*  
043EB0             0065*  vdu_flip:
043EB0 21 BB 3E 04 0066*  	ld hl,@cmd
043EB4 01 03 00 00 0067*  	ld bc,@end-@cmd
043EB8 5B DF       0068*  	rst.lil $18
043EBA C9          0069*  	ret
043EBB 17 00 C3    0070*  @cmd: db 23,0,0xC3
043EBE             0071*  @end:
043EBE             0072*  
043EBE             0073*  ; VDU 16: Clear graphics area (CLG)
043EBE             0074*  vdu_clg:
043EBE 3E 10       0075*      ld a,16
043EC0 5B D7       0076*  	rst.lil $10
043EC2 C9          0077*  	ret
043EC3             0078*  
043EC3             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
043EC3             0080*  ; VDU 23, 7: Scrolling
043EC3             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
043EC3             0082*  ; inputs: a, extent; l, direction; h; speed
043EC3             0083*  vdu_scroll_down:
043EC3 32 D8 3E 04 0084*  	ld (@extent),a
043EC7 22 D9 3E 04 0085*  	ld (@dir),hl ; implicitly populates @speed
043ECB 21 D6 3E 04 0086*  	ld hl,@cmd
043ECF 01 05 00 00 0087*  	ld bc,@end-@cmd
043ED3 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
043ED5 C9          0089*  	ret
043ED6 17 07       0090*  @cmd:       db 23,7
043ED8 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
043ED9 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
043EDA 00          0093*  @speed:     db 0x00 ; pixels
043EDB 00          0094*  @end:		db 0x00 ; padding
043EDC             0095*  
043EDC             0096*  ; COLOUR MODES
043EDC             0097*  ; Mode	Effect
043EDC             0098*  ; 0	Set on-screen pixel to target colour value
043EDC             0099*  ; 1	OR value with the on-screen pixel
043EDC             0100*  ; 2	AND value with the on-screen pixel
043EDC             0101*  ; 3	XOR value with the on-screen pixel
043EDC             0102*  ; 4	Invert the on-screen pixel
043EDC             0103*  ; 5	No operation
043EDC             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
043EDC             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
043EDC             0106*  
043EDC             0107*  ; VDU 17, colour: Define text colour (COLOUR)
043EDC             0108*  vdu_colour_text:
043EDC 32 EC 3E 04 0109*  	ld (@arg),a
043EE0 21 EB 3E 04 0110*  	ld hl,@cmd
043EE4 01 02 00 00 0111*  	ld bc,@end-@cmd
043EE8 5B DF       0112*  	rst.lil $18
043EEA C9          0113*  	ret
043EEB 11          0114*  @cmd: db 17
043EEC 00          0115*  @arg: db 0
043EED             0116*  @end:
043EED             0117*  
043EED             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
043EED             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
043EED             0120*  vdu_gcol:
043EED 32 02 3F 04 0121*  	ld (@mode),a
043EF1 79          0122*      ld a,c
043EF2 32 03 3F 04 0123*      ld (@col),a
043EF6 21 01 3F 04 0124*  	ld hl,@cmd
043EFA 01 03 00 00 0125*  	ld bc,@end-@cmd
043EFE 5B DF       0126*  	rst.lil $18
043F00 C9          0127*  	ret
043F01 12          0128*  @cmd:  db 18
043F02 00          0129*  @mode: db 0
043F03 00          0130*  @col:  db 0
043F04             0131*  @end:
043F04             0132*  
043F04             0133*  
043F04             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
043F04             0135*  ; MIND THE LITTLE-ENDIANESS
043F04             0136*  ; inputs: c=left,b=bottom,e=right,d=top
043F04             0137*  ; outputs; nothing
043F04             0138*  ; destroys: a might make it out alive
043F04             0139*  vdu_set_txt_viewport:
043F04 ED 43 1A 3F 0140*      ld (@lb),bc
       04          
043F09 ED 53 1C 3F 0141*  	ld (@rt),de
       04          
043F0E 21 19 3F 04 0142*  	ld hl,@cmd
043F12 01 05 00 00 0143*  	ld bc,@end-@cmd
043F16 5B DF       0144*  	rst.lil $18
043F18 C9          0145*  	ret
043F19 1C          0146*  @cmd:   db 28 ; set text viewport command
043F1A 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
043F1C 00 00       0148*  @rt: 	dw 0x0000 ; set by de
043F1E 00          0149*  @end:   db 0x00	  ; padding
043F1F             0150*  
043F1F             0151*  ; Wait for VBLANK interrupt
043F1F             0152*  vdu_vblank:
043F1F DD E5       0153*      PUSH 	IX
043F21             0154*  	MOSCALL	mos_sysvars
043F21 3E 08       0001*M 			LD	A, function
043F23 5B CF       0002*M 			RST.LIL	08h
043F25 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
043F28             0156*  @wait:
043F28 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
043F2B 28 FB       0158*      JR	Z, @wait
043F2D DD E1       0159*      POP	IX
043F2F C9          0160*      RET
043F30             0161*  
043F30             0162*  ; VDU 29, x; y;: Set graphics origin
043F30             0163*  ; This command sets the graphics origin.
043F30             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
043F30             0165*  ; inputs: bc=x0,de=y0
043F30             0166*  ; outputs; nothing
043F30             0167*  ; destroys: a might make it out alive
043F30             0168*  vdu_set_gfx_origin:
043F30 ED 43 46 3F 0169*      ld (@x0),bc
       04          
043F35 ED 53 48 3F 0170*      ld (@y0),de
       04          
043F3A 21 45 3F 04 0171*      ld hl,@cmd
043F3E 01 05 00 00 0172*      ld bc,@end-@cmd
043F42 5B DF       0173*      rst.lil $18
043F44 C9          0174*      ret
043F45 1D          0175*  @cmd:   db 29 ; set graphics origin command
043F46 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
043F48 00 00       0177*  @y0: 	dw 0x0000 ; set by de
043F4A 00          0178*  @end:   db 0x00	  ; padding
043F4B             0179*  
043F4B             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
043F4B             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
043F4B             0182*  ; 	because we have turned off logical screen scaling
043F4B             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
043F4B             0184*  ; outputs; nothing
043F4B             0185*  ; destroys: a might make it out alive
043F4B             0186*  vdu_set_gfx_viewport:
043F4B ED 43 6B 3F 0187*      ld (@x0),bc
       04          
043F50 FD 22 6D 3F 0188*      ld (@y1),iy
       04          
043F55 DD 22 6F 3F 0189*  	ld (@x1),ix
       04          
043F5A ED 53 71 3F 0190*  	ld (@y0),de
       04          
043F5F 21 6A 3F 04 0191*  	ld hl,@cmd
043F63 01 09 00 00 0192*  	ld bc,@end-@cmd
043F67 5B DF       0193*  	rst.lil $18
043F69 C9          0194*  	ret
043F6A 18          0195*  @cmd:   db 24 ; set graphics viewport command
043F6B 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
043F6D 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
043F6F 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
043F71 00 00       0199*  @y0: 	dw 0x0000 ; set by de
043F73 00          0200*  @end:   db 0x00	  ; padding
043F74             0201*  
043F74             0202*  ; SCREEN MODES
043F74             0203*  ; ===============================
043F74             0204*  ; Mode  Horz  Vert  Cols  Refresh
043F74             0205*  ; ---   ----  ----  ----  -------
043F74             0206*  ; 11    320   240   2     60hz
043F74             0207*  ; 139   320   240   2     60hz
043F74             0208*  ; 23    512   384   2     60hz
043F74             0209*  ; 151   512   384   2     60hz
043F74             0210*  ; 6     640   240   2     60hz
043F74             0211*  ; 134   640   240   2     60hz
043F74             0212*  ; 2     640   480   2     60hz
043F74             0213*  ; 130   640   480   2     60hz
043F74             0214*  ; 17    800   600   2     60hz
043F74             0215*  ; 145   800   600   2     60hz
043F74             0216*  ; 18    1024  768   2     60hz
043F74             0217*  ; 146   1024  768   2     60hz
043F74             0218*  ; ---   ----  ----  ----  -------
043F74             0219*  ; 10    320   240   4     60hz
043F74             0220*  ; 138   320   240   4     60hz
043F74             0221*  ; 22    512   384   4     60hz
043F74             0222*  ; 150   512   384   4     60hz
043F74             0223*  ; 5     640   240   4     60hz
043F74             0224*  ; 133   640   240   4     60hz
043F74             0225*  ; 1     640   480   4     60hz
043F74             0226*  ; 129   640   480   4     60hz
043F74             0227*  ; 16    800   600   4     60hz
043F74             0228*  ; 19    1024  768   4     60hz
043F74             0229*  ; ---   ----  ----  ----  -------
043F74             0230*  ; 9     320   240   16    60hz
043F74             0231*  ; 137   320   240   16    60hz
043F74             0232*  ; 21    512   384   16    60hz
043F74             0233*  ; 149   512   384   16    60hz
043F74             0234*  ; 4     640   240   16    60hz
043F74             0235*  ; 132   640   240   16    60hz
043F74             0236*  ; 0     640   480   16    60hz
043F74             0237*  ; 7     n/a   n/a   16    60hz
043F74             0238*  ; ---   ----  ----  ----  -------
043F74             0239*  ; 8     320   240   64    60hz
043F74             0240*  ; 136   320   240   64    60hz
043F74             0241*  ; 20    512   384   64    60hz
043F74             0242*  ; 3     640   240   64    60hz
043F74             0243*  ; ---   ----  ----  ----  -------
043F74             0244*  vdu_set_screen_mode:
043F74 32 84 3F 04 0245*  	ld (@arg),a
043F78 21 83 3F 04 0246*  	ld hl,@cmd
043F7C 01 02 00 00 0247*  	ld bc,@end-@cmd
043F80 5B DF       0248*  	rst.lil $18
043F82 C9          0249*  	ret
043F83 16          0250*  @cmd: db 22 ; set screen mode
043F84 00          0251*  @arg: db 0  ; screen mode parameter
043F85             0252*  @end:
043F85             0253*  
043F85             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
043F85             0255*  ; inputs: a is scaling mode, 1=on, 0=off
043F85             0256*  ; note: default setting on boot is scaling ON
043F85             0257*  vdu_set_scaling:
043F85 32 97 3F 04 0258*  	ld (@arg),a
043F89 21 94 3F 04 0259*  	ld hl,@cmd
043F8D 01 04 00 00 0260*  	ld bc,@end-@cmd
043F91 5B DF       0261*  	rst.lil $18
043F93 C9          0262*  	ret
043F94 17 00 C0    0263*  @cmd: db 23,0,0xC0
043F97 00          0264*  @arg: db 0  ; scaling on/off
043F98             0265*  @end:
043F98             0266*  
043F98             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
043F98             0268*  ; inputs: hl=bufferId
043F98             0269*  vdu_buff_select:
043F98 22 AA 3F 04 0270*  	ld (@bufferId),hl
043F9C 21 A7 3F 04 0271*  	ld hl,@cmd
043FA0 01 05 00 00 0272*  	ld bc,@end-@cmd
043FA4 5B DF       0273*  	rst.lil $18
043FA6 C9          0274*  	ret
043FA7 17 1B 20    0275*  @cmd: db 23,27,0x20
043FAA 00 00       0276*  @bufferId: dw 0x0000
043FAC 00          0277*  @end: db 0x00 ; padding
043FAD             0278*  
043FAD             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
043FAD             0280*  ; inputs: a=format; bc=width; de=height
043FAD             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
043FAD             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
043FAD             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
043FAD             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
043FAD             0285*  ; 2 	Mono/Mask (1-bit per pixel)
043FAD             0286*  ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
043FAD             0287*  vdu_bmp_create:
043FAD ED 43 C9 3F 0288*      ld (@width),bc
       04          
043FB2 ED 53 CB 3F 0289*      ld (@height),de
       04          
043FB7 32 CD 3F 04 0290*      ld (@fmt),a
043FBB 21 C6 3F 04 0291*  	ld hl,@cmd
043FBF 01 08 00 00 0292*  	ld bc,@end-@cmd
043FC3 5B DF       0293*  	rst.lil $18
043FC5 C9          0294*  	ret
043FC6 17 1B 21    0295*  @cmd:       db 23,27,0x21
043FC9 00 00       0296*  @width:     dw 0x0000
043FCB 00 00       0297*  @height:    dw 0x0000
043FCD 00          0298*  @fmt:       db 0x00
043FCE             0299*  @end:
043FCE             0300*  
043FCE             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
043FCE             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
043FCE             0303*  vdu_load_img_rgba2_to_8:
043FCE             0304*  ; backup the target buffer id and image dimensions
043FCE E5          0305*      push hl
043FCF D5          0306*      push de
043FD0 C5          0307*      push bc
043FD1             0308*  ; load the rgba2 image to working buffer 65534
043FD1 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
043FD5 CD D8 40 04 0310*  	call vdu_load_buffer_from_file
043FD9             0311*  ; restore the image dimensions and target buffer id
043FD9 C1          0312*      pop bc
043FDA D1          0313*      pop de
043FDB E1          0314*      pop hl
043FDC             0315*  ; fall through to vdu_rgba2_to_8
043FDC             0316*  
043FDC             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
043FDC             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
043FDC             0319*  ; the "expand bitmap" command is:
043FDC             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
043FDC             0321*  ; and then to reverse the byte order to fix endian-ness:
043FDC             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
043FDC             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
043FDC             0324*  ; VDU 23,27,&20,targetBufferID%;
043FDC             0325*  ; VDU 23,27,&21,width%;height%;0
043FDC             0326*  ; -------------------------------------------------------------------
043FDC             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
043FDC             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
043FDC             0329*  vdu_rgba2_to_8:
043FDC             0330*  ; load the image dimensions and buffer id parameters
043FDC ED 43 38 40 0331*      ld (@width),bc
       04          
043FE1 ED 53 3A 40 0332*      ld (@height),de
       04          
043FE6 22 1D 40 04 0333*      ld (@bufferId0),hl
043FEA 22 2A 40 04 0334*      ld (@bufferId2),hl
043FEE 22 33 40 04 0335*      ld (@bufferId1),hl
043FF2             0336*  ; clean up bytes that got stomped on by the ID loads
043FF2 3E 48       0337*      ld a,0x48
043FF4 32 1F 40 04 0338*      ld (@bufferId0+2),a
043FF8 3E 17       0339*      ld a,23
043FFA 32 35 40 04 0340*      ld (@bufferId1+2),a
043FFE 3E 18       0341*      ld a,24
044000 32 2C 40 04 0342*      ld (@bufferId2+2),a
044004 AF          0343*      xor a
044005 32 3C 40 04 0344*      ld (@height+2),a
044009             0345*  ; send the vdu command strings
044009 21 14 40 04 0346*      ld hl,@beg
04400D 01 29 00 00 0347*      ld bc,@end-@beg
044011 5B DF       0348*      rst.lil $18
044013 C9          0349*      ret
044014             0350*  @beg:
044014             0351*  ; Command 14: Consolidate blocks in a buffer
044014             0352*  ; VDU 23, 0, &A0, bufferId; 14
044014 17 00 A0    0353*      db 23,0,0xA0
044017 FE FF       0354*      dw 65534 ; workingBufferId
044019 0E          0355*      db 14 ; consolidate blocks
04401A             0356*  ; the "expand bitmap" command is:
04401A             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04401A 17 00 A0    0358*      db 23,0,0xA0
04401D 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04401F 48          0360*      db 0x48 ; given as decimal command 72 in the docs
044020 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
044021 FE FF       0362*      dw 65534 ; sourceBufferId
044023 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
044027             0364*  ; reverse the byte order to fix endian-ness:
044027             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
044027             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
044027             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
044027 17 00 A0    0368*      db 23,0,0xA0
04402A 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04402C 18          0370*      db 24 ; reverse byte order
04402D 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04402E 04 00       0372*      dw 4 ; size (4 bytes)
044030             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
044030             0374*  ; VDU 23,27,&20,targetBufferID%;
044030 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
044033 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
044035             0377*  ; VDU 23,27,&21,width%;height%;0
044035 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
044038 00 00       0379*  @width: dw 0x0000
04403A 00 00       0380*  @height: dw 0x0000
04403C 00          0381*      db 0x00 ; rgba8888 format
04403D             0382*  @end:
04403D             0383*  
04403D             0384*  ; scratch variables
04403D 00 00 00    0385*  bufferId0: dl 0x000000
044040 00 00 00    0386*  bufferId1: dl 0x000000
044043             0387*  
044043             0388*  ; load a vdu buffer from local memory
044043             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044043             0390*  vdu_load_buffer:
044043 ED 43 6C 40 0391*      ld (@length),bc
       04          
044048 D5          0392*      push de ; save data pointer
044049             0393*  ; send the vdu command string
044049 7D          0394*      ld a,l
04404A 32 69 40 04 0395*      ld (@bufferId),a
04404E 7C          0396*      ld a,h
04404F 32 6A 40 04 0397*      ld (@bufferId+1),a
044053 21 66 40 04 0398*      ld hl,@cmd
044057 01 08 00 00 0399*      ld bc,@end-@cmd
04405B 5B DF       0400*      rst.lil $18
04405D             0401*  ; send the buffer data
04405D E1          0402*      pop hl ; pointer to data
04405E ED 4B 6C 40 0403*      ld bc,(@length)
       04          
044063 5B DF       0404*      rst.lil $18 ; send it
044065 C9          0405*      ret
044066             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
044066 17 00 A0    0407*  @cmd:       db 23,0,0xA0
044069 00 00       0408*  @bufferId:	dw 0x0000
04406B 00          0409*  		    db 0 ; load buffer
04406C 00 00       0410*  @length:	dw 0x0000
04406E 00          0411*  @end: db 0 ; padding
04406F             0412*  
04406F             0413*  ; clear a buffer
04406F             0414*  ; inputs: hl = bufferId
04406F             0415*  vdu_clear_buffer:
04406F 7D          0416*      ld a,l
044070 32 87 40 04 0417*      ld (@bufferId),a
044074 7C          0418*      ld a,h
044075 32 88 40 04 0419*      ld (@bufferId+1),a
044079 21 84 40 04 0420*      ld hl,@cmd
04407D 01 06 00 00 0421*      ld bc,@end-@cmd
044081 5B DF       0422*      rst.lil $18
044083 C9          0423*      ret
044084 17 00 A0    0424*  @cmd:       db 23,0,0xA0
044087 00 00       0425*  @bufferId:	dw 0x0000
044089 02          0426*  		    db 2 ; clear buffer
04408A             0427*  @end:
04408A             0428*  
04408A             0429*  vdu_clear_all_buffers:
04408A             0430*  ; clear all buffers
04408A 21 95 40 04 0431*      ld hl,@beg
04408E 01 06 00 00 0432*      ld bc,@end-@beg
044092 5B DF       0433*      rst.lil $18
044094 C9          0434*      ret
044095 17 00 A0    0435*  @beg: db 23,0,$A0
044098 FF FF       0436*        dw -1 ; clear all buffers
04409A 02          0437*        db 2  ; command 2: clear a buffer
04409B             0438*  @end:
04409B             0439*  
04409B             0440*  ; Command 14: Consolidate blocks in a buffer
04409B             0441*  vdu_consolidate_buffer:
04409B             0442*  ; set parameters for vdu call
04409B 7D          0443*      ld a,l
04409C 32 B3 40 04 0444*      ld (@bufferId),a
0440A0 7C          0445*      ld a,h
0440A1 32 B4 40 04 0446*      ld (@bufferId+1),a
0440A5 21 B0 40 04 0447*      ld hl,@beg
0440A9 01 06 00 00 0448*      ld bc,@end-@beg
0440AD 5B DF       0449*      rst.lil $18
0440AF C9          0450*      ret
0440B0             0451*  ; VDU 23, 0, &A0, bufferId; 14
0440B0 17 00 A0    0452*  @beg: db 23,0,0xA0
0440B3 00 00       0453*  @bufferId: dw 0x0000
0440B5 0E          0454*             db 14
0440B6             0455*  @end:
0440B6             0456*  
0440B6             0457*  ; load an image file to a buffer and make it a bitmap
0440B6             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0440B6             0459*  vdu_load_img:
0440B6             0460*  ; back up image type and dimension parameters
0440B6 22 3D 40 04 0461*      ld (bufferId0),hl
0440BA F5          0462*      push af
0440BB C5          0463*  	push bc
0440BC D5          0464*  	push de
0440BD             0465*  ; load the image
0440BD CD D8 40 04 0466*  	call vdu_load_buffer_from_file
0440C1             0467*  ; now make it a bitmap
0440C1 2A 3D 40 04 0468*      ld hl,(bufferId0)
0440C5 CD 9B 40 04 0469*      call vdu_consolidate_buffer
0440C9 2A 3D 40 04 0470*      ld hl,(bufferId0)
0440CD CD 98 3F 04 0471*      call vdu_buff_select
0440D1 D1          0472*  	pop de ; image height
0440D2 C1          0473*  	pop bc ; image width
0440D3 F1          0474*  	pop af ; image type
0440D4 C3 AD 3F 04 0475*  	jp vdu_bmp_create ; will return to caller from there
0440D8             0476*  
0440D8             0477*  ; inputs: hl = bufferId; iy = pointer to filename
0440D8             0478*  vdu_load_buffer_from_file:
0440D8 22 3D 40 04 0479*      ld (bufferId0),hl
0440DC             0480*  
0440DC             0481*  ; clear target buffer
0440DC CD 6F 40 04 0482*      call vdu_clear_buffer
0440E0             0483*  
0440E0             0484*  ; open the file in read mode
0440E0             0485*  ; Open a file
0440E0             0486*  ; HLU: Filename
0440E0             0487*  ;   C: Mode
0440E0             0488*  ; Returns:
0440E0             0489*  ;   A: Filehandle, or 0 if couldn't open
0440E0 FD E5       0490*  	push iy ; pointer to filename
0440E2 E1          0491*  	pop hl
0440E3 0E 01       0492*  	ld c,fa_read
0440E5             0493*      MOSCALL mos_fopen
0440E5 3E 0A       0001*M 			LD	A, function
0440E7 5B CF       0002*M 			RST.LIL	08h
0440E9 32 24 41 04 0494*      ld (@filehandle),a
0440ED             0495*  
0440ED             0496*  @read_file:
0440ED             0497*  ; Read a block of data from a file
0440ED             0498*  ;   C: Filehandle
0440ED             0499*  ; HLU: Pointer to where to write the data to
0440ED             0500*  ; DEU: Number of bytes to read
0440ED             0501*  ; Returns:
0440ED             0502*  ; DEU: Number of bytes read
0440ED 3A 24 41 04 0503*      ld a,(@filehandle)
0440F1 4F          0504*      ld c,a
0440F2 21 00 E0 B7 0505*      ld hl,filedata
0440F6 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0440FA             0507*      MOSCALL mos_fread
0440FA 3E 1A       0001*M 			LD	A, function
0440FC 5B CF       0002*M 			RST.LIL	08h
0440FE             0508*  
0440FE             0509*  ; test de for zero bytes read
0440FE 21 00 00 00 0510*      ld hl,0
044102 AF          0511*      xor a ; clear carry
044103 ED 52       0512*      sbc hl,de
044105 CA 1B 41 04 0513*      jp z,@close_file
044109             0514*  
044109             0515*  ; load a vdu buffer from local memory
044109             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044109 2A 3D 40 04 0517*      ld hl,(bufferId0)
04410D D5          0518*      push de ; chunksize
04410E C1          0519*      pop bc
04410F 11 00 E0 B7 0520*      ld de,filedata
044113 CD 43 40 04 0521*      call vdu_load_buffer
044117             0522*  
044117             0523*  ; read the next block
044117 C3 ED 40 04 0524*      jp @read_file
04411B             0525*  
04411B             0526*  ; close the file
04411B             0527*  @close_file:
04411B 3A 24 41 04 0528*      ld a,(@filehandle)
04411F             0529*      MOSCALL mos_fclose
04411F 3E 0B       0001*M 			LD	A, function
044121 5B CF       0002*M 			RST.LIL	08h
044123 C9          0530*      ret ; vdu_load_buffer_from_file
044124             0531*  
044124 00          0532*  @filehandle: db 0 ; file handle
044125 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
044128             0534*  
044128 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
04412B             0536*  
04412B             0537*  ; File information structure (FILINFO)
04412B             0538*  @filinfo:
04412B 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04412F 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
044131 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
044133 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
044134 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
044141 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044241             0045       include "vdu_plot.inc"
044241             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044241             0002*  ; PLOT code 	(Decimal) 	Effect
044241             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
044241             0004*  plot_sl_both: equ 0x00
044241             0005*  
044241             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
044241             0007*  plot_sl_first: equ 0x08
044241             0008*  
044241             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
044241             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
044241             0011*  
044241             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
044241             0013*  plot_sl_last: equ 0x20
044241             0014*  
044241             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
044241             0016*  plot_sl_none: equ 0x28
044241             0017*  
044241             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
044241             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
044241             0020*  
044241             0021*  ; &40-&47 	64-71 	Point plot
044241             0022*  plot_pt: equ 0x40
044241             0023*  
044241             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
044241             0025*  plot_lf_lr_non_bg: equ 0x48
044241             0026*  
044241             0027*  ; &50-&57 	80-87 	Triangle fill
044241             0028*  plot_tf: equ 0x50
044241             0029*  
044241             0030*  ; &58-&5F 	88-95 	Line fill right to background Â§Â§
044241             0031*  plot_lf_r_bg: equ 0x58
044241             0032*  
044241             0033*  ; &60-&67 	96-103 	Rectangle fill
044241             0034*  plot_rf: equ 0x60
044241             0035*  
044241             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
044241             0037*  plot_lf_lr_fg: equ 0x60
044241             0038*  
044241             0039*  ; &70-&77 	112-119 	Parallelogram fill
044241             0040*  plot_pf: equ 0x70
044241             0041*  
044241             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
044241             0043*  plot_lf_r_non_fg: equ 0x78
044241             0044*  
044241             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
044241             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
044241             0047*  
044241             0048*  ; &90-&97 	144-151 	Circle outline
044241             0049*  plot_co: equ 0x90
044241             0050*  
044241             0051*  ; &98-&9F 	152-159 	Circle fill
044241             0052*  plot_cf: equ 0x98
044241             0053*  
044241             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
044241             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
044241             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
044241             0057*  
044241             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
044241             0059*  plot_rcm: equ 0xB8
044241             0060*  
044241             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
044241             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
044241             0063*  ; &D0-&D7 	208-215 	Not defined
044241             0064*  ; &D8-&DF 	216-223 	Not defined
044241             0065*  ; &E0-&E7 	224-231 	Not defined
044241             0066*  
044241             0067*  ; &E8-&EF 	232-239 	Bitmap plot Â§
044241             0068*  plot_bmp: equ 0xE8
044241             0069*  
044241             0070*  ; &F0-&F7 	240-247 	Not defined
044241             0071*  ; &F8-&FF 	248-255 	Not defined
044241             0072*  
044241             0073*  ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
044241             0074*  ; Agon Console8 VDP 2.2.0
044241             0075*  
044241             0076*  ; Within each group of eight plot codes, the effects are as follows:
044241             0077*  ; Plot code 	Effect
044241             0078*  ; 0 	Move relative
044241             0079*  mv_rel: equ 0
044241             0080*  
044241             0081*  ; 1 	Plot relative in current foreground colour
044241             0082*  dr_rel_fg: equ 1
044241             0083*  
044241             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
044241             0085*  ; 3 	Plot relative in current background colour
044241             0086*  dr_rel_bg: equ 3
044241             0087*  
044241             0088*  ; 4 	Move absolute
044241             0089*  mv_abs: equ 4
044241             0090*  
044241             0091*  ; 5 	Plot absolute in current foreground colour
044241             0092*  dr_abs_fg: equ 5
044241             0093*  
044241             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
044241             0095*  ; 7 	Plot absolute in current background colour
044241             0096*  dr_abs_bg: equ 7
044241             0097*  
044241             0098*  ; Codes 0-3 use the position data provided as part of the command
044241             0099*  ; as a relative position, adding the position given to the current
044241             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
044241             0101*  ; as part of the command as an absolute position, setting the current
044241             0102*  ; graphical cursor position to the position given.
044241             0103*  
044241             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
044241             0105*  ; current pixel colour. These operations cannot currently be supported
044241             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
044241             0107*  ; supported. Support for these codes may be added in a future version
044241             0108*  ; of the VDP firmware.
044241             0109*  
044241             0110*  ; 16 colour palette constants
044241             0111*  c_black: equ 0
044241             0112*  c_red_dk: equ 1
044241             0113*  c_green_dk: equ 2
044241             0114*  c_yellow_dk: equ 3
044241             0115*  c_blue_dk: equ 4
044241             0116*  c_magenta_dk: equ 5
044241             0117*  c_cyan_dk: equ 6
044241             0118*  c_grey: equ 7
044241             0119*  c_grey_dk: equ 8
044241             0120*  c_red: equ 9
044241             0121*  c_green: equ 10
044241             0122*  c_yellow: equ 11
044241             0123*  c_blue: equ 12
044241             0124*  c_magenta: equ 13
044241             0125*  c_cyan: equ 14
044241             0126*  c_white: equ 15
044241             0127*  
044241             0128*  ; VDU 25, mode, x; y;: PLOT command
044241             0129*  ; inputs: a=mode, bc=x0, de=y0
044241             0130*  vdu_plot:
044241 32 5B 42 04 0131*      ld (@mode),a
044245 ED 43 5C 42 0132*      ld (@x0),bc
       04          
04424A ED 53 5E 42 0133*      ld (@y0),de
       04          
04424F 21 5A 42 04 0134*  	ld hl,@cmd
044253 01 06 00 00 0135*  	ld bc,@end-@cmd
044257 5B DF       0136*  	rst.lil $18
044259 C9          0137*  	ret
04425A 19          0138*  @cmd:   db 25
04425B 00          0139*  @mode:  db 0
04425C 00 00       0140*  @x0: 	dw 0
04425E 00 00       0141*  @y0: 	dw 0
044260 00          0142*  @end:   db 0 ; extra byte to soak up deu
044261             0143*  
044261             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044261             0145*  ; &E8-&EF 	232-239 	Bitmap plot Â§
044261             0146*  ; VDU 25, mode, x; y;: PLOT command
044261             0147*  ; inputs: bc=x0, de=y0
044261             0148*  ; prerequisites: vdu_buff_select
044261             0149*  vdu_plot_bmp:
044261 ED 43 78 42 0150*      ld (@x0),bc
       04          
044266 ED 53 7A 42 0151*      ld (@y0),de
       04          
04426B 21 76 42 04 0152*  	ld hl,@cmd
04426F 01 06 00 00 0153*  	ld bc,@end-@cmd
044273 5B DF       0154*  	rst.lil $18
044275 C9          0155*  	ret
044276 19          0156*  @cmd:   db 25
044277 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
044278 00 00       0158*  @x0: 	dw 0x0000
04427A 00 00       0159*  @y0: 	dw 0x0000
04427C 00          0160*  @end:   db 0x00 ; padding
04427D             0161*  
04427D             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04427D             0163*  ; &E8-&EF 	232-239 	Bitmap plot Â§
04427D             0164*  ; VDU 25, mode, x; y;: PLOT command
04427D             0165*  ; inputs: bc=x0, de=y0
04427D             0166*  ; USING 16.8 FIXED POINT COORDINATES
04427D             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04427D             0168*  ;   the fractional portiion of the inputs are truncated
04427D             0169*  ;   leaving only the 16-bit integer portion
04427D             0170*  ; prerequisites: vdu_buff_select
04427D             0171*  vdu_plot_bmp168:
04427D             0172*  ; populate in the reverse of normal to keep the
04427D             0173*  ; inputs from stomping on each other
04427D ED 53 9B 42 0174*      ld (@y0-1),de
       04          
044282 ED 43 99 42 0175*      ld (@x0-1),bc
       04          
044287 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
044289 32 99 42 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
04428D 21 98 42 04 0178*  	ld hl,@cmd
044291 01 06 00 00 0179*  	ld bc,@end-@cmd
044295 5B DF       0180*  	rst.lil $18
044297 C9          0181*  	ret
044298 19          0182*  @cmd:   db 25
044299 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04429A 00 00       0184*  @x0: 	dw 0x0000
04429C 00 00       0185*  @y0: 	dw 0x0000
04429E             0186*  @end:  ; no padding required b/c we shifted de right
04429E             0187*  
04429E             0188*  ; draw a filled rectangle
04429E             0189*  vdu_plot_rf:
04429E ED 43 C5 42 0190*      ld (@x0),bc
       04          
0442A3 ED 53 C7 42 0191*      ld (@y0),de
       04          
0442A8 DD 22 CB 42 0192*      ld (@x1),ix
       04          
0442AD FD 22 CD 42 0193*      ld (@y1),iy
       04          
0442B2 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0442B4 32 C9 42 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0442B8 21 C3 42 04 0196*  	ld hl,@cmd0
0442BC 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0442C0 5B DF       0198*  	rst.lil $18
0442C2 C9          0199*      ret
0442C3 19          0200*  @cmd0:  db 25 ; plot
0442C4 04          0201*  @arg0:  db plot_sl_both+mv_abs
0442C5 00 00       0202*  @x0:    dw 0x0000
0442C7 00 00       0203*  @y0:    dw 0x0000
0442C9 19          0204*  @cmd1:  db 25 ; plot
0442CA 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0442CB 00 00       0206*  @x1:    dw 0x0000
0442CD 00 00       0207*  @y1:    dw 0x0000
0442CF 00          0208*  @end:   db 0x00 ; padding
0442D0             0209*  
0442D0             0210*  ; draw a filled circle
0442D0             0211*  vdu_plot_cf:
0442D0 ED 43 F7 42 0212*      ld (@x0),bc
       04          
0442D5 ED 53 F9 42 0213*      ld (@y0),de
       04          
0442DA DD 22 FD 42 0214*      ld (@x1),ix
       04          
0442DF FD 22 FF 42 0215*      ld (@y1),iy
       04          
0442E4 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0442E6 32 FB 42 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0442EA 21 F5 42 04 0218*  	ld hl,@cmd0
0442EE 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0442F2 5B DF       0220*  	rst.lil $18
0442F4 C9          0221*      ret
0442F5 19          0222*  @cmd0:  db 25 ; plot
0442F6 04          0223*  @arg0:  db plot_sl_both+mv_abs
0442F7 00 00       0224*  @x0:    dw 0x0000
0442F9 00 00       0225*  @y0:    dw 0x0000
0442FB 19          0226*  @cmd1:  db 25 ; plot
0442FC 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0442FD 00 00       0228*  @x1:    dw 0x0000
0442FF 00 00       0229*  @y1:    dw 0x0000
044301 00          0230*  @end:   db 0x00 ; padding
044302             0046       include "vdu_sprites.inc"
044302             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
044302             0002*  ; the VDP can support up to 256 sprites. They must be defined
044302             0003*  ; contiguously, and so the first sprite is sprite 0.
044302             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
044302             0005*  ; Once a selection of sprites have been defined, you can activate
044302             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
044302             0007*  ; of sprites to activate. This will activate the first n sprites,
044302             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
044302             0009*  
044302             0010*  ; A single sprite can have multiple "frames", referring to
044302             0011*  ; different bitmaps.
044302             0012*  ; (These bitmaps do not need to be the same size.)
044302             0013*  ; This allows a sprite to include an animation sequence,
044302             0014*  ; which can be stepped through one frame at a time, or picked
044302             0015*  ; in any order.
044302             0016*  
044302             0017*  ; Any format of bitmap can be used as a sprite frame. It should
044302             0018*  ; be noted however that "native" format bitmaps are not
044302             0019*  ; recommended for use as sprite frames, as they cannot get
044302             0020*  ; erased from the screen. (As noted above, the "native" bitmap
044302             0021*  ; format is not really intended for general use.) This is part
044302             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
044302             0023*  ; screen are now stored in RGBA2222 format.
044302             0024*  
044302             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
044302             0026*  ; and then later shown again.
044302             0027*  
044302             0028*  ; Moving sprites around the screen is done by changing the
044302             0029*  ; position of the sprite. This can be done either by setting
044302             0030*  ; the absolute position of the sprite, or by moving the sprite
044302             0031*  ; by a given number of pixels. (Sprites are positioned using
044302             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
044302             0033*  ; In the current sprite system, sprites will not update their
044302             0034*  ; position on-screen until either another drawing operation is
044302             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
044302             0036*  
044302             0037*  ; VDU 23, 27, 4, n: Select sprite n
044302             0038*  ; inputs: a is the 8-bit sprite id
044302             0039*  vdu_sprite_select:
044302 32 14 43 04 0040*      ld (@sprite),a
044306 21 11 43 04 0041*      ld hl,@cmd
04430A 01 04 00 00 0042*      ld bc,@end-@cmd
04430E 5B DF       0043*      rst.lil $18
044310 C9          0044*      ret
044311 17 1B 04    0045*  @cmd:    db 23,27,4
044314 00          0046*  @sprite: db 0x00
044315             0047*  @end:
044315             0048*  
044315             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
044315             0050*  ; inputs: none
044315             0051*  ; prerequisites: vdu_sprite_select
044315             0052*  vdu_sprite_clear_frames:
044315 21 20 43 04 0053*      ld hl,@cmd
044319 01 03 00 00 0054*      ld bc,@end-@cmd
04431D 5B DF       0055*      rst.lil $18
04431F C9          0056*      ret
044320 17 1B 05    0057*  @cmd: db 23,27,5
044323             0058*  @end:
044323             0059*  
044323             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
044323             0061*  ; inputs: a is the 8-bit bitmap number
044323             0062*  ; prerequisites: vdu_sprite_select
044323             0063*  vdu_sprite_add_bmp:
044323 32 35 43 04 0064*      ld (@bmp),a
044327 21 32 43 04 0065*      ld hl,@cmd
04432B 01 04 00 00 0066*      ld bc,@end-@cmd
04432F 5B DF       0067*      rst.lil $18
044331 C9          0068*      ret
044332 17 1B 06    0069*  @cmd: db 23,27,6
044335 00          0070*  @bmp: db 0x00
044336             0071*  @end:
044336             0072*  
044336             0073*  ; VDU 23, 27, 7, n: Activate n sprites
044336             0074*  ; inputs: a is the number of sprites to activate
044336             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
044336             0076*  vdu_sprite_activate:
044336 32 48 43 04 0077*      ld (@num),a
04433A 21 45 43 04 0078*      ld hl,@cmd
04433E 01 04 00 00 0079*      ld bc,@end-@cmd
044342 5B DF       0080*      rst.lil $18
044344 C9          0081*      ret
044345 17 1B 07    0082*  @cmd: db 23,27,7
044348 00          0083*  @num: db 0x00
044349             0084*  @end:
044349             0085*  
044349             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
044349             0087*  ; inputs: none
044349             0088*  ; prerequisites: vdu_sprite_select
044349             0089*  vdu_sprite_next_frame:
044349 21 54 43 04 0090*      ld hl,@cmd
04434D 01 03 00 00 0091*      ld bc,@end-@cmd
044351 5B DF       0092*      rst.lil $18
044353 C9          0093*      ret
044354 17 1B 08    0094*  @cmd: db 23,27,8
044357             0095*  @end:
044357             0096*  
044357             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
044357             0098*  ; inputs: none
044357             0099*  ; prerequisites: vdu_sprite_select
044357             0100*  vdu_sprite_prev_frame:
044357 21 62 43 04 0101*      ld hl,@cmd
04435B 01 03 00 00 0102*      ld bc,@end-@cmd
04435F 5B DF       0103*      rst.lil $18
044361 C9          0104*      ret
044362 17 1B 09    0105*  @cmd: db 23,27,9
044365             0106*  @end:
044365             0107*  
044365             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
044365             0109*  ; inputs: a is frame number to select
044365             0110*  ; prerequisites: vdu_sprite_select
044365             0111*  vdu_sprite_select_frame:
044365 32 77 43 04 0112*      ld (@frame),a
044369 21 74 43 04 0113*      ld hl,@cmd
04436D 01 04 00 00 0114*      ld bc,@end-@cmd
044371 5B DF       0115*      rst.lil $18
044373 C9          0116*      ret
044374 17 1B 0A    0117*  @cmd:    db 23,27,10
044377 00          0118*  @frame:  db 0x00
044378             0119*  @end:
044378             0120*  
044378             0121*  ; VDU 23, 27, 11: Show current sprite
044378             0122*  ; inputs: none
044378             0123*  ; prerequisites: vdu_sprite_select
044378             0124*  vdu_sprite_show:
044378 21 83 43 04 0125*      ld hl,@cmd
04437C 01 03 00 00 0126*      ld bc,@end-@cmd
044380 5B DF       0127*      rst.lil $18
044382 C9          0128*      ret
044383 17 1B 0B    0129*  @cmd: db 23,27,11
044386             0130*  @end:
044386             0131*  
044386             0132*  ; VDU 23, 27, 12: Hide current sprite
044386             0133*  ; inputs: none
044386             0134*  ; prerequisites: vdu_sprite_select
044386             0135*  vdu_sprite_hide:
044386 21 91 43 04 0136*      ld hl,@cmd
04438A 01 03 00 00 0137*      ld bc,@end-@cmd
04438E 5B DF       0138*      rst.lil $18
044390 C9          0139*      ret
044391 17 1B 0C    0140*  @cmd: db 23,27,12
044394             0141*  @end:
044394             0142*  
044394             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044394             0144*  ; inputs: bc is x coordinate, de is y coordinate
044394             0145*  ; prerequisites: vdu_sprite_select
044394             0146*  vdu_sprite_move_abs:
044394 ED 43 AC 43 0147*      ld (@xpos),bc
       04          
044399 ED 53 AE 43 0148*      ld (@ypos),de
       04          
04439E 21 A9 43 04 0149*      ld hl,@cmd
0443A2 01 07 00 00 0150*      ld bc,@end-@cmd
0443A6 5B DF       0151*      rst.lil $18
0443A8 C9          0152*      ret
0443A9 17 1B 0D    0153*  @cmd:  db 23,27,13
0443AC 00 00       0154*  @xpos: dw 0x0000
0443AE 00 00       0155*  @ypos: dw 0x0000
0443B0 00          0156*  @end:  db 0x00 ; padding
0443B1             0157*  
0443B1             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0443B1             0159*  ; inputs: bc is x coordinate, de is y coordinate
0443B1             0160*  ; prerequisites: vdu_sprite_select
0443B1             0161*  vdu_sprite_move_rel:
0443B1 ED 43 C9 43 0162*      ld (@dx),bc
       04          
0443B6 ED 53 CB 43 0163*      ld (@dy),de
       04          
0443BB 21 C6 43 04 0164*      ld hl,@cmd
0443BF 01 07 00 00 0165*      ld bc,@end-@cmd
0443C3 5B DF       0166*      rst.lil $18
0443C5 C9          0167*      ret
0443C6 17 1B 0E    0168*  @cmd: db 23,27,14
0443C9 00 00       0169*  @dx:  dw 0x0000
0443CB 00 00       0170*  @dy:  dw 0x0000
0443CD 00          0171*  @end: db 0x00 ; padding
0443CE             0172*  
0443CE             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
0443CE             0174*  ; USING 16.8 FIXED POINT COORDINATES
0443CE             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0443CE             0176*  ;   the fractional portiion of the inputs are truncated
0443CE             0177*  ;   leaving only the 16-bit integer portion
0443CE             0178*  ; prerequisites: vdu_sprite_select
0443CE             0179*  vdu_sprite_move_abs168:
0443CE             0180*  ; offset inputs by the gfx origin
0443CE             0181*  ; y coordinate
0443CE 21 00 00 00 0182*      ld hl,origin_top*256
0443D2 19          0183*      add hl,de
0443D3 22 F5 43 04 0184*      ld (@ypos-1),hl
0443D7             0185*  ; x coordinate
0443D7 21 00 80 00 0186*      ld hl,origin_left*256
0443DB 09          0187*      add hl,bc
0443DC 22 F3 43 04 0188*      ld (@xpos-1),hl
0443E0             0189*  ; prepare vdu command
0443E0 3E 0D       0190*      ld a,13       ; restore the final byte of the command
0443E2 32 F3 43 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
0443E6 21 F1 43 04 0192*      ld hl,@cmd
0443EA 01 07 00 00 0193*      ld bc,@end-@cmd
0443EE 5B DF       0194*      rst.lil $18
0443F0 C9          0195*      ret
0443F1 17 1B 0D    0196*  @cmd:  db 23,27,13
0443F4 00 00       0197*  @xpos: dw 0x0000
0443F6 00 00       0198*  @ypos: dw 0x0000
0443F8             0199*  @end:  ; no padding required b/c we shifted de right
0443F8             0200*  
0443F8             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0443F8             0202*  ; USING 16.8 FIXED POINT COORDINATES
0443F8             0203*  ; inputs: ub.c is dx, ud.e is dy
0443F8             0204*  ;   the fractional portiion of the inputs are truncated
0443F8             0205*  ;   leaving only the 16-bit integer portion
0443F8             0206*  ; prerequisites: vdu_sprite_select
0443F8             0207*  vdu_sprite_move_rel168:
0443F8             0208*  ; populate in the reverse of normal to keep the
0443F8             0209*  ; inputs from stomping on each other
0443F8 ED 53 17 44 0210*      ld (@dy-1),de
       04          
0443FD ED 43 15 44 0211*      ld (@dx-1),bc
       04          
044402 3E 0E       0212*      ld a,14       ; restore the final byte of the command
044404 32 15 44 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
044408 21 13 44 04 0214*      ld hl,@cmd
04440C 01 07 00 00 0215*      ld bc,@end-@cmd
044410 5B DF       0216*      rst.lil $18
044412 C9          0217*      ret
044413 17 1B 0E    0218*  @cmd:  db 23,27,14
044416 00 00       0219*  @dx: dw 0x0000
044418 00 00       0220*  @dy: dw 0x0000
04441A             0221*  @end:  ; no padding required b/c we shifted de right
04441A             0222*  
04441A             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
04441A             0224*  ; inputs: none
04441A             0225*  vdu_sprite_update:
04441A 21 25 44 04 0226*      ld hl,@cmd
04441E 01 03 00 00 0227*      ld bc,@end-@cmd
044422 5B DF       0228*      rst.lil $18
044424 C9          0229*      ret
044425 17 1B 0F    0230*  @cmd: db 23,27,15
044428             0231*  @end:
044428             0232*  
044428             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
044428             0234*  ; inputs: none
044428             0235*  vdu_sprite_bmp_reset:
044428 21 33 44 04 0236*      ld hl,@cmd
04442C 01 03 00 00 0237*      ld bc,@end-@cmd
044430 5B DF       0238*      rst.lil $18
044432 C9          0239*      ret
044433 17 1B 10    0240*  @cmd: db 23,27,16
044436             0241*  @end:
044436             0242*  
044436             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
044436             0244*  ; inputs: none
044436             0245*  vdu_sprite_reset:
044436 21 41 44 04 0246*      ld hl,@cmd
04443A 01 03 00 00 0247*      ld bc,@end-@cmd
04443E 5B DF       0248*      rst.lil $18
044440 C9          0249*      ret
044441 17 1B 11    0250*  @cmd: db 23,27,17
044444             0251*  @end:
044444             0252*  
044444             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
044444             0254*  ; inputs: a is the GCOL paint mode
044444             0255*  ; prerequisites: vdu_sprite_select
044444             0256*  vdu_sprite_set_gcol:
044444 32 56 44 04 0257*      ld (@mode),a
044448 21 53 44 04 0258*      ld hl,@cmd
04444C 01 04 00 00 0259*      ld bc,@end-@cmd
044450 5B DF       0260*      rst.lil $18
044452 C9          0261*      ret
044453 17 1B 12    0262*  @cmd:  db 23,27,18
044456 00          0263*  @mode: db 0x00
044457             0264*  @end:
044457             0265*  
044457             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
044457             0267*  ; inputs: hl=bufferId
044457             0268*  ; prerequisites: vdu_sprite_select
044457             0269*  vdu_sprite_add_buff:
044457 22 69 44 04 0270*      ld (@bufferId),hl
04445B 21 66 44 04 0271*      ld hl,@cmd
04445F 01 05 00 00 0272*      ld bc,@end-@cmd
044463 5B DF       0273*      rst.lil $18
044465 C9          0274*      ret
044466 17 1B 26    0275*  @cmd:      db 23,27,0x26
044469 00 00       0276*  @bufferId: dw 0x0000
04446B 00          0277*  @end:      db 0x00 ; padding
04446C             0047   
04446C 57 65 6C 63 0048   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
044487 4C 6F 61 64 0049   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044492 4C 6F 61 64 0050   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0444A0 50 72 65 73 0051   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0444BB             0052   
0444BB             0053   init:
0444BB             0054   ; clear all buffers
0444BB CD 8A 40 04 0055       call vdu_clear_all_buffers
0444BF             0056   
0444BF             0057   ; set up the display
0444BF 3E 08       0058       ld a,8;+128 ; 136   320   240   64    60hz double-buffered
0444C1 CD 74 3F 04 0059       call vdu_set_screen_mode
0444C5 AF          0060       xor a
0444C6 CD 85 3F 04 0061       call vdu_set_scaling
0444CA             0062   
0444CA             0063   ; ; enable additional audio channels
0444CA             0064   ; 	call vdu_enable_channels
0444CA             0065   
0444CA             0066   ; set text background color
0444CA 3E 9A       0067       ld a,26+128 ; violet
0444CC CD DC 3E 04 0068       call vdu_colour_text
0444D0             0069   
0444D0             0070   ; set text foreground color
0444D0 3E 2F       0071       ld a,47 ; aaaaff lavenderish
0444D2 CD DC 3E 04 0072       call vdu_colour_text
0444D6             0073   
0444D6             0074   ; set gfx bg color
0444D6 AF          0075       xor a ; plotting mode 0
0444D7 3E 9A       0076       ld a,26+128 ; violet
0444D9 CD ED 3E 04 0077       call vdu_gcol
0444DD CD AB 3E 04 0078       call vdu_cls
0444E1             0079   
0444E1             0080   ; set the cursor off
0444E1 CD 73 3E 04 0081       call vdu_cursor_off
0444E5             0082   
0444E5             0083   ; VDU 28, left, bottom, right, top: Set text viewport **
0444E5             0084   ; MIND THE LITTLE-ENDIANESS
0444E5             0085   ; inputs: c=left,b=bottom,e=right,d=top
0444E5 0E 00       0086       ld c,0 ; left
0444E7 16 1D       0087       ld d,29 ; top
0444E9 1E 27       0088       ld e,39 ; right
0444EB 06 1D       0089       ld b,29; bottom
0444ED CD 04 3F 04 0090       call vdu_set_txt_viewport
0444F1             0091   
0444F1             0092   ; print loading ui message
0444F1 21 87 44 04 0093       ld hl,loading_ui
0444F5 CD 77 00 04 0094       call printString
0444F9 CD B0 3E 04 0095       call vdu_flip
0444FD             0096   
0444FD             0097   ; load UI images
0444FD CD 1F 14 04 0098       call load_ui_images
044501             0099   
044501             0100   ; ; load fonts ; TODO
044501             0101   ; 	call load_font_rc
044501             0102   
044501             0103   ; load sprites
044501 CD C8 14 04 0104       call img_load_init ; sets up the animated load screen
044505 CD 3A 14 04 0105       call load_sprite_images
044509             0106   
044509             0107   ; ; load sound effects ; TODO
044509             0108   ; 	ld bc,SFX_num_buffers
044509             0109   ; 	ld hl,SFX_buffer_id_lut
044509             0110   ; 	ld (cur_buffer_id_lut),hl
044509             0111   ; 	ld hl,SFX_load_routines_table
044509             0112   ; 	ld (cur_load_jump_table),hl
044509             0113   ; 	call sfx_load_main
044509             0114   
044509             0115   ; print loading complete message and wait for user keypress
044509 CD AB 3E 04 0116       call vdu_cls
04450D 21 A0 44 04 0117       ld hl,loading_complete
044511 CD 77 00 04 0118       call printString
044515 CD B0 3E 04 0119       call vdu_flip
044519 CD 15 06 04 0120       call waitKeypress
04451D             0121   
04451D             0122   ; set up display for gameplay
04451D             0123       ; ld a,8
04451D 3E 14       0124       ld a,20
04451F CD 74 3F 04 0125       call vdu_set_screen_mode
044523 AF          0126       xor a
044524 CD 85 3F 04 0127       call vdu_set_scaling
044528 CD 73 3E 04 0128       call vdu_cursor_off
04452C             0129   ; plot bezel art
04452C 21 00 00 00 0130       ld hl,BUF_BEZEL_L
044530 CD 98 3F 04 0131       call vdu_buff_select
044534 01 00 00 00 0132       ld bc,0
044538 11 00 00 00 0133       ld de,0
04453C CD 61 42 04 0134       call vdu_plot_bmp
044540 21 01 00 00 0135       ld hl,BUF_BEZEL_R
044544 CD 98 3F 04 0136       call vdu_buff_select
044548 01 80 01 00 0137       ld bc,384
04454C 11 00 00 00 0138       ld de,0
044550 CD 61 42 04 0139       call vdu_plot_bmp
044554             0140   ; set gfx origin and viewport to playing field window
044554 01 80 00 00 0141       ld bc,origin_left
044558 11 00 00 00 0142       ld de,origin_top
04455C CD 30 3F 04 0143       call vdu_set_gfx_origin
044560 01 00 00 00 0144       ld bc,field_left
044564 11 00 00 00 0145       ld de,field_top
044568 DD 21 FF 00 0146       ld ix,field_right
       00          
04456D FD 21 7F 01 0147       ld iy,field_bottom
       00          
044572 CD 4B 3F 04 0148       call vdu_set_gfx_viewport
044576             0149   ; set background color
044576 3E 9A       0150       ld a,26+128 ; violet
044578 CD ED 3E 04 0151       call vdu_gcol
04457C CD BE 3E 04 0152       call vdu_clg
044580             0153   ; VDU 28, left, bottom, right, top: Set text viewport **
044580 0E 00       0154       ld c,0 ; left
044582 16 00       0155       ld d,0 ; top
044584 1E 3E       0156       ld e,62 ; right
044586 06 07       0157       ld b,7; bottom
044588 CD 04 3F 04 0158       call vdu_set_txt_viewport
04458C             0159   
04458C C9          0160       ret
04458D             0161   
04458D             0162   
04458D             0163   
04458D             0164   main:
04458D             0165   ; start a new game
04458D CD B7 45 04 0166       call new_game
044591             0167   
044591             0168   main_loop:
044591             0169   ; scroll tiles
044591 CD D7 3B 04 0170       call tiles_plot
044595             0171   
044595             0172   ; call state-specific player routines
044595 CD 77 3B 04 0173       call player_do
044599             0174   
044599             0175   ; move enemies
044599 CD AD 07 04 0176       call move_enemies
04459D             0177   
04459D             0178   ; wait for the next vblank mitigate flicker and for loop timing
04459D CD 1F 3F 04 0179       call vdu_vblank
0445A1             0180   
0445A1             0181   ; poll keyboard
0445A1 3E 08       0182       ld a, $08 ; code to send to MOS
0445A3 5B CF       0183       rst.lil $08 ; get IX pointer to System Variables
0445A5             0184   
0445A5 DD 7E 05    0185       ld a, (ix + $05) ; get ASCII code of key pressed
0445A8 FE 1B       0186       cp 27 ; check if 27 (ascii code for ESC)
0445AA CA B2 45 04 0187       jp z, main_end ; if pressed, jump to exit
0445AE             0188   
0445AE C3 91 45 04 0189       jp main_loop
0445B2             0190   
0445B2             0191   main_end:
0445B2 CD 65 3E 04 0192       call vdu_cursor_on
0445B6 C9          0193       ret
0445B7             0194   
0445B7             0195   new_game:
0445B7             0196   ; initialize sprites
0445B7 CD 92 3A 04 0197       call sprites_init
0445BB             0198   
0445BB             0199   ; initialize the first level
0445BB AF          0200       xor a
0445BC 32 8C 3B 04 0201       ld (cur_level),a
0445C0 CD 8C 3C 04 0202       call init_level
0445C4             0203   
0445C4             0204   ; initialize player
0445C4 CD F7 36 04 0205       call player_init
0445C8             0206   
0445C8             0207   ; spawn an enemy sprite
0445C8 06 10       0208       ld b,table_max_records
0445CA             0209   @spawn_enemy_loop:
0445CA C5          0210       push bc
0445CB CD 8F 08 04 0211       call enemy_init_from_landing_pad
0445CF C1          0212       pop bc
0445D0 10 F8       0213       djnz @spawn_enemy_loop
0445D2             0214   
0445D2 C9          0215       ret
0445D3             0216   
0445D3             0217   ; ; ###### INITIALIZE GAME #######
0445D3             0218   ; ; clear the screen
0445D3             0219   ;     ld a,3
0445D3             0220   ;     out (81h),a
0445D3             0221   
0445D3             0222   ; ; reset the sprite table
0445D3             0223   ;     xor a
0445D3             0224   ;     ld (table_active_sprites),a
0445D3             0225   ;     ld hl,table_limit
0445D3             0226   ;     ld (table_base),hl
0445D3             0227   ;     ld (table_pointer),hl
0445D3             0228   
0445D3             0229   ; ; draw a starfield over the entire screen
0445D3             0230   ;     ld b,#50 ; first row of visible screen
0445D3             0231   ; new_game_draw_stars_loop:
0445D3             0232   ;     push bc
0445D3             0233   ;     call draw_stars
0445D3             0234   ;     pop bc
0445D3             0235   ;     ld a,#10
0445D3             0236   ;     add a,b
0445D3             0237   ;     ld b,a
0445D3             0238   ;     jr nz,new_game_draw_stars_loop
0445D3             0239   
0445D3             0240   ; ; ; print a welcome message
0445D3             0241   ; ;     ld de,msg_welcome
0445D3             0242   ; ;     ld hl,#581C
0445D3             0243   ; ;     ld c,218 ; a bright pastel purple d677e3
0445D3             0244   ; ;     call print_string
0445D3             0245   
0445D3             0246   ; ; push all that to frame buffer
0445D3             0247   ;     ld a,#01 ; send video to frame buffer
0445D3             0248   ;     out (81h),a
0445D3             0249   
0445D3             0250   ; ; reset score, lives, shields
0445D3             0251   ;     xor a
0445D3             0252   ;     ld hl,player_score
0445D3             0253   ;     ld (hl),a ; player_score 0
0445D3             0254   ;     inc hl
0445D3             0255   ;     ld (hl),a ; player_score 1
0445D3             0256   ;     inc hl
0445D3             0257   ;     ld (hl),a ; player_score 3
0445D3             0258   ;     inc hl
0445D3             0259   ;     ld a,16
0445D3             0260   ;     ld (hl),a ; player_shields
0445D3             0261   ;     inc hl
0445D3             0262   ;     ld (hl),a ; player_max_shields
0445D3             0263   ;     inc hl
0445D3             0264   ;     ld a,3
0445D3             0265   ;     ld (hl),a ; player_ships
0445D3             0266   ;     inc hl
0445D3             0267   
0445D3             0268   ; ; initialize first level
0445D3             0269   ;     ld a,1 ; levels are zero-based, so this will wrap around
0445D3             0270   ;     ld (cur_level),a
0445D3             0271   ;     ld a,3 ; set max enemy sprites to easy street
0445D3             0272   ;     ld (max_enemy_sprites),a
0445D3             0273   ;     call dt_next_level
0445D3             0274   ;     call dt
0445D3             0275   
0445D3             0276   ; ; spawn our intrepid hero
0445D3             0277   ;     call player_init
0445D3             0278   
0445D3             0279   
0445D3             0280   ; ; #### BEGIN GAME MAIN LOOP ####
0445D3             0281   ; main_loop:
0445D3             0282   ; ; ; debug: start execution counter
0445D3             0283   ; ;     ld a,1
0445D3             0284   ; ;     out (#e0),a ; start counting instructions
0445D3             0285   
0445D3             0286   ; ; refresh background from frame buffer
0445D3             0287   ;     ld a,#02
0445D3             0288   ;     out (81h),a
0445D3             0289   ;     call move_background ; now move it
0445D3             0290   ;     ld a,#01
0445D3             0291   ;     out (81h),a ; save it back to buffer
0445D3             0292   ; ; do all the things
0445D3             0293   ;     call move_enemies
0445D3             0294   ;     call player_move
0445D3             0295   ;     call laser_control
0445D3             0296   ;     call print_score
0445D3             0297   ;     call draw_shields
0445D3             0298   ;     call draw_lives
0445D3             0299   ; ; ; debug: stop execution counter and print results
0445D3             0300   ; ;     ld a,0
0445D3             0301   ; ;     out (#e0),a ; stop counting instructions
0445D3             0302   
0445D3             0303   ; ; ; debug: start execution counter
0445D3             0304   ; ;     ld a,1
0445D3             0305   ; ;     out (#e0),a ; start counting instructions
0445D3             0306   
0445D3             0307   ;     call vdu_vblank
0445D3             0308   ; ; ; debug: stop execution counter and print results
0445D3             0309   ; ;     ld a,0
0445D3             0310   ; ;     out (#e0),a ; stop counting instructions
0445D3             0311   
0445D3             0312   ;     jr main_loop
0445D3             0313   ; #### END GAME MAIN LOOP ####
0445D3             0314   
0445D3             0315   ; draws the player's shields level
0445D3             0316   ; draw_shields:
0445D3             0317   ; TODO: Agonize this routine
0445D3             0318   ; ; prep the loop to draw the bars
0445D3             0319   ;     ld a,(player_shields) ; snag shields
0445D3             0320   ;     and a
0445D3             0321   ;     ret z ; don't draw if zero shields
0445D3             0322   ; ; set loop counter and drawing position
0445D3             0323   ;     ld b,a ; loop counter
0445D3             0324   ;     ld hl,#5300+48+12
0445D3             0325   ; ; set color based on bars remaining
0445D3             0326   ;     ld c,103 ; bright green 28fe0a
0445D3             0327   ;     cp 9
0445D3             0328   ;     jp p,draw_shields_loop
0445D3             0329   ;     ld c,74 ; bright yellow eafe5b
0445D3             0330   ;     cp 3
0445D3             0331   ;     jp p,draw_shields_loop
0445D3             0332   ;     ld c,28 ; bright red fe0a0a
0445D3             0333   ; draw_shields_loop:
0445D3             0334   ;     push bc ; yup,outta
0445D3             0335   ;     push hl ; registers again
0445D3             0336   ;     ; ld a,#A8 ; â–€,168
0445D3             0337   ;     ld a,10 ; â–€,168 ; we renumber because we don't use the full charset
0445D3             0338   ;     ; call draw_char
0445D3             0339   ;     call draw_num ; we nuked draw_char for the time being
0445D3             0340   ;     pop hl
0445D3             0341   ;     ld a,8
0445D3             0342   ;     add a,l
0445D3             0343   ;     ld l,a
0445D3             0344   ;     pop bc
0445D3             0345   ;     djnz draw_shields_loop
0445D3             0346       ; ret
0445D3             0347   
0445D3             0348   ; prints the player's score
0445D3             0349   ; print_score:
0445D3             0350   ; TODO: Agonize this
0445D3             0351   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0445D3             0352   ;     ld c,42 ; dark orange b74400
0445D3             0353   ;     ld hl,#5200+1+8+6*6
0445D3             0354   ;     ld a,3 ; print 6 bdc digits
0445D3             0355   ;     ld de,player_score
0445D3             0356   ;     call print_num
0445D3             0357   
0445D3             0358   ;     ld c,58 ; golden yellow fec10a
0445D3             0359   ;     ld hl,#5100+8+6*6
0445D3             0360   ;     ld a,3 ; print 6 bdc digits
0445D3             0361   ;     ld de,player_score
0445D3             0362   ;     call print_num
0445D3             0363       ; ret
0445D3             0364   
0445D3             0365   ; draw_lives:
0445D3             0366   ;     ld hl,player_small ; make small yellow ship the active sprite
0445D3             0367   ;     ld (sprite_base_bufferId),hl
0445D3             0368   ;     ; ld a,#80 ; northern orientation
0445D3             0369   ;     ; ld (sprite_orientation),a
0445D3             0370   ;     ld hl,0 ; north
0445D3             0371   ;     ld (sprite_heading),hl
0445D3             0372   ;     xor a
0445D3             0373   ;     ld (sprite_animation),a
0445D3             0374   ;     ld a,#56 ; top of visible screen
0445D3             0375   ;     ld (sprite_y+1),a
0445D3             0376   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0445D3             0377   ;     ld a,(player_ships)
0445D3             0378   ;     dec a ; we draw one fewer ships than lives
0445D3             0379   ;     ret z ; nothing to draw here, move along
0445D3             0380   ;     ld b,a ; loop counter
0445D3             0381   ;     ld a,256-16 ; initial x position
0445D3             0382   ; draw_lives_loop:
0445D3             0383   ;     ld (sprite_x+1),a
0445D3             0384   ;     push af
0445D3             0385   ;     push bc
0445D3             0386   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0445D3             0387   ;     pop bc
0445D3             0388   ;     pop af
0445D3             0389   ;     sub 10
0445D3             0390   ;     djnz draw_lives_loop
0445D3             0391   ;     ret
