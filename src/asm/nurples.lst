PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 76 77 04 0030   	call	init			; Initialization code
040050 CD FC 77 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "images2.asm"
040060             0001*  ; Bitmap indices:
040060             0002*  BUF_0TILE_EMPTY: equ $0100
040060             0003*  BUF_1TILE_CROSS: equ $0101
040060             0004*  BUF_2TILE_HORIZ: equ $0102
040060             0005*  BUF_3TILE_VERT: equ $0103
040060             0006*  BUF_4TILE_SQUARE: equ $0104
040060             0007*  BUF_5TILE_CIRCLE: equ $0105
040060             0008*  BUF_6TILE_PAD: equ $0106
040060             0009*  BUF_7TILE_TURRET: equ $0107
040060             0010*  BUF_CIRCLE: equ $0108
040060             0011*  BUF_CRATER: equ $0109
040060             0012*  BUF_EXPLOSION_A: equ $010A
040060             0013*  BUF_EXPLOSION_B: equ $010B
040060             0014*  BUF_EXPLOSION_C: equ $010C
040060             0015*  BUF_EXPLOSION_D: equ $010D
040060             0016*  BUF_EXPLOSION_E: equ $010E
040060             0017*  BUF_FIREBALL_A: equ $010F
040060             0018*  BUF_FIREBALL_B: equ $0110
040060             0019*  BUF_LASER_A: equ $0111
040060             0020*  BUF_LASER_B: equ $0112
040060             0021*  BUF_PAD: equ $0113
040060             0022*  BUF_SEEKER_000: equ $0114
040060             0023*  BUF_SEEKER_008: equ $0115
040060             0024*  BUF_SEEKER_016: equ $0116
040060             0025*  BUF_SEEKER_024: equ $0117
040060             0026*  BUF_SEEKER_032: equ $0118
040060             0027*  BUF_SEEKER_040: equ $0119
040060             0028*  BUF_SEEKER_048: equ $011A
040060             0029*  BUF_SEEKER_056: equ $011B
040060             0030*  BUF_SEEKER_064: equ $011C
040060             0031*  BUF_SEEKER_072: equ $011D
040060             0032*  BUF_SEEKER_080: equ $011E
040060             0033*  BUF_SEEKER_088: equ $011F
040060             0034*  BUF_SEEKER_096: equ $0120
040060             0035*  BUF_SEEKER_104: equ $0121
040060             0036*  BUF_SEEKER_112: equ $0122
040060             0037*  BUF_SEEKER_120: equ $0123
040060             0038*  BUF_SEEKER_128: equ $0124
040060             0039*  BUF_SEEKER_136: equ $0125
040060             0040*  BUF_SEEKER_144: equ $0126
040060             0041*  BUF_SEEKER_152: equ $0127
040060             0042*  BUF_SEEKER_160: equ $0128
040060             0043*  BUF_SEEKER_168: equ $0129
040060             0044*  BUF_SEEKER_176: equ $012A
040060             0045*  BUF_SEEKER_184: equ $012B
040060             0046*  BUF_SEEKER_192: equ $012C
040060             0047*  BUF_SEEKER_200: equ $012D
040060             0048*  BUF_SEEKER_208: equ $012E
040060             0049*  BUF_SEEKER_216: equ $012F
040060             0050*  BUF_SEEKER_224: equ $0130
040060             0051*  BUF_SEEKER_232: equ $0131
040060             0052*  BUF_SEEKER_240: equ $0132
040060             0053*  BUF_SEEKER_248: equ $0133
040060             0054*  BUF_SHIP_0L: equ $0134
040060             0055*  BUF_SHIP_1C: equ $0135
040060             0056*  BUF_SHIP_2R: equ $0136
040060             0057*  BUF_SHIP_SMALL: equ $0137
040060             0058*  BUF_STAR: equ $0138
040060             0059*  BUF_TURRET: equ $0139
040060             0060*  BUF_TURRET_ROT: equ $013A
040060             0061*  
040060             0062*  ; import .rgba bitmap files and load them into VDP buffers
040060             0063*  bmp2_init:
040060 21 6B 00 04 0064*  	ld hl, @cmd
040064 01 40 3A 00 0065*  	ld bc, @end-@cmd
040068 5B DF       0066*  	rst.lil $18
04006A C9          0067*  	ret
04006B             0068*  @cmd:
04006B             0069*  	LOADBMPBUFFER2 BUF_0TILE_EMPTY,16,16,"../../tgt/sprites/0tile_empty.rgba2"
04006B             0001*M 
04006B             0002*M     ; Clear buffer
04006B 17 00 A0    0003*M     db 23,0,0xA0
04006E 00 01       0004*M     dw bufferId
040070 02          0005*M     db 2
040071             0006*M 
040071 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040074 00 01       0008*M     dw bufferId
040076             0009*M 
040076             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040076 17 00 A0    0011*M     db 23,0,0xA0
040079 00 01       0012*M     dw bufferId
04007B 00          0013*M     db 0
04007C 00 01       0014*M 	dw width * height ; length of data in bytes
04007E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04017E             0016*M 
04017E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04017E 17 1B 21    0018*M     db 23,27,0x21
040181 10 00       0019*M     dw width ; in pixels
040183 10 00       0020*M     dw height ; in pixels
040185 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040186             0070*  	LOADBMPBUFFER2 BUF_1TILE_CROSS,16,16,"../../tgt/sprites/1tile_cross.rgba2"
040186             0001*M 
040186             0002*M     ; Clear buffer
040186 17 00 A0    0003*M     db 23,0,0xA0
040189 01 01       0004*M     dw bufferId
04018B 02          0005*M     db 2
04018C             0006*M 
04018C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04018F 01 01       0008*M     dw bufferId
040191             0009*M 
040191             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040191 17 00 A0    0011*M     db 23,0,0xA0
040194 01 01       0012*M     dw bufferId
040196 00          0013*M     db 0
040197 00 01       0014*M 	dw width * height ; length of data in bytes
040199 00 00 D0 F5 0015*M     incbin file ; bitmap data
       FA FF FF FF 
       FF FF FF EA 
       F5 D0 00 00 
       00 00 D0 F5 
       FA EA FF FF 
       FF FF EA EA 
       F5 D0 00 00 
       D0 D0 D0 F5 
       FA FF FF FF 
       FF FF EA EA 
       F5 D0 D0 D0 
       F5 F5 F5 F5 
       FB FA EA EA 
       EA EA EA E5 
       F5 F5 F5 F5 
       D1 E5 E5 D0 
       FA FB E5 FA 
       FA FA FA FA 
       C0 D0 D0 D0 
       E1 E1 D0 D0 
       FA D1 D0 D1 
       D0 D0 D0 EA 
       D1 D1 D1 D1 
       FA FF E5 E5 
       E5 D0 F8 FD 
       FE F8 D0 E5 
       D1 E5 E5 E5 
       FA FF FA E5 
       E5 D0 F8 FD 
       FE F8 D0 FA 
       E5 E5 E5 E5 
       E5 FB FA E5 
       E5 D0 F8 FD 
       FE F8 E1 FA 
       E5 E5 E5 E5 
       FA FA FA E5 
       E5 D0 F8 FD 
       FD F8 D0 FA 
       E5 E5 E5 E5 
       E5 E5 E5 E5 
       E5 D0 F8 F8 
       F8 F8 D0 FA 
       D1 D1 D1 D1 
       E1 E1 E1 E1 
       D1 D0 D0 D0 
       D0 D0 D0 E5 
       D0 D1 D0 D0 
       F5 F5 F5 F5 
       E5 D1 E1 E5 
       E5 E5 E5 E5 
       F5 F5 F5 F5 
       D0 D0 D0 F5 
       E5 E5 E5 E5 
       E6 E5 E5 E5 
       F5 D0 D0 D0 
       00 00 D0 F5 
       E5 E6 D6 E6 
       D7 E6 E6 E5 
       F5 D0 00 00 
       00 00 D0 F5 
       E5 E6 E6 D6 
       D6 D6 E6 E5 
       F5 D0 00 00 
040299             0016*M 
040299             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040299 17 1B 21    0018*M     db 23,27,0x21
04029C 10 00       0019*M     dw width ; in pixels
04029E 10 00       0020*M     dw height ; in pixels
0402A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0402A1             0071*  	LOADBMPBUFFER2 BUF_2TILE_HORIZ,16,16,"../../tgt/sprites/2tile_horiz.rgba2"
0402A1             0001*M 
0402A1             0002*M     ; Clear buffer
0402A1 17 00 A0    0003*M     db 23,0,0xA0
0402A4 02 01       0004*M     dw bufferId
0402A6 02          0005*M     db 2
0402A7             0006*M 
0402A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0402AA 02 01       0008*M     dw bufferId
0402AC             0009*M 
0402AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0402AC 17 00 A0    0011*M     db 23,0,0xA0
0402AF 02 01       0012*M     dw bufferId
0402B1 00          0013*M     db 0
0402B2 00 01       0014*M 	dw width * height ; length of data in bytes
0402B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF F8 
       F8 F8 F8 EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF FF 
       EA EA FA FA 
       F8 F8 EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FA E5 
       F8 F8 EA EA 
       D0 E6 E6 D1 
       D1 D1 D1 EA 
       EA F8 F5 F5 
       EA F8 EA D0 
       C0 D1 D1 D1 
       D1 D2 D1 D0 
       D0 EA F5 E5 
       EA EA F8 E5 
       E5 E6 E6 E6 
       E6 E6 D1 F8 
       E5 EA E5 E5 
       EA E5 D1 D1 
       D1 D1 D1 D1 
       D1 D1 C0 D1 
       EA D1 EA D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0403B4             0016*M 
0403B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0403B4 17 1B 21    0018*M     db 23,27,0x21
0403B7 10 00       0019*M     dw width ; in pixels
0403B9 10 00       0020*M     dw height ; in pixels
0403BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0403BC             0072*  	LOADBMPBUFFER2 BUF_3TILE_VERT,16,16,"../../tgt/sprites/3tile_vert.rgba2"
0403BC             0001*M 
0403BC             0002*M     ; Clear buffer
0403BC 17 00 A0    0003*M     db 23,0,0xA0
0403BF 03 01       0004*M     dw bufferId
0403C1 02          0005*M     db 2
0403C2             0006*M 
0403C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0403C5 03 01       0008*M     dw bufferId
0403C7             0009*M 
0403C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0403C7 17 00 A0    0011*M     db 23,0,0xA0
0403CA 03 01       0012*M     dw bufferId
0403CC 00          0013*M     db 0
0403CD 00 01       0014*M 	dw width * height ; length of data in bytes
0403CF 00 00 D0 F5 0015*M     incbin file ; bitmap data
       D0 D0 D0 D0 
       E5 E5 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 E5 E5 
       E5 F8 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E5 E5 
       FA F8 FD F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E1 E5 
       E5 E5 FA F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 D0 D1 
       E6 E6 FA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D1 D1 D1 
       FB EA FB D1 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 EA C0 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E1 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 C0 EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 F8 F8 
       FA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       EA EA F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 E5 F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
0404CF             0016*M 
0404CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0404CF 17 1B 21    0018*M     db 23,27,0x21
0404D2 10 00       0019*M     dw width ; in pixels
0404D4 10 00       0020*M     dw height ; in pixels
0404D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0404D7             0073*  	LOADBMPBUFFER2 BUF_4TILE_SQUARE,16,16,"../../tgt/sprites/4tile_square.rgba2"
0404D7             0001*M 
0404D7             0002*M     ; Clear buffer
0404D7 17 00 A0    0003*M     db 23,0,0xA0
0404DA 04 01       0004*M     dw bufferId
0404DC 02          0005*M     db 2
0404DD             0006*M 
0404DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0404E0 04 01       0008*M     dw bufferId
0404E2             0009*M 
0404E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0404E2 17 00 A0    0011*M     db 23,0,0xA0
0404E5 04 01       0012*M     dw bufferId
0404E7 00          0013*M     db 0
0404E8 00 01       0014*M 	dw width * height ; length of data in bytes
0404EA D0 D1 E5 D1 0015*M     incbin file ; bitmap data
       E5 E5 D0 D5 
       D0 D0 D0 D0 
       D0 D5 D0 D1 
       D5 EA EA EA 
       EA E5 E5 E5 
       E5 E5 E5 D5 
       D1 FF E9 D5 
       D0 EA EA D5 
       D5 D5 D1 D5 
       D4 D4 FE FE 
       D1 EA E5 D5 
       D0 C0 D1 D1 
       D2 D2 E6 E9 
       FE FE FE FE 
       C0 C0 C0 D1 
       D0 D1 D1 D2 
       D2 D2 E6 D4 
       E9 E9 FE FE 
       D1 D0 D0 D0 
       D0 D1 D2 D2 
       D2 D2 D5 C0 
       D1 D1 D4 E9 
       D1 C0 E5 D0 
       D0 D1 C0 D5 
       D5 D5 E6 E6 
       E6 E6 D1 E5 
       E5 C0 E5 E5 
       D0 D1 D1 E9 
       FE D5 D1 D2 
       D2 D1 D1 E9 
       E9 C0 D1 D0 
       E5 D1 C0 D0 
       E5 D0 D1 D2 
       D2 D1 D1 E5 
       E5 C0 EA D0 
       E5 E5 C0 C0 
       D5 C1 D5 D1 
       D1 C1 D1 D0 
       D4 D5 EA D0 
       E5 E5 D5 D2 
       D2 D2 D0 D0 
       D5 D5 D5 E9 
       E9 C0 EA E5 
       E5 E5 D5 D2 
       D2 D2 EA E9 
       FA FA D4 E6 
       E5 D5 E5 D1 
       D0 EA D5 D2 
       D1 C1 D5 E5 
       E9 E9 D0 E5 
       D0 E5 E5 E5 
       D0 D4 E9 D4 
       C0 C0 D5 C0 
       D0 D0 C0 D0 
       D0 EA EA D0 
       D0 D4 D4 D5 
       C0 D0 D5 C0 
       C0 C0 D0 C0 
       D0 D0 D0 D0 
       D0 D0 D0 C0 
       C0 D0 D0 D0 
       D5 D0 D0 C0 
       D0 D5 D0 D0 
0405EA             0016*M 
0405EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0405EA 17 1B 21    0018*M     db 23,27,0x21
0405ED 10 00       0019*M     dw width ; in pixels
0405EF 10 00       0020*M     dw height ; in pixels
0405F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0405F2             0074*  	LOADBMPBUFFER2 BUF_5TILE_CIRCLE,16,16,"../../tgt/sprites/5tile_circle.rgba2"
0405F2             0001*M 
0405F2             0002*M     ; Clear buffer
0405F2 17 00 A0    0003*M     db 23,0,0xA0
0405F5 05 01       0004*M     dw bufferId
0405F7 02          0005*M     db 2
0405F8             0006*M 
0405F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0405FB 05 01       0008*M     dw bufferId
0405FD             0009*M 
0405FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0405FD 17 00 A0    0011*M     db 23,0,0xA0
040600 05 01       0012*M     dw bufferId
040602 00          0013*M     db 0
040603 00 01       0014*M 	dw width * height ; length of data in bytes
040605 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 D0 D0 D1 
       EA D1 D1 D0 
       D0 00 00 00 
       00 00 D0 D0 
       D0 D1 D1 EA 
       FB EA D1 D1 
       D0 D0 00 00 
       00 D0 D0 D1 
       D1 D0 D0 D1 
       D1 EA D1 E5 
       EA D0 D0 00 
       00 D0 E1 D1 
       D0 D0 CA EA 
       EA D7 EA E6 
       D1 D1 D0 00 
       D0 D1 E1 FA 
       D1 CA EF FF 
       FF EF D7 D0 
       D1 D1 D1 D0 
       D0 D0 D0 E5 
       FB EA EF FF 
       FF EF EA D0 
       E5 D0 D0 D0 
       D0 E1 D0 EA 
       EA EF EF EF 
       EF EF EA E5 
       EA D0 D0 D0 
       D0 D0 D0 D1 
       EA F8 EA EA 
       EA EA F8 D0 
       EA D0 D1 D0 
       D0 D0 D1 D1 
       E5 EA F8 F8 
       F8 F8 E5 E1 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D1 E5 E5 E1 
       E1 E1 E1 D0 
       D0 D1 D0 D0 
       00 D0 D0 D0 
       D0 D0 C0 D0 
       D0 C0 D0 D0 
       D0 C0 D0 00 
       00 D0 D0 D0 
       C0 C0 EA E6 
       E6 D1 C0 C0 
       D0 D0 D0 00 
       00 00 D0 D0 
       C0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 D0 00 00 
       00 00 00 D0 
       D0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040705             0016*M 
040705             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040705 17 1B 21    0018*M     db 23,27,0x21
040708 10 00       0019*M     dw width ; in pixels
04070A 10 00       0020*M     dw height ; in pixels
04070C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04070D             0075*  	LOADBMPBUFFER2 BUF_6TILE_PAD,16,16,"../../tgt/sprites/6tile_pad.rgba2"
04070D             0001*M 
04070D             0002*M     ; Clear buffer
04070D 17 00 A0    0003*M     db 23,0,0xA0
040710 06 01       0004*M     dw bufferId
040712 02          0005*M     db 2
040713             0006*M 
040713 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040716 06 01       0008*M     dw bufferId
040718             0009*M 
040718             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040718 17 00 A0    0011*M     db 23,0,0xA0
04071B 06 01       0012*M     dw bufferId
04071D 00          0013*M     db 0
04071E 00 01       0014*M 	dw width * height ; length of data in bytes
040720 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
040820             0016*M 
040820             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040820 17 1B 21    0018*M     db 23,27,0x21
040823 10 00       0019*M     dw width ; in pixels
040825 10 00       0020*M     dw height ; in pixels
040827 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040828             0076*  	LOADBMPBUFFER2 BUF_7TILE_TURRET,16,16,"../../tgt/sprites/7tile_turret.rgba2"
040828             0001*M 
040828             0002*M     ; Clear buffer
040828 17 00 A0    0003*M     db 23,0,0xA0
04082B 07 01       0004*M     dw bufferId
04082D 02          0005*M     db 2
04082E             0006*M 
04082E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040831 07 01       0008*M     dw bufferId
040833             0009*M 
040833             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040833 17 00 A0    0011*M     db 23,0,0xA0
040836 07 01       0012*M     dw bufferId
040838 00          0013*M     db 0
040839 00 01       0014*M 	dw width * height ; length of data in bytes
04083B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
04093B             0016*M 
04093B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04093B 17 1B 21    0018*M     db 23,27,0x21
04093E 10 00       0019*M     dw width ; in pixels
040940 10 00       0020*M     dw height ; in pixels
040942 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040943             0077*  	LOADBMPBUFFER2 BUF_CIRCLE,16,16,"../../tgt/sprites/circle.rgba2"
040943             0001*M 
040943             0002*M     ; Clear buffer
040943 17 00 A0    0003*M     db 23,0,0xA0
040946 08 01       0004*M     dw bufferId
040948 02          0005*M     db 2
040949             0006*M 
040949 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04094C 08 01       0008*M     dw bufferId
04094E             0009*M 
04094E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04094E 17 00 A0    0011*M     db 23,0,0xA0
040951 08 01       0012*M     dw bufferId
040953 00          0013*M     db 0
040954 00 01       0014*M 	dw width * height ; length of data in bytes
040956 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040A56             0016*M 
040A56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040A56 17 1B 21    0018*M     db 23,27,0x21
040A59 10 00       0019*M     dw width ; in pixels
040A5B 10 00       0020*M     dw height ; in pixels
040A5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040A5E             0078*  	LOADBMPBUFFER2 BUF_CRATER,16,16,"../../tgt/sprites/crater.rgba2"
040A5E             0001*M 
040A5E             0002*M     ; Clear buffer
040A5E 17 00 A0    0003*M     db 23,0,0xA0
040A61 09 01       0004*M     dw bufferId
040A63 02          0005*M     db 2
040A64             0006*M 
040A64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040A67 09 01       0008*M     dw bufferId
040A69             0009*M 
040A69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A69 17 00 A0    0011*M     db 23,0,0xA0
040A6C 09 01       0012*M     dw bufferId
040A6E 00          0013*M     db 0
040A6F 00 01       0014*M 	dw width * height ; length of data in bytes
040A71 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E2 C0 F2 
       C0 D1 E2 00 
       00 00 00 00 
       00 00 D2 D5 
       C0 D2 C0 C6 
       D1 C6 D1 C1 
       C0 E2 00 00 
       00 F2 EA D5 
       DF C0 D1 D2 
       DF D2 D1 C1 
       C0 EA C0 00 
       00 F2 D5 C0 
       C0 C0 CB D1 
       D6 DF D5 C0 
       C0 C0 D5 00 
       F2 D5 C0 C6 
       C0 CB D1 D6 
       D6 D7 D6 C0 
       D5 C1 C0 C0 
       D5 C0 C0 D5 
       C1 D1 C1 D6 
       C2 D7 C2 C1 
       C0 CB C1 C1 
       C1 C6 C0 C1 
       DF C2 D6 D7 
       D7 DB D6 CB 
       C1 D6 D6 D5 
       C0 C0 C0 D5 
       F7 D6 D7 DB 
       EB EF D7 D6 
       D6 CB C1 C1 
       C1 D6 C0 C1 
       D6 EB EB FF 
       CB FF FF EB 
       D6 C1 C1 D5 
       EA D5 C0 DF 
       C2 EA EA FF 
       FF FF EA C0 
       D6 D2 D5 C0 
       00 FA C2 D5 
       D5 C1 C0 CB 
       EA C0 D6 C1 
       C1 D5 E2 00 
       00 F2 FA C1 
       D5 D6 D5 C2 
       C0 D2 D2 D5 
       D6 C1 D5 00 
       00 00 FA F2 
       EB D6 C0 C0 
       C1 D5 D6 D6 
       EA D5 00 00 
       00 00 00 00 
       00 FA F6 F2 
       FA F6 F6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71             0016*M 
040B71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040B71 17 1B 21    0018*M     db 23,27,0x21
040B74 10 00       0019*M     dw width ; in pixels
040B76 10 00       0020*M     dw height ; in pixels
040B78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040B79             0079*  	LOADBMPBUFFER2 BUF_EXPLOSION_A,16,16,"../../tgt/sprites/explosion_a.rgba2"
040B79             0001*M 
040B79             0002*M     ; Clear buffer
040B79 17 00 A0    0003*M     db 23,0,0xA0
040B7C 0A 01       0004*M     dw bufferId
040B7E 02          0005*M     db 2
040B7F             0006*M 
040B7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040B82 0A 01       0008*M     dw bufferId
040B84             0009*M 
040B84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B84 17 00 A0    0011*M     db 23,0,0xA0
040B87 0A 01       0012*M     dw bufferId
040B89 00          0013*M     db 0
040B8A 00 01       0014*M 	dw width * height ; length of data in bytes
040B8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 3F 
       3F 3F 2F C7 
       C7 C7 07 00 
       00 00 00 00 
       00 00 00 3F 
       3F 3F C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 3F 
       3F 3F C7 EF 
       EF EF C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 3F C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 3F 07 C7 
       C7 C7 07 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C8C             0016*M 
040C8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040C8C 17 1B 21    0018*M     db 23,27,0x21
040C8F 10 00       0019*M     dw width ; in pixels
040C91 10 00       0020*M     dw height ; in pixels
040C93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040C94             0080*  	LOADBMPBUFFER2 BUF_EXPLOSION_B,16,16,"../../tgt/sprites/explosion_b.rgba2"
040C94             0001*M 
040C94             0002*M     ; Clear buffer
040C94 17 00 A0    0003*M     db 23,0,0xA0
040C97 0B 01       0004*M     dw bufferId
040C99 02          0005*M     db 2
040C9A             0006*M 
040C9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040C9D 0B 01       0008*M     dw bufferId
040C9F             0009*M 
040C9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040C9F 17 00 A0    0011*M     db 23,0,0xA0
040CA2 0B 01       0012*M     dw bufferId
040CA4 00          0013*M     db 0
040CA5 00 01       0014*M 	dw width * height ; length of data in bytes
040CA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 3F 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F C7 C7 00 
       00 00 3F 3F 
       3F 3F 3F C7 
       C7 C7 3F 3F 
       3F C7 C7 00 
       00 00 3F 3F 
       3F C7 C7 EF 
       EF EF C7 C7 
       3F 07 07 00 
       00 00 3F 3F 
       3F C7 EF EF 
       EF EF EF C7 
       3F 07 07 00 
       00 00 3F 3F 
       C7 EF EF EF 
       EF EF EF EF 
       C7 3F 3F 00 
       00 00 3F C7 
       C7 EF EF EF 
       EF EF EF EF 
       C7 3F 3F 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF EF 
       C7 3F 3F 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF C7 
       3F 3F 3F 00 
       00 00 3F C7 
       C7 C7 C7 EF 
       EF EF C7 C7 
       3F 3F 3F 00 
       00 00 3F 3F 
       2F 07 07 C7 
       C7 C7 07 07 
       07 3F 3F 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040DA7             0016*M 
040DA7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040DA7 17 1B 21    0018*M     db 23,27,0x21
040DAA 10 00       0019*M     dw width ; in pixels
040DAC 10 00       0020*M     dw height ; in pixels
040DAE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040DAF             0081*  	LOADBMPBUFFER2 BUF_EXPLOSION_C,16,16,"../../tgt/sprites/explosion_c.rgba2"
040DAF             0001*M 
040DAF             0002*M     ; Clear buffer
040DAF 17 00 A0    0003*M     db 23,0,0xA0
040DB2 0C 01       0004*M     dw bufferId
040DB4 02          0005*M     db 2
040DB5             0006*M 
040DB5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040DB8 0C 01       0008*M     dw bufferId
040DBA             0009*M 
040DBA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040DBA 17 00 A0    0011*M     db 23,0,0xA0
040DBD 0C 01       0012*M     dw bufferId
040DBF 00          0013*M     db 0
040DC0 00 01       0014*M 	dw width * height ; length of data in bytes
040DC2 3F C7 07 3F 0015*M     incbin file ; bitmap data
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F 3F 00 
       3F 07 07 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       C6 C6 06 00 
       3F 07 07 3F 
       3F 3F C7 C7 
       C7 C7 3F C6 
       C7 C7 C6 00 
       3F 3F 3F 3F 
       C7 C7 EF EF 
       EF EF C7 C6 
       C7 C7 C6 00 
       3F 3F 3F C7 
       EF EF EF EF 
       EF EF EF EF 
       C6 C6 3F 00 
       3F 3F 3F C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 07 07 00 
       3F 3F C7 EF 
       EF EF EF EF 
       EF EF EF EF 
       EF C7 06 00 
       07 C6 C6 C6 
       C6 EF EF EF 
       EF EF EF EF 
       EF C7 3F 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       EF C7 3F 00 
       C6 C7 C7 EF 
       C7 C6 EF EF 
       EF EF EF EF 
       EF C7 3F 00 
       C6 C7 06 C7 
       C7 C6 EF EF 
       EF EF EF EF 
       C7 3F 3F 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       C7 3F 3F 00 
       06 C6 C6 C6 
       C6 C7 EF EF 
       EF EF C7 C7 
       3F 3F 3F 00 
       3F 3F 2F 07 
       07 07 C7 C7 
       C7 C7 07 07 
       07 07 3F 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040EC2             0016*M 
040EC2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040EC2 17 1B 21    0018*M     db 23,27,0x21
040EC5 10 00       0019*M     dw width ; in pixels
040EC7 10 00       0020*M     dw height ; in pixels
040EC9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040ECA             0082*  	LOADBMPBUFFER2 BUF_EXPLOSION_D,16,16,"../../tgt/sprites/explosion_d.rgba2"
040ECA             0001*M 
040ECA             0002*M     ; Clear buffer
040ECA 17 00 A0    0003*M     db 23,0,0xA0
040ECD 0D 01       0004*M     dw bufferId
040ECF 02          0005*M     db 2
040ED0             0006*M 
040ED0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040ED3 0D 01       0008*M     dw bufferId
040ED5             0009*M 
040ED5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040ED5 17 00 A0    0011*M     db 23,0,0xA0
040ED8 0D 01       0012*M     dw bufferId
040EDA 00          0013*M     db 0
040EDB 00 01       0014*M 	dw width * height ; length of data in bytes
040EDD 3F C7 C7 07 0015*M     incbin file ; bitmap data
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F C6 06 3F 
       3F C7 C7 07 
       3F 3F C6 C6 
       C6 C6 3F C6 
       06 06 06 3F 
       3F 3F 07 07 
       C6 C6 C7 C7 
       C7 C7 C6 C6 
       C6 C6 06 3F 
       07 07 07 C6 
       C7 C7 EF EF 
       EF EF EF EF 
       C6 C6 06 C6 
       07 07 C6 C7 
       EF EF EF EF 
       EF EF EF C6 
       C7 C6 06 06 
       3F 3F C6 C7 
       EF EF EF 3F 
       3F EF EF EF 
       C7 C6 C6 06 
       3F C6 C7 EF 
       EF EF 3F 3F 
       3F 3F EF EF 
       EF C7 C6 06 
       3F C6 C7 EF 
       EF 3F 3F 3F 
       3F 3F 3F EF 
       EF C7 C6 06 
       3F C7 C7 C7 
       C7 07 3F 3F 
       3F 3F 3F EF 
       EF C7 C6 3F 
       C7 C6 C7 EF 
       EF C7 07 3F 
       3F 3F EF EF 
       EF C7 C6 3F 
       C6 06 C6 C7 
       EF C7 EF 3F 
       3F EF EF EF 
       C7 C6 3F 3F 
       C6 06 C6 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 C6 3F 3F 
       C6 06 3F C6 
       C7 C7 EF EF 
       EF EF C7 C7 
       C6 3F 3F 3F 
       06 C6 C6 C6 
       C7 C6 C7 C7 
       C7 C7 C6 C6 
       3F 3F 3F 3F 
       3F 3F 3F 06 
       07 07 C6 C6 
       C6 C6 07 07 
       07 06 3F 3F 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FDD             0016*M 
040FDD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040FDD 17 1B 21    0018*M     db 23,27,0x21
040FE0 10 00       0019*M     dw width ; in pixels
040FE2 10 00       0020*M     dw height ; in pixels
040FE4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040FE5             0083*  	LOADBMPBUFFER2 BUF_EXPLOSION_E,16,16,"../../tgt/sprites/explosion_e.rgba2"
040FE5             0001*M 
040FE5             0002*M     ; Clear buffer
040FE5 17 00 A0    0003*M     db 23,0,0xA0
040FE8 0E 01       0004*M     dw bufferId
040FEA 02          0005*M     db 2
040FEB             0006*M 
040FEB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040FEE 0E 01       0008*M     dw bufferId
040FF0             0009*M 
040FF0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040FF0 17 00 A0    0011*M     db 23,0,0xA0
040FF3 0E 01       0012*M     dw bufferId
040FF5 00          0013*M     db 0
040FF6 00 01       0014*M 	dw width * height ; length of data in bytes
040FF8 00 3F 3F C6 0015*M     incbin file ; bitmap data
       06 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F 3F 00 
       00 C6 06 3F 
       C6 3F C6 C6 
       C6 C6 06 3F 
       3F 3F 3F 00 
       00 C6 06 3F 
       C6 C6 C7 C7 
       C7 C7 C7 C6 
       06 2F 3F 00 
       00 06 C6 C6 
       C7 C7 3F 3F 
       3F 3F 07 07 
       C7 07 3F 00 
       00 2F C6 C7 
       3F 3F 3F 3F 
       3F 3F 07 07 
       07 C6 06 00 
       00 2F C6 C7 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       07 C6 06 00 
       00 C6 C7 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F C6 00 
       00 C6 C7 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F C7 00 
       00 C6 C7 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F C7 00 
       00 C6 C7 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F C7 00 
       00 06 C6 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F 07 00 
       00 06 C6 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F 07 00 
       00 2F 06 C7 
       07 3F 3F 3F 
       3F 3F 3F 3F 
       3F 06 06 00 
       00 2F 06 07 
       C6 C6 3F 3F 
       3F 3F 3F 3F 
       06 06 06 00 
       00 3F 3F 07 
       07 06 C7 C7 
       C7 C7 07 06 
       06 06 3F 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0410F8             0016*M 
0410F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0410F8 17 1B 21    0018*M     db 23,27,0x21
0410FB 10 00       0019*M     dw width ; in pixels
0410FD 10 00       0020*M     dw height ; in pixels
0410FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041100             0084*  	LOADBMPBUFFER2 BUF_FIREBALL_A,7,7,"../../tgt/sprites/fireball_a.rgba2"
041100             0001*M 
041100             0002*M     ; Clear buffer
041100 17 00 A0    0003*M     db 23,0,0xA0
041103 0F 01       0004*M     dw bufferId
041105 02          0005*M     db 2
041106             0006*M 
041106 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041109 0F 01       0008*M     dw bufferId
04110B             0009*M 
04110B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04110B 17 00 A0    0011*M     db 23,0,0xA0
04110E 0F 01       0012*M     dw bufferId
041110 00          0013*M     db 0
041111 31 00       0014*M 	dw width * height ; length of data in bytes
041113 2B 2B D2 D2 0015*M     incbin file ; bitmap data
       D2 2B 2B 2B 
       D2 C3 D2 CF 
       D1 2B D2 CF 
       D6 C7 CB C7 
       D2 C3 D2 D6 
       CB D2 D2 D2 
       D2 D2 D6 D6 
       D6 C3 D1 2B 
       D1 C3 D2 CF 
       C1 2B 2B 2B 
       D1 D2 D1 2B 
       2B          
041144             0016*M 
041144             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041144 17 1B 21    0018*M     db 23,27,0x21
041147 07 00       0019*M     dw width ; in pixels
041149 07 00       0020*M     dw height ; in pixels
04114B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04114C             0085*  	LOADBMPBUFFER2 BUF_FIREBALL_B,7,7,"../../tgt/sprites/fireball_b.rgba2"
04114C             0001*M 
04114C             0002*M     ; Clear buffer
04114C 17 00 A0    0003*M     db 23,0,0xA0
04114F 10 01       0004*M     dw bufferId
041151 02          0005*M     db 2
041152             0006*M 
041152 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041155 10 01       0008*M     dw bufferId
041157             0009*M 
041157             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041157 17 00 A0    0011*M     db 23,0,0xA0
04115A 10 01       0012*M     dw bufferId
04115C 00          0013*M     db 0
04115D 31 00       0014*M 	dw width * height ; length of data in bytes
04115F 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 DF CF 
       D1 00 D2 D2 
       C7 C3 C3 D2 
       D1 C3 C3 DF 
       CF CF C3 D2 
       D2 D2 C7 CF 
       C7 C3 D1 00 
       D1 C3 C3 D2 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041190             0016*M 
041190             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041190 17 1B 21    0018*M     db 23,27,0x21
041193 07 00       0019*M     dw width ; in pixels
041195 07 00       0020*M     dw height ; in pixels
041197 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041198             0086*  	LOADBMPBUFFER2 BUF_LASER_A,5,13,"../../tgt/sprites/laser_a.rgba2"
041198             0001*M 
041198             0002*M     ; Clear buffer
041198 17 00 A0    0003*M     db 23,0,0xA0
04119B 11 01       0004*M     dw bufferId
04119D 02          0005*M     db 2
04119E             0006*M 
04119E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411A1 11 01       0008*M     dw bufferId
0411A3             0009*M 
0411A3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411A3 17 00 A0    0011*M     db 23,0,0xA0
0411A6 11 01       0012*M     dw bufferId
0411A8 00          0013*M     db 0
0411A9 41 00       0014*M 	dw width * height ; length of data in bytes
0411AB 3F FF FF FF 0015*M     incbin file ; bitmap data
       3F FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       3A FA FF FA 
       3A 3A FA FF 
       FA 3A 3F F5 
       FF F5 35 3F 
       35 FF F5 35 
       3F 35 FF F5 
       35 3F 3F FA 
       35 35 3F 3F 
       F5 35 35 3F 
       3F F5 35 3F 
       00 00 00 00 
       00          
0411EC             0016*M 
0411EC             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0411EC 17 1B 21    0018*M     db 23,27,0x21
0411EF 05 00       0019*M     dw width ; in pixels
0411F1 0D 00       0020*M     dw height ; in pixels
0411F3 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0411F4             0087*  	LOADBMPBUFFER2 BUF_LASER_B,5,13,"../../tgt/sprites/laser_b.rgba2"
0411F4             0001*M 
0411F4             0002*M     ; Clear buffer
0411F4 17 00 A0    0003*M     db 23,0,0xA0
0411F7 12 01       0004*M     dw bufferId
0411F9 02          0005*M     db 2
0411FA             0006*M 
0411FA 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411FD 12 01       0008*M     dw bufferId
0411FF             0009*M 
0411FF             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411FF 17 00 A0    0011*M     db 23,0,0xA0
041202 12 01       0012*M     dw bufferId
041204 00          0013*M     db 0
041205 41 00       0014*M 	dw width * height ; length of data in bytes
041207 3F FF FF FF 0015*M     incbin file ; bitmap data
       3F FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       3A FA FF FA 
       3A 3A FA FF 
       FA 3A 3F FA 
       FF F5 35 3F 
       F5 F5 3F 3F 
       3F 35 F5 3F 
       3F 3F 35 F5 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F 3F 3F 
       3F 3F F5 3F 
       3F          
041248             0016*M 
041248             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041248 17 1B 21    0018*M     db 23,27,0x21
04124B 05 00       0019*M     dw width ; in pixels
04124D 0D 00       0020*M     dw height ; in pixels
04124F 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041250             0088*  	LOADBMPBUFFER2 BUF_PAD,16,16,"../../tgt/sprites/pad.rgba2"
041250             0001*M 
041250             0002*M     ; Clear buffer
041250 17 00 A0    0003*M     db 23,0,0xA0
041253 13 01       0004*M     dw bufferId
041255 02          0005*M     db 2
041256             0006*M 
041256 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041259 13 01       0008*M     dw bufferId
04125B             0009*M 
04125B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04125B 17 00 A0    0011*M     db 23,0,0xA0
04125E 13 01       0012*M     dw bufferId
041260 00          0013*M     db 0
041261 00 01       0014*M 	dw width * height ; length of data in bytes
041263 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
041363             0016*M 
041363             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041363 17 1B 21    0018*M     db 23,27,0x21
041366 10 00       0019*M     dw width ; in pixels
041368 10 00       0020*M     dw height ; in pixels
04136A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04136B             0089*  	LOADBMPBUFFER2 BUF_SEEKER_000,16,16,"../../tgt/sprites/seeker_000.rgba2"
04136B             0001*M 
04136B             0002*M     ; Clear buffer
04136B 17 00 A0    0003*M     db 23,0,0xA0
04136E 14 01       0004*M     dw bufferId
041370 02          0005*M     db 2
041371             0006*M 
041371 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041374 14 01       0008*M     dw bufferId
041376             0009*M 
041376             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041376 17 00 A0    0011*M     db 23,0,0xA0
041379 14 01       0012*M     dw bufferId
04137B 00          0013*M     db 0
04137C 00 01       0014*M 	dw width * height ; length of data in bytes
04137E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA F1 
       E0 E5 00 00 
       00 00 00 00 
       00 FB 00 00 
       FA 00 FF FF 
       FF EA 00 FA 
       00 00 FA 00 
       F3 E2 E5 00 
       E1 F3 FB FF 
       FF E5 E2 E1 
       00 E5 E1 E2 
       F2 E1 F2 E2 
       E1 EB FB FA 
       F6 E6 D3 E1 
       F7 F2 E1 E1 
       F1 E0 E1 00 
       F2 FB FE F5 
       F1 E5 D1 F2 
       00 E1 E0 E0 
       00 E0 E1 E2 
       E1 F6 F8 FC 
       F8 F4 E0 E1 
       E2 E0 E0 00 
       00 E0 00 00 
       E1 E1 FC FE 
       FD F8 E0 E1 
       00 00 E0 00 
       00 E0 00 00 
       E0 E0 FD FE 
       FD F8 D0 E0 
       00 00 E0 00 
       00 FB 00 00 
       E0 E0 F1 FD 
       F8 E0 D0 E0 
       00 00 FA 00 
       EF CB DB 00 
       E5 E0 E2 F5 
       F1 D1 D0 E5 
       00 DB CB DB 
       00 DF 00 00 
       00 E0 E2 F1 
       E0 D1 D0 00 
       00 00 DF 00 
       EF CB DB 00 
       00 E0 E2 00 
       00 D1 D0 00 
       00 DB CB DB 
       00 EB 00 00 
       00 E2 FB 00 
       00 E6 D1 00 
       00 00 D7 00 
       00 C3 00 00 
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
04147E             0016*M 
04147E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04147E 17 1B 21    0018*M     db 23,27,0x21
041481 10 00       0019*M     dw width ; in pixels
041483 10 00       0020*M     dw height ; in pixels
041485 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041486             0090*  	LOADBMPBUFFER2 BUF_SEEKER_008,16,16,"../../tgt/sprites/seeker_008.rgba2"
041486             0001*M 
041486             0002*M     ; Clear buffer
041486 17 00 A0    0003*M     db 23,0,0xA0
041489 15 01       0004*M     dw bufferId
04148B 02          0005*M     db 2
04148C             0006*M 
04148C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04148F 15 01       0008*M     dw bufferId
041491             0009*M 
041491             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041491 17 00 A0    0011*M     db 23,0,0xA0
041494 15 01       0012*M     dw bufferId
041496 00          0013*M     db 0
041497 00 01       0014*M 	dw width * height ; length of data in bytes
041499 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       F1 E0 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       F1 E0 00 00 
       00 00 00 00 
       00 00 FB 00 
       00 FA 00 FA 
       F1 E0 E5 00 
       00 00 00 00 
       00 F3 E2 E5 
       00 E1 00 FF 
       FF FF EA 00 
       00 00 00 00 
       00 F2 E1 F2 
       E2 E1 F3 FB 
       FF FF E5 00 
       FA 00 00 FA 
       00 E0 E1 00 
       F2 FB FB FA 
       F6 F6 E6 E2 
       E1 00 E5 E1 
       00 E0 E1 E2 
       E1 F6 FE F5 
       F1 E5 D1 E1 
       F7 F2 E1 E1 
       00 E0 00 00 
       E1 F6 F8 FC 
       F8 F4 E0 F2 
       00 E1 E0 E0 
       00 E0 00 00 
       E0 E1 FC FE 
       FD F8 E0 E1 
       E2 E0 E0 00 
       00 FB 00 00 
       E0 E0 FD FE 
       FD F8 E0 E1 
       00 00 E0 00 
       CB DB 00 E5 
       E0 F1 FD FD 
       F8 E0 D0 E0 
       00 00 E0 00 
       DF 00 00 00 
       E0 E2 F5 F1 
       D1 D0 E0 00 
       00 FA 00 00 
       CB DB 00 00 
       E0 E2 F1 E0 
       D1 D0 E5 00 
       DB CB DB 00 
       EB 00 00 00 
       E2 E2 00 00 
       D1 D0 00 00 
       00 DF 00 00 
       C3 00 00 00 
       F3 FB 00 00 
       E6 D1 00 00 
       DB CB DB 00 
       00 00 00 00 
       00 00 00 00 
       00 F3 00 00 
       00 D7 00 00 
041599             0016*M 
041599             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041599 17 1B 21    0018*M     db 23,27,0x21
04159C 10 00       0019*M     dw width ; in pixels
04159E 10 00       0020*M     dw height ; in pixels
0415A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0415A1             0091*  	LOADBMPBUFFER2 BUF_SEEKER_016,16,16,"../../tgt/sprites/seeker_016.rgba2"
0415A1             0001*M 
0415A1             0002*M     ; Clear buffer
0415A1 17 00 A0    0003*M     db 23,0,0xA0
0415A4 16 01       0004*M     dw bufferId
0415A6 02          0005*M     db 2
0415A7             0006*M 
0415A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0415AA 16 01       0008*M     dw bufferId
0415AC             0009*M 
0415AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415AC 17 00 A0    0011*M     db 23,0,0xA0
0415AF 16 01       0012*M     dw bufferId
0415B1 00          0013*M     db 0
0415B2 00 01       0014*M 	dw width * height ; length of data in bytes
0415B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 F1 00 
       00 00 00 00 
       00 00 F3 FB 
       00 00 00 00 
       00 00 F1 E0 
       00 00 00 00 
       00 00 F2 E2 
       E5 00 FA 00 
       FA F1 E0 00 
       00 00 00 00 
       00 F1 E1 F2 
       E2 00 E1 F3 
       FF FF E0 E5 
       00 00 00 00 
       00 00 E0 E1 
       00 E1 EB FB 
       FF FF FF EA 
       00 00 00 00 
       00 E0 E0 E1 
       E2 F2 FB FB 
       FA F6 E5 E2 
       FA 00 00 00 
       00 E0 00 00 
       E1 F6 F8 FE 
       F5 F1 E6 D3 
       E1 00 E5 FA 
       00 FB 00 00 
       E1 E1 FC FC 
       F8 E5 D1 F2 
       E1 F7 F2 E1 
       CB 00 00 E0 
       E0 E0 FD FE 
       FD F4 E0 E1 
       00 E1 E1 E1 
       DF DB 00 E5 
       E0 F1 FE FD 
       F8 F8 E0 E1 
       E2 E0 E0 E0 
       DB 00 00 00 
       E0 E2 FD F8 
       E0 D0 E0 00 
       00 E0 E0 00 
       00 00 00 E0 
       E2 F1 F5 F1 
       D1 D0 E0 00 
       00 E0 00 00 
       00 00 00 E0 
       E2 00 E0 D1 
       D0 E5 00 00 
       00 FA 00 00 
       00 00 F3 E2 
       FB 00 00 D1 
       D0 00 00 DB 
       CB 00 00 00 
       00 00 00 00 
       00 00 E6 D1 
       D0 00 00 00 
       DF DB 00 00 
       00 00 00 00 
       00 00 00 F3 
       00 00 DB CB 
       DB 00 00 00 
0416B4             0016*M 
0416B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0416B4 17 1B 21    0018*M     db 23,27,0x21
0416B7 10 00       0019*M     dw width ; in pixels
0416B9 10 00       0020*M     dw height ; in pixels
0416BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0416BC             0092*  	LOADBMPBUFFER2 BUF_SEEKER_024,16,16,"../../tgt/sprites/seeker_024.rgba2"
0416BC             0001*M 
0416BC             0002*M     ; Clear buffer
0416BC 17 00 A0    0003*M     db 23,0,0xA0
0416BF 17 01       0004*M     dw bufferId
0416C1 02          0005*M     db 2
0416C2             0006*M 
0416C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0416C5 17 01       0008*M     dw bufferId
0416C7             0009*M 
0416C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0416C7 17 00 A0    0011*M     db 23,0,0xA0
0416CA 17 01       0012*M     dw bufferId
0416CC 00          0013*M     db 0
0416CD 00 01       0014*M 	dw width * height ; length of data in bytes
0416CF 00 00 00 F3 0015*M     incbin file ; bitmap data
       00 FB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F2 
       E2 00 00 00 
       00 00 00 F1 
       E0 00 00 00 
       00 00 F1 E1 
       F2 E5 00 FA 
       00 FA F1 F1 
       E0 00 00 00 
       00 00 00 E0 
       E1 E2 E1 F3 
       00 FF F1 E0 
       00 00 00 00 
       00 00 E0 E1 
       E2 00 E1 EB 
       FB FF FF FF 
       E5 00 00 00 
       00 E0 00 00 
       E2 E1 FB FE 
       FA FA FF EA 
       00 00 00 00 
       00 FB 00 00 
       E1 E1 F6 F8 
       F5 F6 E6 E2 
       E2 FA 00 00 
       CB DB 00 00 
       E0 E1 FC FC 
       F8 F1 E5 D3 
       E1 00 00 00 
       00 00 00 E0 
       E0 FD FE FE 
       FD F4 E0 F2 
       F7 F7 E5 E1 
       DB 00 00 E0 
       E0 F1 FD FD 
       F8 E0 E0 E1 
       00 E1 E1 E1 
       00 00 00 E0 
       E2 F5 F8 F8 
       F8 D0 E1 00 
       E0 E0 E0 E1 
       00 00 E0 E2 
       F1 F1 F1 D1 
       D0 E0 00 00 
       00 E0 00 00 
       00 F3 E2 FB 
       00 00 D1 D0 
       D0 E0 00 00 
       E0 00 00 00 
       00 00 00 00 
       00 00 D1 D0 
       00 00 DB 00 
       FA 00 00 00 
       00 00 00 00 
       00 E6 D1 00 
       00 00 00 CB 
       00 00 00 00 
       00 00 00 00 
       00 F3 F3 00 
       00 DB DF 00 
       DB 00 00 00 
0417CF             0016*M 
0417CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0417CF 17 1B 21    0018*M     db 23,27,0x21
0417D2 10 00       0019*M     dw width ; in pixels
0417D4 10 00       0020*M     dw height ; in pixels
0417D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0417D7             0093*  	LOADBMPBUFFER2 BUF_SEEKER_032,16,16,"../../tgt/sprites/seeker_032.rgba2"
0417D7             0001*M 
0417D7             0002*M     ; Clear buffer
0417D7 17 00 A0    0003*M     db 23,0,0xA0
0417DA 18 01       0004*M     dw bufferId
0417DC 02          0005*M     db 2
0417DD             0006*M 
0417DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0417E0 18 01       0008*M     dw bufferId
0417E2             0009*M 
0417E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0417E2 17 00 A0    0011*M     db 23,0,0xA0
0417E5 18 01       0012*M     dw bufferId
0417E7 00          0013*M     db 0
0417E8 00 01       0014*M 	dw width * height ; length of data in bytes
0417EA 00 00 00 00 0015*M     incbin file ; bitmap data
       F2 F3 FB 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F1 
       F2 E1 E5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E0 F2 E2 00 
       FA 00 00 00 
       F1 E0 00 00 
       00 00 00 E0 
       E1 00 E2 E1 
       F3 00 FF F1 
       E0 E0 00 00 
       00 00 E0 00 
       00 E2 F2 EB 
       EB FB FF FF 
       E0 00 00 00 
       EF FB 00 00 
       00 E1 F6 FB 
       FB FA FF FF 
       EA 00 00 00 
       DF DB 00 00 
       E0 E1 E1 F8 
       F5 F6 F6 E5 
       00 00 00 00 
       00 00 00 E0 
       E0 E0 FC FE 
       F8 F1 E6 D3 
       E2 FA 00 00 
       00 00 00 E0 
       E0 F1 FE FD 
       FD F4 D1 D3 
       E1 00 00 00 
       00 00 E0 E0 
       E2 FD F8 FD 
       F8 E0 E0 F2 
       F7 F7 E5 FA 
       00 E2 E0 E2 
       F1 F1 F8 E0 
       D0 E0 E1 E2 
       00 F2 E1 E2 
       F3 F3 FB 00 
       E0 E0 D1 D0 
       D0 E0 00 00 
       E0 E0 E1 E1 
       00 00 00 00 
       00 D1 D0 D0 
       E0 00 00 00 
       E0 00 E0 00 
       00 00 00 00 
       E6 D0 D0 00 
       00 00 00 E0 
       00 00 00 00 
       00 00 00 00 
       F3 D1 00 00 
       00 DB FA 00 
       00 00 00 00 
       00 00 00 00 
       F3 00 00 00 
       00 DF DB 00 
       00 00 00 00 
0418EA             0016*M 
0418EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0418EA 17 1B 21    0018*M     db 23,27,0x21
0418ED 10 00       0019*M     dw width ; in pixels
0418EF 10 00       0020*M     dw height ; in pixels
0418F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0418F2             0094*  	LOADBMPBUFFER2 BUF_SEEKER_040,16,16,"../../tgt/sprites/seeker_040.rgba2"
0418F2             0001*M 
0418F2             0002*M     ; Clear buffer
0418F2 17 00 A0    0003*M     db 23,0,0xA0
0418F5 19 01       0004*M     dw bufferId
0418F7 02          0005*M     db 2
0418F8             0006*M 
0418F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0418FB 19 01       0008*M     dw bufferId
0418FD             0009*M 
0418FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418FD 17 00 A0    0011*M     db 23,0,0xA0
041900 19 01       0012*M     dw bufferId
041902 00          0013*M     db 0
041903 00 01       0014*M 	dw width * height ; length of data in bytes
041905 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F2 F2 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E1 E2 
       00 FA 00 00 
       00 00 00 00 
       EF 00 FB E0 
       00 E1 00 E2 
       E1 F3 00 FA 
       00 F1 F1 00 
       00 CB 00 00 
       00 00 E1 F2 
       EB F3 FF FF 
       F1 E0 E0 00 
       DF 00 DB 00 
       00 E1 F6 F6 
       FE FB FF FF 
       E0 E0 00 00 
       DB 00 00 E0 
       E0 E0 E1 F8 
       F5 FA F6 FF 
       EA E5 00 00 
       00 00 00 E0 
       E0 FD FC FE 
       FC F1 F6 E5 
       00 00 00 00 
       00 00 E0 E0 
       E2 FD FE FD 
       F8 F4 E5 D3 
       E2 FA 00 00 
       F3 E2 E2 E2 
       F5 FD F8 FD 
       F8 E0 D1 E1 
       E1 00 00 00 
       F3 FB 00 00 
       E0 F1 E0 F8 
       E0 E0 E1 00 
       F7 E5 00 FA 
       00 00 00 00 
       E0 D1 D0 D0 
       E0 E1 E2 E2 
       E1 F2 E1 00 
       00 00 00 E6 
       D1 D0 D0 E0 
       00 00 00 E0 
       E0 E1 E1 E2 
       00 00 00 D1 
       D0 00 00 00 
       00 00 00 E0 
       00 E0 00 00 
       00 00 00 F3 
       00 00 00 00 
       DB FA E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB 00 
       CB 00 00 00 
       00 00 00 00 
041A05             0016*M 
041A05             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041A05 17 1B 21    0018*M     db 23,27,0x21
041A08 10 00       0019*M     dw width ; in pixels
041A0A 10 00       0020*M     dw height ; in pixels
041A0C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041A0D             0095*  	LOADBMPBUFFER2 BUF_SEEKER_048,16,16,"../../tgt/sprites/seeker_048.rgba2"
041A0D             0001*M 
041A0D             0002*M     ; Clear buffer
041A0D 17 00 A0    0003*M     db 23,0,0xA0
041A10 1A 01       0004*M     dw bufferId
041A12 02          0005*M     db 2
041A13             0006*M 
041A13 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041A16 1A 01       0008*M     dw bufferId
041A18             0009*M 
041A18             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041A18 17 00 A0    0011*M     db 23,0,0xA0
041A1B 1A 01       0012*M     dw bufferId
041A1D 00          0013*M     db 0
041A1E 00 01       0014*M 	dw width * height ; length of data in bytes
041A20 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 F1 F2 
       E2 FB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E0 E1 
       F2 E5 00 00 
       00 00 00 00 
       00 EF 00 FB 
       E0 E0 E1 E1 
       E2 00 00 00 
       00 00 00 00 
       EF DF CB 00 
       00 00 E2 00 
       E1 E1 FA 00 
       00 00 00 00 
       CB 00 DB 00 
       00 00 E1 E1 
       F2 EB F3 FF 
       FA 00 F1 00 
       DB 00 00 00 
       E0 E0 E1 F6 
       FB FB FB FF 
       F1 F1 E0 E0 
       00 00 00 E5 
       E0 E0 FC F8 
       FE F5 FA FF 
       FF E0 00 00 
       00 E0 E0 E0 
       E2 F1 FD FE 
       FC F1 F6 FF 
       EA E5 00 00 
       F3 E2 E2 E2 
       F5 FD FE FD 
       F8 E5 E6 E5 
       E2 00 00 00 
       00 FB 00 F1 
       F1 F8 FD F8 
       F8 F4 D1 D3 
       E1 FA 00 00 
       00 00 00 00 
       E0 D1 E0 D0 
       E0 E0 F2 E1 
       00 00 00 00 
       00 00 E6 D1 
       D1 D0 D0 E0 
       E1 E1 E2 00 
       F7 E5 00 00 
       00 00 D1 D0 
       D0 00 E5 E0 
       00 00 E0 E1 
       F2 E1 FA 00 
       00 00 F3 00 
       00 00 00 00 
       00 00 E0 E0 
       E1 E1 E2 00 
       00 00 00 00 
       00 00 DB 00 
       FA E0 E0 00 
       E0 00 00 00 
       00 00 00 00 
       00 DB DF CB 
       00 00 00 00 
       00 00 00 00 
041B20             0016*M 
041B20             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041B20 17 1B 21    0018*M     db 23,27,0x21
041B23 10 00       0019*M     dw width ; in pixels
041B25 10 00       0020*M     dw height ; in pixels
041B27 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041B28             0096*  	LOADBMPBUFFER2 BUF_SEEKER_056,16,16,"../../tgt/sprites/seeker_056.rgba2"
041B28             0001*M 
041B28             0002*M     ; Clear buffer
041B28 17 00 A0    0003*M     db 23,0,0xA0
041B2B 1B 01       0004*M     dw bufferId
041B2D 02          0005*M     db 2
041B2E             0006*M 
041B2E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041B31 1B 01       0008*M     dw bufferId
041B33             0009*M 
041B33             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041B33 17 00 A0    0011*M     db 23,0,0xA0
041B36 1B 01       0012*M     dw bufferId
041B38 00          0013*M     db 0
041B39 00 01       0014*M 	dw width * height ; length of data in bytes
041B3B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       F1 F2 E2 FB 
       00 00 00 00 
       00 EF 00 EF 
       00 E0 E0 E0 
       E0 E1 E5 00 
       00 00 00 00 
       EB CB DF CB 
       FB 00 00 E1 
       E1 F2 00 00 
       00 00 00 00 
       00 DB 00 DB 
       00 00 00 E2 
       00 E2 E1 FA 
       00 00 00 00 
       00 00 00 00 
       00 E0 E1 E1 
       F2 E1 F3 00 
       00 00 00 00 
       00 00 00 E5 
       E0 E0 E1 E1 
       F6 FB FB FB 
       FF FA 00 F1 
       F3 E2 E0 E0 
       E0 F1 FD FC 
       F8 FE FA FF 
       FF F1 F1 F1 
       00 FB E2 E2 
       E2 FD FE FE 
       FC F5 FA FF 
       FF E0 E0 E0 
       00 00 00 F1 
       F5 F8 FD FD 
       F8 F1 F6 E5 
       EA E5 00 00 
       00 00 00 E0 
       F1 F8 F8 F8 
       F4 E5 E6 E2 
       00 00 00 00 
       00 E6 D1 D1 
       D1 E0 D0 E0 
       E0 E0 D1 E1 
       E1 FA 00 00 
       00 F3 D1 D0 
       D0 D0 E0 E0 
       E1 E1 F2 F7 
       00 00 00 00 
       00 00 00 00 
       00 E5 00 00 
       00 E2 00 F2 
       E5 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E1 E1 
       E1 FA 00 00 
       00 00 00 DB 
       00 DB FA E0 
       E0 E0 E0 E1 
       E2 00 00 00 
       00 C3 D7 CB 
       DF CB 00 00 
       00 00 00 00 
       00 00 00 00 
041C3B             0016*M 
041C3B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041C3B 17 1B 21    0018*M     db 23,27,0x21
041C3E 10 00       0019*M     dw width ; in pixels
041C40 10 00       0020*M     dw height ; in pixels
041C42 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041C43             0097*  	LOADBMPBUFFER2 BUF_SEEKER_064,16,16,"../../tgt/sprites/seeker_064.rgba2"
041C43             0001*M 
041C43             0002*M     ; Clear buffer
041C43 17 00 A0    0003*M     db 23,0,0xA0
041C46 1C 01       0004*M     dw bufferId
041C48 02          0005*M     db 2
041C49             0006*M 
041C49 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041C4C 1C 01       0008*M     dw bufferId
041C4E             0009*M 
041C4E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041C4E 17 00 A0    0011*M     db 23,0,0xA0
041C51 1C 01       0012*M     dw bufferId
041C53 00          0013*M     db 0
041C54 00 01       0014*M 	dw width * height ; length of data in bytes
041C56 00 00 EF 00 0015*M     incbin file ; bitmap data
       EF 00 00 00 
       00 F1 F2 F3 
       00 00 00 00 
       C3 EB CB DF 
       CB FB E0 E0 
       E0 E0 E1 E2 
       FB 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F2 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 E2 00 
       00 00 00 00 
       00 00 00 00 
       E5 E0 E0 E1 
       E1 F2 E1 E1 
       FA 00 00 00 
       F3 E2 E0 E0 
       E0 E0 E0 E1 
       F6 FB EB F3 
       00 00 00 00 
       00 FB E2 E2 
       E2 F1 FD FC 
       F8 FE FB FB 
       FF FA 00 00 
       00 00 00 F1 
       F5 FD FE FE 
       FC F5 FA FF 
       FF F1 F1 F1 
       00 00 00 E0 
       F1 F8 FD FD 
       F8 F1 F6 FF 
       FF E0 E0 E0 
       00 E6 D1 D1 
       D1 E0 F8 F8 
       F4 E5 E6 E5 
       EA E5 00 00 
       F3 D1 D0 D0 
       D0 D0 D0 E0 
       E0 D1 D3 E2 
       00 00 00 00 
       00 00 00 00 
       E5 E0 E0 E1 
       E1 F2 E1 E1 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 F7 00 
       00 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E0 E1 F2 E5 
       00 00 00 00 
       C3 D7 CB DF 
       CB FA E0 E0 
       E0 E0 E1 E1 
       FA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       00 E0 E1 E2 
       00 00 00 00 
041D56             0016*M 
041D56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041D56 17 1B 21    0018*M     db 23,27,0x21
041D59 10 00       0019*M     dw width ; in pixels
041D5B 10 00       0020*M     dw height ; in pixels
041D5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041D5E             0098*  	LOADBMPBUFFER2 BUF_SEEKER_072,16,16,"../../tgt/sprites/seeker_072.rgba2"
041D5E             0001*M 
041D5E             0002*M     ; Clear buffer
041D5E 17 00 A0    0003*M     db 23,0,0xA0
041D61 1D 01       0004*M     dw bufferId
041D63 02          0005*M     db 2
041D64             0006*M 
041D64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041D67 1D 01       0008*M     dw bufferId
041D69             0009*M 
041D69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D69 17 00 A0    0011*M     db 23,0,0xA0
041D6C 1D 01       0012*M     dw bufferId
041D6E 00          0013*M     db 0
041D6F 00 01       0014*M 	dw width * height ; length of data in bytes
041D71 00 C3 EB CB 0015*M     incbin file ; bitmap data
       DF CB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 DB 
       00 DB FB E0 
       E0 E0 E0 F2 
       F3 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E1 
       E2 FB 00 00 
       00 00 00 00 
       00 E5 00 00 
       00 E2 00 F2 
       E5 00 00 00 
       00 F3 E2 E0 
       E0 E0 E0 E0 
       E1 E1 F2 E2 
       00 00 00 00 
       00 FB E2 E2 
       E2 F1 E0 E1 
       F6 F6 FB E1 
       E1 FA 00 00 
       00 00 00 F1 
       F5 FD FD FC 
       F8 FE FB F3 
       00 00 00 00 
       00 00 00 E0 
       F1 FD FE FE 
       FC F5 FA FB 
       FF FA 00 00 
       00 E6 D1 D1 
       D1 F8 FD FD 
       F8 F1 F6 FF 
       FF F1 F1 F1 
       F3 D1 D0 D0 
       D0 E0 F8 F8 
       F4 E5 F6 FF 
       FF E0 E0 E0 
       00 00 00 E5 
       E0 D0 E0 E0 
       E0 D1 E6 E5 
       EA E5 00 E0 
       00 00 00 00 
       00 E0 E1 E1 
       F2 E1 E2 00 
       00 00 00 00 
       00 DB 00 DB 
       00 00 00 E2 
       00 F7 E1 FA 
       00 00 00 00 
       D7 CB DF CB 
       FA 00 00 E0 
       E1 F2 00 00 
       00 00 00 00 
       00 DB 00 DB 
       00 E0 E0 E0 
       E0 E1 E5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E1 FA 
       00 00 00 00 
041E71             0016*M 
041E71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041E71 17 1B 21    0018*M     db 23,27,0x21
041E74 10 00       0019*M     dw width ; in pixels
041E76 10 00       0020*M     dw height ; in pixels
041E78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041E79             0099*  	LOADBMPBUFFER2 BUF_SEEKER_080,16,16,"../../tgt/sprites/seeker_080.rgba2"
041E79             0001*M 
041E79             0002*M     ; Clear buffer
041E79 17 00 A0    0003*M     db 23,0,0xA0
041E7C 1E 01       0004*M     dw bufferId
041E7E 02          0005*M     db 2
041E7F             0006*M 
041E7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041E82 1E 01       0008*M     dw bufferId
041E84             0009*M 
041E84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E84 17 00 A0    0011*M     db 23,0,0xA0
041E87 1E 01       0012*M     dw bufferId
041E89 00          0013*M     db 0
041E8A 00 01       0014*M 	dw width * height ; length of data in bytes
041E8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 DB DF CB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB 00 
       FB E0 E0 00 
       F1 00 00 00 
       00 00 F3 00 
       00 00 00 00 
       00 00 E0 E0 
       E1 F2 F3 00 
       00 00 E2 E0 
       E0 00 E5 E0 
       00 00 E1 E1 
       F2 E2 FB 00 
       00 00 FB E2 
       E2 E0 E0 E0 
       E1 E1 E2 00 
       E2 E5 00 00 
       00 00 00 00 
       F1 E2 F1 E0 
       E1 F6 F2 E1 
       00 00 00 00 
       00 E6 00 E0 
       F5 FD FE FD 
       FC F8 FB EB 
       E1 FA 00 00 
       F3 D1 D1 D1 
       F1 F8 FD FE 
       FC FE FB FB 
       F3 00 00 00 
       00 D0 D0 D0 
       D1 E0 F8 FD 
       F8 F5 FA FF 
       FF FA 00 00 
       00 00 00 E5 
       D0 D0 F8 F4 
       E5 F1 F6 FF 
       FF F1 00 00 
       DB 00 00 00 
       E0 E0 E0 E0 
       D1 E6 E5 FF 
       E0 E0 F1 F1 
       CB 00 DB 00 
       00 00 E1 E1 
       F2 D3 E2 EA 
       E5 00 E0 00 
       DB DF CB 00 
       00 00 E2 00 
       E1 E1 FA 00 
       00 00 00 00 
       00 DB 00 FA 
       E0 E0 E0 E1 
       F7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E0 E1 
       F2 E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E0 E1 
       E1 FA 00 00 
       00 00 00 00 
041F8C             0016*M 
041F8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041F8C 17 1B 21    0018*M     db 23,27,0x21
041F8F 10 00       0019*M     dw width ; in pixels
041F91 10 00       0020*M     dw height ; in pixels
041F93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041F94             0100*  	LOADBMPBUFFER2 BUF_SEEKER_088,16,16,"../../tgt/sprites/seeker_088.rgba2"
041F94             0001*M 
041F94             0002*M     ; Clear buffer
041F94 17 00 A0    0003*M     db 23,0,0xA0
041F97 1F 01       0004*M     dw bufferId
041F99 02          0005*M     db 2
041F9A             0006*M 
041F9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041F9D 1F 01       0008*M     dw bufferId
041F9F             0009*M 
041F9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F9F 17 00 A0    0011*M     db 23,0,0xA0
041FA2 1F 01       0012*M     dw bufferId
041FA4 00          0013*M     db 0
041FA5 00 01       0014*M 	dw width * height ; length of data in bytes
041FA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 DB 00 
       CB 00 00 00 
       00 00 00 00 
       00 00 00 F3 
       00 00 00 00 
       DB FB E0 00 
       00 00 00 00 
       00 00 00 E2 
       E0 00 00 00 
       00 00 00 E0 
       00 F1 00 00 
       00 00 00 FB 
       E2 E0 E0 E0 
       00 00 00 E1 
       E0 E1 F2 F3 
       00 00 00 00 
       F1 E2 E0 E0 
       E0 E1 E2 E2 
       E1 F2 E2 00 
       F3 E6 00 00 
       F1 F5 F1 FD 
       E1 E1 E1 00 
       E2 E5 00 FB 
       F3 D1 D1 D1 
       F1 F8 FD FE 
       FC F6 FB E1 
       E1 00 00 00 
       00 00 D0 D0 
       D1 F8 FD FE 
       FC F8 FE EB 
       F3 FA 00 00 
       00 00 00 D0 
       D0 F8 F8 FD 
       F8 F5 FA FB 
       00 00 00 00 
       DB 00 00 E0 
       E0 D0 E0 F4 
       F1 F6 FA FF 
       FF FA 00 00 
       DF 00 DB 00 
       00 E1 E0 E0 
       E5 E6 FF FF 
       F1 F1 00 00 
       00 CB 00 00 
       00 00 E1 F2 
       D3 E2 EA FF 
       E0 F1 F1 00 
       DB 00 FA E0 
       00 E0 00 F7 
       E1 E2 00 E5 
       00 E0 E0 00 
       00 00 00 00 
       E0 E0 E1 F7 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E1 
       00 00 00 00 
       00 00 00 00 
0420A7             0016*M 
0420A7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0420A7 17 1B 21    0018*M     db 23,27,0x21
0420AA 10 00       0019*M     dw width ; in pixels
0420AC 10 00       0020*M     dw height ; in pixels
0420AE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0420AF             0101*  	LOADBMPBUFFER2 BUF_SEEKER_096,16,16,"../../tgt/sprites/seeker_096.rgba2"
0420AF             0001*M 
0420AF             0002*M     ; Clear buffer
0420AF 17 00 A0    0003*M     db 23,0,0xA0
0420B2 20 01       0004*M     dw bufferId
0420B4 02          0005*M     db 2
0420B5             0006*M 
0420B5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0420B8 20 01       0008*M     dw bufferId
0420BA             0009*M 
0420BA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420BA 17 00 A0    0011*M     db 23,0,0xA0
0420BD 20 01       0012*M     dw bufferId
0420BF 00          0013*M     db 0
0420C0 00 01       0014*M 	dw width * height ; length of data in bytes
0420C2 00 00 00 00 0015*M     incbin file ; bitmap data
       F3 00 00 00 
       00 DF EF 00 
       00 00 00 00 
       00 00 00 00 
       F3 E2 00 00 
       00 DB FB 00 
       00 00 00 00 
       00 00 00 00 
       FB E0 E0 00 
       00 00 00 E0 
       00 00 00 00 
       00 00 00 00 
       00 E2 E0 E0 
       E0 00 00 00 
       E0 00 F1 00 
       F3 F3 E6 00 
       E0 F1 E2 E0 
       E0 E0 00 E2 
       E1 E0 F2 F2 
       00 D1 D0 D1 
       E0 F1 FD F1 
       E0 E1 E1 E2 
       00 F2 E1 F3 
       00 00 D0 D0 
       D1 F8 F8 FE 
       FC F6 F6 F2 
       E2 E2 E5 FB 
       00 00 00 D0 
       D0 E0 FD FD 
       FC F8 FB EB 
       E1 00 00 00 
       00 00 00 E0 
       D0 D0 F8 F8 
       F8 F5 FB EB 
       F3 FA 00 00 
       DF DB 00 00 
       E0 E0 E0 F4 
       F1 F6 FA FB 
       00 00 00 00 
       DB FA 00 00 
       00 E1 E0 D1 
       E6 F6 FF FF 
       FF 00 00 00 
       00 00 E0 00 
       E2 E2 F2 D3 
       D3 E5 FF FF 
       F1 00 00 00 
       00 00 00 E0 
       E0 00 F7 E1 
       E2 00 EA E0 
       E0 F1 00 00 
       00 00 00 00 
       E0 F2 F7 00 
       FA 00 00 00 
       E0 E0 00 00 
       00 00 00 E0 
       E1 E1 E5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E1 E2 FA 00 
       00 00 00 00 
       00 00 00 00 
0421C2             0016*M 
0421C2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0421C2 17 1B 21    0018*M     db 23,27,0x21
0421C5 10 00       0019*M     dw width ; in pixels
0421C7 10 00       0020*M     dw height ; in pixels
0421C9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0421CA             0102*  	LOADBMPBUFFER2 BUF_SEEKER_104,16,16,"../../tgt/sprites/seeker_104.rgba2"
0421CA             0001*M 
0421CA             0002*M     ; Clear buffer
0421CA 17 00 A0    0003*M     db 23,0,0xA0
0421CD 21 01       0004*M     dw bufferId
0421CF 02          0005*M     db 2
0421D0             0006*M 
0421D0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0421D3 21 01       0008*M     dw bufferId
0421D5             0009*M 
0421D5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0421D5 17 00 A0    0011*M     db 23,0,0xA0
0421D8 21 01       0012*M     dw bufferId
0421DA 00          0013*M     db 0
0421DB 00 01       0014*M 	dw width * height ; length of data in bytes
0421DD 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F3 F3 00 
       00 DB DF 00 
       EF 00 00 00 
       00 00 00 00 
       00 FB E2 00 
       00 00 00 CB 
       00 00 00 00 
       00 00 00 00 
       00 00 E2 E0 
       00 00 DB 00 
       FB 00 00 00 
       00 F3 D1 E6 
       00 00 E2 E0 
       E0 E0 00 00 
       E0 00 00 00 
       00 00 D0 D1 
       E0 E0 F5 E2 
       E0 E0 00 00 
       00 E0 00 00 
       00 00 00 D0 
       D1 F1 FD FD 
       FD E0 E1 00 
       E1 E1 E0 F2 
       DB 00 00 D0 
       D0 E0 F8 FE 
       FC E1 F6 E1 
       00 E1 E1 F2 
       00 00 00 E0 
       D0 F8 FD FD 
       FE F8 F6 F2 
       E2 E2 E5 E2 
       CB DB 00 00 
       E0 E0 F8 F8 
       FC F5 FE EB 
       E1 00 00 00 
       00 FA 00 00 
       E1 E0 E0 F4 
       F1 FA FB F3 
       F3 FA 00 00 
       00 E0 00 00 
       E2 E1 D1 E5 
       F6 F6 FF FF 
       00 00 00 00 
       00 00 E0 E0 
       E2 00 E1 D3 
       E5 FF FF FF 
       FA 00 00 00 
       00 00 00 E0 
       E1 F7 E1 E2 
       00 EA E0 F1 
       00 00 00 00 
       00 00 E0 E1 
       F2 E5 00 FA 
       00 E5 E0 E0 
       F1 00 00 00 
       00 00 00 E1 
       E1 00 00 00 
       00 00 00 E0 
       F1 00 00 00 
       00 00 00 E2 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 00 
0422DD             0016*M 
0422DD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0422DD 17 1B 21    0018*M     db 23,27,0x21
0422E0 10 00       0019*M     dw width ; in pixels
0422E2 10 00       0020*M     dw height ; in pixels
0422E4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0422E5             0103*  	LOADBMPBUFFER2 BUF_SEEKER_112,16,16,"../../tgt/sprites/seeker_112.rgba2"
0422E5             0001*M 
0422E5             0002*M     ; Clear buffer
0422E5 17 00 A0    0003*M     db 23,0,0xA0
0422E8 22 01       0004*M     dw bufferId
0422EA 02          0005*M     db 2
0422EB             0006*M 
0422EB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0422EE 22 01       0008*M     dw bufferId
0422F0             0009*M 
0422F0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0422F0 17 00 A0    0011*M     db 23,0,0xA0
0422F3 22 01       0012*M     dw bufferId
0422F5 00          0013*M     db 0
0422F6 00 01       0014*M 	dw width * height ; length of data in bytes
0422F8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F3 
       00 00 DB CB 
       EF 00 00 00 
       00 00 00 00 
       00 00 FB E2 
       E0 00 00 00 
       DF EF 00 00 
       00 00 F3 D1 
       E6 00 00 E2 
       E0 00 00 DB 
       CB 00 00 00 
       00 00 00 D0 
       D1 00 F1 E2 
       E0 E5 00 00 
       00 FB 00 00 
       00 00 00 D0 
       D1 E0 F1 F5 
       E2 E0 E0 00 
       00 E0 00 00 
       DB 00 00 00 
       D0 D1 F8 FD 
       F1 E0 E0 00 
       00 E0 E0 00 
       DF DB 00 E5 
       D0 E0 FD FE 
       FD FC E1 E1 
       E2 E1 E0 F1 
       CB 00 00 E0 
       E0 D0 F8 FD 
       FE F8 F6 E1 
       00 E1 E1 F2 
       00 FA 00 00 
       E1 E0 F8 F8 
       FC FE FB F2 
       E1 E2 F2 E2 
       00 E0 00 00 
       E1 E0 F4 E5 
       F1 F5 FB EB 
       E1 00 E5 FB 
       00 E0 E0 E0 
       E2 F2 D1 E6 
       F6 FA FB F3 
       FA 00 00 00 
       00 00 E0 E1 
       00 E1 D3 E5 
       FF FF FF FF 
       00 00 00 00 
       00 E0 E1 F2 
       F7 00 E1 E2 
       EA FF F1 FA 
       00 00 00 00 
       00 00 E1 E1 
       E5 00 FA 00 
       E5 E0 F1 00 
       00 00 00 00 
       00 00 E2 FA 
       00 00 00 00 
       00 00 E0 F1 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E0 00 
       00 00 00 00 
0423F8             0016*M 
0423F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0423F8 17 1B 21    0018*M     db 23,27,0x21
0423FB 10 00       0019*M     dw width ; in pixels
0423FD 10 00       0020*M     dw height ; in pixels
0423FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042400             0104*  	LOADBMPBUFFER2 BUF_SEEKER_120,16,16,"../../tgt/sprites/seeker_120.rgba2"
042400             0001*M 
042400             0002*M     ; Clear buffer
042400 17 00 A0    0003*M     db 23,0,0xA0
042403 23 01       0004*M     dw bufferId
042405 02          0005*M     db 2
042406             0006*M 
042406 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042409 23 01       0008*M     dw bufferId
04240B             0009*M 
04240B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04240B 17 00 A0    0011*M     db 23,0,0xA0
04240E 23 01       0012*M     dw bufferId
042410 00          0013*M     db 0
042411 00 01       0014*M 	dw width * height ; length of data in bytes
042413 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 F3 00 00 
       00 EB 00 00 
       C3 00 00 00 
       F3 E6 00 00 
       FB E2 00 00 
       DB CB EF 00 
       D7 00 00 00 
       D1 D1 00 00 
       E2 E0 00 00 
       00 DF 00 00 
       CB DB 00 00 
       D0 D1 E0 F1 
       E2 E0 E5 00 
       DB CB EF 00 
       DF 00 00 00 
       D0 D1 F1 F5 
       E2 E0 E0 00 
       00 FB 00 00 
       CB DB 00 E5 
       D0 E0 F8 F8 
       FD F1 E0 E0 
       00 00 E0 00 
       00 FA 00 00 
       E0 D0 F8 FD 
       FE FD E1 E1 
       00 00 E0 00 
       00 E0 00 00 
       E0 E0 F8 FD 
       FE FC E1 E1 
       E2 E1 E0 00 
       00 E0 00 00 
       E1 E0 F4 F8 
       FC F8 F6 F2 
       00 E1 E0 F1 
       00 E0 E0 E2 
       E1 E0 E5 F1 
       F5 FE FB E1 
       E2 F2 E1 F2 
       00 E0 E1 00 
       F2 D1 E6 F6 
       FA FA FB F3 
       E1 00 E5 E2 
       00 E1 E1 F2 
       F7 E1 E2 E5 
       FF FF FB 00 
       FA 00 00 FB 
       00 E2 E1 E5 
       00 E1 00 EA 
       FF FF FF 00 
       00 00 00 00 
       00 00 FA 00 
       00 FA 00 E5 
       E0 F1 FA 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E0 F1 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E0 F1 F1 00 
       00 00 00 00 
042513             0016*M 
042513             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042513 17 1B 21    0018*M     db 23,27,0x21
042516 10 00       0019*M     dw width ; in pixels
042518 10 00       0020*M     dw height ; in pixels
04251A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04251B             0105*  	LOADBMPBUFFER2 BUF_SEEKER_128,16,16,"../../tgt/sprites/seeker_128.rgba2"
04251B             0001*M 
04251B             0002*M     ; Clear buffer
04251B 17 00 A0    0003*M     db 23,0,0xA0
04251E 24 01       0004*M     dw bufferId
042520 02          0005*M     db 2
042521             0006*M 
042521 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042524 24 01       0008*M     dw bufferId
042526             0009*M 
042526             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042526 17 00 A0    0011*M     db 23,0,0xA0
042529 24 01       0012*M     dw bufferId
04252B 00          0013*M     db 0
04252C 00 01       0014*M 	dw width * height ; length of data in bytes
04252E 00 C3 00 00 0015*M     incbin file ; bitmap data
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
       00 D7 00 00 
       00 D1 E6 00 
       00 FB E2 00 
       00 00 EB 00 
       DB CB DB 00 
       00 D0 D1 00 
       00 E2 E0 00 
       00 DB CB EF 
       00 DF 00 00 
       00 D0 D1 E0 
       F1 E2 E0 00 
       00 00 DF 00 
       DB CB DB 00 
       E5 D0 D1 F1 
       F5 E2 E0 E5 
       00 DB CB EF 
       00 FA 00 00 
       E0 D0 E0 F8 
       FD F1 E0 E0 
       00 00 FB 00 
       00 E0 00 00 
       E0 D0 F8 FD 
       FE FD E0 E0 
       00 00 E0 00 
       00 E0 00 00 
       E1 E0 F8 FD 
       FE FC E1 E1 
       00 00 E0 00 
       00 E0 E0 E2 
       E1 E0 F4 F8 
       FC F8 F6 E1 
       E2 E1 E0 00 
       E0 E0 E1 00 
       F2 D1 E5 F1 
       F5 FE FB F2 
       00 E1 E0 F1 
       E1 E1 F2 F7 
       E1 D3 E6 F6 
       FA FB EB E1 
       E2 F2 E1 F2 
       E2 E1 E5 00 
       E1 E2 E5 FF 
       FF FB F3 E1 
       00 E5 E2 F3 
       00 FA 00 00 
       FA 00 EA FF 
       FF FF 00 FA 
       00 00 FB 00 
       00 00 00 00 
       00 00 E5 E0 
       F1 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       F1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       F1 00 00 00 
       00 00 00 00 
04262E             0016*M 
04262E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04262E 17 1B 21    0018*M     db 23,27,0x21
042631 10 00       0019*M     dw width ; in pixels
042633 10 00       0020*M     dw height ; in pixels
042635 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042636             0106*  	LOADBMPBUFFER2 BUF_SEEKER_136,16,16,"../../tgt/sprites/seeker_136.rgba2"
042636             0001*M 
042636             0002*M     ; Clear buffer
042636 17 00 A0    0003*M     db 23,0,0xA0
042639 25 01       0004*M     dw bufferId
04263B 02          0005*M     db 2
04263C             0006*M 
04263C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04263F 25 01       0008*M     dw bufferId
042641             0009*M 
042641             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042641 17 00 A0    0011*M     db 23,0,0xA0
042644 25 01       0012*M     dw bufferId
042646 00          0013*M     db 0
042647 00 01       0014*M 	dw width * height ; length of data in bytes
042649 00 00 D7 00 0015*M     incbin file ; bitmap data
       00 00 F3 00 
       00 00 00 00 
       00 00 00 00 
       00 DB CB DB 
       00 00 D1 E6 
       00 00 FB F3 
       00 00 00 C3 
       00 00 DF 00 
       00 00 D0 D1 
       00 00 E2 E2 
       00 00 00 EB 
       00 DB CB DB 
       00 E5 D0 D1 
       E0 F1 E2 E0 
       00 00 DB CB 
       00 00 FA 00 
       00 E0 D0 D1 
       F1 F5 E2 E0 
       00 00 00 DF 
       00 E0 00 00 
       E0 D0 E0 F8 
       FD FD F1 E0 
       E5 00 DB CB 
       00 E0 00 00 
       E1 E0 F8 FD 
       FE FD E0 E0 
       00 00 FB 00 
       00 E0 E0 E2 
       E1 E0 F8 FD 
       FE FC E1 E0 
       00 00 E0 00 
       E0 E0 E1 00 
       F2 E0 F4 F8 
       FC F8 F6 E1 
       00 00 E0 00 
       E1 E1 F2 F7 
       E1 D1 E5 F1 
       F5 FE F6 E1 
       E2 E1 E0 00 
       E1 E5 00 E1 
       E2 E6 F6 F6 
       FA FB FB F2 
       00 E1 E0 00 
       FA 00 00 FA 
       00 E5 FF FF 
       FB F3 E1 E2 
       F2 E1 F2 00 
       00 00 00 00 
       00 EA FF FF 
       FF 00 E1 00 
       E5 E2 F3 00 
       00 00 00 00 
       00 E5 E0 F1 
       FA 00 FA 00 
       00 FB 00 00 
       00 00 00 00 
       00 00 E0 F1 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 E0 F1 
       00 00 00 00 
       00 00 00 00 
042749             0016*M 
042749             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042749 17 1B 21    0018*M     db 23,27,0x21
04274C 10 00       0019*M     dw width ; in pixels
04274E 10 00       0020*M     dw height ; in pixels
042750 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042751             0107*  	LOADBMPBUFFER2 BUF_SEEKER_144,16,16,"../../tgt/sprites/seeker_144.rgba2"
042751             0001*M 
042751             0002*M     ; Clear buffer
042751 17 00 A0    0003*M     db 23,0,0xA0
042754 26 01       0004*M     dw bufferId
042756 02          0005*M     db 2
042757             0006*M 
042757 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04275A 26 01       0008*M     dw bufferId
04275C             0009*M 
04275C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04275C 17 00 A0    0011*M     db 23,0,0xA0
04275F 26 01       0012*M     dw bufferId
042761 00          0013*M     db 0
042762 00 01       0014*M 	dw width * height ; length of data in bytes
042764 00 00 00 DB 0015*M     incbin file ; bitmap data
       CB DB 00 00 
       F3 00 00 00 
       00 00 00 00 
       00 00 DB DF 
       00 00 00 D0 
       D1 E6 00 00 
       00 00 00 00 
       00 00 00 CB 
       DB 00 00 D0 
       D1 00 00 FB 
       E2 F3 00 00 
       00 00 FA 00 
       00 00 E5 D0 
       D1 E0 00 E2 
       E0 00 00 00 
       00 00 E0 00 
       00 E0 D0 D1 
       F1 F5 F1 E2 
       E0 00 00 00 
       00 E0 E0 00 
       00 E0 D0 E0 
       F8 FD E2 E0 
       00 00 00 DB 
       E0 E0 E0 E2 
       E1 E0 F8 F8 
       FD FE F1 E0 
       E5 00 DB DF 
       E1 E1 E1 00 
       E1 E0 F4 FD 
       FE FD E0 E0 
       E0 00 00 CB 
       E1 F2 F7 E1 
       F2 D1 E5 F8 
       FC FC E1 E1 
       00 00 FB 00 
       FA E5 00 E1 
       D3 E6 F1 F5 
       FE F8 F6 E1 
       00 00 E0 00 
       00 00 00 FA 
       E2 E5 F6 FA 
       FB FB F2 E2 
       E1 E0 E0 00 
       00 00 00 00 
       EA FF FF FF 
       FB EB E1 00 
       E1 E0 00 00 
       00 00 00 00 
       E5 E0 FF FF 
       F3 E1 00 E2 
       F2 E1 F1 00 
       00 00 00 00 
       00 E0 F1 FA 
       00 FA 00 E5 
       E2 F2 00 00 
       00 00 00 00 
       E0 F1 00 00 
       00 00 00 00 
       FB F3 00 00 
       00 00 00 00 
       00 F1 00 00 
       00 00 00 00 
       00 00 00 00 
042864             0016*M 
042864             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042864 17 1B 21    0018*M     db 23,27,0x21
042867 10 00       0019*M     dw width ; in pixels
042869 10 00       0020*M     dw height ; in pixels
04286B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04286C             0108*  	LOADBMPBUFFER2 BUF_SEEKER_152,16,16,"../../tgt/sprites/seeker_152.rgba2"
04286C             0001*M 
04286C             0002*M     ; Clear buffer
04286C 17 00 A0    0003*M     db 23,0,0xA0
04286F 27 01       0004*M     dw bufferId
042871 02          0005*M     db 2
042872             0006*M 
042872 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042875 27 01       0008*M     dw bufferId
042877             0009*M 
042877             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042877 17 00 A0    0011*M     db 23,0,0xA0
04287A 27 01       0012*M     dw bufferId
04287C 00          0013*M     db 0
04287D 00 01       0014*M 	dw width * height ; length of data in bytes
04287F 00 00 00 DB 0015*M     incbin file ; bitmap data
       00 DF DB 00 
       00 F3 F3 00 
       00 00 00 00 
       00 00 00 00 
       CB 00 00 00 
       00 D1 E6 00 
       00 00 00 00 
       00 00 00 FA 
       00 DB 00 00 
       D0 D1 00 00 
       00 00 00 00 
       00 00 00 E0 
       00 00 E0 D0 
       D0 D1 00 00 
       FB E2 F3 00 
       00 00 E0 00 
       00 00 E0 D0 
       D1 F1 F1 F1 
       E2 E0 00 00 
       E1 E0 E0 E0 
       00 E1 D0 F8 
       F8 F8 F5 E2 
       E0 00 00 00 
       E1 E1 E1 00 
       E1 E0 E0 F8 
       FD FD F1 E0 
       E0 00 00 DB 
       E1 E5 F7 F7 
       F2 E0 F4 FD 
       FE FE FD E0 
       E0 00 00 00 
       00 00 00 E1 
       D3 E5 F1 F8 
       FC FC E1 E0 
       00 00 DB CB 
       00 00 FA E2 
       E2 E6 F6 F5 
       F8 F6 E1 E1 
       00 00 FB 00 
       00 00 00 00 
       EA FF FA FA 
       FE FB E1 E2 
       00 00 E0 00 
       00 00 00 E5 
       FF FF FF FB 
       EB E1 00 E2 
       E1 E0 00 00 
       00 00 00 00 
       E0 F1 FF 00 
       F3 E1 E2 E1 
       E0 00 00 00 
       00 00 00 E0 
       F1 F1 FA 00 
       FA 00 E5 F2 
       E1 F1 00 00 
       00 00 00 E0 
       F1 00 00 00 
       00 00 00 E2 
       F2 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FB 00 
       F3 00 00 00 
04297F             0016*M 
04297F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04297F 17 1B 21    0018*M     db 23,27,0x21
042982 10 00       0019*M     dw width ; in pixels
042984 10 00       0020*M     dw height ; in pixels
042986 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042987             0109*  	LOADBMPBUFFER2 BUF_SEEKER_160,16,16,"../../tgt/sprites/seeker_160.rgba2"
042987             0001*M 
042987             0002*M     ; Clear buffer
042987 17 00 A0    0003*M     db 23,0,0xA0
04298A 28 01       0004*M     dw bufferId
04298C 02          0005*M     db 2
04298D             0006*M 
04298D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042990 28 01       0008*M     dw bufferId
042992             0009*M 
042992             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042992 17 00 A0    0011*M     db 23,0,0xA0
042995 28 01       0012*M     dw bufferId
042997 00          0013*M     db 0
042998 00 01       0014*M 	dw width * height ; length of data in bytes
04299A 00 00 00 00 0015*M     incbin file ; bitmap data
       00 DB DF 00 
       00 00 00 F3 
       00 00 00 00 
       00 00 00 00 
       00 FA DB 00 
       00 00 D1 F3 
       00 00 00 00 
       00 00 00 00 
       E0 00 00 00 
       00 D0 D0 E6 
       00 00 00 00 
       00 E0 00 E0 
       00 00 00 E0 
       D0 D0 D1 00 
       00 00 00 00 
       E1 E1 E0 E0 
       00 00 E0 D0 
       D0 D1 E0 F1 
       00 FB F3 F3 
       E2 E1 F2 00 
       E2 E1 E0 D0 
       E0 F8 F5 F1 
       E2 E0 E2 00 
       FA E5 F7 F7 
       F2 E0 E0 F8 
       FD FD FD E2 
       E0 E0 00 00 
       00 00 00 E1 
       D3 D1 F4 FD 
       FE FE F1 E0 
       E0 00 00 00 
       00 00 FA E2 
       D3 E6 F1 FC 
       FE FC E0 E0 
       E0 00 00 00 
       00 00 00 00 
       E5 F6 FA F5 
       F8 E1 E1 E0 
       00 00 DB DF 
       00 00 00 EA 
       FF FF FA FB 
       FB F6 E1 00 
       00 00 FB EF 
       00 00 00 E0 
       FF FF FB EB 
       EB F2 E2 00 
       00 E0 00 00 
       00 00 E0 F1 
       F1 FF 00 F3 
       E1 E2 00 E1 
       E0 00 00 00 
       00 00 F1 F1 
       00 00 00 FA 
       00 E2 F2 E0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E5 E1 F2 
       F1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 FB F3 F2 
       00 00 00 00 
042A9A             0016*M 
042A9A             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042A9A 17 1B 21    0018*M     db 23,27,0x21
042A9D 10 00       0019*M     dw width ; in pixels
042A9F 10 00       0020*M     dw height ; in pixels
042AA1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042AA2             0110*  	LOADBMPBUFFER2 BUF_SEEKER_168,16,16,"../../tgt/sprites/seeker_168.rgba2"
042AA2             0001*M 
042AA2             0002*M     ; Clear buffer
042AA2 17 00 A0    0003*M     db 23,0,0xA0
042AA5 29 01       0004*M     dw bufferId
042AA7 02          0005*M     db 2
042AA8             0006*M 
042AA8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042AAB 29 01       0008*M     dw bufferId
042AAD             0009*M 
042AAD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042AAD 17 00 A0    0011*M     db 23,0,0xA0
042AB0 29 01       0012*M     dw bufferId
042AB2 00          0013*M     db 0
042AB3 00 01       0014*M 	dw width * height ; length of data in bytes
042AB5 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 CB 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E0 FA DB 
       00 00 00 00 
       F3 00 00 00 
       00 00 E0 00 
       E0 00 00 00 
       00 00 00 D0 
       D1 00 00 00 
       E2 E1 E1 E0 
       E0 00 00 00 
       E0 D0 D0 D1 
       E6 00 00 00 
       00 E1 F2 E1 
       E2 E2 E1 E0 
       D0 D0 D1 E0 
       00 00 00 00 
       FA 00 E5 F7 
       00 E1 E0 E0 
       F8 E0 F1 E0 
       00 00 FB F3 
       00 00 00 E1 
       E1 D1 E0 F8 
       FD F8 FD F5 
       E2 E2 E2 F3 
       00 00 FA E2 
       D3 E5 F4 F8 
       FD FE FD E2 
       E0 E0 00 00 
       00 00 00 00 
       E5 F6 F1 FC 
       FE FC FD E0 
       E0 00 00 00 
       00 00 E5 EA 
       FF F6 FA F5 
       F8 E1 E0 E0 
       E0 00 00 DB 
       00 00 E0 E0 
       FF FF FB FE 
       F6 F6 E1 00 
       00 DB 00 DF 
       00 E0 E0 F1 
       FF FF F3 EB 
       F2 E1 00 00 
       00 00 CB 00 
       00 F1 F1 00 
       FA 00 F3 E1 
       E2 00 E1 00 
       E0 FB 00 EF 
       00 00 00 00 
       00 00 FA 00 
       E2 E1 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 F2 F2 00 
       00 00 00 00 
042BB5             0016*M 
042BB5             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042BB5 17 1B 21    0018*M     db 23,27,0x21
042BB8 10 00       0019*M     dw width ; in pixels
042BBA 10 00       0020*M     dw height ; in pixels
042BBC 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042BBD             0111*  	LOADBMPBUFFER2 BUF_SEEKER_176,16,16,"../../tgt/sprites/seeker_176.rgba2"
042BBD             0001*M 
042BBD             0002*M     ; Clear buffer
042BBD 17 00 A0    0003*M     db 23,0,0xA0
042BC0 2A 01       0004*M     dw bufferId
042BC2 02          0005*M     db 2
042BC3             0006*M 
042BC3 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042BC6 2A 01       0008*M     dw bufferId
042BC8             0009*M 
042BC8             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042BC8 17 00 A0    0011*M     db 23,0,0xA0
042BCB 2A 01       0012*M     dw bufferId
042BCD 00          0013*M     db 0
042BCE 00 01       0014*M 	dw width * height ; length of data in bytes
042BD0 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       CB DF DB 00 
       00 00 00 00 
       00 00 00 E0 
       00 E0 E0 FA 
       00 DB 00 00 
       00 00 00 00 
       00 E2 E1 E1 
       E0 E0 00 00 
       00 00 00 00 
       00 F3 00 00 
       00 FA E1 F2 
       E1 E0 00 00 
       E0 E5 00 D0 
       D0 D1 00 00 
       00 00 E5 F7 
       00 E2 E1 E1 
       E0 D0 D0 D1 
       D1 E6 00 00 
       00 00 00 00 
       E1 F2 E0 E0 
       D0 E0 D1 E0 
       00 00 00 00 
       00 00 FA E1 
       D3 D1 F4 F8 
       F8 FD F8 F1 
       F1 00 FB 00 
       00 00 00 E2 
       E5 E6 E5 F8 
       FD FE FD F5 
       E2 E2 E2 F3 
       00 00 E5 EA 
       FF F6 F1 FC 
       FE FD F1 E2 
       E0 E0 E0 00 
       00 00 E0 FF 
       FF FA F5 FE 
       F8 FC E0 E0 
       E5 00 00 00 
       E0 E0 F1 F1 
       FF FB FB FB 
       F6 E1 E0 E0 
       00 00 00 DB 
       00 F1 00 FA 
       FF F3 EB F2 
       E1 E1 00 00 
       00 DB 00 CB 
       00 00 00 00 
       00 FA E1 E1 
       00 E2 00 00 
       00 CB DF EF 
       00 00 00 00 
       00 00 00 E2 
       E1 E1 E0 E0 
       FB 00 EF 00 
       00 00 00 00 
       00 00 E5 F2 
       E1 E0 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FB E2 
       F2 F1 00 00 
       00 00 00 00 
042CD0             0016*M 
042CD0             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042CD0 17 1B 21    0018*M     db 23,27,0x21
042CD3 10 00       0019*M     dw width ; in pixels
042CD5 10 00       0020*M     dw height ; in pixels
042CD7 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042CD8             0112*  	LOADBMPBUFFER2 BUF_SEEKER_184,16,16,"../../tgt/sprites/seeker_184.rgba2"
042CD8             0001*M 
042CD8             0002*M     ; Clear buffer
042CD8 17 00 A0    0003*M     db 23,0,0xA0
042CDB 2B 01       0004*M     dw bufferId
042CDD 02          0005*M     db 2
042CDE             0006*M 
042CDE 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042CE1 2B 01       0008*M     dw bufferId
042CE3             0009*M 
042CE3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042CE3 17 00 A0    0011*M     db 23,0,0xA0
042CE6 2B 01       0012*M     dw bufferId
042CE8 00          0013*M     db 0
042CE9 00 01       0014*M 	dw width * height ; length of data in bytes
042CEB 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 CB DF 
       CB D7 C3 00 
       00 00 00 E2 
       E1 E0 E0 E0 
       E0 FA DB 00 
       DB 00 00 00 
       00 00 FA E1 
       E1 E1 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E5 
       F2 00 E2 00 
       00 00 E5 00 
       00 00 00 00 
       00 00 00 00 
       F7 F2 E1 E1 
       E0 E0 D0 D0 
       D0 D1 F3 00 
       00 00 FA E1 
       E1 D1 E0 E0 
       E0 D0 E0 D1 
       D1 D1 E6 00 
       00 00 00 00 
       E2 E6 E5 F4 
       F8 F8 F8 F1 
       E0 00 00 00 
       00 00 E5 EA 
       E5 F6 F1 F8 
       FD FD F8 F5 
       F1 00 00 00 
       E0 E0 E0 FF 
       FF FA F5 FC 
       FE FE FD E2 
       E2 E2 FB 00 
       F1 F1 F1 FF 
       FF FA FE F8 
       FC FD F1 E0 
       E0 E0 E2 F3 
       F1 00 FA FF 
       FB FB FB F6 
       E1 E1 E0 E0 
       E5 00 00 00 
       00 00 00 00 
       00 F3 E1 F2 
       E1 E1 E0 00 
       00 00 00 00 
       00 00 00 00 
       FA E1 E2 00 
       E2 00 00 00 
       DB 00 DB 00 
       00 00 00 00 
       00 00 F2 E1 
       E1 00 00 FB 
       CB DF CB EB 
       00 00 00 00 
       00 E5 E1 E0 
       E0 E0 E0 00 
       EF 00 EF 00 
       00 00 00 00 
       FB E2 F2 F1 
       00 00 00 00 
       00 00 00 00 
042DEB             0016*M 
042DEB             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042DEB 17 1B 21    0018*M     db 23,27,0x21
042DEE 10 00       0019*M     dw width ; in pixels
042DF0 10 00       0020*M     dw height ; in pixels
042DF2 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042DF3             0113*  	LOADBMPBUFFER2 BUF_SEEKER_192,16,16,"../../tgt/sprites/seeker_192.rgba2"
042DF3             0001*M 
042DF3             0002*M     ; Clear buffer
042DF3 17 00 A0    0003*M     db 23,0,0xA0
042DF6 2C 01       0004*M     dw bufferId
042DF8 02          0005*M     db 2
042DF9             0006*M 
042DF9 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042DFC 2C 01       0008*M     dw bufferId
042DFE             0009*M 
042DFE             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042DFE 17 00 A0    0011*M     db 23,0,0xA0
042E01 2C 01       0012*M     dw bufferId
042E03 00          0013*M     db 0
042E04 00 01       0014*M 	dw width * height ; length of data in bytes
042E06 00 00 00 00 0015*M     incbin file ; bitmap data
       E2 E1 E0 00 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FA 
       E1 E1 E0 E0 
       E0 E0 FA CB 
       DF CB D7 C3 
       00 00 00 00 
       E5 F2 E1 E0 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 00 
       00 F7 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       E1 E1 F2 E1 
       E1 E0 E0 E5 
       00 00 00 00 
       00 00 00 00 
       E2 D3 D1 E0 
       E0 D0 D0 D0 
       D0 D0 D1 F3 
       00 00 E5 EA 
       E5 E6 E5 F4 
       F8 F8 E0 D1 
       D1 D1 E6 00 
       E0 E0 E0 FF 
       FF F6 F1 F8 
       FD FD F8 F1 
       E0 00 00 00 
       F1 F1 F1 FF 
       FF FA F5 FC 
       FE FE FD F5 
       F1 00 00 00 
       00 00 FA FF 
       FB FB FE F8 
       FC FD F1 E2 
       E2 E2 FB 00 
       00 00 00 00 
       F3 EB FB F6 
       E1 E0 E0 E0 
       E0 E0 E2 F3 
       00 00 00 FA 
       E1 E1 F2 E1 
       E1 E0 E0 E5 
       00 00 00 00 
       00 00 00 00 
       00 E2 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 F2 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FB 
       E2 E1 E0 E0 
       E0 E0 FB CB 
       DF CB EB C3 
       00 00 00 00 
       F3 F2 F1 00 
       00 00 00 EF 
       00 EF 00 00 
042F06             0016*M 
042F06             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042F06 17 1B 21    0018*M     db 23,27,0x21
042F09 10 00       0019*M     dw width ; in pixels
042F0B 10 00       0020*M     dw height ; in pixels
042F0D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042F0E             0114*  	LOADBMPBUFFER2 BUF_SEEKER_200,16,16,"../../tgt/sprites/seeker_200.rgba2"
042F0E             0001*M 
042F0E             0002*M     ; Clear buffer
042F0E 17 00 A0    0003*M     db 23,0,0xA0
042F11 2D 01       0004*M     dw bufferId
042F13 02          0005*M     db 2
042F14             0006*M 
042F14 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042F17 2D 01       0008*M     dw bufferId
042F19             0009*M 
042F19             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042F19 17 00 A0    0011*M     db 23,0,0xA0
042F1C 2D 01       0012*M     dw bufferId
042F1E 00          0013*M     db 0
042F1F 00 01       0014*M 	dw width * height ; length of data in bytes
042F21 00 00 00 00 0015*M     incbin file ; bitmap data
       FA E1 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E5 E1 E0 
       E0 E0 E0 00 
       DB 00 DB 00 
       00 00 00 00 
       00 00 F2 E1 
       E0 00 00 FA 
       CB DF CB D7 
       00 00 00 00 
       FA E1 F7 00 
       E2 00 00 00 
       DB 00 DB 00 
       00 00 00 00 
       00 E2 E1 F2 
       E1 E1 E0 00 
       00 00 00 00 
       E0 00 E5 EA 
       E5 E6 D1 E0 
       E0 E0 D0 E0 
       E5 00 00 00 
       E0 E0 E0 FF 
       FF F6 E5 F4 
       F8 F8 E0 D0 
       D0 D0 D1 F3 
       F1 F1 F1 FF 
       FF F6 F1 F8 
       FD FD F8 D1 
       D1 D1 E6 00 
       00 00 FA FF 
       FB FA F5 FC 
       FE FE FD F1 
       E0 00 00 00 
       00 00 00 00 
       F3 FB FE F8 
       FC FD FD F5 
       F1 00 00 00 
       00 00 FA E1 
       E1 FB F6 F6 
       E1 E0 F1 E2 
       E2 E2 FB 00 
       00 00 00 00 
       E2 F2 E1 E1 
       E0 E0 E0 E0 
       E0 E2 F3 00 
       00 00 00 E5 
       F2 00 E2 00 
       00 00 E5 00 
       00 00 00 00 
       00 00 FB E2 
       E1 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F3 
       F2 E0 E0 E0 
       E0 FB DB 00 
       DB 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 CB DF 
       CB EB C3 00 
043021             0016*M 
043021             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043021 17 1B 21    0018*M     db 23,27,0x21
043024 10 00       0019*M     dw width ; in pixels
043026 10 00       0020*M     dw height ; in pixels
043028 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043029             0115*  	LOADBMPBUFFER2 BUF_SEEKER_208,16,16,"../../tgt/sprites/seeker_208.rgba2"
043029             0001*M 
043029             0002*M     ; Clear buffer
043029 17 00 A0    0003*M     db 23,0,0xA0
04302C 2E 01       0004*M     dw bufferId
04302E 02          0005*M     db 2
04302F             0006*M 
04302F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043032 2E 01       0008*M     dw bufferId
043034             0009*M 
043034             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043034 17 00 A0    0011*M     db 23,0,0xA0
043037 2E 01       0012*M     dw bufferId
043039 00          0013*M     db 0
04303A 00 01       0014*M 	dw width * height ; length of data in bytes
04303C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 FA E1 
       E1 E0 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E5 F2 
       E1 E0 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F7 
       E1 E0 E0 E0 
       FA 00 DB 00 
       00 00 00 00 
       00 FA E1 E1 
       00 E2 00 00 
       00 CB DF DB 
       00 E0 00 E5 
       EA E2 D3 F2 
       E1 E1 00 00 
       00 DB 00 CB 
       F1 F1 E0 E0 
       FF E5 E6 D1 
       E0 E0 E0 E0 
       00 00 00 DB 
       00 00 F1 FF 
       FF F6 F1 E5 
       F4 F8 D0 D0 
       E5 00 00 00 
       00 00 FA FF 
       FF FA F5 F8 
       FD F8 E0 D1 
       D0 D0 D0 00 
       00 00 00 F3 
       FB FB FE FC 
       FE FD F8 F1 
       D1 D1 D1 F3 
       00 00 FA E1 
       EB FB F8 FC 
       FD FE FD F5 
       E0 00 E6 00 
       00 00 00 00 
       E1 F2 F6 E1 
       E0 F1 E2 F1 
       00 00 00 00 
       00 00 E5 E2 
       00 E2 E1 E1 
       E0 E0 E0 E2 
       E2 FB 00 00 
       00 FB E2 F2 
       E1 E1 00 00 
       E0 E5 00 E0 
       E0 E2 00 00 
       00 F3 F2 E1 
       E0 E0 00 00 
       00 00 00 00 
       00 F3 00 00 
       00 00 00 F1 
       00 E0 E0 FB 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       CB DF DB 00 
       00 00 00 00 
04313C             0016*M 
04313C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04313C 17 1B 21    0018*M     db 23,27,0x21
04313F 10 00       0019*M     dw width ; in pixels
043141 10 00       0020*M     dw height ; in pixels
043143 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043144             0116*  	LOADBMPBUFFER2 BUF_SEEKER_216,16,16,"../../tgt/sprites/seeker_216.rgba2"
043144             0001*M 
043144             0002*M     ; Clear buffer
043144 17 00 A0    0003*M     db 23,0,0xA0
043147 2F 01       0004*M     dw bufferId
043149 02          0005*M     db 2
04314A             0006*M 
04314A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04314D 2F 01       0008*M     dw bufferId
04314F             0009*M 
04314F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04314F 17 00 A0    0011*M     db 23,0,0xA0
043152 2F 01       0012*M     dw bufferId
043154 00          0013*M     db 0
043155 00 01       0014*M 	dw width * height ; length of data in bytes
043157 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       E1 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E0 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA 00 
       F7 E1 E0 E0 
       00 00 00 00 
       00 E0 E0 00 
       E5 00 E2 E1 
       F7 00 E0 00 
       E0 FA 00 DB 
       00 F1 F1 E0 
       FF EA E2 D3 
       F2 E1 00 00 
       00 00 CB 00 
       00 00 F1 F1 
       FF FF E6 E5 
       E0 E0 E1 00 
       00 DB 00 DF 
       00 00 FA FF 
       FF FA F6 F1 
       F4 E0 D0 E0 
       E0 00 00 DB 
       00 00 00 00 
       FB FA F5 F8 
       FD F8 F8 D0 
       D0 00 00 00 
       00 00 FA F3 
       EB FE F8 FC 
       FE FD F8 D1 
       D0 D0 00 00 
       00 00 00 E1 
       E1 FB F6 FC 
       FE FD F8 F1 
       D1 D1 D1 F3 
       FB 00 E5 E2 
       00 E1 E1 E1 
       FD F1 F5 F1 
       00 00 E6 F3 
       00 E2 F2 E1 
       E2 E2 E1 E0 
       E0 E0 E2 F1 
       00 00 00 00 
       F3 F2 E1 E0 
       E1 00 00 00 
       E0 E0 E0 E2 
       FB 00 00 00 
       00 00 F1 00 
       E0 00 00 00 
       00 00 00 E0 
       E2 00 00 00 
       00 00 00 00 
       00 E0 FB DB 
       00 00 00 00 
       F3 00 00 00 
       00 00 00 00 
       00 00 00 CB 
       00 DB 00 00 
       00 00 00 00 
043257             0016*M 
043257             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043257 17 1B 21    0018*M     db 23,27,0x21
04325A 10 00       0019*M     dw width ; in pixels
04325C 10 00       0020*M     dw height ; in pixels
04325E 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04325F             0117*  	LOADBMPBUFFER2 BUF_SEEKER_224,16,16,"../../tgt/sprites/seeker_224.rgba2"
04325F             0001*M 
04325F             0002*M     ; Clear buffer
04325F 17 00 A0    0003*M     db 23,0,0xA0
043262 30 01       0004*M     dw bufferId
043264 02          0005*M     db 2
043265             0006*M 
043265 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043268 30 01       0008*M     dw bufferId
04326A             0009*M 
04326A             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04326A 17 00 A0    0011*M     db 23,0,0xA0
04326D 30 01       0012*M     dw bufferId
04326F 00          0013*M     db 0
043270 00 01       0014*M 	dw width * height ; length of data in bytes
043272 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 FA E2 E1 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E5 E1 E1 
       E0 00 00 00 
       00 00 E0 E0 
       00 00 00 FA 
       00 F7 F2 E0 
       00 00 00 00 
       00 00 F1 E0 
       E0 EA 00 E2 
       E1 F7 00 E0 
       E0 00 00 00 
       00 00 00 F1 
       FF FF E5 D3 
       D3 F2 E2 00 
       00 E0 00 00 
       00 00 00 FF 
       FF FF F6 E6 
       D1 E0 E1 00 
       00 00 FA DB 
       00 00 00 00 
       FB FA F6 F1 
       F4 E0 E0 E0 
       00 00 DB DF 
       00 00 FA F3 
       EB FB F5 F8 
       FD F8 D0 D0 
       E0 00 00 00 
       00 00 00 E1 
       EB FB F8 FE 
       FD FD E0 D0 
       D0 00 00 00 
       FB E5 E2 E2 
       F2 F6 E1 FC 
       FE F8 F8 D1 
       D0 D0 00 00 
       F3 E1 F2 00 
       E2 E1 E1 E0 
       F1 FD F1 E0 
       D1 D0 D1 00 
       F2 F2 E0 E1 
       00 00 E0 E0 
       E0 E2 F1 E0 
       00 E6 F3 F3 
       00 F1 00 E0 
       00 00 00 E0 
       E0 E0 E2 00 
       00 00 00 00 
       00 00 00 00 
       E0 00 00 00 
       00 E0 E0 FB 
       00 00 00 00 
       00 00 00 00 
       00 FB DB 00 
       00 00 E2 F3 
       00 00 00 00 
       00 00 00 00 
       00 EF DF 00 
       00 00 00 F3 
       00 00 00 00 
043372             0016*M 
043372             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043372 17 1B 21    0018*M     db 23,27,0x21
043375 10 00       0019*M     dw width ; in pixels
043377 10 00       0020*M     dw height ; in pixels
043379 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04337A             0118*  	LOADBMPBUFFER2 BUF_SEEKER_232,16,16,"../../tgt/sprites/seeker_232.rgba2"
04337A             0001*M 
04337A             0002*M     ; Clear buffer
04337A 17 00 A0    0003*M     db 23,0,0xA0
04337D 31 01       0004*M     dw bufferId
04337F 02          0005*M     db 2
043380             0006*M 
043380 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043383 31 01       0008*M     dw bufferId
043385             0009*M 
043385             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043385 17 00 A0    0011*M     db 23,0,0xA0
043388 31 01       0012*M     dw bufferId
04338A 00          0013*M     db 0
04338B 00 01       0014*M 	dw width * height ; length of data in bytes
04338D 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 FA 00 
       E2 00 00 00 
       00 00 00 F1 
       E0 00 00 00 
       00 00 00 E1 
       E1 00 00 00 
       00 00 00 F1 
       E0 E0 E5 00 
       FA 00 E5 F2 
       E1 E0 00 00 
       00 00 00 00 
       F1 E0 EA 00 
       E2 E1 F7 E1 
       E0 00 00 00 
       00 00 00 FA 
       FF FF FF E5 
       D3 E1 00 E2 
       E0 E0 00 00 
       00 00 00 00 
       FF FF F6 F6 
       E5 D1 E1 E2 
       00 00 E0 00 
       00 00 FA F3 
       F3 FB FA F1 
       F4 E0 E0 E1 
       00 00 FA 00 
       00 00 00 E1 
       EB FE F5 FC 
       F8 F8 E0 E0 
       00 00 DB CB 
       E2 E5 E2 E2 
       F2 F6 F8 FE 
       FD FD F8 D0 
       E0 00 00 00 
       F2 E1 E1 00 
       E1 F6 E1 FC 
       FE F8 E0 D0 
       D0 00 00 DB 
       F2 E0 E1 E1 
       00 E1 E0 FD 
       FD FD F1 D1 
       D0 00 00 00 
       00 00 E0 00 
       00 00 E0 E0 
       E2 F5 E0 E0 
       D1 D0 00 00 
       00 00 00 E0 
       00 00 E0 E0 
       E0 E2 00 00 
       E6 D1 F3 00 
       00 00 00 FB 
       00 DB 00 00 
       E0 E2 00 00 
       00 00 00 00 
       00 00 00 00 
       CB 00 00 00 
       00 E2 FB 00 
       00 00 00 00 
       00 00 00 EF 
       00 DF DB 00 
       00 F3 F3 00 
       00 00 00 00 
04348D             0016*M 
04348D             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04348D 17 1B 21    0018*M     db 23,27,0x21
043490 10 00       0019*M     dw width ; in pixels
043492 10 00       0020*M     dw height ; in pixels
043494 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043495             0119*  	LOADBMPBUFFER2 BUF_SEEKER_240,16,16,"../../tgt/sprites/seeker_240.rgba2"
043495             0001*M 
043495             0002*M     ; Clear buffer
043495 17 00 A0    0003*M     db 23,0,0xA0
043498 32 01       0004*M     dw bufferId
04349A 02          0005*M     db 2
04349B             0006*M 
04349B 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04349E 32 01       0008*M     dw bufferId
0434A0             0009*M 
0434A0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0434A0 17 00 A0    0011*M     db 23,0,0xA0
0434A3 32 01       0012*M     dw bufferId
0434A5 00          0013*M     db 0
0434A6 00 01       0014*M 	dw width * height ; length of data in bytes
0434A8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       F1 E0 00 00 
       00 00 00 00 
       FA E2 00 00 
       00 00 00 00 
       00 F1 E0 E5 
       00 FA 00 E5 
       E1 E1 00 00 
       00 00 00 00 
       FA F1 FF EA 
       E2 E1 00 F7 
       F2 E1 E0 00 
       00 00 00 00 
       FF FF FF FF 
       E5 D3 E1 00 
       E1 E0 00 00 
       00 00 00 FA 
       F3 FB FA F6 
       E6 D1 F2 E2 
       E0 E0 E0 00 
       FB E5 00 E1 
       EB FB F5 F1 
       E5 F4 E0 E1 
       00 00 E0 00 
       E2 F2 E2 E1 
       F2 FB FE FC 
       F8 F8 E0 E1 
       00 00 FA 00 
       F2 E1 E1 00 
       E1 F6 F8 FE 
       FD F8 D0 E0 
       E0 00 00 CB 
       F1 E0 E1 E2 
       E1 E1 FC FD 
       FE FD E0 D0 
       E5 00 DB DF 
       00 E0 E0 00 
       00 E0 E0 F1 
       FD F8 D1 D0 
       00 00 00 DB 
       00 00 E0 00 
       00 E0 E0 E2 
       F5 F1 E0 D1 
       D0 00 00 00 
       00 00 FB 00 
       00 00 E5 E0 
       E2 F1 00 D1 
       D0 00 00 00 
       00 00 00 CB 
       DB 00 00 E0 
       E2 00 00 E6 
       D1 F3 00 00 
       00 00 EF DF 
       00 00 00 E0 
       E2 FB 00 00 
       00 00 00 00 
       00 00 00 EF 
       CB DB 00 00 
       F3 00 00 00 
       00 00 00 00 
0435A8             0016*M 
0435A8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0435A8 17 1B 21    0018*M     db 23,27,0x21
0435AB 10 00       0019*M     dw width ; in pixels
0435AD 10 00       0020*M     dw height ; in pixels
0435AF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0435B0             0120*  	LOADBMPBUFFER2 BUF_SEEKER_248,16,16,"../../tgt/sprites/seeker_248.rgba2"
0435B0             0001*M 
0435B0             0002*M     ; Clear buffer
0435B0 17 00 A0    0003*M     db 23,0,0xA0
0435B3 33 01       0004*M     dw bufferId
0435B5 02          0005*M     db 2
0435B6             0006*M 
0435B6 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0435B9 33 01       0008*M     dw bufferId
0435BB             0009*M 
0435BB             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0435BB 17 00 A0    0011*M     db 23,0,0xA0
0435BE 33 01       0012*M     dw bufferId
0435C0 00          0013*M     db 0
0435C1 00 01       0014*M 	dw width * height ; length of data in bytes
0435C3 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F1 F1 E0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 F1 E0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 FA F1 E0 
       E5 00 FA 00 
       00 FA 00 00 
       00 00 00 00 
       00 FF FF FF 
       EA 00 E1 00 
       E5 E1 E2 00 
       FB 00 00 FA 
       00 FB FF FF 
       E5 E2 E1 F7 
       F2 E1 E1 00 
       E2 E5 00 E1 
       F3 FB FA FA 
       F6 E6 D1 F2 
       00 E1 E0 00 
       F2 E1 F2 E2 
       E1 FB FE F5 
       F1 E5 E0 E1 
       E2 E0 E0 00 
       F1 E0 E1 00 
       F2 F6 F8 FC 
       F8 F4 E0 E1 
       00 00 E0 00 
       00 E0 E1 E2 
       E1 E1 FC FE 
       FD F8 E0 E0 
       00 00 E0 00 
       00 E0 00 00 
       E1 E1 FD FE 
       FD F8 D0 E0 
       00 00 FA 00 
       00 E0 00 00 
       E0 E0 F1 FD 
       F8 F8 E0 D0 
       E5 00 DB CB 
       00 00 FB 00 
       00 E0 E0 E2 
       F5 F1 D1 D0 
       00 00 00 DF 
       00 EF CB DB 
       00 E5 E0 E2 
       F1 E0 D1 D0 
       00 00 DB CB 
       00 00 DF 00 
       00 00 E0 E2 
       00 00 D1 D1 
       00 00 00 D7 
       00 EF CB DB 
       00 00 E2 FB 
       00 00 E6 F3 
       00 00 00 C3 
       00 00 EB 00 
       00 00 F3 00 
       00 00 00 00 
       00 00 00 00 
0436C3             0016*M 
0436C3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0436C3 17 1B 21    0018*M     db 23,27,0x21
0436C6 10 00       0019*M     dw width ; in pixels
0436C8 10 00       0020*M     dw height ; in pixels
0436CA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0436CB             0121*  	LOADBMPBUFFER2 BUF_SHIP_0L,16,16,"../../tgt/sprites/ship_0l.rgba2"
0436CB             0001*M 
0436CB             0002*M     ; Clear buffer
0436CB 17 00 A0    0003*M     db 23,0,0xA0
0436CE 34 01       0004*M     dw bufferId
0436D0 02          0005*M     db 2
0436D1             0006*M 
0436D1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0436D4 34 01       0008*M     dw bufferId
0436D6             0009*M 
0436D6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0436D6 17 00 A0    0011*M     db 23,0,0xA0
0436D9 34 01       0012*M     dw bufferId
0436DB 00          0013*M     db 0
0436DC 00 01       0014*M 	dw width * height ; length of data in bytes
0436DE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 C6 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 CA 
       CF C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D4 E5 
       CF C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D4 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D4 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D4 E5 
       CF C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C6 CA 
       CF C7 DB 00 
       00 00 00 00 
       00 00 C7 00 
       C7 CA C6 CA 
       CF C7 CF DB 
       00 00 C7 00 
       00 00 C7 00 
       CA CA C6 CA 
       CF C7 CF CF 
       DB 00 C7 00 
       00 00 C7 C7 
       CA C6 C6 CA 
       CF C7 C7 CF 
       CF DB C7 00 
       00 00 C7 CA 
       C6 C6 C6 CA 
       CF C7 C7 C7 
       CF CF C7 00 
       00 00 C7 CA 
       C6 CA C6 CA 
       CF C7 CF C7 
       C7 CF C7 00 
       00 00 C7 CA 
       C7 C7 C6 CA 
       CF C7 DB DB 
       C7 CF C7 00 
       00 00 C7 00 
       00 00 C6 00 
       00 C7 00 00 
       DB CF C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB DB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
0437DE             0016*M 
0437DE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0437DE 17 1B 21    0018*M     db 23,27,0x21
0437E1 10 00       0019*M     dw width ; in pixels
0437E3 10 00       0020*M     dw height ; in pixels
0437E5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0437E6             0122*  	LOADBMPBUFFER2 BUF_SHIP_1C,16,16,"../../tgt/sprites/ship_1c.rgba2"
0437E6             0001*M 
0437E6             0002*M     ; Clear buffer
0437E6 17 00 A0    0003*M     db 23,0,0xA0
0437E9 35 01       0004*M     dw bufferId
0437EB 02          0005*M     db 2
0437EC             0006*M 
0437EC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0437EF 35 01       0008*M     dw bufferId
0437F1             0009*M 
0437F1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0437F1 17 00 A0    0011*M     db 23,0,0xA0
0437F4 35 01       0012*M     dw bufferId
0437F6 00          0013*M     db 0
0437F7 00 01       0014*M 	dw width * height ; length of data in bytes
0437F9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CF 
       CF C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CF 
       CF C7 DB 00 
       00 00 00 00 
       00 DB 00 00 
       DB CF DB CF 
       CF C7 CF DB 
       00 00 C7 00 
       00 DB 00 DB 
       CF CF DB CF 
       CF C7 CF CF 
       DB 00 C7 00 
       00 DB DB CF 
       CF C7 DB CF 
       CF C7 C7 CF 
       CF DB C7 00 
       00 DB CF CF 
       C7 C7 DB CF 
       CF C7 C7 C7 
       CF CF C7 00 
       00 DB CF C7 
       C7 CF DB CF 
       CF C7 CF C7 
       C7 CF C7 00 
       00 DB CF C7 
       DB DB DB CF 
       CF C7 DB DB 
       C7 CF C7 00 
       00 DB DB DB 
       00 00 DB 00 
       00 C7 00 00 
       DB DB C7 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438F9             0016*M 
0438F9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0438F9 17 1B 21    0018*M     db 23,27,0x21
0438FC 10 00       0019*M     dw width ; in pixels
0438FE 10 00       0020*M     dw height ; in pixels
043900 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043901             0123*  	LOADBMPBUFFER2 BUF_SHIP_2R,16,16,"../../tgt/sprites/ship_2r.rgba2"
043901             0001*M 
043901             0002*M     ; Clear buffer
043901 17 00 A0    0003*M     db 23,0,0xA0
043904 36 01       0004*M     dw bufferId
043906 02          0005*M     db 2
043907             0006*M 
043907 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04390A 36 01       0008*M     dw bufferId
04390C             0009*M 
04390C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04390C 17 00 A0    0011*M     db 23,0,0xA0
04390F 36 01       0012*M     dw bufferId
043911 00          0013*M     db 0
043912 00 01       0014*M 	dw width * height ; length of data in bytes
043914 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C6 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CF 
       CF C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CF 
       E5 D4 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D4 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D4 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CF 
       E5 D4 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CF 
       CF C6 C7 00 
       00 00 00 00 
       00 DB 00 00 
       DB CF DB CF 
       CF C6 CA C7 
       00 C6 00 00 
       00 DB 00 DB 
       CF CF DB CF 
       CF C6 CA CA 
       00 C6 00 00 
       00 DB DB CF 
       CF C7 DB CF 
       CF C6 C6 CA 
       C7 C6 00 00 
       00 DB CF CF 
       C7 C7 DB CF 
       CF C6 C6 C6 
       CA C6 00 00 
       00 DB CF C7 
       C7 CF DB CF 
       CF C6 CA C6 
       CA C6 00 00 
       00 DB CF C7 
       DB DB DB CF 
       CF C6 C7 C7 
       CA C6 00 00 
       00 DB CF DB 
       00 00 DB 00 
       00 C6 00 00 
       00 C6 00 00 
       00 DB DB DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A14             0016*M 
043A14             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A14 17 1B 21    0018*M     db 23,27,0x21
043A17 10 00       0019*M     dw width ; in pixels
043A19 10 00       0020*M     dw height ; in pixels
043A1B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A1C             0124*  	LOADBMPBUFFER2 BUF_SHIP_SMALL,8,8,"../../tgt/sprites/ship_small.rgba2"
043A1C             0001*M 
043A1C             0002*M     ; Clear buffer
043A1C 17 00 A0    0003*M     db 23,0,0xA0
043A1F 37 01       0004*M     dw bufferId
043A21 02          0005*M     db 2
043A22             0006*M 
043A22 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A25 37 01       0008*M     dw bufferId
043A27             0009*M 
043A27             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A27 17 00 A0    0011*M     db 23,0,0xA0
043A2A 37 01       0012*M     dw bufferId
043A2C 00          0013*M     db 0
043A2D 40 00       0014*M 	dw width * height ; length of data in bytes
043A2F 00 00 00 CF 0015*M     incbin file ; bitmap data
       CA 00 00 00 
       00 00 00 FE 
       FC 00 00 00 
       00 00 00 FE 
       FC 00 00 00 
       CF 00 00 CF 
       CA 00 00 CA 
       CF 00 CF C7 
       C6 CF 00 CA 
       CF CF C7 CF 
       CA C6 CF CA 
       CF C7 CF CF 
       CA CF C6 CA 
       CF 00 00 00 
       00 00 00 CA 
043A6F             0016*M 
043A6F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A6F 17 1B 21    0018*M     db 23,27,0x21
043A72 08 00       0019*M     dw width ; in pixels
043A74 08 00       0020*M     dw height ; in pixels
043A76 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A77             0125*  	LOADBMPBUFFER2 BUF_STAR,5,5,"../../tgt/sprites/star.rgba2"
043A77             0001*M 
043A77             0002*M     ; Clear buffer
043A77 17 00 A0    0003*M     db 23,0,0xA0
043A7A 38 01       0004*M     dw bufferId
043A7C 02          0005*M     db 2
043A7D             0006*M 
043A7D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A80 38 01       0008*M     dw bufferId
043A82             0009*M 
043A82             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A82 17 00 A0    0011*M     db 23,0,0xA0
043A85 38 01       0012*M     dw bufferId
043A87 00          0013*M     db 0
043A88 19 00       0014*M 	dw width * height ; length of data in bytes
043A8A 00 00 D0 00 0015*M     incbin file ; bitmap data
       00 00 00 E6 
       00 00 D0 E6 
       FF E6 D0 00 
       00 E6 00 00 
       00 00 D0 00 
       00          
043AA3             0016*M 
043AA3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043AA3 17 1B 21    0018*M     db 23,27,0x21
043AA6 05 00       0019*M     dw width ; in pixels
043AA8 05 00       0020*M     dw height ; in pixels
043AAA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043AAB             0126*  	; LOADBMPBUFFER2 BUF_TURRET,16,16,"../../tgt/sprites/turret.rgba2"
043AAB             0127*  	; LOADBMPBUFFER2 BUF_TURRET_ROT,16,16,"../../tgt/sprites/turret_rot.rgba2"
043AAB             0128*  @end:
043AAB             0048   	include "fonts.asm"
043AAB             0001*  font_nurples:
043AAB 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
043AB3 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
043ABB 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
043AC3 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
043ACB 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
043AD3 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
043ADB 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
043AE3 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
043AEB 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
043AF3 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
043AFB 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
043B03 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
043B0B 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
043B13 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
043B1B 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
043B23 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
043B2B 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
043B33 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
043B3B 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
043B43 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
043B4B 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
043B53 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
043B5B 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
043B63 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
043B6B 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
043B73 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
043B7B 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
043B83 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
043B8B 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
043B93 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
043B9B 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
043BA3 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
043BAB 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
043BB3 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
043BBB F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
043BC3 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
043BCB E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
043BD3 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
043BDB F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
043BE3 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
043BEB 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
043BF3 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
043BFB 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
043C03 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
043C0B 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
043C13 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
043C1B 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
043C23 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
043C2B F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
043C33 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
043C3B F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
043C43 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
043C4B F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
043C53 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
043C5B 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
043C63 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
043C6B 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
043C73 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
043C7B F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
043C83 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
043C8B 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
043C93 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
043C9B 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
043CA3 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
043CAB 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
043CB3 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
043CBB 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
043CC3 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
043CCB 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
043CD3 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
043CDB 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
043CE3 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
043CEB 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
043CF3 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
043CFB 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
043D03 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
043D0B 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
043D13 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
043D1B 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
043D23 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
043D2B 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
043D33 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
043D3B 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
043D43 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
043D4B 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
043D53 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
043D5B 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
043D63 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
043D6B 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
043D73 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
043D7B 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
043D83 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
043D8B 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
043D93 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
043D9B 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
043DA3 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
043DAB 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
043DB3 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
043DBB 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
043DC3 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
043DCB 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
043DD3 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
043DDB 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
043DE3 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
043DEB 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
043DF3 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
043DFB 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
043E03 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
043E0B 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
043E13 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
043E1B 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
043E23 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
043E2B 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
043E33 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
043E3B 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
043E43 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
043E4B 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
043E53 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
043E5B 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
043E63 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
043E6B 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
043E73 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
043E7B 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
043E83 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
043E8B 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
043E93 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
043E9B 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
043EA3 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
043EAB 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
043EB3 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
043EBB 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
043EC3 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
043ECB 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
043ED3 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
043EDB 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
043EE3 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
043EEB FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
043EF3 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
043EFB FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
043F03 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
043F0B 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
043F13 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
043F1B A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
043F23 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
043F2B             0049   	include "levels.asm"
043F2B 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
043F2C 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
043F3C 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
043F4C 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
043F5C 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
043F6C 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
043F7C 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
043F8C 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
043F9C 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
043FAC 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
043FBC 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
043FCC 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
043FDC 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
043FEC 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
043FFC 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
04400C 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04401C 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
04402C 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
04403C 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
04404C 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04405C 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
04406C 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
04407C 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
04408C 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
04409C 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0440AC 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
0440BC 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
0440CC 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
0440DC 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0440EC 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0440FC 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04410C 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
04411C 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
04412C 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
04413C 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04414C 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04415C 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
04416C 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04417C 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04418C 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04419C 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0441AC 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0441BC 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0441CC 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0441DC 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0441EC 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0441FC 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04420C 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04421C 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04422C 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04423C 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04424C 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
04425C 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04426C 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04427C 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
04428C 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04429C 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0442AC 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0442BC 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0442CC 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0442DC 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0442EC 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0442FC 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04430C 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
04431C 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04432C 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04433C 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
04434C 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04435C 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04436C 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04437C 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
04438C 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
04439C 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
0443AC 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0443BC 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0443CC 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0443DC 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443EC 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443FC 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04440C 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04441C 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04442C 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
04443C 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04444C 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04445C 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04446C 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04447C 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04448C 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04449C 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
0444AC 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
0444BC 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0444CC 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0444DC 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0444EC 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
0444FC 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
04450C 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
04451C 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
04452C 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04453C 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04454C 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
04455C 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04456C 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04457C 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04458C 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04459C 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0445AC 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0445BC 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0445CC 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0445DC 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0445EC 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0445FC 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04460C 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04461C 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
04462C 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04463C 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04464C 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04465C 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
04466C 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
04467C 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04468C 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04469C 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0446AC 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0446BC 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
0446CC 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
0446DC 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
0446EC 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0446FC 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04470C 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04471C 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04472C 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04473C 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
04474C 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
04475C 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
04476C 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04477C 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04478C 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04479C 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447AC 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447BC 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447CC 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0447DC 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
0447EC 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
0447FC 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04480C 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04481C 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04482C 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04483C 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
04484C 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
04485C 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
04486C 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04487C 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04488C 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
04489C 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
0448AC 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
0448BC 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0448CC 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
0448DC 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
0448EC 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
0448FC 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04490C 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04491C 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
04492C 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
04493C 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
04494C 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
04495C 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04496C 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04497C 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
04498C 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
04499C 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
0449AC 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
0449BC 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449CC 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449DC 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449EC 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449FC 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A0C 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A1C 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A2C 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A3C 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A4C 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A5C 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A6C 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A7C 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044A8C 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044A9C 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044AAC 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044ABC 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044ACC 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044ADC 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044AEC 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044AFC 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044B0C 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044B1C 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044B2C 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044B3C 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044B4C 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044B5C 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044B6C 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044B7C 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044B8C 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044B9C 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044BAC 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044BBC 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044BCC 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044BDC 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044BEC 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044BFC 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
044C0C 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044C1C 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044C2C 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044C3C 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044C4C 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044C5C 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
044C6C 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
044C7C 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
044C8C 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
044C9C 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
044CAC 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
044CBC 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
044CCC 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
044CDC 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CEC 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CFC 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044D0C 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D1C 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D2C 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
044D3C 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D4C 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D5C 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044D6C 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044D7C 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044D8C 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044D9C 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044DAC 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044DBC 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
044DCC 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DDC 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DEC 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044DFC 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044E0C 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044E1C 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044E2C 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E3C 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E4C 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
044E5C 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E6C 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E7C 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044E8C 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044E9C 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044EAC 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044EBC 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044ECC 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044EDC 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
044EEC 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
044EFC 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
044F0C 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
044F1C 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F2C             0258*  
044F2C             0259*  
044F2C 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
044F2D 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F3D 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F4D 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F5D 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F6D 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F7D 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F8D 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F9D 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FAD 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FBD 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FCD 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FDD 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FED 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044FFD 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04500D 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04501D 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04502D             0277*  
04502D             0050   
04502D             0051   	include "sprites.asm"
04502D             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
04502D             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
04502D             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
04502D             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
04502D             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
04502D             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
04502D             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
04502D             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
04502D             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
04502D             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
04502D             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
04502D             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04502D             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04502D             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
04502D             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
04502D             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
04502D             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
04502D             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
04502D             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
04502D             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
04502D             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
04502D             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
04502D             0023*  
04502D             0024*  ; ###### SPRITE TABLE VARIABLES ######
04502D             0025*  ; maximum number of sprites
04502D             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
04502D             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
04502D             0028*  
04502D             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
04502D             0030*  table_base:
04502D 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0450C5             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0450C5             0033*  
0450C5             0034*  ; pointer to top address of current record, initialized to table_base
0450C5 2D 50 04    0035*  table_pointer: dl table_base
0450C8             0036*  ; how many active sprites
0450C8 00          0037*  table_active_sprites: db 0x00
0450C9             0038*  ; flag indicating collision with screen edge
0450C9             0039*  ; uses orientation codes to specify which edge(s)
0450C9 00          0040*  sprite_screen_edge: db #00
0450CA             0041*  ; next sprite id to use
0450CA 00          0042*  sprite_next_id: db 0
0450CB             0043*  
0450CB             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
0450CB             0045*  ; integer coordinates are all that are needed for collision calculations
0450CB 00          0046*  collision_x: db 0x00
0450CC 00          0047*  collision_y: db 0x00
0450CD 00          0048*  collision_dim_x: db 0x00
0450CE 00          0049*  collision_dim_y: db 0x00
0450CF             0050*  
0450CF             0051*  ; scratch variables
0450CF 00          0052*  x: db 0x00 ; 8-bit signed integer
0450D0 00          0053*  y: db 0x00 ; 8-bit signed integer
0450D1 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
0450D4 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
0450D7 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
0450DA 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
0450DD 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
0450E0 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
0450E3             0060*  
0450E3             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
0450E3 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
0450E6 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
0450E9 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
0450EC             0065*  
0450EC             0066*  ; gets the next available sprite id
0450EC             0067*  ; inputs; none
0450EC             0068*  ; returns: if new sprite available, a = sprite id,
0450EC             0069*  ;           ix pointing to new sprite vars, carry set
0450EC             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
0450EC             0071*  ; destroys: a,b,hl,ix
0450EC             0072*  ; affects: bumps table_active_sprites by one
0450EC             0073*  table_get_next_id:
0450EC DD 21 2D 50 0074*      ld ix,table_base
       04          
0450F1 11 26 00 00 0075*      ld de,table_bytes_per_record
0450F5 06 04       0076*      ld b,table_max_records
0450F7             0077*  @loop:
0450F7 DD 7E 01    0078*      ld a,(ix+sprite_type)
0450FA A7          0079*      and a
0450FB 28 06       0080*      jr z,@found
0450FD DD 19       0081*      add ix,de
0450FF 10 F6       0082*      djnz @loop
045101             0083*  @notfound:
045101 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
045102 C9          0085*      ret
045103             0086*  @found:
045103             0087*  ; bump number of active sprites
045103 21 C8 50 04 0088*      ld hl,table_active_sprites
045107 34          0089*      inc (hl)
045108             0090*  ; return sprite id
045108 3E 04       0091*      ld a,table_max_records
04510A 90          0092*      sub b
04510B 32 CA 50 04 0093*      ld (sprite_next_id),a
04510F 37          0094*      scf ; sets carry flag indicating we found a free sprite
045110 C9          0095*      ret ; done
045111             0096*  
045111             0097*  ; deactivate the sprite with the given id
045111             0098*  ; inputs: a = sprite id
045111             0099*  ; outputs: nothing
045111             0100*  ; destroys: a,ix,de
045111             0101*  ; affects: decrements table_active_sprites by one
045111             0102*  table_deactivate_sprite:
045111 F5          0103*      push af ; save sprite id bc we need it later
045112 CD 68 5F 04 0104*      call vdu_sprite_select
045116 CD EC 5F 04 0105*      call vdu_sprite_hide
04511A F1          0106*      pop af ; restore sprite id
04511B 11 00 00 00 0107*      ld de,0 ; clear deu
04511F 57          0108*      ld d,a
045120 1E 26       0109*      ld e,table_bytes_per_record
045122 ED 5C       0110*      mlt de
045124 DD 21 2D 50 0111*      ld ix,table_base
       04          
045129 DD 19       0112*      add ix,de
04512B AF          0113*      xor a
04512C DD 77 01    0114*      ld (ix+sprite_type),a
04512F DD 21 C8 50 0115*      ld ix,table_active_sprites
       04          
045134 DD 35 00    0116*      dec (ix)
045137 C9          0117*      ret
045138             0052   ; API includes
045138             0053       include "mos_api.inc"
045138             0001*  ;
045138             0002*  ; Title:	AGON MOS - API for user projects
045138             0003*  ; Author:	Dean Belfield
045138             0004*  ; Created:	03/08/2022
045138             0005*  ; Last Updated:	11/11/2023
045138             0006*  ;
045138             0007*  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
045138             0008*  ;
045138             0009*  ; Modinfo:
045138             0010*  ; 05/08/2022:	Added mos_feof
045138             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
045138             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
045138             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
045138             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
045138             0015*  ; 13/10/2022:	Added mos_oscli
045138             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
045138             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
045138             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
045138             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
045138             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
045138             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
045138             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
045138             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
045138             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
045138             0025*  ; 19/05/2023:	Added sysvar_scrMode
045138             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
045138             0027*  ; 03/08/2023:	Added mos_setkbvector
045138             0028*  ; 10/08/2023:	Added mos_getkbmap
045138             0029*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
045138             0030*  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
045138             0031*  ;
045138             0032*  ; VDP control (VDU 23, 0, n)
045138             0033*  ;
045138             0034*  vdp_gp:			EQU 	80h
045138             0035*  vdp_keycode:		EQU 	81h
045138             0036*  vdp_cursor:		EQU	82h
045138             0037*  vdp_scrchar:		EQU	83h
045138             0038*  vdp_scrpixel:		EQU	84h
045138             0039*  vdp_audio:		EQU	85h
045138             0040*  vdp_mode:		EQU	86h
045138             0041*  vdp_rtc:		EQU	87h
045138             0042*  vdp_keystate:		EQU	88h
045138             0043*  vdp_logicalcoords:	EQU	C0h
045138             0044*  vdp_terminalmode:	EQU	FFh
045138             0045*  
045138             0046*  ; MOS high level functions
045138             0047*  ;
045138             0048*  mos_getkey:		EQU	00h
045138             0049*  mos_load:		EQU	01h
045138             0050*  mos_save:		EQU	02h
045138             0051*  mos_cd:			EQU	03h
045138             0052*  mos_dir:		EQU	04h
045138             0053*  mos_del:		EQU	05h
045138             0054*  mos_ren:		EQU	06h
045138             0055*  mos_mkdir:		EQU	07h
045138             0056*  mos_sysvars:		EQU	08h
045138             0057*  mos_editline:		EQU	09h
045138             0058*  mos_fopen:		EQU	0Ah
045138             0059*  mos_fclose:		EQU	0Bh
045138             0060*  mos_fgetc:		EQU	0Ch
045138             0061*  mos_fputc:		EQU	0Dh
045138             0062*  mos_feof:		EQU	0Eh
045138             0063*  mos_getError:		EQU	0Fh
045138             0064*  mos_oscli:		EQU	10h
045138             0065*  mos_copy:		EQU	11h
045138             0066*  mos_getrtc:		EQU	12h
045138             0067*  mos_setrtc:		EQU	13h
045138             0068*  mos_setintvector:	EQU	14h
045138             0069*  mos_uopen:		EQU	15h
045138             0070*  mos_uclose:		EQU	16h
045138             0071*  mos_ugetc:		EQU	17h
045138             0072*  mos_uputc:		EQU 	18h
045138             0073*  mos_getfil:		EQU	19h
045138             0074*  mos_fread:		EQU	1Ah
045138             0075*  mos_fwrite:		EQU	1Bh
045138             0076*  mos_flseek:		EQU	1Ch
045138             0077*  mos_setkbvector:	EQU	1Dh
045138             0078*  mos_getkbmap:		EQU	1Eh
045138             0079*  mos_i2c_open:		EQU	1Fh
045138             0080*  mos_i2c_close:		EQU	20h
045138             0081*  mos_i2c_write:		EQU	21h
045138             0082*  mos_i2c_read:		EQU	22h
045138             0083*  
045138             0084*  
045138             0085*  ; FatFS file access functions
045138             0086*  ;
045138             0087*  ffs_fopen:		EQU	80h
045138             0088*  ffs_fclose:		EQU	81h
045138             0089*  ffs_fread:		EQU	82h
045138             0090*  ffs_fwrite:		EQU	83h
045138             0091*  ffs_flseek:		EQU	84h
045138             0092*  ffs_ftruncate:		EQU	85h
045138             0093*  ffs_fsync:		EQU	86h
045138             0094*  ffs_fforward:		EQU	87h
045138             0095*  ffs_fexpand:		EQU	88h
045138             0096*  ffs_fgets:		EQU	89h
045138             0097*  ffs_fputc:		EQU	8Ah
045138             0098*  ffs_fputs:		EQU	8Bh
045138             0099*  ffs_fprintf:		EQU	8Ch
045138             0100*  ffs_ftell:		EQU	8Dh
045138             0101*  ffs_feof:		EQU	8Eh
045138             0102*  ffs_fsize:		EQU	8Fh
045138             0103*  ffs_ferror:		EQU	90h
045138             0104*  
045138             0105*  ; FatFS directory access functions
045138             0106*  ;
045138             0107*  ffs_dopen:		EQU	91h
045138             0108*  ffs_dclose:		EQU	92h
045138             0109*  ffs_dread:		EQU	93h
045138             0110*  ffs_dfindfirst:		EQU	94h
045138             0111*  ffs_dfindnext:		EQU	95h
045138             0112*  
045138             0113*  ; FatFS file and directory management functions
045138             0114*  ;
045138             0115*  ffs_stat:		EQU	96h
045138             0116*  ffs_unlink:		EQU	97h
045138             0117*  ffs_rename:		EQU	98h
045138             0118*  ffs_chmod:		EQU	99h
045138             0119*  ffs_utime:		EQU	9Ah
045138             0120*  ffs_mkdir:		EQU	9Bh
045138             0121*  ffs_chdir:		EQU	9Ch
045138             0122*  ffs_chdrive:		EQU	9Dh
045138             0123*  ffs_getcwd:		EQU	9Eh
045138             0124*  
045138             0125*  ; FatFS volume management and system configuration functions
045138             0126*  ;
045138             0127*  ffs_mount:		EQU	9Fh
045138             0128*  ffs_mkfs:		EQU	A0h
045138             0129*  ffs_fdisk:		EQU	A1h
045138             0130*  ffs_getfree:		EQU	A2h
045138             0131*  ffs_getlabel:		EQU	A3h
045138             0132*  ffs_setlabel:		EQU	A4h
045138             0133*  ffs_setcp:		EQU	A5h
045138             0134*  
045138             0135*  ; File access modes
045138             0136*  ;
045138             0137*  fa_read:		EQU	01h
045138             0138*  fa_write:		EQU	02h
045138             0139*  fa_open_existing:	EQU	00h
045138             0140*  fa_create_new:		EQU	04h
045138             0141*  fa_create_always:	EQU	08h
045138             0142*  fa_open_always:		EQU	10h
045138             0143*  fa_open_append:		EQU	30h
045138             0144*  
045138             0145*  ; System variable indexes for api_sysvars
045138             0146*  ; Index into _sysvars in globals.asm
045138             0147*  ;
045138             0148*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
045138             0149*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
045138             0150*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
045138             0151*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
045138             0152*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
045138             0153*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
045138             0154*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
045138             0155*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
045138             0156*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
045138             0157*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
045138             0158*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
045138             0159*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
045138             0160*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
045138             0161*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
045138             0162*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
045138             0163*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
045138             0164*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
045138             0165*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
045138             0166*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
045138             0167*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
045138             0168*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
045138             0169*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
045138             0170*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
045138             0171*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
045138             0172*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
045138             0173*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
045138             0174*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
045138             0175*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
045138             0176*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
045138             0177*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
045138             0178*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
045138             0179*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
045138             0180*  ;
045138             0181*  ; Flags for the VPD protocol
045138             0182*  ;
045138             0183*  vdp_pflag_cursor:	EQU	00000001b
045138             0184*  vdp_pflag_scrchar:	EQU	00000010b
045138             0185*  vdp_pflag_point:	EQU	00000100b
045138             0186*  vdp_pflag_audio:	EQU	00001000b
045138             0187*  vdp_pflag_mode:		EQU	00010000b
045138             0188*  vdp_pflag_rtc:		EQU	00100000b
045138             0189*  vdp_pflag_mouse:	EQU	01000000b
045138             0190*  ; vdp_pflag_buffered:	EQU	10000000b
045138             0191*  
045138             0192*  
045138             0193*  ; FatFS structures
045138             0194*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
045138             0195*  ;
045138             0196*  ; Object ID and allocation information (FFOBJID)
045138             0197*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
045138             0198*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
045138             0199*  FFOBJID.attr:     EQU 5    ; Object attribute
045138             0200*  FFOBJID.stat:     EQU 6    ; Object chain status
045138             0201*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
045138             0202*  FFOBJID.objsize:  EQU 11   ; Object size
045138             0203*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
045138             0204*  ;
045138             0205*  ; File object structure (FIL)
045138             0206*  ;
045138             0207*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
045138             0208*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
045138             0209*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
045138             0210*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
045138             0211*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
045138             0212*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
045138             0213*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
045138             0214*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
045138             0215*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
045138             0216*  ;
045138             0217*  ; Directory object structure (DIR)
045138             0218*  ;
045138             0219*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
045138             0220*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
045138             0221*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
045138             0222*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
045138             0223*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
045138             0224*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
045138             0225*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
045138             0226*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
045138             0227*  ;
045138             0228*  ; File information structure (FILINFO)
045138             0229*  ;
045138             0230*  FILINFO.fsize:    EQU 0    ; File size
045138             0231*  FILINFO.fdate:    EQU 4    ; Modified date
045138             0232*  FILINFO.ftime:    EQU 6    ; Modified time
045138             0233*  FILINFO.fattrib:  EQU 8    ; File attribute
045138             0234*  FILINFO.altname:  EQU 9    ; Alternative file name
045138             0235*  FILINFO.fname:    EQU 22   ; Primary file name
045138             0236*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
045138             0237*  ;
045138             0238*  ; Macro for calling the API
045138             0239*  ; Parameters:
045138             0240*  ; - function: One of the function numbers listed above
045138             0241*  ;
045138             0242*  			MACRO MOSCALL	function
045138             0243*  			LD	A, function
045138             0244*  			RST.LIS	08h
045138             0245*  			ENDMACRO
045138             0054       include "functions.inc"
045138             0001*  
045138             0002*      MACRO printChar char
045138             0003*          LD A, char
045138             0004*          RST.LIL 10h
045138             0005*      ENDMACRO
045138             0006*  
045138             0007*  ; test the sign of HL
045138             0008*  ; inputs: HL obviously
045138             0009*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
045138             0010*  ; destroys: flags
045138             0011*      MACRO sign_hlu
045138             0012*          add hl,de
045138             0013*          or a
045138             0014*          sbc hl,de
045138             0015*      ENDMACRO
045138             0016*  
045138             0017*  ; Simulated call to subroutine at HL
045138             0018*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
045138             0019*  ; outputs: whatever the subroutine does, including HL and BC
045138             0020*  ; destroys: only what the subroutine does, but always BC
045138             0021*      MACRO callHL
045138             0022*          ld bc,$+7     ; Address of first instruction after the jump
045138             0023*          push bc       ; which constitutes the return address
045138             0024*          jp   (hl)     ; Jump to the address in HL
045138             0025*      ENDMACRO
045138             0026*  
045138             0027*  ; Simulated call to subroutine at IX
045138             0028*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
045138             0029*  ; outputs: whatever the subroutine does, including IX and BC
045138             0030*  ; destroys: only what the subroutine does, but always BC
045138             0031*      MACRO callIX
045138             0032*          ld bc,$+7     ; Address of first instruction after the jump
045138             0033*          push bc       ; which constitutes the return address
045138             0034*          jp   (ix)     ; Jump to the address in IX
045138             0035*      ENDMACRO
045138             0036*  
045138             0037*  ; Simulated call to soubroutinte at IY
045138             0038*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
045138             0039*  ; outputs: whatever the subroutine does, including IY and BC
045138             0040*  ; destroys: only what the subroutine does, but always BC
045138             0041*      MACRO callIY
045138             0042*          ld bc,$+7     ; Address of first instruction after the jump
045138             0043*          push bc       ; which constitutes the return address
045138             0044*          jp   (iy)     ; Jump to the address in IY
045138             0045*      ENDMACRO
045138             0046*  
045138             0047*  ; put the value in HLU into the accumulator
045138             0048*  ; destroys: af
045138             0049*      MACRO HLU_TO_A
045138             0050*          push hl ; 4 cycles
045138             0051*          inc sp ; 1 cycle
045138             0052*          pop af  ; 4 cycles
045138             0053*          dec sp ; 1 cycle
045138             0054*                 ; 10 cycles total
045138             0055*      ENDMACRO
045138             0056*  
045138             0057*  A_TO_HLU:
045138             0058*      ; call is 7 cycles
045138 22 45 51 04 0059*      ld (@scratch),hl ; 7 cycles
04513C 32 47 51 04 0060*      ld (@scratch+2),a ; 5 cycles
045140 2A 45 51 04 0061*      ld hl,(@scratch) ; 7 cycles
045144 C9          0062*      ret ; 6 cycles
045145             0063*          ; 25 cycles total
045145 00 00 00    0064*  @scratch: dl 0
045148             0065*  
045148             0066*      ; TODO: implement this
045148             0067*      ; MACRO A_TO_HLU
045148             0068*      ;     push.s af
045148             0069*      ;     inc sp
045148             0070*      ;     push.s hl
045148             0071*      ;     pop hl
045148             0072*      ;     inc sp
045148             0073*      ;     inc sp
045148             0074*      ; ENDMACRO
045148             0075*  
045148             0076*      MACRO PUSH_ALL
045148             0077*          ex af,af'
045148             0078*          exx
045148             0079*          push af
045148             0080*          push hl
045148             0081*          push bc
045148             0082*          push de
045148             0083*  
045148             0084*          ex af,af'
045148             0085*          exx
045148             0086*          push af
045148             0087*          push hl
045148             0088*          push bc
045148             0089*          push de
045148             0090*          push ix
045148             0091*          push iy
045148             0092*      ENDMACRO
045148             0093*  
045148             0094*      MACRO POP_ALL
045148             0095*          pop iy
045148             0096*          pop ix
045148             0097*          pop de
045148             0098*          pop bc
045148             0099*          pop hl
045148             0100*          pop af
045148             0101*          ex af,af'
045148             0102*          exx
045148             0103*  
045148             0104*          pop de
045148             0105*          pop bc
045148             0106*          pop hl
045148             0107*          pop af
045148             0108*          ex af,af'
045148             0109*          exx
045148             0110*      ENDMACRO
045148             0111*  
045148             0112*  ; Print a zero-terminated string inline with code, e.g.:
045148             0113*  ;
045148             0114*  ;    call printInline
045148             0115*  ;    ASCIZ "Hello, world!\r\n"
045148             0116*  ;
045148             0117*  ; Destroys: HL,AF
045148             0118*  printInline:
045148 E1          0119*      pop hl ; get the return address = pointer to start of string
045149 CD 4F 51 04 0120*      call printString ; HL advances to end of string
04514D E5          0121*      push hl ; restore the return address = pointer to end of string
04514E C9          0122*      ret
04514F             0123*  
04514F             0124*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04514F             0125*  ; Print a zero-terminated string
04514F             0126*  ; HL: Pointer to string
04514F             0127*  printString:
04514F C5          0128*  	PUSH	BC
045150 01 00 00 00 0129*  	LD		BC,0
045154 3E 00       0130*  	LD 	 	A,0
045156 5B DF       0131*  	RST.LIL 18h
045158 C1          0132*  	POP		BC
045159 C9          0133*  	RET
04515A             0134*  ; print a VDU sequence
04515A             0135*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
04515A             0136*  sendVDUsequence:
04515A C5          0137*  	PUSH	BC
04515B 01 00 00 00 0138*  	LD		BC, 0
04515F 4E          0139*  	LD		C, (HL)
045160 5B DF       0140*  	RST.LIL	18h
045162 C1          0141*  	POP		BC
045163 C9          0142*  	RET
045164             0143*  ; Print Newline sequence to VDP
045164             0144*  printNewLine:
045164 F5          0145*      push af ; for some reason rst.lil 10h sets carry flag
045165 3E 0D       0146*  	LD	A, '\r'
045167 5B D7       0147*  	RST.LIL 10h
045169 3E 0A       0148*  	LD	A, '\n'
04516B 5B D7       0149*  	RST.LIL 10h
04516D F1          0150*      pop af
04516E C9          0151*  	RET
04516F             0152*  
04516F             0153*  ; Print a 24-bit HEX number
04516F             0154*  ; HLU: Number to print
04516F             0155*  printHex24:
04516F             0156*      HLU_TO_A
04516F E5          0001*M         push hl ; 4 cycles
045170 33          0002*M         inc sp ; 1 cycle
045171 F1          0003*M         pop af  ; 4 cycles
045172 3B          0004*M         dec sp ; 1 cycle
045173             0005*M                ; 10 cycles total
045173 CD 7D 51 04 0157*  	CALL	printHex8
045177             0158*  ; Print a 16-bit HEX number
045177             0159*  ; HL: Number to print
045177             0160*  printHex16:
045177 7C          0161*  	LD		A,H
045178 CD 7D 51 04 0162*  	CALL	printHex8
04517C 7D          0163*  	LD		A,L
04517D             0164*  ; Print an 8-bit HEX number
04517D             0165*  ; A: Number to print
04517D             0166*  printHex8:
04517D 4F          0167*  	LD		C,A
04517E 1F          0168*  	RRA
04517F 1F          0169*  	RRA
045180 1F          0170*  	RRA
045181 1F          0171*  	RRA
045182 CD 87 51 04 0172*  	CALL	@F
045186 79          0173*  	LD		A,C
045187             0174*  @@:
045187 E6 0F       0175*  	AND		0Fh
045189 C6 90       0176*  	ADD		A,90h
04518B 27          0177*  	DAA
04518C CE 40       0178*  	ADC		A,40h
04518E 27          0179*  	DAA
04518F 5B D7       0180*  	RST.LIL	10h
045191 C9          0181*  	RET
045192             0182*  
045192             0183*  printHexA:
045192 F5          0184*      push af
045193 C5          0185*      push bc
045194 CD 7D 51 04 0186*      call printHex8
045198 3E 20       0187*      ld a,' '
04519A 5B D7       0188*      rst.lil 10h
04519C C1          0189*      pop bc
04519D F1          0190*      pop af
04519E C9          0191*      ret
04519F             0192*  
04519F             0193*  printHexHL:
04519F F5          0194*      push af
0451A0 C5          0195*      push bc
0451A1 CD 77 51 04 0196*      call printHex16
0451A5 3E 20       0197*      ld a,' '
0451A7 5B D7       0198*      rst.lil 10h
0451A9 C1          0199*      pop bc
0451AA F1          0200*      pop af
0451AB C9          0201*      ret
0451AC             0202*  
0451AC             0203*  printHexUHL:
0451AC F5          0204*      push af
0451AD C5          0205*      push bc
0451AE CD 6F 51 04 0206*      call printHex24
0451B2 3E 20       0207*      ld a,' '
0451B4 5B D7       0208*      rst.lil 10h
0451B6 C1          0209*      pop bc
0451B7 F1          0210*      pop af
0451B8 C9          0211*      ret
0451B9             0212*  
0451B9             0213*  printHexAUHL:
0451B9 F5          0214*      push af
0451BA C5          0215*      push bc
0451BB CD 7D 51 04 0216*      call printHex8
0451BF 3E 2E       0217*      ld a,'.'
0451C1 5B D7       0218*      rst.lil 10h
0451C3 CD 6F 51 04 0219*      call printHex24
0451C7 3E 20       0220*      ld a,' '
0451C9 5B D7       0221*      rst.lil 10h
0451CB C1          0222*      pop bc
0451CC F1          0223*      pop af
0451CD C9          0224*      ret
0451CE             0225*  
0451CE             0226*  printHexABHL:
0451CE             0227*  ; preserve registers
0451CE C5          0228*      push bc ; b will be ok c will not
0451CF F5          0229*      push af ; will get totally destroyed
0451D0             0230*  ; print a
0451D0 CD 7D 51 04 0231*      call printHex8
0451D4             0232*  ; print b
0451D4 78          0233*      ld a,b
0451D5 CD 7D 51 04 0234*      call printHex8
0451D9             0235*  ; print hl
0451D9 CD 77 51 04 0236*      call printHex16
0451DD             0237*  ; restore registers
0451DD F1          0238*      pop af
0451DE C1          0239*      pop bc
0451DF C9          0240*      ret
0451E0             0241*  
0451E0             0242*  printHexBHL:
0451E0             0243*  ; preserve registers
0451E0 C5          0244*      push bc ; b will be ok c will not
0451E1 F5          0245*      push af ; will get totally destroyed
0451E2             0246*  ; print b
0451E2 78          0247*      ld a,b
0451E3 CD 7D 51 04 0248*      call printHex8
0451E7             0249*  ; print hl
0451E7 CD 77 51 04 0250*      call printHex16
0451EB             0251*  ; restore registers
0451EB F1          0252*      pop af
0451EC C1          0253*      pop bc
0451ED C9          0254*      ret
0451EE             0255*  
0451EE             0256*  printHexCDE:
0451EE             0257*  ; preserve registers
0451EE C5          0258*      push bc ; b will be ok c will not
0451EF F5          0259*      push af ; will get totally destroyed
0451F0             0260*  ; print c
0451F0 79          0261*      ld a,c
0451F1 CD 7D 51 04 0262*      call printHex8
0451F5             0263*  ; print de
0451F5 EB          0264*      ex de,hl
0451F6 CD 77 51 04 0265*      call printHex16
0451FA EB          0266*      ex de,hl
0451FB             0267*  ; restore registers
0451FB F1          0268*      pop af
0451FC C1          0269*      pop bc
0451FD C9          0270*      ret
0451FE             0271*  
0451FE             0272*  printHexUIX:
0451FE             0273*  ; store everything in scratch
0451FE 22 77 56 04 0274*      ld (uhl),hl
045202 ED 43 7A 56 0275*      ld (ubc),bc
       04          
045207 ED 53 7D 56 0276*      ld (ude),de
       04          
04520C DD 22 80 56 0277*      ld (uix),ix
       04          
045211 FD 22 83 56 0278*      ld (uiy),iy
       04          
045216 F5          0279*      push af ; fml
045217             0280*  
045217 21 0E 56 04 0281*      ld hl,str_ixu
04521B CD 4F 51 04 0282*      call printString
04521F 2A 80 56 04 0283*      ld hl,(uix)
045223 CD 6F 51 04 0284*      call printHex24
045227 CD 64 51 04 0285*      call printNewLine
04522B             0286*  
04522B             0287*  ; restore everything
04522B 2A 77 56 04 0288*      ld hl, (uhl)
04522F ED 4B 7A 56 0289*      ld bc, (ubc)
       04          
045234 ED 5B 7D 56 0290*      ld de, (ude)
       04          
045239 DD 2A 80 56 0291*      ld ix, (uix)
       04          
04523E FD 2A 83 56 0292*      ld iy, (uiy)
       04          
045243 F1          0293*      pop af
045244             0294*  ; all done
045244 C9          0295*      ret
045245             0296*  
045245             0297*  ; Print a 0x HEX prefix
045245             0298*  DisplayHexPrefix:
045245 3E 30       0299*  	LD	A, '0'
045247 5B D7       0300*  	RST.LIL 10h
045249 3E 78       0301*  	LD	A, 'x'
04524B 5B D7       0302*  	RST.LIL 10h
04524D C9          0303*  	RET
04524E             0304*  
04524E             0305*      MACRO printDecBC
04524E             0306*          push hl
04524E             0307*          push bc
04524E             0308*          pop hl
04524E             0309*          call printDec
04524E             0310*          pop hl
04524E             0311*      ENDMACRO
04524E             0312*  
04524E             0313*      MACRO printDecDE
04524E             0314*          push hl
04524E             0315*          push de
04524E             0316*          pop hl
04524E             0317*          call printDec
04524E             0318*          pop hl
04524E             0319*      ENDMACRO
04524E             0320*  
04524E             0321*      MACRO printDecHL
04524E             0322*          call printDec
04524E             0323*      ENDMACRO
04524E             0324*  
04524E             0325*      MACRO printDecIX
04524E             0326*          push hl
04524E             0327*          push ix
04524E             0328*          pop hl
04524E             0329*          call printDec
04524E             0330*          pop hl
04524E             0331*      ENDMACRO
04524E             0332*  
04524E             0333*      MACRO printDecIY
04524E             0334*          push hl
04524E             0335*          push iy
04524E             0336*          pop hl
04524E             0337*          call printDec
04524E             0338*          pop hl
04524E             0339*      ENDMACRO
04524E             0340*  
04524E             0341*  
04524E             0342*  ; Prints the right justified decimal value in HL without leading zeroes
04524E             0343*  ; HL : Value to print
04524E             0344*  ; preserves all registers and flags
04524E             0345*  printDec:
04524E             0346*  ; BEGIN MY CODE
04524E             0347*  ; back up all the things
04524E F5          0348*      push af
04524F C5          0349*      push bc
045250 D5          0350*      push de
045251 E5          0351*      push hl
045252             0352*  ; END MY CODE
045252 11 7A 52 04 0353*  	LD	 DE, _printDecBuffer
045256 CD 8A 52 04 0354*  	CALL u24_to_ascii
04525A             0355*  ; BEGIN MY CODE
04525A             0356*  ; replace leading zeroes with spaces
04525A 21 7A 52 04 0357*      LD	 HL, _printDecBuffer
04525E 06 07       0358*      ld   B, 7 ; if HL was 0, we want to keep the final zero
045260             0359*  @loop:
045260 7E          0360*      LD	 A, (HL)
045261 FE 30       0361*      CP	 '0'
045263 C2 6D 52 04 0362*      JP	 NZ, @done
045267 3E 20       0363*      LD   A, ' '
045269 77          0364*      LD	 (HL), A
04526A 23          0365*      INC	 HL
04526B             0366*      ; CALL vdu_cursor_forward
04526B 10 F3       0367*      DJNZ @loop
04526D             0368*  @done:
04526D             0369*  ; END MY CODE
04526D 21 7A 52 04 0370*  	LD	 HL, _printDecBuffer
045271 CD 4F 51 04 0371*  	CALL printString
045275             0372*  ; BEGIN MY CODE
045275             0373*  ; restore all the things
045275 E1          0374*      pop hl
045276 D1          0375*      pop de
045277 C1          0376*      pop bc
045278 F1          0377*      pop af
045279             0378*  ; END MY CODE
045279 C9          0379*  	RET
04527A 00 00 00 00 0380*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04528A             0381*  
04528A             0382*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
04528A             0383*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
04528A             0384*  ; so it will allways be 8 characters length
04528A             0385*  ; HL : Value to convert to string
04528A             0386*  ; DE : pointer to buffer, at least 8 byte + 0
04528A             0387*  u24_to_ascii:
04528A 01 80 69 67 0388*  	LD	 BC,-10000000
04528E CD C1 52 04 0389*  	CALL @one_digit
045292 01 C0 BD F0 0390*  	LD	 BC,-1000000
045296 CD C1 52 04 0391*  	CALL @one_digit
04529A 01 60 79 FE 0392*  	LD	 BC,-100000
04529E CD C1 52 04 0393*  	CALL @one_digit
0452A2 01 F0 D8 FF 0394*  	LD   BC,-10000
0452A6 CD C1 52 04 0395*  	CALL @one_digit
0452AA 01 18 FC FF 0396*  	LD   BC,-1000
0452AE CD C1 52 04 0397*  	CALL @one_digit
0452B2 01 9C FF FF 0398*  	LD   BC,-100
0452B6 CD C1 52 04 0399*  	CALL @one_digit
0452BA 0E F6       0400*  	LD   C,-10
0452BC CD C1 52 04 0401*  	CALL @one_digit
0452C0 48          0402*  	LD   C,B
0452C1             0403*  @one_digit:
0452C1 3E 2F       0404*  	LD   A,'0'-1
0452C3             0405*  @divide_me:
0452C3 3C          0406*  	INC  A
0452C4 09          0407*  	ADD  HL,BC
0452C5 38 FC       0408*  	JR   C,@divide_me
0452C7 ED 42       0409*  	SBC  HL,BC
0452C9 12          0410*  	LD   (DE),A
0452CA 13          0411*  	INC  DE
0452CB C9          0412*  	RET
0452CC             0413*  
0452CC             0414*  print_u24:
0452CC D5          0415*      push de
0452CD E5          0416*      push hl
0452CE 11 7A 52 04 0417*      ld de,_printDecBuffer
0452D2 CD 8A 52 04 0418*      call u24_to_ascii
0452D6 21 7A 52 04 0419*      ld hl,_printDecBuffer
0452DA CD 4F 51 04 0420*      call printString
0452DE 3E 20       0421*      ld a,' '
0452E0 5B D7       0422*      rst.lil 10h
0452E2 E1          0423*      pop hl
0452E3 D1          0424*      pop de
0452E4 C9          0425*      ret
0452E5             0426*  
0452E5             0427*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0452E5             0428*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0452E5             0429*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0452E5             0430*  u168_to_ascii:
0452E5             0431*  ; add a leading space to make room for sign flag if needed
0452E5 3E 20       0432*      ld a,' '
0452E7 12          0433*      ld (de),a
0452E8 13          0434*      inc de
0452E9             0435*  ; Convert integer part
0452E9 E5          0436*      push hl               ; Save HL (we’ll need the fractional part later)
0452EA CD 37 61 04 0437*      call hlu_udiv256    ; Shift to get integer portion in HL
0452EE 01 F0 D8 FF 0438*      ld   bc, -10000
0452F2 CD 15 53 04 0439*      call @one_int
0452F6 01 18 FC FF 0440*      ld   bc, -1000
0452FA CD 15 53 04 0441*      call @one_int
0452FE 01 9C FF FF 0442*      ld   bc, -100
045302 CD 15 53 04 0443*      call @one_int
045306 0E F6       0444*      ld   c, -10
045308 CD 15 53 04 0445*      call @one_int
04530C 48          0446*      ld   c, b
04530D CD 15 53 04 0447*      call @one_int
045311 C3 20 53 04 0448*      jp   @frac            ; Jump to fractional part conversion
045315             0449*  @one_int:
045315 3E 2F       0450*      ld   a, '0' - 1       ; Start ASCII character at '0'
045317             0451*  @divide_me:
045317 3C          0452*      inc  a
045318 09          0453*      add  hl, bc           ; Accumulate until overflow
045319 38 FC       0454*      jr   c, @divide_me
04531B ED 42       0455*      sbc  hl, bc           ; Remove excess after overflow
04531D 12          0456*      ld   (de), a          ; Store ASCII digit
04531E 13          0457*      inc  de
04531F C9          0458*      ret
045320             0459*  ; Convert fractional part
045320             0460*  @frac:
045320 3E 2E       0461*      ld   a, '.'           ; Decimal point
045322 12          0462*      ld   (de), a
045323 13          0463*      inc  de
045324 E1          0464*      pop  hl               ; Restore HL with original fraction
045325 06 03       0465*      ld   b, 3             ; Loop counter for 3 fractional digits
045327             0466*  @frac_loop:
045327 26 0A       0467*      ld   h, 10            ; Load multiplier for fractional part
045329 ED 6C       0468*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
04532B 3E 30       0469*      ld   a, '0'
04532D 84          0470*      add  a, h             ; Convert integer part to ASCII
04532E 12          0471*      ld   (de), a
04532F 13          0472*      inc  de
045330 10 F5       0473*      djnz @frac_loop       ; Repeat for each fractional digit
045332             0474*  ; Add null terminator
045332 AF          0475*      xor  a                ; Null terminator
045333 12          0476*      ld   (de), a
045334 C9          0477*      ret
045335             0478*  
045335             0479*  print_u168:
045335 D5          0480*      push de
045336 E5          0481*      push hl
045337 11 7A 52 04 0482*      ld de,_printDecBuffer
04533B CD E5 52 04 0483*      call u168_to_ascii
04533F 21 7A 52 04 0484*      ld hl,_printDecBuffer
045343 CD 4F 51 04 0485*      call printString
045347 E1          0486*      pop hl
045348 D1          0487*      pop de
045349 C9          0488*      ret
04534A             0489*  
04534A             0490*  ; signed version of u168_to_ascii
04534A             0491*  s168_to_ascii:
04534A D5          0492*      push de ; save starting address of buffer
04534B CD D0 60 04 0493*      call hlu_abs
04534F F5          0494*      push af ; save sign flag
045350 CD E5 52 04 0495*      call u168_to_ascii
045354 F1          0496*      pop af ; restore sign flag
045355 D1          0497*      pop de ; restore starting address of buffer
045356 F0          0498*      ret p ; hlu was positive so nothing to do
045357 3E 2D       0499*      ld a,'-'
045359 12          0500*      ld (de),a
04535A C9          0501*      ret
04535B             0502*  
04535B             0503*  print_s168:
04535B D5          0504*      push de
04535C E5          0505*      push hl
04535D 11 7A 52 04 0506*      ld de,_printDecBuffer
045361 CD 4A 53 04 0507*      call s168_to_ascii
045365 21 7A 52 04 0508*      ld hl,_printDecBuffer
045369 CD 4F 51 04 0509*      call printString
04536D E1          0510*      pop hl
04536E D1          0511*      pop de
04536F C9          0512*      ret
045370             0513*  
045370             0514*  print_s168_hl:
045370 F5          0515*      push af
045371 E5          0516*      push hl
045372 CD 5B 53 04 0517*      call print_s168
045376 3E 20       0518*      ld a,' '
045378 5B D7       0519*      rst.lil 10h
04537A E1          0520*      pop hl
04537B F1          0521*      pop af
04537C C9          0522*      ret
04537D             0523*  
04537D             0524*  print_s168_bc:
04537D F5          0525*      push af
04537E C5          0526*      push bc
04537F E5          0527*      push hl
045380 C5          0528*      push bc
045381 E1          0529*      pop hl
045382 CD 5B 53 04 0530*      call print_s168
045386 3E 20       0531*      ld a,' '
045388 5B D7       0532*      rst.lil 10h
04538A E1          0533*      pop hl
04538B C1          0534*      pop bc
04538C F1          0535*      pop af
04538D C9          0536*      ret
04538E             0537*  
04538E             0538*  print_s168_de:
04538E F5          0539*      push af
04538F D5          0540*      push de
045390 E5          0541*      push hl
045391 EB          0542*      ex de,hl
045392 CD 5B 53 04 0543*      call print_s168
045396 3E 20       0544*      ld a,' '
045398 5B D7       0545*      rst.lil 10h
04539A E1          0546*      pop hl
04539B D1          0547*      pop de
04539C F1          0548*      pop af
04539D C9          0549*      ret
04539E             0550*  
04539E             0551*  print_s168_hl_bc_de:
04539E F5          0552*      push af
04539F C5          0553*      push bc
0453A0 D5          0554*      push de
0453A1 E5          0555*      push hl
0453A2 CD 5B 53 04 0556*      call print_s168
0453A6 3E 20       0557*      ld a,' '
0453A8 5B D7       0558*      rst.lil 10h
0453AA C5          0559*      push bc
0453AB E1          0560*      pop hl
0453AC CD 5B 53 04 0561*      call print_s168
0453B0 3E 20       0562*      ld a,' '
0453B2 5B D7       0563*      rst.lil 10h
0453B4 EB          0564*      ex de,hl
0453B5 CD 5B 53 04 0565*      call print_s168
0453B9 3E 20       0566*      ld a,' '
0453BB 5B D7       0567*      rst.lil 10h
0453BD E1          0568*      pop hl
0453BE D1          0569*      pop de
0453BF C1          0570*      pop bc
0453C0 F1          0571*      pop af
0453C1 C9          0572*      ret
0453C2             0573*  
0453C2             0574*  print_s168_bc_de:
0453C2 F5          0575*      push af
0453C3 C5          0576*      push bc
0453C4 D5          0577*      push de
0453C5 C5          0578*      push bc
0453C6 E1          0579*      pop hl
0453C7 CD 5B 53 04 0580*      call print_s168
0453CB 3E 20       0581*      ld a,' '
0453CD 5B D7       0582*      rst.lil 10h
0453CF EB          0583*      ex de,hl
0453D0 CD 5B 53 04 0584*      call print_s168
0453D4 3E 20       0585*      ld a,' '
0453D6 5B D7       0586*      rst.lil 10h
0453D8 E1          0587*      pop hl
0453D9 D1          0588*      pop de
0453DA C1          0589*      pop bc
0453DB F1          0590*      pop af
0453DC C9          0591*      ret
0453DD             0592*  
0453DD             0593*  print_s168_a:
0453DD F5          0594*      push af
0453DE C5          0595*      push bc
0453DF E5          0596*      push hl
0453E0 21 00 00 00 0597*      ld hl,0
0453E4 6F          0598*      ld l,a
0453E5 CD 70 53 04 0599*      call print_s168_hl
0453E9 E1          0600*      pop hl
0453EA C1          0601*      pop bc
0453EB F1          0602*      pop af
0453EC C9          0603*      ret
0453ED             0604*  
0453ED             0605*  ; #### new functions added by Brandon R. Gates ####
0453ED             0606*  
0453ED             0607*  ; print the binary representation of the 8-bit value in a
0453ED             0608*  ; destroys a, hl, bc
0453ED             0609*  printBin8:
0453ED 06 08       0610*      ld b,8      ; loop counter for 8 bits
0453EF 21 0A 54 04 0611*      ld hl,@cmd  ; set hl to the low byte of the output string
0453F3             0612*                  ; (which will be the high bit of the value in a)
0453F3             0613*  @loop:
0453F3 07          0614*      rlca ; put the next highest bit into carry
0453F4 38 04       0615*      jr c,@one
0453F6 36 30       0616*      ld (hl),'0'
0453F8 18 02       0617*      jr @next_bit
0453FA             0618*  @one:
0453FA 36 31       0619*      ld (hl),'1'
0453FC             0620*  @next_bit:
0453FC 23          0621*      inc hl
0453FD 10 F4       0622*      djnz @loop
0453FF             0623*  ; print it
0453FF 21 0A 54 04 0624*  	ld hl,@cmd
045403 01 08 00 00 0625*  	ld bc,@end-@cmd
045407 5B DF       0626*  	rst.lil $18
045409 C9          0627*  	ret
04540A             0628*  @cmd: ds 8 ; eight bytes for eight bits
045412             0629*  @end:
045412             0630*  
045412             0631*  ; print the binary representation of the 8-bit value in a
045412             0632*  ; in reverse order (lsb first)
045412             0633*  ; destroys a, hl, bc
045412             0634*  printBin8Rev:
045412 06 08       0635*      ld b,8      ; loop counter for 8 bits
045414 21 2F 54 04 0636*      ld hl,@cmd  ; set hl to the low byte of the output string
045418             0637*                  ; (which will be the high bit of the value in a)
045418             0638*  @loop:
045418 0F          0639*      rrca ; put the next lowest bit into carry
045419 38 04       0640*      jr c,@one
04541B 36 30       0641*      ld (hl),'0'
04541D 18 02       0642*      jr @next_bit
04541F             0643*  @one:
04541F 36 31       0644*      ld (hl),'1'
045421             0645*  @next_bit:
045421 23          0646*      inc hl
045422 10 F4       0647*      djnz @loop
045424             0648*  ; print it
045424 21 2F 54 04 0649*  	ld hl,@cmd
045428 01 08 00 00 0650*  	ld bc,@end-@cmd
04542C 5B DF       0651*  	rst.lil $18
04542E C9          0652*  	ret
04542F             0653*  @cmd: ds 8 ; eight bytes for eight bits
045437             0654*  @end:
045437             0655*  
045437             0656*  ; print registers to screen in hexidecimal format
045437             0657*  ; inputs: none
045437             0658*  ; outputs: values of every register printed to screen
045437             0659*  ;    values of each register in global scratch memory
045437             0660*  ; destroys: nothing
045437             0661*  stepRegistersHex:
045437             0662*  ; store everything in scratch
045437 22 77 56 04 0663*      ld (uhl),hl
04543B ED 43 7A 56 0664*      ld (ubc),bc
       04          
045440 ED 53 7D 56 0665*      ld (ude),de
       04          
045445 DD 22 80 56 0666*      ld (uix),ix
       04          
04544A FD 22 83 56 0667*      ld (uiy),iy
       04          
04544F F5          0668*      push af ; fml
045450 E1          0669*      pop hl  ; thanks, zilog
045451 22 74 56 04 0670*      ld (uaf),hl
045455 F5          0671*      push af ; dammit
045456             0672*  
045456             0673*  ; home the cursor
045456             0674*      ; call vdu_home_cursor
045456             0675*  
045456             0676*  ; print each register
045456 21 FA 55 04 0677*      ld hl,str_afu
04545A CD 4F 51 04 0678*      call printString
04545E 2A 74 56 04 0679*      ld hl,(uaf)
045462 CD 6F 51 04 0680*      call printHex24
045466 CD 64 51 04 0681*      call printNewLine
04546A             0682*  
04546A 21 FF 55 04 0683*      ld hl,str_hlu
04546E CD 4F 51 04 0684*      call printString
045472 2A 77 56 04 0685*      ld hl,(uhl)
045476 CD 6F 51 04 0686*      call printHex24
04547A CD 64 51 04 0687*      call printNewLine
04547E             0688*  
04547E 21 04 56 04 0689*      ld hl,str_bcu
045482 CD 4F 51 04 0690*      call printString
045486 2A 7A 56 04 0691*      ld hl,(ubc)
04548A CD 6F 51 04 0692*      call printHex24
04548E CD 64 51 04 0693*      call printNewLine
045492             0694*  
045492 21 09 56 04 0695*      ld hl,str_deu
045496 CD 4F 51 04 0696*      call printString
04549A 2A 7D 56 04 0697*      ld hl,(ude)
04549E CD 6F 51 04 0698*      call printHex24
0454A2 CD 64 51 04 0699*      call printNewLine
0454A6             0700*  
0454A6 21 0E 56 04 0701*      ld hl,str_ixu
0454AA CD 4F 51 04 0702*      call printString
0454AE 2A 80 56 04 0703*      ld hl,(uix)
0454B2 CD 6F 51 04 0704*      call printHex24
0454B6 CD 64 51 04 0705*      call printNewLine
0454BA             0706*  
0454BA 21 13 56 04 0707*      ld hl,str_iyu
0454BE CD 4F 51 04 0708*      call printString
0454C2 2A 83 56 04 0709*      ld hl,(uiy)
0454C6 CD 6F 51 04 0710*      call printHex24
0454CA CD 64 51 04 0711*      call printNewLine
0454CE             0712*  
0454CE             0713*      ; call vsync
0454CE             0714*  
0454CE CD 64 51 04 0715*      call printNewLine
0454D2             0716*  
0454D2             0717*  ; check for right shift key and quit if pressed
0454D2             0718*  	MOSCALL mos_getkbmap
0454D2 3E 1E       0001*M 			LD	A, function
0454D4 49 CF       0002*M 			RST.LIS	08h
0454D6             0719*  @stayhere:
0454D6             0720*  ; 7 RightShift
0454D6 DD CB 00 76 0721*      bit 6,(ix+0)
0454DA 20 02       0722*      jr nz,@RightShift
0454DC 18 F8       0723*      jr @stayhere
0454DE             0724*  @RightShift:
0454DE DD CB 0E 86 0725*      res 0,(ix+14) ; debounce the key (hopefully)
0454E2 3E 80       0726*      ld a,%10000000
0454E4             0727*      ; call multiPurposeDelay
0454E4             0728*  
0454E4             0729*  ; restore everything
0454E4 2A 77 56 04 0730*      ld hl, (uhl)
0454E8 ED 4B 7A 56 0731*      ld bc, (ubc)
       04          
0454ED ED 5B 7D 56 0732*      ld de, (ude)
       04          
0454F2 DD 2A 80 56 0733*      ld ix, (uix)
       04          
0454F7 FD 2A 83 56 0734*      ld iy, (uiy)
       04          
0454FC F1          0735*      pop af
0454FD             0736*  ; all done
0454FD C9          0737*      ret
0454FE             0738*  
0454FE             0739*  ; print registers to screen in hexidecimal format
0454FE             0740*  ; inputs: none
0454FE             0741*  ; outputs: values of every register printed to screen
0454FE             0742*  ;    values of each register in global scratch memory
0454FE             0743*  ; destroys: nothing
0454FE             0744*  dumpRegistersHex:
0454FE             0745*  ; store everything in scratch
0454FE 22 77 56 04 0746*      ld (uhl),hl
045502 ED 43 7A 56 0747*      ld (ubc),bc
       04          
045507 ED 53 7D 56 0748*      ld (ude),de
       04          
04550C DD 22 80 56 0749*      ld (uix),ix
       04          
045511 FD 22 83 56 0750*      ld (uiy),iy
       04          
045516 F5          0751*      push af ; fml
045517 E1          0752*      pop hl  ; thanks, zilog
045518 22 74 56 04 0753*      ld (uaf),hl
04551C F5          0754*      push af ; dammit
04551D             0755*  
04551D             0756*  ; home the cursor
04551D             0757*      ; call vdu_home_cursor
04551D             0758*      ; call printNewLine
04551D             0759*  
04551D             0760*  ; print each register
04551D 21 FA 55 04 0761*      ld hl,str_afu
045521 CD 4F 51 04 0762*      call printString
045525 2A 74 56 04 0763*      ld hl,(uaf)
045529 CD 6F 51 04 0764*      call printHex24
04552D             0765*      ; call printNewLine
04552D             0766*  
04552D 21 FF 55 04 0767*      ld hl,str_hlu
045531 CD 4F 51 04 0768*      call printString
045535 2A 77 56 04 0769*      ld hl,(uhl)
045539 CD 6F 51 04 0770*      call printHex24
04553D             0771*      ; call printNewLine
04553D             0772*  
04553D 21 04 56 04 0773*      ld hl,str_bcu
045541 CD 4F 51 04 0774*      call printString
045545 2A 7A 56 04 0775*      ld hl,(ubc)
045549 CD 6F 51 04 0776*      call printHex24
04554D             0777*      ; call printNewLine
04554D             0778*  
04554D 21 09 56 04 0779*      ld hl,str_deu
045551 CD 4F 51 04 0780*      call printString
045555 2A 7D 56 04 0781*      ld hl,(ude)
045559 CD 6F 51 04 0782*      call printHex24
04555D             0783*      ; call printNewLine
04555D             0784*  
04555D 21 0E 56 04 0785*      ld hl,str_ixu
045561 CD 4F 51 04 0786*      call printString
045565 2A 80 56 04 0787*      ld hl,(uix)
045569 CD 6F 51 04 0788*      call printHex24
04556D             0789*      ; call printNewLine
04556D             0790*  
04556D 21 13 56 04 0791*      ld hl,str_iyu
045571 CD 4F 51 04 0792*      call printString
045575 2A 83 56 04 0793*      ld hl,(uiy)
045579 CD 6F 51 04 0794*      call printHex24
04557D             0795*      ; call printNewLine
04557D             0796*  
04557D             0797*      ; call vdu_vblank
04557D             0798*  
04557D CD 64 51 04 0799*      call printNewLine
045581             0800*  ; restore everything
045581 2A 77 56 04 0801*      ld hl, (uhl)
045585 ED 4B 7A 56 0802*      ld bc, (ubc)
       04          
04558A ED 5B 7D 56 0803*      ld de, (ude)
       04          
04558F DD 2A 80 56 0804*      ld ix, (uix)
       04          
045594 FD 2A 83 56 0805*      ld iy, (uiy)
       04          
045599 F1          0806*      pop af
04559A             0807*  ; all done
04559A C9          0808*      ret
04559B             0809*  
04559B             0810*  dumpRegistersHexPrime:
04559B D9          0811*      exx
04559C 08          0812*      ex af,af'
04559D CD FE 54 04 0813*      call dumpRegistersHex
0455A1 08          0814*      ex af,af'
0455A2 D9          0815*      exx
0455A3 C9          0816*      ret
0455A4             0817*  
0455A4             0818*  ; additionally dump prime registers
0455A4             0819*  ; inputs: none
0455A4             0820*  ; outputs: values of every register printed to screen
0455A4             0821*  ; destroys: nothing
0455A4             0822*  dumpRegistersHexAll:
0455A4 CD FE 54 04 0823*      call dumpRegistersHex
0455A8 08          0824*      ex af,af'
0455A9 D9          0825*      exx
0455AA CD FE 54 04 0826*      call dumpRegistersHex
0455AE 08          0827*      ex af,af'
0455AF D9          0828*      exx
0455B0 C9          0829*      ret
0455B1             0830*  
0455B1             0831*  ; print hlu to screen in hexidecimal format
0455B1             0832*  ; inputs: none
0455B1             0833*  ; destroys: nothing
0455B1             0834*  print_hex_hl:
0455B1 F5          0835*      push af
0455B2 E5          0836*      push hl
0455B3 21 FF 55 04 0837*      ld hl,str_hlu
0455B7 CD 4F 51 04 0838*      call printString
0455BB E1          0839*      pop hl
0455BC E5          0840*      push hl
0455BD CD 6F 51 04 0841*      call printHex24
0455C1 3E 20       0842*      ld a,' '
0455C3 5B D7       0843*      rst.lil 10h
0455C5 E1          0844*      pop hl
0455C6 F1          0845*      pop af
0455C7 C9          0846*      ret
0455C8             0847*  
0455C8             0848*  ; print bcu to screen in hexidecimal format
0455C8             0849*  ; inputs: none
0455C8             0850*  ; destroys: nothing
0455C8             0851*  print_hex_bc:
0455C8 F5          0852*      push af
0455C9 E5          0853*      push hl
0455CA C5          0854*      push bc
0455CB 21 04 56 04 0855*      ld hl,str_bcu
0455CF CD 4F 51 04 0856*      call printString
0455D3 E1          0857*      pop hl
0455D4 E5          0858*      push hl
0455D5 CD 6F 51 04 0859*      call printHex24
0455D9 3E 20       0860*      ld a,' '
0455DB 5B D7       0861*      rst.lil 10h
0455DD C1          0862*      pop bc
0455DE E1          0863*      pop hl
0455DF F1          0864*      pop af
0455E0 C9          0865*      ret
0455E1             0866*  
0455E1             0867*  ; print deu to screen in hexidecimal format
0455E1             0868*  ; inputs: none
0455E1             0869*  ; destroys: nothing
0455E1             0870*  print_hex_de:
0455E1 F5          0871*      push af
0455E2 E5          0872*      push hl
0455E3 D5          0873*      push de
0455E4 21 09 56 04 0874*      ld hl,str_deu
0455E8 CD 4F 51 04 0875*      call printString
0455EC E1          0876*      pop hl
0455ED E5          0877*      push hl
0455EE CD 6F 51 04 0878*      call printHex24
0455F2 3E 20       0879*      ld a,' '
0455F4 5B D7       0880*      rst.lil 10h
0455F6 D1          0881*      pop de
0455F7 E1          0882*      pop hl
0455F8 F1          0883*      pop af
0455F9 C9          0884*      ret
0455FA             0885*  
0455FA 20 61 66 3D 0886*  str_afu: db " af=",0
       00          
0455FF 20 68 6C 3D 0887*  str_hlu: db " hl=",0
       00          
045604 20 62 63 3D 0888*  str_bcu: db " bc=",0
       00          
045609 20 64 65 3D 0889*  str_deu: db " de=",0
       00          
04560E 20 69 78 3D 0890*  str_ixu: db " ix=",0
       00          
045613 20 69 79 3D 0891*  str_iyu: db " iy=",0
       00          
045618             0892*  
045618             0893*  ; print udeuhl to screen in hexidecimal format
045618             0894*  ; inputs: none
045618             0895*  ; outputs: concatenated hexidecimal udeuhl
045618             0896*  ; destroys: nothing
045618             0897*  dumpUDEUHLHex:
045618             0898*  ; store everything in scratch
045618 22 77 56 04 0899*      ld (uhl),hl
04561C ED 43 7A 56 0900*      ld (ubc),bc
       04          
045621 ED 53 7D 56 0901*      ld (ude),de
       04          
045626 DD 22 80 56 0902*      ld (uix),ix
       04          
04562B FD 22 83 56 0903*      ld (uiy),iy
       04          
045630 F5          0904*      push af
045631             0905*  
045631             0906*  ; print each register
045631             0907*  
045631 21 6B 56 04 0908*      ld hl,str_udeuhl
045635 CD 4F 51 04 0909*      call printString
045639 2A 7D 56 04 0910*      ld hl,(ude)
04563D CD 6F 51 04 0911*      call printHex24
045641 3E 2E       0912*  	ld a,'.'	; print a dot to separate the values
045643 5B D7       0913*  	rst.lil 10h
045645 2A 77 56 04 0914*      ld hl,(uhl)
045649 CD 6F 51 04 0915*      call printHex24
04564D CD 64 51 04 0916*      call printNewLine
045651             0917*  
045651             0918*  ; restore everything
045651 2A 77 56 04 0919*      ld hl, (uhl)
045655 ED 4B 7A 56 0920*      ld bc, (ubc)
       04          
04565A ED 5B 7D 56 0921*      ld de, (ude)
       04          
04565F DD 2A 80 56 0922*      ld ix, (uix)
       04          
045664 FD 2A 83 56 0923*      ld iy, (uiy)
       04          
045669 F1          0924*      pop af
04566A             0925*  ; all done
04566A C9          0926*      ret
04566B             0927*  
04566B 75 64 65 2E 0928*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
045674             0929*  
045674             0930*  ; global scratch memory for registers
045674 00 00 00    0931*  uaf: dl 0
045677 00 00 00    0932*  uhl: dl 0
04567A 00 00 00    0933*  ubc: dl 0
04567D 00 00 00    0934*  ude: dl 0
045680 00 00 00    0935*  uix: dl 0
045683 00 00 00    0936*  uiy: dl 0
045686 00 00 00    0937*  usp: dl 0
045689 00 00 00    0938*  upc: dl 0
04568C             0939*  
04568C             0940*  ; inputs: whatever is in the flags register
04568C             0941*  ; outputs: binary representation of flags
04568C             0942*  ;          with a header so we know which is what
04568C             0943*  ; destroys: nothing
04568C             0944*  ; preserves: everything
04568C             0945*  dumpFlags:
04568C             0946*  ; first we curse zilog for not giving direct access to flags
04568C F5          0947*      push af ; this is so we can send it back unharmed
04568D F5          0948*      push af ; this is so we can pop it to hl
04568E             0949*  ; store everything in scratch
04568E 22 77 56 04 0950*      ld (uhl),hl
045692 ED 43 7A 56 0951*      ld (ubc),bc
       04          
045697 ED 53 7D 56 0952*      ld (ude),de
       04          
04569C DD 22 80 56 0953*      ld (uix),ix
       04          
0456A1 FD 22 83 56 0954*      ld (uiy),iy
       04          
0456A6             0955*  ; next we print the header
0456A6 21 D2 56 04 0956*      ld hl,@header
0456AA CD 4F 51 04 0957*      call printString
0456AE E1          0958*      pop hl ; flags are now in l
0456AF 7D          0959*      ld a,l ; flags are now in a
0456B0 CD ED 53 04 0960*      call printBin8
0456B4 CD 64 51 04 0961*  	call printNewLine
0456B8             0962*  ; restore everything
0456B8 2A 77 56 04 0963*      ld hl, (uhl)
0456BC ED 4B 7A 56 0964*      ld bc, (ubc)
       04          
0456C1 ED 5B 7D 56 0965*      ld de, (ude)
       04          
0456C6 DD 2A 80 56 0966*      ld ix, (uix)
       04          
0456CB FD 2A 83 56 0967*      ld iy, (uiy)
       04          
0456D0 F1          0968*      pop af ; send her home the way she came
0456D1 C9          0969*      ret
0456D2             0970*  ; Bit 7 (S): Sign flag
0456D2             0971*  ; Bit 6 (Z): Zero flag
0456D2             0972*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0456D2             0973*  ; Bit 4 (H): Half Carry flag
0456D2             0974*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0456D2             0975*  ; Bit 2 (PV): Parity/Overflow flag
0456D2             0976*  ; Bit 1 (N): Subtract flag
0456D2             0977*  ; Bit 0 (C): Carry flag
0456D2 53 5A 78 48 0978*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0456DD             0979*  
0456DD             0980*  ; set all the bits in the flag register
0456DD             0981*  ; more of an academic exercise than anything useful
0456DD             0982*  ; inputs; none
0456DD             0983*  ; outputs; a=0,f=255
0456DD             0984*  ; destroys: flags, hl
0456DD             0985*  ; preserves: a, because why not
0456DD             0986*  setAllFlags:
0456DD 21 FF 00 00 0987*      ld hl,255
0456E1 67          0988*      ld h,a ; four cycles to preserve a is cheap
0456E2 E5          0989*      push hl
0456E3 F1          0990*      pop af
0456E4 C9          0991*      ret
0456E5             0992*  
0456E5             0993*  ; reset all the bits in the flag register
0456E5             0994*  ; unlike its inverse counterpart, this may actually be useful
0456E5             0995*  ; inputs; none
0456E5             0996*  ; outputs; a=0,f=0
0456E5             0997*  ; destroys: flags, hl
0456E5             0998*  ; preserves: a, because why not
0456E5             0999*  resetAllFlags:
0456E5 21 00 00 00 1000*      ld hl,0
0456E9 67          1001*      ld h,a ; four cycles to preserve a is cheap
0456EA E5          1002*      push hl
0456EB F1          1003*      pop af
0456EC C9          1004*      ret
0456ED             1005*  
0456ED             1006*  ; wait until user presses a key
0456ED             1007*  ; inputs: none
0456ED             1008*  ; outputs: ascii code of key pressed in a
0456ED             1009*  ; destroys: af,ix
0456ED             1010*  waitKeypress:
0456ED             1011*      MOSCALL mos_getkey
0456ED 3E 00       0001*M 			LD	A, function
0456EF 49 CF       0002*M 			RST.LIS	08h
0456F1 C9          1012*      ret
0456F2             1013*  
0456F2             1014*  ; print bytes from an address to the screen in hexidecimal format
0456F2             1015*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0456F2             1016*  ; outputs: values of each byte printed to screen separated by spaces
0456F2             1017*  ; destroys: nothing
0456F2             1018*  dumpMemoryHex:
0456F2             1019*  ; save registers to the stack
0456F2 C5          1020*      push bc
0456F3 E5          1021*      push hl
0456F4 F5          1022*      push af
0456F5             1023*  
0456F5             1024*  ; print the address and separator
0456F5 CD 6F 51 04 1025*      call printHex24
0456F9 3E 3A       1026*      ld a,':'
0456FB 5B D7       1027*      rst.lil 10h
0456FD 3E 20       1028*      ld a,' '
0456FF 5B D7       1029*      rst.lil 10h
045701             1030*  
045701             1031*  ; set b to be our loop counter
045701 F1          1032*      pop af
045702 47          1033*      ld b,a
045703 E1          1034*      pop hl
045704 E5          1035*      push hl
045705 F5          1036*      push af
045706             1037*  @loop:
045706             1038*  ; print the byte
045706 7E          1039*      ld a,(hl)
045707 CD 7D 51 04 1040*      call printHex8
04570B             1041*  ; print a space
04570B 3E 20       1042*      ld a,' '
04570D 5B D7       1043*      rst.lil 10h
04570F 23          1044*      inc hl
045710 10 F4       1045*      djnz @loop
045712 CD 64 51 04 1046*      call printNewLine
045716             1047*  
045716             1048*  ; restore everything
045716 F1          1049*      pop af
045717 E1          1050*      pop hl
045718 C1          1051*      pop bc
045719             1052*  
045719             1053*  ; all done
045719 C9          1054*      ret
04571A             1055*  
04571A             1056*  
04571A             1057*  ; print bytes from an address to the screen in binary format
04571A             1058*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04571A             1059*  ; outputs: values of each byte printed to screen separated by spaces
04571A             1060*  ; destroys: nothing
04571A             1061*  dumpMemoryBin:
04571A             1062*  ; save all registers to the stack
04571A F5          1063*      push af
04571B C5          1064*      push bc
04571C D5          1065*      push de
04571D E5          1066*      push hl
04571E DD E5       1067*      push ix
045720 FD E5       1068*      push iy
045722             1069*  
045722             1070*  ; set b to be our loop counter
045722 47          1071*      ld b,a
045723             1072*  @loop:
045723             1073*  ; print the byte
045723 7E          1074*      ld a,(hl)
045724 E5          1075*      push hl
045725 C5          1076*      push bc
045726 CD ED 53 04 1077*      call printBin8
04572A C1          1078*      pop bc
04572B             1079*  ; print a space
04572B 3E 20       1080*      ld a,' '
04572D 5B D7       1081*      rst.lil 10h
04572F E1          1082*      pop hl
045730 23          1083*      inc hl
045731 10 F0       1084*      djnz @loop
045733 CD 64 51 04 1085*      call printNewLine
045737             1086*  
045737             1087*  ; restore everything
045737 FD E1       1088*      pop iy
045739 DD E1       1089*      pop ix
04573B E1          1090*      pop hl
04573C D1          1091*      pop de
04573D C1          1092*      pop bc
04573E F1          1093*      pop af
04573F             1094*  ; all done
04573F C9          1095*      ret
045740             1096*  
045740             1097*  ; print bytes from an address to the screen in binary format
045740             1098*  ; with the bits of each byte in reverse order (lsb first)
045740             1099*  ; inputs: hl = address of first byte to print, a = number of bytes to print
045740             1100*  ; outputs: values of each byte printed to screen separated by spaces
045740             1101*  ; destroys: nothing
045740             1102*  dumpMemoryBinRev:
045740             1103*  ; save all registers to the stack
045740 F5          1104*      push af
045741 C5          1105*      push bc
045742 D5          1106*      push de
045743 E5          1107*      push hl
045744 DD E5       1108*      push ix
045746 FD E5       1109*      push iy
045748             1110*  
045748             1111*  ; set b to be our loop counter
045748 47          1112*      ld b,a
045749             1113*  @loop:
045749             1114*  ; print the byte
045749 7E          1115*      ld a,(hl)
04574A E5          1116*      push hl
04574B C5          1117*      push bc
04574C CD 12 54 04 1118*      call printBin8Rev
045750 C1          1119*      pop bc
045751             1120*  ; print a space
045751 3E 20       1121*      ld a,' '
045753 5B D7       1122*      rst.lil 10h
045755 E1          1123*      pop hl
045756 23          1124*      inc hl
045757 10 F0       1125*      djnz @loop
045759 CD 64 51 04 1126*      call printNewLine
04575D             1127*  
04575D             1128*  ; restore everything
04575D FD E1       1129*      pop iy
04575F DD E1       1130*      pop ix
045761 E1          1131*      pop hl
045762 D1          1132*      pop de
045763 C1          1133*      pop bc
045764 F1          1134*      pop af
045765             1135*  ; all done
045765 C9          1136*      ret
045766             0055       include "vdu.inc"
045766             0001*  
045766             0002*  ; VDU 30: Home cursor
045766             0003*  vdu_home_cursor:
045766 3E 1E       0004*      ld a,30
045768 5B D7       0005*  	rst.lil $10
04576A C9          0006*  	ret
04576B             0007*  
04576B             0008*  vdu_cursor_on:
04576B 21 76 57 04 0009*  	ld hl,@cmd
04576F 01 03 00 00 0010*  	ld bc,@end-@cmd
045773 5B DF       0011*  	rst.lil $18
045775 C9          0012*  	ret
045776             0013*  @cmd:
045776 17 01 01    0014*  	db 23,1,1
045779             0015*  @end:
045779             0016*  
045779             0017*  vdu_cursor_off:
045779 21 84 57 04 0018*  	ld hl,@cmd
04577D 01 03 00 00 0019*  	ld bc,@end-@cmd
045781 5B DF       0020*  	rst.lil $18
045783 C9          0021*  	ret
045784             0022*  @cmd:
045784 17 01 00    0023*  	db 23,1,0
045787             0024*  @end:
045787             0025*  
045787             0026*  ; VDU 5: Write text at graphics cursor
045787             0027*  ; inputs: a is the character to write to the screen
045787             0028*  ; prerequisites: the graphics cursor at the intended position on screen
045787             0029*  ; outputs: see the name of the function
045787             0030*  ; destroys: a, hl, bc
045787             0031*  vdu_char_to_gfx_cursor:
045787 32 97 57 04 0032*  	ld (@arg),a
04578B 21 96 57 04 0033*  	ld hl,@cmd
04578F 01 02 00 00 0034*  	ld bc,@end-@cmd
045793 5B DF       0035*  	rst.lil $18
045795 C9          0036*  	ret
045796 05          0037*  @cmd: db 5
045797 00          0038*  @arg: db 0
045798             0039*  @end:
045798             0040*  ; VDU 9: Move cursor forward one character
045798             0041*  vdu_cursor_forward:
045798 3E 09       0042*      ld a,9
04579A 5B D7       0043*  	rst.lil $10
04579C C9          0044*  	ret
04579D             0045*  
04579D             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04579D             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
04579D             0048*  vdu_move_cursor:
04579D ED 43 AE 57 0049*      ld (@x0),bc
       04          
0457A2 21 AD 57 04 0050*  	ld hl,@cmd
0457A6 01 03 00 00 0051*  	ld bc,@end-@cmd
0457AA 5B DF       0052*  	rst.lil $18
0457AC C9          0053*  	ret
0457AD 1F          0054*  @cmd: 	db 31
0457AE 00          0055*  @x0:	db 0
0457AF 00          0056*  @y0: 	db 0
0457B0 00          0057*  @end: 	db 0 ; padding
0457B1             0058*  
0457B1             0059*  ; VDU 12: Clear text area (CLS)
0457B1             0060*  vdu_cls:
0457B1 3E 0C       0061*      ld a,12
0457B3 5B D7       0062*  	rst.lil $10
0457B5 C9          0063*  	ret
0457B6             0064*  
0457B6             0065*  vdu_flip:
0457B6 21 C1 57 04 0066*  	ld hl,@cmd
0457BA 01 03 00 00 0067*  	ld bc,@end-@cmd
0457BE 5B DF       0068*  	rst.lil $18
0457C0 C9          0069*  	ret
0457C1 17 00 C3    0070*  @cmd: db 23,0,0xC3
0457C4             0071*  @end:
0457C4             0072*  
0457C4             0073*  ; VDU 16: Clear graphics area (CLG)
0457C4             0074*  vdu_clg:
0457C4 3E 10       0075*      ld a,16
0457C6 5B D7       0076*  	rst.lil $10
0457C8 C9          0077*  	ret
0457C9             0078*  
0457C9             0079*  ; COLOUR MODES
0457C9             0080*  ; Mode	Effect
0457C9             0081*  ; 0	Set on-screen pixel to target colour value
0457C9             0082*  ; 1	OR value with the on-screen pixel
0457C9             0083*  ; 2	AND value with the on-screen pixel
0457C9             0084*  ; 3	XOR value with the on-screen pixel
0457C9             0085*  ; 4	Invert the on-screen pixel
0457C9             0086*  ; 5	No operation
0457C9             0087*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0457C9             0088*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0457C9             0089*  
0457C9             0090*  ; VDU 17, colour: Define text colour (COLOUR)
0457C9             0091*  vdu_colour_text:
0457C9 32 D9 57 04 0092*  	ld (@arg),a
0457CD 21 D8 57 04 0093*  	ld hl,@cmd
0457D1 01 02 00 00 0094*  	ld bc,@end-@cmd
0457D5 5B DF       0095*  	rst.lil $18
0457D7 C9          0096*  	ret
0457D8 11          0097*  @cmd: db 17
0457D9 00          0098*  @arg: db 0
0457DA             0099*  @end:
0457DA             0100*  
0457DA             0101*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0457DA             0102*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0457DA             0103*  vdu_gcol:
0457DA 32 EF 57 04 0104*  	ld (@mode),a
0457DE 79          0105*      ld a,c
0457DF 32 F0 57 04 0106*      ld (@col),a
0457E3 21 EE 57 04 0107*  	ld hl,@cmd
0457E7 01 03 00 00 0108*  	ld bc,@end-@cmd
0457EB 5B DF       0109*  	rst.lil $18
0457ED C9          0110*  	ret
0457EE 12          0111*  @cmd:  db 18
0457EF 00          0112*  @mode: db 0
0457F0 00          0113*  @col:  db 0
0457F1             0114*  @end:
0457F1             0115*  
0457F1             0116*  
0457F1             0117*  ; VDU 28, left, bottom, right, top: Set text viewport **
0457F1             0118*  ; MIND THE LITTLE-ENDIANESS
0457F1             0119*  ; inputs: c=left,b=bottom,e=right,d=top
0457F1             0120*  ; outputs; nothing
0457F1             0121*  ; destroys: a might make it out alive
0457F1             0122*  vdu_set_txt_viewport:
0457F1 ED 43 07 58 0123*      ld (@lb),bc
       04          
0457F6 ED 53 09 58 0124*  	ld (@rt),de
       04          
0457FB 21 06 58 04 0125*  	ld hl,@cmd
0457FF 01 05 00 00 0126*  	ld bc,@end-@cmd
045803 5B DF       0127*  	rst.lil $18
045805 C9          0128*  	ret
045806 1C          0129*  @cmd:   db 28 ; set text viewport command
045807 00 00       0130*  @lb: 	dw 0x0000 ; set by bc
045809 00 00       0131*  @rt: 	dw 0x0000 ; set by de
04580B 00          0132*  @end:   db 0x00	  ; padding
04580C             0133*  
04580C             0134*  ; Wait for VBLANK interrupt
04580C             0135*  vdu_vblank:
04580C DD E5       0136*      PUSH 	IX
04580E             0137*  	MOSCALL	mos_sysvars
04580E 3E 08       0001*M 			LD	A, function
045810 49 CF       0002*M 			RST.LIS	08h
045812 DD 7E 00    0138*  	LD	A, (IX + sysvar_time + 0)
045815             0139*  @wait:
045815 DD BE 00    0140*      CP 	A, (IX + sysvar_time + 0)
045818 28 FB       0141*      JR	Z, @wait
04581A DD E1       0142*      POP	IX
04581C C9          0143*      RET
04581D             0144*  
04581D             0145*  ; VDU 29, x; y;: Set graphics origin
04581D             0146*  ; This command sets the graphics origin.
04581D             0147*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04581D             0148*  ; inputs: bc=x0,de=y0
04581D             0149*  ; outputs; nothing
04581D             0150*  ; destroys: a might make it out alive
04581D             0151*  vdu_set_gfx_origin:
04581D ED 43 33 58 0152*      ld (@x0),bc
       04          
045822 ED 53 35 58 0153*      ld (@y0),de
       04          
045827 21 32 58 04 0154*      ld hl,@cmd
04582B 01 05 00 00 0155*      ld bc,@end-@cmd
04582F 5B DF       0156*      rst.lil $18
045831 C9          0157*      ret
045832 1D          0158*  @cmd:   db 29 ; set graphics origin command
045833 00 00       0159*  @x0: 	dw 0x0000 ; set by bc
045835 00 00       0160*  @y0: 	dw 0x0000 ; set by de
045837 00          0161*  @end:   db 0x00	  ; padding
045838             0162*  
045838             0163*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
045838             0164*  ; NOTE: the order of the y-coordinate parameters are inverted
045838             0165*  ; 	because we have turned off logical screen scaling
045838             0166*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
045838             0167*  ; outputs; nothing
045838             0168*  ; destroys: a might make it out alive
045838             0169*  vdu_set_gfx_viewport:
045838 ED 43 58 58 0170*      ld (@x0),bc
       04          
04583D FD 22 5A 58 0171*      ld (@y1),iy
       04          
045842 DD 22 5C 58 0172*  	ld (@x1),ix
       04          
045847 ED 53 5E 58 0173*  	ld (@y0),de
       04          
04584C 21 57 58 04 0174*  	ld hl,@cmd
045850 01 09 00 00 0175*  	ld bc,@end-@cmd
045854 5B DF       0176*  	rst.lil $18
045856 C9          0177*  	ret
045857 18          0178*  @cmd:   db 24 ; set graphics viewport command
045858 00 00       0179*  @x0: 	dw 0x0000 ; set by bc
04585A 00 00       0180*  @y1: 	dw 0x0000 ; set by iy
04585C 00 00       0181*  @x1: 	dw 0x0000 ; set by ix
04585E 00 00       0182*  @y0: 	dw 0x0000 ; set by de
045860 00          0183*  @end:   db 0x00	  ; padding
045861             0184*  
045861             0185*  ; SCREEN MODES
045861             0186*  ; ===============================
045861             0187*  ; Mode  Horz  Vert  Cols  Refresh
045861             0188*  ; ---   ----  ----  ----  -------
045861             0189*  ; 11    320   240   2     60hz
045861             0190*  ; 139   320   240   2     60hz
045861             0191*  ; 23    512   384   2     60hz
045861             0192*  ; 151   512   384   2     60hz
045861             0193*  ; 6     640   240   2     60hz
045861             0194*  ; 134   640   240   2     60hz
045861             0195*  ; 2     640   480   2     60hz
045861             0196*  ; 130   640   480   2     60hz
045861             0197*  ; 17    800   600   2     60hz
045861             0198*  ; 145   800   600   2     60hz
045861             0199*  ; 18    1024  768   2     60hz
045861             0200*  ; 146   1024  768   2     60hz
045861             0201*  ; ---   ----  ----  ----  -------
045861             0202*  ; 10    320   240   4     60hz
045861             0203*  ; 138   320   240   4     60hz
045861             0204*  ; 22    512   384   4     60hz
045861             0205*  ; 150   512   384   4     60hz
045861             0206*  ; 5     640   240   4     60hz
045861             0207*  ; 133   640   240   4     60hz
045861             0208*  ; 1     640   480   4     60hz
045861             0209*  ; 129   640   480   4     60hz
045861             0210*  ; 16    800   600   4     60hz
045861             0211*  ; 19    1024  768   4     60hz
045861             0212*  ; ---   ----  ----  ----  -------
045861             0213*  ; 9     320   240   16    60hz
045861             0214*  ; 137   320   240   16    60hz
045861             0215*  ; 21    512   384   16    60hz
045861             0216*  ; 149   512   384   16    60hz
045861             0217*  ; 4     640   240   16    60hz
045861             0218*  ; 132   640   240   16    60hz
045861             0219*  ; 0     640   480   16    60hz
045861             0220*  ; 7     n/a   n/a   16    60hz
045861             0221*  ; ---   ----  ----  ----  -------
045861             0222*  ; 8     320   240   64    60hz
045861             0223*  ; 136   320   240   64    60hz
045861             0224*  ; 20    512   384   64    60hz
045861             0225*  ; 3     640   240   64    60hz
045861             0226*  ; ---   ----  ----  ----  -------
045861             0227*  vdu_set_screen_mode:
045861 32 71 58 04 0228*  	ld (@arg),a
045865 21 70 58 04 0229*  	ld hl,@cmd
045869 01 02 00 00 0230*  	ld bc,@end-@cmd
04586D 5B DF       0231*  	rst.lil $18
04586F C9          0232*  	ret
045870 16          0233*  @cmd: db 22 ; set screen mode
045871 00          0234*  @arg: db 0  ; screen mode parameter
045872             0235*  @end:
045872             0236*  
045872             0237*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
045872             0238*  ; inputs: a is scaling mode, 1=on, 0=off
045872             0239*  ; note: default setting on boot is scaling ON
045872             0240*  vdu_set_scaling:
045872 32 84 58 04 0241*  	ld (@arg),a
045876 21 81 58 04 0242*  	ld hl,@cmd
04587A 01 04 00 00 0243*  	ld bc,@end-@cmd
04587E 5B DF       0244*  	rst.lil $18
045880 C9          0245*  	ret
045881 17 00 C0    0246*  @cmd: db 23,0,0xC0
045884 00          0247*  @arg: db 0  ; scaling on/off
045885             0248*  @end:
045885             0249*  
045885             0250*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045885             0251*  ; inputs: hl=bufferId
045885             0252*  vdu_buff_select:
045885 22 97 58 04 0253*  	ld (@bufferId),hl
045889 21 94 58 04 0254*  	ld hl,@cmd
04588D 01 05 00 00 0255*  	ld bc,@end-@cmd
045891 5B DF       0256*  	rst.lil $18
045893 C9          0257*  	ret
045894 17 1B 20    0258*  @cmd: db 23,27,0x20
045897 00 00       0259*  @bufferId: dw 0x0000
045899 00          0260*  @end: db 0x00 ; padding
04589A             0261*  
04589A             0262*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04589A             0263*  ; inputs: a=format; bc=width; de=height
04589A             0264*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04589A             0265*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04589A             0266*  ; 0 	RGBA8888 (4-bytes per pixel)
04589A             0267*  ; 1 	RGBA2222 (1-bytes per pixel)
04589A             0268*  ; 2 	Mono/Mask (1-bit per pixel)
04589A             0269*  ; 3 	Reserved for internal use by VDP (“native” format)
04589A             0270*  vdu_bmp_create:
04589A ED 43 B6 58 0271*      ld (@width),bc
       04          
04589F ED 53 B8 58 0272*      ld (@height),de
       04          
0458A4 32 BA 58 04 0273*      ld (@fmt),a
0458A8 21 B3 58 04 0274*  	ld hl,@cmd
0458AC 01 08 00 00 0275*  	ld bc,@end-@cmd
0458B0 5B DF       0276*  	rst.lil $18
0458B2 C9          0277*  	ret
0458B3 17 1B 21    0278*  @cmd:       db 23,27,0x21
0458B6 00 00       0279*  @width:     dw 0x0000
0458B8 00 00       0280*  @height:    dw 0x0000
0458BA 00          0281*  @fmt:       db 0x00
0458BB             0282*  @end:
0458BB             0283*  
0458BB             0284*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0458BB             0285*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0458BB             0286*  vdu_load_img_rgba2_to_8:
0458BB             0287*  ; backup the target buffer id and image dimensions
0458BB E5          0288*      push hl
0458BC D5          0289*      push de
0458BD C5          0290*      push bc
0458BE             0291*  ; load the rgba2 image to working buffer 65534
0458BE 21 FE FF 00 0292*      ld hl,65534 ; temporary working buffer id
0458C2 CD C5 59 04 0293*  	call vdu_load_buffer_from_file
0458C6             0294*  ; restore the image dimensions and target buffer id
0458C6 C1          0295*      pop bc
0458C7 D1          0296*      pop de
0458C8 E1          0297*      pop hl
0458C9             0298*  ; fall through to vdu_rgba2_to_8
0458C9             0299*  
0458C9             0300*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0458C9             0301*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0458C9             0302*  ; the "expand bitmap" command is:
0458C9             0303*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0458C9             0304*  ; and then to reverse the byte order to fix endian-ness:
0458C9             0305*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0458C9             0306*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0458C9             0307*  ; VDU 23,27,&20,targetBufferID%;
0458C9             0308*  ; VDU 23,27,&21,width%;height%;0
0458C9             0309*  ; -------------------------------------------------------------------
0458C9             0310*  ; inputs: bc,de image width,height ; hl = targetBufferId
0458C9             0311*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0458C9             0312*  vdu_rgba2_to_8:
0458C9             0313*  ; load the image dimensions and buffer id parameters
0458C9 ED 43 25 59 0314*      ld (@width),bc
       04          
0458CE ED 53 27 59 0315*      ld (@height),de
       04          
0458D3 22 0A 59 04 0316*      ld (@bufferId0),hl
0458D7 22 17 59 04 0317*      ld (@bufferId2),hl
0458DB 22 20 59 04 0318*      ld (@bufferId1),hl
0458DF             0319*  ; clean up bytes that got stomped on by the ID loads
0458DF 3E 48       0320*      ld a,0x48
0458E1 32 0C 59 04 0321*      ld (@bufferId0+2),a
0458E5 3E 17       0322*      ld a,23
0458E7 32 22 59 04 0323*      ld (@bufferId1+2),a
0458EB 3E 18       0324*      ld a,24
0458ED 32 19 59 04 0325*      ld (@bufferId2+2),a
0458F1 AF          0326*      xor a
0458F2 32 29 59 04 0327*      ld (@height+2),a
0458F6             0328*  ; send the vdu command strings
0458F6 21 01 59 04 0329*      ld hl,@beg
0458FA 01 29 00 00 0330*      ld bc,@end-@beg
0458FE 5B DF       0331*      rst.lil $18
045900 C9          0332*      ret
045901             0333*  @beg:
045901             0334*  ; Command 14: Consolidate blocks in a buffer
045901             0335*  ; VDU 23, 0, &A0, bufferId; 14
045901 17 00 A0    0336*      db 23,0,0xA0
045904 FE FF       0337*      dw 65534 ; workingBufferId
045906 0E          0338*      db 14 ; consolidate blocks
045907             0339*  ; the "expand bitmap" command is:
045907             0340*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
045907 17 00 A0    0341*      db 23,0,0xA0
04590A 00 00       0342*  @bufferId0: dw 0x0000 ; targetBufferId
04590C 48          0343*      db 0x48 ; given as decimal command 72 in the docs
04590D 02          0344*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04590E FE FF       0345*      dw 65534 ; sourceBufferId
045910 00 7F BF FF 0346*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
045914             0347*  ; reverse the byte order to fix endian-ness:
045914             0348*  ; Command 24: Reverse the order of data of blocks within a buffer
045914             0349*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045914             0350*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
045914 17 00 A0    0351*      db 23,0,0xA0
045917 00 00       0352*  @bufferId2:    dw 0x0000 ; targetBufferId
045919 18          0353*      db 24 ; reverse byte order
04591A 04          0354*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04591B 04 00       0355*      dw 4 ; size (4 bytes)
04591D             0356*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04591D             0357*  ; VDU 23,27,&20,targetBufferID%;
04591D 17 1B 20    0358*      db 23,27,0x20 ; select bitmap
045920 00 00       0359*  @bufferId1: dw 0x0000 ; targetBufferId
045922             0360*  ; VDU 23,27,&21,width%;height%;0
045922 17 1B 21    0361*      db 23,27,0x21 ; create bitmap from buffer
045925 00 00       0362*  @width: dw 0x0000
045927 00 00       0363*  @height: dw 0x0000
045929 00          0364*      db 0x00 ; rgba8888 format
04592A             0365*  @end:
04592A             0366*  
04592A             0367*  ; scratch variables
04592A 00 00 00    0368*  bufferId0: dl 0x000000
04592D 00 00 00    0369*  bufferId1: dl 0x000000
045930             0370*  
045930             0371*  ; load a vdu buffer from local memory
045930             0372*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
045930             0373*  vdu_load_buffer:
045930 ED 43 59 59 0374*      ld (@length),bc
       04          
045935 D5          0375*      push de ; save data pointer
045936             0376*  ; send the vdu command string
045936 7D          0377*      ld a,l
045937 32 56 59 04 0378*      ld (@bufferId),a
04593B 7C          0379*      ld a,h
04593C 32 57 59 04 0380*      ld (@bufferId+1),a
045940 21 53 59 04 0381*      ld hl,@cmd
045944 01 08 00 00 0382*      ld bc,@end-@cmd
045948 5B DF       0383*      rst.lil $18
04594A             0384*  ; send the buffer data
04594A E1          0385*      pop hl ; pointer to data
04594B ED 4B 59 59 0386*      ld bc,(@length)
       04          
045950 5B DF       0387*      rst.lil $18 ; send it
045952 C9          0388*      ret
045953             0389*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045953 17 00 A0    0390*  @cmd:       db 23,0,0xA0
045956 00 00       0391*  @bufferId:	dw 0x0000
045958 00          0392*  		    db 0 ; load buffer
045959 00 00       0393*  @length:	dw 0x0000
04595B 00          0394*  @end: db 0 ; padding
04595C             0395*  
04595C             0396*  ; clear a buffer
04595C             0397*  ; inputs: hl = bufferId
04595C             0398*  vdu_clear_buffer:
04595C 7D          0399*      ld a,l
04595D 32 74 59 04 0400*      ld (@bufferId),a
045961 7C          0401*      ld a,h
045962 32 75 59 04 0402*      ld (@bufferId+1),a
045966 21 71 59 04 0403*      ld hl,@cmd
04596A 01 06 00 00 0404*      ld bc,@end-@cmd
04596E 5B DF       0405*      rst.lil $18
045970 C9          0406*      ret
045971 17 00 A0    0407*  @cmd:       db 23,0,0xA0
045974 00 00       0408*  @bufferId:	dw 0x0000
045976 02          0409*  		    db 2 ; clear buffer
045977             0410*  @end:
045977             0411*  
045977             0412*  vdu_clear_all_buffers:
045977             0413*  ; clear all buffers
045977 21 82 59 04 0414*      ld hl,@beg
04597B 01 06 00 00 0415*      ld bc,@end-@beg
04597F 5B DF       0416*      rst.lil $18
045981 C9          0417*      ret
045982 17 00 A0    0418*  @beg: db 23,0,$A0
045985 FF FF       0419*        dw -1 ; clear all buffers
045987 02          0420*        db 2  ; command 2: clear a buffer
045988             0421*  @end:
045988             0422*  
045988             0423*  ; Command 14: Consolidate blocks in a buffer
045988             0424*  vdu_consolidate_buffer:
045988             0425*  ; set parameters for vdu call
045988 7D          0426*      ld a,l
045989 32 A0 59 04 0427*      ld (@bufferId),a
04598D 7C          0428*      ld a,h
04598E 32 A1 59 04 0429*      ld (@bufferId+1),a
045992 21 9D 59 04 0430*      ld hl,@beg
045996 01 06 00 00 0431*      ld bc,@end-@beg
04599A 5B DF       0432*      rst.lil $18
04599C C9          0433*      ret
04599D             0434*  ; VDU 23, 0, &A0, bufferId; 14
04599D 17 00 A0    0435*  @beg: db 23,0,0xA0
0459A0 00 00       0436*  @bufferId: dw 0x0000
0459A2 0E          0437*             db 14
0459A3             0438*  @end:
0459A3             0439*  
0459A3             0440*  ; load an image file to a buffer and make it a bitmap
0459A3             0441*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0459A3             0442*  vdu_load_img:
0459A3             0443*  ; back up image type and dimension parameters
0459A3 22 2A 59 04 0444*      ld (bufferId0),hl
0459A7 F5          0445*      push af
0459A8 C5          0446*  	push bc
0459A9 D5          0447*  	push de
0459AA             0448*  ; load the image
0459AA CD C5 59 04 0449*  	call vdu_load_buffer_from_file
0459AE             0450*  ; now make it a bitmap
0459AE 2A 2A 59 04 0451*      ld hl,(bufferId0)
0459B2 CD 88 59 04 0452*      call vdu_consolidate_buffer
0459B6 2A 2A 59 04 0453*      ld hl,(bufferId0)
0459BA CD 85 58 04 0454*      call vdu_buff_select
0459BE D1          0455*  	pop de ; image height
0459BF C1          0456*  	pop bc ; image width
0459C0 F1          0457*  	pop af ; image type
0459C1 C3 9A 58 04 0458*  	jp vdu_bmp_create ; will return to caller from there
0459C5             0459*  
0459C5             0460*  ; inputs: hl = bufferId; iy = pointer to filename
0459C5             0461*  vdu_load_buffer_from_file:
0459C5 22 2A 59 04 0462*      ld (bufferId0),hl
0459C9             0463*  
0459C9             0464*  ; clear target buffer
0459C9 CD 5C 59 04 0465*      call vdu_clear_buffer
0459CD             0466*  
0459CD             0467*  ; open the file in read mode
0459CD             0468*  ; Open a file
0459CD             0469*  ; HLU: Filename
0459CD             0470*  ;   C: Mode
0459CD             0471*  ; Returns:
0459CD             0472*  ;   A: Filehandle, or 0 if couldn't open
0459CD FD E5       0473*  	push iy ; pointer to filename
0459CF E1          0474*  	pop hl
0459D0 0E 01       0475*  	ld c,fa_read
0459D2             0476*      MOSCALL mos_fopen
0459D2 3E 0A       0001*M 			LD	A, function
0459D4 49 CF       0002*M 			RST.LIS	08h
0459D6 32 11 5A 04 0477*      ld (@filehandle),a
0459DA             0478*  
0459DA             0479*  @read_file:
0459DA             0480*  ; Read a block of data from a file
0459DA             0481*  ;   C: Filehandle
0459DA             0482*  ; HLU: Pointer to where to write the data to
0459DA             0483*  ; DEU: Number of bytes to read
0459DA             0484*  ; Returns:
0459DA             0485*  ; DEU: Number of bytes read
0459DA 3A 11 5A 04 0486*      ld a,(@filehandle)
0459DE 4F          0487*      ld c,a
0459DF 21 00 E0 B7 0488*      ld hl,filedata
0459E3 11 00 20 00 0489*      ld de,8192 ; max we can read into onboard sram at one time
0459E7             0490*      MOSCALL mos_fread
0459E7 3E 1A       0001*M 			LD	A, function
0459E9 49 CF       0002*M 			RST.LIS	08h
0459EB             0491*  
0459EB             0492*  ; ; DEBUG: print chunk size
0459EB             0493*  ;     push de
0459EB             0494*  ;     pop hl
0459EB             0495*  ;     call printDec
0459EB             0496*  ;     call printNewLine
0459EB             0497*  
0459EB             0498*  ; test de for zero bytes read
0459EB 21 00 00 00 0499*      ld hl,0
0459EF AF          0500*      xor a ; clear carry
0459F0 ED 52       0501*      sbc hl,de
0459F2 CA 08 5A 04 0502*      jp z,@close_file
0459F6             0503*  
0459F6             0504*  ; load a vdu buffer from local memory
0459F6             0505*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0459F6 2A 2A 59 04 0506*      ld hl,(bufferId0)
0459FA D5          0507*      push de ; chunksize
0459FB C1          0508*      pop bc
0459FC 11 00 E0 B7 0509*      ld de,filedata
045A00 CD 30 59 04 0510*      call vdu_load_buffer
045A04             0511*  
045A04             0512*  ; ; print progress breadcrumbs
045A04             0513*  ;     ld a,'.'
045A04             0514*  ;     rst.lil 10h
045A04             0515*  
045A04             0516*  ; read the next block
045A04 C3 DA 59 04 0517*      jp @read_file
045A08             0518*  
045A08             0519*  ; close the file
045A08             0520*  @close_file:
045A08 3A 11 5A 04 0521*      ld a,(@filehandle)
045A0C             0522*      MOSCALL mos_fclose
045A0C 3E 0B       0001*M 			LD	A, function
045A0E 49 CF       0002*M 			RST.LIS	08h
045A10 C9          0523*      ret ; vdu_load_buffer_from_file
045A11             0524*  
045A11 00          0525*  @filehandle: db 0 ; file handle
045A12 00 00 00    0526*  @fil: dl 0 ; pointer to FIL struct
045A15             0527*  
045A15 00 00 00    0528*  @chunkpointer: dl 0 ; pointer to current chunk
045A18             0529*  
045A18             0530*  ; File information structure (FILINFO)
045A18             0531*  @filinfo:
045A18 00 00 00 00 0532*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
045A1C 00 00       0533*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
045A1E 00 00       0534*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
045A20 00          0535*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
045A21 00 00 00 00 0536*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
045A2E 00 00 00 00 0537*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045B2E             0056       include "vdu_buff.inc"
045B2E             0001*  ; VDP Buffered Commands API
045B2E             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
045B2E             0003*  
045B2E             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045B2E             0005*  ; This command is used to store a data block (a sequence of bytes)
045B2E             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
045B2E             0007*  ; It could be a sequence of VDU commands which can be executed
045B2E             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
045B2E             0009*  ; When used for a sequence of VDU commands, this effectively
045B2E             0010*  ; allows for functions or stored procedures to be created.
045B2E             0011*  
045B2E             0012*  ; This is the most common command to use to send data to the VDP.
045B2E             0013*  ; Typically you will call command 2 first to ensure that the
045B2E             0014*  ; buffer is empty, and then make a series of calls to this command
045B2E             0015*  ; to send data to the buffer.
045B2E             0016*  
045B2E             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
045B2E             0018*  ; write to. Writing to the same buffer ID multiple times will add
045B2E             0019*  ; new blocks to that buffer. This allows a buffer to be built up
045B2E             0020*  ; over time, essentially allowing for a command to be sent across
045B2E             0021*  ; to the VDP in multiple separate packets.
045B2E             0022*  
045B2E             0023*  ; Whilst the length of an individual block added using this command
045B2E             0024*  ; is restricted to 65535 bytes (as the largest value that can be
045B2E             0025*  ; sent in a 16-bit number) the total size of a buffer is not
045B2E             0026*  ; restricted to this size, as multiple blocks can be added to a
045B2E             0027*  ; buffer. Given how long it takes to send data to the VDP it is
045B2E             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
045B2E             0029*  ; data or less at a time.
045B2E             0030*  
045B2E             0031*  ; As writing to a single buffer ID is cumulative with this command,
045B2E             0032*  ; care should be taken to ensure that the buffer is cleared out
045B2E             0033*  ; before writing to it.
045B2E             0034*  
045B2E             0035*  ; When building up a complex sequence of commands it is often
045B2E             0036*  ; advisable to use multiple blocks within a buffer. Typically
045B2E             0037*  ; this is easier to code, as otherwise working out exactly how
045B2E             0038*  ; many bytes long a command sequence is can be can be onerously
045B2E             0039*  ; difficult. It is also easier to modify a command sequences that
045B2E             0040*  ; are broken up into multiple blocks.
045B2E             0041*  
045B2E             0042*  ; As mentioned above it is advisable to send large pieces of data,
045B2E             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
045B2E             0044*  ; each packet of data sent to a buffer, the user can then perform
045B2E             0045*  ; other operations, such as updating the screen to indicate
045B2E             0046*  ; progress. This allows for long-running operations to be performed
045B2E             0047*  ; without blocking the screen, and larger amounts of data to be
045B2E             0048*  ; transferred over to the VDP than may otherwise be practical given
045B2E             0049*  ; the limitations of the eZ80.
045B2E             0050*  
045B2E             0051*  ; If a buffer ID of 65535 is used then this command will be
045B2E             0052*  ; ignored, and the data discarded. This is because this buffer ID
045B2E             0053*  ; is reserved for special functions.
045B2E             0054*  
045B2E             0055*  ; Using buffers for bitmaps
045B2E             0056*  
045B2E             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
045B2E             0058*  ; they cannot be used if they are spread over multiple blocks.
045B2E             0059*  ; To use a bitmap its data must be in a single contiguous block,
045B2E             0060*  ; and this is achieved by using the “consolidate” command &0E.
045B2E             0061*  
045B2E             0062*  ; Once you have a block that is ready to be used for a bitmap,
045B2E             0063*  ; the buffer must be selected, and then a bitmap created for that
045B2E             0064*  ; buffer using the bitmap and sprites API. This is done with the
045B2E             0065*  ; following commands:
045B2E             0066*  
045B2E             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
045B2E             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
045B2E             0069*  
045B2E             0070*  ; Until the “create bitmap” call has been made the buffer cannot
045B2E             0071*  ; be used as a bitmap. That is because the system needs to
045B2E             0072*  ; understand the dimensions of the bitmap, as well as the format
045B2E             0073*  ; of the data. Usually this only needs to be done once. The format
045B2E             0074*  ; is given as an 8-bit value, with the following values supported:
045B2E             0075*  ; Value 	Type 	Description
045B2E             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
045B2E             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
045B2E             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
045B2E             0079*  
045B2E             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
045B2E             0081*  ; and these are automatically stored in buffers numbered 64000-64255
045B2E             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
045B2E             0083*  ; simply a matter of adding 64000. All bitmaps created with that
045B2E             0084*  ; API will be RGBA8888 format.
045B2E             0085*  
045B2E             0086*  ; There is one other additional call added to the bitmap and
045B2E             0087*  ; sprites API, which allows for bitmaps referenced with a
045B2E             0088*  ; buffer ID to be added to sprites. This is done with the
045B2E             0089*  ; following command:
045B2E             0090*  
045B2E             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
045B2E             0092*  
045B2E             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
045B2E             0094*  
045B2E             0095*  ; It should be noted that it is possible to modify the buffer
045B2E             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
045B2E             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
045B2E             0098*  ; can allow you to do things such as changing colours in a bitmap,
045B2E             0099*  ; or flipping an image horizontally or vertically. This will even
045B2E             0100*  ; work on bitmaps that are being used inside sprites.
045B2E             0101*  
045B2E             0102*  ; Using commands targetting a buffer that create new blocks,
045B2E             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
045B2E             0104*  ; and remove it from use.
045B2E             0105*  
045B2E             0106*  ; Using buffers for sound samples
045B2E             0107*  
045B2E             0108*  ; Much like with bitmaps, it is advisable to send samples over
045B2E             0109*  ; to the VDP in multiple blocks for the same reasons.
045B2E             0110*  
045B2E             0111*  ; In contrast to bitmaps, the sound system can play back samples
045B2E             0112*  ; that are spread over multiple blocks, so there is no need to
045B2E             0113*  ; consolidate buffers. As a result of this, the sample playback
045B2E             0114*  ; system is also more tolerant of modifications being made to
045B2E             0115*  ; the buffer after a sample has been created from it, even if
045B2E             0116*  ; the sample is currently playing. It should be noted that
045B2E             0117*  ; splitting a buffer may result in unexpected behaviour if
045B2E             0118*  ; the sample is currently playing, such as skipping to other
045B2E             0119*  ; parts of the sample.
045B2E             0120*  
045B2E             0121*  ; Once you have a buffer that contains block(s) that are ready
045B2E             0122*  ; to be used for a sound sample, the following command must be
045B2E             0123*  ; used to indicate that a sample should be created from that buffer:
045B2E             0124*  
045B2E             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
045B2E             0126*  
045B2E             0127*  ; The format parameter is an 8-bit value that indicates the
045B2E             0128*  ; format of the sample data. The following values are supported:
045B2E             0129*  ; Value 	Description
045B2E             0130*  ; 0 	8-bit signed, 16KHz
045B2E             0131*  ; 1 	8-bit unsigned, 16KHz
045B2E             0132*  
045B2E             0133*  ; Once a sample has been created in this way, the sample can
045B2E             0134*  ; be selected for use on a channel using the following command:
045B2E             0135*  
045B2E             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
045B2E             0137*  
045B2E             0138*  ; Samples uploaded using the existing “load sample” command
045B2E             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
045B2E             0140*  ; are also stored in buffers automatically. A sample number using this system is in
045B2E             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
045B2E             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
045B2E             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
045B2E             0144*  ; buffer 64257, and so on.
045B2E             0145*  ; Command 1: Call a buffer
045B2E             0146*  
045B2E             0147*  ; VDU 23, 0 &A0, bufferId; 1
045B2E             0148*  
045B2E             0149*  ; This command will attempt to execute all of the commands
045B2E             0150*  ; stored in the buffer with the given ID. If the buffer does
045B2E             0151*  ; not exist, or is empty, then this command will do nothing.
045B2E             0152*  
045B2E             0153*  ; Essentially, this command passes the contents of the buffer
045B2E             0154*  ; to the VDP’s VDU command processor system, and executes them
045B2E             0155*  ; as if they were sent directly to the VDP.
045B2E             0156*  
045B2E             0157*  ; As noted against command 0, it is possible to build up a
045B2E             0158*  ; buffer over time by sending across multiple commands to write
045B2E             0159*  ; to the same buffer ID. When calling a buffer with multiple
045B2E             0160*  ; blocks, the blocks are executed in order.
045B2E             0161*  
045B2E             0162*  ; Care should be taken when using this command within a buffer,
045B2E             0163*  ; as it is possible to create an infinite loop. For instance,
045B2E             0164*  ; if a buffer contains a command to call itself, then this will
045B2E             0165*  ; result in an infinite loop. This will cause the VDP to hang,
045B2E             0166*  ; and the only way to recover from this is to reset the VDP.
045B2E             0167*  
045B2E             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
045B2E             0169*  ; to be executed. This can be useful for creating loops within
045B2E             0170*  ; a buffer. It will be ignored if used outside of a buffered
045B2E             0171*  ; command sequence.
045B2E             0172*  
045B2E             0173*  ; Command 2: Clear a buffer
045B2E             0174*  ; VDU 23, 0 &A0, bufferId; 2
045B2E             0175*  
045B2E             0176*  ; This command will clear the buffer with the given ID. If
045B2E             0177*  ; the buffer does not exist then this command will do nothing.
045B2E             0178*  
045B2E             0179*  ; Please note that this clears out all of the blocks sent to
045B2E             0180*  ; a buffer via command 0, not just the last one. i.e. if you
045B2E             0181*  ; have built up a buffer over time by sending multiple commands
045B2E             0182*  ; to write to the same buffer ID, this command will clear out
045B2E             0183*  ; all of those commands.
045B2E             0184*  
045B2E             0185*  ; Calling this command with a bufferId value of -1 (65535) will
045B2E             0186*  ; clear out all buffers.
045B2E             0187*  
045B2E             0188*  ; Command 3: Create a writeable buffer
045B2E             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
045B2E             0190*  ; This command will create a new writeable buffer with the given
045B2E             0191*  ; ID. If a buffer with the given ID already exists then this
045B2E             0192*  ; command will do nothing. This command is primarily intended
045B2E             0193*  ; for use to create a buffer that can be used to capture output
045B2E             0194*  ; using the “set output stream” command (see below), or to store
045B2E             0195*  ; data that can be used for other commands.
045B2E             0196*  
045B2E             0197*  ; It is generally quite rare that you will want to use this
045B2E             0198*  ; command. Typically you will instead want to use command 0
045B2E             0199*  ; to write data to a buffer. It is not necessary to use this
045B2E             0200*  ; command before using command 0, and indeed doing so will
045B2E             0201*  ; lead to errors as you will end up with two blocks in the
045B2E             0202*  ; buffer, the first of which will be empty. If you do wish
045B2E             0203*  ; to use this command to create a buffer for data and then
045B2E             0204*  ; write to it, you would need to use operation 2 of command 5,
045B2E             0205*  ; the “set” operation in the “buffer adjust” command, to set a
045B2E             0206*  ; sequence of bytes in the buffer to the data you want to write.
045B2E             0207*  ; This is not recommended, as it is much easier to just use
045B2E             0208*  ; command 0 to write a data block to a buffer.
045B2E             0209*  
045B2E             0210*  ; This new buffer will be a single empty single block upon
045B2E             0211*  ; creation, containing zeros.
045B2E             0212*  
045B2E             0213*  ; The length parameter is a 16-bit integer that specifies
045B2E             0214*  ; the maximum size of the buffer. This is the maximum number
045B2E             0215*  ; of bytes that can be stored in the buffer. If the buffer
045B2E             0216*  ; is full then no more data can be written to it, and subsequent
045B2E             0217*  ; writes will be ignored.
045B2E             0218*  
045B2E             0219*  ; After creating a buffer with this command it is possible to
045B2E             0220*  ; use command 0 to write further blocks to the buffer, however
045B2E             0221*  ; this is probably not advisable.
045B2E             0222*  
045B2E             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
045B2E             0224*  ; values have special meanings for writable buffers. See command 4.
045B2E             0225*  
045B2E             0226*  ; Command 4: Set output stream to a buffer
045B2E             0227*  ; VDU 23, 0 &A0, bufferId; 4
045B2E             0228*  
045B2E             0229*  ; Sets then current output stream to the buffer with the given ID.
045B2E             0230*  ; With two exceptions, noted below, this needs to be a writable
045B2E             0231*  ; buffer created with command 3. If the buffer does not exist,
045B2E             0232*  ; or the first block within the buffer is not writable, then
045B2E             0233*  ; this command will do nothing.
045B2E             0234*  
045B2E             0235*  ; Following this command, any subsequent VDU commands that send
045B2E             0236*  ; response packets will have those packets written to the specified
045B2E             0237*  ; output buffer. This allows the user to capture the response
045B2E             0238*  ; packets from a command sent to the VDP.
045B2E             0239*  
045B2E             0240*  ; By default, the output stream (for the main VDU command processor)
045B2E             0241*  ; is the communications channel from the VDP to MOS running on the
045B2E             0242*  ; eZ80.
045B2E             0243*  
045B2E             0244*  ; Passing a buffer ID of -1 (65535) to this command will
045B2E             0245*  ; remove/detach the output buffer. From that point onwards,
045B2E             0246*  ; any subsequent VDU commands that send response packets will
045B2E             0247*  ; have those responses discarded/ignored.
045B2E             0248*  
045B2E             0249*  ; Passing a buffer ID of 0 to this command will set the output
045B2E             0250*  ; buffer back to its original value for the current command stream.
045B2E             0251*  ; Typically that will be the communications channel from the VDP to
045B2E             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
045B2E             0253*  ; call has been made.
045B2E             0254*  
045B2E             0255*  ; When used inside a buffered command sequence, this command will
045B2E             0256*  ; only affect the output stream for that sequence of commands, and
045B2E             0257*  ; any other buffered command sequences that are called from within
045B2E             0258*  ; that sequence. Once the buffered command sequence has completed,
045B2E             0259*  ; the output stream will effectively be reset to its original value.
045B2E             0260*  
045B2E             0261*  ; It is strongly recommended to only use this command from within a
045B2E             0262*  ; buffered command sequence. Whilst it is possible to use this
045B2E             0263*  ; command from within a normal VDU command sequence, it is not
045B2E             0264*  ; recommended as it may cause unexpected behaviour. If you do use
045B2E             0265*  ; it in that context, it is very important to remember to restore
045B2E             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
045B2E             0267*  ; future, this command may be disabled from being used outside of
045B2E             0268*  ; a buffered command sequence.)
045B2E             0269*  
045B2E             0270*  ; At present, writable buffers can only be written to until the end
045B2E             0271*  ; of the buffer has been reached; once that happens no more data
045B2E             0272*  ; will be written to the buffer. It is not currently possible to
045B2E             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
045B2E             0274*  ; that the buffer is large enough to capture all of the data that
045B2E             0275*  ; is expected to be written to it. The only current way to “rewind”
045B2E             0276*  ; an output stream would be to clear the buffer and create a new
045B2E             0277*  ; one, and then call set output stream again with the newly created
045B2E             0278*  ; buffer.
045B2E             0279*  
045B2E             0280*  ; Command 5: Adjust buffer contents
045B2E             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
045B2E             0282*  
045B2E             0283*  ; This command will adjust the contents of a buffer, at a given
045B2E             0284*  ; offset. The exact nature of the adjustment will depend on the
045B2E             0285*  ; operation used.
045B2E             0286*  
045B2E             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
045B2E             0288*  ; the contents of the current buffer. This will only work if this
045B2E             0289*  ; command is used within a buffered command sequence, otherwise the
045B2E             0290*  ; command will not do anything.
045B2E             0291*  
045B2E             0292*  ; The basic set of adjustment operations are as follows:
045B2E             0293*  ; Operation 	Description
045B2E             0294*  ; 0 	NOT
045B2E             0295*  ; 1 	Negate
045B2E             0296*  ; 2 	Set value
045B2E             0297*  ; 3 	Add
045B2E             0298*  ; 4 	Add with carry
045B2E             0299*  ; 5 	AND
045B2E             0300*  ; 6 	OR
045B2E             0301*  ; 7 	XOR
045B2E             0302*  
045B2E             0303*  ; All of these operations will modify a byte found at the given
045B2E             0304*  ; offset in the buffer. The only exception to that is the “Add with
045B2E             0305*  ; carry” operation, which will also store the “carry” value in the
045B2E             0306*  ; byte at the next offset. With the exception of NOT and Negate,
045B2E             0307*  ; each command requires an operand value to be specified.
045B2E             0308*  
045B2E             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
045B2E             0310*  ; need to use the NOT operation, and so the following command would
045B2E             0311*  ; be used:
045B2E             0312*  
045B2E             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
045B2E             0314*  
045B2E             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
045B2E             0316*  ; to use the Add operation, and so the following command would be
045B2E             0317*  ; used:
045B2E             0318*  
045B2E             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
045B2E             0320*  
045B2E             0321*  ; When using add with carry, the carry value is stored in the byte
045B2E             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
045B2E             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
045B2E             0324*  ; you would need to use the Add with carry operation, and so the
045B2E             0325*  ; following command would be used:
045B2E             0326*  
045B2E             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
045B2E             0328*  
045B2E             0329*  ; Advanced operations
045B2E             0330*  
045B2E             0331*  ; Whilst these operations are useful, they are not particularly
045B2E             0332*  ; powerful as they only operate one one byte at a time, with a
045B2E             0333*  ; fixed operand value, and potentially cannot reach all bytes in
045B2E             0334*  ; a buffer. To address this, the API supports a number of advanced
045B2E             0335*  ; operations.
045B2E             0336*  
045B2E             0337*  ; The operation value used is an 8-bit value that can have bits
045B2E             0338*  ; set to modify the behaviour of the operation. The following bits
045B2E             0339*  ; are defined:
045B2E             0340*  ; Bit 	Description
045B2E             0341*  ; &10 	Use “advanced” offsets
045B2E             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B2E             0343*  ; &40 	Multiple target values should be adjusted
045B2E             0344*  ; &80 	Multiple operand values should be used
045B2E             0345*  
045B2E             0346*  ; These bits can be combined together to modify the behaviour of
045B2E             0347*  ; the operation.
045B2E             0348*  
045B2E             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
045B2E             0350*  ; offset one byte at a time. When either of the “multiple” variants
045B2E             0351*  ; are used, a 16-bit count must be provided to indicate how many
045B2E             0352*  ; bytes should be altered.
045B2E             0353*  
045B2E             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
045B2E             0355*  ; order, which can allow for buffers that are larger than 64kb
045B2E             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
045B2E             0357*  ; the 16-bit value immediately following the offset is used as a
045B2E             0358*  ; block index number, and the remaining 23-bits of the offset value
045B2E             0359*  ; are used as an offset within that block. When the “advanced”
045B2E             0360*  ; offset mode bit has been set then all offsets associated with
045B2E             0361*  ; this command must be sent as advanced offsets.
045B2E             0362*  
045B2E             0363*  ; The “buffer-fetched value” mode allows for the operand value to
045B2E             0364*  ; be fetched from a buffer. The operand sent as part of the
045B2E             0365*  ; command in this case is a pair of 16-bit values giving the
045B2E             0366*  ; buffer ID and offset to indicate where the actual operand value
045B2E             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
045B2E             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
045B2E             0369*  ; used inside a buffered command sequence. If the advanced offset
045B2E             0370*  ; mode is used, then the operand value is an advanced offset value.
045B2E             0371*  
045B2E             0372*  ; The “multiple target values” mode allows for multiple bytes to
045B2E             0373*  ; be adjusted at once. When this mode is used, the count value
045B2E             0374*  ; must be provided to indicate how many bytes should be adjusted.
045B2E             0375*  ; Unless the “multiple operand values” mode is also used, the
045B2E             0376*  ; operand value is used for all bytes adjusted.
045B2E             0377*  
045B2E             0378*  ; The “multiple operand values” mode allows for multiple operand
045B2E             0379*  ; values to be used. When this mode is used, the count value must
045B2E             0380*  ; be provided to indicate how many operand values should be used.
045B2E             0381*  ; This can allow, for instance, to add together several bytes in a
045B2E             0382*  ; buffer. When this mode is used in conjunction with the “multiple
045B2E             0383*  ; target values” mode, the number of operand values must match the
045B2E             0384*  ; number of target values, and the operation happens one byte at a
045B2E             0385*  ; time.
045B2E             0386*  
045B2E             0387*  ; Some examples of advanced operations are as follows:
045B2E             0388*  
045B2E             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
045B2E             0390*  
045B2E             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
045B2E             0392*  
045B2E             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
045B2E             0394*  ; modifier (&40).
045B2E             0395*  
045B2E             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
045B2E             0397*  
045B2E             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
045B2E             0399*  
045B2E             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
045B2E             0401*  
045B2E             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
045B2E             0403*  
045B2E             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
045B2E             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
045B2E             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
045B2E             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
045B2E             0408*  ; in little-endian order. As the top bit of the offset is set, this
045B2E             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
045B2E             0410*  ; Finally the value to write is sent, 42.
045B2E             0411*  
045B2E             0412*  ; An operation like this could be used to set the position as part
045B2E             0413*  ; of a draw command.
045B2E             0414*  
045B2E             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
045B2E             0416*  ; values 1, 2, 3, 4, 5:
045B2E             0417*  
045B2E             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
045B2E             0419*  ; offset 12 (set it to 0)
045B2E             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
045B2E             0421*  
045B2E             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
045B2E             0423*  ; 7 bytes in buffer 4 starting at offset 42:
045B2E             0424*  
045B2E             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
045B2E             0426*  
045B2E             0427*  ; As we are working on a little-endian system, integers longer
045B2E             0428*  ; than one byte are sent with their least significant byte first.
045B2E             0429*  ; This means that the add with carry operation can be used to add
045B2E             0430*  ; together integers of any size, so long as they are the same size.
045B2E             0431*  ; To do this, both the “multiple target values” and “multiple
045B2E             0432*  ; operand values” modes must be used.
045B2E             0433*  
045B2E             0434*  ; The following commands will add together a 16-bit, 24-bit,
045B2E             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
045B2E             0436*  ; in buffer 3 starting at offset 12, and all using the operand
045B2E             0437*  ; value of 42:
045B2E             0438*  
045B2E             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
045B2E             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
045B2E             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
045B2E             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
045B2E             0443*  
045B2E             0444*  ; Take note of how the operand value is padded out with zeros
045B2E             0445*  ; to match the size of the target value. 42; is used as a base
045B2E             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
045B2E             0447*  ; 16-bits to pad it out to the required size. The “carry” value
045B2E             0448*  ; will be stored at the next offset in the target buffer after
045B2E             0449*  ; the complete target value. So for a 16-bit value, the carry
045B2E             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
045B2E             0451*  ; at offset 15, and so on.
045B2E             0452*  
045B2E             0453*  ; Command 6: Conditionally call a buffer
045B2E             0454*  
045B2E             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
045B2E             0456*  
045B2E             0457*  ; This command will conditionally call a buffer if the condition
045B2E             0458*  ; operation passes. This command works in a similar manner to the
045B2E             0459*  ; “Adjust buffer contents” command.
045B2E             0460*  
045B2E             0461*  ; With this command a buffer ID of 65535 (-1) is always
045B2E             0462*  ; interpretted as “current buffer”, and so can only be used
045B2E             0463*  ; within a buffered command sequence. If used outside of a
045B2E             0464*  ; buffered command sequence then this command will do nothing.
045B2E             0465*  
045B2E             0466*  ; The basic set of condition operations are as follows:
045B2E             0467*  ; Operation 	Description
045B2E             0468*  ; 0 	Exists (value is non-zero)
045B2E             0469*  ; 1 	Not exists (value is zero)
045B2E             0470*  ; 2 	Equal
045B2E             0471*  ; 3 	Not equal
045B2E             0472*  ; 4 	Less than
045B2E             0473*  ; 5 	Greater than
045B2E             0474*  ; 6 	Less than or equal
045B2E             0475*  ; 7 	Greater than or equal
045B2E             0476*  ; 8 	AND
045B2E             0477*  ; 9 	OR
045B2E             0478*  
045B2E             0479*  ; The value that is being checked is fetched from the specified
045B2E             0480*  ; check buffer ID and offset. With the exception of “Exists” and
045B2E             0481*  ; “Not exists”, each command requires an operand value to be
045B2E             0482*  ; specified to check against.
045B2E             0483*  
045B2E             0484*  ; The operation value used is an 8-bit value that can have bits
045B2E             0485*  ; set to modify the behaviour of the operation. The following bits
045B2E             0486*  ; are defined:
045B2E             0487*  ; Bit value 	Description
045B2E             0488*  ; &10 	Use advanced offsets
045B2E             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B2E             0490*  
045B2E             0491*  ; These modifiers can be combined together to modify the behaviour
045B2E             0492*  ; of the operation.
045B2E             0493*  
045B2E             0494*  ; At this time, unlike with the “adjust” command, multiple target
045B2E             0495*  ; values and multiple operand values are not supported. All
045B2E             0496*  ; comparisons are therefore only conducted on single 8-bit values.
045B2E             0497*  ; (If comparisons of 16-bit values are required, multiple calls
045B2E             0498*  ; can be combined.) Support for them may be added in the future.
045B2E             0499*  
045B2E             0500*  ; The AND and OR operations are logical operations, and so the
045B2E             0501*  ; operand value is used as a boolean value. Any non-zero value is
045B2E             0502*  ; considered to be true, and zero is considered to be false. These
045B2E             0503*  ; operations therefore are most useful when used with buffer-fetched
045B2E             0504*  ; operand values (operations &28, &29, &38 and &39).
045B2E             0505*  
045B2E             0506*  ; Some examples of condition operations are as follows:
045B2E             0507*  
045B2E             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
045B2E             0509*  ; (is non-zero):
045B2E             0510*  
045B2E             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B2E             0512*  
045B2E             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
045B2E             0514*  ; exist (is zero):
045B2E             0515*  
045B2E             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B2E             0517*  
045B2E             0518*  ; Combining the above two examples is effectively equivalent to
045B2E             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
045B2E             0520*  
045B2E             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B2E             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B2E             0523*  
045B2E             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
045B2E             0525*  
045B2E             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
045B2E             0527*  
045B2E             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
045B2E             0529*  ; the value in buffer 2 at offset 8:
045B2E             0530*  
045B2E             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
045B2E             0532*  
045B2E             0533*  ; Command 7: Jump to a buffer
045B2E             0534*  
045B2E             0535*  ; VDU 23, 0, &A0, bufferId; 7
045B2E             0536*  
045B2E             0537*  ; This command will jump to the buffer with the given ID. If
045B2E             0538*  ; the buffer does not exist, or is empty, then this command will
045B2E             0539*  ; do nothing.
045B2E             0540*  
045B2E             0541*  ; This essentially works the same as the call command (command 1),
045B2E             0542*  ;  except that it does not return to the caller. This command is
045B2E             0543*  ;  therefore useful for creating loops.
045B2E             0544*  
045B2E             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
045B2E             0546*  ; treated as a “jump to end of current buffer”. This will return
045B2E             0547*  ; execution to the caller, and can be useful for exiting a loop.
045B2E             0548*  
045B2E             0549*  ; ## Command 8: Conditional Jump to a buffer
045B2E             0550*  
045B2E             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
045B2E             0552*  
045B2E             0553*  ; This command operates in a similar manner to the “Conditionally
045B2E             0554*  ; call a buffer” command (command 6), except that it will jump to
045B2E             0555*  ; the buffer if the condition operation passes.
045B2E             0556*  
045B2E             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
045B2E             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
045B2E             0559*  ; Command 9: Jump to an offset in a buffer
045B2E             0560*  
045B2E             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
045B2E             0562*  
045B2E             0563*  ; This command will jump to the given offset in the buffer with the
045B2E             0564*  ; given ID. If the buffer does not exist, or is empty, then this
045B2E             0565*  ; command will do nothing.
045B2E             0566*  
045B2E             0567*  ; The offset in this command is always an “advanced” offset, given
045B2E             0568*  ; as a 24-bit value in little-endian order. As with other uses of
045B2E             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
045B2E             0570*  ; offset value, a block number must also be provided.
045B2E             0571*  
045B2E             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
045B2E             0573*  ; meaning “jump within current buffer”. This can be useful for
045B2E             0574*  ; creating loops within a buffer, or when building up command
045B2E             0575*  ; sequences that may be copied across multiple buffers.
045B2E             0576*  
045B2E             0577*  ; Jumping to an offset that is beyond the end of the buffer is
045B2E             0578*  ; equivalent to jumping to the end of the buffer.
045B2E             0579*  ; Command 10: Conditional jump to an offset in a buffer
045B2E             0580*  
045B2E             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
045B2E             0582*  
045B2E             0583*  ; A conditional jump with an offset works in a similar manner to
045B2E             0584*  ; the “Conditional call a buffer” command (command 6), except that
045B2E             0585*  ; it will jump to the given offset in the buffer if the condition
045B2E             0586*  ; operation passes.
045B2E             0587*  
045B2E             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
045B2E             0589*  ; the offset in this command is always an “advanced” offset, given
045B2E             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
045B2E             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
045B2E             0592*  ; treated as meaning “jump within current buffer”.
045B2E             0593*  ; Command 11: Call buffer with an offset
045B2E             0594*  
045B2E             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
045B2E             0596*  
045B2E             0597*  ; Works just like “Call a buffer” (command 1), except that it also
045B2E             0598*  ; accepts an advanced offset.
045B2E             0599*  
045B2E             0600*  ; Command 12: Conditional call buffer with an offset
045B2E             0601*  
045B2E             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
045B2E             0603*  
045B2E             0604*  ; Works just like the “Conditional call a buffer” command
045B2E             0605*  ; (command 6), except that it also accepts an advanced offset.
045B2E             0606*  
045B2E             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
045B2E             0608*  
045B2E             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
045B2E             0610*  
045B2E             0611*  ; This command will copy the contents of multiple buffers into a
045B2E             0612*  ; single buffer. The buffers to copy from are specified as a list
045B2E             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
045B2E             0614*  ; buffers are copied in the order they are specified.
045B2E             0615*  
045B2E             0616*  ; This is a block-wise copy, so the blocks from the source buffers
045B2E             0617*  ; are copied into the target buffer. The blocks are copied in the
045B2E             0618*  ; order they are found in the source buffers.
045B2E             0619*  
045B2E             0620*  ; The target buffer will be overwritten with the contents of the
045B2E             0621*  ; source buffers. This will not be done however until after all the
045B2E             0622*  ; data has been gathered and copied. The target buffer can therefore
045B2E             0623*  ; included in the list of the source buffers.
045B2E             0624*  
045B2E             0625*  ; If a source buffer that does not exist is specified, or a source
045B2E             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
045B2E             0627*  
045B2E             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
045B2E             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
045B2E             0630*  ; copied multiple times into the target buffer.
045B2E             0631*  
045B2E             0632*  ; If there is insufficient memory available on the VDP to complete
045B2E             0633*  ; this command then it will fail, and the target buffer will be
045B2E             0634*  ; left unchanged.
045B2E             0635*  
045B2E             0636*  
045B2E             0637*  ; Command 14: Consolidate blocks in a buffer
045B2E             0638*  
045B2E             0639*  ; VDU 23, 0, &A0, bufferId; 14
045B2E             0640*  
045B2E             0641*  ; Takes all the blocks in a buffer and consolidates them into a
045B2E             0642*  ; single block. This is useful for bitmaps, as it allows for a
045B2E             0643*  ; bitmap to be built up over time in multiple blocks, and then
045B2E             0644*  ; consolidated into a single block for use as a bitmap.
045B2E             0645*  
045B2E             0646*  ; If there is insufficient memory available on the VDP to complete
045B2E             0647*  ; this command then it will fail, and the buffer will be left
045B2E             0648*  ; unchanged.
045B2E             0649*  
045B2E             0650*  ; Command 15: Split a buffer into multiple blocks
045B2E             0651*  
045B2E             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
045B2E             0653*  
045B2E             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
045B2E             0655*  ; is a 16-bit integer that specifies the target size of each block.
045B2E             0656*  ; If the source data is not a multiple of the block size then the
045B2E             0657*  ; last block will be smaller than the specified block size.
045B2E             0658*  
045B2E             0659*  ; If this command is used on a buffer that is already split into
045B2E             0660*  ; multiple blocks, then the blocks will be consolidated first,
045B2E             0661*  ; and then re-split into the new block size.
045B2E             0662*  
045B2E             0663*  ; If there is insufficient memory available on the VDP to complete
045B2E             0664*  ; this command then it will fail, and the buffer will be left
045B2E             0665*  ; unchanged.
045B2E             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
045B2E             0667*  ; multiple buffers
045B2E             0668*  
045B2E             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B2E             0670*  
045B2E             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
045B2E             0672*  ; then spreads the resultant blocks across the target buffers.
045B2E             0673*  ; The target buffers are specified as a list of buffer IDs,
045B2E             0674*  ; terminated by a buffer ID of -1 (65535).
045B2E             0675*  
045B2E             0676*  ; The blocks are spread across the target buffers in the order
045B2E             0677*  ; they are specified, and the spread will loop around the buffers
045B2E             0678*  ; until all the blocks have been distributed. The target buffers
045B2E             0679*  ; will be cleared out before the blocks are spread across them.
045B2E             0680*  
045B2E             0681*  ; What this means is that if the source buffer is, let’s say,
045B2E             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
045B2E             0683*  ; then we will end up with 10 blocks. If we then spread those
045B2E             0684*  ; blocks across 3 target buffers, then the first buffer will
045B2E             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
045B2E             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
045B2E             0687*  ; blocks 3, 6 and 9.
045B2E             0688*  
045B2E             0689*  ; This command attempts to ensure that, in the event of
045B2E             0690*  ; insufficient memory being available on the VDP to complete
045B2E             0691*  ; the command, it will leave the targets as they were before
045B2E             0692*  ; the command was executed. However this may not always be
045B2E             0693*  ; possible. The first step of this command is to consolidate
045B2E             0694*  ; the source buffer into a single block, and this may fail from
045B2E             0695*  ; insufficient memory. If that happens then all the buffers will
045B2E             0696*  ; be left as they were. After this however the target buffers
045B2E             0697*  ; will be cleared. If there is insufficient memory to successfully
045B2E             0698*  ; split the buffer into multiple blocks then the call will exit,
045B2E             0699*  ; and the target buffers will be left empty.
045B2E             0700*  ; Command 17: Split a buffer and spread across blocks, starting
045B2E             0701*  ; at target buffer ID
045B2E             0702*  
045B2E             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
045B2E             0704*  
045B2E             0705*  ; As per the above two commands, this will split a buffer into
045B2E             0706*  ; multiple blocks. It will then spread the blocks across buffers
045B2E             0707*  ; starting at the target buffer ID, incrementing the target buffer
045B2E             0708*  ; ID until all the blocks have been distributed.
045B2E             0709*  
045B2E             0710*  ; Target blocks will be cleared before a block is stored in them.
045B2E             0711*  ; Each target will contain a single block. The exception to this
045B2E             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
045B2E             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
045B2E             0714*  ; will be placed into buffer 65534.
045B2E             0715*  
045B2E             0716*  ; With this command if there is insufficient memory available on
045B2E             0717*  ; the VDP to complete the command then it will fail, and the target
045B2E             0718*  ; buffers will be left unchanged.
045B2E             0719*  
045B2E             0720*  ; Command 18: Split a buffer into blocks by width
045B2E             0721*  
045B2E             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
045B2E             0723*  
045B2E             0724*  ; This command splits a buffer into a given number of blocks by
045B2E             0725*  ; first of all splitting the buffer into blocks of a given width
045B2E             0726*  ; (number of bytes), and then consolidating those blocks into the
045B2E             0727*  ; given number of blocks.
045B2E             0728*  
045B2E             0729*  ; This is useful for splitting a bitmap into a number of separate
045B2E             0730*  ; columns, which can then be manipulated individually. This can be
045B2E             0731*  ; useful for dealing with sprite sheets.
045B2E             0732*  ; Command 19: Split by width into blocks and spread across target
045B2E             0733*  ; buffers
045B2E             0734*  
045B2E             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B2E             0736*  
045B2E             0737*  ; This command essentially operates the same as command 18, but the
045B2E             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
045B2E             0739*  
045B2E             0740*  ; Command 20: Split by width into blocks and spread across blocks
045B2E             0741*  ; starting at target buffer ID
045B2E             0742*  
045B2E             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
045B2E             0744*  
045B2E             0745*  ; This command essentially operates the same as command 18, but
045B2E             0746*  ; the generated blocks are spread across blocks starting at the
045B2E             0747*  ; target buffer ID, as per command 17.
045B2E             0748*  
045B2E             0749*  ; Command 21: Spread blocks from a buffer across multiple target
045B2E             0750*  ; buffers
045B2E             0751*  
045B2E             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
045B2E             0753*  
045B2E             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
045B2E             0755*  ; The target buffers are specified as a list of buffer IDs,
045B2E             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
045B2E             0757*  ; across the target buffers in the order they are specified, and
045B2E             0758*  ; the spread will loop around the buffers until all the blocks have
045B2E             0759*  ; been distributed.
045B2E             0760*  
045B2E             0761*  ; It should be noted that this command does not copy the blocks,
045B2E             0762*  ; and nor does it move them. Unless the source buffer has been
045B2E             0763*  ; included in the list of targets, it will remain completely
045B2E             0764*  ; intact. The blocks distributed across the target buffers will
045B2E             0765*  ; point to the same memory as the blocks in the source buffer.
045B2E             0766*  ; Operations to modify data in the source buffer will also modify
045B2E             0767*  ; the data in the target buffers. Clearing the source buffer
045B2E             0768*  ; however will not clear the target buffers.
045B2E             0769*  
045B2E             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
045B2E             0771*  ; at target buffer ID
045B2E             0772*  
045B2E             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
045B2E             0774*  
045B2E             0775*  ; Spreads the blocks from a buffer across blocks starting at
045B2E             0776*  ; the target buffer ID.
045B2E             0777*  
045B2E             0778*  ; This essentially works the same as command 21, and the same
045B2E             0779*  ; notes about copying and moving blocks apply. Blocks are spread
045B2E             0780*  ; in the same manner as commands 17 and 20.
045B2E             0781*  
045B2E             0782*  ; Command 23: Reverse the order of blocks in a buffer
045B2E             0783*  
045B2E             0784*  ; VDU 23, 0, &A0, bufferId; 23
045B2E             0785*  
045B2E             0786*  ; Reverses the order of the blocks in a buffer.
045B2E             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
045B2E             0788*  
045B2E             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045B2E             0790*  
045B2E             0791*  ; Reverses the order of the data within the blocks of a buffer.
045B2E             0792*  ; The options parameter is an 8-bit value that can have bits set
045B2E             0793*  ; to modify the behaviour of the operation. The following bits
045B2E             0794*  ; are defined:
045B2E             0795*  ; Bit value 	Description
045B2E             0796*  ; 1 	Values are 16-bits in size
045B2E             0797*  ; 2 	Values are 32-bits in size
045B2E             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
045B2E             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
045B2E             0800*  ; 8 	Reverse blocks
045B2E             0801*  
045B2E             0802*  ; These modifiers can be combined together to modify the behaviour
045B2E             0803*  ; of the operation.
045B2E             0804*  
045B2E             0805*  ; If no value size is set in the options (i.e. the value of the
045B2E             0806*  ; bottom two bits of the options is zero) then the value size is
045B2E             0807*  ; assumed to be 8-bits.
045B2E             0808*  
045B2E             0809*  ; It is probably easiest to understand what this operation is
045B2E             0810*  ; capable of by going through some examples of how it can be used
045B2E             0811*  ; to manipulate bitmaps. The VDP supports two different formats
045B2E             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
045B2E             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
045B2E             0814*  ; pixel.
045B2E             0815*  
045B2E             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
045B2E             0817*  ; degrees, which can be done by just reversing the order of
045B2E             0818*  ; bytes in the buffer:
045B2E             0819*  
045B2E             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
045B2E             0821*  
045B2E             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
045B2E             0823*  ; little more complex, as each pixel is made up of 4 bytes.
045B2E             0824*  ; However with this command it is still a simple operation, as
045B2E             0825*  ; we can just reverse the order of the 32-bit values that make
045B2E             0826*  ; up the bitmap by using an options value of 2:
045B2E             0827*  
045B2E             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
045B2E             0829*  
045B2E             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
045B2E             0831*  ; the order of rows of pixels. To do this we can set a custom
045B2E             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
045B2E             0833*  ; bitmap we can just set a custom value size to our bitmap width:
045B2E             0834*  
045B2E             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
045B2E             0836*  
045B2E             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
045B2E             0838*  ; our width by 4:
045B2E             0839*  
045B2E             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
045B2E             0841*  
045B2E             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
045B2E             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
045B2E             0844*  ; just set a custom chunk size to our bitmap width:
045B2E             0845*  
045B2E             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
045B2E             0847*  
045B2E             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
045B2E             0849*  ; 32-bit values as well as a custom chunk size:
045B2E             0850*  
045B2E             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
045B2E             0852*  
045B2E             0853*  ; Command 25: Copy blocks from multiple buffers by reference
045B2E             0854*  
045B2E             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
045B2E             0856*  
045B2E             0857*  ; This command is essentially a version of command 13 that copies
045B2E             0858*  ; blocks by reference rather than by value. The parameters for
045B2E             0859*  ; this command are the same as for command 13, and the same rules
045B2E             0860*  ; apply.
045B2E             0861*  
045B2E             0862*  ; If the target buffer is included in the list of source buffers
045B2E             0863*  ; then it will be skipped to prevent a reference loop.
045B2E             0864*  
045B2E             0865*  ; Copying by reference means that the blocks in the target buffer
045B2E             0866*  ; will point to the same memory as the blocks in the source
045B2E             0867*  ; buffers. Operations to modify data blocks in the source buffers
045B2E             0868*  ; will therefore also modify those blocks in the target buffer.
045B2E             0869*  ; Clearing the source buffers will not clear the target buffer -
045B2E             0870*  ; it will still point to the original data blocks. Data blocks
045B2E             0871*  ; are only freed from memory when no buffers are left with any
045B2E             0872*  ; references to them.
045B2E             0873*  
045B2E             0874*  ; Buffers that get consolidated become new blocks, so will lose
045B2E             0875*  ; their links to the original blocks, thus after a “consolidate”
045B2E             0876*  ; operation modifications to the original blocks will no longer be
045B2E             0877*  ; reflected in the consolidated buffer.
045B2E             0878*  
045B2E             0879*  ; This command is useful to construct a single buffer from multiple
045B2E             0880*  ; sources without the copy overhead, which can be costly. For
045B2E             0881*  ; example, this can be useful for constructing a bitmap from
045B2E             0882*  ; multiple constituent parts before consolidating it into a
045B2E             0883*  ; single block. In such an example, using command 13 instead
045B2E             0884*  ; would first make a copy of the contents of the source buffers,
045B2E             0885*  ; and then consolidate them into a single block. Using this
045B2E             0886*  ; command does not make that first copy, and so would be faster.
045B2E             0887*  
045B2E             0888*  ; This command is also useful for creating multiple buffers that
045B2E             0889*  ; all point to the same data.
045B2E             0890*  
045B2E             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
045B2E             0892*  
045B2E             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
045B2E             0057       ; include "vdu_plot.inc"
045B2E             0058   	; include "vdu_sprites.inc"
045B2E             0059   	; include "vdp.inc"
045B2E             0060   	; include "div_168_signed.inc"
045B2E             0061   	; include "maths24.inc"
045B2E             0062   ; App-specific includes
045B2E             0063   	include "player.asm"
045B2E             0001*  ; ######## GAME STATE VARIABLES #######
045B2E             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
045B2E 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
045B31             0004*  ; player current shields,binary
045B31             0005*  ; when < 0 player splodes
045B31             0006*  ; restores to player_max_shields when new ship spawns
045B31 10          0007*  player_shields: db 16 ; binary
045B32             0008*  ; max player shields,binary
045B32             0009*  ; can increase with power-ups (todo)
045B32 10          0010*  player_max_shields: db 16 ; binary
045B33             0011*  ; when reaches zero,game ends
045B33             0012*  ; can increase based on TODO
045B33 03          0013*  player_ships: db 0x03 ; binary
045B34             0014*  
045B34             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
045B34             0016*  ; uses the same offsets from its table base as the main sprite table:
045B34             0017*  player_start_variables: ; label marking beginning of table
045B34 04          0018*  player_id:               db table_max_records
045B35 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
045B36 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
045B39 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
045B3C 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
045B3D 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
045B3E 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
045B3F 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
045B42 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
045B45 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045B48 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045B4B 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
045B4E 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
045B51 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
045B54 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
045B55 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
045B56 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
045B57 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
045B58 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
045B59 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
045B5A             0038*  player_end_variables: ; for when we want to traverse this table in reverse
045B5A             0039*  
045B5A             0040*  ; set initial player position
045B5A             0041*  ; inputs: none,everything is hardcoded
045B5A             0042*  ; outputs: player_x/y set to bottom-left corner of screen
045B5A             0043*  ; destroys: a
045B5A             0044*  player_init:
045B5A 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
045B5C CD 68 5F 04 0046*  	call vdu_sprite_select
045B60 CD 7B 5F 04 0047*      call vdu_sprite_clear_frames
045B64 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
045B68 CD B5 60 04 0049*      call vdu_sprite_add_buff
045B6C 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
045B70 CD B5 60 04 0051*      call vdu_sprite_add_buff
045B74 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
045B78 CD B5 60 04 0053*      call vdu_sprite_add_buff
045B7C 01 00 00 00 0054*      ld bc,0
045B80 ED 43 3F 5B 0055*      ld (player_x),bc
       04          
045B85 11 00 DF 00 0056*      ld de,0x00DF00
045B89 ED 53 42 5B 0057*      ld (player_y),de
       04          
045B8E CD 34 60 04 0058*      call vdu_sprite_move_abs168
045B92 CD DE 5F 04 0059*      call vdu_sprite_show
045B96 C9          0060*      ret
045B97             0061*  
045B97             0062*  ; process player keyboard input, set player bitmap
045B97             0063*  ; velocities and draw player bitmap at updated coordinates
045B97             0064*  ; Inputs: player_x/y set at desired position
045B97             0065*  ; Returns: player bitmap drawn at updated position
045B97             0066*  ; Destroys: probably everything except maybe iy
045B97             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
045B97             0068*  ; TODO: requires sprite implementation
045B97             0069*  player_input:
045B97             0070*  ; reset player component velocities to zero as the default
045B97 21 00 00 00 0071*  	ld hl,0
045B9B 22 45 5B 04 0072*  	ld (player_xvel),hl
045B9F 22 48 5B 04 0073*  	ld (player_yvel),hl
045BA3             0074*  ; make ship the active sprite
045BA3 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
045BA5 CD 68 5F 04 0076*      call vdu_sprite_select
045BA9             0077*  ; check for keypresses and branch accordingly
045BA9             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
045BA9             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
045BA9 3E 1E       0001*M 			LD	A, function
045BAB 49 CF       0002*M 			RST.LIS	08h
045BAD             0080*  ; we test all four arrow keys and add/subract velocities accordingly
045BAD             0081*  ; this handles the case where two opposing movement keys
045BAD             0082*  ; are down simultaneously (velocities will net to zero)
045BAD             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
045BAD             0084*  ; it also allows movement and action keys to be detected simultaneously
045BAD             0085*  ; so we can walk and chew gum at the same time
045BAD 3E 01       0086*      ld a,1 ; set ship's default animation to center
045BAF             0087*          ; if left and right are both down a will net to
045BAF             0088*  
045BAF             0089*  @left:
045BAF DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
045BB3 28 0E       0091*      jr z,@right
045BB5 2A 45 5B 04 0092*      ld hl,(player_xvel)
045BB9 01 00 FD FF 0093*      ld bc,-speed_player
045BBD 09          0094*      add hl,bc
045BBE 22 45 5B 04 0095*      ld (player_xvel),hl
045BC2 3D          0096*      dec a ; set ship's animation to left
045BC3             0097*  @right:
045BC3 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
045BC7 28 0E       0099*  	jr z,@up
045BC9 2A 45 5B 04 0100*      ld hl,(player_xvel)
045BCD 01 00 03 00 0101*      ld bc,speed_player
045BD1 09          0102*      add hl,bc
045BD2 22 45 5B 04 0103*      ld (player_xvel),hl
045BD6 3C          0104*      inc a ; set ship's animation to right
045BD7             0105*  @up:
045BD7 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
045BDB 28 0D       0107*  	jr z,@down
045BDD 2A 48 5B 04 0108*      ld hl,(player_yvel)
045BE1 01 00 FD FF 0109*      ld bc,-speed_player
045BE5 09          0110*      add hl,bc
045BE6 22 48 5B 04 0111*      ld (player_yvel),hl
045BEA             0112*  @down:
045BEA DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
045BEE 28 0D       0114*  	jr z,@done_keyboard
045BF0 2A 48 5B 04 0115*      ld hl,(player_yvel)
045BF4 01 00 03 00 0116*      ld bc,speed_player
045BF8 09          0117*      add hl,bc
045BF9 22 48 5B 04 0118*      ld (player_yvel),hl
045BFD             0119*  @done_keyboard:
045BFD             0120*  ; move player sprite according to velocities set by keypresses
045BFD 2A 45 5B 04 0121*      ld hl,(player_xvel)
045C01             0122*  ; compute new x position
045C01 ED 5B 3F 5B 0123*      ld de,(player_x)
       04          
045C06 19          0124*      add hl,de ; hl = player_x + player_xvel
045C07             0125*      ; check for horizontal screen edge collisions
045C07             0126*      ; and adjust coordinate as necessary
045C07             0127*  ; TODO: make this work using 24-bit registers
045C07             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
045C07             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
045C07             0130*      ; ld a,8 ; set x to leftmost allowable position
045C07             0131*  ; @check_right:
045C07             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
045C07             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
045C07             0134*  ;     ld a,248 ; set x to rightmost allowable position
045C07             0135*  @x_ok:
045C07             0136*  ; save the updated drawing coordinate
045C07 22 3F 5B 04 0137*      ld (player_x),hl
045C0B             0138*  ;compute new y position
045C0B 2A 42 5B 04 0139*      ld hl,(player_y)
045C0F ED 5B 48 5B 0140*      ld de,(player_yvel)
       04          
045C14 19          0141*      add hl,de ; hl = player_y + player_yvel
045C15             0142*  ; TODO: make this work using 24-bit registers
045C15             0143*  ;     ; check for vertical screen edge collisions
045C15             0144*  ;     ; and adjust coordinate as necessary
045C15             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
045C15             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
045C15             0147*  ;     ld a,8 ; set y to topmost allowable position
045C15             0148*  ; @check_top:
045C15             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
045C15             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
045C15             0151*  ;     ld a,232 ; set y to bottommost allowable position
045C15             0152*  @y_ok:
045C15 22 42 5B 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
045C19             0154*  ; a should land here loaded with the correct frame
045C19 CD CB 5F 04 0155*      call vdu_sprite_select_frame
045C1D             0156*  ; draw player at updated position
045C1D ED 4B 3F 5B 0157*      ld bc,(player_x)
       04          
045C22 ED 5B 42 5B 0158*  	ld de,(player_y)
       04          
045C27             0159*  
045C27             0160*      ; call dumpRegistersHex
045C27             0161*  
045C27 CD 34 60 04 0162*  	call vdu_sprite_move_abs168
045C2B             0163*  
045C2B             0164*  ; end player_input
045C2B C9          0165*  	ret
045C2C             0166*  
045C2C             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
045C2C             0168*  ; ; INSTEAD OF FRACTIONAL
045C2C             0169*  ; ; ----------------------------------------------------------------
045C2C             0170*  ; ; process player keyboard input, set player bitmap
045C2C             0171*  ; ; velocities and draw player bitmap at updated coordinates
045C2C             0172*  ; ; Inputs: player_x/y set at desired position
045C2C             0173*  ; ; Returns: player bitmap drawn at updated position
045C2C             0174*  ; ; Destroys: probably everything except maybe iy
045C2C             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
045C2C             0176*  ; ; TODO: requires sprite implementation
045C2C             0177*  ; player_input:
045C2C             0178*  ; ; reset player component velocities to zero as the default
045C2C             0179*  ; 	ld hl,0
045C2C             0180*  ; 	ld (player_xvel),hl
045C2C             0181*  ; 	ld (player_yvel),hl
045C2C             0182*  ; ; check for keypresses and branch accordingly
045C2C             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
045C2C             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
045C2C             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
045C2C             0186*  ; ; this handles the case where two opposing movement keys
045C2C             0187*  ; ; are down simultaneously (velocities will net to zero)
045C2C             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
045C2C             0189*  ; ; it also allows movement and action keys to be detected simultaneously
045C2C             0190*  ; ; so we can walk and chew gum at the same time
045C2C             0191*  ; @left:
045C2C             0192*  ;     bit 1,(ix+3) ; keycode 26
045C2C             0193*  ;     jr z,@right
045C2C             0194*  ;     ld hl,(player_xvel)
045C2C             0195*  ;     ld bc,-3
045C2C             0196*  ;     add hl,bc
045C2C             0197*  ;     ld (player_xvel),hl
045C2C             0198*  ; @right:
045C2C             0199*  ;     bit 1,(ix+15) ; keycode 122
045C2C             0200*  ; 	jr z,@up
045C2C             0201*  ;     ld hl,(player_xvel)
045C2C             0202*  ;     ld bc,3
045C2C             0203*  ;     add hl,bc
045C2C             0204*  ;     ld (player_xvel),hl
045C2C             0205*  ; @up:
045C2C             0206*  ;     bit 1,(ix+7) ; keycode 58
045C2C             0207*  ; 	jr z,@down
045C2C             0208*  ;     ld hl,(player_yvel)
045C2C             0209*  ;     ld bc,-3
045C2C             0210*  ;     add hl,bc
045C2C             0211*  ;     ld (player_yvel),hl
045C2C             0212*  ; @down:
045C2C             0213*  ;     bit 1,(ix+5) ; keycode 42
045C2C             0214*  ; 	jr z,@done_keyboard
045C2C             0215*  ;     ld hl,(player_yvel)
045C2C             0216*  ;     ld bc,3
045C2C             0217*  ;     add hl,bc
045C2C             0218*  ;     ld (player_yvel),hl
045C2C             0219*  ; @done_keyboard:
045C2C             0220*  ; ; move player sprite according to velocities set by keypresses
045C2C             0221*  ;     ld hl,(player_xvel)
045C2C             0222*  ; ; compute new x position
045C2C             0223*  ;     ld de,(player_x)
045C2C             0224*  ;     add hl,de ; hl = player_x + player_xvel
045C2C             0225*  ;     ; check for horizontal screen edge collisions
045C2C             0226*  ;     ; and adjust coordinate as necessary
045C2C             0227*  ; ; TODO: make this work using 24-bit registers
045C2C             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
045C2C             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
045C2C             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
045C2C             0231*  ; ; @check_right:
045C2C             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
045C2C             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
045C2C             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
045C2C             0235*  ; @x_ok:
045C2C             0236*  ;     ; save the updated drawing coordinate
045C2C             0237*  ;     ld (player_x),hl
045C2C             0238*  ; ;compute new y position
045C2C             0239*  ;     ld hl,(player_y)
045C2C             0240*  ;     ld de,(player_yvel)
045C2C             0241*  ;     add hl,de ; hl = player_y + player_yvel
045C2C             0242*  ; ; TODO: make this work using 24-bit registers
045C2C             0243*  ; ;     ; check for vertical screen edge collisions
045C2C             0244*  ; ;     ; and adjust coordinate as necessary
045C2C             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
045C2C             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
045C2C             0247*  ; ;     ld a,8 ; set y to topmost allowable position
045C2C             0248*  ; ; @check_top:
045C2C             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
045C2C             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
045C2C             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
045C2C             0252*  ; @y_ok:
045C2C             0253*  ;     ld (player_y),hl
045C2C             0254*  ; ; draw player at updated position
045C2C             0255*  ;     ld a,table_max_records ; this is always player spriteId
045C2C             0256*  ;     call vdu_sprite_select
045C2C             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
045C2C             0258*  ;     call get_sign_hlu ; to set the proper animation
045C2C             0259*  ;     add a,1 ; ...
045C2C             0260*  ;     call vdu_sprite_select_frame
045C2C             0261*  ;     ld bc,(player_x)
045C2C             0262*  ; 	ld de,(player_y)
045C2C             0263*  ; 	call vdu_sprite_move_abs
045C2C             0264*  ; ; end player_input
045C2C             0265*  ; 	ret
045C2C             0266*  
045C2C             0267*  
045C2C             0268*  ; ###################################################################
045C2C             0269*  ; TODO: the below is all stuff from the original code we need to port
045C2C             0270*  ; ###################################################################
045C2C             0271*  
045C2C             0272*  ; kill_player:
045C2C             0273*  ; ; set player status to dead
045C2C             0274*  ;     xor a; sets all player flags to zero
045C2C             0275*  ;     ld (player_collisions),a
045C2C             0276*  ; ; deduct a ship from the inventory
045C2C             0277*  ;     ld a,(player_ships)
045C2C             0278*  ;     dec a
045C2C             0279*  ;     ld (player_ships),a
045C2C             0280*  ; ; are we out of ships?
045C2C             0281*  ;     jp z,game_over
045C2C             0282*  ; ; wait a few ticks
045C2C             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
045C2C             0284*  ;     ld (player_move_timer),a
045C2C             0285*  ; kill_player_loop:
045C2C             0286*  ;     call vsync
045C2C             0287*  ;     ld a,(player_move_timer)
045C2C             0288*  ;     dec a
045C2C             0289*  ;     ld (player_move_timer),a
045C2C             0290*  ;     jr nz,kill_player_loop
045C2C             0291*  ;     call player_init ; player respawn if timer zero
045C2C             0292*  ;     ret ; and out
045C2C             0293*  
045C2C             0294*  
045C2C             0295*  ; player_move:
045C2C             0296*  ; ; begin setting player to active sprite
045C2C             0297*  ;     ld hl,player
045C2C             0298*  ;     ld (sprite_base_bufferId),hl
045C2C             0299*  ;     ld hl,0 ; north
045C2C             0300*  ;     ld (sprite_heading),hl
045C2C             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
045C2C             0302*  ;     ld (sprite_animation),a
045C2C             0303*  ;     ; we set position here for the time being as a default
045C2C             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
045C2C             0305*  ;     ld hl,(player_x)
045C2C             0306*  ;     ld (sprite_x),hl
045C2C             0307*  ;     ld hl,(player_y)
045C2C             0308*  ;     ld (sprite_y),hl
045C2C             0309*  ; ; did we just die?
045C2C             0310*  ;     ld a,(player_collisions)
045C2C             0311*  ;     and %00000010 ; zero flag will be set if not dead
045C2C             0312*  ;     jr z,player_not_dead
045C2C             0313*  ; ; yes we died
045C2C             0314*  ;     call kill_player
045C2C             0315*  ;     ret ; done
045C2C             0316*  ; ; yay we didn't die
045C2C             0317*  ; player_not_dead:
045C2C             0318*  ; ; set player movements to zero by default
045C2C             0319*  ;     ld hl,0
045C2C             0320*  ;     ld (player_xvel),hl
045C2C             0321*  ;     ld (player_yvel),hl
045C2C             0322*  ; ; do we move it?
045C2C             0323*  ;     in a,(#82) ; keyboard
045C2C             0324*  ;     or a ; if zero,don't move
045C2C             0325*  ;     jr z,player_draw
045C2C             0326*  ; ; move it
045C2C             0327*  ;     call player_move_calc
045C2C             0328*  ; player_draw:
045C2C             0329*  ;     call vdu_bmp_select
045C2C             0330*  ;     call vdu_bmp_draw
045C2C             0331*  ; player_move_done:
045C2C             0332*  ;     ; write updated x,y coordinates back to player table
045C2C             0333*  ;     ld hl,(sprite_x)
045C2C             0334*  ;     ld (player_x),hl
045C2C             0335*  ;     ld hl,(sprite_y)
045C2C             0336*  ;     ld (player_y),hl
045C2C             0337*  ;     ret
045C2C             0064   	; include "tiles.asm"
045C2C             0065   	include "enemies.asm"
045C2C 10          0001*  max_enemy_sprites: db 16
045C2D             0002*  
045C2D             0003*  ; sprite_type
045C2D             0004*  enemy_dead: equ 0
045C2D             0005*  enemy_small: equ 1
045C2D             0006*  enemy_medium: equ 2
045C2D             0007*  enemy_large: equ 3
045C2D             0008*  landing_pad: equ 4
045C2D             0009*  laser_turret: equ 5
045C2D             0010*  fireballs: equ 6
045C2D             0011*  explosion: equ 7
045C2D             0012*  
045C2D             0013*  
045C2D             0014*  respawn_countdown:
045C2D 2A 4E 5C 04 0015*      ld hl,(respawn_timer)
045C31 2B          0016*      dec hl
045C32 22 4E 5C 04 0017*      ld (respawn_timer),hl
045C36             0018*  ; check hl for zero
045C36 19          0019*      add hl,de
045C37 B7          0020*      or a
045C38 ED 52       0021*      sbc hl,de
045C3A C0          0022*      ret nz
045C3B 06 04       0023*      ld b,table_max_records
045C3D             0024*  @respawn_loop:
045C3D C5          0025*      push bc
045C3E CD 43 5D 04 0026*      call enemy_init_from_landing_pad
045C42 C1          0027*      pop bc
045C43 10 F8       0028*      djnz @respawn_loop
045C45 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
045C49 22 4E 5C 04 0030*      ld (respawn_timer),hl
045C4D C9          0031*      ret
045C4E 3C 00 00    0032*  respawn_timer: dl 1*60
045C51             0033*  
045C51             0034*  move_enemies:
045C51             0035*  ; are there any active enemies or explosions?
045C51 21 00 00 00 0036*      ld hl,0
045C55 3A C8 50 04 0037*      ld a,(table_active_sprites)
045C59 6F          0038*      ld l,a
045C5A CD FE 54 04 0039*      call dumpRegistersHex
045C5E A7          0040*      and a ; will be zero if no alive enemies or explosions
045C5F             0041*      ; ret z ; so nothing to do but go back
045C5F             0042*      ; ld hl,(respawn_timer)
045C5F             0043*      ; call dumpRegistersHex
045C5F 20 05       0044*      jr nz,move_enemies_do
045C61 CD 2D 5C 04 0045*      call respawn_countdown
045C65 C9          0046*      ret
045C66             0047*  move_enemies_do:
045C66             0048*  ; initialize pointers and loop counter
045C66 FD 21 2D 50 0049*      ld iy,table_base ; set iy to first record in table
       04          
045C6B 06 04       0050*      ld b,table_max_records ; loop counter
045C6D             0051*  move_enemies_loop:
045C6D FD 22 C5 50 0052*      ld (table_pointer),iy ; update table pointer
       04          
045C72 C5          0053*      push bc ; backup loop counter
045C73             0054*  ; check sprite_type to see if sprite is active
045C73 FD 7E 01    0055*      ld a,(iy+sprite_type)
045C76 A7          0056*      and a ; if zero, sprite is dead
045C77 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
045C79             0058*  ; otherwise we prepare to move the sprite
045C79 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
045C7C CD 68 5F 04 0060*      call vdu_sprite_select ; select sprite
045C80 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
045C83 E9          0062*      jp (hl)  ; ... and jump to it
045C84             0063*  ; we always jp back here from behavior subroutines
045C84             0064*  move_enemies_loop_return:
045C84 FD 2A C5 50 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
045C89             0066*  ; now we check results of all the moves
045C89 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
045C8C E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
045C8E FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
045C91 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
045C93 CD 11 51 04 0071*      call table_deactivate_sprite ; otherwise we ded
045C97 AF          0072*      xor a ; zero a so that we can ...
045C98 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
045C9B 18 0A       0074*      jr move_enemies_next_record ; and to the next record
045C9D             0075*  move_enemies_draw_sprite:
045C9D             0076*  ; if we got here sprite will have already been activated
045C9D             0077*  ; so all we need to do is set its coordinates and draw it
045C9D FD 07 0B    0078*      ld bc,(iy+sprite_x)
045CA0 FD 17 0E    0079*      ld de,(iy+sprite_y)
045CA3 CD 34 60 04 0080*      call vdu_sprite_move_abs168
045CA7             0081*  ; fall through to next record
045CA7             0082*  move_enemies_next_record:
045CA7 11 26 00 00 0083*      ld de,table_bytes_per_record
045CAB FD 19       0084*      add iy,de ; point to next record
045CAD AF          0085*      xor a ; clears carry flag
045CAE 32 C9 50 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
045CB2 C1          0087*      pop bc ; get back our loop counter
045CB3 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
045CB5 C9          0089*      ret ; and we're out
045CB6             0090*  
045CB6             0091*  en_nav_zigzag_start:
045CB6 FD 2A C5 50 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
045CBB CD 85 61 04 0093*      call rand_8
045CBF E6 3F       0094*      and %00111111 ; limit it to 64
045CC1 CB DF       0095*      set 3,a ; make sure it's at least 8
045CC3 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
045CC6             0097*      ; fall through to en_nav_zigzag
045CC6             0098*  en_nav_zigzag:
045CC6 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
045CC9 3D          0100*      dec a
045CCA FD 77 22    0101*      ld (iy+sprite_move_timer),a
045CCD 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
045CCF             0103*      ; otherwise flip direction and restart timer
045CCF FD 7E 23    0104*      ld a,(iy+sprite_move_step)
045CD2 EE 01       0105*      xor %1 ; flips bit one
045CD4 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
045CD7 20 09       0107*      jr nz,en_nav_zigzag_right
045CD9             0108*  ;otherwise zag left
045CD9 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
045CDD FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
045CE0 18 D4       0111*      jr en_nav_zigzag_start
045CE2             0112*  en_nav_zigzag_right:
045CE2 21 00 60 00 0113*      ld hl,0x006000; southeast heading
045CE6 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
045CE9 18 CB       0115*      jr en_nav_zigzag_start
045CEB             0116*  en_nav_zigzag_no_switch:
045CEB             0117*      ; ld a,(sprite_orientation)
045CEB FD 27 1A    0118*      ld hl,(iy+sprite_heading)
045CEE 18 13       0119*      jr en_nav_computevelocities
045CF0             0120*  
045CF0             0121*  ; contains the logic for how to move the enemy
045CF0             0122*  ; and then does the moving
045CF0             0123*  ; inputs: a fully-populated active sprite table
045CF0             0124*  ;         player position variables
045CF0             0125*  ; destroys: everything except index registers
045CF0             0126*  ; outputs: moving enemies
045CF0             0127*  en_nav:
045CF0             0128*  ; set velocity and orientation by player's relative location
045CF0             0129*  ; move enemies y-axis
045CF0             0130*  ; where is player relative to us?
045CF0 CD C6 5D 04 0131*      call orientation_to_player
045CF4             0132*  ;    h.l 16.8 fixed angle256 to player
045CF4             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
045CF4             0134*  ; is player above or below us?
045CF4 ED 53 7D 56 0135*      ld (ude),de ; dy
       04          
045CF9 3A 7F 56 04 0136*      ld a,(ude+2) ; deu
045CFD 17          0137*      rla ; shift sign bit into carry
045CFE 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
045D00             0139*  ; player is even or above,so home in on current heading
045D00 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
045D03             0141*  
045D03             0142*  ; we land here from zig-zag program so as not to
045D03             0143*  ; redundantly save orientation and heading
045D03             0144*  en_nav_computevelocities:
045D03             0145*  ; set x/y component velocities based on bearing to player
045D03 FD 2A C5 50 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
045D08 E5          0147*      push hl ; we need it back to set rotation frame
045D09 FD 17 17    0148*      ld de,(iy+sprite_vel)
045D0C CD 3C 66 04 0149*      call polar_to_cartesian
045D10 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
045D13 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
045D16             0152*  ; change the animation frame to match heading
045D16             0153*  ; by dividng the heading by 8
045D16 E1          0154*      pop hl ; get back Heading
045D17 7C          0155*      ld a,h
045D18 CB 3F       0156*      srl a
045D1A CB 3F       0157*      srl a
045D1C CB 3F       0158*      srl a
045D1E CD CB 5F 04 0159*      call vdu_sprite_select_frame
045D22             0160*  ; update sprite position
045D22             0161*  move_enemy_sprite:
045D22 FD 27 0B    0162*      ld hl,(iy+sprite_x)
045D25 FD 17 11    0163*      ld de,(iy+sprite_xvel)
045D28 19          0164*      add hl,de
045D29 FD 2F 0B    0165*      ld (iy+sprite_x),hl
045D2C             0166*  
045D2C FD 27 0E    0167*      ld hl,(iy+sprite_y)
045D2F FD 17 14    0168*      ld de,(iy+sprite_yvel)
045D32 19          0169*      add hl,de
045D33 FD 2F 0E    0170*      ld (iy+sprite_y),hl
045D36 C9          0171*      ret
045D37             0172*  
045D37             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
045D37             0174*  ; move_enemy_sprite:
045D37             0175*  ; ; x-axis movement first
045D37             0176*  ;     ld hl,(iy+sprite_x)
045D37             0177*  ;     push hl ; save pre-move position
045D37             0178*  ;     pop bc ; to detect screen edge collision
045D37             0179*  ;     ld de,(iy+sprite_xvel)
045D37             0180*  ;     add hl,de ;compute new x position
045D37             0181*  ;     ld (iy+sprite_x),hl ; store it
045D37             0182*  ;     and a ; clear the carry flag
045D37             0183*  ;     sbc hl,bc ; test which direction was our movement
045D37             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
045D37             0185*  ;     jp p,@move_right ; sign positive means moved right
045D37             0186*  ; @move_left: ; otherwise we moved left
045D37             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
045D37             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
045D37             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
045D37             0190*  ;     ld a,#20 ; west
045D37             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
045D37             0192*  ;     jr @move_y
045D37             0193*  ; @move_right:
045D37             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
045D37             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
045D37             0196*  ;     ld l,0x00
045D37             0197*  ;     ld a,(iy+sprite_dim_x)
045D37             0198*  ;     ld h,a
045D37             0199*  ;     ld a,0x00
045D37             0200*  ;     sub h
045D37             0201*  ;     ld h,a
045D37             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
045D37             0203*  ;     ld a,0x02 ; east
045D37             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
045D37             0205*  ; @move_y:
045D37             0206*  ;     ld hl,(iy+sprite_y)
045D37             0207*  ;     ld b,h ; save pre-move position
045D37             0208*  ;     ld c,l ; to detect screen edge collision
045D37             0209*  ;     ld de,(iy+sprite_yvel)
045D37             0210*  ;     add hl,de ;compute new y position
045D37             0211*  ;     ld (iy+sprite_y),hl ; store it
045D37             0212*  ;     and a ; clear the carry flag
045D37             0213*  ;     sbc hl,bc ; test which direction was our movement
045D37             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
045D37             0215*  ;     jp p,@move_dn ; sign positive means moved down
045D37             0216*  ; @move_up:
045D37             0217*  ;     add hl,bc ; get back new y position
045D37             0218*  ;     ld de,0x5000 ; top edge of visible screen
045D37             0219*  ;     and a ; clear the carry flag
045D37             0220*  ;     sbc hl,de
045D37             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
045D37             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
045D37             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
045D37             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
045D37             0225*  ;     or 0x80 ; north
045D37             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
045D37             0227*  ;     jr @move_ret
045D37             0228*  ; @move_dn:
045D37             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
045D37             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
045D37             0231*  ;     ld l,0x00
045D37             0232*  ;     ld a,(iy+sprite_dim_y)
045D37             0233*  ;     ld h,a
045D37             0234*  ;     ld a,0x00
045D37             0235*  ;     sub h
045D37             0236*  ;     ld h,a
045D37             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
045D37             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
045D37             0239*  ;     or 0x08 ; south
045D37             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
045D37             0241*  ; @move_ret:
045D37             0242*  ;     ret
045D37             0243*  
045D37             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
045D37             0245*  ; ; each sprite in the table must have one of these defined
045D37             0246*  ; ; but they need not be unique to a particular sprite
045D37             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
045D37             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
045D37             0249*  ; ; but they can call anything they want between those two endpoints
045D37             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
045D37             0251*  
045D37             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
045D37             0253*  ;     jp move_enemies_loop_return
045D37             0254*  
045D37             0255*  ; move_explosion:
045D37             0256*  ;     call animate_explosion
045D37             0257*  ;     jp move_enemies_loop_return
045D37             0258*  
045D37             0259*  move_enemy_small:
045D37 CD F0 5C 04 0260*      call en_nav
045D3B CD 62 5E 04 0261*      call check_collisions
045D3F C3 84 5C 04 0262*      jp move_enemies_loop_return
045D43             0263*  
045D43             0264*  ; move_enemy_medium:
045D43             0265*  ;     call en_nav
045D43             0266*  ;     call check_collisions
045D43             0267*  ;     jp move_enemies_loop_return
045D43             0268*  
045D43             0269*  ; move_enemy_large:
045D43             0270*  ;     call en_nav
045D43             0271*  ;     call check_collisions
045D43             0272*  ;     jp move_enemies_loop_return
045D43             0273*  
045D43             0274*  ; move_landing_pad:
045D43             0275*  ;     call move_active_tiles
045D43             0276*  ;     call check_collisions
045D43             0277*  ; ; is it time to launch an enemy?
045D43             0278*  ;     ld hl,sprite_move_timer
045D43             0279*  ;     dec (hl)
045D43             0280*  ;     jp nz,move_enemies_loop_return
045D43             0281*  ;     call enemy_init_from_landing_pad
045D43             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
045D43             0283*  ;     call rand_8     ; snag a random number
045D43             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
045D43             0285*  ;     add a,64 ; range is now 64-127
045D43             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
045D43             0287*  ;     jp move_enemies_loop_return
045D43             0288*  
045D43             0289*  enemy_init_from_landing_pad:
045D43             0290*  ; get next available spriteId
045D43 CD EC 50 04 0291*      call table_get_next_id
045D47 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
045D48             0293*  ; ix comes back with the pointer to the new sprite variables
045D48 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
045D4A             0295*  ; a comes back with the spriteId of the new sprite
045D4A 32 A0 5D 04 0296*      ld (@id),a
045D4E             0297*  ; initialize the new sprite
045D4E CD 68 5F 04 0298*      call vdu_sprite_select
045D52 CD 7B 5F 04 0299*      call vdu_sprite_clear_frames
045D56 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
045D5A 06 20       0301*      ld b,32
045D5C             0302*  @load_frames:
045D5C C5          0303*      push bc
045D5D E5          0304*      push hl
045D5E CD B5 60 04 0305*      call vdu_sprite_add_buff
045D62 E1          0306*      pop hl
045D63 23          0307*      inc hl
045D64 C1          0308*      pop bc
045D65 10 F5       0309*      djnz @load_frames
045D67             0310*  ; copy coordinates of active sprite to new sprite
045D67 FD 2A C5 50 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
045D6C             0312*      ; ld hl,(iy+sprite_x)
045D6C             0313*  	; ld hl,0x008000 ; debug
045D6C             0314*  
045D6C CD 85 61 04 0315*      call rand_8
045D70 21 00 00 00 0316*      ld hl,0
045D74 67          0317*      ld h,a
045D75             0318*  
045D75 22 AB 5D 04 0319*      ld (@x),hl
045D79             0320*      ; ld hl,(iy+sprite_y)
045D79             0321*      ; ld hl,0x002000 ; debug
045D79             0322*  
045D79 CD 85 61 04 0323*      call rand_8
045D7D 21 00 00 00 0324*      ld hl,0
045D81 67          0325*      ld h,a
045D82             0326*  
045D82 22 AE 5D 04 0327*      ld (@y),hl
045D86 CD 85 61 04 0328*      call rand_8
045D8A E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
045D8C 32 C3 5D 04 0330*      ld (@move_step),a
045D90             0331*  ; now copy to the table
045D90 21 A0 5D 04 0332*      ld hl,@id ; address to copy from
045D94 D1          0333*      pop de ; address to copy to (was ix)
045D95 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
045D99 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
045D9B             0336*  ; finally, make the new sprite visible
045D9B CD DE 5F 04 0337*      call vdu_sprite_show
045D9F C9          0338*      ret
045DA0 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
045DA1 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
045DA2 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
045DA5 37 5D 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
045DA8 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
045DA9 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
045DAA 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
045DAB 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
045DAE 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
045DB1 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045DB4 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045DB7 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
045DBA 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
045DBD 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
045DC0 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
045DC1 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
045DC2 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
045DC3 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
045DC4 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
045DC5 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
045DC6             0359*  
045DC6             0360*  ; move_laser_turret:
045DC6             0361*  ; ; compute orientation to player
045DC6             0362*  ;     call orientation_to_player
045DC6             0363*  ; ; h.l 8.8 fixed angle256 to player
045DC6             0364*  ; ; bc and de as signed 16-bit integers
045DC6             0365*  ; ; representing delta-x/y *to* target respectively
045DC6             0366*  ;     ld (Bearing_t),hl
045DC6             0367*  ;     ld hl,0x0400
045DC6             0368*  ;     ld (Vp),hl
045DC6             0369*  ;     call targeting_computer
045DC6             0370*  ;     ld (sprite_heading),hl ; store bearing to player
045DC6             0371*  ; ; is it time to launch a fireball?
045DC6             0372*  ;     ld hl,sprite_move_timer
045DC6             0373*  ;     dec (hl)
045DC6             0374*  ;     jp nz,move_laser_turret_boilerplate
045DC6             0375*  ;     call fireballs_init
045DC6             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
045DC6             0377*  ;     call rand_8     ; snag a random number
045DC6             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
045DC6             0379*  ;     add a,64 ; range is now 64-127
045DC6             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
045DC6             0381*  ; move_laser_turret_boilerplate:
045DC6             0382*  ;     call move_active_tiles
045DC6             0383*  ;     call check_collisions
045DC6             0384*  ;     jp move_enemies_loop_return
045DC6             0385*  
045DC6             0386*  ; fireballs_init:
045DC6             0387*  ;     call sprite_variables_to_stack
045DC6             0388*  
045DC6             0389*  ;     ld hl,fireballs
045DC6             0390*  ;     ld (sprite_base_bufferId),hl
045DC6             0391*  
045DC6             0392*  ;     ld hl,move_fireballs
045DC6             0393*  ;     ld (sprite_move_program),hl
045DC6             0394*  
045DC6             0395*  ;     ld a,%11 ; collides with laser and player
045DC6             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
045DC6             0397*  ;     ld (iy+sprite_collisions),a
045DC6             0398*  
045DC6             0399*  ;     ld hl,(Vp)
045DC6             0400*  ;     ld (sprite_vel),hl
045DC6             0401*  ;     ld hl,(Vp_x)
045DC6             0402*  ;     ld (sprite_xvel),hl
045DC6             0403*  ;     ld hl,(Vp_y)
045DC6             0404*  ;     inc h ; account for ground movement
045DC6             0405*  ;     ld (sprite_yvel),hl
045DC6             0406*  
045DC6             0407*  ;     xor a ; zero a
045DC6             0408*  ;     ld (sprite_animation),a
045DC6             0409*  ;     ld (sprite_move_step),a
045DC6             0410*  ;     ld (sprite_move_timer),a
045DC6             0411*  
045DC6             0412*  ;     ld a,6 ; 1/10th of a second timer
045DC6             0413*  ;     ld (sprite_animation_timer),a
045DC6             0414*  
045DC6             0415*  ;     ld a,0x00 ; BCD
045DC6             0416*  ;     ld (sprite_points),a
045DC6             0417*  ;     ld a,1 ; binary
045DC6             0418*  ;     ld (sprite_shield_damage),a
045DC6             0419*  
045DC6             0420*  ;     call table_add_record ; plops that on the sprite stack for later
045DC6             0421*  ;     call sprite_variables_from_stack ; come back to where we started
045DC6             0422*  ;     ret
045DC6             0423*  
045DC6             0424*  ; move_fireballs:
045DC6             0425*  ;     call move_enemy_sprite ; move sprite
045DC6             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
045DC6             0427*  ;     and a ; if zero we're still within screen bounds
045DC6             0428*  ;     jr z,move_fireballs_alive
045DC6             0429*  ; ; otherwise kill sprite
045DC6             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
045DC6             0431*  ;     ld (iy+sprite_collisions),a
045DC6             0432*  ;     jp move_enemies_loop_return
045DC6             0433*  ; move_fireballs_alive:
045DC6             0434*  ;     ld a,(sprite_animation_timer)
045DC6             0435*  ;     dec a
045DC6             0436*  ;     ld (sprite_animation_timer),a
045DC6             0437*  ;     jr nz,move_fireballs_draw
045DC6             0438*  ;     ld a,(sprite_animation)
045DC6             0439*  ;     xor %1
045DC6             0440*  ;     ld (sprite_animation),a
045DC6             0441*  ;     ld a,6 ; 1/10th of a second timer
045DC6             0442*  ;     ld (sprite_animation_timer),a
045DC6             0443*  ;     ; fall through
045DC6             0444*  
045DC6             0445*  ; move_fireballs_draw:
045DC6             0446*  ;     call vdu_bmp_select
045DC6             0447*  ;     call vdu_bmp_draw
045DC6             0448*  ;     call check_collisions
045DC6             0449*  ;     jp move_enemies_loop_return
045DC6             0450*  
045DC6             0451*  ; compute orientation to player
045DC6             0452*  ; based on relative positions
045DC6             0453*  ; returns: h.l 16.8 fixed angle256 to player
045DC6             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
045DC6             0455*  ;    representing delta-x/y *to* target respectively
045DC6             0456*  orientation_to_player:
045DC6 FD 2A C5 50 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
045DCB FD E5       0458*      push iy ; so we can send it back intact
045DCD FD 07 0B    0459*      ld bc,(iy+sprite_x)
045DD0 FD 17 0E    0460*      ld de,(iy+sprite_y)
045DD3 DD 2A 3F 5B 0461*      ld ix,(player_x)
       04          
045DD8 FD 2A 42 5B 0462*      ld iy,(player_y)
       04          
045DDD CD 6D 66 04 0463*      call dxy168
045DE1 CD D4 66 04 0464*      call atan2_168game
045DE5 ED 4B C8 66 0465*      ld bc,(dx168)
       04          
045DEA ED 5B CE 66 0466*      ld de,(dy168)
       04          
045DEF FD E1       0467*      pop iy ; restore table pointer
045DF1 C9          0468*      ret
045DF2             0469*  
045DF2             0470*  
045DF2             0471*  ; targeting_computer scratch variables
045DF2 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
045DF4 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
045DF6 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
045DF8 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
045DFA 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
045DFC 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
045DFE 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
045E00 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
045E02             0480*  
045E02             0481*  
045E02             0482*  ; ; Inputs:   see scratch variables
045E02             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
045E02             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
045E02             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
045E02             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
045E02             0487*  ; targeting_computer:
045E02             0488*  ; ; compute target velocity from x,y component velocities
045E02             0489*  ;     ld bc,(player_xvel)
045E02             0490*  ;     ld de,(player_yvel)
045E02             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
045E02             0492*  
045E02             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
045E02             0494*  ;     ld (Heading_t),bc
045E02             0495*  ;     ld (Vt),de
045E02             0496*  
045E02             0497*  ; ; compute Heading_t-Bearing_t
045E02             0498*  ;     ld h,b
045E02             0499*  ;     ld l,c
045E02             0500*  ;     ld bc,(Bearing_t)
045E02             0501*  ;     and a ; clear carry
045E02             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
045E02             0503*  
045E02             0504*  ; ; compute sin(Heading_t-Bearing_t)
045E02             0505*  ;     ld b,h
045E02             0506*  ;     ld c,l
045E02             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
045E02             0508*  
045E02             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
045E02             0510*  ;     ex de,hl
045E02             0511*  ;     ld bc,(Vt)
045E02             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
045E02             0513*  
045E02             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
045E02             0515*  ;     ld b,h
045E02             0516*  ;     ld c,l
045E02             0517*  ;     ld de,(Vp)
045E02             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
045E02             0519*  ; ; answer is in radians, convert to degrees256
045E02             0520*  ;     ex de,hl
045E02             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
045E02             0522*  ;     call BC_Mul_DE_88
045E02             0523*  
045E02             0524*  ; ; add lead angle to target bearing
045E02             0525*  ;     ld de,(Bearing_t)
045E02             0526*  ;     add hl,de ; h.l=lead angle+target bearing
045E02             0527*  ;     push hl
045E02             0528*  
045E02             0529*  ; ; compute component projectile velocities
045E02             0530*  ;     ld b,h
045E02             0531*  ;     ld c,l
045E02             0532*  ;     ld de,(Vp)
045E02             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
045E02             0534*  
045E02             0535*  ;     ld (Vp_x),bc
045E02             0536*  ;     ld (Vp_y),de
045E02             0537*  ;     pop hl ; h.l=lead angle+target bearing
045E02             0538*  ;     ret
045E02             0539*  
045E02             0540*  ; this routine vanquishes the enemy sprite
045E02             0541*  ; and replaces it with an animated explosion
045E02             0542*  ; we jump here instead of call because
045E02             0543*  ; we want to return to differing locations in the loop
045E02             0544*  ; depending on whether we're still sploding
045E02             0545*  ; destroys: everything except index registers
045E02             0546*  ; returns: an incandescent ball of debris and gas
045E02             0547*  kill_nurple:
045E02             0548*  ; ; tally up points
045E02             0549*  ;     ld bc,0
045E02             0550*  ;     ld a,(sprite_points)
045E02             0551*  ;     ld e,a
045E02             0552*  ;     ld d,0
045E02             0553*  ;     ld hl,add_bcd_arg2
045E02             0554*  ;     call set_bcd
045E02             0555*  ;     ld hl,player_score
045E02             0556*  ;     ld de,add_bcd_arg2
045E02             0557*  ;     ld a,3 ; number of bytes to add
045E02             0558*  ;     call add_bcd
045E02             0559*  ; ; initialize explosion
045E02             0560*  ; init_explosion:
045E02             0561*  ;     ld hl,explosion
045E02             0562*  ;     ld (sprite_base_bufferId),hl
045E02             0563*  ;     ld hl,move_explosion
045E02             0564*  ;     ld (sprite_move_program),hl
045E02             0565*  ;     ld a,%00000000 ; collides with nothing
045E02             0566*  ;     ld (iy+sprite_collisions),a
045E02             0567*  ;     ld hl,0 ; north
045E02             0568*  ;     ld (sprite_heading),hl
045E02             0569*  ;     ld a,0x04 ; will decrement to 03
045E02             0570*  ;     ld (sprite_animation),a
045E02             0571*  ;     ld a,0x07 ; 7/60th of a second timer
045E02             0572*  ;     ld (sprite_animation_timer),a
045E02             0573*  ;     xor a
045E02             0574*  ;     ld (sprite_move_timer),a
045E02             0575*  ;     call vdu_bmp_select
045E02             0576*  ; ; fall through to next_explosion
045E02             0577*  ; next_explosion:
045E02             0578*  ;     ld a,(sprite_animation)
045E02             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
045E02             0580*  ;     jp m,done_explosion
045E02             0581*  ;     ld (sprite_animation),a
045E02             0582*  ;     ld a,0x7 ; 7/60th of a second timer
045E02             0583*  ;     ld (sprite_animation_timer),a
045E02             0584*  ; ; fall through to animate_explosion
045E02             0585*  ; animate_explosion:
045E02             0586*  ;     ld hl,sprite_y+1
045E02             0587*  ;     inc (hl) ; move explosion down 1 pixel
045E02             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
045E02             0589*  ;     ld hl,sprite_animation_timer
045E02             0590*  ;     dec (hl) ; if timer is zero,we do next animation
045E02             0591*  ;     jr z,next_explosion
045E02             0592*  ;     ;otherwise we fall through to draw the current one
045E02             0593*  ;     call vdu_bmp_select
045E02             0594*  ;     call vdu_bmp_draw
045E02             0595*  ;     ret ; now we go back to caller
045E02             0596*  ; done_explosion:
045E02 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
045E04 FD 2A C5 50 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
045E09 FD 77 08    0599*      ld (iy+sprite_collisions),a
045E0C C9          0600*      ret ; now we go back to caller
045E0D             0601*  
045E0D             0602*  ; game_over:
045E0D             0603*  ;     jp new_game
045E0D             0604*  
045E0D             0605*  ; it's presumed we've already checked that laser is alive
045E0D             0606*  collision_enemy_with_laser:
045E0D DD 2A 9A 5E 0607*      ld ix,(laser_x)
       04          
045E12 FD 2A 9D 5E 0608*      ld iy,(laser_y)
       04          
045E17 3A 98 5E 04 0609*      ld a,(laser_dim_x)
045E1B CB 2F       0610*      sra a ; divide by 2
045E1D F5          0611*      push af ; we need this later
045E1E             0612*      ; ld de,0
045E1E             0613*      ; ld d,a
045E1E             0614*      ; add ix,de
045E1E             0615*      ; add iy,de
045E1E 18 11       0616*      jr collision_enemy
045E20             0617*  
045E20             0618*  ; it's presumed we've already checked that player is alive
045E20             0619*  collision_enemy_with_player:
045E20 DD 2A 3F 5B 0620*      ld ix,(player_x)
       04          
045E25 FD 2A 42 5B 0621*      ld iy,(player_y)
       04          
045E2A 3A 3D 5B 04 0622*      ld a,(player_dim_x)
045E2E             0623*  
045E2E             0624*      ; call dumpRegistersHex
045E2E             0625*  
045E2E CB 2F       0626*      sra a ; divide by 2
045E30 F5          0627*      push af ; we need this later
045E31             0628*      ; ld de,0
045E31             0629*      ; ld d,a
045E31             0630*      ; add ix,de
045E31             0631*      ; add iy,de
045E31             0632*      ; fall through to collision_enemy
045E31             0633*  
045E31             0634*  ; compute the distance between the two sprites' centers
045E31             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
045E31             0636*  collision_enemy:
045E31             0637*  ; back up iy because we need it as the sprite table pointer
045E31 FD E5       0638*      push iy
045E33 FD 2A C5 50 0639*      ld iy,(table_pointer)
       04          
045E38 FD 27 0B    0640*      ld hl,(iy+sprite_x)
045E3B FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
045E3E CB 2F       0642*      sra a
045E40 F5          0643*      push af ; we need this later
045E41             0644*      ; ld de,0
045E41             0645*      ; ld d,a
045E41             0646*      ; add hl,de
045E41 E5          0647*      push hl
045E42 C1          0648*      pop bc ; bc = x0
045E43 FD 27 0E    0649*      ld hl,(iy+sprite_y)
045E46 FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
045E49             0651*      ; sra a
045E49             0652*      ; ld de,0
045E49             0653*      ; ld d,a
045E49             0654*      ; add hl,de
045E49 EB          0655*      ex de,hl ; de = y0
045E4A F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
045E4B FD E1       0657*      pop iy
045E4D F5          0658*      push af
045E4E             0659*  
045E4E             0660*      ; call dumpRegistersHex
045E4E             0661*  
045E4E CD 88 66 04 0662*      call distance168
045E52             0663*      ; CALL dumpRegistersHex
045E52             0664*  ; ; subtract sum of radii from distance between centers
045E52             0665*  ;     ld de,0
045E52             0666*  ;     pop af ; radius of enemy sprite
045E52             0667*  ;     ld e,a
045E52             0668*  ;     pop af ; radius of player or laser sprite
045E52             0669*  ;     add a,e
045E52             0670*  ;     ld e,a
045E52             0671*  ;     and a ; clear carry
045E52             0672*  ;     sbc hl,de
045E52             0673*  ;     jr c,collision_enemy_is
045E52             0674*  ;     xor a
045E52             0675*  ;     ret
045E52             0676*  ; temp fix TODO: remove this
045E52 F1          0677*      pop af
045E53 F1          0678*      pop af
045E54 11 00 10 00 0679*      ld de,16*256
045E58 A7          0680*      and a
045E59 ED 52       0681*      sbc hl,de
045E5B 38 02       0682*      jr c,collision_enemy_is
045E5D AF          0683*      xor a
045E5E             0684*      ; call dumpRegistersHex
045E5E C9          0685*      ret
045E5F             0686*  collision_enemy_is:
045E5F AF          0687*      xor a
045E60 3C          0688*      inc a
045E61             0689*      ; call dumpRegistersHex
045E61 C9          0690*      ret
045E62             0691*  
045E62             0692*  ; ; looks up what enemy sprite collides with
045E62             0693*  ; ; detects collisions
045E62             0694*  ; ; and sets things to sploding accordingly
045E62             0695*  ; check_collisions:
045E62             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
045E62             0697*  ;     and a ; if this is zero,
045E62             0698*  ;     ret z ; there's nothing to do
045E62             0699*  ;     and %01 ; do we collide with player?
045E62             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
045E62             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
045E62             0702*  ;     and a ; was there a collision?
045E62             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
045E62             0704*  ; ; yes collision with player
045E62             0705*  ;     ; deduct shield damage
045E62             0706*  ;     ld hl,sprite_shield_damage
045E62             0707*  ;     ld a,(player_shields)
045E62             0708*  ;     sub (hl)
045E62             0709*  ;     ld (player_shields),a
045E62             0710*  ; ; if shields >= 0,player survives
045E62             0711*  ;     jp p,check_collisions_kill_nurple
045E62             0712*  ; ; otherwise update player status so it will die
045E62             0713*  ;     ld a,(player_collisions)
045E62             0714*  ;     or %10 ; sets bit 1,meaning player just died
045E62             0715*  ;     ld (player_collisions),a
045E62             0716*  ;     ; fall through
045E62             0717*  ; check_collisions_kill_nurple:
045E62             0718*  ; ; kill enemy and replace with explosion
045E62             0719*  ;     call kill_nurple
045E62             0720*  ;     ret ; and out
045E62             0721*  
045E62             0722*  check_collisions:
045E62 CD 20 5E 04 0723*      call collision_enemy_with_player ; did we hit the player?
045E66 A7          0724*      and a ; was there a collision?
045E67 C8          0725*      ret z ; if not,we're done
045E68 CD 02 5E 04 0726*      call kill_nurple ; otherwise kill enemy
045E6C C9          0727*      ret
045E6D             0728*  
045E6D             0729*  ; did we hit the laser?
045E6D             0730*  move_enemies_laser:
045E6D FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
045E70 E6 02       0732*      and %10 ; do we even collide with laser?
045E72 C8          0733*      ret z ; if not,we're out
045E73 3A 97 5E 04 0734*      ld a,(laser_collisions) ; is laser alive?
045E77 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
045E79 C8          0736*      ret z ; so we're out
045E7A CD 0D 5E 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
045E7E A7          0738*      and a ; was there a collision?
045E7F C8          0739*      ret z ; if not,we're done
045E80             0740*  ; otherwise we mark laser for termination and kill enemy
045E80             0741*  ; update laser status so it will die
045E80 3A 97 5E 04 0742*      ld a,(laser_collisions)
045E84 F6 02       0743*      or %10 ; bit 1 set means laser just died
045E86 32 97 5E 04 0744*      ld (laser_collisions),a
045E8A CD 02 5E 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
045E8E C9          0746*      ret ; we're outta' here
045E8F             0066   	include "laser.asm"
045E8F             0001*  ; ##### LASER SPRITE PARAMETERS #####
045E8F             0002*  ; uses the same offsets from its table base as the main sprite table:
045E8F             0003*  laser_start_variables: ; label marking beginning of table
045E8F 05          0004*  laser_id:               db table_max_records+1
045E90 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
045E91 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
045E94 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
045E97 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
045E98 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
045E99 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
045E9A 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
045E9D 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
045EA0 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045EA3 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045EA6 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
045EA9 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
045EAC 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
045EAF 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
045EB0 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
045EB1 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
045EB2 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
045EB3 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
045EB4 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
045EB5             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
045EB5             0025*  
045EB5             0026*  ; laser_control:
045EB5             0027*  ; ; is laser already active?
045EB5             0028*  ;     ld a,(laser_collisions)
045EB5             0029*  ;     and %00000001 ; bit zero is lit if laser is active
045EB5             0030*  ;     jr nz,laser_move ; move laser if not zero
045EB5             0031*  ; ; otherwise check if laser fired
045EB5             0032*  ;     in a,(#82) ; keyboard
045EB5             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
045EB5             0034*  ;     ret z ; go back if laser not fired
045EB5             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
045EB5             0036*  ; ; set laser status to active (set bit 0)
045EB5             0037*  ;     ld a,%1
045EB5             0038*  ;     ld (laser_collisions),a
045EB5             0039*  ; ; initialize laser position
045EB5             0040*  ;     ld a,(player_x+1) ; we only need the integer part
045EB5             0041*  ;     ; add a,6 ; horizontal center with player sprite
045EB5             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
045EB5             0043*  ;     ld a,(player_y+1) ; we only need the integer part
045EB5             0044*  ;     add a,-6 ; set laser y a few pixels above player
045EB5             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
045EB5             0046*  ;     ; fall through to laser_move
045EB5             0047*  
045EB5             0048*  ; laser_move:
045EB5             0049*  ; ; begin setting laser to active sprite
045EB5             0050*  ;     ld hl,lasers
045EB5             0051*  ;     ld (sprite_base_bufferId),hl
045EB5             0052*  ;     ld hl,0 ; north
045EB5             0053*  ;     ld (sprite_heading),hl
045EB5             0054*  ;     xor a ; laser has no animations yet :-(
045EB5             0055*  ;     ld (sprite_animation),a
045EB5             0056*  ;     ; we set position here for the time being as a default
045EB5             0057*  ;     ; in case the laser is flagged for deletion
045EB5             0058*  ;     ; load sprite_x with laser x position (we do y further down)
045EB5             0059*  ;     ld hl,(laser_x)
045EB5             0060*  ;     ld (sprite_x),hl
045EB5             0061*  ; ; did laser just die?
045EB5             0062*  ;     ld a,(laser_collisions)
045EB5             0063*  ;     bit 1,a ; z if laser didn't just die
045EB5             0064*  ;     jr z,laser_not_dead_yet
045EB5             0065*  ; ; yes laser died
045EB5             0066*  ;     call kill_laser
045EB5             0067*  ;     ret ; done
045EB5             0068*  ; laser_not_dead_yet:
045EB5             0069*  ; ; draw it
045EB5             0070*  ; ; update laser y position
045EB5             0071*  ;     ld hl,(laser_y) ; grab laser y position
045EB5             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
045EB5             0073*  ;     add hl,de ; add y velocity to y pos
045EB5             0074*  ;     ld (sprite_y),hl ; update laser y position
045EB5             0075*  ;     ld (laser_y),hl ; update laser y position
045EB5             0076*  ; ; are we at top of screen?
045EB5             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
045EB5             0078*  ;     sub h ; no carry if above threshold
045EB5             0079*  ;     jr c,finally_draw_the_frikken_laser
045EB5             0080*  ;     ; if at top of screen,laser dies
045EB5             0081*  ;     call kill_laser
045EB5             0082*  ;     ret
045EB5             0083*  ; ; otherwise,finally draw the frikken laser
045EB5             0084*  ; finally_draw_the_frikken_laser:
045EB5             0085*  ;     call vdu_bmp_select
045EB5             0086*  ;     call vdu_bmp_draw
045EB5             0087*  ; ; all done
045EB5             0088*  ;     ret
045EB5             0089*  
045EB5             0090*  ; kill_laser:
045EB5             0091*  ; ; update status to inactive
045EB5             0092*  ;     xor a ; zero out a
045EB5             0093*  ;     ld (laser_collisions),a
045EB5             0094*  ;     ret
045EB5             0067   	; include "temp.asm"
045EB5             0068   	include "vdp.inc"
045EB5 00 00 00    0001*  keycode_ptr:	dl	0
045EB8 00 00 00    0002*  frame_ptr:		dl	0
045EBB 00 00 00    0003*  vk_code:		dl	0
045EBE 00 00 00    0004*  key_up:			dl	0
045EC1             0005*  
045EC1 00          0006*  keycode:		db	0
045EC2 00          0007*  vk:				db	0
045EC3             0008*  
045EC3 00          0009*  c_up:			db	0
045EC4 00          0010*  c_dn:			db	0
045EC5 00          0011*  c_lf:			db	0
045EC6 00          0012*  c_rt:			db	0
045EC7             0013*  
045EC7             0014*  VK_U: 			equ 150
045EC7             0015*  VK_D: 			equ 152
045EC7             0016*  VK_L: 			equ 154
045EC7             0017*  VK_R: 			equ 156
045EC7             0018*  
045EC7             0019*  ; ############# MY MODIFICATIONS / ADDITIONS #############
045EC7             0020*  
045EC7             0021*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
045EC7             0022*  ; ; VDU 23, 7: Scrolling
045EC7             0023*  ; ;     VDU 23, 7, extent, direction, speed: Scroll the screen
045EC7             0024*  ; ; inputs: a, extent; l, direction; h; speed
045EC7             0025*  ; vdu_scroll_down:
045EC7             0026*  ; 	ld (@extent),a
045EC7             0027*  ; 	ld (@dir),hl ; implicitly populates @speed
045EC7             0028*  ; 	ld hl,@cmd
045EC7             0029*  ; 	ld bc,@end-@cmd
045EC7             0030*  ; 	rst.lil $18     ;; Sending command to VDP
045EC7             0031*  ; 	ret
045EC7             0032*  ; @cmd:       db 23,7
045EC7             0033*  ; @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
045EC7             0034*  ; @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
045EC7             0035*  ; @speed:     db 0x00 ; pixels
045EC7             0036*  ; @end:		db 0x00 ; padding
045EC7             0037*  
045EC7             0038*  
045EC7             0039*  ; ####### ROKKY ORIGINAL STUFF BELOW, WITH SOME COMMENTARY BY ME
045EC7             0040*  
045EC7             0041*  vdu_init:
045EC7             0042*  ; TODO: this is technically MOS stuff,and should live in mos_api.inc
045EC7             0043*  ; Get pointers to the MOS sysvars we'll be using,and stash
045EC7             0044*  ; their addresses as scratch variables in program space
045EC7             0045*  	MOSCALL mos_sysvars
045EC7 3E 08       0001*M 			LD	A, function
045EC9 49 CF       0002*M 			RST.LIS	08h
045ECB ED 22 05    0046*  	lea hl,ix+5
045ECE 22 B5 5E 04 0047*  	ld (keycode_ptr),hl
045ED2 ED 22 17    0048*  	lea hl,ix+$17
045ED5 22 BB 5E 04 0049*  	ld  (vk_code),hl
045ED9 ED 22 18    0050*  	lea hl,ix+$18
045EDC 22 BE 5E 04 0051*  	ld (key_up),hl
045EE0 DD 22 B8 5E 0052*  	ld (frame_ptr),ix
       04          
045EE5             0053*  ; ; set up a string of VDP commands and send them
045EE5             0054*  ; 	ld hl,vdu_init_cmd
045EE5             0055*  ; 	ld bc,vdu_init_end-vdu_init_cmd
045EE5             0056*  ; 	rst.lil $18
045EE5 C9          0057*  	ret
045EE6             0058*  ; vdu_init_cmd: db 22 ; set screen mode
045EE6             0059*  ; vdu_init_mode: db 0 ; presently self-modified in _main at startup
045EE6             0060*  ; 	db 23,1,0 ; Hide cursor
045EE6             0061*  ; 	db 23,0,$88 ; set keyboard mode?
045EE6             0062*  ; 	dw 250,33 ; no idea
045EE6             0063*  ; 	db 255 ; stumped here as well
045EE6             0064*  ; 	; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
045EE6             0065*  ; 	db 23,0,0xC0,0 ; 0 IS OFF
045EE6             0066*  ; vdu_init_end:
045EE6             0067*  
045EE6             0068*  vk_down:
045EE6 2A BB 5E 04 0069*  	ld hl,(vk_code)
045EEA 7E          0070*  	ld a,(hl)
045EEB             0071*  
045EEB 21 C3 5E 04 0072*  	ld hl,c_up
045EEF FE 96       0073*  	cp VK_U
045EF1 28 10       0074*  	jr z,@write
045EF3             0075*  
045EF3 23          0076*  	inc hl
045EF4 FE 98       0077*  	cp VK_D
045EF6 28 0B       0078*  	jr z,@write
045EF8             0079*  
045EF8 23          0080*  	inc hl
045EF9 FE 9A       0081*  	cp VK_L
045EFB 28 06       0082*  	jr z,@write
045EFD             0083*  
045EFD 23          0084*  	inc hl
045EFE FE 9C       0085*  	cp VK_R
045F00 28 01       0086*  	jr z,@write
045F02 C9          0087*  	ret
045F03             0088*  @write:
045F03 3E 01       0089*  	ld a,1
045F05 77          0090*  	ld (hl),a
045F06 C9          0091*  	ret
045F07             0092*  
045F07             0093*  vk_up:
045F07 2A BB 5E 04 0094*  	ld hl,(vk_code)
045F0B 7E          0095*  	ld a,(hl)
045F0C             0096*  
045F0C 21 C3 5E 04 0097*  	ld hl,c_up
045F10 FE 96       0098*  	cp VK_U
045F12 28 10       0099*  	jr z,@write
045F14             0100*  
045F14 23          0101*  	inc hl
045F15 FE 98       0102*  	cp VK_D
045F17 28 0B       0103*  	jr z,@write
045F19             0104*  
045F19 23          0105*  	inc hl
045F1A FE 9A       0106*  	cp VK_L
045F1C 28 06       0107*  	jr z,@write
045F1E             0108*  
045F1E 23          0109*  	inc hl
045F1F FE 9C       0110*  	cp VK_R
045F21 28 01       0111*  	jr z,@write
045F23 C9          0112*  	ret
045F24             0113*  @write:
045F24 AF          0114*  	xor a
045F25 77          0115*  	ld (hl),a
045F26 C9          0116*  	ret
045F27             0117*  
045F27             0118*  
045F27             0119*  get_key:
045F27 AF          0120*  	xor a
045F28 32 C1 5E 04 0121*  	ld (keycode),a
045F2C             0122*  
045F2C 2A BE 5E 04 0123*  	ld hl,(key_up)
045F30 7E          0124*  	ld a,(hl)
045F31 A7          0125*  	and a
045F32 28 D3       0126*  	jr z,vk_up
045F34             0127*  
045F34 CD E6 5E 04 0128*  	call vk_down
045F38             0129*  
045F38 2A B5 5E 04 0130*  	ld hl,(keycode_ptr)
045F3C 7E          0131*  	ld a,(hl)
045F3D 32 C1 5E 04 0132*  	ld (keycode),a
045F41 C9          0133*  	ret
045F42             0134*  
045F42             0135*  vsync:
045F42 2A B8 5E 04 0136*  	ld hl,(frame_ptr)
045F46 7E          0137*  	ld a,(hl)
045F47 F5          0138*  @wait:	push af
045F48 E5          0139*  	push hl
045F49 CD 27 5F 04 0140*  	call get_key
045F4D E1          0141*  	pop hl
045F4E F1          0142*  	pop af
045F4F BE          0143*  	cp (hl)
045F50 28 F5       0144*  	jr z,@wait
045F52 C9          0145*  	ret
045F53             0146*  
045F53             0147*  ; cursor_on:
045F53             0148*  ; 	ld hl,@cmd
045F53             0149*  ; 	ld bc,@end-@cmd
045F53             0150*  ; 	rst.lil $18
045F53             0151*  ; 	ret
045F53             0152*  ; @cmd:
045F53             0153*  ; 	db 23,1,1
045F53             0154*  ; @end:
045F53             0155*  
045F53             0156*  ; cursor_off:
045F53             0157*  ; 	ld hl,@cmd
045F53             0158*  ; 	ld bc,@end-@cmd
045F53             0159*  ; 	rst.lil $18
045F53             0160*  ; 	ret
045F53             0161*  ; @cmd:
045F53             0162*  ; 	db 23,1,0
045F53             0163*  ; @end:
045F53             0164*  
045F53             0165*  vdu_close:
045F53 21 5E 5F 04 0166*  	ld hl,@cmd
045F57 01 0A 00 00 0167*  	ld bc,@end-@cmd
045F5B 5B DF       0168*  	rst.lil $18
045F5D C9          0169*  	ret
045F5E             0170*  @cmd:
045F5E 16 00       0171*  	db 22,0
045F60 11 07 11 80 0172*  	db 17,7,17,$80
045F64 17 01 01    0173*  	db 23,1,1
045F67 0C          0174*  	db 12
045F68             0175*  @end:
045F68             0176*  
045F68             0177*  
045F68             0178*  ; vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
045F68             0179*  ; 			MOSCALL	mos_sysvars		; Fetch pointer to system variables
045F68             0180*  ; 			LD	A, (IX + sysvar_time + 0)
045F68             0181*  ; @wait:			CP 	A, (IX + sysvar_time + 0)
045F68             0182*  ; 			JR	Z, @wait
045F68             0183*  ; 			POP	IX
045F68             0184*  ; 			RET
045F68             0069   
045F68             0070   	include "vdu_sprites.inc"
045F68             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
045F68             0002*  ; the VDP can support up to 256 sprites. They must be defined
045F68             0003*  ; contiguously, and so the first sprite is sprite 0.
045F68             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
045F68             0005*  ; Once a selection of sprites have been defined, you can activate
045F68             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
045F68             0007*  ; of sprites to activate. This will activate the first n sprites,
045F68             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
045F68             0009*  
045F68             0010*  ; A single sprite can have multiple "frames", referring to
045F68             0011*  ; different bitmaps.
045F68             0012*  ; (These bitmaps do not need to be the same size.)
045F68             0013*  ; This allows a sprite to include an animation sequence,
045F68             0014*  ; which can be stepped through one frame at a time, or picked
045F68             0015*  ; in any order.
045F68             0016*  
045F68             0017*  ; Any format of bitmap can be used as a sprite frame. It should
045F68             0018*  ; be noted however that "native" format bitmaps are not
045F68             0019*  ; recommended for use as sprite frames, as they cannot get
045F68             0020*  ; erased from the screen. (As noted above, the "native" bitmap
045F68             0021*  ; format is not really intended for general use.) This is part
045F68             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
045F68             0023*  ; screen are now stored in RGBA2222 format.
045F68             0024*  
045F68             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
045F68             0026*  ; and then later shown again.
045F68             0027*  
045F68             0028*  ; Moving sprites around the screen is done by changing the
045F68             0029*  ; position of the sprite. This can be done either by setting
045F68             0030*  ; the absolute position of the sprite, or by moving the sprite
045F68             0031*  ; by a given number of pixels. (Sprites are positioned using
045F68             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
045F68             0033*  ; In the current sprite system, sprites will not update their
045F68             0034*  ; position on-screen until either another drawing operation is
045F68             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
045F68             0036*  
045F68             0037*  ; VDU 23, 27, 4, n: Select sprite n
045F68             0038*  ; inputs: a is the 8-bit sprite id
045F68             0039*  vdu_sprite_select:
045F68 32 7A 5F 04 0040*      ld (@sprite),a
045F6C 21 77 5F 04 0041*      ld hl,@cmd
045F70 01 04 00 00 0042*      ld bc,@end-@cmd
045F74 5B DF       0043*      rst.lil $18
045F76 C9          0044*      ret
045F77 17 1B 04    0045*  @cmd:    db 23,27,4
045F7A 00          0046*  @sprite: db 0x00
045F7B             0047*  @end:
045F7B             0048*  
045F7B             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
045F7B             0050*  ; inputs: none
045F7B             0051*  ; prerequisites: vdu_sprite_select
045F7B             0052*  vdu_sprite_clear_frames:
045F7B 21 86 5F 04 0053*      ld hl,@cmd
045F7F 01 03 00 00 0054*      ld bc,@end-@cmd
045F83 5B DF       0055*      rst.lil $18
045F85 C9          0056*      ret
045F86 17 1B 05    0057*  @cmd: db 23,27,5
045F89             0058*  @end:
045F89             0059*  
045F89             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045F89             0061*  ; inputs: a is the 8-bit bitmap number
045F89             0062*  ; prerequisites: vdu_sprite_select
045F89             0063*  vdu_sprite_add_bmp:
045F89 32 9B 5F 04 0064*      ld (@bmp),a
045F8D 21 98 5F 04 0065*      ld hl,@cmd
045F91 01 04 00 00 0066*      ld bc,@end-@cmd
045F95 5B DF       0067*      rst.lil $18
045F97 C9          0068*      ret
045F98 17 1B 06    0069*  @cmd: db 23,27,6
045F9B 00          0070*  @bmp: db 0x00
045F9C             0071*  @end:
045F9C             0072*  
045F9C             0073*  ; VDU 23, 27, 7, n: Activate n sprites
045F9C             0074*  ; inputs: a is the number of sprites to activate
045F9C             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
045F9C             0076*  vdu_sprite_activate:
045F9C 32 AE 5F 04 0077*      ld (@num),a
045FA0 21 AB 5F 04 0078*      ld hl,@cmd
045FA4 01 04 00 00 0079*      ld bc,@end-@cmd
045FA8 5B DF       0080*      rst.lil $18
045FAA C9          0081*      ret
045FAB 17 1B 07    0082*  @cmd: db 23,27,7
045FAE 00          0083*  @num: db 0x00
045FAF             0084*  @end:
045FAF             0085*  
045FAF             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
045FAF             0087*  ; inputs: none
045FAF             0088*  ; prerequisites: vdu_sprite_select
045FAF             0089*  vdu_sprite_next_frame:
045FAF 21 BA 5F 04 0090*      ld hl,@cmd
045FB3 01 03 00 00 0091*      ld bc,@end-@cmd
045FB7 5B DF       0092*      rst.lil $18
045FB9 C9          0093*      ret
045FBA 17 1B 08    0094*  @cmd: db 23,27,8
045FBD             0095*  @end:
045FBD             0096*  
045FBD             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
045FBD             0098*  ; inputs: none
045FBD             0099*  ; prerequisites: vdu_sprite_select
045FBD             0100*  vdu_sprite_prev_frame:
045FBD 21 C8 5F 04 0101*      ld hl,@cmd
045FC1 01 03 00 00 0102*      ld bc,@end-@cmd
045FC5 5B DF       0103*      rst.lil $18
045FC7 C9          0104*      ret
045FC8 17 1B 09    0105*  @cmd: db 23,27,9
045FCB             0106*  @end:
045FCB             0107*  
045FCB             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045FCB             0109*  ; inputs: a is frame number to select
045FCB             0110*  ; prerequisites: vdu_sprite_select
045FCB             0111*  vdu_sprite_select_frame:
045FCB 32 DD 5F 04 0112*      ld (@frame),a
045FCF 21 DA 5F 04 0113*      ld hl,@cmd
045FD3 01 04 00 00 0114*      ld bc,@end-@cmd
045FD7 5B DF       0115*      rst.lil $18
045FD9 C9          0116*      ret
045FDA 17 1B 0A    0117*  @cmd:    db 23,27,10
045FDD 00          0118*  @frame:  db 0x00
045FDE             0119*  @end:
045FDE             0120*  
045FDE             0121*  ; VDU 23, 27, 11: Show current sprite
045FDE             0122*  ; inputs: none
045FDE             0123*  ; prerequisites: vdu_sprite_select
045FDE             0124*  vdu_sprite_show:
045FDE 21 E9 5F 04 0125*      ld hl,@cmd
045FE2 01 03 00 00 0126*      ld bc,@end-@cmd
045FE6 5B DF       0127*      rst.lil $18
045FE8 C9          0128*      ret
045FE9 17 1B 0B    0129*  @cmd: db 23,27,11
045FEC             0130*  @end:
045FEC             0131*  
045FEC             0132*  ; VDU 23, 27, 12: Hide current sprite
045FEC             0133*  ; inputs: none
045FEC             0134*  ; prerequisites: vdu_sprite_select
045FEC             0135*  vdu_sprite_hide:
045FEC 21 F7 5F 04 0136*      ld hl,@cmd
045FF0 01 03 00 00 0137*      ld bc,@end-@cmd
045FF4 5B DF       0138*      rst.lil $18
045FF6 C9          0139*      ret
045FF7 17 1B 0C    0140*  @cmd: db 23,27,12
045FFA             0141*  @end:
045FFA             0142*  
045FFA             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045FFA             0144*  ; inputs: bc is x coordinate, de is y coordinate
045FFA             0145*  ; prerequisites: vdu_sprite_select
045FFA             0146*  vdu_sprite_move_abs:
045FFA ED 43 12 60 0147*      ld (@xpos),bc
       04          
045FFF ED 53 14 60 0148*      ld (@ypos),de
       04          
046004 21 0F 60 04 0149*      ld hl,@cmd
046008 01 07 00 00 0150*      ld bc,@end-@cmd
04600C 5B DF       0151*      rst.lil $18
04600E C9          0152*      ret
04600F 17 1B 0D    0153*  @cmd:  db 23,27,13
046012 00 00       0154*  @xpos: dw 0x0000
046014 00 00       0155*  @ypos: dw 0x0000
046016 00          0156*  @end:  db 0x00 ; padding
046017             0157*  
046017             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
046017             0159*  ; inputs: bc is x coordinate, de is y coordinate
046017             0160*  ; prerequisites: vdu_sprite_select
046017             0161*  vdu_sprite_move_rel:
046017 ED 43 2F 60 0162*      ld (@dx),bc
       04          
04601C ED 53 31 60 0163*      ld (@dy),de
       04          
046021 21 2C 60 04 0164*      ld hl,@cmd
046025 01 07 00 00 0165*      ld bc,@end-@cmd
046029 5B DF       0166*      rst.lil $18
04602B C9          0167*      ret
04602C 17 1B 0E    0168*  @cmd: db 23,27,14
04602F 00 00       0169*  @dx:  dw 0x0000
046031 00 00       0170*  @dy:  dw 0x0000
046033 00          0171*  @end: db 0x00 ; padding
046034             0172*  
046034             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
046034             0174*  ; USING 16.8 FIXED POINT COORDINATES
046034             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
046034             0176*  ;   the fractional portiion of the inputs are truncated
046034             0177*  ;   leaving only the 16-bit integer portion
046034             0178*  ; prerequisites: vdu_sprite_select
046034             0179*  vdu_sprite_move_abs168:
046034             0180*  ; populate in the reverse of normal to keep the
046034             0181*  ; inputs from stomping on each other
046034 ED 53 53 60 0182*      ld (@ypos-1),de
       04          
046039 ED 43 51 60 0183*      ld (@xpos-1),bc
       04          
04603E 3E 0D       0184*      ld a,13       ; restore the final byte of the command
046040 32 51 60 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
046044 21 4F 60 04 0186*      ld hl,@cmd
046048 01 07 00 00 0187*      ld bc,@end-@cmd
04604C 5B DF       0188*      rst.lil $18
04604E C9          0189*      ret
04604F 17 1B 0D    0190*  @cmd:  db 23,27,13
046052 00 00       0191*  @xpos: dw 0x0000
046054 00 00       0192*  @ypos: dw 0x0000
046056             0193*  @end:  ; no padding required b/c we shifted de right
046056             0194*  
046056             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
046056             0196*  ; USING 16.8 FIXED POINT COORDINATES
046056             0197*  ; inputs: ub.c is dx, ud.e is dy
046056             0198*  ;   the fractional portiion of the inputs are truncated
046056             0199*  ;   leaving only the 16-bit integer portion
046056             0200*  ; prerequisites: vdu_sprite_select
046056             0201*  vdu_sprite_move_rel168:
046056             0202*  ; populate in the reverse of normal to keep the
046056             0203*  ; inputs from stomping on each other
046056 ED 53 75 60 0204*      ld (@dy-1),de
       04          
04605B ED 43 73 60 0205*      ld (@dx-1),bc
       04          
046060 3E 0E       0206*      ld a,14       ; restore the final byte of the command
046062 32 73 60 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
046066 21 71 60 04 0208*      ld hl,@cmd
04606A 01 07 00 00 0209*      ld bc,@end-@cmd
04606E 5B DF       0210*      rst.lil $18
046070 C9          0211*      ret
046071 17 1B 0E    0212*  @cmd:  db 23,27,14
046074 00 00       0213*  @dx: dw 0x0000
046076 00 00       0214*  @dy: dw 0x0000
046078             0215*  @end:  ; no padding required b/c we shifted de right
046078             0216*  
046078             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
046078             0218*  ; inputs: none
046078             0219*  vdu_sprite_update:
046078 21 83 60 04 0220*      ld hl,@cmd
04607C 01 03 00 00 0221*      ld bc,@end-@cmd
046080 5B DF       0222*      rst.lil $18
046082 C9          0223*      ret
046083 17 1B 0F    0224*  @cmd: db 23,27,15
046086             0225*  @end:
046086             0226*  
046086             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
046086             0228*  ; inputs: none
046086             0229*  vdu_sprite_bmp_reset:
046086 21 91 60 04 0230*      ld hl,@cmd
04608A 01 03 00 00 0231*      ld bc,@end-@cmd
04608E 5B DF       0232*      rst.lil $18
046090 C9          0233*      ret
046091 17 1B 10    0234*  @cmd: db 23,27,16
046094             0235*  @end:
046094             0236*  
046094             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
046094             0238*  ; inputs: none
046094             0239*  vdu_sprite_reset:
046094 21 9F 60 04 0240*      ld hl,@cmd
046098 01 03 00 00 0241*      ld bc,@end-@cmd
04609C 5B DF       0242*      rst.lil $18
04609E C9          0243*      ret
04609F 17 1B 11    0244*  @cmd: db 23,27,17
0460A2             0245*  @end:
0460A2             0246*  
0460A2             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0460A2             0248*  ; inputs: a is the GCOL paint mode
0460A2             0249*  ; prerequisites: vdu_sprite_select
0460A2             0250*  vdu_sprite_set_gcol:
0460A2 32 B4 60 04 0251*      ld (@mode),a
0460A6 21 B1 60 04 0252*      ld hl,@cmd
0460AA 01 04 00 00 0253*      ld bc,@end-@cmd
0460AE 5B DF       0254*      rst.lil $18
0460B0 C9          0255*      ret
0460B1 17 1B 12    0256*  @cmd:  db 23,27,18
0460B4 00          0257*  @mode: db 0x00
0460B5             0258*  @end:
0460B5             0259*  
0460B5             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0460B5             0261*  ; inputs: hl=bufferId
0460B5             0262*  ; prerequisites: vdu_sprite_select
0460B5             0263*  vdu_sprite_add_buff:
0460B5 22 C7 60 04 0264*      ld (@bufferId),hl
0460B9 21 C4 60 04 0265*      ld hl,@cmd
0460BD 01 05 00 00 0266*      ld bc,@end-@cmd
0460C1 5B DF       0267*      rst.lil $18
0460C3 C9          0268*      ret
0460C4 17 1B 26    0269*  @cmd:      db 23,27,0x26
0460C7 00 00       0270*  @bufferId: dw 0x0000
0460C9 00          0271*  @end:      db 0x00 ; padding
0460CA             0071   	include "maths.inc"
0460CA             0001*  ;------------------------------------------------------------------------
0460CA             0002*  ; Scratch area for calculations
0460CA             0003*  ;------------------------------------------------------------------------
0460CA 00 00 00    0004*  scratch1:	dw24	0	;bit manipulation buffer 1
0460CD 00 00 00    0005*  scratch2:	dw24	0	;bit manipulation buffer 2
0460D0             0006*  
0460D0             0007*  ; absolute value of hlu
0460D0             0008*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0460D0             0009*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0460D0             0010*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0460D0             0011*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0460D0             0012*  ; destroys: a
0460D0             0013*  hlu_abs:
0460D0 19          0014*      add hl,de
0460D1 B7          0015*      or a
0460D2 ED 52       0016*      sbc hl,de
0460D4 FA D9 60 04 0017*      jp m,@is_neg
0460D8 C9          0018*      ret         ; hlu is positive or zero so we're done
0460D9             0019*  @is_neg:
0460D9 F5          0020*      push af     ; otherwise, save current flags for return
0460DA CD E0 60 04 0021*      call neg_hlu ; negate hlu
0460DE F1          0022*      pop af      ; get back flags
0460DF C9          0023*      ret
0460E0             0024*  
0460E0             0025*  ; flip the sign of hlu
0460E0             0026*  ; inputs: hlu
0460E0             0027*  ; returns: 0-hlu, flags set appropriately for the result:
0460E0             0028*  ;         s1,z0,pv0,n1,c1 if result is negative
0460E0             0029*  ;         s0,z1,pv0,n1,c0 if result is zero
0460E0             0030*  ;         s0,z0,pv0,n1,c1 if result is positive
0460E0             0031*  ; destroys a
0460E0             0032*  neg_hlu:
0460E0 D5          0033*      push de     ; save de
0460E1 EB          0034*      ex de,hl    ; put hl into de
0460E2 21 00 00 00 0035*      ld hl,0     ; clear hl
0460E6 AF          0036*      xor a       ; clear carry
0460E7 ED 52       0037*      sbc hl,de   ; 0-hlu = -hlu
0460E9 D1          0038*      pop de      ; get de back
0460EA C9          0039*      ret         ; easy peasy
0460EB             0040*  
0460EB             0041*  ;------------------------------------------------------------------------
0460EB             0042*  ; divide hlu by 2, inspired by above
0460EB             0043*  ;------------------------------------------------------------------------
0460EB             0044*  hlu_div2:
0460EB 22 CA 60 04 0045*  	ld		(scratch1),hl
0460EF 21 CC 60 04 0046*  	ld		hl,scratch1+2
0460F3 CB 1E       0047*  	rr		(hl)
0460F5 2B          0048*  	dec		hl
0460F6 CB 1E       0049*  	rr		(hl)
0460F8 2B          0050*  	dec		hl
0460F9 CB 1E       0051*  	rr		(hl)
0460FB 23          0052*  	inc		hl
0460FC 23          0053*  	inc		hl
0460FD 2A CA 60 04 0054*      ld hl,(scratch1)
046101 C9          0055*      ret
046102             0056*  
046102             0057*  ; this is my little hack to divide by 16
046102             0058*  hlu_div16:
046102 AF          0059*      xor a
046103 29          0060*      add hl,hl
046104 17          0061*      rla
046105 29          0062*      add hl,hl
046106 17          0063*      rla
046107 29          0064*      add hl,hl
046108 17          0065*      rla
046109 29          0066*      add hl,hl
04610A 17          0067*      rla
04610B 22 18 61 04 0068*      ld (@scratch),hl
04610F 32 1B 61 04 0069*      ld (@scratch+3),a
046113 2A 19 61 04 0070*      ld hl,(@scratch+1)
046117 C9          0071*      ret
046118             0072*  @scratch: ds 4
04611C             0073*  
04611C             0074*  ; hlu signed division by 256
04611C             0075*  ; returns: hlu / 256
04611C             0076*  ; destroys: af
04611C             0077*  hlu_sdiv256:
04611C AF          0078*      xor a ; assume hl is positive
04611D 22 33 61 04 0079*      ld (@buffer),hl
046121             0080*      sign_hlu
046121 19          0001*M         add hl,de
046122 B7          0002*M         or a
046123 ED 52       0003*M         sbc hl,de
046125 F2 2A 61 04 0081*      jp p,@hl_pos
046129 3D          0082*      dec a
04612A             0083*  @hl_pos:
04612A 32 36 61 04 0084*      ld (@buffer+3),a
04612E 2A 34 61 04 0085*      ld hl,(@buffer+1)
046132 C9          0086*      ret
046133             0087*  @buffer: ds 4
046137             0088*  
046137             0089*  ; hlu 1 byte right shift, unsigned
046137             0090*  ; returns: hlu / 256, fractional portion in a
046137             0091*  ; destroys: af
046137             0092*  hlu_udiv256:
046137 AF          0093*  	xor a
046138 32 49 61 04 0094*  	ld (@buffer+3),a
04613C 7D          0095*  	ld a,l ; save the fractional portion
04613D 22 46 61 04 0096*  	ld (@buffer),hl
046141 2A 47 61 04 0097*  	ld hl,(@buffer+1)
046145 C9          0098*  	ret
046146             0099*  @buffer: ds 4
04614A             0100*  
04614A             0101*      MACRO hlu_mul256
04614A             0102*          add hl,hl ; * 2
04614A             0103*          add hl,hl ; * 4
04614A             0104*          add hl,hl ; * 8
04614A             0105*          add hl,hl ; * 16
04614A             0106*          add hl,hl ; * 32
04614A             0107*          add hl,hl ; * 64
04614A             0108*          add hl,hl ; * 128
04614A             0109*          add hl,hl ; * 256
04614A             0110*      ENDMACRO
04614A             0111*  
04614A             0112*  ; compute the modulo of hlu by deu
04614A             0113*  ; outputs: hlu = hlu % deu
04614A             0114*  ; destroys: f, hl
04614A             0115*  hlu_mod:
04614A B7          0116*  	or a ; clear carry
04614B             0117*  @loop:
04614B ED 52       0118*      sbc hl,de
04614D DA 55 61 04 0119*      jp c, @end
046151 C3 4B 61 04 0120*      jp @loop
046155             0121*  @end:
046155 19          0122*      add hl,de
046156 C9          0123*  	ret
046157             0124*  
046157             0125*  
046157 00 00 00 00 0126*  add_bcd_arg1: db #00,#00,#00,#00
04615B 00 00 00 00 0127*  add_bcd_arg2: db #00,#00,#00,#00
04615F             0128*  
04615F             0129*  ; set bcd values in a scratch memory address from registers bcde
04615F             0130*  ; input: hl; scratch address,bcde; 8-place bcd number
04615F             0131*  ; destroys ; hl
04615F             0132*  set_bcd:
04615F 73          0133*      ld (hl),e
046160 23          0134*      inc hl
046161 72          0135*      ld (hl),d
046162 23          0136*      inc hl
046163 71          0137*      ld (hl),c
046164 23          0138*      inc hl
046165 70          0139*      ld (hl),b
046166 C9          0140*      ret
046167             0141*  
046167             0142*  ; load bcd values from a scratch memory address to bcde
046167             0143*  ; input: hl; scratch address
046167             0144*  ; output: bcde; 8-place bcd number
046167             0145*  ; destroys: hl
046167             0146*  get_bcd:
046167 5E          0147*      ld e,(hl)
046168 23          0148*      inc hl
046169 56          0149*      ld d,(hl)
04616A 23          0150*      inc hl
04616B 4E          0151*      ld c,(hl)
04616C 23          0152*      inc hl
04616D 46          0153*      ld b,(hl)
04616E C9          0154*      ret
04616F             0155*  
04616F             0156*  ; BCD addition
04616F             0157*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04616F             0158*  ;       a is the number of bytes holding each number (number of places/2)
04616F             0159*  ; outputs: (hl) + (de) --> (hl)
04616F             0160*  ; destroys: a,b,de,hl
04616F             0161*  add_bcd:
04616F 47          0162*      ld b,a ; loop counter
046170 AF          0163*      xor a ; reset a, clear carry flag
046171             0164*  adcec:
046171 1A          0165*      ld a,(de) ; addend to acc
046172 8E          0166*      adc a,(hl) ; add (hl) to acc
046173 27          0167*      daa ; adjust result to bcd
046174 77          0168*      ld (hl),a ; store result
046175 23          0169*      inc hl ; advance memory pointers
046176 13          0170*      inc de
046177 10 F8       0171*      djnz adcec ; loop until b == 0
046179 C9          0172*      ret
04617A             0173*  
04617A             0174*  ; BCD subtraction
04617A             0175*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04617A             0176*  ;       a is the number of bytes holding each number (number of places/2)
04617A             0177*  ; outputs: (hl) - (de) --> (hl)
04617A             0178*  ; destroys: a,b,de,hl
04617A             0179*  sub_bcd:
04617A 47          0180*      ld b,a ; loop counter
04617B AF          0181*      xor a ; reset a,clear carry flag
04617C             0182*  subdec:
04617C 1A          0183*      ld a,(de) ; subtrahend to acc
04617D 9E          0184*      sbc a,(hl) ; subtract (hl) from acc
04617E 27          0185*      daa ; adjust result to bcd
04617F 77          0186*      ld (hl),a ; store result
046180 23          0187*      inc hl ; advance memory pointers
046181 13          0188*      inc de
046182 10 F8       0189*      djnz subdec ; loop until b == 0
046184 C9          0190*      ret
046185             0191*  
046185             0192*  ; http://www.z80.info/pseudo-random.txt
046185             0193*  rand_8:
046185 C5          0194*      push bc
046186 3A 99 61 04 0195*      ld a,(r_seed)
04618A 4F          0196*      ld c,a
04618B             0197*  
04618B 0F          0198*      rrca ; multiply by 32
04618C 0F          0199*      rrca
04618D 0F          0200*      rrca
04618E EE 1F       0201*      xor 0x1f
046190             0202*  
046190 81          0203*      add a,c
046191 DE FF       0204*      sbc a,255 ; carry
046193             0205*  
046193 32 99 61 04 0206*      ld (r_seed),a
046197 C1          0207*      pop bc
046198 C9          0208*      ret
046199 50          0209*  r_seed: defb $50
04619A             0072   	include "files.inc"
04619A             0001*  ; load to onboard 8k sram
04619A             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04619A             0073   	include "fixed24.inc"
04619A             0001*  arith24uaf: ds 6
0461A0             0002*  arith24uhl: ds 6
0461A6             0003*  arith24ubc: ds 6
0461AC             0004*  arith24ude: ds 6
0461B2             0005*  arith24uix: ds 6
0461B8             0006*  arith24uiy: ds 6
0461BE             0007*  arith24usp: ds 6
0461C4             0008*  arith24upc: ds 6
0461CA             0009*  
0461CA             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
0461CA             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
0461CA             0012*  ; inputs: hlu = 24-bit number to shift
0461CA             0013*  ;         a = signed number of bits to shift
0461CA             0014*  ;         ix = output buffer address
0461CA             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
0461CA             0016*  shift_hlu:
0461CA C5          0017*      push bc ; preserve
0461CB 47          0018*      ld b,a            ; store shift value in b for later
0461CC             0019*  
0461CC             0020*  ; Initialize DE to zero and clear output buffer
0461CC 11 00 00 00 0021*      ld de, 0
0461D0 DD 1F FD    0022*      ld (ix-3), de
0461D3 DD 1F 03    0023*      ld (ix+3), de
0461D6             0024*  
0461D6             0025*  ; Get absolute value of a and save its original sign
0461D6 B7          0026*      or a
0461D7 F5          0027*      push af ; save sign flag
0461D8 F2 DE 61 04 0028*      jp p,@F ; If a is positive do nothing
0461DC ED 44       0029*      neg ; If a is negative, negate it
0461DE             0030*  @@:
0461DE             0031*  
0461DE             0032*  ; Write abs(HLU) to the output buffer and save its original sign
0461DE CD D0 60 04 0033*      call hlu_abs
0461E2 F5          0034*      push af ; save sign of HLU
0461E3 DD 2F 00    0035*      ld (ix), hl
0461E6             0036*  
0461E6             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
0461E6 78          0038*      ld a,b            ; Restore original shift value into 'a'
0461E7 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
0461E9 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
0461EB CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
0461ED 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
0461EE             0043*  
0461EE             0044*  ; Calculate remainder of a (original shift) mod 8
0461EE E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0461F0 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
0461F1 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
0461F5             0048*  
0461F5             0049*      ; call dumpRegistersHex ; DEBUG
0461F5             0050*  
0461F5             0051*  ; Get back the original sign of the byte shift
0461F5 F1          0052*      pop af            ; Restore sign flag
0461F6 F2 04 62 04 0053*      jp p,@F           ; If a was positive, we're done
0461FA 79          0054*      ld a,c            ; 'a' now holds the number of whole bytes to shift
0461FB ED 44       0055*      neg               ; Negate the number of whole bytes to shift
0461FD 3D          0056*      dec a             ; Subtract 1 because that's just how this works
0461FE 4F          0057*      ld c,a            ; 'c' now holds the number of whole bytes to shift
0461FF 1B          0058*      dec de            ; DE = -1 to make the signed addition below work
046200 3E 08       0059*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
046202 90          0060*      sub b
046203 47          0061*      ld b,a            ; b is the number of bits to shift back up
046204             0062*  
046204             0063*      ; call dumpRegistersHex ; DEBUG
046204             0064*  
046204             0065*  @@:
046204             0066*  
046204             0067*  ; Add the byte offset to the base address of output buffer
046204 59          0068*      ld e,c            ; DEU and D were properly signed above
046205 DD 19       0069*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
046207             0070*  
046207             0071*      ; call dumpRegistersHex ; DEBUG
046207             0072*  
046207             0073*  ; Read the byte-aligned result into HL and shift in the required number of bits
046207 DD 27 00    0074*      ld hl,(ix)        ; Byte-aligned result
04620A             0075*  
04620A CD FE 54 04 0076*      call dumpRegistersHex ; DEBUG
04620E             0077*  
04620E             0078*  ; Check whether we're already byte-aligned
04620E AF          0079*      xor a
04620F B0          0080*      or b
046210 28 10       0081*      jr z,@end         ; If no bits to shift, we're done
046212             0082*  
046212             0083*  ; Otherwise shiften zee bitzen
046212 DD 7E FF    0084*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
046215             0085*  @loop:
046215 07          0086*      rlca              ; One bit to carry
046216             0087*  
046216 CD 8C 56 04 0088*      call dumpFlags ; DEBUG
04621A             0089*  
04621A ED 6A       0090*      adc hl,hl         ; Shift the carry into the result
04621C             0091*  
04621C CD FE 54 04 0092*      call dumpRegistersHex ; DEBUG
046220             0093*  
046220 10 F3       0094*      djnz @loop        ; Loop until all bits are shifted up
046222             0095*  
046222             0096*  @end:
046222             0097*  
046222 CD FE 54 04 0098*      call dumpRegistersHex ; DEBUG
046226             0099*  
046226             0100*  ; get back HLU's original sign and negate if necessary
046226 F1          0101*      pop af
046227 F2 2F 62 04 0102*      jp p,@F
04622B CD E0 60 04 0103*      call neg_hlu
04622F             0104*  @@:
04622F             0105*  ; return the result
04622F DD 2F 00    0106*      ld (ix),hl        ; Store the shifted result
046232 C1          0107*      pop bc              ; Restore BC
046233 C9          0108*      ret
046234             0109*  
046234             0110*  ; operation: UHL * UDE --> UHL
046234             0111*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
046234             0112*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
046234             0113*  ; inputs: hl = 24-bit number, de = 24-bit number,
046234             0114*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
046234             0115*  ; outputs: umulfxout = 48-bit intermediate
046234             0116*  ; destroys: af, hl, bc, de
046234             0117*  umulfx:
046234 DD E5       0118*      push ix ; preserve
046236 F5          0119*      push af ; need later
046237             0120*  
046237             0121*  ; do the multiplication
046237 CD F8 62 04 0122*      call umul24x24
04623B             0123*      ; DEBUG
04623B 21 8D 62 04 0124*      ld hl,umulfxout ; point to output buffer
04623F 3E 06       0125*      ld a,6 ; 6 bytes to print
046241 CD F2 56 04 0126*      call dumpMemoryHex ; print the result
046245             0127*      ; END DEBUG
046245             0128*  
046245             0129*  ; shift the result to the required output precision
046245 78          0130*      ld a,b
046246 81          0131*      add a,c ; a is left shift from the multiplication
046247 C1          0132*      pop bc ; b is the output precision (was a)
046248 90          0133*      sub b ; a is the net shift of the output
046249             0134*  
046249             0135*  ; Get absolute value of a and save its original sign
046249 B7          0136*      or a
04624A F5          0137*      push af ; save sign flag
04624B F2 51 62 04 0138*      jp p,@F ; If a is positive do nothing
04624F ED 44       0139*      neg ; If a is negative, negate it
046251             0140*  @@:
046251             0141*  
046251             0142*  ; Divide a by 8 to get the whole byte shift and bit remainder
046251 47          0143*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
046252 CB 3F       0144*      srl a             ; a = a / 2 (shift right 1 bit)
046254 CB 3F       0145*      srl a             ; a = a / 4 (shift right another bit)
046256 CB 3F       0146*      srl a             ; a = a / 8 (final shift for division by 8)
046258 4F          0147*      ld c,a            ; c holds the number of whole bytes to shift
046259             0148*  
046259             0149*  ; Calculate remainder of a (original shift) mod 8
046259 78          0150*      ld a,b            ; Restore original shift value into 'a'
04625A E6 07       0151*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
04625C 47          0152*      ld b,a            ; 'b' now holds the number of bits to shift back up
04625D 11 00 00 00 0153*      ld de,0           ; Clear deu for computing the offset address later
046261             0154*  
046261             0155*      ; call dumpRegistersHex ; DEBUG
046261             0156*  
046261             0157*  ; Get back the original sign of the byte shift
046261 F1          0158*      pop af            ; Restore sign flag
046262 F2 70 62 04 0159*      jp p,@F           ; If a was positive, we're done
046266 79          0160*      ld a,c            ; 'a' now holds the number of whole bytes to shift
046267 ED 44       0161*      neg               ; Negate the number of whole bytes to shift
046269 3D          0162*      dec a             ; Subtract 1 because that's just how this works
04626A 4F          0163*      ld c,a            ; 'c' now holds the number of whole bytes to shift
04626B 1B          0164*      dec de            ; DE = -1 to make the signed addition below work
04626C 3E 08       0165*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
04626E 90          0166*      sub b
04626F 47          0167*      ld b,a            ; b is the number of bits to shift back up
046270             0168*  
046270             0169*      ; call dumpRegistersHex ; DEBUG
046270             0170*  
046270             0171*  @@:
046270             0172*  
046270             0173*  ; Add the byte offset to the base address of umulfxout
046270 59          0174*      ld e,c            ; DEU and D were properly signed above
046271 DD 21 8D 62 0175*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
046276 DD 19       0176*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
046278             0177*  
046278             0178*      ; call dumpRegistersHex ; DEBUG
046278             0179*  
046278             0180*  ; Read the byte-aligned result into HL and shift in the required number of bits
046278 DD 27 00    0181*      ld hl,(ix)        ; Byte-aligned result
04627B DD 7E FF    0182*      ld a,(ix-1)       ; One byte below
04627E             0183*  
04627E             0184*  ; Check whether we're already byte-aligned
04627E AF          0185*      xor a
04627F B0          0186*      or b
046280 28 05       0187*      jr z,@end         ; If no bits to shift, we're done
046282             0188*  
046282             0189*  ; Otherwise shiften zee bitzen
046282             0190*  @loop:
046282             0191*  
046282             0192*      ; call dumpRegistersHex ; DEBUG
046282             0193*  
046282 07          0194*      rlca              ; One bit to carry
046283 ED 6A       0195*      adc hl,hl         ; Shift the carry into the result
046285             0196*  
046285 10 FB       0197*      djnz @loop        ; Loop until all bits are shifted up
046287             0198*  
046287             0199*  @end:
046287             0200*  ; return the result
046287 DD E1       0201*      pop ix ; restore
046289 C9          0202*      ret
04628A             0203*  
04628A 00 00 00    0204*      dl 0 ; padding
04628D 00 00 00 00 0205*  umulfxout: blkb 6,0
       00 00       
046293 00 00 00    0206*      dl 0 ; padding
046296             0207*  
046296             0208*  ; operation: UHL * UDE --> UHL
046296             0209*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
046296             0210*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
046296             0211*  ; inputs: hl = 24-bit number, de = 24-bit number,
046296             0212*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
046296             0213*  ; outputs: umulfxout = 48-bit intermediate
046296             0214*  ; destroys: af, hl, bc, de
046296             0215*  smulfx:
046296             0216*  ; make everything positive and store sign flags
046296 CD D0 60 04 0217*  	call hlu_abs
04629A F5          0218*  	push af
04629B EB          0219*  	ex de,hl
04629C CD D0 60 04 0220*  	call hlu_abs
0462A0 EB          0221*  	ex de,hl
0462A1 F5          0222*  	push af
0462A2             0223*  ; do the division
0462A2 CD 34 62 04 0224*      call umulfx ; hl = product
0462A6             0225*  ; adjust sign of result
0462A6 F1          0226*  	pop af ; sign de
0462A7 FA B2 62 04 0227*  	jp m,@de_neg
0462AB F1          0228*  	pop af ; sign hl
0462AC F0          0229*  	ret p ; both positive, nothing to do
0462AD             0230*  @hl_neg:
0462AD CD E0 60 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
0462B1 C9          0232*      ret
0462B2             0233*  @de_neg:
0462B2 F1          0234*  	pop af
0462B3 F8          0235*  	ret m ; both negative, nothing to do
0462B4 CD E0 60 04 0236*  	call neg_hlu ; result is negative
0462B8 C9          0237*  	ret
0462B9             0238*  
0462B9             0239*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0462B9             0240*  ; uses EZ80 MLT instruction for speed
0462B9             0241*  ; operation: UHL * A --> UHL
0462B9             0242*  ; destroys: AF, HL
0462B9             0243*  smul24x8:
0462B9             0244*  ; make hl positive and store sign flag
0462B9 CD D0 60 04 0245*  	call hlu_abs
0462BD F5          0246*  	push af
0462BE             0247*  ; do the division
0462BE CD C9 62 04 0248*      call umul24x8 ; hl = product
0462C2             0249*  ; adjust sign of result
0462C2 F1          0250*  	pop af ; sign de
0462C3 F0          0251*  	ret p ; hl was positive, nothing to do
0462C4 CD E0 60 04 0252*  	call neg_hlu ; result is negative
0462C8 C9          0253*  	ret
0462C9             0254*  
0462C9             0255*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0462C9             0256*  ; uses EZ80 MLT instruction for speed
0462C9             0257*  ; operation: UHL * A --> AUHL
0462C9             0258*  ; destroys: AF, HL
0462C9             0259*  umul24x8:
0462C9 D5          0260*  	push de ; preserve de
0462CA             0261*  ; low byte
0462CA 5D          0262*  	ld e,l
0462CB 57          0263*  	ld d,a
0462CC ED 5C       0264*  	mlt de
0462CE 6B          0265*  	ld l,e ; product low byte
0462CF 08          0266*  	ex af,af' ; save multiplier
0462D0 7A          0267*  	ld a,d ; carry
0462D1 08          0268*  	ex af,af' ; save carry, restore multiplier
0462D2             0269*  ; high byte
0462D2 5C          0270*  	ld e,h
0462D3 57          0271*  	ld d,a
0462D4 ED 5C       0272*  	mlt de
0462D6 08          0273*  	ex af,af' ; save multiplier, restore carry
0462D7 83          0274*  	add a,e ; add carry
0462D8 67          0275*  	ld h,a ; product middle byte
0462D9 7A          0276*  	ld a,d ; carry
0462DA 08          0277*  	ex af,af' ; save carry, restore multiplier
0462DB             0278*  ; upper byte
0462DB E5          0279*  	push hl
0462DC 33          0280*  	inc sp
0462DD D1          0281*  	pop de ; d = hlu
0462DE 3B          0282*  	dec sp
0462DF 5F          0283*  	ld e,a
0462E0 ED 5C       0284*  	mlt de
0462E2 08          0285*  	ex af,af' ; restore carry
0462E3 8B          0286*  	adc a,e ; add carry
0462E4 22 F5 62 04 0287*      ld (@scratch),hl ; 7 cycles
0462E8 32 F7 62 04 0288*      ld (@scratch+2),a ; 5 cycles
0462EC 2A F5 62 04 0289*      ld hl,(@scratch) ; 7 cycles
0462F0             0290*  ; highest byte
0462F0 3E 00       0291*  	ld a,0 ; preserve carry flag
0462F2 8A          0292*  	adc a,d ; product highest byte
0462F3 D1          0293*  	pop de ; restore de
0462F4 C9          0294*  	ret
0462F5             0295*  @scratch: ds 3
0462F8             0296*  
0462F8             0297*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0462F8             0298*  ; operation: UHL * UDE --> umulfxout
0462F8             0299*  umul24x24:
0462F8 FD 21 8D 62 0300*  	ld iy,umulfxout ; point to output buffer
       04          
0462FD C5          0301*  	push bc
0462FE 01 00 00 00 0302*  	ld bc,0
046302 FD 0F 00    0303*  	ld (iy),bc
046305 FD 0F 03    0304*  	ld (iy+3),bc
046308 C1          0305*  	pop bc
046309             0306*  
046309             0307*  ; STEP 1: UHL * E
046309 7B          0308*  	ld a,e
04630A E5          0309*  	push hl
04630B CD C9 62 04 0310*  	call umul24x8
04630F FD 2F 00    0311*  	ld (iy+0),hl
046312 FD 77 03    0312*  	ld (iy+3),a
046315             0313*  
046315             0314*  ; STEP 2: UHL * D
046315 E1          0315*  	pop hl
046316 E5          0316*  	push hl
046317 7A          0317*  	ld a,d
046318 CD C9 62 04 0318*  	call umul24x8
04631C CD 29 63 04 0319*  	call @accumulate
046320             0320*  
046320             0321*  ; STEP 3: UHL * DEU
046320 E1          0322*  	pop hl
046321 D5          0323*  	push de
046322 33          0324*  	inc sp
046323 F1          0325*  	pop af
046324 3B          0326*  	dec sp
046325 CD C9 62 04 0327*  	call umul24x8
046329             0328*  
046329             0329*  @accumulate:
046329 FD 23       0330*  	inc iy
04632B             0331*  ; highest byte of product to carry
04632B FD 77 03    0332*  	ld (iy+3),a
04632E             0333*  ; low byte of product
04632E 7D          0334*  	ld a,l
04632F FD 86 00    0335*  	add a,(iy+0)
046332 FD 77 00    0336*  	ld (iy+0),a
046335             0337*  ; high byte of product
046335 7C          0338*  	ld a,h
046336 FD 8E 01    0339*  	adc a,(iy+1)
046339 FD 77 01    0340*  	ld (iy+1),a
04633C             0341*  ; uppper byte of product
04633C E5          0342*  	push hl
04633D 33          0343*  	inc sp
04633E E1          0344*  	pop hl
04633F 3B          0345*  	dec sp
046340 7C          0346*  	ld a,h
046341 FD 8E 02    0347*  	adc a,(iy+2)
046344 FD 77 02    0348*  	ld (iy+2),a
046347             0349*  ; carry
046347 3E 00       0350*  	ld a,0 ; preserve flags
046349 FD 8E 03    0351*  	adc a,(iy+3)
04634C FD 77 03    0352*  	ld (iy+3),a
04634F C9          0353*  	ret
046350             0354*  
046350             0355*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
046350             0356*  umul168:
046350 CD F8 62 04 0357*  	call umul24x24
046354 FD 27 FF    0358*  	ld hl,(iy-1)
046357 C9          0359*  	ret
046358             0360*  
046358             0361*  ; smul168:	UH.L * UD.E --> UH.L (signed)
046358             0362*  smul168:
046358             0363*  ; make everything positive and store sign flags
046358 CD D0 60 04 0364*  	call hlu_abs
04635C F5          0365*  	push af
04635D EB          0366*  	ex de,hl
04635E CD D0 60 04 0367*  	call hlu_abs
046362 EB          0368*  	ex de,hl
046363 F5          0369*  	push af
046364             0370*  ; do the division
046364 CD 50 63 04 0371*      call umul168 ; hl = product
046368             0372*  ; adjust sign of result
046368 F1          0373*  	pop af ; sign de
046369 FA 74 63 04 0374*  	jp m,@de_neg
04636D F1          0375*  	pop af ; sign hl
04636E F0          0376*  	ret p ; both positive, nothing to do
04636F             0377*  @hl_neg:
04636F CD E0 60 04 0378*      call neg_hlu ; de pos, hl neg, result is negative
046373 C9          0379*      ret
046374             0380*  @de_neg:
046374 F1          0381*  	pop af
046375 F8          0382*  	ret m ; both negative, nothing to do
046376 CD E0 60 04 0383*  	call neg_hlu ; result is negative
04637A C9          0384*  	ret
04637B             0385*  
04637B             0386*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
04637B             0387*  ; perform unsigned division of 16.8 fixed place values
04637B             0388*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
04637B             0389*  udiv168:
04637B             0390*  ; back up divisor
04637B ED 53 B2 63 0391*  	ld (@ude),de
       04          
046380             0392*  ; get the 16-bit integer part of the quotient
046380 CD A6 76 04 0393*      call udiv24 ; de = quotient, hl = remainder
046384             0394*  ; load quotient to upper three bytes of output
046384 ED 53 B9 63 0395*      ld (div168_out+1),de
       04          
046389             0396*  @div256:
046389             0397*  ; multiply remainder by 256
046389             0398*  	hlu_mul256
046389 29          0001*M         add hl,hl ; * 2
04638A 29          0002*M         add hl,hl ; * 4
04638B 29          0003*M         add hl,hl ; * 8
04638C 29          0004*M         add hl,hl ; * 16
04638D 29          0005*M         add hl,hl ; * 32
04638E 29          0006*M         add hl,hl ; * 64
04638F 29          0007*M         add hl,hl ; * 128
046390 29          0008*M         add hl,hl ; * 256
046391             0399*  ; skip fractional computation if remainder is zero
046391             0400*      sign_hlu
046391 19          0001*M         add hl,de
046392 B7          0002*M         or a
046393 ED 52       0003*M         sbc hl,de
046395 20 03       0401*      jr nz,@div_frac
046397 AF          0402*      xor a
046398 18 0A       0403*      jr @write_frac
04639A             0404*  ; now divide the shifted remainder by the divisor
04639A             0405*  @div_frac:
04639A ED 5B B2 63 0406*  	ld de,(@ude) ; get back divisor
       04          
04639F CD A6 76 04 0407*      call udiv24 ; de = quotient, hl = remainder
0463A3             0408*  ; load low byte of quotient to low byte of output
0463A3 7B          0409*      ld a,e
0463A4             0410*  @write_frac:
0463A4 32 B8 63 04 0411*      ld (div168_out),a
0463A8             0412*  ; load de with return value
0463A8 ED 5B B8 63 0413*      ld de,(div168_out)
       04          
0463AD             0414*  ; load a with any overflow
0463AD 3A BB 63 04 0415*      ld a,(div168_out+3)
0463B1 C9          0416*      ret ; ud.e is the 16.8 result
0463B2             0417*  @ude: ds 6
0463B8             0418*  div168_out: ds 4 ; the extra byte is for overflow
0463BC             0419*  
0463BC             0420*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0463BC             0421*  ; perform signed division of 16.8 fixed place values
0463BC             0422*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0463BC             0423*  sdiv168:
0463BC             0424*  ; make everything positive and store sign flags
0463BC CD D0 60 04 0425*  	call hlu_abs
0463C0 F5          0426*  	push af
0463C1 EB          0427*  	ex de,hl
0463C2 CD D0 60 04 0428*  	call hlu_abs
0463C6 EB          0429*  	ex de,hl
0463C7 F5          0430*  	push af
0463C8             0431*  ; do the division
0463C8 CD 7B 63 04 0432*      call udiv168 ; de = quotient, hl = remainder
0463CC             0433*  ; adjust sign of result
0463CC F1          0434*  	pop af ; sign de
0463CD FA DA 63 04 0435*  	jp m,@de_neg
0463D1 F1          0436*  	pop af ; sign hl
0463D2 F0          0437*  	ret p ; both positive, nothing to do
0463D3             0438*  @hl_neg:
0463D3 EB          0439*      ex de,hl ; hl = quotient, de = remainder
0463D4 CD E0 60 04 0440*      call neg_hlu ; de pos, hl neg, result is negative
0463D8 EB          0441*      ex de,hl ; de = negated quotient, hl = remainder
0463D9 C9          0442*      ret
0463DA             0443*  @de_neg:
0463DA F1          0444*  	pop af
0463DB F8          0445*  	ret m ; both negative, nothing to do
0463DC EB          0446*      ex de,hl ; hl = quotient, de = remainder
0463DD CD E0 60 04 0447*  	call neg_hlu ; result is negative
0463E1 EB          0448*      ex de,hl ; de = negated quotient, hl = remainder
0463E2 C9          0449*  	ret
0463E3             0450*  ; ========== FROM maths24.inc ==========
0463E3             0451*  
0463E3             0452*  ; Expects  ADL mode
0463E3             0453*  ; Inputs:  UH.L
0463E3             0454*  ; Outputs: UH.L is the 16.8 square root
0463E3             0455*  ;          UD.E is the difference inputHL-DE^2
0463E3             0456*  ;          c flag reset
0463E3             0457*  sqrt168:
0463E3 CD ED 63 04 0458*      call sqrt24
0463E7 EB          0459*      ex de,hl
0463E8 29          0460*      add hl,hl
0463E9 29          0461*      add hl,hl
0463EA 29          0462*      add hl,hl
0463EB 29          0463*      add hl,hl
0463EC C9          0464*      ret
0463ED             0465*  
0463ED             0466*  ; Expects  ADL mode
0463ED             0467*  ; Inputs:  HL
0463ED             0468*  ; Outputs: DE is the integer square root
0463ED             0469*  ;          HL is the difference inputHL-DE^2
0463ED             0470*  ;          c flag reset
0463ED             0471*  sqrt24:
0463ED AF          0472*      xor a
0463EE 45          0473*      ld b,l
0463EF C5          0474*      push bc
0463F0 47          0475*      ld b,a
0463F1 57          0476*      ld d,a
0463F2 4F          0477*      ld c,a
0463F3 6F          0478*      ld l,a
0463F4 5F          0479*      ld e,a
0463F5             0480*  
0463F5             0481*      ;Iteration 1
0463F5 29          0482*      add hl,hl
0463F6 CB 11       0483*      rl c
0463F8 29          0484*      add hl,hl
0463F9 CB 11       0485*      rl c
0463FB 91          0486*      sub c
0463FC 30 04       0487*      jr nc,$+6
0463FE 1C          0488*      inc e
0463FF 1C          0489*      inc e
046400 2F          0490*      cpl
046401 4F          0491*      ld c,a
046402             0492*  
046402             0493*      ;Iteration 2
046402 29          0494*      add hl,hl
046403 CB 11       0495*      rl c
046405 29          0496*      add hl,hl
046406 CB 11       0497*      rl c
046408 CB 13       0498*      rl e
04640A 7B          0499*      ld a,e
04640B 91          0500*      sub c
04640C 30 04       0501*      jr nc,$+6
04640E 1C          0502*      inc e
04640F 1C          0503*      inc e
046410 2F          0504*      cpl
046411 4F          0505*      ld c,a
046412             0506*  
046412             0507*      ;Iteration 3
046412 29          0508*      add hl,hl
046413 CB 11       0509*      rl c
046415 29          0510*      add hl,hl
046416 CB 11       0511*      rl c
046418 CB 13       0512*      rl e
04641A 7B          0513*      ld a,e
04641B 91          0514*      sub c
04641C 30 04       0515*      jr nc,$+6
04641E 1C          0516*      inc e
04641F 1C          0517*      inc e
046420 2F          0518*      cpl
046421 4F          0519*      ld c,a
046422             0520*  
046422             0521*      ;Iteration 4
046422 29          0522*      add hl,hl
046423 CB 11       0523*      rl c
046425 29          0524*      add hl,hl
046426 CB 11       0525*      rl c
046428 CB 13       0526*      rl e
04642A 7B          0527*      ld a,e
04642B 91          0528*      sub c
04642C 30 04       0529*      jr nc,$+6
04642E 1C          0530*      inc e
04642F 1C          0531*      inc e
046430 2F          0532*      cpl
046431 4F          0533*      ld c,a
046432             0534*  
046432             0535*      ;Iteration 5
046432 29          0536*      add hl,hl
046433 CB 11       0537*      rl c
046435 29          0538*      add hl,hl
046436 CB 11       0539*      rl c
046438 CB 13       0540*      rl e
04643A 7B          0541*      ld a,e
04643B 91          0542*      sub c
04643C 30 04       0543*      jr nc,$+6
04643E 1C          0544*      inc e
04643F 1C          0545*      inc e
046440 2F          0546*      cpl
046441 4F          0547*      ld c,a
046442             0548*  
046442             0549*      ;Iteration 6
046442 29          0550*      add hl,hl
046443 CB 11       0551*      rl c
046445 29          0552*      add hl,hl
046446 CB 11       0553*      rl c
046448 CB 13       0554*      rl e
04644A 7B          0555*      ld a,e
04644B 91          0556*      sub c
04644C 30 04       0557*      jr nc,$+6
04644E 1C          0558*      inc e
04644F 1C          0559*      inc e
046450 2F          0560*      cpl
046451 4F          0561*      ld c,a
046452             0562*  
046452             0563*      ;Iteration 7
046452 29          0564*      add hl,hl
046453 CB 11       0565*      rl c
046455 29          0566*      add hl,hl
046456 CB 11       0567*      rl c
046458 CB 10       0568*      rl b
04645A EB          0569*      ex de,hl
04645B 29          0570*      add hl,hl
04645C E5          0571*      push hl
04645D ED 42       0572*      sbc hl,bc
04645F 30 06       0573*      jr nc,$+8
046461 7C          0574*      ld a,h
046462 2F          0575*      cpl
046463 47          0576*      ld b,a
046464 7D          0577*      ld a,l
046465 2F          0578*      cpl
046466 4F          0579*      ld c,a
046467 E1          0580*      pop hl
046468 30 02       0581*      jr nc,$+4
04646A 23          0582*      inc hl
04646B 23          0583*      inc hl
04646C EB          0584*      ex de,hl
04646D             0585*  
04646D             0586*      ;Iteration 8
04646D 29          0587*      add hl,hl
04646E 69          0588*      ld l,c
04646F 60          0589*      ld h,b
046470 ED 6A       0590*      adc hl,hl
046472 ED 6A       0591*      adc hl,hl
046474 EB          0592*      ex de,hl
046475 29          0593*      add hl,hl
046476 ED 52       0594*      sbc hl,de
046478 19          0595*      add hl,de
046479 EB          0596*      ex de,hl
04647A 30 04       0597*      jr nc,$+6
04647C ED 52       0598*      sbc hl,de
04647E 13          0599*      inc de
04647F 13          0600*      inc de
046480             0601*  
046480             0602*      ;Iteration 9
046480 F1          0603*      pop af
046481 17          0604*      rla
046482 ED 6A       0605*      adc hl,hl
046484 17          0606*      rla
046485 ED 6A       0607*      adc hl,hl
046487 EB          0608*      ex de,hl
046488 29          0609*      add hl,hl
046489 ED 52       0610*      sbc hl,de
04648B 19          0611*      add hl,de
04648C EB          0612*      ex de,hl
04648D 30 04       0613*      jr nc,$+6
04648F ED 52       0614*      sbc hl,de
046491 13          0615*      inc de
046492 13          0616*      inc de
046493             0617*  
046493             0618*      ;Iteration 10
046493 17          0619*      rla
046494 ED 6A       0620*      adc hl,hl
046496 17          0621*      rla
046497 ED 6A       0622*      adc hl,hl
046499 EB          0623*      ex de,hl
04649A 29          0624*      add hl,hl
04649B ED 52       0625*      sbc hl,de
04649D 19          0626*      add hl,de
04649E EB          0627*      ex de,hl
04649F 30 04       0628*      jr nc,$+6
0464A1 ED 52       0629*      sbc hl,de
0464A3 13          0630*      inc de
0464A4 13          0631*      inc de
0464A5             0632*  
0464A5             0633*      ;Iteration 11
0464A5 17          0634*      rla
0464A6 ED 6A       0635*      adc hl,hl
0464A8 17          0636*      rla
0464A9 ED 6A       0637*      adc hl,hl
0464AB EB          0638*      ex de,hl
0464AC 29          0639*      add hl,hl
0464AD ED 52       0640*      sbc hl,de
0464AF 19          0641*      add hl,de
0464B0 EB          0642*      ex de,hl
0464B1 30 04       0643*      jr nc,$+6
0464B3 ED 52       0644*      sbc hl,de
0464B5 13          0645*      inc de
0464B6 13          0646*      inc de
0464B7             0647*  
0464B7             0648*      ;Iteration 11
0464B7 17          0649*      rla
0464B8 ED 6A       0650*      adc hl,hl
0464BA 17          0651*      rla
0464BB ED 6A       0652*      adc hl,hl
0464BD EB          0653*      ex de,hl
0464BE 29          0654*      add hl,hl
0464BF ED 52       0655*      sbc hl,de
0464C1 19          0656*      add hl,de
0464C2 EB          0657*      ex de,hl
0464C3 30 04       0658*      jr nc,$+6
0464C5 ED 52       0659*      sbc hl,de
0464C7 13          0660*      inc de
0464C8 13          0661*      inc de
0464C9             0662*  
0464C9 CB 1A       0663*      rr d
0464CB CB 1B       0664*      rr e
0464CD C9          0665*      ret
0464CE             0074   	include "vdu_plot.inc"
0464CE             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0464CE             0002*  ; PLOT code 	(Decimal) 	Effect
0464CE             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0464CE             0004*  plot_sl_both: equ 0x00
0464CE             0005*  
0464CE             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0464CE             0007*  plot_sl_first: equ 0x08
0464CE             0008*  
0464CE             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0464CE             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0464CE             0011*  
0464CE             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0464CE             0013*  plot_sl_last: equ 0x20
0464CE             0014*  
0464CE             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0464CE             0016*  plot_sl_none: equ 0x28
0464CE             0017*  
0464CE             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0464CE             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0464CE             0020*  
0464CE             0021*  ; &40-&47 	64-71 	Point plot
0464CE             0022*  plot_pt: equ 0x40
0464CE             0023*  
0464CE             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0464CE             0025*  plot_lf_lr_non_bg: equ 0x48
0464CE             0026*  
0464CE             0027*  ; &50-&57 	80-87 	Triangle fill
0464CE             0028*  plot_tf: equ 0x50
0464CE             0029*  
0464CE             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0464CE             0031*  plot_lf_r_bg: equ 0x58
0464CE             0032*  
0464CE             0033*  ; &60-&67 	96-103 	Rectangle fill
0464CE             0034*  plot_rf: equ 0x60
0464CE             0035*  
0464CE             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0464CE             0037*  plot_lf_lr_fg: equ 0x60
0464CE             0038*  
0464CE             0039*  ; &70-&77 	112-119 	Parallelogram fill
0464CE             0040*  plot_pf: equ 0x70
0464CE             0041*  
0464CE             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0464CE             0043*  plot_lf_r_non_fg: equ 0x78
0464CE             0044*  
0464CE             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0464CE             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0464CE             0047*  
0464CE             0048*  ; &90-&97 	144-151 	Circle outline
0464CE             0049*  plot_co: equ 0x90
0464CE             0050*  
0464CE             0051*  ; &98-&9F 	152-159 	Circle fill
0464CE             0052*  plot_cf: equ 0x98
0464CE             0053*  
0464CE             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0464CE             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0464CE             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0464CE             0057*  
0464CE             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0464CE             0059*  plot_rcm: equ 0xB8
0464CE             0060*  
0464CE             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0464CE             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0464CE             0063*  ; &D0-&D7 	208-215 	Not defined
0464CE             0064*  ; &D8-&DF 	216-223 	Not defined
0464CE             0065*  ; &E0-&E7 	224-231 	Not defined
0464CE             0066*  
0464CE             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0464CE             0068*  plot_bmp: equ 0xE8
0464CE             0069*  
0464CE             0070*  ; &F0-&F7 	240-247 	Not defined
0464CE             0071*  ; &F8-&FF 	248-255 	Not defined
0464CE             0072*  
0464CE             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0464CE             0074*  ; Agon Console8 VDP 2.2.0
0464CE             0075*  
0464CE             0076*  ; Within each group of eight plot codes, the effects are as follows:
0464CE             0077*  ; Plot code 	Effect
0464CE             0078*  ; 0 	Move relative
0464CE             0079*  mv_rel: equ 0
0464CE             0080*  
0464CE             0081*  ; 1 	Plot relative in current foreground colour
0464CE             0082*  dr_rel_fg: equ 1
0464CE             0083*  
0464CE             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0464CE             0085*  ; 3 	Plot relative in current background colour
0464CE             0086*  dr_rel_bg: equ 3
0464CE             0087*  
0464CE             0088*  ; 4 	Move absolute
0464CE             0089*  mv_abs: equ 4
0464CE             0090*  
0464CE             0091*  ; 5 	Plot absolute in current foreground colour
0464CE             0092*  dr_abs_fg: equ 5
0464CE             0093*  
0464CE             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0464CE             0095*  ; 7 	Plot absolute in current background colour
0464CE             0096*  dr_abs_bg: equ 7
0464CE             0097*  
0464CE             0098*  ; Codes 0-3 use the position data provided as part of the command
0464CE             0099*  ; as a relative position, adding the position given to the current
0464CE             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0464CE             0101*  ; as part of the command as an absolute position, setting the current
0464CE             0102*  ; graphical cursor position to the position given.
0464CE             0103*  
0464CE             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0464CE             0105*  ; current pixel colour. These operations cannot currently be supported
0464CE             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0464CE             0107*  ; supported. Support for these codes may be added in a future version
0464CE             0108*  ; of the VDP firmware.
0464CE             0109*  
0464CE             0110*  ; 16 colour palette constants
0464CE             0111*  c_black: equ 0
0464CE             0112*  c_red_dk: equ 1
0464CE             0113*  c_green_dk: equ 2
0464CE             0114*  c_yellow_dk: equ 3
0464CE             0115*  c_blue_dk: equ 4
0464CE             0116*  c_magenta_dk: equ 5
0464CE             0117*  c_cyan_dk: equ 6
0464CE             0118*  c_grey: equ 7
0464CE             0119*  c_grey_dk: equ 8
0464CE             0120*  c_red: equ 9
0464CE             0121*  c_green: equ 10
0464CE             0122*  c_yellow: equ 11
0464CE             0123*  c_blue: equ 12
0464CE             0124*  c_magenta: equ 13
0464CE             0125*  c_cyan: equ 14
0464CE             0126*  c_white: equ 15
0464CE             0127*  
0464CE             0128*  ; VDU 25, mode, x; y;: PLOT command
0464CE             0129*  ; inputs: a=mode, bc=x0, de=y0
0464CE             0130*  vdu_plot:
0464CE 32 E8 64 04 0131*      ld (@mode),a
0464D2 ED 43 E9 64 0132*      ld (@x0),bc
       04          
0464D7 ED 53 EB 64 0133*      ld (@y0),de
       04          
0464DC 21 E7 64 04 0134*  	ld hl,@cmd
0464E0 01 06 00 00 0135*  	ld bc,@end-@cmd
0464E4 5B DF       0136*  	rst.lil $18
0464E6 C9          0137*  	ret
0464E7 19          0138*  @cmd:   db 25
0464E8 00          0139*  @mode:  db 0
0464E9 00 00       0140*  @x0: 	dw 0
0464EB 00 00       0141*  @y0: 	dw 0
0464ED 00          0142*  @end:   db 0 ; extra byte to soak up deu
0464EE             0143*  
0464EE             0144*  ; VDU 25, mode, x; y;: PLOT command
0464EE             0145*  ; USING 16.8 FIXED POINT COORDINATES
0464EE             0146*  ; inputs: a=mode, ub.c=x0, ud.e=y0
0464EE             0147*  vdu_plot_168:
0464EE ED 53 0A 65 0148*      ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       04          
0464F3 ED 43 08 65 0149*      ld (@x0-1),bc ; integer portion only
       04          
0464F8 32 08 65 04 0150*      ld (@mode),a  ; load this order b/c we shifted bc right
0464FC 21 07 65 04 0151*  	ld hl,@cmd
046500 01 06 00 00 0152*  	ld bc,@end-@cmd
046504 5B DF       0153*  	rst.lil $18
046506             0154*      ; ld hl,@cmd
046506             0155*      ; ld a,6
046506             0156*      ; call dumpMemoryHex
046506             0157*      ; call printNewLine
046506 C9          0158*  	ret
046507 19          0159*  @cmd:   db 25
046508 00          0160*  @mode:  db 0
046509 00 00       0161*  @x0: 	dw 0
04650B 00 00       0162*  @y0: 	dw 0
04650D             0163*  @end:  ; no padding required b/c we shifted de right
04650D             0164*  
04650D             0165*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04650D             0166*  ; &E8-&EF 	232-239 	Bitmap plot §
04650D             0167*  ; VDU 25, mode, x; y;: PLOT command
04650D             0168*  ; inputs: bc=x0, de=y0
04650D             0169*  ; prerequisites: vdu_buff_select
04650D             0170*  vdu_plot_bmp:
04650D ED 43 24 65 0171*      ld (@x0),bc
       04          
046512 ED 53 26 65 0172*      ld (@y0),de
       04          
046517 21 22 65 04 0173*  	ld hl,@cmd
04651B 01 06 00 00 0174*  	ld bc,@end-@cmd
04651F 5B DF       0175*  	rst.lil $18
046521 C9          0176*  	ret
046522 19          0177*  @cmd:   db 25
046523 ED          0178*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
046524 00 00       0179*  @x0: 	dw 0x0000
046526 00 00       0180*  @y0: 	dw 0x0000
046528 00          0181*  @end:   db 0x00 ; padding
046529             0182*  
046529             0183*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
046529             0184*  ; &E8-&EF 	232-239 	Bitmap plot §
046529             0185*  ; VDU 25, mode, x; y;: PLOT command
046529             0186*  ; inputs: bc=x0, de=y0
046529             0187*  ; USING 16.8 FIXED POINT COORDINATES
046529             0188*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
046529             0189*  ;   the fractional portiion of the inputs are truncated
046529             0190*  ;   leaving only the 16-bit integer portion
046529             0191*  ; prerequisites: vdu_buff_select
046529             0192*  vdu_plot_bmp168:
046529             0193*  ; populate in the reverse of normal to keep the
046529             0194*  ; inputs from stomping on each other
046529 ED 53 47 65 0195*      ld (@y0-1),de
       04          
04652E ED 43 45 65 0196*      ld (@x0-1),bc
       04          
046533 3E ED       0197*      ld a,plot_bmp+dr_abs_fg ; 0xED
046535 32 45 65 04 0198*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
046539 21 44 65 04 0199*  	ld hl,@cmd
04653D 01 06 00 00 0200*  	ld bc,@end-@cmd
046541 5B DF       0201*  	rst.lil $18
046543 C9          0202*  	ret
046544 19          0203*  @cmd:   db 25
046545 ED          0204*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
046546 00 00       0205*  @x0: 	dw 0x0000
046548 00 00       0206*  @y0: 	dw 0x0000
04654A             0207*  @end:  ; no padding required b/c we shifted de right
04654A             0208*  
04654A             0209*  ; draw a filled rectangle
04654A             0210*  vdu_plot_rf:
04654A ED 43 71 65 0211*      ld (@x0),bc
       04          
04654F ED 53 73 65 0212*      ld (@y0),de
       04          
046554 DD 22 77 65 0213*      ld (@x1),ix
       04          
046559 FD 22 79 65 0214*      ld (@y1),iy
       04          
04655E 3E 19       0215*      ld a,25 ; we have to reload the 2nd plot command
046560 32 75 65 04 0216*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
046564 21 6F 65 04 0217*  	ld hl,@cmd0
046568 01 0C 00 00 0218*  	ld bc,@end-@cmd0
04656C 5B DF       0219*  	rst.lil $18
04656E C9          0220*      ret
04656F 19          0221*  @cmd0:  db 25 ; plot
046570 04          0222*  @arg0:  db plot_sl_both+mv_abs
046571 00 00       0223*  @x0:    dw 0x0000
046573 00 00       0224*  @y0:    dw 0x0000
046575 19          0225*  @cmd1:  db 25 ; plot
046576 65          0226*  @arg1:  db plot_rf+dr_abs_fg
046577 00 00       0227*  @x1:    dw 0x0000
046579 00 00       0228*  @y1:    dw 0x0000
04657B 00          0229*  @end:   db 0x00 ; padding
04657C             0230*  
04657C             0231*  ; draw a filled circle
04657C             0232*  vdu_plot_cf:
04657C ED 43 A3 65 0233*      ld (@x0),bc
       04          
046581 ED 53 A5 65 0234*      ld (@y0),de
       04          
046586 DD 22 A9 65 0235*      ld (@x1),ix
       04          
04658B FD 22 AB 65 0236*      ld (@y1),iy
       04          
046590 3E 19       0237*      ld a,25 ; we have to reload the 2nd plot command
046592 32 A7 65 04 0238*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
046596 21 A1 65 04 0239*  	ld hl,@cmd0
04659A 01 0C 00 00 0240*  	ld bc,@end-@cmd0
04659E 5B DF       0241*  	rst.lil $18
0465A0 C9          0242*      ret
0465A1 19          0243*  @cmd0:  db 25 ; plot
0465A2 04          0244*  @arg0:  db plot_sl_both+mv_abs
0465A3 00 00       0245*  @x0:    dw 0x0000
0465A5 00 00       0246*  @y0:    dw 0x0000
0465A7 19          0247*  @cmd1:  db 25 ; plot
0465A8 9D          0248*  @arg1:  db plot_cf+dr_abs_fg
0465A9 00 00       0249*  @x1:    dw 0x0000
0465AB 00 00       0250*  @y1:    dw 0x0000
0465AD 00          0251*  @end:   db 0x00 ; padding
0465AE             0252*  
0465AE             0253*  ; VDU 25, mode, x; y;: PLOT command
0465AE             0254*  ; inputs: a=mode, ix=x0, iy=y0
0465AE             0255*  plot:
0465AE 32 C8 65 04 0256*      ld (@mode),a
0465B2 DD 22 C9 65 0257*      ld (@x0),ix
       04          
0465B7 FD 22 CB 65 0258*      ld (@y0),iy
       04          
0465BC 21 C7 65 04 0259*  	ld hl,@cmd
0465C0 01 06 00 00 0260*  	ld bc,@end-@cmd
0465C4 5B DF       0261*  	rst.lil $18
0465C6 C9          0262*  	ret
0465C7 19          0263*  @cmd:   db 25
0465C8 00          0264*  @mode:  db 0
0465C9 00 00       0265*  @x0: 	dw 0
0465CB 00 00       0266*  @y0: 	dw 0
0465CD 00          0267*  @end:   db 0 ; padding
0465CE             0268*  
0465CE             0269*  ; VDU 5: Write text at graphics cursor
0465CE             0270*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0465CE             0271*  ; prerequisites: gcol foreground set, VDU 5 set
0465CE             0272*  plot_text:
0465CE E5          0273*      push hl ; save text pointer
0465CF             0274*  ; move graphics cursor to x0, y0
0465CF 3E 44       0275*      ld a,plot_pt+mv_abs
0465D1 CD AE 65 04 0276*      call plot
0465D5             0277*  ; write text
0465D5 E1          0278*      pop hl ; restore text pointer
0465D6 CD 4F 51 04 0279*      call printString
0465DA C9          0280*      ret
0465DB             0075   	include "trig24.inc"
0465DB             0001*  
0465DB             0002*  ; convert signed angles from a 360 to 256 degree circle
0465DB             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0465DB             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0465DB             0005*  ; destroys: TODO
0465DB             0006*  deg_360_to_256:
0465DB D5          0007*  	push de ; preserve de
0465DC             0008*  ; make angle positive and store sign flag
0465DC CD D0 60 04 0009*  	call hlu_abs
0465E0 F5          0010*  	push af
0465E1             0011*  ; multiply by 256 first to keep precision
0465E1             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0465E1 29          0001*M         add hl,hl ; * 2
0465E2 29          0002*M         add hl,hl ; * 4
0465E3 29          0003*M         add hl,hl ; * 8
0465E4 29          0004*M         add hl,hl ; * 16
0465E5 29          0005*M         add hl,hl ; * 32
0465E6 29          0006*M         add hl,hl ; * 64
0465E7 29          0007*M         add hl,hl ; * 128
0465E8 29          0008*M         add hl,hl ; * 256
0465E9             0013*  ; divide uh.l by 360
0465E9 11 68 01 00 0014*  	ld de,360
0465ED CD A6 76 04 0015*  	call udiv24 ; ud.e = degrees / 360
0465F1 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0465F2             0017*  ; restore sign flag and adjust output accordingly
0465F2 F1          0018*  	pop af
0465F3 F2 FB 65 04 0019*  	jp p,@pos ; positive number
0465F7 CD E0 60 04 0020*  	call neg_hlu
0465FB             0021*  @pos:
0465FB             0022*  ; restore de and return uh.l as the result
0465FB D1          0023*  	pop de
0465FC C9          0024*  	ret
0465FD             0025*  
0465FD             0026*  ; fixed 16.8 routine
0465FD             0027*  ; cos(uh.l) --> uh.l
0465FD             0028*  ; destroys: de
0465FD             0029*  cos168:
0465FD             0030*  ; for cos we simply increment the angle by 90 degrees
0465FD             0031*  ; or 0x004000 in 16.8 degrees256
0465FD             0032*  ; which makes it a sin problem
0465FD 11 00 40 00 0033*      ld de,0x004000
046601 19          0034*      add hl,de ; modulo 256 happens below
046602             0035*  ; fall through to sin168
046602             0036*  
046602             0037*  ; ---------------------
046602             0038*  ; fixed 16.8 routine
046602             0039*  ; sin(uh.l) --> uh.l
046602             0040*  ; destroys: af
046602             0041*  sin168:
046602 D5          0042*  	push de
046603 DD E5       0043*  	push ix
046605             0044*  ; handle negative angles appropriately
046605 CD D0 60 04 0045*  	call hlu_abs
046609 F2 12 66 04 0046*  	jp p,@f
04660D 11 00 00 FF 0047*  	ld de,-256*256
046611 19          0048*  	add hl,de
046612             0049*  @@:
046612             0050*  ; get the lookup value for the integer portion of the angle
046612 7D          0051*  	ld a,l ; save fractional part of the angle
046613 2E 06       0052*  	ld l,6 ; multiply by 6 to get our lookup index
046615 EB          0053*  	ex de,hl ; can't add ix,hl
046616 ED 5C       0054*  	mlt de ; gosh that is handy
046618 DD 21 84 6A 0055*      ld ix,sin_lut_816 ; grab the lut address
       04          
04661D DD 19       0056*      add ix,de ; bump hl by the index
04661F DD 27 00    0057*      ld hl,(ix) ; hl = sin(int(angle))
046622 B7          0058*  	or a  ; check fractional part of the angle for zero
046623 CA 34 66 04 0059*  	jp z,@f ; no fractional part so skip interpolation
046627             0060*  ; interpolate the fractional part of the angle
046627 DD 17 03    0061*  	ld de,(ix+3)
04662A EB          0062*  	ex de,hl
04662B CD B9 62 04 0063*  	call smul24x8
04662F CD 1C 61 04 0064*  	call hlu_sdiv256
046633 19          0065*  	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle))
046634             0066*  @@:
046634 CD 1C 61 04 0067*  	call hlu_sdiv256
046638 DD E1       0068*  	pop ix
04663A D1          0069*  	pop de
04663B C9          0070*      ret ; and out
04663C             0071*  
04663C             0072*  ; 16.8 fixed inputs / outputs
04663C             0073*  ; takes: uh.l as angle in degrees 256
04663C             0074*  ;        ud.e as radius
04663C             0075*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
04663C             0076*  ;        displacements from origin (0,0)
04663C             0077*  ; destroys: everything except indexes
04663C             0078*  polar_to_cartesian:
04663C             0079*  	; call printNewLine ; DEBUG
04663C             0080*  ; back up input parameters
04663C 22 67 66 04 0081*      ld (@angle), hl
046640 ED 53 6A 66 0082*      ld (@radius), de
       04          
046645             0083*  ; compute dx = cos(uh.l) * ud.e
046645 CD FD 65 04 0084*      call cos168 ; uh.l = cos(uh.l)
046649             0085*  	; call print_hex_hl ; DEBUG
046649             0086*  	; call print_s168_hl ; DEBUG
046649 ED 5B 6A 66 0087*  	ld de,(@radius)
       04          
04664E CD 58 63 04 0088*  	call smul168 ; uh.l = dx
046652 E5          0089*      push hl
046653             0090*  ; compute dy = sin(uh.l) * ud.e
046653 2A 67 66 04 0091*      ld hl,(@angle)
046657 CD 02 66 04 0092*      call sin168 ; uh.l = sin(uh.l)
04665B             0093*  	; call print_hex_hl ; DEBUG
04665B             0094*  	; call print_s168_hl ; DEBUG
04665B ED 5B 6A 66 0095*      ld de,(@radius)
       04          
046660 CD 58 63 04 0096*      call smul168    ; uh.l = dy
046664 EB          0097*      ex de,hl       ; de = dy for output
046665 C1          0098*      pop bc          ; bc = dx for output
046666             0099*  ; and out
046666 C9          0100*      ret
046667             0101*  @angle: ds 3
04666A             0102*  @radius: ds 3
04666D             0103*  
04666D             0104*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04666D             0105*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04666D             0106*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
04666D             0107*  ;         also populates scratch locations dx168 and dy168
04666D             0108*  ; destroys: a,hl,bc,de
04666D             0109*  dxy168:
04666D             0110*  ; compute dx = x1-x0
04666D AF          0111*      xor a ; clear carry
04666E DD E5       0112*      push ix ; move ix to hl via the stack
046670 E1          0113*      pop hl ; hl = x1
046671 ED 42       0114*      sbc hl,bc ; hl = dx
046673 22 C8 66 04 0115*      ld (dx168),hl ; dx to scratch
046677             0116*  ; compute dy = y1-y0
046677 AF          0117*      xor a ; clear carry
046678 FD E5       0118*      push iy ; move iy to hl via the stack
04667A E1          0119*      pop hl ; hl = y1
04667B ED 52       0120*      sbc hl,de ; hl = dy
04667D 22 CE 66 04 0121*      ld (dy168),hl ; dy to scratch
046681             0122*  ; populate output registers and return
046681 EB          0123*      ex de,hl        ; ud.e = dy
046682 ED 4B C8 66 0124*      ld bc,(dx168)   ; ub.c = dx
       04          
046687 C9          0125*      ret
046688             0126*  
046688             0127*  ; compute the euclidian distance between two cartesian coordinates
046688             0128*  ; using the formula d = sqrt(dx^2+dy^2
046688             0129*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
046688             0130*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
046688             0131*  ; output; uh.l is the 16.8 fixed format distance
046688             0132*  ;       dx168/y are the 16.8 fixed format dx and dy
046688             0133*  ; destroys: a,hl,bc,de
046688             0134*  distance168:
046688             0135*  ; compute dx = x1-x0
046688 AF          0136*      xor a ; clear carry
046689 DD E5       0137*      push ix ; move ix to hl via the stack
04668B E1          0138*      pop hl ; hl = x1
04668C ED 42       0139*      sbc hl,bc ; hl = dx
04668E 22 C8 66 04 0140*      ld (dx168),hl ; dx to scratch
046692             0141*  ; ; test dx for overflow
046692             0142*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
046692             0143*  ; 	ex de,hl
046692             0144*  ; 	sbc hl,de ; test for overflow
046692             0145*  ; 	push af ; carry indicates overflow
046692             0146*  ; compute dy = y1-y0
046692 AF          0147*      xor a ; clear carry
046693 FD E5       0148*      push iy ; move iy to hl via the stack
046695 E1          0149*      pop hl ; hl = y1
046696 ED 52       0150*      sbc hl,de ; hl = dy
046698 22 CE 66 04 0151*      ld (dy168),hl ; dy to scratch
04669C             0152*  ; ; test dy for overflow
04669C             0153*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
04669C             0154*  ; 	ex de,hl
04669C             0155*  ; 	sbc hl,de ; test for overflow
04669C             0156*  ; 	push af ; carry indicates overflow
04669C             0157*  ; compute dy^2
04669C 2A CE 66 04 0158*  	ld hl,(dy168)
0466A0 CD D0 60 04 0159*      call hlu_abs  ; make dy positive so we can use unsigned multiply
0466A4             0160*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0466A4 E5          0161*      push hl ; load hl/2 to bc via the stack
0466A5 C1          0162*      pop bc ; bc = dy/2
0466A6 EB          0163*      ex de,hl ; de = dy/2
0466A7 CD 50 63 04 0164*      call umul168 ; uh.l = dy^2/2
0466AB E5          0165*      push hl ; dy^2/2 to the stack
0466AC             0166*  ; compute dx^2
0466AC 2A C8 66 04 0167*      ld hl,(dx168) ; get back dx
0466B0 CD D0 60 04 0168*      call hlu_abs  ; make dx positive so we can use unsigned multiply
0466B4             0169*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0466B4 E5          0170*      push hl ; load hl/2 to bc via the stack
0466B5 C1          0171*      pop bc ; bc = dx/2
0466B6 EB          0172*      ex de,hl ; de = dx/2
0466B7 CD 50 63 04 0173*      call umul168 ; uh.l = dx^2/2
0466BB             0174*  ; commpute dy^2+dx^2
0466BB D1          0175*      pop de ; get back dx^2/2
0466BC 19          0176*      add hl,de ; hl = dx^2/2+dy^2/2
0466BD             0177*  ; compute sqrt(dx^2/2+dy^2/2)
0466BD CD E3 63 04 0178*      call sqrt168 ; uh.l = distance/2
0466C1             0179*      ; add hl,hl ; hl = distance
0466C1             0180*  ; ; check for overflow
0466C1             0181*  ; 	pop af ; get back the overflow flags
0466C1             0182*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0466C1             0183*  ; 	ld b,a ; save the overflow flag
0466C1             0184*  ; 	pop af ; get back the overflow flags
0466C1             0185*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0466C1             0186*  ; 	add a,b ; if a != 0 then we had overflow
0466C1             0187*  ;     ret z ; no overflow we're done
0466C1             0188*  ; @overflow:
0466C1             0189*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0466C1 C9          0190*  	ret
0466C2             0191*  @scratch: ds 6
0466C8             0192*  dx168: ds 6
0466CE             0193*  dy168: ds 6
0466D4             0194*  
0466D4             0195*  ; atan2(ub.c,ud.e) --> uh.l
0466D4             0196*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0466D4             0197*  ;   whether inputs are integers or fractional doesn't matter
0466D4             0198*  ;   so long as the sign bit of the upper byte is correct
0466D4             0199*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0466D4             0200*  ; angles are COMPASS HEADINGS based on
0466D4             0201*  ; screen coordinate conventions,where the y axis is flipped
0466D4             0202*  ; #E0 315      0       45 #20
0466D4             0203*  ;        -x,-y | +x,-y
0466D4             0204*  ; #C0 270------+------ 90 #40
0466D4             0205*  ;        -x,+y | +x,+y
0466D4             0206*  ; #A0 225   180 #80   135 #60
0466D4             0207*  atan2_168game:
0466D4             0208*  ; get signs and make everything positive
0466D4             0209*  ; get abs(x) and store its original sign
0466D4 C5          0210*      push bc
0466D5 E1          0211*      pop hl
0466D6 CD D0 60 04 0212*      call hlu_abs ; if x was negative this also sets the sign flag
0466DA E5          0213*      push hl ; store abs(x)
0466DB C1          0214*      pop bc ; bc = abs(x)
0466DC F5          0215*      push af ; store sign of x
0466DD             0216*  ; get abs(y) and store its original sign
0466DD EB          0217*      ex de,hl ; hl = y
0466DE CD D0 60 04 0218*      call hlu_abs ; if y was negative this also sets the sign flag
0466E2 EB          0219*      ex de,hl ; de = abs(y)
0466E3 F5          0220*      push af ; store sign of y
0466E4             0221*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0466E4             0222*  ; this ensures that our lookup value is between 0 and 1 inclusive
0466E4 AF          0223*      xor a ; clear the carry flag
0466E5 D5          0224*      push de
0466E6 E1          0225*      pop hl
0466E7 ED 42       0226*      sbc hl,bc
0466E9 F5          0227*      push af ; save sign of de - bc
0466EA F2 F3 66 04 0228*      jp p,@1 ; bc <= de, so we skip ahead
0466EE             0229*  ; otherwise we swap bc and de
0466EE C5          0230*      push bc
0466EF E1          0231*      pop hl
0466F0 EB          0232*      ex de,hl
0466F1 E5          0233*      push hl
0466F2 C1          0234*      pop bc
0466F3             0235*  @1:
0466F3             0236*  ; now we're ready to snag our preliminary result
0466F3 CD 61 67 04 0237*      call atan_168game ; uh.l comes back with prelim result
0466F7             0238*  ; now we adjust uh.l based on sign of de - bc
0466F7 F1          0239*      pop af
0466F8 F2 04 67 04 0240*      jp p,@2 ; bc <= de,so we skip ahead
0466FC EB          0241*      ex de,hl
0466FD 21 00 40 00 0242*      ld hl,0x004000 ; 90 degrees
046701 AF          0243*      xor a ; clear the carry flag
046702 ED 52       0244*      sbc hl,de ; subtract result from 90 degrees
046704             0245*      ; ld de,0 ; prep to clear hlu
046704             0246*      ; ld d,h
046704             0247*      ; ld e,l
046704             0248*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
046704             0249*      ; fall through
046704             0250*  @2:
046704             0251*  ; now the fun part of adjusting the result
046704             0252*  ; based on which quadrant (x,y) is in
046704             0253*  ; #E0 315      0       45 #20
046704             0254*  ;        -x,-y | +x,-y
046704             0255*  ; #C0 270------+------ 90 #40
046704             0256*  ;        -x,+y | +x,+y
046704             0257*  ; #A0 225   180 #80   135 #60
046704 F1          0258*      pop af ; sign of y
046705 CA 42 67 04 0259*      jp z,@y_zero
046709 F2 22 67 04 0260*      jp p,@y_pos
04670D             0261*  ; y neg,check x
04670D F1          0262*      pop af ; sign of x
04670E CA 1C 67 04 0263*      jp z,@y_neg_x_zero
046712 F2 21 67 04 0264*      jp p,@y_neg_x_pos
046716             0265*  ; y neg,x neg
046716             0266*  ; angle is 270-360
046716             0267*  ; negating the intermediate does the trick
046716 CD E0 60 04 0268*      call neg_hlu
04671A 18 31       0269*      jr @zero_hlu
04671C             0270*  
04671C             0271*  @y_neg_x_zero:
04671C             0272*  ; y neg,x zero
04671C             0273*  ; angle is 0
04671C 21 00 00 00 0274*      ld hl,0
046720 C9          0275*      ret
046721             0276*  @y_neg_x_pos:
046721             0277*  ; y neg,x pos
046721             0278*  ; angle is 0 to 90
046721             0279*  ; so we're good
046721 C9          0280*      ret
046722             0281*  
046722             0282*  @y_pos:
046722 F1          0283*      pop af ; sign of x
046723 CA 32 67 04 0284*      jp z,@y_pos_x_zero
046727 F2 37 67 04 0285*      jp p,@y_pos_x_pos
04672B             0286*  ; y pos,x neg
04672B             0287*  ; angle is 180-270
04672B             0288*  ; so we add 180 to intermediate
04672B 11 00 80 00 0289*      ld de,0x008000
04672F 19          0290*      add hl,de
046730 18 1B       0291*      jr @zero_hlu
046732             0292*  @y_pos_x_zero:
046732             0293*  ; y pos,x zero
046732             0294*  ; angle is 180
046732 21 00 80 00 0295*      ld hl,0x008000
046736 C9          0296*      ret
046737             0297*  @y_pos_x_pos:
046737             0298*  ; y pos,x pos
046737             0299*  ; angle is 90-180
046737             0300*  ; neg the intermediate and add 180 degrees
046737 CD E0 60 04 0301*      call neg_hlu
04673B 11 00 80 00 0302*      ld de,0x008000
04673F 19          0303*      add hl,de
046740 18 0B       0304*      jr @zero_hlu
046742             0305*  
046742             0306*  @y_zero:
046742 F1          0307*      pop af ; sign of x
046743 FA 48 67 04 0308*      jp m,@y_zero_x_neg
046747             0309*  ; y zero,x pos
046747             0310*  ; angle is 90,nothing to do
046747 C9          0311*      ret
046748             0312*  @y_zero_x_neg:
046748             0313*  ; y zero ,x neg
046748             0314*  ; angle is 270
046748 21 00 C0 00 0315*      ld hl,0x00C000
04674C C9          0316*      ret
04674D             0317*  @zero_hlu:
04674D AF          0318*      xor a
04674E 22 5B 67 04 0319*      ld (@scratch),hl
046752 32 5D 67 04 0320*      ld (@scratch+2),a
046756 2A 5B 67 04 0321*      ld hl,(@scratch)
04675A C9          0322*      ret
04675B             0323*  @scratch: ds 6
046761             0324*  
046761             0325*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046761             0326*  ; output: uh.l is the 16.8 fixed format angle
046761             0327*  ; destroys: a,hl,bc,de
046761             0328*  ; the following note was written by github copilot:
046761             0329*  ; note: this routine is a bit of a hack
046761             0330*  ;      but it works
046761             0331*  ;      and it's fast
046761             0332*  ;      and it's small
046761             0333*  ;      and it's accurate
046761             0334*  ;      and it's easy to understand
046761             0335*  ;      and it's easy to modify
046761             0336*  ;      and it's easy to use
046761             0337*  ;      and it's easy to remember
046761             0338*  ;      and it's easy to love
046761             0339*  ;      and it's easy to hate
046761             0340*  ;      and it's easy to ignore
046761             0341*  ;      and it's easy to forget
046761             0342*  ;      and it's easy to remember
046761             0343*  ;      and it's easy to forget
046761             0344*  ;      and it's easy to remember
046761             0345*  ;      (ok the bot is stuck in a loop)
046761             0346*  ; REAL NOTE: only works for angles from 0 to 45 degrees
046761             0347*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
046761             0348*  atan_168game:
046761             0349*  ; because we use compass headings instead of geometric angles
046761             0350*  ; we compute dx/dy which is 1/tan(theta) in the maths world
046761             0351*  ; we can do faster unsigned division here because we know dx and dy are positive
046761 CD 7B 63 04 0352*  	call udiv168 ; uh.l = dx/dy
046765             0353*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
046765             0354*  ; ; test uh.l for 0
046765             0355*  ;     add hl,de
046765             0356*  ;     or a
046765             0357*  ;     sbc hl,de
046765             0358*  ;     jr z,@is_zero
046765             0359*  ; ; test uh.l for 1
046765             0360*  ;     xor a ; clear carry
046765             0361*  ;     ex de,hl
046765             0362*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
046765             0363*  ;     sbc hl,de
046765             0364*  ;     jr z,@is_45
046765             0365*  ; ; END TODO
046765             0366*  
046765             0367*  ; no special cases so we move on
046765             0368*  ; l contains the fractional portion of tan(uh.l)
046765             0369*  ; we multiply it by three to get our lookup table index
046765 26 03       0370*      ld h,3
046767 ED 6C       0371*      mlt hl ; gosh that is handy
046769 11 00 00 00 0372*      ld de,0 ; clear deu
04676D 54          0373*      ld d,h ; copy hl to de
04676E 5D          0374*      ld e,l ; de contains our index
04676F 21 8A 73 04 0375*      ld hl,atan_lut_168 ; grab the lut address
046773 19          0376*      add hl,de ; bump hl by the index
046774 ED 27       0377*      ld hl,(hl) ; don't try this on a z80!
046776 C9          0378*      ret ; and out
046777             0379*  @is_45:
046777 21 00 20 00 0380*      ld hl,0x002000 ; 45 degrees decimal
04677B C9          0381*      ret
04677C             0382*  ; for the case tan(0)
04677C             0383*  @is_zero:
04677C 21 00 00 00 0384*      ld hl,0x000000
046780 C9          0385*      ret
046781             0386*  
046781             0387*  sin_lut_168:
046781 00 00 00    0388*  	dl 0x000000 ; 0.000 00, 0.000
046784 06 00 00    0389*  	dl 0x000006 ; 1.406 01, 0.025
046787 0C 00 00    0390*  	dl 0x00000C ; 2.813 02, 0.049
04678A 12 00 00    0391*  	dl 0x000012 ; 4.219 03, 0.074
04678D 19 00 00    0392*  	dl 0x000019 ; 5.625 04, 0.098
046790 1F 00 00    0393*  	dl 0x00001F ; 7.031 05, 0.122
046793 25 00 00    0394*  	dl 0x000025 ; 8.438 06, 0.147
046796 2B 00 00    0395*  	dl 0x00002B ; 9.844 07, 0.171
046799 31 00 00    0396*  	dl 0x000031 ; 11.250 08, 0.195
04679C 38 00 00    0397*  	dl 0x000038 ; 12.656 09, 0.219
04679F 3E 00 00    0398*  	dl 0x00003E ; 14.063 0A, 0.243
0467A2 44 00 00    0399*  	dl 0x000044 ; 15.469 0B, 0.267
0467A5 4A 00 00    0400*  	dl 0x00004A ; 16.875 0C, 0.290
0467A8 50 00 00    0401*  	dl 0x000050 ; 18.281 0D, 0.314
0467AB 56 00 00    0402*  	dl 0x000056 ; 19.688 0E, 0.337
0467AE 5C 00 00    0403*  	dl 0x00005C ; 21.094 0F, 0.360
0467B1 61 00 00    0404*  	dl 0x000061 ; 22.500 10, 0.383
0467B4 67 00 00    0405*  	dl 0x000067 ; 23.906 11, 0.405
0467B7 6D 00 00    0406*  	dl 0x00006D ; 25.313 12, 0.428
0467BA 73 00 00    0407*  	dl 0x000073 ; 26.719 13, 0.450
0467BD 78 00 00    0408*  	dl 0x000078 ; 28.125 14, 0.471
0467C0 7E 00 00    0409*  	dl 0x00007E ; 29.531 15, 0.493
0467C3 83 00 00    0410*  	dl 0x000083 ; 30.938 16, 0.514
0467C6 88 00 00    0411*  	dl 0x000088 ; 32.344 17, 0.535
0467C9 8E 00 00    0412*  	dl 0x00008E ; 33.750 18, 0.556
0467CC 93 00 00    0413*  	dl 0x000093 ; 35.156 19, 0.576
0467CF 98 00 00    0414*  	dl 0x000098 ; 36.563 1A, 0.596
0467D2 9D 00 00    0415*  	dl 0x00009D ; 37.969 1B, 0.615
0467D5 A2 00 00    0416*  	dl 0x0000A2 ; 39.375 1C, 0.634
0467D8 A7 00 00    0417*  	dl 0x0000A7 ; 40.781 1D, 0.653
0467DB AB 00 00    0418*  	dl 0x0000AB ; 42.188 1E, 0.672
0467DE B0 00 00    0419*  	dl 0x0000B0 ; 43.594 1F, 0.690
0467E1 B5 00 00    0420*  	dl 0x0000B5 ; 45.000 20, 0.707
0467E4 B9 00 00    0421*  	dl 0x0000B9 ; 46.406 21, 0.724
0467E7 BD 00 00    0422*  	dl 0x0000BD ; 47.813 22, 0.741
0467EA C1 00 00    0423*  	dl 0x0000C1 ; 49.219 23, 0.757
0467ED C5 00 00    0424*  	dl 0x0000C5 ; 50.625 24, 0.773
0467F0 C9 00 00    0425*  	dl 0x0000C9 ; 52.031 25, 0.788
0467F3 CD 00 00    0426*  	dl 0x0000CD ; 53.438 26, 0.803
0467F6 D1 00 00    0427*  	dl 0x0000D1 ; 54.844 27, 0.818
0467F9 D4 00 00    0428*  	dl 0x0000D4 ; 56.250 28, 0.831
0467FC D8 00 00    0429*  	dl 0x0000D8 ; 57.656 29, 0.845
0467FF DB 00 00    0430*  	dl 0x0000DB ; 59.063 2A, 0.858
046802 DE 00 00    0431*  	dl 0x0000DE ; 60.469 2B, 0.870
046805 E1 00 00    0432*  	dl 0x0000E1 ; 61.875 2C, 0.882
046808 E4 00 00    0433*  	dl 0x0000E4 ; 63.281 2D, 0.893
04680B E7 00 00    0434*  	dl 0x0000E7 ; 64.688 2E, 0.904
04680E EA 00 00    0435*  	dl 0x0000EA ; 66.094 2F, 0.914
046811 EC 00 00    0436*  	dl 0x0000EC ; 67.500 30, 0.924
046814 EE 00 00    0437*  	dl 0x0000EE ; 68.906 31, 0.933
046817 F1 00 00    0438*  	dl 0x0000F1 ; 70.313 32, 0.942
04681A F3 00 00    0439*  	dl 0x0000F3 ; 71.719 33, 0.950
04681D F4 00 00    0440*  	dl 0x0000F4 ; 73.125 34, 0.957
046820 F6 00 00    0441*  	dl 0x0000F6 ; 74.531 35, 0.964
046823 F8 00 00    0442*  	dl 0x0000F8 ; 75.938 36, 0.970
046826 F9 00 00    0443*  	dl 0x0000F9 ; 77.344 37, 0.976
046829 FB 00 00    0444*  	dl 0x0000FB ; 78.750 38, 0.981
04682C FC 00 00    0445*  	dl 0x0000FC ; 80.156 39, 0.985
04682F FD 00 00    0446*  	dl 0x0000FD ; 81.563 3A, 0.989
046832 FE 00 00    0447*  	dl 0x0000FE ; 82.969 3B, 0.992
046835 FE 00 00    0448*  	dl 0x0000FE ; 84.375 3C, 0.995
046838 FF 00 00    0449*  	dl 0x0000FF ; 85.781 3D, 0.997
04683B FF 00 00    0450*  	dl 0x0000FF ; 87.188 3E, 0.999
04683E FF 00 00    0451*  	dl 0x0000FF ; 88.594 3F, 1.000
046841 00 01 00    0452*  	dl 0x000100 ; 90.000 40, 1.000
046844 FF 00 00    0453*  	dl 0x0000FF ; 91.406 41, 1.000
046847 FF 00 00    0454*  	dl 0x0000FF ; 92.813 42, 0.999
04684A FF 00 00    0455*  	dl 0x0000FF ; 94.219 43, 0.997
04684D FE 00 00    0456*  	dl 0x0000FE ; 95.625 44, 0.995
046850 FE 00 00    0457*  	dl 0x0000FE ; 97.031 45, 0.992
046853 FD 00 00    0458*  	dl 0x0000FD ; 98.438 46, 0.989
046856 FC 00 00    0459*  	dl 0x0000FC ; 99.844 47, 0.985
046859 FB 00 00    0460*  	dl 0x0000FB ; 101.250 48, 0.981
04685C F9 00 00    0461*  	dl 0x0000F9 ; 102.656 49, 0.976
04685F F8 00 00    0462*  	dl 0x0000F8 ; 104.063 4A, 0.970
046862 F6 00 00    0463*  	dl 0x0000F6 ; 105.469 4B, 0.964
046865 F4 00 00    0464*  	dl 0x0000F4 ; 106.875 4C, 0.957
046868 F3 00 00    0465*  	dl 0x0000F3 ; 108.281 4D, 0.950
04686B F1 00 00    0466*  	dl 0x0000F1 ; 109.688 4E, 0.942
04686E EE 00 00    0467*  	dl 0x0000EE ; 111.094 4F, 0.933
046871 EC 00 00    0468*  	dl 0x0000EC ; 112.500 50, 0.924
046874 EA 00 00    0469*  	dl 0x0000EA ; 113.906 51, 0.914
046877 E7 00 00    0470*  	dl 0x0000E7 ; 115.313 52, 0.904
04687A E4 00 00    0471*  	dl 0x0000E4 ; 116.719 53, 0.893
04687D E1 00 00    0472*  	dl 0x0000E1 ; 118.125 54, 0.882
046880 DE 00 00    0473*  	dl 0x0000DE ; 119.531 55, 0.870
046883 DB 00 00    0474*  	dl 0x0000DB ; 120.938 56, 0.858
046886 D8 00 00    0475*  	dl 0x0000D8 ; 122.344 57, 0.845
046889 D4 00 00    0476*  	dl 0x0000D4 ; 123.750 58, 0.831
04688C D1 00 00    0477*  	dl 0x0000D1 ; 125.156 59, 0.818
04688F CD 00 00    0478*  	dl 0x0000CD ; 126.563 5A, 0.803
046892 C9 00 00    0479*  	dl 0x0000C9 ; 127.969 5B, 0.788
046895 C5 00 00    0480*  	dl 0x0000C5 ; 129.375 5C, 0.773
046898 C1 00 00    0481*  	dl 0x0000C1 ; 130.781 5D, 0.757
04689B BD 00 00    0482*  	dl 0x0000BD ; 132.188 5E, 0.741
04689E B9 00 00    0483*  	dl 0x0000B9 ; 133.594 5F, 0.724
0468A1 B5 00 00    0484*  	dl 0x0000B5 ; 135.000 60, 0.707
0468A4 B0 00 00    0485*  	dl 0x0000B0 ; 136.406 61, 0.690
0468A7 AB 00 00    0486*  	dl 0x0000AB ; 137.813 62, 0.672
0468AA A7 00 00    0487*  	dl 0x0000A7 ; 139.219 63, 0.653
0468AD A2 00 00    0488*  	dl 0x0000A2 ; 140.625 64, 0.634
0468B0 9D 00 00    0489*  	dl 0x00009D ; 142.031 65, 0.615
0468B3 98 00 00    0490*  	dl 0x000098 ; 143.438 66, 0.596
0468B6 93 00 00    0491*  	dl 0x000093 ; 144.844 67, 0.576
0468B9 8E 00 00    0492*  	dl 0x00008E ; 146.250 68, 0.556
0468BC 88 00 00    0493*  	dl 0x000088 ; 147.656 69, 0.535
0468BF 83 00 00    0494*  	dl 0x000083 ; 149.063 6A, 0.514
0468C2 7E 00 00    0495*  	dl 0x00007E ; 150.469 6B, 0.493
0468C5 78 00 00    0496*  	dl 0x000078 ; 151.875 6C, 0.471
0468C8 73 00 00    0497*  	dl 0x000073 ; 153.281 6D, 0.450
0468CB 6D 00 00    0498*  	dl 0x00006D ; 154.688 6E, 0.428
0468CE 67 00 00    0499*  	dl 0x000067 ; 156.094 6F, 0.405
0468D1 61 00 00    0500*  	dl 0x000061 ; 157.500 70, 0.383
0468D4 5C 00 00    0501*  	dl 0x00005C ; 158.906 71, 0.360
0468D7 56 00 00    0502*  	dl 0x000056 ; 160.313 72, 0.337
0468DA 50 00 00    0503*  	dl 0x000050 ; 161.719 73, 0.314
0468DD 4A 00 00    0504*  	dl 0x00004A ; 163.125 74, 0.290
0468E0 44 00 00    0505*  	dl 0x000044 ; 164.531 75, 0.267
0468E3 3E 00 00    0506*  	dl 0x00003E ; 165.938 76, 0.243
0468E6 38 00 00    0507*  	dl 0x000038 ; 167.344 77, 0.219
0468E9 31 00 00    0508*  	dl 0x000031 ; 168.750 78, 0.195
0468EC 2B 00 00    0509*  	dl 0x00002B ; 170.156 79, 0.171
0468EF 25 00 00    0510*  	dl 0x000025 ; 171.563 7A, 0.147
0468F2 1F 00 00    0511*  	dl 0x00001F ; 172.969 7B, 0.122
0468F5 19 00 00    0512*  	dl 0x000019 ; 174.375 7C, 0.098
0468F8 12 00 00    0513*  	dl 0x000012 ; 175.781 7D, 0.074
0468FB 0C 00 00    0514*  	dl 0x00000C ; 177.188 7E, 0.049
0468FE 06 00 00    0515*  	dl 0x000006 ; 178.594 7F, 0.025
046901 00 00 00    0516*  	dl 0x000000 ; 180.000 80, 0.000
046904 FA FF FF    0517*  	dl 0xFFFFFA ; 181.406 81, -0.025
046907 F4 FF FF    0518*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04690A EE FF FF    0519*  	dl 0xFFFFEE ; 184.219 83, -0.074
04690D E7 FF FF    0520*  	dl 0xFFFFE7 ; 185.625 84, -0.098
046910 E1 FF FF    0521*  	dl 0xFFFFE1 ; 187.031 85, -0.122
046913 DB FF FF    0522*  	dl 0xFFFFDB ; 188.438 86, -0.147
046916 D5 FF FF    0523*  	dl 0xFFFFD5 ; 189.844 87, -0.171
046919 CF FF FF    0524*  	dl 0xFFFFCF ; 191.250 88, -0.195
04691C C8 FF FF    0525*  	dl 0xFFFFC8 ; 192.656 89, -0.219
04691F C2 FF FF    0526*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
046922 BC FF FF    0527*  	dl 0xFFFFBC ; 195.469 8B, -0.267
046925 B6 FF FF    0528*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
046928 B0 FF FF    0529*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04692B AA FF FF    0530*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04692E A4 FF FF    0531*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
046931 9F FF FF    0532*  	dl 0xFFFF9F ; 202.500 90, -0.383
046934 99 FF FF    0533*  	dl 0xFFFF99 ; 203.906 91, -0.405
046937 93 FF FF    0534*  	dl 0xFFFF93 ; 205.313 92, -0.428
04693A 8D FF FF    0535*  	dl 0xFFFF8D ; 206.719 93, -0.450
04693D 88 FF FF    0536*  	dl 0xFFFF88 ; 208.125 94, -0.471
046940 82 FF FF    0537*  	dl 0xFFFF82 ; 209.531 95, -0.493
046943 7D FF FF    0538*  	dl 0xFFFF7D ; 210.938 96, -0.514
046946 78 FF FF    0539*  	dl 0xFFFF78 ; 212.344 97, -0.535
046949 72 FF FF    0540*  	dl 0xFFFF72 ; 213.750 98, -0.556
04694C 6D FF FF    0541*  	dl 0xFFFF6D ; 215.156 99, -0.576
04694F 68 FF FF    0542*  	dl 0xFFFF68 ; 216.563 9A, -0.596
046952 63 FF FF    0543*  	dl 0xFFFF63 ; 217.969 9B, -0.615
046955 5E FF FF    0544*  	dl 0xFFFF5E ; 219.375 9C, -0.634
046958 59 FF FF    0545*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04695B 55 FF FF    0546*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04695E 50 FF FF    0547*  	dl 0xFFFF50 ; 223.594 9F, -0.690
046961 4B FF FF    0548*  	dl 0xFFFF4B ; 225.000 A0, -0.707
046964 47 FF FF    0549*  	dl 0xFFFF47 ; 226.406 A1, -0.724
046967 43 FF FF    0550*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04696A 3F FF FF    0551*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04696D 3B FF FF    0552*  	dl 0xFFFF3B ; 230.625 A4, -0.773
046970 37 FF FF    0553*  	dl 0xFFFF37 ; 232.031 A5, -0.788
046973 33 FF FF    0554*  	dl 0xFFFF33 ; 233.438 A6, -0.803
046976 2F FF FF    0555*  	dl 0xFFFF2F ; 234.844 A7, -0.818
046979 2C FF FF    0556*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04697C 28 FF FF    0557*  	dl 0xFFFF28 ; 237.656 A9, -0.845
04697F 25 FF FF    0558*  	dl 0xFFFF25 ; 239.063 AA, -0.858
046982 22 FF FF    0559*  	dl 0xFFFF22 ; 240.469 AB, -0.870
046985 1F FF FF    0560*  	dl 0xFFFF1F ; 241.875 AC, -0.882
046988 1C FF FF    0561*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04698B 19 FF FF    0562*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04698E 16 FF FF    0563*  	dl 0xFFFF16 ; 246.094 AF, -0.914
046991 14 FF FF    0564*  	dl 0xFFFF14 ; 247.500 B0, -0.924
046994 12 FF FF    0565*  	dl 0xFFFF12 ; 248.906 B1, -0.933
046997 0F FF FF    0566*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04699A 0D FF FF    0567*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04699D 0C FF FF    0568*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0469A0 0A FF FF    0569*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0469A3 08 FF FF    0570*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0469A6 07 FF FF    0571*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0469A9 05 FF FF    0572*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0469AC 04 FF FF    0573*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0469AF 03 FF FF    0574*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0469B2 02 FF FF    0575*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0469B5 02 FF FF    0576*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0469B8 01 FF FF    0577*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0469BB 01 FF FF    0578*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0469BE 01 FF FF    0579*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0469C1 00 FF FF    0580*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0469C4 01 FF FF    0581*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0469C7 01 FF FF    0582*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0469CA 01 FF FF    0583*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0469CD 02 FF FF    0584*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0469D0 02 FF FF    0585*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0469D3 03 FF FF    0586*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0469D6 04 FF FF    0587*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0469D9 05 FF FF    0588*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0469DC 07 FF FF    0589*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0469DF 08 FF FF    0590*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0469E2 0A FF FF    0591*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0469E5 0C FF FF    0592*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0469E8 0D FF FF    0593*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0469EB 0F FF FF    0594*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0469EE 12 FF FF    0595*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0469F1 14 FF FF    0596*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0469F4 16 FF FF    0597*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0469F7 19 FF FF    0598*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0469FA 1C FF FF    0599*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0469FD 1F FF FF    0600*  	dl 0xFFFF1F ; 298.125 D4, -0.882
046A00 22 FF FF    0601*  	dl 0xFFFF22 ; 299.531 D5, -0.870
046A03 25 FF FF    0602*  	dl 0xFFFF25 ; 300.938 D6, -0.858
046A06 28 FF FF    0603*  	dl 0xFFFF28 ; 302.344 D7, -0.845
046A09 2C FF FF    0604*  	dl 0xFFFF2C ; 303.750 D8, -0.831
046A0C 2F FF FF    0605*  	dl 0xFFFF2F ; 305.156 D9, -0.818
046A0F 33 FF FF    0606*  	dl 0xFFFF33 ; 306.563 DA, -0.803
046A12 37 FF FF    0607*  	dl 0xFFFF37 ; 307.969 DB, -0.788
046A15 3B FF FF    0608*  	dl 0xFFFF3B ; 309.375 DC, -0.773
046A18 3F FF FF    0609*  	dl 0xFFFF3F ; 310.781 DD, -0.757
046A1B 43 FF FF    0610*  	dl 0xFFFF43 ; 312.188 DE, -0.741
046A1E 47 FF FF    0611*  	dl 0xFFFF47 ; 313.594 DF, -0.724
046A21 4B FF FF    0612*  	dl 0xFFFF4B ; 315.000 E0, -0.707
046A24 50 FF FF    0613*  	dl 0xFFFF50 ; 316.406 E1, -0.690
046A27 55 FF FF    0614*  	dl 0xFFFF55 ; 317.813 E2, -0.672
046A2A 59 FF FF    0615*  	dl 0xFFFF59 ; 319.219 E3, -0.653
046A2D 5E FF FF    0616*  	dl 0xFFFF5E ; 320.625 E4, -0.634
046A30 63 FF FF    0617*  	dl 0xFFFF63 ; 322.031 E5, -0.615
046A33 68 FF FF    0618*  	dl 0xFFFF68 ; 323.438 E6, -0.596
046A36 6D FF FF    0619*  	dl 0xFFFF6D ; 324.844 E7, -0.576
046A39 72 FF FF    0620*  	dl 0xFFFF72 ; 326.250 E8, -0.556
046A3C 78 FF FF    0621*  	dl 0xFFFF78 ; 327.656 E9, -0.535
046A3F 7D FF FF    0622*  	dl 0xFFFF7D ; 329.063 EA, -0.514
046A42 82 FF FF    0623*  	dl 0xFFFF82 ; 330.469 EB, -0.493
046A45 88 FF FF    0624*  	dl 0xFFFF88 ; 331.875 EC, -0.471
046A48 8D FF FF    0625*  	dl 0xFFFF8D ; 333.281 ED, -0.450
046A4B 93 FF FF    0626*  	dl 0xFFFF93 ; 334.688 EE, -0.428
046A4E 99 FF FF    0627*  	dl 0xFFFF99 ; 336.094 EF, -0.405
046A51 9F FF FF    0628*  	dl 0xFFFF9F ; 337.500 F0, -0.383
046A54 A4 FF FF    0629*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
046A57 AA FF FF    0630*  	dl 0xFFFFAA ; 340.313 F2, -0.337
046A5A B0 FF FF    0631*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
046A5D B6 FF FF    0632*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
046A60 BC FF FF    0633*  	dl 0xFFFFBC ; 344.531 F5, -0.267
046A63 C2 FF FF    0634*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
046A66 C8 FF FF    0635*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
046A69 CF FF FF    0636*  	dl 0xFFFFCF ; 348.750 F8, -0.195
046A6C D5 FF FF    0637*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
046A6F DB FF FF    0638*  	dl 0xFFFFDB ; 351.563 FA, -0.147
046A72 E1 FF FF    0639*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
046A75 E7 FF FF    0640*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
046A78 EE FF FF    0641*  	dl 0xFFFFEE ; 355.781 FD, -0.074
046A7B F4 FF FF    0642*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
046A7E FA FF FF    0643*  	dl 0xFFFFFA ; 358.594 FF, -0.025
046A81 00 00 00    0644*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
046A84             0645*  
046A84             0646*  sin_lut_816:
046A84 00 00 00 48 0647*      dl 0x000000,0x000648 ; 00 000.000 0.000
       06 00       
046A8A 48 06 00 48 0648*      dl 0x000648,0x000648 ; 01 001.406 0.025
       06 00       
046A90 90 0C 00 45 0649*      dl 0x000C90,0x000645 ; 02 002.813 0.049
       06 00       
046A96 D5 12 00 42 0650*      dl 0x0012D5,0x000642 ; 03 004.219 0.074
       06 00       
046A9C 17 19 00 3E 0651*      dl 0x001917,0x00063E ; 04 005.625 0.098
       06 00       
046AA2 56 1F 00 3A 0652*      dl 0x001F56,0x00063A ; 05 007.031 0.122
       06 00       
046AA8 90 25 00 33 0653*      dl 0x002590,0x000633 ; 06 008.438 0.147
       06 00       
046AAE C4 2B 00 2C 0654*      dl 0x002BC4,0x00062C ; 07 009.844 0.171
       06 00       
046AB4 F1 31 00 25 0655*      dl 0x0031F1,0x000625 ; 08 011.250 0.195
       06 00       
046ABA 16 38 00 1D 0656*      dl 0x003816,0x00061D ; 09 012.656 0.219
       06 00       
046AC0 34 3E 00 13 0657*      dl 0x003E34,0x000613 ; 0A 014.063 0.243
       06 00       
046AC6 47 44 00 08 0658*      dl 0x004447,0x000608 ; 0B 015.469 0.267
       06 00       
046ACC 50 4A 00 FD 0659*      dl 0x004A50,0x0005FD ; 0C 016.875 0.290
       05 00       
046AD2 4D 50 00 F1 0660*      dl 0x00504D,0x0005F1 ; 0D 018.281 0.314
       05 00       
046AD8 3E 56 00 E3 0661*      dl 0x00563E,0x0005E3 ; 0E 019.688 0.337
       05 00       
046ADE 22 5C 00 D5 0662*      dl 0x005C22,0x0005D5 ; 0F 021.094 0.360
       05 00       
046AE4 F7 61 00 C6 0663*      dl 0x0061F7,0x0005C6 ; 10 022.500 0.383
       05 00       
046AEA BD 67 00 B7 0664*      dl 0x0067BD,0x0005B7 ; 11 023.906 0.405
       05 00       
046AF0 74 6D 00 A5 0665*      dl 0x006D74,0x0005A5 ; 12 025.313 0.428
       05 00       
046AF6 19 73 00 93 0666*      dl 0x007319,0x000593 ; 13 026.719 0.450
       05 00       
046AFC AD 78 00 80 0667*      dl 0x0078AD,0x000580 ; 14 028.125 0.471
       05 00       
046B02 2E 7E 00 6E 0668*      dl 0x007E2E,0x00056E ; 15 029.531 0.493
       05 00       
046B08 9C 83 00 59 0669*      dl 0x00839C,0x000559 ; 16 030.938 0.514
       05 00       
046B0E F5 88 00 44 0670*      dl 0x0088F5,0x000544 ; 17 032.344 0.535
       05 00       
046B14 39 8E 00 2E 0671*      dl 0x008E39,0x00052E ; 18 033.750 0.556
       05 00       
046B1A 67 93 00 18 0672*      dl 0x009367,0x000518 ; 19 035.156 0.576
       05 00       
046B20 80 98 00 FF 0673*      dl 0x009880,0x0004FF ; 1A 036.563 0.596
       04 00       
046B26 80 9D 00 E7 0674*      dl 0x009D80,0x0004E7 ; 1B 037.969 0.615
       04 00       
046B2C 67 A2 00 CE 0675*      dl 0x00A267,0x0004CE ; 1C 039.375 0.634
       04 00       
046B32 36 A7 00 B5 0676*      dl 0x00A736,0x0004B5 ; 1D 040.781 0.653
       04 00       
046B38 EB AB 00 9A 0677*      dl 0x00ABEB,0x00049A ; 1E 042.188 0.672
       04 00       
046B3E 85 B0 00 7F 0678*      dl 0x00B085,0x00047F ; 1F 043.594 0.690
       04 00       
046B44 04 B5 00 63 0679*      dl 0x00B504,0x000463 ; 20 045.000 0.707
       04 00       
046B4A 68 B9 00 47 0680*      dl 0x00B968,0x000447 ; 21 046.406 0.724
       04 00       
046B50 AF BD 00 29 0681*      dl 0x00BDAF,0x000429 ; 22 047.813 0.741
       04 00       
046B56 D8 C1 00 0B 0682*      dl 0x00C1D8,0x00040B ; 23 049.219 0.757
       04 00       
046B5C E4 C5 00 EC 0683*      dl 0x00C5E4,0x0003EC ; 24 050.625 0.773
       03 00       
046B62 D0 C9 00 CE 0684*      dl 0x00C9D0,0x0003CE ; 25 052.031 0.788
       03 00       
046B68 9F CD 00 AE 0685*      dl 0x00CD9F,0x0003AE ; 26 053.438 0.803
       03 00       
046B6E 4D D1 00 8D 0686*      dl 0x00D14D,0x00038D ; 27 054.844 0.818
       03 00       
046B74 DB D4 00 6C 0687*      dl 0x00D4DB,0x00036C ; 28 056.250 0.831
       03 00       
046B7A 48 D8 00 4C 0688*      dl 0x00D848,0x00034C ; 29 057.656 0.845
       03 00       
046B80 94 DB 00 29 0689*      dl 0x00DB94,0x000329 ; 2A 059.063 0.858
       03 00       
046B86 BE DE 00 07 0690*      dl 0x00DEBE,0x000307 ; 2B 060.469 0.870
       03 00       
046B8C C5 E1 00 E4 0691*      dl 0x00E1C5,0x0002E4 ; 2C 061.875 0.882
       02 00       
046B92 AA E4 00 C1 0692*      dl 0x00E4AA,0x0002C1 ; 2D 063.281 0.893
       02 00       
046B98 6C E7 00 9D 0693*      dl 0x00E76C,0x00029D ; 2E 064.688 0.904
       02 00       
046B9E 09 EA 00 79 0694*      dl 0x00EA09,0x000279 ; 2F 066.094 0.914
       02 00       
046BA4 83 EC 00 55 0695*      dl 0x00EC83,0x000255 ; 30 067.500 0.924
       02 00       
046BAA D8 EE 00 30 0696*      dl 0x00EED8,0x000230 ; 31 068.906 0.933
       02 00       
046BB0 09 F1 00 0B 0697*      dl 0x00F109,0x00020B ; 32 070.313 0.942
       02 00       
046BB6 14 F3 00 E5 0698*      dl 0x00F314,0x0001E5 ; 33 071.719 0.950
       01 00       
046BBC FA F4 00 BF 0699*      dl 0x00F4FA,0x0001BF ; 34 073.125 0.957
       01 00       
046BC2 B9 F6 00 9A 0700*      dl 0x00F6B9,0x00019A ; 35 074.531 0.964
       01 00       
046BC8 54 F8 00 73 0701*      dl 0x00F854,0x000173 ; 36 075.938 0.970
       01 00       
046BCE C7 F9 00 4D 0702*      dl 0x00F9C7,0x00014D ; 37 077.344 0.976
       01 00       
046BD4 14 FB 00 26 0703*      dl 0x00FB14,0x000126 ; 38 078.750 0.981
       01 00       
046BDA 3B FC 00 FF 0704*      dl 0x00FC3B,0x0000FF ; 39 080.156 0.985
       00 00       
046BE0 3A FD 00 D8 0705*      dl 0x00FD3A,0x0000D8 ; 3A 081.563 0.989
       00 00       
046BE6 13 FE 00 B1 0706*      dl 0x00FE13,0x0000B1 ; 3B 082.969 0.992
       00 00       
046BEC C4 FE 00 89 0707*      dl 0x00FEC4,0x000089 ; 3C 084.375 0.995
       00 00       
046BF2 4E FF 00 62 0708*      dl 0x00FF4E,0x000062 ; 3D 085.781 0.997
       00 00       
046BF8 B1 FF 00 3B 0709*      dl 0x00FFB1,0x00003B ; 3E 087.188 0.999
       00 00       
046BFE EC FF 00 13 0710*      dl 0x00FFEC,0x000013 ; 3F 088.594 1.000
       00 00       
046C04 00 00 01 EC 0711*      dl 0x010000,0xFFFFEC ; 40 090.000 1.000
       FF FF       
046C0A EC FF 00 C4 0712*      dl 0x00FFEC,0xFFFFC4 ; 41 091.406 1.000
       FF FF       
046C10 B1 FF 00 9D 0713*      dl 0x00FFB1,0xFFFF9D ; 42 092.813 0.999
       FF FF       
046C16 4E FF 00 76 0714*      dl 0x00FF4E,0xFFFF76 ; 43 094.219 0.997
       FF FF       
046C1C C4 FE 00 4E 0715*      dl 0x00FEC4,0xFFFF4E ; 44 095.625 0.995
       FF FF       
046C22 13 FE 00 27 0716*      dl 0x00FE13,0xFFFF27 ; 45 097.031 0.992
       FF FF       
046C28 3A FD 00 00 0717*      dl 0x00FD3A,0xFFFF00 ; 46 098.438 0.989
       FF FF       
046C2E 3B FC 00 D9 0718*      dl 0x00FC3B,0xFFFED9 ; 47 099.844 0.985
       FE FF       
046C34 14 FB 00 B2 0719*      dl 0x00FB14,0xFFFEB2 ; 48 101.250 0.981
       FE FF       
046C3A C7 F9 00 8C 0720*      dl 0x00F9C7,0xFFFE8C ; 49 102.656 0.976
       FE FF       
046C40 53 F8 00 66 0721*      dl 0x00F853,0xFFFE66 ; 4A 104.063 0.970
       FE FF       
046C46 B9 F6 00 40 0722*      dl 0x00F6B9,0xFFFE40 ; 4B 105.469 0.964
       FE FF       
046C4C FA F4 00 1A 0723*      dl 0x00F4FA,0xFFFE1A ; 4C 106.875 0.957
       FE FF       
046C52 14 F3 00 F4 0724*      dl 0x00F314,0xFFFDF4 ; 4D 108.281 0.950
       FD FF       
046C58 08 F1 00 CF 0725*      dl 0x00F108,0xFFFDCF ; 4E 109.688 0.942
       FD FF       
046C5E D8 EE 00 AA 0726*      dl 0x00EED8,0xFFFDAA ; 4F 111.094 0.933
       FD FF       
046C64 83 EC 00 86 0727*      dl 0x00EC83,0xFFFD86 ; 50 112.500 0.924
       FD FF       
046C6A 09 EA 00 61 0728*      dl 0x00EA09,0xFFFD61 ; 51 113.906 0.914
       FD FF       
046C70 6B E7 00 3E 0729*      dl 0x00E76B,0xFFFD3E ; 52 115.313 0.904
       FD FF       
046C76 AA E4 00 1B 0730*      dl 0x00E4AA,0xFFFD1B ; 53 116.719 0.893
       FD FF       
046C7C C5 E1 00 F8 0731*      dl 0x00E1C5,0xFFFCF8 ; 54 118.125 0.882
       FC FF       
046C82 BE DE 00 D5 0732*      dl 0x00DEBE,0xFFFCD5 ; 55 119.531 0.870
       FC FF       
046C88 93 DB 00 B4 0733*      dl 0x00DB93,0xFFFCB4 ; 56 120.938 0.858
       FC FF       
046C8E 48 D8 00 93 0734*      dl 0x00D848,0xFFFC93 ; 57 122.344 0.845
       FC FF       
046C94 DB D4 00 72 0735*      dl 0x00D4DB,0xFFFC72 ; 58 123.750 0.831
       FC FF       
046C9A 4D D1 00 51 0736*      dl 0x00D14D,0xFFFC51 ; 59 125.156 0.818
       FC FF       
046CA0 9E CD 00 32 0737*      dl 0x00CD9E,0xFFFC32 ; 5A 126.563 0.803
       FC FF       
046CA6 D0 C9 00 13 0738*      dl 0x00C9D0,0xFFFC13 ; 5B 127.969 0.788
       FC FF       
046CAC E4 C5 00 F4 0739*      dl 0x00C5E4,0xFFFBF4 ; 5C 129.375 0.773
       FB FF       
046CB2 D8 C1 00 D5 0740*      dl 0x00C1D8,0xFFFBD5 ; 5D 130.781 0.757
       FB FF       
046CB8 AE BD 00 B9 0741*      dl 0x00BDAE,0xFFFBB9 ; 5E 132.188 0.741
       FB FF       
046CBE 68 B9 00 9C 0742*      dl 0x00B968,0xFFFB9C ; 5F 133.594 0.724
       FB FF       
046CC4 04 B5 00 80 0743*      dl 0x00B504,0xFFFB80 ; 60 135.000 0.707
       FB FF       
046CCA 85 B0 00 64 0744*      dl 0x00B085,0xFFFB64 ; 61 136.406 0.690
       FB FF       
046CD0 EA AB 00 4B 0745*      dl 0x00ABEA,0xFFFB4B ; 62 137.813 0.672
       FB FF       
046CD6 36 A7 00 31 0746*      dl 0x00A736,0xFFFB31 ; 63 139.219 0.653
       FB FF       
046CDC 67 A2 00 18 0747*      dl 0x00A267,0xFFFB18 ; 64 140.625 0.634
       FB FF       
046CE2 80 9D 00 FF 0748*      dl 0x009D80,0xFFFAFF ; 65 142.031 0.615
       FA FF       
046CE8 7F 98 00 E8 0749*      dl 0x00987F,0xFFFAE8 ; 66 143.438 0.596
       FA FF       
046CEE 67 93 00 D1 0750*      dl 0x009367,0xFFFAD1 ; 67 144.844 0.576
       FA FF       
046CF4 39 8E 00 BB 0751*      dl 0x008E39,0xFFFABB ; 68 146.250 0.556
       FA FF       
046CFA F5 88 00 A5 0752*      dl 0x0088F5,0xFFFAA5 ; 69 147.656 0.535
       FA FF       
046D00 9B 83 00 92 0753*      dl 0x00839B,0xFFFA92 ; 6A 149.063 0.514
       FA FF       
046D06 2E 7E 00 7F 0754*      dl 0x007E2E,0xFFFA7F ; 6B 150.469 0.493
       FA FF       
046D0C AD 78 00 6C 0755*      dl 0x0078AD,0xFFFA6C ; 6C 151.875 0.471
       FA FF       
046D12 19 73 00 59 0756*      dl 0x007319,0xFFFA59 ; 6D 153.281 0.450
       FA FF       
046D18 73 6D 00 49 0757*      dl 0x006D73,0xFFFA49 ; 6E 154.688 0.428
       FA FF       
046D1E BD 67 00 39 0758*      dl 0x0067BD,0xFFFA39 ; 6F 156.094 0.405
       FA FF       
046D24 F7 61 00 2A 0759*      dl 0x0061F7,0xFFFA2A ; 70 157.500 0.383
       FA FF       
046D2A 22 5C 00 1B 0760*      dl 0x005C22,0xFFFA1B ; 71 158.906 0.360
       FA FF       
046D30 3D 56 00 0F 0761*      dl 0x00563D,0xFFFA0F ; 72 160.313 0.337
       FA FF       
046D36 4D 50 00 02 0762*      dl 0x00504D,0xFFFA02 ; 73 161.719 0.314
       FA FF       
046D3C 50 4A 00 F7 0763*      dl 0x004A50,0xFFF9F7 ; 74 163.125 0.290
       F9 FF       
046D42 47 44 00 EB 0764*      dl 0x004447,0xFFF9EB ; 75 164.531 0.267
       F9 FF       
046D48 33 3E 00 E3 0765*      dl 0x003E33,0xFFF9E3 ; 76 165.938 0.243
       F9 FF       
046D4E 16 38 00 DA 0766*      dl 0x003816,0xFFF9DA ; 77 167.344 0.219
       F9 FF       
046D54 F1 31 00 D3 0767*      dl 0x0031F1,0xFFF9D3 ; 78 168.750 0.195
       F9 FF       
046D5A C4 2B 00 CB 0768*      dl 0x002BC4,0xFFF9CB ; 79 170.156 0.171
       F9 FF       
046D60 8F 25 00 C6 0769*      dl 0x00258F,0xFFF9C6 ; 7A 171.563 0.147
       F9 FF       
046D66 56 1F 00 C1 0770*      dl 0x001F56,0xFFF9C1 ; 7B 172.969 0.122
       F9 FF       
046D6C 17 19 00 BD 0771*      dl 0x001917,0xFFF9BD ; 7C 174.375 0.098
       F9 FF       
046D72 D5 12 00 B9 0772*      dl 0x0012D5,0xFFF9B9 ; 7D 175.781 0.074
       F9 FF       
046D78 8F 0C 00 B8 0773*      dl 0x000C8F,0xFFF9B8 ; 7E 177.188 0.049
       F9 FF       
046D7E 48 06 00 B7 0774*      dl 0x000648,0xFFF9B7 ; 7F 178.594 0.025
       F9 FF       
046D84 00 00 00 B7 0775*      dl 0x000000,0xFFF9B7 ; 80 180.000 0.000
       F9 FF       
046D8A B8 F9 FF B7 0776*      dl 0xFFF9B8,0xFFF9B7 ; 81 181.406 -0.025
       F9 FF       
046D90 70 F3 FF BA 0777*      dl 0xFFF370,0xFFF9BA ; 82 182.813 -0.049
       F9 FF       
046D96 2B ED FF BD 0778*      dl 0xFFED2B,0xFFF9BD ; 83 184.219 -0.074
       F9 FF       
046D9C E9 E6 FF C1 0779*      dl 0xFFE6E9,0xFFF9C1 ; 84 185.625 -0.098
       F9 FF       
046DA2 AA E0 FF C5 0780*      dl 0xFFE0AA,0xFFF9C5 ; 85 187.031 -0.122
       F9 FF       
046DA8 70 DA FF CC 0781*      dl 0xFFDA70,0xFFF9CC ; 86 188.438 -0.147
       F9 FF       
046DAE 3C D4 FF D3 0782*      dl 0xFFD43C,0xFFF9D3 ; 87 189.844 -0.171
       F9 FF       
046DB4 0F CE FF DA 0783*      dl 0xFFCE0F,0xFFF9DA ; 88 191.250 -0.195
       F9 FF       
046DBA EA C7 FF E2 0784*      dl 0xFFC7EA,0xFFF9E2 ; 89 192.656 -0.219
       F9 FF       
046DC0 CC C1 FF EC 0785*      dl 0xFFC1CC,0xFFF9EC ; 8A 194.063 -0.243
       F9 FF       
046DC6 B9 BB FF F7 0786*      dl 0xFFBBB9,0xFFF9F7 ; 8B 195.469 -0.267
       F9 FF       
046DCC B0 B5 FF 02 0787*      dl 0xFFB5B0,0xFFFA02 ; 8C 196.875 -0.290
       FA FF       
046DD2 B3 AF FF 0E 0788*      dl 0xFFAFB3,0xFFFA0E ; 8D 198.281 -0.314
       FA FF       
046DD8 C2 A9 FF 1C 0789*      dl 0xFFA9C2,0xFFFA1C ; 8E 199.688 -0.337
       FA FF       
046DDE DE A3 FF 2A 0790*      dl 0xFFA3DE,0xFFFA2A ; 8F 201.094 -0.360
       FA FF       
046DE4 09 9E FF 39 0791*      dl 0xFF9E09,0xFFFA39 ; 90 202.500 -0.383
       FA FF       
046DEA 43 98 FF 48 0792*      dl 0xFF9843,0xFFFA48 ; 91 203.906 -0.405
       FA FF       
046DF0 8C 92 FF 5A 0793*      dl 0xFF928C,0xFFFA5A ; 92 205.313 -0.428
       FA FF       
046DF6 E7 8C FF 6C 0794*      dl 0xFF8CE7,0xFFFA6C ; 93 206.719 -0.450
       FA FF       
046DFC 53 87 FF 7F 0795*      dl 0xFF8753,0xFFFA7F ; 94 208.125 -0.471
       FA FF       
046E02 D2 81 FF 91 0796*      dl 0xFF81D2,0xFFFA91 ; 95 209.531 -0.493
       FA FF       
046E08 64 7C FF A6 0797*      dl 0xFF7C64,0xFFFAA6 ; 96 210.938 -0.514
       FA FF       
046E0E 0B 77 FF BB 0798*      dl 0xFF770B,0xFFFABB ; 97 212.344 -0.535
       FA FF       
046E14 C7 71 FF D1 0799*      dl 0xFF71C7,0xFFFAD1 ; 98 213.750 -0.556
       FA FF       
046E1A 99 6C FF E7 0800*      dl 0xFF6C99,0xFFFAE7 ; 99 215.156 -0.576
       FA FF       
046E20 80 67 FF 00 0801*      dl 0xFF6780,0xFFFB00 ; 9A 216.563 -0.596
       FB FF       
046E26 80 62 FF 18 0802*      dl 0xFF6280,0xFFFB18 ; 9B 217.969 -0.615
       FB FF       
046E2C 99 5D FF 31 0803*      dl 0xFF5D99,0xFFFB31 ; 9C 219.375 -0.634
       FB FF       
046E32 CA 58 FF 4A 0804*      dl 0xFF58CA,0xFFFB4A ; 9D 220.781 -0.653
       FB FF       
046E38 15 54 FF 65 0805*      dl 0xFF5415,0xFFFB65 ; 9E 222.188 -0.672
       FB FF       
046E3E 7B 4F FF 80 0806*      dl 0xFF4F7B,0xFFFB80 ; 9F 223.594 -0.690
       FB FF       
046E44 FC 4A FF 9C 0807*      dl 0xFF4AFC,0xFFFB9C ; A0 225.000 -0.707
       FB FF       
046E4A 98 46 FF B8 0808*      dl 0xFF4698,0xFFFBB8 ; A1 226.406 -0.724
       FB FF       
046E50 51 42 FF D6 0809*      dl 0xFF4251,0xFFFBD6 ; A2 227.813 -0.741
       FB FF       
046E56 28 3E FF F4 0810*      dl 0xFF3E28,0xFFFBF4 ; A3 229.219 -0.757
       FB FF       
046E5C 1C 3A FF 13 0811*      dl 0xFF3A1C,0xFFFC13 ; A4 230.625 -0.773
       FC FF       
046E62 30 36 FF 31 0812*      dl 0xFF3630,0xFFFC31 ; A5 232.031 -0.788
       FC FF       
046E68 61 32 FF 51 0813*      dl 0xFF3261,0xFFFC51 ; A6 233.438 -0.803
       FC FF       
046E6E B3 2E FF 72 0814*      dl 0xFF2EB3,0xFFFC72 ; A7 234.844 -0.818
       FC FF       
046E74 25 2B FF 93 0815*      dl 0xFF2B25,0xFFFC93 ; A8 236.250 -0.831
       FC FF       
046E7A B8 27 FF B3 0816*      dl 0xFF27B8,0xFFFCB3 ; A9 237.656 -0.845
       FC FF       
046E80 6C 24 FF D6 0817*      dl 0xFF246C,0xFFFCD6 ; AA 239.063 -0.858
       FC FF       
046E86 42 21 FF F8 0818*      dl 0xFF2142,0xFFFCF8 ; AB 240.469 -0.870
       FC FF       
046E8C 3B 1E FF 1B 0819*      dl 0xFF1E3B,0xFFFD1B ; AC 241.875 -0.882
       FD FF       
046E92 56 1B FF 3E 0820*      dl 0xFF1B56,0xFFFD3E ; AD 243.281 -0.893
       FD FF       
046E98 94 18 FF 62 0821*      dl 0xFF1894,0xFFFD62 ; AE 244.688 -0.904
       FD FF       
046E9E F7 15 FF 86 0822*      dl 0xFF15F7,0xFFFD86 ; AF 246.094 -0.914
       FD FF       
046EA4 7D 13 FF AA 0823*      dl 0xFF137D,0xFFFDAA ; B0 247.500 -0.924
       FD FF       
046EAA 28 11 FF CF 0824*      dl 0xFF1128,0xFFFDCF ; B1 248.906 -0.933
       FD FF       
046EB0 F7 0E FF F4 0825*      dl 0xFF0EF7,0xFFFDF4 ; B2 250.313 -0.942
       FD FF       
046EB6 EC 0C FF 1A 0826*      dl 0xFF0CEC,0xFFFE1A ; B3 251.719 -0.950
       FE FF       
046EBC 06 0B FF 40 0827*      dl 0xFF0B06,0xFFFE40 ; B4 253.125 -0.957
       FE FF       
046EC2 47 09 FF 65 0828*      dl 0xFF0947,0xFFFE65 ; B5 254.531 -0.964
       FE FF       
046EC8 AC 07 FF 8C 0829*      dl 0xFF07AC,0xFFFE8C ; B6 255.938 -0.970
       FE FF       
046ECE 39 06 FF B2 0830*      dl 0xFF0639,0xFFFEB2 ; B7 257.344 -0.976
       FE FF       
046ED4 EC 04 FF D9 0831*      dl 0xFF04EC,0xFFFED9 ; B8 258.750 -0.981
       FE FF       
046EDA C5 03 FF 00 0832*      dl 0xFF03C5,0xFFFF00 ; B9 260.156 -0.985
       FF FF       
046EE0 C6 02 FF 27 0833*      dl 0xFF02C6,0xFFFF27 ; BA 261.563 -0.989
       FF FF       
046EE6 ED 01 FF 4E 0834*      dl 0xFF01ED,0xFFFF4E ; BB 262.969 -0.992
       FF FF       
046EEC 3C 01 FF 76 0835*      dl 0xFF013C,0xFFFF76 ; BC 264.375 -0.995
       FF FF       
046EF2 B2 00 FF 9D 0836*      dl 0xFF00B2,0xFFFF9D ; BD 265.781 -0.997
       FF FF       
046EF8 4F 00 FF C4 0837*      dl 0xFF004F,0xFFFFC4 ; BE 267.188 -0.999
       FF FF       
046EFE 14 00 FF EC 0838*      dl 0xFF0014,0xFFFFEC ; BF 268.594 -1.000
       FF FF       
046F04 00 00 FF 13 0839*      dl 0xFF0000,0x000013 ; C0 270.000 -1.000
       00 00       
046F0A 14 00 FF 3B 0840*      dl 0xFF0014,0x00003B ; C1 271.406 -1.000
       00 00       
046F10 4F 00 FF 62 0841*      dl 0xFF004F,0x000062 ; C2 272.813 -0.999
       00 00       
046F16 B2 00 FF 89 0842*      dl 0xFF00B2,0x000089 ; C3 274.219 -0.997
       00 00       
046F1C 3C 01 FF B1 0843*      dl 0xFF013C,0x0000B1 ; C4 275.625 -0.995
       00 00       
046F22 ED 01 FF D8 0844*      dl 0xFF01ED,0x0000D8 ; C5 277.031 -0.992
       00 00       
046F28 C6 02 FF FF 0845*      dl 0xFF02C6,0x0000FF ; C6 278.438 -0.989
       00 00       
046F2E C5 03 FF 26 0846*      dl 0xFF03C5,0x000126 ; C7 279.844 -0.985
       01 00       
046F34 EC 04 FF 4D 0847*      dl 0xFF04EC,0x00014D ; C8 281.250 -0.981
       01 00       
046F3A 39 06 FF 73 0848*      dl 0xFF0639,0x000173 ; C9 282.656 -0.976
       01 00       
046F40 AD 07 FF 99 0849*      dl 0xFF07AD,0x000199 ; CA 284.063 -0.970
       01 00       
046F46 47 09 FF BF 0850*      dl 0xFF0947,0x0001BF ; CB 285.469 -0.964
       01 00       
046F4C 06 0B FF E5 0851*      dl 0xFF0B06,0x0001E5 ; CC 286.875 -0.957
       01 00       
046F52 EC 0C FF 0B 0852*      dl 0xFF0CEC,0x00020B ; CD 288.281 -0.950
       02 00       
046F58 F8 0E FF 30 0853*      dl 0xFF0EF8,0x000230 ; CE 289.688 -0.942
       02 00       
046F5E 28 11 FF 55 0854*      dl 0xFF1128,0x000255 ; CF 291.094 -0.933
       02 00       
046F64 7D 13 FF 79 0855*      dl 0xFF137D,0x000279 ; D0 292.500 -0.924
       02 00       
046F6A F7 15 FF 9E 0856*      dl 0xFF15F7,0x00029E ; D1 293.906 -0.914
       02 00       
046F70 95 18 FF C1 0857*      dl 0xFF1895,0x0002C1 ; D2 295.313 -0.904
       02 00       
046F76 56 1B FF E4 0858*      dl 0xFF1B56,0x0002E4 ; D3 296.719 -0.893
       02 00       
046F7C 3B 1E FF 07 0859*      dl 0xFF1E3B,0x000307 ; D4 298.125 -0.882
       03 00       
046F82 42 21 FF 2A 0860*      dl 0xFF2142,0x00032A ; D5 299.531 -0.870
       03 00       
046F88 6D 24 FF 4B 0861*      dl 0xFF246D,0x00034B ; D6 300.938 -0.858
       03 00       
046F8E B8 27 FF 6C 0862*      dl 0xFF27B8,0x00036C ; D7 302.344 -0.845
       03 00       
046F94 25 2B FF 8D 0863*      dl 0xFF2B25,0x00038D ; D8 303.750 -0.831
       03 00       
046F9A B3 2E FF AE 0864*      dl 0xFF2EB3,0x0003AE ; D9 305.156 -0.818
       03 00       
046FA0 62 32 FF CD 0865*      dl 0xFF3262,0x0003CD ; DA 306.563 -0.803
       03 00       
046FA6 30 36 FF EC 0866*      dl 0xFF3630,0x0003EC ; DB 307.969 -0.788
       03 00       
046FAC 1C 3A FF 0B 0867*      dl 0xFF3A1C,0x00040B ; DC 309.375 -0.773
       04 00       
046FB2 28 3E FF 2A 0868*      dl 0xFF3E28,0x00042A ; DD 310.781 -0.757
       04 00       
046FB8 52 42 FF 46 0869*      dl 0xFF4252,0x000446 ; DE 312.188 -0.741
       04 00       
046FBE 98 46 FF 63 0870*      dl 0xFF4698,0x000463 ; DF 313.594 -0.724
       04 00       
046FC4 FC 4A FF 7F 0871*      dl 0xFF4AFC,0x00047F ; E0 315.000 -0.707
       04 00       
046FCA 7B 4F FF 9B 0872*      dl 0xFF4F7B,0x00049B ; E1 316.406 -0.690
       04 00       
046FD0 16 54 FF B4 0873*      dl 0xFF5416,0x0004B4 ; E2 317.813 -0.672
       04 00       
046FD6 CA 58 FF CE 0874*      dl 0xFF58CA,0x0004CE ; E3 319.219 -0.653
       04 00       
046FDC 99 5D FF E7 0875*      dl 0xFF5D99,0x0004E7 ; E4 320.625 -0.634
       04 00       
046FE2 80 62 FF 00 0876*      dl 0xFF6280,0x000500 ; E5 322.031 -0.615
       05 00       
046FE8 81 67 FF 17 0877*      dl 0xFF6781,0x000517 ; E6 323.438 -0.596
       05 00       
046FEE 99 6C FF 2E 0878*      dl 0xFF6C99,0x00052E ; E7 324.844 -0.576
       05 00       
046FF4 C7 71 FF 44 0879*      dl 0xFF71C7,0x000544 ; E8 326.250 -0.556
       05 00       
046FFA 0B 77 FF 5A 0880*      dl 0xFF770B,0x00055A ; E9 327.656 -0.535
       05 00       
047000 65 7C FF 6D 0881*      dl 0xFF7C65,0x00056D ; EA 329.063 -0.514
       05 00       
047006 D2 81 FF 80 0882*      dl 0xFF81D2,0x000580 ; EB 330.469 -0.493
       05 00       
04700C 53 87 FF 93 0883*      dl 0xFF8753,0x000593 ; EC 331.875 -0.471
       05 00       
047012 E7 8C FF A6 0884*      dl 0xFF8CE7,0x0005A6 ; ED 333.281 -0.450
       05 00       
047018 8D 92 FF B6 0885*      dl 0xFF928D,0x0005B6 ; EE 334.688 -0.428
       05 00       
04701E 43 98 FF C6 0886*      dl 0xFF9843,0x0005C6 ; EF 336.094 -0.405
       05 00       
047024 09 9E FF D5 0887*      dl 0xFF9E09,0x0005D5 ; F0 337.500 -0.383
       05 00       
04702A DE A3 FF E4 0888*      dl 0xFFA3DE,0x0005E4 ; F1 338.906 -0.360
       05 00       
047030 C3 A9 FF F0 0889*      dl 0xFFA9C3,0x0005F0 ; F2 340.313 -0.337
       05 00       
047036 B3 AF FF FD 0890*      dl 0xFFAFB3,0x0005FD ; F3 341.719 -0.314
       05 00       
04703C B0 B5 FF 08 0891*      dl 0xFFB5B0,0x000608 ; F4 343.125 -0.290
       06 00       
047042 B9 BB FF 14 0892*      dl 0xFFBBB9,0x000614 ; F5 344.531 -0.267
       06 00       
047048 CD C1 FF 1C 0893*      dl 0xFFC1CD,0x00061C ; F6 345.938 -0.243
       06 00       
04704E EA C7 FF 25 0894*      dl 0xFFC7EA,0x000625 ; F7 347.344 -0.219
       06 00       
047054 0F CE FF 2C 0895*      dl 0xFFCE0F,0x00062C ; F8 348.750 -0.195
       06 00       
04705A 3C D4 FF 34 0896*      dl 0xFFD43C,0x000634 ; F9 350.156 -0.171
       06 00       
047060 71 DA FF 39 0897*      dl 0xFFDA71,0x000639 ; FA 351.563 -0.147
       06 00       
047066 AA E0 FF 3E 0898*      dl 0xFFE0AA,0x00063E ; FB 352.969 -0.122
       06 00       
04706C E9 E6 FF 42 0899*      dl 0xFFE6E9,0x000642 ; FC 354.375 -0.098
       06 00       
047072 2B ED FF 46 0900*      dl 0xFFED2B,0x000646 ; FD 355.781 -0.074
       06 00       
047078 71 F3 FF 47 0901*      dl 0xFFF371,0x000647 ; FE 357.188 -0.049
       06 00       
04707E B8 F9 FF 48 0902*      dl 0xFFF9B8,0x000648 ; FF 358.594 -0.025
       06 00       
047084 00 00 00 48 0903*      dl 0x000000,0x000648 ; 00 360.000 0.000
       06 00       
04708A             0904*  
04708A             0905*  sin_lut_1212:
04708A 00 00 00    0906*      dl 0x000000 ; 00, 00.000, +0.000000
04708D 65 00 00    0907*      dl 0x000065 ; 01, 01.406, +0.024541
047090 C9 00 00    0908*      dl 0x0000C9 ; 02, 02.812, +0.049068
047093 2D 01 00    0909*      dl 0x00012D ; 03, 04.219, +0.073565
047096 91 01 00    0910*      dl 0x000191 ; 04, 05.625, +0.098017
047099 F5 01 00    0911*      dl 0x0001F5 ; 05, 07.031, +0.122411
04709C 59 02 00    0912*      dl 0x000259 ; 06, 08.438, +0.146730
04709F BC 02 00    0913*      dl 0x0002BC ; 07, 09.844, +0.170962
0470A2 1F 03 00    0914*      dl 0x00031F ; 08, 11.250, +0.195090
0470A5 81 03 00    0915*      dl 0x000381 ; 09, 12.656, +0.219101
0470A8 E3 03 00    0916*      dl 0x0003E3 ; 0A, 14.062, +0.242980
0470AB 44 04 00    0917*      dl 0x000444 ; 0B, 15.469, +0.266713
0470AE A5 04 00    0918*      dl 0x0004A5 ; 0C, 16.875, +0.290285
0470B1 05 05 00    0919*      dl 0x000505 ; 0D, 18.281, +0.313682
0470B4 64 05 00    0920*      dl 0x000564 ; 0E, 19.688, +0.336890
0470B7 C2 05 00    0921*      dl 0x0005C2 ; 0F, 21.094, +0.359895
0470BA 1F 06 00    0922*      dl 0x00061F ; 10, 22.500, +0.382683
0470BD 7C 06 00    0923*      dl 0x00067C ; 11, 23.906, +0.405241
0470C0 D7 06 00    0924*      dl 0x0006D7 ; 12, 25.312, +0.427555
0470C3 32 07 00    0925*      dl 0x000732 ; 13, 26.719, +0.449611
0470C6 8B 07 00    0926*      dl 0x00078B ; 14, 28.125, +0.471397
0470C9 E3 07 00    0927*      dl 0x0007E3 ; 15, 29.531, +0.492898
0470CC 3A 08 00    0928*      dl 0x00083A ; 16, 30.938, +0.514103
0470CF 8F 08 00    0929*      dl 0x00088F ; 17, 32.344, +0.534998
0470D2 E4 08 00    0930*      dl 0x0008E4 ; 18, 33.750, +0.555570
0470D5 37 09 00    0931*      dl 0x000937 ; 19, 35.156, +0.575808
0470D8 88 09 00    0932*      dl 0x000988 ; 1A, 36.562, +0.595699
0470DB D8 09 00    0933*      dl 0x0009D8 ; 1B, 37.969, +0.615232
0470DE 26 0A 00    0934*      dl 0x000A26 ; 1C, 39.375, +0.634393
0470E1 73 0A 00    0935*      dl 0x000A73 ; 1D, 40.781, +0.653173
0470E4 BF 0A 00    0936*      dl 0x000ABF ; 1E, 42.188, +0.671559
0470E7 08 0B 00    0937*      dl 0x000B08 ; 1F, 43.594, +0.689541
0470EA 50 0B 00    0938*      dl 0x000B50 ; 20, 45.000, +0.707107
0470ED 97 0B 00    0939*      dl 0x000B97 ; 21, 46.406, +0.724247
0470F0 DB 0B 00    0940*      dl 0x000BDB ; 22, 47.812, +0.740951
0470F3 1E 0C 00    0941*      dl 0x000C1E ; 23, 49.219, +0.757209
0470F6 5E 0C 00    0942*      dl 0x000C5E ; 24, 50.625, +0.773010
0470F9 9D 0C 00    0943*      dl 0x000C9D ; 25, 52.031, +0.788346
0470FC DA 0C 00    0944*      dl 0x000CDA ; 26, 53.438, +0.803208
0470FF 15 0D 00    0945*      dl 0x000D15 ; 27, 54.844, +0.817585
047102 4E 0D 00    0946*      dl 0x000D4E ; 28, 56.250, +0.831470
047105 85 0D 00    0947*      dl 0x000D85 ; 29, 57.656, +0.844854
047108 B9 0D 00    0948*      dl 0x000DB9 ; 2A, 59.062, +0.857729
04710B EC 0D 00    0949*      dl 0x000DEC ; 2B, 60.469, +0.870087
04710E 1C 0E 00    0950*      dl 0x000E1C ; 2C, 61.875, +0.881921
047111 4B 0E 00    0951*      dl 0x000E4B ; 2D, 63.281, +0.893224
047114 77 0E 00    0952*      dl 0x000E77 ; 2E, 64.688, +0.903989
047117 A1 0E 00    0953*      dl 0x000EA1 ; 2F, 66.094, +0.914210
04711A C8 0E 00    0954*      dl 0x000EC8 ; 30, 67.500, +0.923880
04711D EE 0E 00    0955*      dl 0x000EEE ; 31, 68.906, +0.932993
047120 11 0F 00    0956*      dl 0x000F11 ; 32, 70.312, +0.941544
047123 31 0F 00    0957*      dl 0x000F31 ; 33, 71.719, +0.949528
047126 50 0F 00    0958*      dl 0x000F50 ; 34, 73.125, +0.956940
047129 6C 0F 00    0959*      dl 0x000F6C ; 35, 74.531, +0.963776
04712C 85 0F 00    0960*      dl 0x000F85 ; 36, 75.938, +0.970031
04712F 9C 0F 00    0961*      dl 0x000F9C ; 37, 77.344, +0.975702
047132 B1 0F 00    0962*      dl 0x000FB1 ; 38, 78.750, +0.980785
047135 C4 0F 00    0963*      dl 0x000FC4 ; 39, 80.156, +0.985278
047138 D4 0F 00    0964*      dl 0x000FD4 ; 3A, 81.562, +0.989177
04713B E1 0F 00    0965*      dl 0x000FE1 ; 3B, 82.969, +0.992480
04713E EC 0F 00    0966*      dl 0x000FEC ; 3C, 84.375, +0.995185
047141 F5 0F 00    0967*      dl 0x000FF5 ; 3D, 85.781, +0.997290
047144 FB 0F 00    0968*      dl 0x000FFB ; 3E, 87.188, +0.998795
047147 FF 0F 00    0969*      dl 0x000FFF ; 3F, 88.594, +0.999699
04714A 00 10 00    0970*      dl 0x001000 ; 40, 90.000, +1.000000
04714D FF 0F 00    0971*      dl 0x000FFF ; 41, 91.406, +0.999699
047150 FB 0F 00    0972*      dl 0x000FFB ; 42, 92.812, +0.998795
047153 F5 0F 00    0973*      dl 0x000FF5 ; 43, 94.219, +0.997290
047156 EC 0F 00    0974*      dl 0x000FEC ; 44, 95.625, +0.995185
047159 E1 0F 00    0975*      dl 0x000FE1 ; 45, 97.031, +0.992480
04715C D4 0F 00    0976*      dl 0x000FD4 ; 46, 98.438, +0.989177
04715F C4 0F 00    0977*      dl 0x000FC4 ; 47, 99.844, +0.985278
047162 B1 0F 00    0978*      dl 0x000FB1 ; 48, 101.250, +0.980785
047165 9C 0F 00    0979*      dl 0x000F9C ; 49, 102.656, +0.975702
047168 85 0F 00    0980*      dl 0x000F85 ; 4A, 104.062, +0.970031
04716B 6C 0F 00    0981*      dl 0x000F6C ; 4B, 105.469, +0.963776
04716E 50 0F 00    0982*      dl 0x000F50 ; 4C, 106.875, +0.956940
047171 31 0F 00    0983*      dl 0x000F31 ; 4D, 108.281, +0.949528
047174 11 0F 00    0984*      dl 0x000F11 ; 4E, 109.688, +0.941544
047177 EE 0E 00    0985*      dl 0x000EEE ; 4F, 111.094, +0.932993
04717A C8 0E 00    0986*      dl 0x000EC8 ; 50, 112.500, +0.923880
04717D A1 0E 00    0987*      dl 0x000EA1 ; 51, 113.906, +0.914210
047180 77 0E 00    0988*      dl 0x000E77 ; 52, 115.312, +0.903989
047183 4B 0E 00    0989*      dl 0x000E4B ; 53, 116.719, +0.893224
047186 1C 0E 00    0990*      dl 0x000E1C ; 54, 118.125, +0.881921
047189 EC 0D 00    0991*      dl 0x000DEC ; 55, 119.531, +0.870087
04718C B9 0D 00    0992*      dl 0x000DB9 ; 56, 120.938, +0.857729
04718F 85 0D 00    0993*      dl 0x000D85 ; 57, 122.344, +0.844854
047192 4E 0D 00    0994*      dl 0x000D4E ; 58, 123.750, +0.831470
047195 15 0D 00    0995*      dl 0x000D15 ; 59, 125.156, +0.817585
047198 DA 0C 00    0996*      dl 0x000CDA ; 5A, 126.562, +0.803208
04719B 9D 0C 00    0997*      dl 0x000C9D ; 5B, 127.969, +0.788346
04719E 5E 0C 00    0998*      dl 0x000C5E ; 5C, 129.375, +0.773010
0471A1 1E 0C 00    0999*      dl 0x000C1E ; 5D, 130.781, +0.757209
0471A4 DB 0B 00    1000*      dl 0x000BDB ; 5E, 132.188, +0.740951
0471A7 97 0B 00    1001*      dl 0x000B97 ; 5F, 133.594, +0.724247
0471AA 50 0B 00    1002*      dl 0x000B50 ; 60, 135.000, +0.707107
0471AD 08 0B 00    1003*      dl 0x000B08 ; 61, 136.406, +0.689541
0471B0 BF 0A 00    1004*      dl 0x000ABF ; 62, 137.812, +0.671559
0471B3 73 0A 00    1005*      dl 0x000A73 ; 63, 139.219, +0.653173
0471B6 26 0A 00    1006*      dl 0x000A26 ; 64, 140.625, +0.634393
0471B9 D8 09 00    1007*      dl 0x0009D8 ; 65, 142.031, +0.615232
0471BC 88 09 00    1008*      dl 0x000988 ; 66, 143.438, +0.595699
0471BF 37 09 00    1009*      dl 0x000937 ; 67, 144.844, +0.575808
0471C2 E4 08 00    1010*      dl 0x0008E4 ; 68, 146.250, +0.555570
0471C5 8F 08 00    1011*      dl 0x00088F ; 69, 147.656, +0.534998
0471C8 3A 08 00    1012*      dl 0x00083A ; 6A, 149.062, +0.514103
0471CB E3 07 00    1013*      dl 0x0007E3 ; 6B, 150.469, +0.492898
0471CE 8B 07 00    1014*      dl 0x00078B ; 6C, 151.875, +0.471397
0471D1 32 07 00    1015*      dl 0x000732 ; 6D, 153.281, +0.449611
0471D4 D7 06 00    1016*      dl 0x0006D7 ; 6E, 154.688, +0.427555
0471D7 7C 06 00    1017*      dl 0x00067C ; 6F, 156.094, +0.405241
0471DA 1F 06 00    1018*      dl 0x00061F ; 70, 157.500, +0.382683
0471DD C2 05 00    1019*      dl 0x0005C2 ; 71, 158.906, +0.359895
0471E0 64 05 00    1020*      dl 0x000564 ; 72, 160.312, +0.336890
0471E3 05 05 00    1021*      dl 0x000505 ; 73, 161.719, +0.313682
0471E6 A5 04 00    1022*      dl 0x0004A5 ; 74, 163.125, +0.290285
0471E9 44 04 00    1023*      dl 0x000444 ; 75, 164.531, +0.266713
0471EC E3 03 00    1024*      dl 0x0003E3 ; 76, 165.938, +0.242980
0471EF 81 03 00    1025*      dl 0x000381 ; 77, 167.344, +0.219101
0471F2 1F 03 00    1026*      dl 0x00031F ; 78, 168.750, +0.195090
0471F5 BC 02 00    1027*      dl 0x0002BC ; 79, 170.156, +0.170962
0471F8 59 02 00    1028*      dl 0x000259 ; 7A, 171.562, +0.146730
0471FB F5 01 00    1029*      dl 0x0001F5 ; 7B, 172.969, +0.122411
0471FE 91 01 00    1030*      dl 0x000191 ; 7C, 174.375, +0.098017
047201 2D 01 00    1031*      dl 0x00012D ; 7D, 175.781, +0.073565
047204 C9 00 00    1032*      dl 0x0000C9 ; 7E, 177.188, +0.049068
047207 65 00 00    1033*      dl 0x000065 ; 7F, 178.594, +0.024541
04720A 00 00 00    1034*      dl 0x000000 ; 80, 180.000, +0.000000
04720D 9B FF FF    1035*      dl 0xFFFF9B ; 81, 181.406, -0.024541
047210 37 FF FF    1036*      dl 0xFFFF37 ; 82, 182.812, -0.049068
047213 D3 FE FF    1037*      dl 0xFFFED3 ; 83, 184.219, -0.073565
047216 6F FE FF    1038*      dl 0xFFFE6F ; 84, 185.625, -0.098017
047219 0B FE FF    1039*      dl 0xFFFE0B ; 85, 187.031, -0.122411
04721C A7 FD FF    1040*      dl 0xFFFDA7 ; 86, 188.438, -0.146730
04721F 44 FD FF    1041*      dl 0xFFFD44 ; 87, 189.844, -0.170962
047222 E1 FC FF    1042*      dl 0xFFFCE1 ; 88, 191.250, -0.195090
047225 7F FC FF    1043*      dl 0xFFFC7F ; 89, 192.656, -0.219101
047228 1D FC FF    1044*      dl 0xFFFC1D ; 8A, 194.062, -0.242980
04722B BC FB FF    1045*      dl 0xFFFBBC ; 8B, 195.469, -0.266713
04722E 5B FB FF    1046*      dl 0xFFFB5B ; 8C, 196.875, -0.290285
047231 FB FA FF    1047*      dl 0xFFFAFB ; 8D, 198.281, -0.313682
047234 9C FA FF    1048*      dl 0xFFFA9C ; 8E, 199.688, -0.336890
047237 3E FA FF    1049*      dl 0xFFFA3E ; 8F, 201.094, -0.359895
04723A E1 F9 FF    1050*      dl 0xFFF9E1 ; 90, 202.500, -0.382683
04723D 84 F9 FF    1051*      dl 0xFFF984 ; 91, 203.906, -0.405241
047240 29 F9 FF    1052*      dl 0xFFF929 ; 92, 205.312, -0.427555
047243 CE F8 FF    1053*      dl 0xFFF8CE ; 93, 206.719, -0.449611
047246 75 F8 FF    1054*      dl 0xFFF875 ; 94, 208.125, -0.471397
047249 1D F8 FF    1055*      dl 0xFFF81D ; 95, 209.531, -0.492898
04724C C6 F7 FF    1056*      dl 0xFFF7C6 ; 96, 210.938, -0.514103
04724F 71 F7 FF    1057*      dl 0xFFF771 ; 97, 212.344, -0.534998
047252 1C F7 FF    1058*      dl 0xFFF71C ; 98, 213.750, -0.555570
047255 C9 F6 FF    1059*      dl 0xFFF6C9 ; 99, 215.156, -0.575808
047258 78 F6 FF    1060*      dl 0xFFF678 ; 9A, 216.562, -0.595699
04725B 28 F6 FF    1061*      dl 0xFFF628 ; 9B, 217.969, -0.615232
04725E DA F5 FF    1062*      dl 0xFFF5DA ; 9C, 219.375, -0.634393
047261 8D F5 FF    1063*      dl 0xFFF58D ; 9D, 220.781, -0.653173
047264 41 F5 FF    1064*      dl 0xFFF541 ; 9E, 222.188, -0.671559
047267 F8 F4 FF    1065*      dl 0xFFF4F8 ; 9F, 223.594, -0.689541
04726A B0 F4 FF    1066*      dl 0xFFF4B0 ; A0, 225.000, -0.707107
04726D 69 F4 FF    1067*      dl 0xFFF469 ; A1, 226.406, -0.724247
047270 25 F4 FF    1068*      dl 0xFFF425 ; A2, 227.812, -0.740951
047273 E2 F3 FF    1069*      dl 0xFFF3E2 ; A3, 229.219, -0.757209
047276 A2 F3 FF    1070*      dl 0xFFF3A2 ; A4, 230.625, -0.773010
047279 63 F3 FF    1071*      dl 0xFFF363 ; A5, 232.031, -0.788346
04727C 26 F3 FF    1072*      dl 0xFFF326 ; A6, 233.438, -0.803208
04727F EB F2 FF    1073*      dl 0xFFF2EB ; A7, 234.844, -0.817585
047282 B2 F2 FF    1074*      dl 0xFFF2B2 ; A8, 236.250, -0.831470
047285 7B F2 FF    1075*      dl 0xFFF27B ; A9, 237.656, -0.844854
047288 47 F2 FF    1076*      dl 0xFFF247 ; AA, 239.062, -0.857729
04728B 14 F2 FF    1077*      dl 0xFFF214 ; AB, 240.469, -0.870087
04728E E4 F1 FF    1078*      dl 0xFFF1E4 ; AC, 241.875, -0.881921
047291 B5 F1 FF    1079*      dl 0xFFF1B5 ; AD, 243.281, -0.893224
047294 89 F1 FF    1080*      dl 0xFFF189 ; AE, 244.688, -0.903989
047297 5F F1 FF    1081*      dl 0xFFF15F ; AF, 246.094, -0.914210
04729A 38 F1 FF    1082*      dl 0xFFF138 ; B0, 247.500, -0.923880
04729D 12 F1 FF    1083*      dl 0xFFF112 ; B1, 248.906, -0.932993
0472A0 EF F0 FF    1084*      dl 0xFFF0EF ; B2, 250.312, -0.941544
0472A3 CF F0 FF    1085*      dl 0xFFF0CF ; B3, 251.719, -0.949528
0472A6 B0 F0 FF    1086*      dl 0xFFF0B0 ; B4, 253.125, -0.956940
0472A9 94 F0 FF    1087*      dl 0xFFF094 ; B5, 254.531, -0.963776
0472AC 7B F0 FF    1088*      dl 0xFFF07B ; B6, 255.938, -0.970031
0472AF 64 F0 FF    1089*      dl 0xFFF064 ; B7, 257.344, -0.975702
0472B2 4F F0 FF    1090*      dl 0xFFF04F ; B8, 258.750, -0.980785
0472B5 3C F0 FF    1091*      dl 0xFFF03C ; B9, 260.156, -0.985278
0472B8 2C F0 FF    1092*      dl 0xFFF02C ; BA, 261.562, -0.989177
0472BB 1F F0 FF    1093*      dl 0xFFF01F ; BB, 262.969, -0.992480
0472BE 14 F0 FF    1094*      dl 0xFFF014 ; BC, 264.375, -0.995185
0472C1 0B F0 FF    1095*      dl 0xFFF00B ; BD, 265.781, -0.997290
0472C4 05 F0 FF    1096*      dl 0xFFF005 ; BE, 267.188, -0.998795
0472C7 01 F0 FF    1097*      dl 0xFFF001 ; BF, 268.594, -0.999699
0472CA 00 F0 FF    1098*      dl 0xFFF000 ; C0, 270.000, -1.000000
0472CD 01 F0 FF    1099*      dl 0xFFF001 ; C1, 271.406, -0.999699
0472D0 05 F0 FF    1100*      dl 0xFFF005 ; C2, 272.812, -0.998795
0472D3 0B F0 FF    1101*      dl 0xFFF00B ; C3, 274.219, -0.997290
0472D6 14 F0 FF    1102*      dl 0xFFF014 ; C4, 275.625, -0.995185
0472D9 1F F0 FF    1103*      dl 0xFFF01F ; C5, 277.031, -0.992480
0472DC 2C F0 FF    1104*      dl 0xFFF02C ; C6, 278.438, -0.989177
0472DF 3C F0 FF    1105*      dl 0xFFF03C ; C7, 279.844, -0.985278
0472E2 4F F0 FF    1106*      dl 0xFFF04F ; C8, 281.250, -0.980785
0472E5 64 F0 FF    1107*      dl 0xFFF064 ; C9, 282.656, -0.975702
0472E8 7B F0 FF    1108*      dl 0xFFF07B ; CA, 284.062, -0.970031
0472EB 94 F0 FF    1109*      dl 0xFFF094 ; CB, 285.469, -0.963776
0472EE B0 F0 FF    1110*      dl 0xFFF0B0 ; CC, 286.875, -0.956940
0472F1 CF F0 FF    1111*      dl 0xFFF0CF ; CD, 288.281, -0.949528
0472F4 EF F0 FF    1112*      dl 0xFFF0EF ; CE, 289.688, -0.941544
0472F7 12 F1 FF    1113*      dl 0xFFF112 ; CF, 291.094, -0.932993
0472FA 38 F1 FF    1114*      dl 0xFFF138 ; D0, 292.500, -0.923880
0472FD 5F F1 FF    1115*      dl 0xFFF15F ; D1, 293.906, -0.914210
047300 89 F1 FF    1116*      dl 0xFFF189 ; D2, 295.312, -0.903989
047303 B5 F1 FF    1117*      dl 0xFFF1B5 ; D3, 296.719, -0.893224
047306 E4 F1 FF    1118*      dl 0xFFF1E4 ; D4, 298.125, -0.881921
047309 14 F2 FF    1119*      dl 0xFFF214 ; D5, 299.531, -0.870087
04730C 47 F2 FF    1120*      dl 0xFFF247 ; D6, 300.938, -0.857729
04730F 7B F2 FF    1121*      dl 0xFFF27B ; D7, 302.344, -0.844854
047312 B2 F2 FF    1122*      dl 0xFFF2B2 ; D8, 303.750, -0.831470
047315 EB F2 FF    1123*      dl 0xFFF2EB ; D9, 305.156, -0.817585
047318 26 F3 FF    1124*      dl 0xFFF326 ; DA, 306.562, -0.803208
04731B 63 F3 FF    1125*      dl 0xFFF363 ; DB, 307.969, -0.788346
04731E A2 F3 FF    1126*      dl 0xFFF3A2 ; DC, 309.375, -0.773010
047321 E2 F3 FF    1127*      dl 0xFFF3E2 ; DD, 310.781, -0.757209
047324 25 F4 FF    1128*      dl 0xFFF425 ; DE, 312.188, -0.740951
047327 69 F4 FF    1129*      dl 0xFFF469 ; DF, 313.594, -0.724247
04732A B0 F4 FF    1130*      dl 0xFFF4B0 ; E0, 315.000, -0.707107
04732D F8 F4 FF    1131*      dl 0xFFF4F8 ; E1, 316.406, -0.689541
047330 41 F5 FF    1132*      dl 0xFFF541 ; E2, 317.812, -0.671559
047333 8D F5 FF    1133*      dl 0xFFF58D ; E3, 319.219, -0.653173
047336 DA F5 FF    1134*      dl 0xFFF5DA ; E4, 320.625, -0.634393
047339 28 F6 FF    1135*      dl 0xFFF628 ; E5, 322.031, -0.615232
04733C 78 F6 FF    1136*      dl 0xFFF678 ; E6, 323.438, -0.595699
04733F C9 F6 FF    1137*      dl 0xFFF6C9 ; E7, 324.844, -0.575808
047342 1C F7 FF    1138*      dl 0xFFF71C ; E8, 326.250, -0.555570
047345 71 F7 FF    1139*      dl 0xFFF771 ; E9, 327.656, -0.534998
047348 C6 F7 FF    1140*      dl 0xFFF7C6 ; EA, 329.062, -0.514103
04734B 1D F8 FF    1141*      dl 0xFFF81D ; EB, 330.469, -0.492898
04734E 75 F8 FF    1142*      dl 0xFFF875 ; EC, 331.875, -0.471397
047351 CE F8 FF    1143*      dl 0xFFF8CE ; ED, 333.281, -0.449611
047354 29 F9 FF    1144*      dl 0xFFF929 ; EE, 334.688, -0.427555
047357 84 F9 FF    1145*      dl 0xFFF984 ; EF, 336.094, -0.405241
04735A E1 F9 FF    1146*      dl 0xFFF9E1 ; F0, 337.500, -0.382683
04735D 3E FA FF    1147*      dl 0xFFFA3E ; F1, 338.906, -0.359895
047360 9C FA FF    1148*      dl 0xFFFA9C ; F2, 340.312, -0.336890
047363 FB FA FF    1149*      dl 0xFFFAFB ; F3, 341.719, -0.313682
047366 5B FB FF    1150*      dl 0xFFFB5B ; F4, 343.125, -0.290285
047369 BC FB FF    1151*      dl 0xFFFBBC ; F5, 344.531, -0.266713
04736C 1D FC FF    1152*      dl 0xFFFC1D ; F6, 345.938, -0.242980
04736F 7F FC FF    1153*      dl 0xFFFC7F ; F7, 347.344, -0.219101
047372 E1 FC FF    1154*      dl 0xFFFCE1 ; F8, 348.750, -0.195090
047375 44 FD FF    1155*      dl 0xFFFD44 ; F9, 350.156, -0.170962
047378 A7 FD FF    1156*      dl 0xFFFDA7 ; FA, 351.562, -0.146730
04737B 0B FE FF    1157*      dl 0xFFFE0B ; FB, 352.969, -0.122411
04737E 6F FE FF    1158*      dl 0xFFFE6F ; FC, 354.375, -0.098017
047381 D3 FE FF    1159*      dl 0xFFFED3 ; FD, 355.781, -0.073565
047384 37 FF FF    1160*      dl 0xFFFF37 ; FE, 357.188, -0.049068
047387 9B FF FF    1161*      dl 0xFFFF9B ; FF, 358.594, -0.024541
04738A             1162*  
04738A             1163*  atan_lut_168:
04738A 00 00 00    1164*  	dl 0x000000 ; 000000, 0.000
04738D 28 00 00    1165*  	dl 0x000028 ; 000001, 0.224
047390 51 00 00    1166*  	dl 0x000051 ; 000002, 0.448
047393 7A 00 00    1167*  	dl 0x00007A ; 000003, 0.671
047396 A2 00 00    1168*  	dl 0x0000A2 ; 000004, 0.895
047399 CB 00 00    1169*  	dl 0x0000CB ; 000005, 1.119
04739C F4 00 00    1170*  	dl 0x0000F4 ; 000006, 1.343
04739F 1D 01 00    1171*  	dl 0x00011D ; 000007, 1.566
0473A2 45 01 00    1172*  	dl 0x000145 ; 000008, 1.790
0473A5 6E 01 00    1173*  	dl 0x00016E ; 000009, 2.013
0473A8 97 01 00    1174*  	dl 0x000197 ; 00000A, 2.237
0473AB BF 01 00    1175*  	dl 0x0001BF ; 00000B, 2.460
0473AE E8 01 00    1176*  	dl 0x0001E8 ; 00000C, 2.684
0473B1 11 02 00    1177*  	dl 0x000211 ; 00000D, 2.907
0473B4 39 02 00    1178*  	dl 0x000239 ; 00000E, 3.130
0473B7 62 02 00    1179*  	dl 0x000262 ; 00000F, 3.353
0473BA 8B 02 00    1180*  	dl 0x00028B ; 000010, 3.576
0473BD B3 02 00    1181*  	dl 0x0002B3 ; 000011, 3.799
0473C0 DC 02 00    1182*  	dl 0x0002DC ; 000012, 4.022
0473C3 04 03 00    1183*  	dl 0x000304 ; 000013, 4.245
0473C6 2D 03 00    1184*  	dl 0x00032D ; 000014, 4.467
0473C9 55 03 00    1185*  	dl 0x000355 ; 000015, 4.690
0473CC 7E 03 00    1186*  	dl 0x00037E ; 000016, 4.912
0473CF A6 03 00    1187*  	dl 0x0003A6 ; 000017, 5.134
0473D2 CE 03 00    1188*  	dl 0x0003CE ; 000018, 5.356
0473D5 F7 03 00    1189*  	dl 0x0003F7 ; 000019, 5.578
0473D8 1F 04 00    1190*  	dl 0x00041F ; 00001A, 5.799
0473DB 48 04 00    1191*  	dl 0x000448 ; 00001B, 6.021
0473DE 70 04 00    1192*  	dl 0x000470 ; 00001C, 6.242
0473E1 98 04 00    1193*  	dl 0x000498 ; 00001D, 6.463
0473E4 C0 04 00    1194*  	dl 0x0004C0 ; 00001E, 6.684
0473E7 E8 04 00    1195*  	dl 0x0004E8 ; 00001F, 6.905
0473EA 11 05 00    1196*  	dl 0x000511 ; 000020, 7.125
0473ED 39 05 00    1197*  	dl 0x000539 ; 000021, 7.345
0473F0 61 05 00    1198*  	dl 0x000561 ; 000022, 7.565
0473F3 89 05 00    1199*  	dl 0x000589 ; 000023, 7.785
0473F6 B1 05 00    1200*  	dl 0x0005B1 ; 000024, 8.005
0473F9 D9 05 00    1201*  	dl 0x0005D9 ; 000025, 8.224
0473FC 01 06 00    1202*  	dl 0x000601 ; 000026, 8.443
0473FF 28 06 00    1203*  	dl 0x000628 ; 000027, 8.662
047402 50 06 00    1204*  	dl 0x000650 ; 000028, 8.881
047405 78 06 00    1205*  	dl 0x000678 ; 000029, 9.099
047408 A0 06 00    1206*  	dl 0x0006A0 ; 00002A, 9.317
04740B C7 06 00    1207*  	dl 0x0006C7 ; 00002B, 9.535
04740E EF 06 00    1208*  	dl 0x0006EF ; 00002C, 9.752
047411 16 07 00    1209*  	dl 0x000716 ; 00002D, 9.970
047414 3E 07 00    1210*  	dl 0x00073E ; 00002E, 10.187
047417 65 07 00    1211*  	dl 0x000765 ; 00002F, 10.403
04741A 8D 07 00    1212*  	dl 0x00078D ; 000030, 10.620
04741D B4 07 00    1213*  	dl 0x0007B4 ; 000031, 10.836
047420 DB 07 00    1214*  	dl 0x0007DB ; 000032, 11.051
047423 03 08 00    1215*  	dl 0x000803 ; 000033, 11.267
047426 2A 08 00    1216*  	dl 0x00082A ; 000034, 11.482
047429 51 08 00    1217*  	dl 0x000851 ; 000035, 11.697
04742C 78 08 00    1218*  	dl 0x000878 ; 000036, 11.911
04742F 9F 08 00    1219*  	dl 0x00089F ; 000037, 12.125
047432 C6 08 00    1220*  	dl 0x0008C6 ; 000038, 12.339
047435 ED 08 00    1221*  	dl 0x0008ED ; 000039, 12.553
047438 13 09 00    1222*  	dl 0x000913 ; 00003A, 12.766
04743B 3A 09 00    1223*  	dl 0x00093A ; 00003B, 12.978
04743E 61 09 00    1224*  	dl 0x000961 ; 00003C, 13.191
047441 87 09 00    1225*  	dl 0x000987 ; 00003D, 13.403
047444 AE 09 00    1226*  	dl 0x0009AE ; 00003E, 13.614
047447 D4 09 00    1227*  	dl 0x0009D4 ; 00003F, 13.825
04744A FB 09 00    1228*  	dl 0x0009FB ; 000040, 14.036
04744D 21 0A 00    1229*  	dl 0x000A21 ; 000041, 14.247
047450 47 0A 00    1230*  	dl 0x000A47 ; 000042, 14.457
047453 6D 0A 00    1231*  	dl 0x000A6D ; 000043, 14.666
047456 94 0A 00    1232*  	dl 0x000A94 ; 000044, 14.876
047459 BA 0A 00    1233*  	dl 0x000ABA ; 000045, 15.085
04745C E0 0A 00    1234*  	dl 0x000AE0 ; 000046, 15.293
04745F 05 0B 00    1235*  	dl 0x000B05 ; 000047, 15.501
047462 2B 0B 00    1236*  	dl 0x000B2B ; 000048, 15.709
047465 51 0B 00    1237*  	dl 0x000B51 ; 000049, 15.916
047468 77 0B 00    1238*  	dl 0x000B77 ; 00004A, 16.123
04746B 9C 0B 00    1239*  	dl 0x000B9C ; 00004B, 16.329
04746E C2 0B 00    1240*  	dl 0x000BC2 ; 00004C, 16.535
047471 E7 0B 00    1241*  	dl 0x000BE7 ; 00004D, 16.740
047474 0C 0C 00    1242*  	dl 0x000C0C ; 00004E, 16.945
047477 32 0C 00    1243*  	dl 0x000C32 ; 00004F, 17.150
04747A 57 0C 00    1244*  	dl 0x000C57 ; 000050, 17.354
04747D 7C 0C 00    1245*  	dl 0x000C7C ; 000051, 17.558
047480 A1 0C 00    1246*  	dl 0x000CA1 ; 000052, 17.761
047483 C6 0C 00    1247*  	dl 0x000CC6 ; 000053, 17.964
047486 EB 0C 00    1248*  	dl 0x000CEB ; 000054, 18.166
047489 0F 0D 00    1249*  	dl 0x000D0F ; 000055, 18.368
04748C 34 0D 00    1250*  	dl 0x000D34 ; 000056, 18.569
04748F 58 0D 00    1251*  	dl 0x000D58 ; 000057, 18.770
047492 7D 0D 00    1252*  	dl 0x000D7D ; 000058, 18.970
047495 A1 0D 00    1253*  	dl 0x000DA1 ; 000059, 19.170
047498 C6 0D 00    1254*  	dl 0x000DC6 ; 00005A, 19.370
04749B EA 0D 00    1255*  	dl 0x000DEA ; 00005B, 19.569
04749E 0E 0E 00    1256*  	dl 0x000E0E ; 00005C, 19.767
0474A1 32 0E 00    1257*  	dl 0x000E32 ; 00005D, 19.965
0474A4 56 0E 00    1258*  	dl 0x000E56 ; 00005E, 20.163
0474A7 7A 0E 00    1259*  	dl 0x000E7A ; 00005F, 20.360
0474AA 9E 0E 00    1260*  	dl 0x000E9E ; 000060, 20.556
0474AD C1 0E 00    1261*  	dl 0x000EC1 ; 000061, 20.752
0474B0 E5 0E 00    1262*  	dl 0x000EE5 ; 000062, 20.947
0474B3 08 0F 00    1263*  	dl 0x000F08 ; 000063, 21.142
0474B6 2C 0F 00    1264*  	dl 0x000F2C ; 000064, 21.337
0474B9 4F 0F 00    1265*  	dl 0x000F4F ; 000065, 21.531
0474BC 72 0F 00    1266*  	dl 0x000F72 ; 000066, 21.724
0474BF 95 0F 00    1267*  	dl 0x000F95 ; 000067, 21.917
0474C2 B8 0F 00    1268*  	dl 0x000FB8 ; 000068, 22.109
0474C5 DB 0F 00    1269*  	dl 0x000FDB ; 000069, 22.301
0474C8 FE 0F 00    1270*  	dl 0x000FFE ; 00006A, 22.493
0474CB 21 10 00    1271*  	dl 0x001021 ; 00006B, 22.683
0474CE 44 10 00    1272*  	dl 0x001044 ; 00006C, 22.874
0474D1 66 10 00    1273*  	dl 0x001066 ; 00006D, 23.063
0474D4 89 10 00    1274*  	dl 0x001089 ; 00006E, 23.253
0474D7 AB 10 00    1275*  	dl 0x0010AB ; 00006F, 23.441
0474DA CD 10 00    1276*  	dl 0x0010CD ; 000070, 23.629
0474DD EF 10 00    1277*  	dl 0x0010EF ; 000071, 23.817
0474E0 11 11 00    1278*  	dl 0x001111 ; 000072, 24.004
0474E3 33 11 00    1279*  	dl 0x001133 ; 000073, 24.191
0474E6 55 11 00    1280*  	dl 0x001155 ; 000074, 24.376
0474E9 77 11 00    1281*  	dl 0x001177 ; 000075, 24.562
0474EC 99 11 00    1282*  	dl 0x001199 ; 000076, 24.747
0474EF BA 11 00    1283*  	dl 0x0011BA ; 000077, 24.931
0474F2 DC 11 00    1284*  	dl 0x0011DC ; 000078, 25.115
0474F5 FD 11 00    1285*  	dl 0x0011FD ; 000079, 25.298
0474F8 1E 12 00    1286*  	dl 0x00121E ; 00007A, 25.481
0474FB 3F 12 00    1287*  	dl 0x00123F ; 00007B, 25.663
0474FE 60 12 00    1288*  	dl 0x001260 ; 00007C, 25.844
047501 81 12 00    1289*  	dl 0x001281 ; 00007D, 26.025
047504 A2 12 00    1290*  	dl 0x0012A2 ; 00007E, 26.206
047507 C3 12 00    1291*  	dl 0x0012C3 ; 00007F, 26.386
04750A E4 12 00    1292*  	dl 0x0012E4 ; 000080, 26.565
04750D 04 13 00    1293*  	dl 0x001304 ; 000081, 26.744
047510 25 13 00    1294*  	dl 0x001325 ; 000082, 26.922
047513 45 13 00    1295*  	dl 0x001345 ; 000083, 27.100
047516 65 13 00    1296*  	dl 0x001365 ; 000084, 27.277
047519 85 13 00    1297*  	dl 0x001385 ; 000085, 27.453
04751C A5 13 00    1298*  	dl 0x0013A5 ; 000086, 27.629
04751F C5 13 00    1299*  	dl 0x0013C5 ; 000087, 27.805
047522 E5 13 00    1300*  	dl 0x0013E5 ; 000088, 27.979
047525 05 14 00    1301*  	dl 0x001405 ; 000089, 28.154
047528 24 14 00    1302*  	dl 0x001424 ; 00008A, 28.327
04752B 44 14 00    1303*  	dl 0x001444 ; 00008B, 28.501
04752E 63 14 00    1304*  	dl 0x001463 ; 00008C, 28.673
047531 83 14 00    1305*  	dl 0x001483 ; 00008D, 28.845
047534 A2 14 00    1306*  	dl 0x0014A2 ; 00008E, 29.017
047537 C1 14 00    1307*  	dl 0x0014C1 ; 00008F, 29.187
04753A E0 14 00    1308*  	dl 0x0014E0 ; 000090, 29.358
04753D FF 14 00    1309*  	dl 0x0014FF ; 000091, 29.527
047540 1E 15 00    1310*  	dl 0x00151E ; 000092, 29.697
047543 3C 15 00    1311*  	dl 0x00153C ; 000093, 29.865
047546 5B 15 00    1312*  	dl 0x00155B ; 000094, 30.033
047549 79 15 00    1313*  	dl 0x001579 ; 000095, 30.201
04754C 98 15 00    1314*  	dl 0x001598 ; 000096, 30.368
04754F B6 15 00    1315*  	dl 0x0015B6 ; 000097, 30.534
047552 D4 15 00    1316*  	dl 0x0015D4 ; 000098, 30.700
047555 F2 15 00    1317*  	dl 0x0015F2 ; 000099, 30.865
047558 10 16 00    1318*  	dl 0x001610 ; 00009A, 31.030
04755B 2E 16 00    1319*  	dl 0x00162E ; 00009B, 31.194
04755E 4C 16 00    1320*  	dl 0x00164C ; 00009C, 31.357
047561 6A 16 00    1321*  	dl 0x00166A ; 00009D, 31.520
047564 87 16 00    1322*  	dl 0x001687 ; 00009E, 31.682
047567 A5 16 00    1323*  	dl 0x0016A5 ; 00009F, 31.844
04756A C2 16 00    1324*  	dl 0x0016C2 ; 0000A0, 32.005
04756D DF 16 00    1325*  	dl 0x0016DF ; 0000A1, 32.166
047570 FC 16 00    1326*  	dl 0x0016FC ; 0000A2, 32.326
047573 19 17 00    1327*  	dl 0x001719 ; 0000A3, 32.486
047576 36 17 00    1328*  	dl 0x001736 ; 0000A4, 32.645
047579 53 17 00    1329*  	dl 0x001753 ; 0000A5, 32.803
04757C 70 17 00    1330*  	dl 0x001770 ; 0000A6, 32.961
04757F 8C 17 00    1331*  	dl 0x00178C ; 0000A7, 33.118
047582 A9 17 00    1332*  	dl 0x0017A9 ; 0000A8, 33.275
047585 C5 17 00    1333*  	dl 0x0017C5 ; 0000A9, 33.431
047588 E2 17 00    1334*  	dl 0x0017E2 ; 0000AA, 33.587
04758B FE 17 00    1335*  	dl 0x0017FE ; 0000AB, 33.742
04758E 1A 18 00    1336*  	dl 0x00181A ; 0000AC, 33.896
047591 36 18 00    1337*  	dl 0x001836 ; 0000AD, 34.050
047594 52 18 00    1338*  	dl 0x001852 ; 0000AE, 34.203
047597 6E 18 00    1339*  	dl 0x00186E ; 0000AF, 34.356
04759A 8A 18 00    1340*  	dl 0x00188A ; 0000B0, 34.509
04759D A5 18 00    1341*  	dl 0x0018A5 ; 0000B1, 34.660
0475A0 C1 18 00    1342*  	dl 0x0018C1 ; 0000B2, 34.811
0475A3 DC 18 00    1343*  	dl 0x0018DC ; 0000B3, 34.962
0475A6 F7 18 00    1344*  	dl 0x0018F7 ; 0000B4, 35.112
0475A9 13 19 00    1345*  	dl 0x001913 ; 0000B5, 35.262
0475AC 2E 19 00    1346*  	dl 0x00192E ; 0000B6, 35.410
0475AF 49 19 00    1347*  	dl 0x001949 ; 0000B7, 35.559
0475B2 64 19 00    1348*  	dl 0x001964 ; 0000B8, 35.707
0475B5 7F 19 00    1349*  	dl 0x00197F ; 0000B9, 35.854
0475B8 99 19 00    1350*  	dl 0x001999 ; 0000BA, 36.001
0475BB B4 19 00    1351*  	dl 0x0019B4 ; 0000BB, 36.147
0475BE CE 19 00    1352*  	dl 0x0019CE ; 0000BC, 36.293
0475C1 E9 19 00    1353*  	dl 0x0019E9 ; 0000BD, 36.438
0475C4 03 1A 00    1354*  	dl 0x001A03 ; 0000BE, 36.582
0475C7 1D 1A 00    1355*  	dl 0x001A1D ; 0000BF, 36.726
0475CA 37 1A 00    1356*  	dl 0x001A37 ; 0000C0, 36.870
0475CD 51 1A 00    1357*  	dl 0x001A51 ; 0000C1, 37.013
0475D0 6B 1A 00    1358*  	dl 0x001A6B ; 0000C2, 37.155
0475D3 85 1A 00    1359*  	dl 0x001A85 ; 0000C3, 37.297
0475D6 9F 1A 00    1360*  	dl 0x001A9F ; 0000C4, 37.439
0475D9 B9 1A 00    1361*  	dl 0x001AB9 ; 0000C5, 37.579
0475DC D2 1A 00    1362*  	dl 0x001AD2 ; 0000C6, 37.720
0475DF EC 1A 00    1363*  	dl 0x001AEC ; 0000C7, 37.859
0475E2 05 1B 00    1364*  	dl 0x001B05 ; 0000C8, 37.999
0475E5 1E 1B 00    1365*  	dl 0x001B1E ; 0000C9, 38.137
0475E8 37 1B 00    1366*  	dl 0x001B37 ; 0000CA, 38.276
0475EB 50 1B 00    1367*  	dl 0x001B50 ; 0000CB, 38.413
0475EE 69 1B 00    1368*  	dl 0x001B69 ; 0000CC, 38.550
0475F1 82 1B 00    1369*  	dl 0x001B82 ; 0000CD, 38.687
0475F4 9B 1B 00    1370*  	dl 0x001B9B ; 0000CE, 38.823
0475F7 B4 1B 00    1371*  	dl 0x001BB4 ; 0000CF, 38.959
0475FA CC 1B 00    1372*  	dl 0x001BCC ; 0000D0, 39.094
0475FD E5 1B 00    1373*  	dl 0x001BE5 ; 0000D1, 39.228
047600 FD 1B 00    1374*  	dl 0x001BFD ; 0000D2, 39.362
047603 16 1C 00    1375*  	dl 0x001C16 ; 0000D3, 39.496
047606 2E 1C 00    1376*  	dl 0x001C2E ; 0000D4, 39.629
047609 46 1C 00    1377*  	dl 0x001C46 ; 0000D5, 39.762
04760C 5E 1C 00    1378*  	dl 0x001C5E ; 0000D6, 39.894
04760F 76 1C 00    1379*  	dl 0x001C76 ; 0000D7, 40.025
047612 8E 1C 00    1380*  	dl 0x001C8E ; 0000D8, 40.156
047615 A5 1C 00    1381*  	dl 0x001CA5 ; 0000D9, 40.286
047618 BD 1C 00    1382*  	dl 0x001CBD ; 0000DA, 40.416
04761B D5 1C 00    1383*  	dl 0x001CD5 ; 0000DB, 40.546
04761E EC 1C 00    1384*  	dl 0x001CEC ; 0000DC, 40.675
047621 04 1D 00    1385*  	dl 0x001D04 ; 0000DD, 40.803
047624 1B 1D 00    1386*  	dl 0x001D1B ; 0000DE, 40.931
047627 32 1D 00    1387*  	dl 0x001D32 ; 0000DF, 41.059
04762A 49 1D 00    1388*  	dl 0x001D49 ; 0000E0, 41.186
04762D 60 1D 00    1389*  	dl 0x001D60 ; 0000E1, 41.312
047630 77 1D 00    1390*  	dl 0x001D77 ; 0000E2, 41.438
047633 8E 1D 00    1391*  	dl 0x001D8E ; 0000E3, 41.564
047636 A5 1D 00    1392*  	dl 0x001DA5 ; 0000E4, 41.689
047639 BB 1D 00    1393*  	dl 0x001DBB ; 0000E5, 41.814
04763C D2 1D 00    1394*  	dl 0x001DD2 ; 0000E6, 41.938
04763F E9 1D 00    1395*  	dl 0x001DE9 ; 0000E7, 42.061
047642 FF 1D 00    1396*  	dl 0x001DFF ; 0000E8, 42.184
047645 15 1E 00    1397*  	dl 0x001E15 ; 0000E9, 42.307
047648 2C 1E 00    1398*  	dl 0x001E2C ; 0000EA, 42.429
04764B 42 1E 00    1399*  	dl 0x001E42 ; 0000EB, 42.551
04764E 58 1E 00    1400*  	dl 0x001E58 ; 0000EC, 42.672
047651 6E 1E 00    1401*  	dl 0x001E6E ; 0000ED, 42.793
047654 84 1E 00    1402*  	dl 0x001E84 ; 0000EE, 42.913
047657 99 1E 00    1403*  	dl 0x001E99 ; 0000EF, 43.033
04765A AF 1E 00    1404*  	dl 0x001EAF ; 0000F0, 43.152
04765D C5 1E 00    1405*  	dl 0x001EC5 ; 0000F1, 43.271
047660 DA 1E 00    1406*  	dl 0x001EDA ; 0000F2, 43.390
047663 F0 1E 00    1407*  	dl 0x001EF0 ; 0000F3, 43.508
047666 05 1F 00    1408*  	dl 0x001F05 ; 0000F4, 43.625
047669 1B 1F 00    1409*  	dl 0x001F1B ; 0000F5, 43.742
04766C 30 1F 00    1410*  	dl 0x001F30 ; 0000F6, 43.859
04766F 45 1F 00    1411*  	dl 0x001F45 ; 0000F7, 43.975
047672 5A 1F 00    1412*  	dl 0x001F5A ; 0000F8, 44.091
047675 6F 1F 00    1413*  	dl 0x001F6F ; 0000F9, 44.206
047678 84 1F 00    1414*  	dl 0x001F84 ; 0000FA, 44.321
04767B 99 1F 00    1415*  	dl 0x001F99 ; 0000FB, 44.435
04767E AD 1F 00    1416*  	dl 0x001FAD ; 0000FC, 44.549
047681 C2 1F 00    1417*  	dl 0x001FC2 ; 0000FD, 44.662
047684 D7 1F 00    1418*  	dl 0x001FD7 ; 0000FE, 44.775
047687 EB 1F 00    1419*  	dl 0x001FEB ; 0000FF, 44.888
04768A 00 20 00    1420*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
04768D             0076   	include "arith24.inc"
04768D             0001*  ;------------------------------------------------------------------------
04768D             0002*  ;  arith24.asm
04768D             0003*  ;  24-bit ez80 arithmetic routines
04768D             0004*  ;  Copyright (c) Shawn Sijnstra 2024
04768D             0005*  ;  MIT license
04768D             0006*  ;
04768D             0007*  ;  This library was created as a tool to help make ez80
04768D             0008*  ;  24-bit native assembly routines for simple mathematical problems
04768D             0009*  ;  more widely available.
04768D             0010*  ;
04768D             0011*  ;------------------------------------------------------------------------
04768D             0012*  
04768D             0013*  ;------------------------------------------------------------------------
04768D             0014*  ; umul24:	HL = HL*DE (unsigned)
04768D             0015*  ; Preserves AF, BC, DE
04768D             0016*  ; Uses a fast multiply routine.
04768D             0017*  ;------------------------------------------------------------------------
04768D             0018*  umul24:
04768D D5          0019*  	push	DE
04768E C5          0020*  	push	BC
04768F F5          0021*  	push	AF
047690 E5          0022*  	push	HL
047691 C1          0023*  	pop		BC
047692 3E 18       0024*      ld	 	a, 24 ; No. of bits to process
047694 21 00 00 00 0025*      ld	 	hl, 0 ; Result
047698             0026*  umul24_lp:
047698 29          0027*  	add	hl,hl
047699 EB          0028*  	ex	de,hl
04769A 29          0029*  	add	hl,hl
04769B EB          0030*  	ex	de,hl
04769C 30 01       0031*  	jr	nc,umul24_nc
04769E 09          0032*  	add	hl,bc
04769F             0033*  umul24_nc:
04769F 3D          0034*  	dec	a
0476A0 20 F6       0035*  	jr	nz,umul24_lp
0476A2 F1          0036*  	pop	af
0476A3 C1          0037*  	pop	bc
0476A4 D1          0038*  	pop	de
0476A5 C9          0039*  	ret
0476A6             0040*  
0476A6             0041*  
0476A6             0042*  ;------------------------------------------------------------------------
0476A6             0043*  ; udiv24
0476A6             0044*  ; Unsigned 24-bit division
0476A6             0045*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0476A6             0046*  ;
0476A6             0047*  ; Uses AF BC DE HL
0476A6             0048*  ; Uses Restoring Division algorithm
0476A6             0049*  ;------------------------------------------------------------------------
0476A6             0050*  
0476A6             0051*  udiv24:
0476A6 E5          0052*  	push	hl
0476A7 C1          0053*  	pop		bc	;move dividend to BCU
0476A8 21 00 00 00 0054*  	ld		hl,0	;result
0476AC A7          0055*  	and		a
0476AD ED 52       0056*  	sbc		hl,de	;test for div by 0
0476AF C8          0057*  	ret		z		;it's zero, carry flag is clear
0476B0 19          0058*  	add		hl,de	;HL is 0 again
0476B1 3E 18       0059*  	ld		a,24	;number of loops through.
0476B3             0060*  udiv1:
0476B3 C5          0061*  	push	bc	;complicated way of doing this because of lack of access to top bits
0476B4 E3          0062*  	ex		(sp),hl
0476B5 37          0063*  	scf
0476B6 ED 6A       0064*  	adc	hl,hl
0476B8 E3          0065*  	ex	(sp),hl
0476B9 C1          0066*  	pop	bc		;we now have bc = (bc * 2) + 1
0476BA             0067*  
0476BA ED 6A       0068*  	adc	hl,hl
0476BC A7          0069*  	and	a		;is this the bug
0476BD ED 52       0070*  	sbc	hl,de
0476BF 30 02       0071*  	jr	nc,udiv2
0476C1 19          0072*  	add	hl,de
0476C2             0073*  ;	dec	c
0476C2 0B          0074*  	dec	bc
0476C3             0075*  udiv2:
0476C3 3D          0076*  	dec	a
0476C4 20 ED       0077*  	jr	nz,udiv1
0476C6 37          0078*  	scf		;flag used for div0 error
0476C7 C5          0079*  	push	bc
0476C8 D1          0080*  	pop		de	;remainder
0476C9 C9          0081*  	ret
0476CA             0082*  
0476CA             0083*  
0476CA             0084*  
0476CA             0085*  ;------------------------------------------------------------------------
0476CA             0086*  ; neg24
0476CA             0087*  ; Returns: HLU = 0-HLU
0476CA             0088*  ; preserves all other registers
0476CA             0089*  ;------------------------------------------------------------------------
0476CA             0090*  neg24:
0476CA D5          0091*  	push	de
0476CB EB          0092*  	ex		de,hl
0476CC 21 00 00 00 0093*  	ld		hl,0
0476D0 B7          0094*  	or		a
0476D1 ED 52       0095*  	sbc		hl,de
0476D3 D1          0096*  	pop		de
0476D4 C9          0097*  	ret
0476D5             0098*  
0476D5             0099*  ;------------------------------------------------------------------------
0476D5             0100*  ; or_hlu_deu: 24 bit bitwise OR
0476D5             0101*  ; Returns: hlu = hlu OR deu
0476D5             0102*  ; preserves all other registers
0476D5             0103*  ;------------------------------------------------------------------------
0476D5             0104*  or_hlu_deu:
0476D5 22 60 77 04 0105*  	ld	(bitbuf1),hl
0476D9 ED 53 63 77 0106*  	ld	(bitbuf2),de
       04          
0476DE D5          0107*  	push	de	;preserve DEU
0476DF C5          0108*  	push	bc	;preserve BCU
0476E0 06 03       0109*  	ld		b,3
0476E2 21 60 77 04 0110*  	ld	hl,bitbuf1
0476E6 11 60 77 04 0111*  	ld	de,bitbuf1
0476EA             0112*  orloop_24:
0476EA 1A          0113*  	ld	a,(de)
0476EB B6          0114*  	or	(hl)
0476EC 12          0115*  	ld	(de),a
0476ED 13          0116*  	inc	de
0476EE 23          0117*  	inc	hl
0476EF 10 F9       0118*  	djnz	orloop_24
0476F1 2A 63 77 04 0119*  	ld	hl,(bitbuf2)
0476F5 C1          0120*  	pop		bc	;restore BC
0476F6 D1          0121*  	pop		de	;restore DE
0476F7             0122*  
0476F7             0123*  ;------------------------------------------------------------------------
0476F7             0124*  ; and_hlu_deu: 24 bit bitwise AND
0476F7             0125*  ; Returns: hlu = hlu AND deu
0476F7             0126*  ; preserves all other registers
0476F7             0127*  ;------------------------------------------------------------------------
0476F7             0128*  and_hlu_deu:
0476F7 22 60 77 04 0129*  	ld	(bitbuf1),hl
0476FB ED 53 63 77 0130*  	ld	(bitbuf2),de
       04          
047700 D5          0131*  	push	de	;preserve DEU
047701 C5          0132*  	push	bc	;preserve BCU
047702 06 03       0133*  	ld		b,3
047704 21 60 77 04 0134*  	ld	hl,bitbuf1
047708 11 60 77 04 0135*  	ld	de,bitbuf1
04770C             0136*  andloop_24:
04770C 1A          0137*  	ld	a,(de)
04770D A6          0138*  	and	(hl)
04770E 12          0139*  	ld	(de),a
04770F 13          0140*  	inc	de
047710 23          0141*  	inc	hl
047711 10 F9       0142*  	djnz	andloop_24
047713 2A 63 77 04 0143*  	ld	hl,(bitbuf2)
047717 C1          0144*  	pop		bc	;restore BC
047718 D1          0145*  	pop		de	;restore DE
047719             0146*  
047719             0147*  ;------------------------------------------------------------------------
047719             0148*  ; xor_hlu_deu: 24 bit bitwise XOR
047719             0149*  ; Returns: hlu = hlu XOR deu
047719             0150*  ; preserves all other registers
047719             0151*  ;------------------------------------------------------------------------
047719             0152*  xor_hlu_deu:
047719 22 60 77 04 0153*  	ld	(bitbuf1),hl
04771D ED 53 63 77 0154*  	ld	(bitbuf2),de
       04          
047722 D5          0155*  	push	de	;preserve DEU
047723 C5          0156*  	push	bc	;preserve BCU
047724 06 03       0157*  	ld		b,3
047726 21 60 77 04 0158*  	ld	hl,bitbuf1
04772A 11 60 77 04 0159*  	ld	de,bitbuf1
04772E             0160*  xorloop_24:
04772E 1A          0161*  	ld	a,(de)
04772F AE          0162*  	xor	(hl)
047730 12          0163*  	ld	(de),a
047731 13          0164*  	inc	de
047732 23          0165*  	inc	hl
047733 10 F9       0166*  	djnz	xorloop_24
047735 2A 63 77 04 0167*  	ld	hl,(bitbuf2)
047739 C1          0168*  	pop		bc	;restore BC
04773A D1          0169*  	pop		de	;restore DE
04773B             0170*  
04773B             0171*  ;------------------------------------------------------------------------
04773B             0172*  ; shl_hlu: 24 bit shift left hlu by deu positions
04773B             0173*  ; Returns: hlu = hlu << deu
04773B             0174*  ;		   de = 0
04773B             0175*  ; NOTE: only considers deu up to 16 bits.
04773B             0176*  ; preserves all other registers
04773B             0177*  ;------------------------------------------------------------------------
04773B             0178*  shl_hlu:
04773B 7A          0179*  	ld		a,d		;up to 16 bit.
04773C B3          0180*  	or		e
04773D C8          0181*  	ret		z		;we're done
04773E 29          0182*  	add		hl,hl	;shift HLU left
04773F 1B          0183*  	dec		de
047740 18 F9       0184*  	jr		shl_hlu
047742             0185*  
047742             0186*  ;------------------------------------------------------------------------
047742             0187*  ; shr_hlu: 24 bit shift right hlu by deu positions
047742             0188*  ; Returns: hlu = hlu >> deu
047742             0189*  ;		   de = 0
047742             0190*  ; NOTE: only considers deu up to 16 bits.
047742             0191*  ; preserves all other registers
047742             0192*  ;------------------------------------------------------------------------
047742             0193*  shr_hlu:
047742 22 60 77 04 0194*  	ld		(bitbuf1),hl
047746 21 62 77 04 0195*  	ld		hl,bitbuf1+2
04774A             0196*  shr_loop:
04774A 7A          0197*  	ld		a,d		;up to 16 bit.
04774B B3          0198*  	or		e
04774C 28 0D       0199*  	jr		z,shr_done		;we're done
04774E             0200*  ;carry is clear from or instruction
04774E CB 1E       0201*  	rr		(hl)
047750 2B          0202*  	dec		hl
047751 CB 1E       0203*  	rr		(hl)
047753 2B          0204*  	dec		hl
047754 CB 1E       0205*  	rr		(hl)
047756 23          0206*  	inc		hl
047757 23          0207*  	inc		hl
047758 1B          0208*  	dec		de
047759 18 EF       0209*  	jr		shr_loop
04775B             0210*  shr_done:
04775B 2A 60 77 04 0211*  	ld		hl,(bitbuf1)	;collect result
04775F C9          0212*  	ret
047760             0213*  
047760             0214*  ;------------------------------------------------------------------------
047760             0215*  ; Scratch area for calculations
047760             0216*  ;------------------------------------------------------------------------
047760 00 00 00    0217*  bitbuf1:	dw24	0	;bit manipulation buffer 1
047763 00 00 00    0218*  bitbuf2:	dw24	0	;bit manipulation buffer 2
047766             0077   
047766 48 65 6C 6C 0078   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
047776             0079   
047776             0080   init:
047776             0081   ; ; set fonts
047776             0082   ; 	ld hl,font_nurples
047776             0083   ; 	ld b,144 ; loop counter for 96 chars
047776             0084   ; 	ld a,32 ; first char to define (space)
047776             0085   ; @loop:
047776             0086   ; 	push bc
047776             0087   ; 	push hl
047776             0088   ; 	push af
047776             0089   ; 	call vdu_define_character
047776             0090   ; 	pop af
047776             0091   ; 	inc a
047776             0092   ; 	pop hl
047776             0093   ; 	ld de,8
047776             0094   ; 	add hl,de
047776             0095   ; 	pop bc
047776             0096   ; 	djnz @loop
047776             0097   
047776             0098   ; set up the display
047776 3E 08       0099       ld a,8
047778 CD 61 58 04 0100       call vdu_set_screen_mode
04777C AF          0101       xor a
04777D CD 72 58 04 0102       call vdu_set_scaling
047781 01 20 00 00 0103   	ld bc,32
047785 11 10 00 00 0104   	ld de,16
047789 CD 1D 58 04 0105   	call vdu_set_gfx_origin
04778D             0106   
04778D CD C7 5E 04 0107   	call vdu_init ; grab a bunch of sysvars and stuff
047791 CD 79 57 04 0108   	call vdu_cursor_off
047795             0109   
047795             0110   ; ; TESTING SOME MATHS
047795             0111   ; 	ld bc,0x00A000 ; 160
047795             0112   ; 	ld de,0x007800 ; 120
047795             0113   ; 	ld ix,0x011F80 ; 287.5
047795             0114   ; 	ld iy,0xFF9B2A ; -100.836
047795             0115   ; 	;  hl=0x00FF00 255
047795             0116   ; 	call distance168
047795             0117   ; 	call dumpRegistersHex
047795             0118   ; 	halt
047795             0119   ; ; END TESTING SOME MATHS
047795             0120   
047795             0121   ; ; print a hello message
047795             0122   ; 	ld hl,hello_world
047795             0123   ; 	call printString
047795             0124   
047795             0125   ; load the bitmaps
047795 CD 60 00 04 0126   	call bmp2_init
047799             0127   
047799             0128   ; ; initialize the first level
047799             0129   ; 	xor a
047799             0130   ; 	ld (cur_level),a
047799             0131   ; 	call init_level
047799             0132   
047799             0133   ; set gfx viewport to scrolling window
047799 01 00 00 00 0134   	ld bc,0
04779D 11 00 00 00 0135   	ld de,0
0477A1 DD 21 FF 00 0136   	ld ix,255
       00          
0477A6 FD 21 DF 00 0137   	ld iy,239-16
       00          
0477AB CD 38 58 04 0138   	call vdu_set_gfx_viewport
0477AF             0139   
0477AF             0140   ; initialize sprites
0477AF CD 94 60 04 0141   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0477B3 AF          0142   	xor a
0477B4             0143   @sprite_loop:
0477B4 F5          0144   	push af
0477B5 CD 68 5F 04 0145   	call vdu_sprite_select
0477B9 21 00 01 00 0146   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0477BD CD B5 60 04 0147   	call vdu_sprite_add_buff
0477C1 F1          0148   	pop af
0477C2 3C          0149   	inc a
0477C3 FE 05       0150   	cp table_max_records+1 ; tack on sprites for player and laser
0477C5 20 ED       0151   	jr nz,@sprite_loop
0477C7 3C          0152   	inc a
0477C8 CD 9C 5F 04 0153   	call vdu_sprite_activate
0477CC             0154   
0477CC             0155   ; define player sprite
0477CC 3E 10       0156   	ld a,16
0477CE CD 68 5F 04 0157   	call vdu_sprite_select
0477D2 CD 7B 5F 04 0158   	call vdu_sprite_clear_frames
0477D6 21 34 01 00 0159   	ld hl,BUF_SHIP_0L
0477DA 01 03 00 00 0160   	ld bc,3 ; three bitmaps for player ship
0477DE             0161   @sprite_player_loop:
0477DE C5          0162   	push bc
0477DF E5          0163   	push hl
0477E0 CD B5 60 04 0164   	call vdu_sprite_add_buff
0477E4 E1          0165   	pop hl
0477E5 23          0166   	inc hl
0477E6 C1          0167   	pop bc
0477E7 10 F5       0168   	djnz @sprite_player_loop
0477E9 CD DE 5F 04 0169   	call vdu_sprite_show
0477ED             0170   
0477ED             0171   ; initialize player
0477ED CD 5A 5B 04 0172   	call player_init
0477F1             0173   
0477F1             0174   ; spawn an enemy sprite
0477F1 06 04       0175   	ld b,table_max_records
0477F3             0176   @spawn_enemy_loop:
0477F3 C5          0177   	push bc
0477F4 CD 43 5D 04 0178   	call enemy_init_from_landing_pad
0477F8 C1          0179   	pop bc
0477F9 10 F8       0180   	djnz @spawn_enemy_loop
0477FB             0181   
0477FB C9          0182   	ret
0477FC             0183   
0477FC             0184   ; new_game:
0477FC             0185   ; ; ###### INITIALIZE GAME #######
0477FC             0186   ; ; clear the screen
0477FC             0187   ;     ld a,3
0477FC             0188   ;     out (81h),a
0477FC             0189   
0477FC             0190   ; ; reset the sprite table
0477FC             0191   ;     xor a
0477FC             0192   ;     ld (table_active_sprites),a
0477FC             0193   ;     ld hl,table_limit
0477FC             0194   ;     ld (table_base),hl
0477FC             0195   ;     ld (table_pointer),hl
0477FC             0196   
0477FC             0197   ; ; draw a starfield over the entire screen
0477FC             0198   ;     ld b,#50 ; first row of visible screen
0477FC             0199   ; new_game_draw_stars_loop:
0477FC             0200   ;     push bc
0477FC             0201   ;     call draw_stars
0477FC             0202   ;     pop bc
0477FC             0203   ;     ld a,#10
0477FC             0204   ;     add a,b
0477FC             0205   ;     ld b,a
0477FC             0206   ;     jr nz,new_game_draw_stars_loop
0477FC             0207   
0477FC             0208   ; ; ; print a welcome message
0477FC             0209   ; ;     ld de,msg_welcome
0477FC             0210   ; ;     ld hl,#581C
0477FC             0211   ; ;     ld c,218 ; a bright pastel purple d677e3
0477FC             0212   ; ;     call print_string
0477FC             0213   
0477FC             0214   ; ; push all that to frame buffer
0477FC             0215   ;     ld a,#01 ; send video to frame buffer
0477FC             0216   ;     out (81h),a
0477FC             0217   
0477FC             0218   ; ; reset score, lives, shields
0477FC             0219   ;     xor a
0477FC             0220   ;     ld hl,player_score
0477FC             0221   ;     ld (hl),a ; player_score 0
0477FC             0222   ;     inc hl
0477FC             0223   ;     ld (hl),a ; player_score 1
0477FC             0224   ;     inc hl
0477FC             0225   ;     ld (hl),a ; player_score 3
0477FC             0226   ;     inc hl
0477FC             0227   ;     ld a,16
0477FC             0228   ;     ld (hl),a ; player_shields
0477FC             0229   ;     inc hl
0477FC             0230   ;     ld (hl),a ; player_max_shields
0477FC             0231   ;     inc hl
0477FC             0232   ;     ld a,3
0477FC             0233   ;     ld (hl),a ; player_ships
0477FC             0234   ;     inc hl
0477FC             0235   
0477FC             0236   ; ; initialize first level
0477FC             0237   ;     ld a,1 ; levels are zero-based, so this will wrap around
0477FC             0238   ;     ld (cur_level),a
0477FC             0239   ;     ld a,3 ; set max enemy sprites to easy street
0477FC             0240   ;     ; ld a,64 ; DEBUG: BRING IT
0477FC             0241   ;     ld (max_enemy_sprites),a
0477FC             0242   ;     call dt_next_level
0477FC             0243   ;     call dt
0477FC             0244   
0477FC             0245   ; ; spawn our intrepid hero
0477FC             0246   ;     call player_init
0477FC             0247   
0477FC             0248   ; ; #### BEGIN GAME VARIABLES ####
0477FC             0249   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
0477FC             0250   speed_player: equ 0x000300 ; 3 pixels per frame
0477FC             0251   
0477FC             0252   main:
0477FC             0253   ; ; move the background down one pixel
0477FC             0254   ; 	ld a,2 ; current gfx viewport
0477FC             0255   ; 	ld l,2 ; direction=down
0477FC             0256   ; 	ld h,1 ; speed=1 px
0477FC             0257   ; 	call vdu_scroll_down
0477FC             0258   
0477FC             0259   ; ; scroll tiles
0477FC             0260   ; 	call tiles_plot
0477FC             0261   
0477FC             0262   ; get player input and update sprite position
0477FC CD 97 5B 04 0263   	call player_input
047800             0264   
047800             0265   ; move enemies
047800 CD 51 5C 04 0266   	call move_enemies
047804             0267   
047804             0268   ; wait for the next vsync
047804 CD 42 5F 04 0269   	call vsync
047808             0270   
047808             0271   ; poll keyboard
047808 3E 08       0272       ld a, $08                           ; code to send to MOS
04780A 5B CF       0273       rst.lil $08                         ; get IX pointer to System Variables
04780C             0274   
04780C DD 7E 05    0275       ld a, (ix + $05)                    ; get ASCII code of key pressed
04780F FE 1B       0276       cp 27                               ; check if 27 (ascii code for ESC)
047811 CA 19 78 04 0277       jp z, main_end                     ; if pressed, jump to exit
047815             0278   
047815 C3 FC 77 04 0279       jp main
047819             0280   
047819             0281   main_end:
047819 CD 6B 57 04 0282       call vdu_cursor_on
04781D C9          0283   	ret
04781E             0284   
04781E             0285   
04781E             0286   ; ; #### BEGIN GAME MAIN LOOP ####
04781E             0287   ; main_loop:
04781E             0288   ; ; ; debug: start execution counter
04781E             0289   ; ;     ld a,1
04781E             0290   ; ;     out (#e0),a ; start counting instructions
04781E             0291   
04781E             0292   ; ; refresh background from frame buffer
04781E             0293   ;     ld a,#02
04781E             0294   ;     out (81h),a
04781E             0295   ;     call move_background ; now move it
04781E             0296   ;     ld a,#01
04781E             0297   ;     out (81h),a ; save it back to buffer
04781E             0298   ; ; do all the things
04781E             0299   ;     call move_enemies
04781E             0300   ;     call player_move
04781E             0301   ;     call laser_control
04781E             0302   ;     call print_score
04781E             0303   ;     call draw_shields
04781E             0304   ;     call draw_lives
04781E             0305   ; ; ; debug: stop execution counter and print results
04781E             0306   ; ;     ld a,0
04781E             0307   ; ;     out (#e0),a ; stop counting instructions
04781E             0308   
04781E             0309   ; ; ; debug: start execution counter
04781E             0310   ; ;     ld a,1
04781E             0311   ; ;     out (#e0),a ; start counting instructions
04781E             0312   
04781E             0313   ;     call vsync
04781E             0314   ; ; ; debug: stop execution counter and print results
04781E             0315   ; ;     ld a,0
04781E             0316   ; ;     out (#e0),a ; stop counting instructions
04781E             0317   
04781E             0318   ;     jr main_loop
04781E             0319   ; #### END GAME MAIN LOOP ####
04781E             0320   
04781E             0321   ; draws the player's shields level
04781E             0322   ; draw_shields:
04781E             0323   ; TODO: Agonize this routine
04781E             0324   ; ; prep the loop to draw the bars
04781E             0325   ;     ld a,(player_shields) ; snag shields
04781E             0326   ;     and a
04781E             0327   ;     ret z ; don't draw if zero shields
04781E             0328   ; ; set loop counter and drawing position
04781E             0329   ;     ld b,a ; loop counter
04781E             0330   ;     ld hl,#5300+48+12
04781E             0331   ; ; set color based on bars remaining
04781E             0332   ;     ld c,103 ; bright green 28fe0a
04781E             0333   ;     cp 9
04781E             0334   ;     jp p,draw_shields_loop
04781E             0335   ;     ld c,74 ; bright yellow eafe5b
04781E             0336   ;     cp 3
04781E             0337   ;     jp p,draw_shields_loop
04781E             0338   ;     ld c,28 ; bright red fe0a0a
04781E             0339   ; draw_shields_loop:
04781E             0340   ;     push bc ; yup,outta
04781E             0341   ;     push hl ; registers again
04781E             0342   ;     ; ld a,#A8 ; ▀,168
04781E             0343   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
04781E             0344   ;     ; call draw_char
04781E             0345   ;     call draw_num ; we nuked draw_char for the time being
04781E             0346   ;     pop hl
04781E             0347   ;     ld a,8
04781E             0348   ;     add a,l
04781E             0349   ;     ld l,a
04781E             0350   ;     pop bc
04781E             0351   ;     djnz draw_shields_loop
04781E             0352       ; ret
04781E             0353   
04781E             0354   ; prints the player's score
04781E             0355   ; print_score:
04781E             0356   ; TODO: Agonize this
04781E             0357   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
04781E             0358   ;     ld c,42 ; dark orange b74400
04781E             0359   ;     ld hl,#5200+1+8+6*6
04781E             0360   ;     ld a,3 ; print 6 bdc digits
04781E             0361   ;     ld de,player_score
04781E             0362   ;     call print_num
04781E             0363   
04781E             0364   ;     ld c,58 ; golden yellow fec10a
04781E             0365   ;     ld hl,#5100+8+6*6
04781E             0366   ;     ld a,3 ; print 6 bdc digits
04781E             0367   ;     ld de,player_score
04781E             0368   ;     call print_num
04781E             0369       ; ret
04781E             0370   
04781E             0371   ; draw_lives:
04781E             0372   ;     ld hl,player_small ; make small yellow ship the active sprite
04781E             0373   ;     ld (sprite_base_bufferId),hl
04781E             0374   ;     ; ld a,#80 ; northern orientation
04781E             0375   ;     ; ld (sprite_orientation),a
04781E             0376   ;     ld hl,0 ; north
04781E             0377   ;     ld (sprite_heading),hl
04781E             0378   ;     xor a
04781E             0379   ;     ld (sprite_animation),a
04781E             0380   ;     ld a,#56 ; top of visible screen
04781E             0381   ;     ld (sprite_y+1),a
04781E             0382   ;     call vdu_bmp_select
04781E             0383   ;     ld a,(player_ships)
04781E             0384   ;     dec a ; we draw one fewer ships than lives
04781E             0385   ;     ret z ; nothing to draw here, move along
04781E             0386   ;     ld b,a ; loop counter
04781E             0387   ;     ld a,256-16 ; initial x position
04781E             0388   ; draw_lives_loop:
04781E             0389   ;     ld (sprite_x+1),a
04781E             0390   ;     push af
04781E             0391   ;     push bc
04781E             0392   ;     call vdu_bmp_draw
04781E             0393   ;     pop bc
04781E             0394   ;     pop af
04781E             0395   ;     sub 10
04781E             0396   ;     djnz draw_lives_loop
04781E             0397   ;     ret
