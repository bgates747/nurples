PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000 C3 45 00 04 0004       jp start
040004 FF FF FF FF 0005       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0006       db "MOS"
040043 00          0007       db 00h
040044 01          0008       db 01h
040045             0009   
040045             0010   start:
040045 F5          0011       push af
040046 C5          0012       push bc
040047 D5          0013       push de
040048 DD E5       0014       push ix
04004A FD E5       0015       push iy
04004C CD 7F 44 04 0016       call init
040050 CD 51 45 04 0017       call main
040054             0018   
040054             0019   exit:
040054 FD E1       0020       pop iy
040056 DD E1       0021       pop ix
040058 D1          0022       pop de
040059 C1          0023       pop bc
04005A F1          0024       pop af
04005B 21 00 00 00 0025       ld hl,0
04005F             0026   
04005F C9          0027       ret
040060             0028   
040060             0029       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,$+7 ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*      ld bc,$+7 ; Address of first instruction after the jump
040060             0023*      push bc ; which constitutes the return address
040060             0024*      jp (ix) ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*      ld bc,$+7 ; Address of first instruction after the jump
040060             0033*      push bc ; which constitutes the return address
040060             0034*      jp (iy) ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*      push hl ; 4 cycles
040060             0041*      inc sp ; 1 cycle
040060             0042*      pop af ; 4 cycles
040060             0043*      dec sp ; 1 cycle
040060             0044*      ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*      ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*      ex af,af'
040070             0068*      exx
040070             0069*      push af
040070             0070*      push hl
040070             0071*      push bc
040070             0072*      push de
040070             0073*  
040070             0074*      ex af,af'
040070             0075*      exx
040070             0076*      push af
040070             0077*      push hl
040070             0078*      push bc
040070             0079*      push de
040070             0080*      push ix
040070             0081*      push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*      pop iy
040070             0086*      pop ix
040070             0087*      pop de
040070             0088*      pop bc
040070             0089*      pop hl
040070             0090*      pop af
040070             0091*      ex af,af'
040070             0092*      exx
040070             0093*  
040070             0094*      pop de
040070             0095*      pop bc
040070             0096*      pop hl
040070             0097*      pop af
040070             0098*      ex af,af'
040070             0099*      exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*      PUSH BC
040078 01 00 00 00 0119*      LD BC,0
04007C 3E 00       0120*      LD A,0
04007E 5B DF       0121*      RST.LIL 18h
040080 C1          0122*      POP BC
040081 C9          0123*      RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*      PUSH BC
040083 01 00 00 00 0128*      LD BC, 0
040087 4E          0129*      LD C, (HL)
040088 5B DF       0130*      RST.LIL 18h
04008A C1          0131*      POP BC
04008B C9          0132*      RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*      LD A, '\r'
04008F 5B D7       0137*      RST.LIL 10h
040091 3E 0A       0138*      LD A, '\n'
040093 5B D7       0139*      RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*      RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0147*      CALL printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*      LD A,H
0400A0 CD A5 00 04 0152*      CALL printHex8
0400A4 7D          0153*      LD A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*      LD C,A
0400A6 1F          0158*      RRA
0400A7 1F          0159*      RRA
0400A8 1F          0160*      RRA
0400A9 1F          0161*      RRA
0400AA CD AF 00 04 0162*      CALL @F
0400AE 79          0163*      LD A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*      AND 0Fh
0400B1 C6 90       0166*      ADD A,90h
0400B3 27          0167*      DAA
0400B4 CE 40       0168*      ADC A,40h
0400B6 27          0169*      DAA
0400B7 5B D7       0170*      RST.LIL 10h
0400B9 C9          0171*      RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*      LD A, '0'
04016F 5B D7       0290*      RST.LIL 10h
040171 3E 78       0291*      LD A, 'x'
040173 5B D7       0292*      RST.LIL 10h
040175 C9          0293*      RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*      push hl
040176             0297*      push bc
040176             0298*      pop hl
040176             0299*      call printDec
040176             0300*      pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*      push hl
040176             0305*      push de
040176             0306*      pop hl
040176             0307*      call printDec
040176             0308*      pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*      call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*      push hl
040176             0317*      push ix
040176             0318*      pop hl
040176             0319*      call printDec
040176             0320*      pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*      push hl
040176             0325*      push iy
040176             0326*      pop hl
040176             0327*      call printDec
040176             0328*      pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*      LD DE, _printDecBuffer
04017E CD B2 01 04 0344*      CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD HL, _printDecBuffer
040186 06 07       0348*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD A, (HL)
040189 FE 30       0351*      CP '0'
04018B C2 95 01 04 0352*      JP NZ, @done
04018F 3E 20       0353*      LD A, ' '
040191 77          0354*      LD (HL), A
040192 23          0355*      INC HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*      LD HL, _printDecBuffer
040199 CD 77 00 04 0361*      CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*      RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*      LD BC,-10000000
0401B6 CD E9 01 04 0379*      CALL @one_digit
0401BA 01 C0 BD F0 0380*      LD BC,-1000000
0401BE CD E9 01 04 0381*      CALL @one_digit
0401C2 01 60 79 FE 0382*      LD BC,-100000
0401C6 CD E9 01 04 0383*      CALL @one_digit
0401CA 01 F0 D8 FF 0384*      LD BC,-10000
0401CE CD E9 01 04 0385*      CALL @one_digit
0401D2 01 18 FC FF 0386*      LD BC,-1000
0401D6 CD E9 01 04 0387*      CALL @one_digit
0401DA 01 9C FF FF 0388*      LD BC,-100
0401DE CD E9 01 04 0389*      CALL @one_digit
0401E2 0E F6       0390*      LD C,-10
0401E4 CD E9 01 04 0391*      CALL @one_digit
0401E8 48          0392*      LD C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*      LD A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*      INC A
0401EC 09          0397*      ADD HL,BC
0401ED 38 FC       0398*      JR C,@divide_me
0401EF ED 42       0399*      SBC HL,BC
0401F1 12          0400*      LD (DE),A
0401F2 13          0401*      INC DE
0401F3 C9          0402*      RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl ; Save HL (we’ll need the fractional part later)
040212 CD FB 06 04 0427*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp @frac ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc a
040240 09          0443*      add hl, bc ; Accumulate until overflow
040241 38 FC       0444*      jr c, @divide_me
040243 ED 42       0445*      sbc hl, bc ; Remove excess after overflow
040245 12          0446*      ld (de), a ; Store ASCII digit
040246 13          0447*      inc de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld a, '.' ; Decimal point
04024A 12          0452*      ld (de), a
04024B 13          0453*      inc de
04024C E1          0454*      pop hl ; Restore HL with original fraction
04024D 06 03       0455*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld a, '0'
040255 84          0460*      add a, h ; Convert integer part to ASCII
040256 12          0461*      ld (de), a
040257 13          0462*      inc de
040258 10 F5       0463*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor a ; Null terminator
04025B 12          0466*      ld (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 94 06 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0602*      ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*      ld hl,@cmd
04032B 01 08 00 00 0615*      ld bc,@end-@cmd
04032F 5B DF       0616*      rst.lil $18
040331 C9          0617*      ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0627*      ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*      ld hl,@cmd
040350 01 08 00 00 0640*      ld bc,@end-@cmd
040354 5B DF       0641*      rst.lil $18
040356 C9          0642*      ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0903*      rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*      call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0030       include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*      add hl,de
04068E             0007*      or a
04068E             0008*      sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de ; save de
0406A5 EB          0045*      ex de,hl ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0 ; clear hl
0406AA AF          0047*      xor a ; clear carry
0406AB ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
0406AD D1          0049*      pop de ; get de back
0406AE C9          0050*      ret ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*      ld (scratch1),hl
0406B3 21 90 06 04 0057*      ld hl,scratch1+2
0406B7 CB 1E       0058*      rr (hl)
0406B9 2B          0059*      dec hl
0406BA CB 1E       0060*      rr (hl)
0406BC 2B          0061*      dec hl
0406BD CB 1E       0062*      rr (hl)
0406BF 23          0063*      inc hl
0406C0 23          0064*      inc hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M     add hl,de
0406E6 B7          0002*M     or a
0406E7 ED 52       0003*M     sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*      xor a
0406FC 32 0D 07 04 0105*      ld (@buffer+3),a
040700 7D          0106*      ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*      ld (@buffer),hl
040705 2A 0B 07 04 0108*      ld hl,(@buffer+1)
040709 C9          0109*      ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*      add hl,hl ; * 2
04070E             0114*      add hl,hl ; * 4
04070E             0115*      add hl,hl ; * 8
04070E             0116*      add hl,hl ; * 16
04070E             0117*      add hl,hl ; * 32
04070E             0118*      add hl,hl ; * 64
04070E             0119*      add hl,hl ; * 128
04070E             0120*      add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*      or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*      ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0031       include "enemies.inc"
040785 10          0001*  max_enemy_sprites: db 16
040786             0002*  
040786             0003*  ; sprite_type
040786             0004*  enemy_dead: equ 0
040786             0005*  enemy_small: equ 1
040786             0006*  enemy_medium: equ 2
040786             0007*  enemy_large: equ 3
040786             0008*  landing_pad: equ 4
040786             0009*  laser_turret: equ 5
040786             0010*  fireballs: equ 6
040786             0011*  explosion: equ 7
040786             0012*  
040786             0013*  
040786             0014*  respawn_countdown:
040786 2A A7 07 04 0015*      ld hl,(respawn_timer)
04078A 2B          0016*      dec hl
04078B 22 A7 07 04 0017*      ld (respawn_timer),hl
04078F             0018*  ; check hl for zero
04078F 19          0019*      add hl,de
040790 B7          0020*      or a
040791 ED 52       0021*      sbc hl,de
040793 C0          0022*      ret nz
040794 06 10       0023*      ld b,table_max_records
040796             0024*  @respawn_loop:
040796 C5          0025*      push bc
040797 CD 8C 08 04 0026*      call enemy_init_from_landing_pad
04079B C1          0027*      pop bc
04079C 10 F8       0028*      djnz @respawn_loop
04079E 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
0407A2 22 A7 07 04 0030*      ld (respawn_timer),hl
0407A6 C9          0031*      ret
0407A7 3C 00 00    0032*  respawn_timer: dl 1*60
0407AA             0033*  
0407AA             0034*  move_enemies:
0407AA             0035*  ; are there any active enemies or explosions?
0407AA 21 00 00 00 0036*      ld hl,0
0407AE 3A FA 39 04 0037*      ld a,(table_active_sprites)
0407B2 6F          0038*      ld l,a
0407B3             0039*      ; call dumpRegistersHex
0407B3 A7          0040*      and a ; will be zero if no alive enemies or explosions
0407B4             0041*      ; ret z ; so nothing to do but go back
0407B4             0042*      ; ld hl,(respawn_timer)
0407B4             0043*      ; call dumpRegistersHex
0407B4 20 05       0044*      jr nz,move_enemies_do
0407B6 CD 86 07 04 0045*      call respawn_countdown
0407BA C9          0046*      ret
0407BB             0047*  move_enemies_do:
0407BB             0048*  ; initialize pointers and loop counter
0407BB FD 21 97 37 0049*      ld iy,table_base ; set iy to first record in table
       04          
0407C0 06 10       0050*      ld b,table_max_records ; loop counter
0407C2             0051*  move_enemies_loop:
0407C2 FD 22 F7 39 0052*      ld (table_pointer),iy ; update table pointer
       04          
0407C7 C5          0053*      push bc ; backup loop counter
0407C8             0054*  ; check sprite_type to see if sprite is active
0407C8 FD 7E 01    0055*      ld a,(iy+sprite_type)
0407CB A7          0056*      and a ; if zero, sprite is dead
0407CC 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
0407CE             0058*  ; otherwise we prepare to move the sprite
0407CE FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
0407D1 CD C6 42 04 0060*      call vdu_sprite_select ; select sprite
0407D5 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0407D8 E9          0062*      jp (hl) ; ... and jump to it
0407D9             0063*  ; we always jp back here from behavior subroutines
0407D9             0064*  move_enemies_loop_return:
0407D9 FD 2A F7 39 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
0407DE             0066*  ; now we check results of all the moves
0407DE FD 7E 08    0067*      ld a,(iy+sprite_collisions)
0407E1 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
0407E3 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0407E6 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0407E8 CD 43 3A 04 0071*      call table_deactivate_sprite ; otherwise we ded
0407EC AF          0072*      xor a ; zero a so that we can ...
0407ED FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
0407F0 18 0A       0074*      jr move_enemies_next_record ; and to the next record
0407F2             0075*  move_enemies_draw_sprite:
0407F2             0076*  ; if we got here sprite will have already been activated
0407F2             0077*  ; so all we need to do is set its coordinates and draw it
0407F2 FD 07 0B    0078*      ld bc,(iy+sprite_x)
0407F5 FD 17 0E    0079*      ld de,(iy+sprite_y)
0407F8 CD 92 43 04 0080*      call vdu_sprite_move_abs168
0407FC             0081*  ; fall through to next record
0407FC             0082*  move_enemies_next_record:
0407FC 11 26 00 00 0083*      ld de,table_bytes_per_record
040800 FD 19       0084*      add iy,de ; point to next record
040802 AF          0085*      xor a ; clears carry flag
040803 32 FB 39 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
040807 C1          0087*      pop bc ; get back our loop counter
040808 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
04080A C9          0089*      ret ; and we're out
04080B             0090*  
04080B             0091*  en_nav_zigzag_start:
04080B FD 2A F7 39 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040810 CD 49 07 04 0093*      call rand_8
040814 E6 3F       0094*      and %00111111 ; limit it to 64
040816 CB DF       0095*      set 3,a ; make sure it's at least 8
040818 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
04081B             0097*      ; fall through to en_nav_zigzag
04081B             0098*  en_nav_zigzag:
04081B FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
04081E 3D          0100*      dec a
04081F FD 77 22    0101*      ld (iy+sprite_move_timer),a
040822 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
040824             0103*      ; otherwise flip direction and restart timer
040824 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
040827 EE 01       0105*      xor %1 ; flips bit one
040829 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
04082C 20 09       0107*      jr nz,en_nav_zigzag_right
04082E             0108*  ;otherwise zag left
04082E 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
040832 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
040835 18 D4       0111*      jr en_nav_zigzag_start
040837             0112*  en_nav_zigzag_right:
040837 21 00 60 00 0113*      ld hl,0x006000; southeast heading
04083B FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
04083E 18 CB       0115*      jr en_nav_zigzag_start
040840             0116*  en_nav_zigzag_no_switch:
040840             0117*      ; ld a,(sprite_orientation)
040840 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
040843 18 13       0119*      jr en_nav_computevelocities
040845             0120*  
040845             0121*  ; contains the logic for how to move the enemy
040845             0122*  ; and then does the moving
040845             0123*  ; inputs: a fully-populated active sprite table
040845             0124*  ;         player position variables
040845             0125*  ; destroys: everything except index registers
040845             0126*  ; outputs: moving enemies
040845             0127*  en_nav:
040845             0128*  ; set velocity and orientation by player's relative location
040845             0129*  ; move enemies y-axis
040845             0130*  ; where is player relative to us?
040845 CD 0F 09 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
040849             0132*  ; is player above or below us?
040849 ED 53 A5 05 0133*      ld (ude),de ; dy
       04          
04084E 3A A7 05 04 0134*      ld a,(ude+2) ; deu
040852 17          0135*      rla ; shift sign bit into carry
040853 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
040855             0137*  ; player is even or above,so home in on current heading
040855 FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
040858             0139*  
040858             0140*  ; we land here from zig-zag program so as not to
040858             0141*  ; redundantly save orientation and heading
040858             0142*  en_nav_computevelocities:
040858             0143*  ; set x/y component velocities based on bearing to player
040858 FD 2A F7 39 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04085D E5          0145*      push hl ; we need it back to set rotation frame
04085E FD 17 17    0146*      ld de,(iy+sprite_vel)
040861 CD A2 0B 04 0147*      call polar_to_cartesian
040865 FD 2A F7 39 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04086A FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
04086D FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
040870             0151*  ; change the animation frame to match heading
040870             0152*  ; by dividng the heading by 8
040870 E1          0153*      pop hl ; get back Heading
040871 7C          0154*      ld a,h
040872 CB 3F       0155*      srl a
040874 CB 3F       0156*      srl a
040876 CB 3F       0157*      srl a
040878 CD 29 43 04 0158*      call vdu_sprite_select_frame
04087C C3 AB 3A 04 0159*      jp move_sprite ; will return to caller from there
040880             0160*  
040880             0161*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
040880             0162*  ; ; each sprite in the table must have one of these defined
040880             0163*  ; ; but they need not be unique to a particular sprite
040880             0164*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
040880             0165*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
040880             0166*  ; ; but they can call anything they want between those two endpoints
040880             0167*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
040880             0168*  
040880             0169*  ; move_nop: ; does nothing but burn a few cycles changing the PC
040880             0170*  ;     jp move_enemies_loop_return
040880             0171*  
040880             0172*  ; move_explosion:
040880             0173*  ;     call animate_explosion
040880             0174*  ;     jp move_enemies_loop_return
040880             0175*  
040880             0176*  move_enemy_small:
040880 CD 45 08 04 0177*      call en_nav
040884 CD A8 09 04 0178*      call check_collisions
040888 C3 D9 07 04 0179*      jp move_enemies_loop_return
04088C             0180*  
04088C             0181*  ; move_enemy_medium:
04088C             0182*  ;     call en_nav
04088C             0183*  ;     call check_collisions
04088C             0184*  ;     jp move_enemies_loop_return
04088C             0185*  
04088C             0186*  ; move_enemy_large:
04088C             0187*  ;     call en_nav
04088C             0188*  ;     call check_collisions
04088C             0189*  ;     jp move_enemies_loop_return
04088C             0190*  
04088C             0191*  ; move_landing_pad:
04088C             0192*  ;     call move_active_tiles
04088C             0193*  ;     call check_collisions
04088C             0194*  ; ; is it time to launch an enemy?
04088C             0195*  ;     ld hl,sprite_move_timer
04088C             0196*  ;     dec (hl)
04088C             0197*  ;     jp nz,move_enemies_loop_return
04088C             0198*  ;     call enemy_init_from_landing_pad
04088C             0199*  ;     ; reset move timer so can spawn again if player doesn't take us out
04088C             0200*  ;     call rand_8     ; snag a random number
04088C             0201*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04088C             0202*  ;     add a,64 ; range is now 64-127
04088C             0203*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04088C             0204*  ;     jp move_enemies_loop_return
04088C             0205*  
04088C             0206*  speed_seeker: equ 0x000280 ; 2.5 pixels per frame
04088C             0207*  enemy_init_from_landing_pad:
04088C             0208*  ; get next available spriteId
04088C CD 1E 3A 04 0209*      call table_get_next_id
040890 D0          0210*      ret nc ; no carry means no free sprite slots, so we go home
040891             0211*  ; ix comes back with the pointer to the new sprite variables
040891 DD E5       0212*      push ix ; de picks it up when we're ready for the copy to the table
040893             0213*  ; a comes back with the spriteId of the new sprite
040893 32 E9 08 04 0214*      ld (@id),a
040897             0215*  ; initialize the new sprite
040897 CD C6 42 04 0216*      call vdu_sprite_select
04089B CD D9 42 04 0217*      call vdu_sprite_clear_frames
04089F 21 14 01 00 0218*      ld hl,BUF_SEEKER_000
0408A3 06 20       0219*      ld b,32
0408A5             0220*  @load_frames:
0408A5 C5          0221*      push bc
0408A6 E5          0222*      push hl
0408A7 CD 1B 44 04 0223*      call vdu_sprite_add_buff
0408AB E1          0224*      pop hl
0408AC 23          0225*      inc hl
0408AD C1          0226*      pop bc
0408AE 10 F5       0227*      djnz @load_frames
0408B0             0228*  ; copy coordinates of active sprite to new sprite
0408B0 FD 2A F7 39 0229*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0408B5             0230*      ; ld hl,(iy+sprite_x)
0408B5             0231*      ; ld hl,0x008000 ; debug
0408B5             0232*  
0408B5 CD 49 07 04 0233*      call rand_8
0408B9 21 00 00 00 0234*      ld hl,0
0408BD 67          0235*      ld h,a
0408BE             0236*  
0408BE 22 F4 08 04 0237*      ld (@x),hl
0408C2             0238*      ; ld hl,(iy+sprite_y)
0408C2             0239*      ; ld hl,0x002000 ; debug
0408C2             0240*  
0408C2 CD 49 07 04 0241*      call rand_8
0408C6 21 00 00 00 0242*      ld hl,0
0408CA 67          0243*      ld h,a
0408CB             0244*  
0408CB 22 F7 08 04 0245*      ld (@y),hl
0408CF CD 49 07 04 0246*      call rand_8
0408D3 E6 01       0247*      and %00000001 ; 50/50 chance of moving left or right on spanw
0408D5 32 0C 09 04 0248*      ld (@move_step),a
0408D9             0249*  ; now copy to the table
0408D9 21 E9 08 04 0250*      ld hl,@id ; address to copy from
0408DD D1          0251*      pop de ; address to copy to (was ix)
0408DE 01 26 00 00 0252*      ld bc,table_bytes_per_record ; number of bytes to copy
0408E2 ED B0       0253*      ldir ; copy the records from local scratch to sprite table
0408E4             0254*  ; finally, make the new sprite visible
0408E4 CD 3C 43 04 0255*      call vdu_sprite_show
0408E8 C9          0256*      ret
0408E9 00          0257*  @id:                    db 0x00 ; 1 bytes unique spriteId, zero-based
0408EA 01          0258*  @type:                  db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
0408EB 14 01 00    0259*  @base_bufferId:         dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0408EE 80 08 04    0260*  @move_program:          dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0408F1 03          0261*  @collisions:            db %00000011 ; 3 bytes collides with enemy and laser
0408F2 10          0262*  @dim_x:                 db 0x10 ; 1 bytes sprite width in pixels
0408F3 10          0263*  @dim_y:                 db 0x10 ; 1 bytes sprite height in pixels
0408F4 00 00 00    0264*  @x:                     dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0408F7 00 00 00    0265*  @y:                     dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0408FA 00 00 00    0266*  @xvel:                  dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0408FD 00 00 00    0267*  @yvel:                  dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
040900 80 02 00    0268*  @vel:                   dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
040903 00 80 00    0269*  @heading:               dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
040906 00 80 00    0270*  @orientation:           dl 0x008000 ; 3 bytes orientation bits
040909 00          0271*  @animation:             db 0x00 ; 1 bytes current animation index, zero-based
04090A 00          0272*  @animation_timer:       db 0x00 ; 1 bytes when hits zero, draw next animation
04090B 01          0273*  @move_timer:            db 0x01 ; 1 bytes when zero, go to next move program, or step
04090C 00          0274*  @move_step:             db 0x00 ; 1 bytes stage in a move program sequence, varies
04090D 20          0275*  @points:                db 0x20 ; 1 bytes points awarded for killing this sprite type, BCD
04090E 02          0276*  @shield_damage:         db 0x02 ; 1 bytes shield points deducted for collision, binary
04090F             0277*  
04090F             0278*  ; move_laser_turret:
04090F             0279*  ; ; compute orientation to player
04090F             0280*  ;     call orientation_to_player
04090F             0281*  ; ; h.l 8.8 fixed angle256 to player
04090F             0282*  ; ; bc and de as signed 16-bit integers
04090F             0283*  ; ; representing delta-x/y *to* target respectively
04090F             0284*  ;     ld (Bearing_t),hl
04090F             0285*  ;     ld hl,0x0400
04090F             0286*  ;     ld (Vp),hl
04090F             0287*  ;     call targeting_computer
04090F             0288*  ;     ld (sprite_heading),hl ; store bearing to player
04090F             0289*  ; ; is it time to launch a fireball?
04090F             0290*  ;     ld hl,sprite_move_timer
04090F             0291*  ;     dec (hl)
04090F             0292*  ;     jp nz,move_laser_turret_boilerplate
04090F             0293*  ;     call fireballs_init
04090F             0294*  ;     ; reset move timer so can fire again if player doesn't take us out
04090F             0295*  ;     call rand_8     ; snag a random number
04090F             0296*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04090F             0297*  ;     add a,64 ; range is now 64-127
04090F             0298*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04090F             0299*  ; move_laser_turret_boilerplate:
04090F             0300*  ;     call move_active_tiles
04090F             0301*  ;     call check_collisions
04090F             0302*  ;     jp move_enemies_loop_return
04090F             0303*  
04090F             0304*  ; fireballs_init:
04090F             0305*  ;     call sprite_variables_to_stack
04090F             0306*  
04090F             0307*  ;     ld hl,fireballs
04090F             0308*  ;     ld (sprite_base_bufferId),hl
04090F             0309*  
04090F             0310*  ;     ld hl,move_fireballs
04090F             0311*  ;     ld (sprite_move_program),hl
04090F             0312*  
04090F             0313*  ;     ld a,%11 ; collides with laser and player
04090F             0314*  ;     ; ld a,%10 ; collides with laser DEBUG
04090F             0315*  ;     ld (iy+sprite_collisions),a
04090F             0316*  
04090F             0317*  ;     ld hl,(Vp)
04090F             0318*  ;     ld (sprite_vel),hl
04090F             0319*  ;     ld hl,(Vp_x)
04090F             0320*  ;     ld (sprite_xvel),hl
04090F             0321*  ;     ld hl,(Vp_y)
04090F             0322*  ;     inc h ; account for ground movement
04090F             0323*  ;     ld (sprite_yvel),hl
04090F             0324*  
04090F             0325*  ;     xor a ; zero a
04090F             0326*  ;     ld (sprite_animation),a
04090F             0327*  ;     ld (sprite_move_step),a
04090F             0328*  ;     ld (sprite_move_timer),a
04090F             0329*  
04090F             0330*  ;     ld a,6 ; 1/10th of a second timer
04090F             0331*  ;     ld (sprite_animation_timer),a
04090F             0332*  
04090F             0333*  ;     ld a,0x00 ; BCD
04090F             0334*  ;     ld (sprite_points),a
04090F             0335*  ;     ld a,1 ; binary
04090F             0336*  ;     ld (sprite_shield_damage),a
04090F             0337*  
04090F             0338*  ;     call table_add_record ; plops that on the sprite stack for later
04090F             0339*  ;     call sprite_variables_from_stack ; come back to where we started
04090F             0340*  ;     ret
04090F             0341*  
04090F             0342*  ; move_fireballs:
04090F             0343*  ;     call move_sprite ; move sprite
04090F             0344*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
04090F             0345*  ;     and a ; if zero we're still within screen bounds
04090F             0346*  ;     jr z,move_fireballs_alive
04090F             0347*  ; ; otherwise kill sprite
04090F             0348*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
04090F             0349*  ;     ld (iy+sprite_collisions),a
04090F             0350*  ;     jp move_enemies_loop_return
04090F             0351*  ; move_fireballs_alive:
04090F             0352*  ;     ld a,(sprite_animation_timer)
04090F             0353*  ;     dec a
04090F             0354*  ;     ld (sprite_animation_timer),a
04090F             0355*  ;     jr nz,move_fireballs_draw
04090F             0356*  ;     ld a,(sprite_animation)
04090F             0357*  ;     xor %1
04090F             0358*  ;     ld (sprite_animation),a
04090F             0359*  ;     ld a,6 ; 1/10th of a second timer
04090F             0360*  ;     ld (sprite_animation_timer),a
04090F             0361*  ;     ; fall through
04090F             0362*  
04090F             0363*  ; move_fireballs_draw:
04090F             0364*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04090F             0365*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04090F             0366*  ;     call check_collisions
04090F             0367*  ;     jp move_enemies_loop_return
04090F             0368*  
04090F             0369*  ; compute orientation to player
04090F             0370*  ; based on relative positions
04090F             0371*  ; returns: h.l 16.8 fixed angle256 to player
04090F             0372*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
04090F             0373*  ;    representing delta-x/y *to* target respectively
04090F             0374*  orientation_to_player:
04090F FD 2A F7 39 0375*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040914 FD 07 0B    0376*      ld bc,(iy+sprite_x)
040917 FD 17 0E    0377*      ld de,(iy+sprite_y)
04091A DD 2A B4 36 0378*      ld ix,(player_x)
       04          
04091F FD 2A B7 36 0379*      ld iy,(player_y)
       04          
040924 CD D7 0B 04 0380*      call dxy168
040928 C5          0381*      push bc
040929 D5          0382*      push de
04092A CD 34 0C 04 0383*      call atan2_168fast
04092E D1          0384*      pop de
04092F C1          0385*      pop bc
040930 FD 2A F7 39 0386*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040935 C9          0387*      ret
040936             0388*  
040936             0389*  
040936             0390*  ; targeting_computer scratch variables
040936 00 00       0391*  Bearing_t: dw #0000 ; 8.8 fixed
040938 00 00       0392*  Heading_t: dw #0000 ; 8.8 fixed
04093A 00 00       0393*  Vp: dw #0000 ; 8.8 fixed
04093C 00 00       0394*  Vp_x: dw #0000 ; 8.8 fixed
04093E 00 00       0395*  Vp_y: dw #0000 ; 8.8 fixed
040940 00 00       0396*  Vt: dw #0000 ; 8.8 fixed
040942 00 00       0397*  Vt_x: dw #0000 ; 8.8 fixed
040944 00 00       0398*  Vt_y: dw #0000 ; 8.8 fixed
040946             0399*  
040946             0400*  
040946             0401*  ; ; Inputs:   see scratch variables
040946             0402*  ; ; Note:     a call to orientation_to_player provides these inputs
040946             0403*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
040946             0404*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
040946             0405*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
040946             0406*  ; targeting_computer:
040946             0407*  ; ; compute target velocity from x,y component velocities
040946             0408*  ;     ld bc,(player_xvel)
040946             0409*  ;     ld de,(player_yvel)
040946             0410*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
040946             0411*  
040946             0412*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
040946             0413*  ;     ld (Heading_t),bc
040946             0414*  ;     ld (Vt),de
040946             0415*  
040946             0416*  ; ; compute Heading_t-Bearing_t
040946             0417*  ;     ld h,b
040946             0418*  ;     ld l,c
040946             0419*  ;     ld bc,(Bearing_t)
040946             0420*  ;     and a ; clear carry
040946             0421*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
040946             0422*  
040946             0423*  ; ; compute sin(Heading_t-Bearing_t)
040946             0424*  ;     ld b,h
040946             0425*  ;     ld c,l
040946             0426*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
040946             0427*  
040946             0428*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
040946             0429*  ;     ex de,hl
040946             0430*  ;     ld bc,(Vt)
040946             0431*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
040946             0432*  
040946             0433*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
040946             0434*  ;     ld b,h
040946             0435*  ;     ld c,l
040946             0436*  ;     ld de,(Vp)
040946             0437*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
040946             0438*  ; ; answer is in radians, convert to degrees256
040946             0439*  ;     ex de,hl
040946             0440*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
040946             0441*  ;     call BC_Mul_DE_88
040946             0442*  
040946             0443*  ; ; add lead angle to target bearing
040946             0444*  ;     ld de,(Bearing_t)
040946             0445*  ;     add hl,de ; h.l=lead angle+target bearing
040946             0446*  ;     push hl
040946             0447*  
040946             0448*  ; ; compute component projectile velocities
040946             0449*  ;     ld b,h
040946             0450*  ;     ld c,l
040946             0451*  ;     ld de,(Vp)
040946             0452*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
040946             0453*  
040946             0454*  ;     ld (Vp_x),bc
040946             0455*  ;     ld (Vp_y),de
040946             0456*  ;     pop hl ; h.l=lead angle+target bearing
040946             0457*  ;     ret
040946             0458*  
040946             0459*  ; this routine vanquishes the enemy sprite
040946             0460*  ; and replaces it with an animated explosion
040946             0461*  ; we jump here instead of call because
040946             0462*  ; we want to return to differing locations in the loop
040946             0463*  ; depending on whether we're still sploding
040946             0464*  ; destroys: everything except index registers
040946             0465*  ; returns: an incandescent ball of debris and gas
040946             0466*  kill_nurple:
040946             0467*  ; ; tally up points
040946             0468*  ;     ld bc,0
040946             0469*  ;     ld a,(sprite_points)
040946             0470*  ;     ld e,a
040946             0471*  ;     ld d,0
040946             0472*  ;     ld hl,add_bcd_arg2
040946             0473*  ;     call set_bcd
040946             0474*  ;     ld hl,player_score
040946             0475*  ;     ld de,add_bcd_arg2
040946             0476*  ;     ld a,3 ; number of bytes to add
040946             0477*  ;     call add_bcd
040946             0478*  ; ; initialize explosion
040946             0479*  ; init_explosion:
040946             0480*  ;     ld hl,explosion
040946             0481*  ;     ld (sprite_base_bufferId),hl
040946             0482*  ;     ld hl,move_explosion
040946             0483*  ;     ld (sprite_move_program),hl
040946             0484*  ;     ld a,%00000000 ; collides with nothing
040946             0485*  ;     ld (iy+sprite_collisions),a
040946             0486*  ;     ld hl,0 ; north
040946             0487*  ;     ld (sprite_heading),hl
040946             0488*  ;     ld a,0x04 ; will decrement to 03
040946             0489*  ;     ld (sprite_animation),a
040946             0490*  ;     ld a,0x07 ; 7/60th of a second timer
040946             0491*  ;     ld (sprite_animation_timer),a
040946             0492*  ;     xor a
040946             0493*  ;     ld (sprite_move_timer),a
040946             0494*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
040946             0495*  ; ; fall through to next_explosion
040946             0496*  ; next_explosion:
040946             0497*  ;     ld a,(sprite_animation)
040946             0498*  ;     dec a ; if rolled negative from zero,we're done sploding
040946             0499*  ;     jp m,done_explosion
040946             0500*  ;     ld (sprite_animation),a
040946             0501*  ;     ld a,0x7 ; 7/60th of a second timer
040946             0502*  ;     ld (sprite_animation_timer),a
040946             0503*  ; ; fall through to animate_explosion
040946             0504*  ; animate_explosion:
040946             0505*  ;     ld hl,sprite_y+1
040946             0506*  ;     inc (hl) ; move explosion down 1 pixel
040946             0507*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
040946             0508*  ;     ld hl,sprite_animation_timer
040946             0509*  ;     dec (hl) ; if timer is zero,we do next animation
040946             0510*  ;     jr z,next_explosion
040946             0511*  ;     ;otherwise we fall through to draw the current one
040946             0512*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
040946             0513*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
040946             0514*  ;     ret ; now we go back to caller
040946             0515*  ; done_explosion:
040946 3E 80       0516*      ld a,%10000000 ; high bit set is non-specific kill-me flag
040948 FD 2A F7 39 0517*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
04094D FD 77 08    0518*      ld (iy+sprite_collisions),a
040950 C9          0519*      ret ; now we go back to caller
040951             0520*  
040951             0521*  ; game_over:
040951             0522*  ;     jp new_game
040951             0523*  
040951             0524*  ; it's presumed we've already checked that laser is alive
040951             0525*  collision_enemy_with_laser:
040951 DD 2A 86 25 0526*      ld ix,(laser_x)
       04          
040956 FD 2A 89 25 0527*      ld iy,(laser_y)
       04          
04095B 3A 84 25 04 0528*      ld a,(laser_dim_x)
04095F CB 2F       0529*      sra a ; divide by 2
040961 F5          0530*      push af ; we need this later
040962 C3 77 09 04 0531*      jp collision_enemy
040966             0532*  
040966             0533*  ; it's presumed we've already checked that player is alive
040966             0534*  collision_enemy_with_player:
040966 DD 2A B4 36 0535*      ld ix,(player_x)
       04          
04096B FD 2A B7 36 0536*      ld iy,(player_y)
       04          
040970 3A B2 36 04 0537*      ld a,(player_dim_x)
040974 CB 2F       0538*      sra a ; divide by 2
040976 F5          0539*      push af ; we need this later
040977             0540*      ; fall through to collision_enemy
040977             0541*  
040977             0542*  ; compute the distance between the two sprites' centers
040977             0543*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
040977             0544*  collision_enemy:
040977             0545*  ; back up iy because we need it as the sprite table pointer
040977 FD E5       0546*      push iy
040979 FD 2A F7 39 0547*      ld iy,(table_pointer)
       04          
04097E FD 27 0B    0548*      ld hl,(iy+sprite_x)
040981 FD 7E 09    0549*      ld a,(iy+sprite_dim_x)
040984 CB 2F       0550*      sra a
040986 F5          0551*      push af ; we need this later
040987 E5          0552*      push hl
040988 C1          0553*      pop bc ; bc = x0
040989 FD 27 0E    0554*      ld hl,(iy+sprite_y)
04098C FD 7E 0A    0555*      ld a,(iy+sprite_dim_y)
04098F EB          0556*      ex de,hl ; de = y0
040990 F1          0557*      pop af ; TODO: srsly, this is the best way to do this?
040991 FD E1       0558*      pop iy
040993 F5          0559*      push af
040994 CD FE 0B 04 0560*      call distance168
040998             0561*  
040998             0562*  ; ; subtract sum of radii from distance between centers
040998             0563*  ;     ld de,0
040998             0564*  ;     pop af ; radius of enemy sprite
040998             0565*  ;     ld e,a
040998             0566*  ;     pop af ; radius of player or laser sprite
040998             0567*  ;     add a,e
040998             0568*  ;     ld e,a
040998             0569*  ;     and a ; clear carry
040998             0570*  ;     sbc hl,de
040998             0571*  ;     jr c,collision_enemy_is
040998             0572*  ;     xor a
040998             0573*  ;     ret
040998             0574*  ; temp fix TODO: remove this
040998 F1          0575*      pop af
040999 F1          0576*      pop af
04099A 11 00 10 00 0577*      ld de,16*256
04099E A7          0578*      and a
04099F ED 52       0579*      sbc hl,de
0409A1 38 02       0580*      jr c,collision_enemy_is
0409A3 AF          0581*      xor a
0409A4 C9          0582*      ret
0409A5             0583*  collision_enemy_is:
0409A5 AF          0584*      xor a
0409A6 3C          0585*      inc a
0409A7 C9          0586*      ret
0409A8             0587*  
0409A8             0588*  ; ; looks up what enemy sprite collides with
0409A8             0589*  ; ; detects collisions
0409A8             0590*  ; ; and sets things to sploding accordingly
0409A8             0591*  ; check_collisions:
0409A8             0592*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
0409A8             0593*  ;     and a ; if this is zero,
0409A8             0594*  ;     ret z ; there's nothing to do
0409A8             0595*  ;     and %01 ; do we collide with player?
0409A8             0596*  ;     jr z,move_enemies_laser ; if not,check laser collision
0409A8             0597*  ;     call collision_enemy_with_player ; otherwise see if we hit player
0409A8             0598*  ;     and a ; was there a collision?
0409A8             0599*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
0409A8             0600*  ; ; yes collision with player
0409A8             0601*  ;     ; deduct shield damage
0409A8             0602*  ;     ld hl,sprite_shield_damage
0409A8             0603*  ;     ld a,(player_shields)
0409A8             0604*  ;     sub (hl)
0409A8             0605*  ;     ld (player_shields),a
0409A8             0606*  ; ; if shields >= 0,player survives
0409A8             0607*  ;     jp p,check_collisions_kill_nurple
0409A8             0608*  ; ; otherwise update player status so it will die
0409A8             0609*  ;     ld a,(player_collisions)
0409A8             0610*  ;     or %10 ; sets bit 1,meaning player just died
0409A8             0611*  ;     ld (player_collisions),a
0409A8             0612*  ;     ; fall through
0409A8             0613*  ; check_collisions_kill_nurple:
0409A8             0614*  ; ; kill enemy and replace with explosion
0409A8             0615*  ;     call kill_nurple
0409A8             0616*  ;     ret ; and out
0409A8             0617*  
0409A8             0618*  check_collisions:
0409A8 CD 66 09 04 0619*      call collision_enemy_with_player ; did we hit the player?
0409AC A7          0620*      and a ; was there a collision?
0409AD C8          0621*      ret z ; if not,we're done
0409AE CD 46 09 04 0622*      call kill_nurple ; otherwise kill enemy
0409B2 C9          0623*      ret
0409B3             0624*  
0409B3             0625*  ; did we hit the laser?
0409B3             0626*  move_enemies_laser:
0409B3 FD 7E 08    0627*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0409B6 E6 02       0628*      and %10 ; do we even collide with laser?
0409B8 C8          0629*      ret z ; if not,we're out
0409B9 3A 83 25 04 0630*      ld a,(laser_collisions) ; is laser alive?
0409BD E6 01       0631*      and %1 ; if bit 0 is not set laser is dead
0409BF C8          0632*      ret z ; so we're out
0409C0 CD 51 09 04 0633*      call collision_enemy_with_laser ; otherwise check for collision
0409C4 A7          0634*      and a ; was there a collision?
0409C5 C8          0635*      ret z ; if not,we're done
0409C6             0636*  ; otherwise we mark laser for termination and kill enemy
0409C6             0637*  ; update laser status so it will die
0409C6 3A 83 25 04 0638*      ld a,(laser_collisions)
0409CA F6 02       0639*      or %10 ; bit 1 set means laser just died
0409CC 32 83 25 04 0640*      ld (laser_collisions),a
0409D0 CD 46 09 04 0641*      call kill_nurple ; yes there was a collision,so kill enemy
0409D4 C9          0642*      ret ; we're outta' here
0409D5             0032       include "files.inc"
0409D5             0001*  ; load to onboard 8k sram
0409D5             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0409D5             0033       include "fixed168.inc"
0409D5             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0409D5             0002*  ; uses EZ80 MLT instruction for speed
0409D5             0003*  ; operation: UHL * A --> UHL
0409D5             0004*  ; destroys: AF, HL
0409D5             0005*  smul24x8:
0409D5             0006*  ; make hl positive and store sign flag
0409D5 CD 94 06 04 0007*      call hlu_abs
0409D9 F5          0008*      push af
0409DA             0009*  ; do the division
0409DA CD E5 09 04 0010*      call mul24x8 ; hl = product
0409DE             0011*  ; adjust sign of result
0409DE F1          0012*      pop af ; sign de
0409DF F0          0013*      ret p ; hl was positive, nothing to do
0409E0 CD A4 06 04 0014*      call neg_hlu ; result is negative
0409E4 C9          0015*      ret
0409E5             0016*  
0409E5             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0409E5             0018*  ; uses EZ80 MLT instruction for speed
0409E5             0019*  ; operation: UHL * A --> AUHL
0409E5             0020*  ; destroys: AF, HL
0409E5             0021*  mul24x8:
0409E5 D5          0022*      push de ; preserve de
0409E6             0023*  ; low byte
0409E6 5D          0024*      ld e,l
0409E7 57          0025*      ld d,a
0409E8 ED 5C       0026*      mlt de
0409EA 6B          0027*      ld l,e ; product low byte
0409EB 08          0028*      ex af,af' ; save multiplier
0409EC 7A          0029*      ld a,d ; carry
0409ED 08          0030*      ex af,af' ; save carry, restore multiplier
0409EE             0031*  ; high byte
0409EE 5C          0032*      ld e,h
0409EF 57          0033*      ld d,a
0409F0 ED 5C       0034*      mlt de
0409F2 08          0035*      ex af,af' ; save multiplier, restore carry
0409F3 83          0036*      add a,e ; add carry
0409F4 67          0037*      ld h,a ; product middle byte
0409F5 7A          0038*      ld a,d ; carry
0409F6 08          0039*      ex af,af' ; save carry, restore multiplier
0409F7             0040*  ; upper byte
0409F7 22 12 0A 04 0041*      ld (@scratch),hl ; 7 cycles
0409FB 5F          0042*      ld e,a
0409FC 3A 14 0A 04 0043*      ld a,(@scratch+2)
040A00 57          0044*      ld d,a
040A01 ED 5C       0045*      mlt de
040A03 08          0046*      ex af,af' ; restore carry
040A04 8B          0047*      adc a,e ; add carry
040A05 32 14 0A 04 0048*      ld (@scratch+2),a ; 5 cycles
040A09 2A 12 0A 04 0049*      ld hl,(@scratch) ; 7 cycles
040A0D             0050*  ; highest byte
040A0D 3E 00       0051*      ld a,0 ; preserve carry flag
040A0F 8A          0052*      adc a,d ; product highest byte
040A10 D1          0053*      pop de ; restore de
040A11 C9          0054*      ret
040A12             0055*  @scratch: ds 3
040A15             0056*  
040A15 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
040A1B             0058*  
040A1B             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A1B             0060*  ; operation: UHL * UDE --> mul24out
040A1B             0061*  mul24:
040A1B DD E5       0062*      push ix ; preserve
040A1D             0063*  ; point to output buffer and clear it
040A1D DD 21 15 0A 0064*      ld ix,mul24out
       04          
040A22 C5          0065*      push bc
040A23 01 00 00 00 0066*      ld bc,0
040A27 DD 0F 00    0067*      ld (ix),bc
040A2A DD 0F 03    0068*      ld (ix+3),bc
040A2D C1          0069*      pop bc
040A2E             0070*  ; STEP 1: UHL * E
040A2E 7B          0071*      ld a,e
040A2F E5          0072*      push hl
040A30 CD E5 09 04 0073*      call mul24x8
040A34 DD 2F 00    0074*      ld (ix+0),hl
040A37 DD 77 03    0075*      ld (ix+3),a
040A3A             0076*  ; STEP 2: UHL * D
040A3A E1          0077*      pop hl
040A3B E5          0078*      push hl
040A3C 7A          0079*      ld a,d
040A3D CD E5 09 04 0080*      call mul24x8
040A41 CD 5A 0A 04 0081*      call @accumulate
040A45             0082*  ; STEP 3: UHL * DEU
040A45 E1          0083*      pop hl
040A46 ED 53 8A 0A 0084*      ld (@de),de
       04          
040A4B 3A 8C 0A 04 0085*      ld a,(@de+2)
040A4F CD E5 09 04 0086*      call mul24x8
040A53 CD 5A 0A 04 0087*      call @accumulate
040A57             0088*  ; all done
040A57 DD E1       0089*      pop ix ; restore
040A59 C9          0090*      ret
040A5A             0091*  @accumulate:
040A5A DD 23       0092*      inc ix
040A5C             0093*  ; highest byte of product to carry
040A5C DD 77 03    0094*      ld (ix+3),a
040A5F             0095*  ; low byte of product
040A5F 7D          0096*      ld a,l
040A60 DD 86 00    0097*      add a,(ix+0)
040A63 DD 77 00    0098*      ld (ix+0),a
040A66             0099*  ; high byte of product
040A66 7C          0100*      ld a,h
040A67 DD 8E 01    0101*      adc a,(ix+1)
040A6A DD 77 01    0102*      ld (ix+1),a
040A6D             0103*  ; uppper byte of product
040A6D 22 87 0A 04 0104*      ld (@hl),hl
040A71 3A 89 0A 04 0105*      ld a,(@hl+2)
040A75 DD 8E 02    0106*      adc a,(ix+2)
040A78 DD 77 02    0107*      ld (ix+2),a
040A7B             0108*  ; carry
040A7B 3E 00       0109*      ld a,0 ; preserve flags
040A7D DD 8E 03    0110*      adc a,(ix+3)
040A80 DD 77 03    0111*      ld (ix+3),a
040A83 C9          0112*      ret
040A84             0113*  
040A84 00 00 00    0114*  @ix: dl 0
040A87 00 00 00    0115*  @hl: dl 0
040A8A 00 00 00    0116*  @de: dl 0
040A8D             0117*  
040A8D             0118*  ; UHL * UDE --> UHL (unsigned)
040A8D             0119*  umul24:
040A8D CD 1B 0A 04 0120*      call mul24
040A91 2A 15 0A 04 0121*      ld hl,(mul24out)
040A95 C9          0122*      ret
040A96             0123*  
040A96             0124*  ; UH.L = UH.L*UD.E (unsigned)
040A96             0125*  umul168:
040A96 CD 1B 0A 04 0126*      call mul24
040A9A 2A 16 0A 04 0127*      ld hl,(mul24out+1)
040A9E C9          0128*      ret
040A9F             0129*  
040A9F             0130*  ; UH.L * UD.E --> UH.L (signed)
040A9F             0131*  smul168:
040A9F             0132*  ; make everything positive and store sign flags
040A9F CD 94 06 04 0133*      call hlu_abs
040AA3 F5          0134*      push af
040AA4 EB          0135*      ex de,hl
040AA5 CD 94 06 04 0136*      call hlu_abs
040AA9 EB          0137*      ex de,hl
040AAA F5          0138*      push af
040AAB             0139*  ; do the division
040AAB CD 96 0A 04 0140*      call umul168 ; hl = product
040AAF             0141*  ; adjust sign of result
040AAF F1          0142*      pop af ; sign de
040AB0 FA BB 0A 04 0143*      jp m,@de_neg
040AB4 F1          0144*      pop af ; sign hl
040AB5 F0          0145*      ret p ; both positive, nothing to do
040AB6             0146*  @hl_neg:
040AB6 CD A4 06 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
040ABA C9          0148*      ret
040ABB             0149*  @de_neg:
040ABB F1          0150*      pop af
040ABC F8          0151*      ret m ; both negative, nothing to do
040ABD CD A4 06 04 0152*      call neg_hlu ; result is negative
040AC1 C9          0153*      ret
040AC2             0154*  
040AC2             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040AC2             0156*  ; perform unsigned division of 16.8 fixed place values
040AC2             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040AC2             0158*  udiv168:
040AC2             0159*  ; back up divisor
040AC2 ED 53 F9 0A 0160*      ld (@ude),de
       04          
040AC7             0161*  ; get the 16-bit integer part of the quotient
040AC7 CD 2A 0B 04 0162*      call udiv24 ; de = quotient, hl = remainder
040ACB             0163*  ; load quotient to upper three bytes of output
040ACB ED 53 00 0B 0164*      ld (div168_out+1),de
       04          
040AD0             0165*  @div256:
040AD0             0166*  ; multiply remainder by 256
040AD0             0167*      hlu_mul256
040AD0 29          0001*M     add hl,hl ; * 2
040AD1 29          0002*M     add hl,hl ; * 4
040AD2 29          0003*M     add hl,hl ; * 8
040AD3 29          0004*M     add hl,hl ; * 16
040AD4 29          0005*M     add hl,hl ; * 32
040AD5 29          0006*M     add hl,hl ; * 64
040AD6 29          0007*M     add hl,hl ; * 128
040AD7 29          0008*M     add hl,hl ; * 256
040AD8             0168*  ; skip fractional computation if remainder is zero
040AD8             0169*      sign_hlu
040AD8 19          0001*M     add hl,de
040AD9 B7          0002*M     or a
040ADA ED 52       0003*M     sbc hl,de
040ADC 20 03       0170*      jr nz,@div_frac
040ADE AF          0171*      xor a
040ADF 18 0A       0172*      jr @write_frac
040AE1             0173*  ; now divide the shifted remainder by the divisor
040AE1             0174*  @div_frac:
040AE1 ED 5B F9 0A 0175*      ld de,(@ude) ; get back divisor
       04          
040AE6 CD 2A 0B 04 0176*      call udiv24 ; de = quotient, hl = remainder
040AEA             0177*  ; load low byte of quotient to low byte of output
040AEA 7B          0178*      ld a,e
040AEB             0179*  @write_frac:
040AEB 32 FF 0A 04 0180*      ld (div168_out),a
040AEF             0181*  ; load de with return value
040AEF ED 5B FF 0A 0182*      ld de,(div168_out)
       04          
040AF4             0183*  ; load a with any overflow
040AF4 3A 02 0B 04 0184*      ld a,(div168_out+3)
040AF8 C9          0185*      ret ; ud.e is the 16.8 result
040AF9             0186*  @ude: ds 6
040AFF             0187*  div168_out: ds 4 ; the extra byte is for overflow
040B03             0188*  
040B03             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B03             0190*  ; perform signed division of 16.8 fixed place values
040B03             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B03             0192*  sdiv168:
040B03             0193*  ; make everything positive and store sign flags
040B03 CD 94 06 04 0194*      call hlu_abs
040B07 F5          0195*      push af
040B08 EB          0196*      ex de,hl
040B09 CD 94 06 04 0197*      call hlu_abs
040B0D EB          0198*      ex de,hl
040B0E F5          0199*      push af
040B0F             0200*  ; do the division
040B0F CD C2 0A 04 0201*      call udiv168 ; de = quotient, hl = remainder
040B13             0202*  ; adjust sign of result
040B13 F1          0203*      pop af ; sign de
040B14 FA 21 0B 04 0204*      jp m,@de_neg
040B18 F1          0205*      pop af ; sign hl
040B19 F0          0206*      ret p ; both positive, nothing to do
040B1A             0207*  @hl_neg:
040B1A EB          0208*      ex de,hl ; hl = quotient, de = remainder
040B1B CD A4 06 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
040B1F EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
040B20 C9          0211*      ret
040B21             0212*  @de_neg:
040B21 F1          0213*      pop af
040B22 F8          0214*      ret m ; both negative, nothing to do
040B23 EB          0215*      ex de,hl ; hl = quotient, de = remainder
040B24 CD A4 06 04 0216*      call neg_hlu ; result is negative
040B28 EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
040B29 C9          0218*      ret
040B2A             0219*  
040B2A             0220*  ;------------------------------------------------------------------------
040B2A             0221*  ;  arith24.asm
040B2A             0222*  ;  24-bit ez80 arithmetic routines
040B2A             0223*  ;  Copyright (c) Shawn Sijnstra 2024
040B2A             0224*  ;  MIT license
040B2A             0225*  ;
040B2A             0226*  ;  This library was created as a tool to help make ez80
040B2A             0227*  ;  24-bit native assembly routines for simple mathematical problems
040B2A             0228*  ;  more widely available.
040B2A             0229*  ;
040B2A             0230*  ;------------------------------------------------------------------------
040B2A             0231*  ;
040B2A             0232*  ;------------------------------------------------------------------------
040B2A             0233*  ; udiv24
040B2A             0234*  ; Unsigned 24-bit division
040B2A             0235*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040B2A             0236*  ;
040B2A             0237*  ; Uses AF BC DE HL
040B2A             0238*  ; Uses Restoring Division algorithm
040B2A             0239*  ;------------------------------------------------------------------------
040B2A             0240*  
040B2A             0241*  udiv24:
040B2A E5          0242*      push hl
040B2B C1          0243*      pop bc ;move dividend to BCU
040B2C 21 00 00 00 0244*      ld hl,0 ;result
040B30 A7          0245*      and a
040B31 ED 52       0246*      sbc hl,de ;test for div by 0
040B33 C8          0247*      ret z ;it's zero, carry flag is clear
040B34 19          0248*      add hl,de ;HL is 0 again
040B35 3E 18       0249*      ld a,24 ;number of loops through.
040B37             0250*  udiv1:
040B37 C5          0251*      push bc ;complicated way of doing this because of lack of access to top bits
040B38 E3          0252*      ex (sp),hl
040B39 37          0253*      scf
040B3A ED 6A       0254*      adc hl,hl
040B3C E3          0255*      ex (sp),hl
040B3D C1          0256*      pop bc ;we now have bc = (bc * 2) + 1
040B3E             0257*  
040B3E ED 6A       0258*      adc hl,hl
040B40 A7          0259*      and a ;is this the bug
040B41 ED 52       0260*      sbc hl,de
040B43 30 02       0261*      jr nc,udiv2
040B45 19          0262*      add hl,de
040B46             0263*  ;	dec	c
040B46 0B          0264*      dec bc
040B47             0265*  udiv2:
040B47 3D          0266*      dec a
040B48 20 ED       0267*      jr nz,udiv1
040B4A 37          0268*      scf ;flag used for div0 error
040B4B C5          0269*      push bc
040B4C D1          0270*      pop de ;remainder
040B4D C9          0271*      ret
040B4E             0272*  
040B4E             0273*  ;------------------------------------------------------------------------
040B4E             0274*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
040B4E             0275*  ;------------------------------------------------------------------------
040B4E             0276*  
040B4E             0277*  
040B4E             0278*      ; include "trig24fast.inc"
040B4E             0279*  
040B4E             0280*  
040B4E             0281*  ; convert signed angles from a 360 to 256 degree circle
040B4E             0282*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B4E             0283*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B4E             0284*  ; destroys: TODO
040B4E             0285*  deg_360_to_256:
040B4E D5          0286*      push de ; preserve de
040B4F             0287*  ; make angle positive and store sign flag
040B4F CD 94 06 04 0288*      call hlu_abs
040B53 F5          0289*      push af
040B54             0290*  ; multiply by coversion factor of 256/360
040B54 11 B6 00 00 0291*      ld de,0x0000B6 ; 0.711
040B58 CD 96 0A 04 0292*      call umul168 ; uh.l = uh.l * 0.711
040B5C             0293*  ; restore sign flag and adjust output accordingly
040B5C F1          0294*      pop af
040B5D F2 65 0B 04 0295*      jp p,@pos ; positive number
040B61 CD A4 06 04 0296*      call neg_hlu
040B65             0297*  @pos:
040B65             0298*  ; restore de and return uh.l as the result
040B65 D1          0299*      pop de
040B66 C9          0300*      ret
040B67             0301*  
040B67             0302*  ; convert signed angles from a 256 to 360 degree circle
040B67             0303*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040B67             0304*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040B67             0305*  ; destroys: TODO
040B67             0306*  deg_256_to_360:
040B67 D5          0307*      push de ; preserve de
040B68             0308*  ; make angle positive and store sign flag
040B68 CD 94 06 04 0309*      call hlu_abs
040B6C F5          0310*      push af
040B6D             0311*  ; multiply by coversion factor of 360/256
040B6D 11 68 01 00 0312*      ld de,0x000168 ; 1.406
040B71 CD 96 0A 04 0313*      call umul168 ; uh.l = uh.l * 1.406
040B75             0314*  ; restore sign flag and adjust output accordingly
040B75 F1          0315*      pop af
040B76 F2 7E 0B 04 0316*      jp p,@pos ; positive number
040B7A CD A4 06 04 0317*      call neg_hlu
040B7E             0318*  @pos:
040B7E             0319*  ; restore de and return uh.l as the result
040B7E D1          0320*      pop de
040B7F C9          0321*      ret
040B80             0322*  
040B80             0323*  ; fixed 16.8 routine
040B80             0324*  ; cos(uh.l) --> uh.l
040B80             0325*  ; destroys: f, hl
040B80             0326*  cos168:
040B80 D5          0327*      push de ; preserve de
040B81             0328*  ; for cos we simply increment the angle by 90 degrees
040B81             0329*  ; or 0x004000 in 16.8 degrees256
040B81             0330*  ; which makes it a sin problem
040B81 11 00 40 00 0331*      ld de,0x004000
040B85 19          0332*      add hl,de ; modulo 256 happens below
040B86 D1          0333*      pop de ; restore de
040B87             0334*  ; fall through to sin168
040B87             0335*  
040B87             0336*  ; ---------------------
040B87             0337*  ; fixed 16.8 routine
040B87             0338*  ; sin(uh.l) --> uh.l
040B87             0339*  ; destroys: f, hl
040B87             0340*  sin168:
040B87 D5          0341*      push de
040B88             0342*  ; handle negative angles appropriately
040B88 CD 94 06 04 0343*      call hlu_abs
040B8C F2 95 0B 04 0344*      jp p,@F
040B90 11 00 00 FF 0345*      ld de,-256*256
040B94 19          0346*      add hl,de
040B95             0347*  @@:
040B95 2E 03       0348*      ld l,3 ; multiply by 3 to get our lookup index
040B97 ED 6C       0349*      mlt hl
040B99 11 E5 0D 04 0350*      ld de,sin_lut_168 ; grab the lut address
040B9D 19          0351*      add hl,de ; bump hl by the index
040B9E ED 27       0352*      ld hl,(hl) ; don't try this on a z80!
040BA0 D1          0353*      pop de
040BA1 C9          0354*      ret
040BA2             0355*  
040BA2             0356*  ; 16.8 fixed inputs / outputs
040BA2             0357*  ; takes: uh.l as angle in degrees 256
040BA2             0358*  ;        ud.e as radius
040BA2             0359*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BA2             0360*  ;        displacements from origin (0,0)
040BA2             0361*  ; destroys: everything except indexes
040BA2             0362*  polar_to_cartesian:
040BA2             0363*  ; back up input parameters
040BA2 22 D1 0B 04 0364*      ld (@angle), hl
040BA6 ED 53 D4 0B 0365*      ld (@radius), de
       04          
040BAB             0366*  ; compute dx = sin(uh.l) * ud.e
040BAB CD 87 0B 04 0367*      call sin168 ; uh.l = sin(uh.l)
040BAF ED 5B D4 0B 0368*      ld de,(@radius)
       04          
040BB4 CD 9F 0A 04 0369*      call smul168 ; uh.l = dx
040BB8 E5          0370*      push hl
040BB9             0371*  ; compute dy = -cos(uh.l) * ud.e
040BB9 2A D1 0B 04 0372*      ld hl,(@angle)
040BBD CD 80 0B 04 0373*      call cos168 ; uh.l = cos(uh.l)
040BC1 ED 5B D4 0B 0374*      ld de,(@radius)
       04          
040BC6 CD 9F 0A 04 0375*      call smul168 ; uh.l = dy
040BCA CD A4 06 04 0376*      call neg_hlu ; invert dy for screen coords convention
040BCE EB          0377*      ex de,hl ; de = dy for output
040BCF C1          0378*      pop bc ; bc = dx for output
040BD0             0379*  ; and out
040BD0 C9          0380*      ret
040BD1             0381*  @angle: ds 3
040BD4             0382*  @radius: ds 3
040BD7             0383*  
040BD7             0384*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BD7             0385*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BD7             0386*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BD7             0387*  ;         also populates scratch locations dx168 and dy168
040BD7             0388*  ; destroys: a,hl,bc,de
040BD7             0389*  dxy168:
040BD7             0390*  ; compute dx = x1-x0
040BD7 AF          0391*      xor a ; clear carry
040BD8 DD E5       0392*      push ix ; move ix to hl via the stack
040BDA E1          0393*      pop hl ; hl = x1
040BDB ED 42       0394*      sbc hl,bc ; hl = dx
040BDD 22 F2 0B 04 0395*      ld (dx168),hl ; dx to scratch
040BE1             0396*  ; compute dy = y1-y0
040BE1 AF          0397*      xor a ; clear carry
040BE2 FD E5       0398*      push iy ; move iy to hl via the stack
040BE4 E1          0399*      pop hl ; hl = y1
040BE5 ED 52       0400*      sbc hl,de ; hl = dy
040BE7 22 F8 0B 04 0401*      ld (dy168),hl ; dy to scratch
040BEB             0402*  ; populate output registers and return
040BEB EB          0403*      ex de,hl ; ud.e = dy
040BEC ED 4B F2 0B 0404*      ld bc,(dx168) ; ub.c = dx
       04          
040BF1 C9          0405*      ret
040BF2 00 00 00 00 0406*  dx168: blkb 6,0
       00 00       
040BF8 00 00 00 00 0407*  dy168: blkb 6,0
       00 00       
040BFE             0408*  
040BFE             0409*  ; compute the euclidian distance between two cartesian coordinates
040BFE             0410*  ; using the formula d = sqrt(dx^2+dy^2)
040BFE             0411*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BFE             0412*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BFE             0413*  ; output; uh.l is the 16.8 fixed format distance
040BFE             0414*  ;         also populates scratch locations dx168 and dy168
040BFE             0415*  ; destroys: a,hl,bc,de
040BFE             0416*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040BFE             0417*  ;       thus the result will always be an integer, albeit in 16.8 format
040BFE             0418*  distance168:
040BFE CD D7 0B 04 0419*      call dxy168 ; ub.c = dx, ud.e = dy
040C02             0420*  ; compute dy^2
040C02 EB          0421*      ex de,hl
040C03 CD 94 06 04 0422*      call hlu_abs
040C07 CD FB 06 04 0423*      call hlu_udiv256 ; make integer to avoid overflow
040C0B E5          0424*      push hl
040C0C D1          0425*      pop de
040C0D CD 8D 0A 04 0426*      call umul24 ; hl = dy^2
040C11 E5          0427*      push hl ; save dy^2
040C12             0428*  ; compute dx^2
040C12 2A F2 0B 04 0429*      ld hl,(dx168)
040C16 CD 94 06 04 0430*      call hlu_abs
040C1A CD FB 06 04 0431*      call hlu_udiv256 ; make integer to avoid overflow
040C1E E5          0432*      push hl
040C1F D1          0433*      pop de
040C20 CD 8D 0A 04 0434*      call umul24 ; hl = dx^2
040C24             0435*  ; add dx^2 and dy^2
040C24 D1          0436*      pop de ; de = dy^2 (was hl)
040C25 19          0437*      add hl,de ; hl = dx^2 + dy^2
040C26             0438*  ; compute the square root
040C26 CD FF 0C 04 0439*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C2A EB          0440*      ex de,hl ; hl = distance
040C2B             0441*      hlu_mul256 ; convert back to 16.8 fixed
040C2B 29          0001*M     add hl,hl ; * 2
040C2C 29          0002*M     add hl,hl ; * 4
040C2D 29          0003*M     add hl,hl ; * 8
040C2E 29          0004*M     add hl,hl ; * 16
040C2F 29          0005*M     add hl,hl ; * 32
040C30 29          0006*M     add hl,hl ; * 64
040C31 29          0007*M     add hl,hl ; * 128
040C32 29          0008*M     add hl,hl ; * 256
040C33 C9          0442*      ret
040C34             0443*  
040C34             0444*  ; atan2_(ub.c,ud.e) --> uh.l
040C34             0445*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C34             0446*  ;   whether inputs are integers or fractional doesn't matter
040C34             0447*  ;   so long as the sign bit of the upper byte is correct
040C34             0448*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C34             0449*  ; angles are COMPASS HEADINGS based on
040C34             0450*  ; screen coordinate conventions,where the y axis is flipped
040C34             0451*  ; #E0 224      0       32 #20
040C34             0452*  ;        -x,-y | +x,-y
040C34             0453*  ; #C0 192------+------ 64 #40
040C34             0454*  ;        -x,+y | +x,+y
040C34             0455*  ; #A0 160   128 #80   96 #60
040C34             0456*  atan2_168fast:
040C34             0457*  ; get signs and make everything positive
040C34             0458*  ; get abs(x) and store its original sign
040C34 C5          0459*      push bc
040C35 E1          0460*      pop hl
040C36 CD 94 06 04 0461*      call hlu_abs ; if x was negative this also sets the sign flag
040C3A E5          0462*      push hl ; store abs(x)
040C3B C1          0463*      pop bc ; bc = abs(x)
040C3C F5          0464*      push af ; store sign of x
040C3D             0465*  ; get abs(y) and store its original sign
040C3D EB          0466*      ex de,hl ; hl = y
040C3E CD 94 06 04 0467*      call hlu_abs ; if y was negative this also sets the sign flag
040C42 EB          0468*      ex de,hl ; de = abs(y)
040C43 F5          0469*      push af ; store sign of y
040C44             0470*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C44             0471*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C44 AF          0472*      xor a ; clear the carry flag
040C45 D5          0473*      push de
040C46 E1          0474*      pop hl
040C47 ED 42       0475*      sbc hl,bc
040C49 F5          0476*      push af ; save sign of de - bc
040C4A F2 53 0C 04 0477*      jp p,@1 ; bc <= de, so we skip ahead
040C4E             0478*  ; otherwise we swap bc and de
040C4E C5          0479*      push bc
040C4F E1          0480*      pop hl
040C50 EB          0481*      ex de,hl
040C51 E5          0482*      push hl
040C52 C1          0483*      pop bc
040C53             0484*  @1:
040C53             0485*  ; now we're ready to snag our preliminary result
040C53 C5          0486*      push bc
040C54 E1          0487*      pop hl
040C55 CD C3 0C 04 0488*      call atan_168fast ; uh.l comes back with prelim result
040C59             0489*  ; now we adjust uh.l based on sign of de - bc
040C59 F1          0490*      pop af
040C5A F2 66 0C 04 0491*      jp p,@2 ; bc <= de,so we skip ahead
040C5E EB          0492*      ex de,hl
040C5F 21 00 40 00 0493*      ld hl,64*256 ; subtract from 64 (90) degrees
040C63 AF          0494*      xor a ; clear the carry flag
040C64 ED 52       0495*      sbc hl,de
040C66             0496*  @2:
040C66             0497*  ; adjust the result based on quadrant
040C66             0498*  ; #E0 224      0       32 #20
040C66             0499*  ;        -x,-y | +x,-y
040C66             0500*  ; #C0 192------+------ 64 #40
040C66             0501*  ;        -x,+y | +x,+y
040C66             0502*  ; #A0 160   128 #80   96 #60
040C66 F1          0503*      pop af ; sign of y
040C67 CA A4 0C 04 0504*      jp z,@y_zero
040C6B F2 84 0C 04 0505*      jp p,@y_pos
040C6F             0506*  ; y neg,check x
040C6F F1          0507*      pop af ; sign of x
040C70 CA 7E 0C 04 0508*      jp z,@y_neg_x_zero
040C74 F2 83 0C 04 0509*      jp p,@y_neg_x_pos
040C78             0510*  ; y neg,x neg
040C78             0511*  ; angle is 128 to 256 (270 to 360)
040C78             0512*  ; negating the intermediate does the trick
040C78 CD A4 06 04 0513*      call neg_hlu
040C7C 18 31       0514*      jr @zero_hlu
040C7E             0515*  
040C7E             0516*  @y_neg_x_zero:
040C7E             0517*  ; y neg,x zero
040C7E             0518*  ; angle is 0
040C7E 21 00 00 00 0519*      ld hl,0
040C82 C9          0520*      ret
040C83             0521*  @y_neg_x_pos:
040C83             0522*  ; y neg,x pos
040C83             0523*  ; angle is 0 to 64 (0 to 90)
040C83             0524*  ; so we're good
040C83 C9          0525*      ret
040C84             0526*  
040C84             0527*  @y_pos:
040C84 F1          0528*      pop af ; sign of x
040C85 CA 94 0C 04 0529*      jp z,@y_pos_x_zero
040C89 F2 99 0C 04 0530*      jp p,@y_pos_x_pos
040C8D             0531*  ; y pos,x neg
040C8D             0532*  ; angle is 128 to 192 (180-270)
040C8D             0533*  ; so we add 128 to intermediate
040C8D 11 00 80 00 0534*      ld de,128*256
040C91 19          0535*      add hl,de
040C92 18 1B       0536*      jr @zero_hlu
040C94             0537*  @y_pos_x_zero:
040C94             0538*  ; y pos,x zero
040C94             0539*  ; angle is 128 (180)
040C94 21 00 80 00 0540*      ld hl,128*256
040C98 C9          0541*      ret
040C99             0542*  @y_pos_x_pos:
040C99             0543*  ; y pos,x pos
040C99             0544*  ; angle is 64 to 128 (90 to 180)
040C99             0545*  ; neg the intermediate and add 180 degrees
040C99 CD A4 06 04 0546*      call neg_hlu
040C9D 11 00 80 00 0547*      ld de,128*256
040CA1 19          0548*      add hl,de
040CA2 18 0B       0549*      jr @zero_hlu
040CA4             0550*  
040CA4             0551*  @y_zero:
040CA4 F1          0552*      pop af ; sign of x
040CA5 FA AA 0C 04 0553*      jp m,@y_zero_x_neg
040CA9             0554*  ; y zero,x pos
040CA9             0555*  ; angle is 64 (90),nothing to do
040CA9 C9          0556*      ret
040CAA             0557*  @y_zero_x_neg:
040CAA             0558*  ; y zero ,x neg
040CAA             0559*  ; angle is 192 (270)
040CAA 21 00 C0 00 0560*      ld hl,192*256
040CAE C9          0561*      ret
040CAF             0562*  @zero_hlu:
040CAF AF          0563*      xor a
040CB0 22 BD 0C 04 0564*      ld (@scratch),hl
040CB4 32 BF 0C 04 0565*      ld (@scratch+2),a
040CB8 2A BD 0C 04 0566*      ld hl,(@scratch)
040CBC C9          0567*      ret
040CBD             0568*  @scratch: ds 6
040CC3             0569*  
040CC3             0570*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CC3             0571*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040CC3             0572*  ; destroys: a,hl,bc,de
040CC3             0573*  ; note: only works for angles from 0 to 32 (45) degrees
040CC3             0574*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040CC3             0575*  atan_168fast:
040CC3             0576*  ; because we use compass headings instead of geometric angles
040CC3             0577*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040CC3             0578*  ; we can do faster unsigned division here because we know dx and dy are positive
040CC3 CD C2 0A 04 0579*      call udiv168 ; ud.e = dx/dy
040CC7 EB          0580*      ex de,hl ; uh.l = dx/dy
040CC8             0581*  ; test uh.l for 0
040CC8 19          0582*      add hl,de
040CC9 B7          0583*      or a
040CCA ED 52       0584*      sbc hl,de
040CCC 28 22       0585*      jr z,@is_zero
040CCE             0586*  ; test uh.l for 1
040CCE AF          0587*      xor a ; clear carry
040CCF EB          0588*      ex de,hl
040CD0 21 00 01 00 0589*      ld hl,1*256 ; 1 in 16.8 fixed format
040CD4 ED 52       0590*      sbc hl,de
040CD6 28 13       0591*      jr z,@is_45
040CD8 EB          0592*      ex de,hl
040CD9             0593*  ; no special cases so we move on
040CD9             0594*  ; l contains the fractional portion of tan(uh.l)
040CD9             0595*  ; we multiply it by three to get our lookup table index
040CD9 26 03       0596*      ld h,3
040CDB ED 6C       0597*      mlt hl ; index into lut
040CDD 11 00 00 00 0598*      ld de,0 ; clear deu
040CE1 54          0599*      ld d,h ; copy hl to de
040CE2 5D          0600*      ld e,l ; de contains our index
040CE3 21 E8 10 04 0601*      ld hl,atan_lut_168 ; grab the lut address
040CE7 19          0602*      add hl,de ; bump hl by the index
040CE8 ED 27       0603*      ld hl,(hl) ; don't try this on a z80!
040CEA C9          0604*      ret ; and out
040CEB             0605*  @is_45:
040CEB 21 00 40 00 0606*      ld hl,64*256
040CEF C9          0607*      ret
040CF0             0608*  ; for the case tan(0)
040CF0             0609*  @is_zero:
040CF0 21 00 00 00 0610*      ld hl,0*256
040CF4 C9          0611*      ret
040CF5             0612*  
040CF5             0613*  ; Expects  ADL mode
040CF5             0614*  ; Inputs:  UH.L
040CF5             0615*  ; Outputs: UH.L is the 16.8 square root
040CF5             0616*  ;          UDE is the integer difference inputHL-DE^2
040CF5             0617*  sqrt168:
040CF5 CD FF 0C 04 0618*      call sqrt24
040CF9 EB          0619*      ex de,hl
040CFA 29          0620*      add hl,hl
040CFB 29          0621*      add hl,hl
040CFC 29          0622*      add hl,hl
040CFD 29          0623*      add hl,hl
040CFE C9          0624*      ret
040CFF             0625*  
040CFF             0626*  ; credit: xeda112358
040CFF             0627*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040CFF             0628*  sqrt24:
040CFF             0629*  ; Expects ADL mode
040CFF             0630*  ; Inputs: HL
040CFF             0631*  ; Outputs: DE is the integer square root
040CFF             0632*  ;  HL is the difference inputHL-DE^2
040CFF             0633*  ;  c flag reset
040CFF 01 00 00 00 0634*      ld bc,0 ; clear bcu
040D03 11 00 00 00 0635*      ld de,0 ; clear deu
040D07 AF          0636*      xor a
040D08 45          0637*      ld b,l
040D09 C5          0638*      push bc
040D0A 47          0639*      ld b,a
040D0B 6F          0640*      ld l,a
040D0C             0641*  ; Iteration 1
040D0C 29          0642*      add hl,hl
040D0D CB 11       0643*      rl c
040D0F 29          0644*      add hl,hl
040D10 CB 11       0645*      rl c
040D12 91          0646*      sub c
040D13 30 04       0647*      jr nc,$+6
040D15 1C          0648*      inc e
040D16 1C          0649*      inc e
040D17 2F          0650*      cpl
040D18 4F          0651*      ld c,a
040D19             0652*  ; Iteration 2
040D19 29          0653*      add hl,hl
040D1A CB 11       0654*      rl c
040D1C 29          0655*      add hl,hl
040D1D CB 11       0656*      rl c
040D1F CB 13       0657*      rl e
040D21 7B          0658*      ld a,e
040D22 91          0659*      sub c
040D23 30 04       0660*      jr nc,$+6
040D25 1C          0661*      inc e
040D26 1C          0662*      inc e
040D27 2F          0663*      cpl
040D28 4F          0664*      ld c,a
040D29             0665*  ; Iteration 3
040D29 29          0666*      add hl,hl
040D2A CB 11       0667*      rl c
040D2C 29          0668*      add hl,hl
040D2D CB 11       0669*      rl c
040D2F CB 13       0670*      rl e
040D31 7B          0671*      ld a,e
040D32 91          0672*      sub c
040D33 30 04       0673*      jr nc,$+6
040D35 1C          0674*      inc e
040D36 1C          0675*      inc e
040D37 2F          0676*      cpl
040D38 4F          0677*      ld c,a
040D39             0678*  ; Iteration 4
040D39 29          0679*      add hl,hl
040D3A CB 11       0680*      rl c
040D3C 29          0681*      add hl,hl
040D3D CB 11       0682*      rl c
040D3F CB 13       0683*      rl e
040D41 7B          0684*      ld a,e
040D42 91          0685*      sub c
040D43 30 04       0686*      jr nc,$+6
040D45 1C          0687*      inc e
040D46 1C          0688*      inc e
040D47 2F          0689*      cpl
040D48 4F          0690*      ld c,a
040D49             0691*  ; Iteration 5
040D49 29          0692*      add hl,hl
040D4A CB 11       0693*      rl c
040D4C 29          0694*      add hl,hl
040D4D CB 11       0695*      rl c
040D4F CB 13       0696*      rl e
040D51 7B          0697*      ld a,e
040D52 91          0698*      sub c
040D53 30 04       0699*      jr nc,$+6
040D55 1C          0700*      inc e
040D56 1C          0701*      inc e
040D57 2F          0702*      cpl
040D58 4F          0703*      ld c,a
040D59             0704*  ; Iteration 6
040D59 29          0705*      add hl,hl
040D5A CB 11       0706*      rl c
040D5C 29          0707*      add hl,hl
040D5D CB 11       0708*      rl c
040D5F CB 13       0709*      rl e
040D61 7B          0710*      ld a,e
040D62 91          0711*      sub c
040D63 30 04       0712*      jr nc,$+6
040D65 1C          0713*      inc e
040D66 1C          0714*      inc e
040D67 2F          0715*      cpl
040D68 4F          0716*      ld c,a
040D69             0717*  ; Iteration 7
040D69 29          0718*      add hl,hl
040D6A CB 11       0719*      rl c
040D6C 29          0720*      add hl,hl
040D6D CB 11       0721*      rl c
040D6F CB 10       0722*      rl b
040D71 EB          0723*      ex de,hl
040D72 29          0724*      add hl,hl
040D73 E5          0725*      push hl
040D74 ED 42       0726*      sbc hl,bc
040D76 30 06       0727*      jr nc,$+8
040D78 7C          0728*      ld a,h
040D79 2F          0729*      cpl
040D7A 47          0730*      ld b,a
040D7B 7D          0731*      ld a,l
040D7C 2F          0732*      cpl
040D7D 4F          0733*      ld c,a
040D7E E1          0734*      pop hl
040D7F 30 02       0735*      jr nc,$+4
040D81 23          0736*      inc hl
040D82 23          0737*      inc hl
040D83 EB          0738*      ex de,hl
040D84             0739*  ; Iteration 8
040D84 29          0740*      add hl,hl
040D85 69          0741*      ld l,c
040D86 60          0742*      ld h,b
040D87 ED 6A       0743*      adc hl,hl
040D89 ED 6A       0744*      adc hl,hl
040D8B EB          0745*      ex de,hl
040D8C 29          0746*      add hl,hl
040D8D ED 52       0747*      sbc hl,de
040D8F 19          0748*      add hl,de
040D90 EB          0749*      ex de,hl
040D91 30 04       0750*      jr nc,$+6
040D93 ED 52       0751*      sbc hl,de
040D95 13          0752*      inc de
040D96 13          0753*      inc de
040D97             0754*  ; Iteration 9
040D97 F1          0755*      pop af
040D98 17          0756*      rla
040D99 ED 6A       0757*      adc hl,hl
040D9B 17          0758*      rla
040D9C ED 6A       0759*      adc hl,hl
040D9E EB          0760*      ex de,hl
040D9F 29          0761*      add hl,hl
040DA0 ED 52       0762*      sbc hl,de
040DA2 19          0763*      add hl,de
040DA3 EB          0764*      ex de,hl
040DA4 30 04       0765*      jr nc,$+6
040DA6 ED 52       0766*      sbc hl,de
040DA8 13          0767*      inc de
040DA9 13          0768*      inc de
040DAA             0769*  ; Iteration 10
040DAA 17          0770*      rla
040DAB ED 6A       0771*      adc hl,hl
040DAD 17          0772*      rla
040DAE ED 6A       0773*      adc hl,hl
040DB0 EB          0774*      ex de,hl
040DB1 29          0775*      add hl,hl
040DB2 ED 52       0776*      sbc hl,de
040DB4 19          0777*      add hl,de
040DB5 EB          0778*      ex de,hl
040DB6 30 04       0779*      jr nc,$+6
040DB8 ED 52       0780*      sbc hl,de
040DBA 13          0781*      inc de
040DBB 13          0782*      inc de
040DBC             0783*  ; Iteration 11
040DBC 17          0784*      rla
040DBD ED 6A       0785*      adc hl,hl
040DBF 17          0786*      rla
040DC0 ED 6A       0787*      adc hl,hl
040DC2 EB          0788*      ex de,hl
040DC3 29          0789*      add hl,hl
040DC4 ED 52       0790*      sbc hl,de
040DC6 19          0791*      add hl,de
040DC7 EB          0792*      ex de,hl
040DC8 30 04       0793*      jr nc,$+6
040DCA ED 52       0794*      sbc hl,de
040DCC 13          0795*      inc de
040DCD 13          0796*      inc de
040DCE             0797*  ; Iteration 12
040DCE 17          0798*      rla
040DCF ED 6A       0799*      adc hl,hl
040DD1 17          0800*      rla
040DD2 ED 6A       0801*      adc hl,hl
040DD4 EB          0802*      ex de,hl
040DD5 29          0803*      add hl,hl
040DD6 ED 52       0804*      sbc hl,de
040DD8 19          0805*      add hl,de
040DD9 EB          0806*      ex de,hl
040DDA 30 04       0807*      jr nc,$+6
040DDC ED 52       0808*      sbc hl,de
040DDE 13          0809*      inc de
040DDF 13          0810*      inc de
040DE0 CB 1A       0811*      rr d
040DE2 CB 1B       0812*      rr e
040DE4 C9          0813*      ret
040DE5             0814*  
040DE5             0815*  sin_lut_168:
040DE5 00 00 00    0816*      dl 0x000000 ; 0.000 00, 0.000
040DE8 06 00 00    0817*      dl 0x000006 ; 1.406 01, 0.025
040DEB 0C 00 00    0818*      dl 0x00000C ; 2.813 02, 0.049
040DEE 12 00 00    0819*      dl 0x000012 ; 4.219 03, 0.074
040DF1 19 00 00    0820*      dl 0x000019 ; 5.625 04, 0.098
040DF4 1F 00 00    0821*      dl 0x00001F ; 7.031 05, 0.122
040DF7 25 00 00    0822*      dl 0x000025 ; 8.438 06, 0.147
040DFA 2B 00 00    0823*      dl 0x00002B ; 9.844 07, 0.171
040DFD 31 00 00    0824*      dl 0x000031 ; 11.250 08, 0.195
040E00 38 00 00    0825*      dl 0x000038 ; 12.656 09, 0.219
040E03 3E 00 00    0826*      dl 0x00003E ; 14.063 0A, 0.243
040E06 44 00 00    0827*      dl 0x000044 ; 15.469 0B, 0.267
040E09 4A 00 00    0828*      dl 0x00004A ; 16.875 0C, 0.290
040E0C 50 00 00    0829*      dl 0x000050 ; 18.281 0D, 0.314
040E0F 56 00 00    0830*      dl 0x000056 ; 19.688 0E, 0.337
040E12 5C 00 00    0831*      dl 0x00005C ; 21.094 0F, 0.360
040E15 61 00 00    0832*      dl 0x000061 ; 22.500 10, 0.383
040E18 67 00 00    0833*      dl 0x000067 ; 23.906 11, 0.405
040E1B 6D 00 00    0834*      dl 0x00006D ; 25.313 12, 0.428
040E1E 73 00 00    0835*      dl 0x000073 ; 26.719 13, 0.450
040E21 78 00 00    0836*      dl 0x000078 ; 28.125 14, 0.471
040E24 7E 00 00    0837*      dl 0x00007E ; 29.531 15, 0.493
040E27 83 00 00    0838*      dl 0x000083 ; 30.938 16, 0.514
040E2A 88 00 00    0839*      dl 0x000088 ; 32.344 17, 0.535
040E2D 8E 00 00    0840*      dl 0x00008E ; 33.750 18, 0.556
040E30 93 00 00    0841*      dl 0x000093 ; 35.156 19, 0.576
040E33 98 00 00    0842*      dl 0x000098 ; 36.563 1A, 0.596
040E36 9D 00 00    0843*      dl 0x00009D ; 37.969 1B, 0.615
040E39 A2 00 00    0844*      dl 0x0000A2 ; 39.375 1C, 0.634
040E3C A7 00 00    0845*      dl 0x0000A7 ; 40.781 1D, 0.653
040E3F AB 00 00    0846*      dl 0x0000AB ; 42.188 1E, 0.672
040E42 B0 00 00    0847*      dl 0x0000B0 ; 43.594 1F, 0.690
040E45 B5 00 00    0848*      dl 0x0000B5 ; 45.000 20, 0.707
040E48 B9 00 00    0849*      dl 0x0000B9 ; 46.406 21, 0.724
040E4B BD 00 00    0850*      dl 0x0000BD ; 47.813 22, 0.741
040E4E C1 00 00    0851*      dl 0x0000C1 ; 49.219 23, 0.757
040E51 C5 00 00    0852*      dl 0x0000C5 ; 50.625 24, 0.773
040E54 C9 00 00    0853*      dl 0x0000C9 ; 52.031 25, 0.788
040E57 CD 00 00    0854*      dl 0x0000CD ; 53.438 26, 0.803
040E5A D1 00 00    0855*      dl 0x0000D1 ; 54.844 27, 0.818
040E5D D4 00 00    0856*      dl 0x0000D4 ; 56.250 28, 0.831
040E60 D8 00 00    0857*      dl 0x0000D8 ; 57.656 29, 0.845
040E63 DB 00 00    0858*      dl 0x0000DB ; 59.063 2A, 0.858
040E66 DE 00 00    0859*      dl 0x0000DE ; 60.469 2B, 0.870
040E69 E1 00 00    0860*      dl 0x0000E1 ; 61.875 2C, 0.882
040E6C E4 00 00    0861*      dl 0x0000E4 ; 63.281 2D, 0.893
040E6F E7 00 00    0862*      dl 0x0000E7 ; 64.688 2E, 0.904
040E72 EA 00 00    0863*      dl 0x0000EA ; 66.094 2F, 0.914
040E75 EC 00 00    0864*      dl 0x0000EC ; 67.500 30, 0.924
040E78 EE 00 00    0865*      dl 0x0000EE ; 68.906 31, 0.933
040E7B F1 00 00    0866*      dl 0x0000F1 ; 70.313 32, 0.942
040E7E F3 00 00    0867*      dl 0x0000F3 ; 71.719 33, 0.950
040E81 F4 00 00    0868*      dl 0x0000F4 ; 73.125 34, 0.957
040E84 F6 00 00    0869*      dl 0x0000F6 ; 74.531 35, 0.964
040E87 F8 00 00    0870*      dl 0x0000F8 ; 75.938 36, 0.970
040E8A F9 00 00    0871*      dl 0x0000F9 ; 77.344 37, 0.976
040E8D FB 00 00    0872*      dl 0x0000FB ; 78.750 38, 0.981
040E90 FC 00 00    0873*      dl 0x0000FC ; 80.156 39, 0.985
040E93 FD 00 00    0874*      dl 0x0000FD ; 81.563 3A, 0.989
040E96 FE 00 00    0875*      dl 0x0000FE ; 82.969 3B, 0.992
040E99 FE 00 00    0876*      dl 0x0000FE ; 84.375 3C, 0.995
040E9C FF 00 00    0877*      dl 0x0000FF ; 85.781 3D, 0.997
040E9F FF 00 00    0878*      dl 0x0000FF ; 87.188 3E, 0.999
040EA2 FF 00 00    0879*      dl 0x0000FF ; 88.594 3F, 1.000
040EA5 00 01 00    0880*      dl 0x000100 ; 90.000 40, 1.000
040EA8 FF 00 00    0881*      dl 0x0000FF ; 91.406 41, 1.000
040EAB FF 00 00    0882*      dl 0x0000FF ; 92.813 42, 0.999
040EAE FF 00 00    0883*      dl 0x0000FF ; 94.219 43, 0.997
040EB1 FE 00 00    0884*      dl 0x0000FE ; 95.625 44, 0.995
040EB4 FE 00 00    0885*      dl 0x0000FE ; 97.031 45, 0.992
040EB7 FD 00 00    0886*      dl 0x0000FD ; 98.438 46, 0.989
040EBA FC 00 00    0887*      dl 0x0000FC ; 99.844 47, 0.985
040EBD FB 00 00    0888*      dl 0x0000FB ; 101.250 48, 0.981
040EC0 F9 00 00    0889*      dl 0x0000F9 ; 102.656 49, 0.976
040EC3 F8 00 00    0890*      dl 0x0000F8 ; 104.063 4A, 0.970
040EC6 F6 00 00    0891*      dl 0x0000F6 ; 105.469 4B, 0.964
040EC9 F4 00 00    0892*      dl 0x0000F4 ; 106.875 4C, 0.957
040ECC F3 00 00    0893*      dl 0x0000F3 ; 108.281 4D, 0.950
040ECF F1 00 00    0894*      dl 0x0000F1 ; 109.688 4E, 0.942
040ED2 EE 00 00    0895*      dl 0x0000EE ; 111.094 4F, 0.933
040ED5 EC 00 00    0896*      dl 0x0000EC ; 112.500 50, 0.924
040ED8 EA 00 00    0897*      dl 0x0000EA ; 113.906 51, 0.914
040EDB E7 00 00    0898*      dl 0x0000E7 ; 115.313 52, 0.904
040EDE E4 00 00    0899*      dl 0x0000E4 ; 116.719 53, 0.893
040EE1 E1 00 00    0900*      dl 0x0000E1 ; 118.125 54, 0.882
040EE4 DE 00 00    0901*      dl 0x0000DE ; 119.531 55, 0.870
040EE7 DB 00 00    0902*      dl 0x0000DB ; 120.938 56, 0.858
040EEA D8 00 00    0903*      dl 0x0000D8 ; 122.344 57, 0.845
040EED D4 00 00    0904*      dl 0x0000D4 ; 123.750 58, 0.831
040EF0 D1 00 00    0905*      dl 0x0000D1 ; 125.156 59, 0.818
040EF3 CD 00 00    0906*      dl 0x0000CD ; 126.563 5A, 0.803
040EF6 C9 00 00    0907*      dl 0x0000C9 ; 127.969 5B, 0.788
040EF9 C5 00 00    0908*      dl 0x0000C5 ; 129.375 5C, 0.773
040EFC C1 00 00    0909*      dl 0x0000C1 ; 130.781 5D, 0.757
040EFF BD 00 00    0910*      dl 0x0000BD ; 132.188 5E, 0.741
040F02 B9 00 00    0911*      dl 0x0000B9 ; 133.594 5F, 0.724
040F05 B5 00 00    0912*      dl 0x0000B5 ; 135.000 60, 0.707
040F08 B0 00 00    0913*      dl 0x0000B0 ; 136.406 61, 0.690
040F0B AB 00 00    0914*      dl 0x0000AB ; 137.813 62, 0.672
040F0E A7 00 00    0915*      dl 0x0000A7 ; 139.219 63, 0.653
040F11 A2 00 00    0916*      dl 0x0000A2 ; 140.625 64, 0.634
040F14 9D 00 00    0917*      dl 0x00009D ; 142.031 65, 0.615
040F17 98 00 00    0918*      dl 0x000098 ; 143.438 66, 0.596
040F1A 93 00 00    0919*      dl 0x000093 ; 144.844 67, 0.576
040F1D 8E 00 00    0920*      dl 0x00008E ; 146.250 68, 0.556
040F20 88 00 00    0921*      dl 0x000088 ; 147.656 69, 0.535
040F23 83 00 00    0922*      dl 0x000083 ; 149.063 6A, 0.514
040F26 7E 00 00    0923*      dl 0x00007E ; 150.469 6B, 0.493
040F29 78 00 00    0924*      dl 0x000078 ; 151.875 6C, 0.471
040F2C 73 00 00    0925*      dl 0x000073 ; 153.281 6D, 0.450
040F2F 6D 00 00    0926*      dl 0x00006D ; 154.688 6E, 0.428
040F32 67 00 00    0927*      dl 0x000067 ; 156.094 6F, 0.405
040F35 61 00 00    0928*      dl 0x000061 ; 157.500 70, 0.383
040F38 5C 00 00    0929*      dl 0x00005C ; 158.906 71, 0.360
040F3B 56 00 00    0930*      dl 0x000056 ; 160.313 72, 0.337
040F3E 50 00 00    0931*      dl 0x000050 ; 161.719 73, 0.314
040F41 4A 00 00    0932*      dl 0x00004A ; 163.125 74, 0.290
040F44 44 00 00    0933*      dl 0x000044 ; 164.531 75, 0.267
040F47 3E 00 00    0934*      dl 0x00003E ; 165.938 76, 0.243
040F4A 38 00 00    0935*      dl 0x000038 ; 167.344 77, 0.219
040F4D 31 00 00    0936*      dl 0x000031 ; 168.750 78, 0.195
040F50 2B 00 00    0937*      dl 0x00002B ; 170.156 79, 0.171
040F53 25 00 00    0938*      dl 0x000025 ; 171.563 7A, 0.147
040F56 1F 00 00    0939*      dl 0x00001F ; 172.969 7B, 0.122
040F59 19 00 00    0940*      dl 0x000019 ; 174.375 7C, 0.098
040F5C 12 00 00    0941*      dl 0x000012 ; 175.781 7D, 0.074
040F5F 0C 00 00    0942*      dl 0x00000C ; 177.188 7E, 0.049
040F62 06 00 00    0943*      dl 0x000006 ; 178.594 7F, 0.025
040F65 00 00 00    0944*      dl 0x000000 ; 180.000 80, 0.000
040F68 FA FF FF    0945*      dl 0xFFFFFA ; 181.406 81, -0.025
040F6B F4 FF FF    0946*      dl 0xFFFFF4 ; 182.813 82, -0.049
040F6E EE FF FF    0947*      dl 0xFFFFEE ; 184.219 83, -0.074
040F71 E7 FF FF    0948*      dl 0xFFFFE7 ; 185.625 84, -0.098
040F74 E1 FF FF    0949*      dl 0xFFFFE1 ; 187.031 85, -0.122
040F77 DB FF FF    0950*      dl 0xFFFFDB ; 188.438 86, -0.147
040F7A D5 FF FF    0951*      dl 0xFFFFD5 ; 189.844 87, -0.171
040F7D CF FF FF    0952*      dl 0xFFFFCF ; 191.250 88, -0.195
040F80 C8 FF FF    0953*      dl 0xFFFFC8 ; 192.656 89, -0.219
040F83 C2 FF FF    0954*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040F86 BC FF FF    0955*      dl 0xFFFFBC ; 195.469 8B, -0.267
040F89 B6 FF FF    0956*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040F8C B0 FF FF    0957*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040F8F AA FF FF    0958*      dl 0xFFFFAA ; 199.688 8E, -0.337
040F92 A4 FF FF    0959*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040F95 9F FF FF    0960*      dl 0xFFFF9F ; 202.500 90, -0.383
040F98 99 FF FF    0961*      dl 0xFFFF99 ; 203.906 91, -0.405
040F9B 93 FF FF    0962*      dl 0xFFFF93 ; 205.313 92, -0.428
040F9E 8D FF FF    0963*      dl 0xFFFF8D ; 206.719 93, -0.450
040FA1 88 FF FF    0964*      dl 0xFFFF88 ; 208.125 94, -0.471
040FA4 82 FF FF    0965*      dl 0xFFFF82 ; 209.531 95, -0.493
040FA7 7D FF FF    0966*      dl 0xFFFF7D ; 210.938 96, -0.514
040FAA 78 FF FF    0967*      dl 0xFFFF78 ; 212.344 97, -0.535
040FAD 72 FF FF    0968*      dl 0xFFFF72 ; 213.750 98, -0.556
040FB0 6D FF FF    0969*      dl 0xFFFF6D ; 215.156 99, -0.576
040FB3 68 FF FF    0970*      dl 0xFFFF68 ; 216.563 9A, -0.596
040FB6 63 FF FF    0971*      dl 0xFFFF63 ; 217.969 9B, -0.615
040FB9 5E FF FF    0972*      dl 0xFFFF5E ; 219.375 9C, -0.634
040FBC 59 FF FF    0973*      dl 0xFFFF59 ; 220.781 9D, -0.653
040FBF 55 FF FF    0974*      dl 0xFFFF55 ; 222.188 9E, -0.672
040FC2 50 FF FF    0975*      dl 0xFFFF50 ; 223.594 9F, -0.690
040FC5 4B FF FF    0976*      dl 0xFFFF4B ; 225.000 A0, -0.707
040FC8 47 FF FF    0977*      dl 0xFFFF47 ; 226.406 A1, -0.724
040FCB 43 FF FF    0978*      dl 0xFFFF43 ; 227.813 A2, -0.741
040FCE 3F FF FF    0979*      dl 0xFFFF3F ; 229.219 A3, -0.757
040FD1 3B FF FF    0980*      dl 0xFFFF3B ; 230.625 A4, -0.773
040FD4 37 FF FF    0981*      dl 0xFFFF37 ; 232.031 A5, -0.788
040FD7 33 FF FF    0982*      dl 0xFFFF33 ; 233.438 A6, -0.803
040FDA 2F FF FF    0983*      dl 0xFFFF2F ; 234.844 A7, -0.818
040FDD 2C FF FF    0984*      dl 0xFFFF2C ; 236.250 A8, -0.831
040FE0 28 FF FF    0985*      dl 0xFFFF28 ; 237.656 A9, -0.845
040FE3 25 FF FF    0986*      dl 0xFFFF25 ; 239.063 AA, -0.858
040FE6 22 FF FF    0987*      dl 0xFFFF22 ; 240.469 AB, -0.870
040FE9 1F FF FF    0988*      dl 0xFFFF1F ; 241.875 AC, -0.882
040FEC 1C FF FF    0989*      dl 0xFFFF1C ; 243.281 AD, -0.893
040FEF 19 FF FF    0990*      dl 0xFFFF19 ; 244.688 AE, -0.904
040FF2 16 FF FF    0991*      dl 0xFFFF16 ; 246.094 AF, -0.914
040FF5 14 FF FF    0992*      dl 0xFFFF14 ; 247.500 B0, -0.924
040FF8 12 FF FF    0993*      dl 0xFFFF12 ; 248.906 B1, -0.933
040FFB 0F FF FF    0994*      dl 0xFFFF0F ; 250.313 B2, -0.942
040FFE 0D FF FF    0995*      dl 0xFFFF0D ; 251.719 B3, -0.950
041001 0C FF FF    0996*      dl 0xFFFF0C ; 253.125 B4, -0.957
041004 0A FF FF    0997*      dl 0xFFFF0A ; 254.531 B5, -0.964
041007 08 FF FF    0998*      dl 0xFFFF08 ; 255.938 B6, -0.970
04100A 07 FF FF    0999*      dl 0xFFFF07 ; 257.344 B7, -0.976
04100D 05 FF FF    1000*      dl 0xFFFF05 ; 258.750 B8, -0.981
041010 04 FF FF    1001*      dl 0xFFFF04 ; 260.156 B9, -0.985
041013 03 FF FF    1002*      dl 0xFFFF03 ; 261.563 BA, -0.989
041016 02 FF FF    1003*      dl 0xFFFF02 ; 262.969 BB, -0.992
041019 02 FF FF    1004*      dl 0xFFFF02 ; 264.375 BC, -0.995
04101C 01 FF FF    1005*      dl 0xFFFF01 ; 265.781 BD, -0.997
04101F 01 FF FF    1006*      dl 0xFFFF01 ; 267.188 BE, -0.999
041022 01 FF FF    1007*      dl 0xFFFF01 ; 268.594 BF, -1.000
041025 00 FF FF    1008*      dl 0xFFFF00 ; 270.000 C0, -1.000
041028 01 FF FF    1009*      dl 0xFFFF01 ; 271.406 C1, -1.000
04102B 01 FF FF    1010*      dl 0xFFFF01 ; 272.813 C2, -0.999
04102E 01 FF FF    1011*      dl 0xFFFF01 ; 274.219 C3, -0.997
041031 02 FF FF    1012*      dl 0xFFFF02 ; 275.625 C4, -0.995
041034 02 FF FF    1013*      dl 0xFFFF02 ; 277.031 C5, -0.992
041037 03 FF FF    1014*      dl 0xFFFF03 ; 278.438 C6, -0.989
04103A 04 FF FF    1015*      dl 0xFFFF04 ; 279.844 C7, -0.985
04103D 05 FF FF    1016*      dl 0xFFFF05 ; 281.250 C8, -0.981
041040 07 FF FF    1017*      dl 0xFFFF07 ; 282.656 C9, -0.976
041043 08 FF FF    1018*      dl 0xFFFF08 ; 284.063 CA, -0.970
041046 0A FF FF    1019*      dl 0xFFFF0A ; 285.469 CB, -0.964
041049 0C FF FF    1020*      dl 0xFFFF0C ; 286.875 CC, -0.957
04104C 0D FF FF    1021*      dl 0xFFFF0D ; 288.281 CD, -0.950
04104F 0F FF FF    1022*      dl 0xFFFF0F ; 289.688 CE, -0.942
041052 12 FF FF    1023*      dl 0xFFFF12 ; 291.094 CF, -0.933
041055 14 FF FF    1024*      dl 0xFFFF14 ; 292.500 D0, -0.924
041058 16 FF FF    1025*      dl 0xFFFF16 ; 293.906 D1, -0.914
04105B 19 FF FF    1026*      dl 0xFFFF19 ; 295.313 D2, -0.904
04105E 1C FF FF    1027*      dl 0xFFFF1C ; 296.719 D3, -0.893
041061 1F FF FF    1028*      dl 0xFFFF1F ; 298.125 D4, -0.882
041064 22 FF FF    1029*      dl 0xFFFF22 ; 299.531 D5, -0.870
041067 25 FF FF    1030*      dl 0xFFFF25 ; 300.938 D6, -0.858
04106A 28 FF FF    1031*      dl 0xFFFF28 ; 302.344 D7, -0.845
04106D 2C FF FF    1032*      dl 0xFFFF2C ; 303.750 D8, -0.831
041070 2F FF FF    1033*      dl 0xFFFF2F ; 305.156 D9, -0.818
041073 33 FF FF    1034*      dl 0xFFFF33 ; 306.563 DA, -0.803
041076 37 FF FF    1035*      dl 0xFFFF37 ; 307.969 DB, -0.788
041079 3B FF FF    1036*      dl 0xFFFF3B ; 309.375 DC, -0.773
04107C 3F FF FF    1037*      dl 0xFFFF3F ; 310.781 DD, -0.757
04107F 43 FF FF    1038*      dl 0xFFFF43 ; 312.188 DE, -0.741
041082 47 FF FF    1039*      dl 0xFFFF47 ; 313.594 DF, -0.724
041085 4B FF FF    1040*      dl 0xFFFF4B ; 315.000 E0, -0.707
041088 50 FF FF    1041*      dl 0xFFFF50 ; 316.406 E1, -0.690
04108B 55 FF FF    1042*      dl 0xFFFF55 ; 317.813 E2, -0.672
04108E 59 FF FF    1043*      dl 0xFFFF59 ; 319.219 E3, -0.653
041091 5E FF FF    1044*      dl 0xFFFF5E ; 320.625 E4, -0.634
041094 63 FF FF    1045*      dl 0xFFFF63 ; 322.031 E5, -0.615
041097 68 FF FF    1046*      dl 0xFFFF68 ; 323.438 E6, -0.596
04109A 6D FF FF    1047*      dl 0xFFFF6D ; 324.844 E7, -0.576
04109D 72 FF FF    1048*      dl 0xFFFF72 ; 326.250 E8, -0.556
0410A0 78 FF FF    1049*      dl 0xFFFF78 ; 327.656 E9, -0.535
0410A3 7D FF FF    1050*      dl 0xFFFF7D ; 329.063 EA, -0.514
0410A6 82 FF FF    1051*      dl 0xFFFF82 ; 330.469 EB, -0.493
0410A9 88 FF FF    1052*      dl 0xFFFF88 ; 331.875 EC, -0.471
0410AC 8D FF FF    1053*      dl 0xFFFF8D ; 333.281 ED, -0.450
0410AF 93 FF FF    1054*      dl 0xFFFF93 ; 334.688 EE, -0.428
0410B2 99 FF FF    1055*      dl 0xFFFF99 ; 336.094 EF, -0.405
0410B5 9F FF FF    1056*      dl 0xFFFF9F ; 337.500 F0, -0.383
0410B8 A4 FF FF    1057*      dl 0xFFFFA4 ; 338.906 F1, -0.360
0410BB AA FF FF    1058*      dl 0xFFFFAA ; 340.313 F2, -0.337
0410BE B0 FF FF    1059*      dl 0xFFFFB0 ; 341.719 F3, -0.314
0410C1 B6 FF FF    1060*      dl 0xFFFFB6 ; 343.125 F4, -0.290
0410C4 BC FF FF    1061*      dl 0xFFFFBC ; 344.531 F5, -0.267
0410C7 C2 FF FF    1062*      dl 0xFFFFC2 ; 345.938 F6, -0.243
0410CA C8 FF FF    1063*      dl 0xFFFFC8 ; 347.344 F7, -0.219
0410CD CF FF FF    1064*      dl 0xFFFFCF ; 348.750 F8, -0.195
0410D0 D5 FF FF    1065*      dl 0xFFFFD5 ; 350.156 F9, -0.171
0410D3 DB FF FF    1066*      dl 0xFFFFDB ; 351.563 FA, -0.147
0410D6 E1 FF FF    1067*      dl 0xFFFFE1 ; 352.969 FB, -0.122
0410D9 E7 FF FF    1068*      dl 0xFFFFE7 ; 354.375 FC, -0.098
0410DC EE FF FF    1069*      dl 0xFFFFEE ; 355.781 FD, -0.074
0410DF F4 FF FF    1070*      dl 0xFFFFF4 ; 357.188 FE, -0.049
0410E2 FA FF FF    1071*      dl 0xFFFFFA ; 358.594 FF, -0.025
0410E5 00 00 00    1072*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
0410E8             1073*  
0410E8             1074*  atan_lut_168:
0410E8 00 00 00    1075*      dl 0x000000 ; 000000, 0.000
0410EB 28 00 00    1076*      dl 0x000028 ; 000001, 0.224
0410EE 51 00 00    1077*      dl 0x000051 ; 000002, 0.448
0410F1 7A 00 00    1078*      dl 0x00007A ; 000003, 0.671
0410F4 A2 00 00    1079*      dl 0x0000A2 ; 000004, 0.895
0410F7 CB 00 00    1080*      dl 0x0000CB ; 000005, 1.119
0410FA F4 00 00    1081*      dl 0x0000F4 ; 000006, 1.343
0410FD 1D 01 00    1082*      dl 0x00011D ; 000007, 1.566
041100 45 01 00    1083*      dl 0x000145 ; 000008, 1.790
041103 6E 01 00    1084*      dl 0x00016E ; 000009, 2.013
041106 97 01 00    1085*      dl 0x000197 ; 00000A, 2.237
041109 BF 01 00    1086*      dl 0x0001BF ; 00000B, 2.460
04110C E8 01 00    1087*      dl 0x0001E8 ; 00000C, 2.684
04110F 11 02 00    1088*      dl 0x000211 ; 00000D, 2.907
041112 39 02 00    1089*      dl 0x000239 ; 00000E, 3.130
041115 62 02 00    1090*      dl 0x000262 ; 00000F, 3.353
041118 8B 02 00    1091*      dl 0x00028B ; 000010, 3.576
04111B B3 02 00    1092*      dl 0x0002B3 ; 000011, 3.799
04111E DC 02 00    1093*      dl 0x0002DC ; 000012, 4.022
041121 04 03 00    1094*      dl 0x000304 ; 000013, 4.245
041124 2D 03 00    1095*      dl 0x00032D ; 000014, 4.467
041127 55 03 00    1096*      dl 0x000355 ; 000015, 4.690
04112A 7E 03 00    1097*      dl 0x00037E ; 000016, 4.912
04112D A6 03 00    1098*      dl 0x0003A6 ; 000017, 5.134
041130 CE 03 00    1099*      dl 0x0003CE ; 000018, 5.356
041133 F7 03 00    1100*      dl 0x0003F7 ; 000019, 5.578
041136 1F 04 00    1101*      dl 0x00041F ; 00001A, 5.799
041139 48 04 00    1102*      dl 0x000448 ; 00001B, 6.021
04113C 70 04 00    1103*      dl 0x000470 ; 00001C, 6.242
04113F 98 04 00    1104*      dl 0x000498 ; 00001D, 6.463
041142 C0 04 00    1105*      dl 0x0004C0 ; 00001E, 6.684
041145 E8 04 00    1106*      dl 0x0004E8 ; 00001F, 6.905
041148 11 05 00    1107*      dl 0x000511 ; 000020, 7.125
04114B 39 05 00    1108*      dl 0x000539 ; 000021, 7.345
04114E 61 05 00    1109*      dl 0x000561 ; 000022, 7.565
041151 89 05 00    1110*      dl 0x000589 ; 000023, 7.785
041154 B1 05 00    1111*      dl 0x0005B1 ; 000024, 8.005
041157 D9 05 00    1112*      dl 0x0005D9 ; 000025, 8.224
04115A 01 06 00    1113*      dl 0x000601 ; 000026, 8.443
04115D 28 06 00    1114*      dl 0x000628 ; 000027, 8.662
041160 50 06 00    1115*      dl 0x000650 ; 000028, 8.881
041163 78 06 00    1116*      dl 0x000678 ; 000029, 9.099
041166 A0 06 00    1117*      dl 0x0006A0 ; 00002A, 9.317
041169 C7 06 00    1118*      dl 0x0006C7 ; 00002B, 9.535
04116C EF 06 00    1119*      dl 0x0006EF ; 00002C, 9.752
04116F 16 07 00    1120*      dl 0x000716 ; 00002D, 9.970
041172 3E 07 00    1121*      dl 0x00073E ; 00002E, 10.187
041175 65 07 00    1122*      dl 0x000765 ; 00002F, 10.403
041178 8D 07 00    1123*      dl 0x00078D ; 000030, 10.620
04117B B4 07 00    1124*      dl 0x0007B4 ; 000031, 10.836
04117E DB 07 00    1125*      dl 0x0007DB ; 000032, 11.051
041181 03 08 00    1126*      dl 0x000803 ; 000033, 11.267
041184 2A 08 00    1127*      dl 0x00082A ; 000034, 11.482
041187 51 08 00    1128*      dl 0x000851 ; 000035, 11.697
04118A 78 08 00    1129*      dl 0x000878 ; 000036, 11.911
04118D 9F 08 00    1130*      dl 0x00089F ; 000037, 12.125
041190 C6 08 00    1131*      dl 0x0008C6 ; 000038, 12.339
041193 ED 08 00    1132*      dl 0x0008ED ; 000039, 12.553
041196 13 09 00    1133*      dl 0x000913 ; 00003A, 12.766
041199 3A 09 00    1134*      dl 0x00093A ; 00003B, 12.978
04119C 61 09 00    1135*      dl 0x000961 ; 00003C, 13.191
04119F 87 09 00    1136*      dl 0x000987 ; 00003D, 13.403
0411A2 AE 09 00    1137*      dl 0x0009AE ; 00003E, 13.614
0411A5 D4 09 00    1138*      dl 0x0009D4 ; 00003F, 13.825
0411A8 FB 09 00    1139*      dl 0x0009FB ; 000040, 14.036
0411AB 21 0A 00    1140*      dl 0x000A21 ; 000041, 14.247
0411AE 47 0A 00    1141*      dl 0x000A47 ; 000042, 14.457
0411B1 6D 0A 00    1142*      dl 0x000A6D ; 000043, 14.666
0411B4 94 0A 00    1143*      dl 0x000A94 ; 000044, 14.876
0411B7 BA 0A 00    1144*      dl 0x000ABA ; 000045, 15.085
0411BA E0 0A 00    1145*      dl 0x000AE0 ; 000046, 15.293
0411BD 05 0B 00    1146*      dl 0x000B05 ; 000047, 15.501
0411C0 2B 0B 00    1147*      dl 0x000B2B ; 000048, 15.709
0411C3 51 0B 00    1148*      dl 0x000B51 ; 000049, 15.916
0411C6 77 0B 00    1149*      dl 0x000B77 ; 00004A, 16.123
0411C9 9C 0B 00    1150*      dl 0x000B9C ; 00004B, 16.329
0411CC C2 0B 00    1151*      dl 0x000BC2 ; 00004C, 16.535
0411CF E7 0B 00    1152*      dl 0x000BE7 ; 00004D, 16.740
0411D2 0C 0C 00    1153*      dl 0x000C0C ; 00004E, 16.945
0411D5 32 0C 00    1154*      dl 0x000C32 ; 00004F, 17.150
0411D8 57 0C 00    1155*      dl 0x000C57 ; 000050, 17.354
0411DB 7C 0C 00    1156*      dl 0x000C7C ; 000051, 17.558
0411DE A1 0C 00    1157*      dl 0x000CA1 ; 000052, 17.761
0411E1 C6 0C 00    1158*      dl 0x000CC6 ; 000053, 17.964
0411E4 EB 0C 00    1159*      dl 0x000CEB ; 000054, 18.166
0411E7 0F 0D 00    1160*      dl 0x000D0F ; 000055, 18.368
0411EA 34 0D 00    1161*      dl 0x000D34 ; 000056, 18.569
0411ED 58 0D 00    1162*      dl 0x000D58 ; 000057, 18.770
0411F0 7D 0D 00    1163*      dl 0x000D7D ; 000058, 18.970
0411F3 A1 0D 00    1164*      dl 0x000DA1 ; 000059, 19.170
0411F6 C6 0D 00    1165*      dl 0x000DC6 ; 00005A, 19.370
0411F9 EA 0D 00    1166*      dl 0x000DEA ; 00005B, 19.569
0411FC 0E 0E 00    1167*      dl 0x000E0E ; 00005C, 19.767
0411FF 32 0E 00    1168*      dl 0x000E32 ; 00005D, 19.965
041202 56 0E 00    1169*      dl 0x000E56 ; 00005E, 20.163
041205 7A 0E 00    1170*      dl 0x000E7A ; 00005F, 20.360
041208 9E 0E 00    1171*      dl 0x000E9E ; 000060, 20.556
04120B C1 0E 00    1172*      dl 0x000EC1 ; 000061, 20.752
04120E E5 0E 00    1173*      dl 0x000EE5 ; 000062, 20.947
041211 08 0F 00    1174*      dl 0x000F08 ; 000063, 21.142
041214 2C 0F 00    1175*      dl 0x000F2C ; 000064, 21.337
041217 4F 0F 00    1176*      dl 0x000F4F ; 000065, 21.531
04121A 72 0F 00    1177*      dl 0x000F72 ; 000066, 21.724
04121D 95 0F 00    1178*      dl 0x000F95 ; 000067, 21.917
041220 B8 0F 00    1179*      dl 0x000FB8 ; 000068, 22.109
041223 DB 0F 00    1180*      dl 0x000FDB ; 000069, 22.301
041226 FE 0F 00    1181*      dl 0x000FFE ; 00006A, 22.493
041229 21 10 00    1182*      dl 0x001021 ; 00006B, 22.683
04122C 44 10 00    1183*      dl 0x001044 ; 00006C, 22.874
04122F 66 10 00    1184*      dl 0x001066 ; 00006D, 23.063
041232 89 10 00    1185*      dl 0x001089 ; 00006E, 23.253
041235 AB 10 00    1186*      dl 0x0010AB ; 00006F, 23.441
041238 CD 10 00    1187*      dl 0x0010CD ; 000070, 23.629
04123B EF 10 00    1188*      dl 0x0010EF ; 000071, 23.817
04123E 11 11 00    1189*      dl 0x001111 ; 000072, 24.004
041241 33 11 00    1190*      dl 0x001133 ; 000073, 24.191
041244 55 11 00    1191*      dl 0x001155 ; 000074, 24.376
041247 77 11 00    1192*      dl 0x001177 ; 000075, 24.562
04124A 99 11 00    1193*      dl 0x001199 ; 000076, 24.747
04124D BA 11 00    1194*      dl 0x0011BA ; 000077, 24.931
041250 DC 11 00    1195*      dl 0x0011DC ; 000078, 25.115
041253 FD 11 00    1196*      dl 0x0011FD ; 000079, 25.298
041256 1E 12 00    1197*      dl 0x00121E ; 00007A, 25.481
041259 3F 12 00    1198*      dl 0x00123F ; 00007B, 25.663
04125C 60 12 00    1199*      dl 0x001260 ; 00007C, 25.844
04125F 81 12 00    1200*      dl 0x001281 ; 00007D, 26.025
041262 A2 12 00    1201*      dl 0x0012A2 ; 00007E, 26.206
041265 C3 12 00    1202*      dl 0x0012C3 ; 00007F, 26.386
041268 E4 12 00    1203*      dl 0x0012E4 ; 000080, 26.565
04126B 04 13 00    1204*      dl 0x001304 ; 000081, 26.744
04126E 25 13 00    1205*      dl 0x001325 ; 000082, 26.922
041271 45 13 00    1206*      dl 0x001345 ; 000083, 27.100
041274 65 13 00    1207*      dl 0x001365 ; 000084, 27.277
041277 85 13 00    1208*      dl 0x001385 ; 000085, 27.453
04127A A5 13 00    1209*      dl 0x0013A5 ; 000086, 27.629
04127D C5 13 00    1210*      dl 0x0013C5 ; 000087, 27.805
041280 E5 13 00    1211*      dl 0x0013E5 ; 000088, 27.979
041283 05 14 00    1212*      dl 0x001405 ; 000089, 28.154
041286 24 14 00    1213*      dl 0x001424 ; 00008A, 28.327
041289 44 14 00    1214*      dl 0x001444 ; 00008B, 28.501
04128C 63 14 00    1215*      dl 0x001463 ; 00008C, 28.673
04128F 83 14 00    1216*      dl 0x001483 ; 00008D, 28.845
041292 A2 14 00    1217*      dl 0x0014A2 ; 00008E, 29.017
041295 C1 14 00    1218*      dl 0x0014C1 ; 00008F, 29.187
041298 E0 14 00    1219*      dl 0x0014E0 ; 000090, 29.358
04129B FF 14 00    1220*      dl 0x0014FF ; 000091, 29.527
04129E 1E 15 00    1221*      dl 0x00151E ; 000092, 29.697
0412A1 3C 15 00    1222*      dl 0x00153C ; 000093, 29.865
0412A4 5B 15 00    1223*      dl 0x00155B ; 000094, 30.033
0412A7 79 15 00    1224*      dl 0x001579 ; 000095, 30.201
0412AA 98 15 00    1225*      dl 0x001598 ; 000096, 30.368
0412AD B6 15 00    1226*      dl 0x0015B6 ; 000097, 30.534
0412B0 D4 15 00    1227*      dl 0x0015D4 ; 000098, 30.700
0412B3 F2 15 00    1228*      dl 0x0015F2 ; 000099, 30.865
0412B6 10 16 00    1229*      dl 0x001610 ; 00009A, 31.030
0412B9 2E 16 00    1230*      dl 0x00162E ; 00009B, 31.194
0412BC 4C 16 00    1231*      dl 0x00164C ; 00009C, 31.357
0412BF 6A 16 00    1232*      dl 0x00166A ; 00009D, 31.520
0412C2 87 16 00    1233*      dl 0x001687 ; 00009E, 31.682
0412C5 A5 16 00    1234*      dl 0x0016A5 ; 00009F, 31.844
0412C8 C2 16 00    1235*      dl 0x0016C2 ; 0000A0, 32.005
0412CB DF 16 00    1236*      dl 0x0016DF ; 0000A1, 32.166
0412CE FC 16 00    1237*      dl 0x0016FC ; 0000A2, 32.326
0412D1 19 17 00    1238*      dl 0x001719 ; 0000A3, 32.486
0412D4 36 17 00    1239*      dl 0x001736 ; 0000A4, 32.645
0412D7 53 17 00    1240*      dl 0x001753 ; 0000A5, 32.803
0412DA 70 17 00    1241*      dl 0x001770 ; 0000A6, 32.961
0412DD 8C 17 00    1242*      dl 0x00178C ; 0000A7, 33.118
0412E0 A9 17 00    1243*      dl 0x0017A9 ; 0000A8, 33.275
0412E3 C5 17 00    1244*      dl 0x0017C5 ; 0000A9, 33.431
0412E6 E2 17 00    1245*      dl 0x0017E2 ; 0000AA, 33.587
0412E9 FE 17 00    1246*      dl 0x0017FE ; 0000AB, 33.742
0412EC 1A 18 00    1247*      dl 0x00181A ; 0000AC, 33.896
0412EF 36 18 00    1248*      dl 0x001836 ; 0000AD, 34.050
0412F2 52 18 00    1249*      dl 0x001852 ; 0000AE, 34.203
0412F5 6E 18 00    1250*      dl 0x00186E ; 0000AF, 34.356
0412F8 8A 18 00    1251*      dl 0x00188A ; 0000B0, 34.509
0412FB A5 18 00    1252*      dl 0x0018A5 ; 0000B1, 34.660
0412FE C1 18 00    1253*      dl 0x0018C1 ; 0000B2, 34.811
041301 DC 18 00    1254*      dl 0x0018DC ; 0000B3, 34.962
041304 F7 18 00    1255*      dl 0x0018F7 ; 0000B4, 35.112
041307 13 19 00    1256*      dl 0x001913 ; 0000B5, 35.262
04130A 2E 19 00    1257*      dl 0x00192E ; 0000B6, 35.410
04130D 49 19 00    1258*      dl 0x001949 ; 0000B7, 35.559
041310 64 19 00    1259*      dl 0x001964 ; 0000B8, 35.707
041313 7F 19 00    1260*      dl 0x00197F ; 0000B9, 35.854
041316 99 19 00    1261*      dl 0x001999 ; 0000BA, 36.001
041319 B4 19 00    1262*      dl 0x0019B4 ; 0000BB, 36.147
04131C CE 19 00    1263*      dl 0x0019CE ; 0000BC, 36.293
04131F E9 19 00    1264*      dl 0x0019E9 ; 0000BD, 36.438
041322 03 1A 00    1265*      dl 0x001A03 ; 0000BE, 36.582
041325 1D 1A 00    1266*      dl 0x001A1D ; 0000BF, 36.726
041328 37 1A 00    1267*      dl 0x001A37 ; 0000C0, 36.870
04132B 51 1A 00    1268*      dl 0x001A51 ; 0000C1, 37.013
04132E 6B 1A 00    1269*      dl 0x001A6B ; 0000C2, 37.155
041331 85 1A 00    1270*      dl 0x001A85 ; 0000C3, 37.297
041334 9F 1A 00    1271*      dl 0x001A9F ; 0000C4, 37.439
041337 B9 1A 00    1272*      dl 0x001AB9 ; 0000C5, 37.579
04133A D2 1A 00    1273*      dl 0x001AD2 ; 0000C6, 37.720
04133D EC 1A 00    1274*      dl 0x001AEC ; 0000C7, 37.859
041340 05 1B 00    1275*      dl 0x001B05 ; 0000C8, 37.999
041343 1E 1B 00    1276*      dl 0x001B1E ; 0000C9, 38.137
041346 37 1B 00    1277*      dl 0x001B37 ; 0000CA, 38.276
041349 50 1B 00    1278*      dl 0x001B50 ; 0000CB, 38.413
04134C 69 1B 00    1279*      dl 0x001B69 ; 0000CC, 38.550
04134F 82 1B 00    1280*      dl 0x001B82 ; 0000CD, 38.687
041352 9B 1B 00    1281*      dl 0x001B9B ; 0000CE, 38.823
041355 B4 1B 00    1282*      dl 0x001BB4 ; 0000CF, 38.959
041358 CC 1B 00    1283*      dl 0x001BCC ; 0000D0, 39.094
04135B E5 1B 00    1284*      dl 0x001BE5 ; 0000D1, 39.228
04135E FD 1B 00    1285*      dl 0x001BFD ; 0000D2, 39.362
041361 16 1C 00    1286*      dl 0x001C16 ; 0000D3, 39.496
041364 2E 1C 00    1287*      dl 0x001C2E ; 0000D4, 39.629
041367 46 1C 00    1288*      dl 0x001C46 ; 0000D5, 39.762
04136A 5E 1C 00    1289*      dl 0x001C5E ; 0000D6, 39.894
04136D 76 1C 00    1290*      dl 0x001C76 ; 0000D7, 40.025
041370 8E 1C 00    1291*      dl 0x001C8E ; 0000D8, 40.156
041373 A5 1C 00    1292*      dl 0x001CA5 ; 0000D9, 40.286
041376 BD 1C 00    1293*      dl 0x001CBD ; 0000DA, 40.416
041379 D5 1C 00    1294*      dl 0x001CD5 ; 0000DB, 40.546
04137C EC 1C 00    1295*      dl 0x001CEC ; 0000DC, 40.675
04137F 04 1D 00    1296*      dl 0x001D04 ; 0000DD, 40.803
041382 1B 1D 00    1297*      dl 0x001D1B ; 0000DE, 40.931
041385 32 1D 00    1298*      dl 0x001D32 ; 0000DF, 41.059
041388 49 1D 00    1299*      dl 0x001D49 ; 0000E0, 41.186
04138B 60 1D 00    1300*      dl 0x001D60 ; 0000E1, 41.312
04138E 77 1D 00    1301*      dl 0x001D77 ; 0000E2, 41.438
041391 8E 1D 00    1302*      dl 0x001D8E ; 0000E3, 41.564
041394 A5 1D 00    1303*      dl 0x001DA5 ; 0000E4, 41.689
041397 BB 1D 00    1304*      dl 0x001DBB ; 0000E5, 41.814
04139A D2 1D 00    1305*      dl 0x001DD2 ; 0000E6, 41.938
04139D E9 1D 00    1306*      dl 0x001DE9 ; 0000E7, 42.061
0413A0 FF 1D 00    1307*      dl 0x001DFF ; 0000E8, 42.184
0413A3 15 1E 00    1308*      dl 0x001E15 ; 0000E9, 42.307
0413A6 2C 1E 00    1309*      dl 0x001E2C ; 0000EA, 42.429
0413A9 42 1E 00    1310*      dl 0x001E42 ; 0000EB, 42.551
0413AC 58 1E 00    1311*      dl 0x001E58 ; 0000EC, 42.672
0413AF 6E 1E 00    1312*      dl 0x001E6E ; 0000ED, 42.793
0413B2 84 1E 00    1313*      dl 0x001E84 ; 0000EE, 42.913
0413B5 99 1E 00    1314*      dl 0x001E99 ; 0000EF, 43.033
0413B8 AF 1E 00    1315*      dl 0x001EAF ; 0000F0, 43.152
0413BB C5 1E 00    1316*      dl 0x001EC5 ; 0000F1, 43.271
0413BE DA 1E 00    1317*      dl 0x001EDA ; 0000F2, 43.390
0413C1 F0 1E 00    1318*      dl 0x001EF0 ; 0000F3, 43.508
0413C4 05 1F 00    1319*      dl 0x001F05 ; 0000F4, 43.625
0413C7 1B 1F 00    1320*      dl 0x001F1B ; 0000F5, 43.742
0413CA 30 1F 00    1321*      dl 0x001F30 ; 0000F6, 43.859
0413CD 45 1F 00    1322*      dl 0x001F45 ; 0000F7, 43.975
0413D0 5A 1F 00    1323*      dl 0x001F5A ; 0000F8, 44.091
0413D3 6F 1F 00    1324*      dl 0x001F6F ; 0000F9, 44.206
0413D6 84 1F 00    1325*      dl 0x001F84 ; 0000FA, 44.321
0413D9 99 1F 00    1326*      dl 0x001F99 ; 0000FB, 44.435
0413DC AD 1F 00    1327*      dl 0x001FAD ; 0000FC, 44.549
0413DF C2 1F 00    1328*      dl 0x001FC2 ; 0000FD, 44.662
0413E2 D7 1F 00    1329*      dl 0x001FD7 ; 0000FE, 44.775
0413E5 EB 1F 00    1330*      dl 0x001FEB ; 0000FF, 44.888
0413E8 00 20 00    1331*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
0413EB             0034       include "images.inc"
0413EB             0001*  image_type: equ 0
0413EB             0002*  image_width: equ image_type+3
0413EB             0003*  image_height: equ image_width+3
0413EB             0004*  image_filesize: equ image_height+3
0413EB             0005*  image_filename: equ image_filesize+3
0413EB             0006*  image_bufferId: equ image_filename+3
0413EB             0007*  image_record_size: equ image_bufferId+3
0413EB             0008*  
0413EB 00 00 00    0009*  cur_image_list: dl 0
0413EE 00 00 00    0010*  cur_file_idx: dl 0
0413F1 00 00 00    0011*  cur_filename: dl 0
0413F4 00 00 00    0012*  cur_buffer_id: dl 0
0413F7             0013*  
0413F7             0014*  load_ui_images:
0413F7             0015*  ; initialize image loading variables
0413F7 21 00 00 00 0016*      ld hl,0
0413FB 22 EE 13 04 0017*      ld (cur_file_idx),hl
0413FF 21 E9 24 04 0018*      ld hl,ui_image_list
041403 22 EB 13 04 0019*      ld (cur_image_list),hl
041407             0020*  ; load images
041407 06 04       0021*      ld b,ui_num_images
041409             0022*  @loop:
041409 C5          0023*      push bc
04140A CD 68 14 04 0024*      call load_next_image
04140E C1          0025*      pop bc
04140F 10 F8       0026*      djnz @loop
041411 C9          0027*      ret
041412             0028*  
041412             0029*  load_sprite_images:
041412             0030*  ; initialize image loading variables
041412 21 00 00 00 0031*      ld hl,0
041416 22 EE 13 04 0032*      ld (cur_file_idx),hl
04141A 21 F9 14 04 0033*      ld hl,sprites_image_list
04141E 22 EB 13 04 0034*      ld (cur_image_list),hl
041422 01 5F 00 00 0035*      ld bc,sprites_num_images
041426             0036*  ; load images
041426 CD 2B 14 04 0037*      call img_load_main
04142A C9          0038*      ret
04142B             0039*  
04142B             0040*  ; inputs: bc is the number of images to load, cur_image_list set
04142B             0041*  img_load_main:
04142B AF          0042*      xor a
04142C 32 EE 13 04 0043*      ld (cur_file_idx),a
041430             0044*  
041430             0045*  img_load_main_loop:
041430             0046*  ; back up loop counter
041430 C5          0047*      push bc
041431             0048*  
041431             0049*  ; load the next image
041431 CD 68 14 04 0050*      call load_next_image
041435             0051*  
041435             0052*  ; plot the background
041435 CD 6F 3E 04 0053*      call vdu_cls
041439 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
04143D CD 5C 3F 04 0055*      call vdu_buff_select
041441 01 00 00 00 0056*      ld bc,0
041445 11 00 00 00 0057*      ld de,0
041449 CD 25 42 04 0058*      call vdu_plot_bmp
04144D             0059*  
04144D             0060*  ; ; draw the most recently loaded image
04144D             0061*  ; 	ld hl,(cur_buffer_id)
04144D             0062*  ; 	call vdu_buff_select
04144D             0063*  ; 	ld bc,0
04144D             0064*  ; 	ld de,0
04144D             0065*  ; 	call vdu_plot_bmp
04144D             0066*  
04144D             0067*  ; move logo
04144D CD C8 14 04 0068*      call move_logo
041451             0069*  
041451             0070*  ; print current filename
041451 2A F1 13 04 0071*      ld hl,(cur_filename)
041455 CD 77 00 04 0072*      call printString
041459             0073*  
041459             0074*  ; flip the framebuffer
041459             0075*      ; call vdu_flip
041459             0076*  
041459             0077*  ; decrement loop counter
041459 C1          0078*      pop bc
04145A 0B          0079*      dec bc
04145B 79          0080*      ld a,c
04145C B7          0081*      or a
04145D C2 30 14 04 0082*      jp nz,img_load_main_loop
041461 78          0083*      ld a,b
041462 B7          0084*      or a
041463 C2 30 14 04 0085*      jp nz,img_load_main_loop
041467 C9          0086*      ret
041468             0087*  
041468             0088*  load_next_image:
041468 16 12       0089*      ld d,image_record_size
04146A 3A EE 13 04 0090*      ld a,(cur_file_idx)
04146E 5F          0091*      ld e,a
04146F ED 5C       0092*      mlt de
041471 FD 2A EB 13 0093*      ld iy,(cur_image_list)
       04          
041476 FD 19       0094*      add iy,de
041478             0095*  
041478 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
04147B FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
04147E FD 17 06    0098*      ld de,(iy+image_height) ; get image height
041481 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
041484 FD 27 0F    0100*      ld hl,(iy+image_bufferId) ; get image bufferId
041487 22 F4 13 04 0101*      ld (cur_buffer_id),hl
04148B FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
04148E FD 22 F1 13 0103*      ld (cur_filename),iy
       04          
041493 CD 7A 40 04 0104*      call vdu_load_img
041497 FD 21 EE 13 0105*      ld iy,cur_file_idx
       04          
04149C FD 34 00    0106*      inc (iy)
04149F C9          0107*      ret
0414A0             0108*  
0414A0             0109*  img_load_init:
0414A0             0110*  ; initialize logo's position parameters
0414A0 21 00 00 00 0111*      ld hl,0
0414A4 22 ED 14 04 0112*      ld (logo_xvel),hl
0414A8 22 F0 14 04 0113*      ld (logo_xpos),hl
0414AC             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0414AC 21 00 E0 00 0115*      ld hl,240-16*256 ; allow space for text at bottom of screen
0414B0 22 F6 14 04 0116*      ld (logo_ypos),hl
0414B4 EB          0117*      ex de,hl
0414B5 21 00 F8 FF 0118*      ld hl,-8*256 ; 8 pixels from top of screen
0414B9 19          0119*      add hl,de ; distance for logo to travel
0414BA 11 00 A1 FF 0120*      ld de,-sprites_num_images*256
0414BE CD 03 0B 04 0121*      call sdiv168 ; ud.e = distance / num images = y velocity
0414C2 ED 53 F3 14 0122*      ld (logo_yvel),de
       04          
0414C7             0123*  ; all done
0414C7 C9          0124*      ret
0414C8             0125*  
0414C8             0126*  move_logo:
0414C8             0127*  ; activate logo bitmap
0414C8 21 03 00 00 0128*      ld hl, BUF_SPLASH_LOGO
0414CC CD 5C 3F 04 0129*      call vdu_buff_select
0414D0             0130*  ; update position based on velocity parameters
0414D0 2A F6 14 04 0131*      ld hl,(logo_ypos)
0414D4 ED 5B F3 14 0132*      ld de,(logo_yvel)
       04          
0414D9 19          0133*      add hl,de
0414DA 22 F6 14 04 0134*      ld (logo_ypos),hl
0414DE             0135*  ; draw logo
0414DE ED 4B F0 14 0136*      ld bc,(logo_xpos)
       04          
0414E3 ED 5B F6 14 0137*      ld de,(logo_ypos)
       04          
0414E8 CD 41 42 04 0138*      call vdu_plot_bmp168
0414EC C9          0139*      ret
0414ED             0140*  
0414ED 00 00 00    0141*  logo_xvel: dl 0
0414F0 00 00 00    0142*  logo_xpos: dl 0
0414F3             0143*  
0414F3 00 00 00    0144*  logo_yvel: dl 0
0414F6 00 00 00    0145*  logo_ypos: dl 0
0414F9             0035       include "images_sprites.inc"
0414F9             0001*  ; Generated by make_images.py
0414F9             0002*  
0414F9             0003*  sprites_num_images: equ 95
0414F9             0004*  
0414F9             0005*  ; buffer_ids:
0414F9             0006*  BUF_0TILE_EMPTY: equ 256
0414F9             0007*  BUF_1TILE_CROSS: equ 257
0414F9             0008*  BUF_2TILE_HORIZ: equ 258
0414F9             0009*  BUF_3TILE_VERT: equ 259
0414F9             0010*  BUF_4TILE_SQUARE: equ 260
0414F9             0011*  BUF_5TILE_CIRCLE: equ 261
0414F9             0012*  BUF_6TILE_PAD: equ 262
0414F9             0013*  BUF_7TILE_TURRET: equ 263
0414F9             0014*  BUF_CIRCLE: equ 264
0414F9             0015*  BUF_CRATER: equ 265
0414F9             0016*  BUF_EXPLOSION_A: equ 266
0414F9             0017*  BUF_EXPLOSION_B: equ 267
0414F9             0018*  BUF_EXPLOSION_C: equ 268
0414F9             0019*  BUF_EXPLOSION_D: equ 269
0414F9             0020*  BUF_EXPLOSION_E: equ 270
0414F9             0021*  BUF_FIREBALL_A: equ 271
0414F9             0022*  BUF_FIREBALL_B: equ 272
0414F9             0023*  BUF_LASER_A: equ 273
0414F9             0024*  BUF_LASER_B: equ 274
0414F9             0025*  BUF_PAD: equ 275
0414F9             0026*  BUF_SEEKER_000: equ 276
0414F9             0027*  BUF_SEEKER_008: equ 277
0414F9             0028*  BUF_SEEKER_016: equ 278
0414F9             0029*  BUF_SEEKER_024: equ 279
0414F9             0030*  BUF_SEEKER_032: equ 280
0414F9             0031*  BUF_SEEKER_040: equ 281
0414F9             0032*  BUF_SEEKER_048: equ 282
0414F9             0033*  BUF_SEEKER_056: equ 283
0414F9             0034*  BUF_SEEKER_064: equ 284
0414F9             0035*  BUF_SEEKER_072: equ 285
0414F9             0036*  BUF_SEEKER_080: equ 286
0414F9             0037*  BUF_SEEKER_088: equ 287
0414F9             0038*  BUF_SEEKER_096: equ 288
0414F9             0039*  BUF_SEEKER_104: equ 289
0414F9             0040*  BUF_SEEKER_112: equ 290
0414F9             0041*  BUF_SEEKER_120: equ 291
0414F9             0042*  BUF_SEEKER_128: equ 292
0414F9             0043*  BUF_SEEKER_136: equ 293
0414F9             0044*  BUF_SEEKER_144: equ 294
0414F9             0045*  BUF_SEEKER_152: equ 295
0414F9             0046*  BUF_SEEKER_160: equ 296
0414F9             0047*  BUF_SEEKER_168: equ 297
0414F9             0048*  BUF_SEEKER_176: equ 298
0414F9             0049*  BUF_SEEKER_184: equ 299
0414F9             0050*  BUF_SEEKER_192: equ 300
0414F9             0051*  BUF_SEEKER_200: equ 301
0414F9             0052*  BUF_SEEKER_208: equ 302
0414F9             0053*  BUF_SEEKER_216: equ 303
0414F9             0054*  BUF_SEEKER_224: equ 304
0414F9             0055*  BUF_SEEKER_232: equ 305
0414F9             0056*  BUF_SEEKER_240: equ 306
0414F9             0057*  BUF_SEEKER_248: equ 307
0414F9             0058*  BUF_SHIP_0L: equ 308
0414F9             0059*  BUF_SHIP_1C: equ 309
0414F9             0060*  BUF_SHIP_2R: equ 310
0414F9             0061*  BUF_SHIP_SMALL: equ 311
0414F9             0062*  BUF_STAR: equ 312
0414F9             0063*  BUF_STATION_BG_00: equ 313
0414F9             0064*  BUF_STATION_BG_01: equ 314
0414F9             0065*  BUF_STATION_BG_02: equ 315
0414F9             0066*  BUF_STATION_BG_03: equ 316
0414F9             0067*  BUF_STATION_BG_04: equ 317
0414F9             0068*  BUF_STATION_BG_05: equ 318
0414F9             0069*  BUF_TURRET_000: equ 319
0414F9             0070*  BUF_TURRET_008: equ 320
0414F9             0071*  BUF_TURRET_016: equ 321
0414F9             0072*  BUF_TURRET_024: equ 322
0414F9             0073*  BUF_TURRET_032: equ 323
0414F9             0074*  BUF_TURRET_040: equ 324
0414F9             0075*  BUF_TURRET_048: equ 325
0414F9             0076*  BUF_TURRET_056: equ 326
0414F9             0077*  BUF_TURRET_064: equ 327
0414F9             0078*  BUF_TURRET_072: equ 328
0414F9             0079*  BUF_TURRET_080: equ 329
0414F9             0080*  BUF_TURRET_088: equ 330
0414F9             0081*  BUF_TURRET_096: equ 331
0414F9             0082*  BUF_TURRET_104: equ 332
0414F9             0083*  BUF_TURRET_112: equ 333
0414F9             0084*  BUF_TURRET_120: equ 334
0414F9             0085*  BUF_TURRET_128: equ 335
0414F9             0086*  BUF_TURRET_136: equ 336
0414F9             0087*  BUF_TURRET_144: equ 337
0414F9             0088*  BUF_TURRET_152: equ 338
0414F9             0089*  BUF_TURRET_160: equ 339
0414F9             0090*  BUF_TURRET_168: equ 340
0414F9             0091*  BUF_TURRET_176: equ 341
0414F9             0092*  BUF_TURRET_184: equ 342
0414F9             0093*  BUF_TURRET_192: equ 343
0414F9             0094*  BUF_TURRET_200: equ 344
0414F9             0095*  BUF_TURRET_208: equ 345
0414F9             0096*  BUF_TURRET_216: equ 346
0414F9             0097*  BUF_TURRET_224: equ 347
0414F9             0098*  BUF_TURRET_232: equ 348
0414F9             0099*  BUF_TURRET_240: equ 349
0414F9             0100*  BUF_TURRET_248: equ 350
0414F9             0101*  
0414F9             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
0414F9 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       A7 1B 04 00 
       01 00       
04150B 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       C1 1B 04 01 
       01 00       
04151D 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       DB 1B 04 02 
       01 00       
04152F 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       F5 1B 04 03 
       01 00       
041541 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       0E 1C 04 04 
       01 00       
041553 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       29 1C 04 05 
       01 00       
041565 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       44 1C 04 06 
       01 00       
041577 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       5C 1C 04 07 
       01 00       
041589 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       77 1C 04 08 
       01 00       
04159B 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       8C 1C 04 09 
       01 00       
0415AD 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       A1 1C 04 0A 
       01 00       
0415BF 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       BB 1C 04 0B 
       01 00       
0415D1 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       D5 1C 04 0C 
       01 00       
0415E3 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       EF 1C 04 0D 
       01 00       
0415F5 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       09 1D 04 0E 
       01 00       
041607 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       23 1D 04 0F 
       01 00       
041619 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       3C 1D 04 10 
       01 00       
04162B 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       55 1D 04 11 
       01 00       
04163D 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       6B 1D 04 12 
       01 00       
04164F 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       81 1D 04 13 
       01 00       
041661 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       93 1D 04 14 
       01 00       
041673 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       AC 1D 04 15 
       01 00       
041685 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       C5 1D 04 16 
       01 00       
041697 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       DE 1D 04 17 
       01 00       
0416A9 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       F7 1D 04 18 
       01 00       
0416BB 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       10 1E 04 19 
       01 00       
0416CD 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       29 1E 04 1A 
       01 00       
0416DF 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       42 1E 04 1B 
       01 00       
0416F1 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       5B 1E 04 1C 
       01 00       
041703 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       74 1E 04 1D 
       01 00       
041715 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       8D 1E 04 1E 
       01 00       
041727 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       A6 1E 04 1F 
       01 00       
041739 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       BF 1E 04 20 
       01 00       
04174B 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       D8 1E 04 21 
       01 00       
04175D 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       F1 1E 04 22 
       01 00       
04176F 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       0A 1F 04 23 
       01 00       
041781 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       23 1F 04 24 
       01 00       
041793 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       3C 1F 04 25 
       01 00       
0417A5 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       55 1F 04 26 
       01 00       
0417B7 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       6E 1F 04 27 
       01 00       
0417C9 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       87 1F 04 28 
       01 00       
0417DB 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       A0 1F 04 29 
       01 00       
0417ED 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       B9 1F 04 2A 
       01 00       
0417FF 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       D2 1F 04 2B 
       01 00       
041811 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       EB 1F 04 2C 
       01 00       
041823 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       04 20 04 2D 
       01 00       
041835 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       1D 20 04 2E 
       01 00       
041847 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       36 20 04 2F 
       01 00       
041859 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       4F 20 04 30 
       01 00       
04186B 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       68 20 04 31 
       01 00       
04187D 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       81 20 04 32 
       01 00       
04188F 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       9A 20 04 33 
       01 00       
0418A1 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       B3 20 04 34 
       01 00       
0418B3 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       C9 20 04 35 
       01 00       
0418C5 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       DF 20 04 36 
       01 00       
0418D7 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       F5 20 04 37 
       01 00       
0418E9 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       0E 21 04 38 
       01 00       
0418FB 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       21 21 04 39 
       01 00       
04190D 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       3D 21 04 3A 
       01 00       
04191F 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       59 21 04 3B 
       01 00       
041931 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       75 21 04 3C 
       01 00       
041943 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       91 21 04 3D 
       01 00       
041955 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       AD 21 04 3E 
       01 00       
041967 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       C9 21 04 3F 
       01 00       
041979 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       E2 21 04 40 
       01 00       
04198B 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       FB 21 04 41 
       01 00       
04199D 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       14 22 04 42 
       01 00       
0419AF 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       2D 22 04 43 
       01 00       
0419C1 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       46 22 04 44 
       01 00       
0419D3 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       5F 22 04 45 
       01 00       
0419E5 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       78 22 04 46 
       01 00       
0419F7 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       91 22 04 47 
       01 00       
041A09 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       AA 22 04 48 
       01 00       
041A1B 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       C3 22 04 49 
       01 00       
041A2D 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       DC 22 04 4A 
       01 00       
041A3F 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       F5 22 04 4B 
       01 00       
041A51 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       0E 23 04 4C 
       01 00       
041A63 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       27 23 04 4D 
       01 00       
041A75 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       40 23 04 4E 
       01 00       
041A87 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       59 23 04 4F 
       01 00       
041A99 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       72 23 04 50 
       01 00       
041AAB 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       8B 23 04 51 
       01 00       
041ABD 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       A4 23 04 52 
       01 00       
041ACF 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       BD 23 04 53 
       01 00       
041AE1 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       D6 23 04 54 
       01 00       
041AF3 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       EF 23 04 55 
       01 00       
041B05 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       08 24 04 56 
       01 00       
041B17 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       21 24 04 57 
       01 00       
041B29 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       3A 24 04 58 
       01 00       
041B3B 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       53 24 04 59 
       01 00       
041B4D 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       6C 24 04 5A 
       01 00       
041B5F 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       85 24 04 5B 
       01 00       
041B71 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       9E 24 04 5C 
       01 00       
041B83 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       B7 24 04 5D 
       01 00       
041B95 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       D0 24 04 5E 
       01 00       
041BA7             0198*  
041BA7             0199*  ; files_list: ; filename:
041BA7 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
041BC1 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
041BDB 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
041BF5 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
041C0E 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
041C29 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
041C44 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
041C5C 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
041C77 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
041C8C 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
041CA1 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
041CBB 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
041CD5 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
041CEF 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
041D09 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
041D23 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
041D3C 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
041D55 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
041D6B 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
041D81 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
041D93 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
041DAC 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
041DC5 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
041DDE 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
041DF7 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
041E10 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
041E29 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
041E42 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
041E5B 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
041E74 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
041E8D 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
041EA6 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
041EBF 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
041ED8 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
041EF1 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
041F0A 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
041F23 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
041F3C 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
041F55 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
041F6E 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
041F87 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
041FA0 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
041FB9 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
041FD2 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
041FEB 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
042004 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04201D 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042036 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04204F 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042068 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
042081 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04209A 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0420B3 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0420C9 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0420DF 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
0420F5 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
04210E 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
042121 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
04213D 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
042159 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
042175 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
042191 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
0421AD 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
0421C9 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0421E2 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0421FB 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
042214 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
04222D 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
042246 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
04225F 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
042278 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
042291 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0422AA 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0422C3 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0422DC 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0422F5 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
04230E 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
042327 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
042340 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042359 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
042372 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
04238B 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0423A4 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0423BD 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0423D6 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0423EF 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
042408 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042421 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
04243A 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
042453 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04246C 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
042485 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04249E 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0424B7 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0424D0 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0424E9             0036       include "images_ui.inc"
0424E9             0001*  ; Generated by make_images.py
0424E9             0002*  
0424E9             0003*  ui_num_images: equ 4
0424E9             0004*  
0424E9             0005*  ; buffer_ids:
0424E9             0006*  BUF_BEZEL_L: equ 0
0424E9             0007*  BUF_BEZEL_R: equ 1
0424E9             0008*  BUF_SPLASH_BG: equ 2
0424E9             0009*  BUF_SPLASH_LOGO: equ 3
0424E9             0010*  
0424E9             0011*  ui_image_list: ; type; width; height; filename; bufferId:
0424E9 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       31 25 04 00 
       00 00       
0424FB 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       42 25 04 01 
       00 00       
04250D 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       53 25 04 02 
       00 00       
04251F 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       66 25 04 03 
       00 00       
042531             0016*  
042531             0017*  ; files_list: ; filename:
042531 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
042542 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
042553 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
042566 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
04257B             0037       include "laser.inc"
04257B             0001*  ; ##### LASER SPRITE PARAMETERS #####
04257B             0002*  ; uses the same offsets from its table base as the main sprite table:
04257B             0003*  laser_start_variables: ; label marking beginning of table
04257B 11          0004*  laser_id:               db table_max_records+1
04257C 00          0005*  laser_type:             db 0x00 ; 1 bytes currently not used
04257D 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
042580 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
042583 00          0008*  laser_collisions:       db 0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042584 00          0009*  laser_dim_x:            db 0x00 ; 1 bytes sprite width in pixels
042585 00          0010*  laser_dim_y:            db 0x00 ; 1 bytes sprite height in pixels
042586 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042589 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
04258C 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04258F 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042592 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
042595 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042598 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
04259B 00          0018*  laser_animation:        db 0x00 ; 1 bytes current sprite animation frame
04259C 00          0019*  laser_animation_timer:  db 0x00 ; 1 bytes decremented every frame, when zero, advance animation
04259D 00          0020*  laser_move_timer:       db 0x00 ; 1 bytes not currently used
04259E 00          0021*  laser_move_step:        db 0x00 ; 1 bytes not currently used
04259F 00          0022*  laser_points:           db 0x00 ; 1 bytes not currently used
0425A0 00          0023*  laser_shield_damage:    db 0x00 ; 1 bytes not currently used
0425A1             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
0425A1             0025*  
0425A1             0026*  ; laser_control:
0425A1             0027*  ; ; is laser already active?
0425A1             0028*  ;     ld a,(laser_collisions)
0425A1             0029*  ;     and %00000001 ; bit zero is lit if laser is active
0425A1             0030*  ;     jr nz,laser_move ; move laser if not zero
0425A1             0031*  ; ; otherwise check if laser fired
0425A1             0032*  ;     in a,(#82) ; keyboard
0425A1             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
0425A1             0034*  ;     ret z ; go back if laser not fired
0425A1             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
0425A1             0036*  ; ; set laser status to active (set bit 0)
0425A1             0037*  ;     ld a,%1
0425A1             0038*  ;     ld (laser_collisions),a
0425A1             0039*  ; ; initialize laser position
0425A1             0040*  ;     ld a,(player_x+1) ; we only need the integer part
0425A1             0041*  ;     ; add a,6 ; horizontal center with player sprite
0425A1             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
0425A1             0043*  ;     ld a,(player_y+1) ; we only need the integer part
0425A1             0044*  ;     add a,-6 ; set laser y a few pixels above player
0425A1             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
0425A1             0046*  ;     ; fall through to laser_move
0425A1             0047*  
0425A1             0048*  ; laser_move:
0425A1             0049*  ; ; begin setting laser to active sprite
0425A1             0050*  ;     ld hl,lasers
0425A1             0051*  ;     ld (sprite_base_bufferId),hl
0425A1             0052*  ;     ld hl,0 ; north
0425A1             0053*  ;     ld (sprite_heading),hl
0425A1             0054*  ;     xor a ; laser has no animations yet :-(
0425A1             0055*  ;     ld (sprite_animation),a
0425A1             0056*  ;     ; we set position here for the time being as a default
0425A1             0057*  ;     ; in case the laser is flagged for deletion
0425A1             0058*  ;     ; load sprite_x with laser x position (we do y further down)
0425A1             0059*  ;     ld hl,(laser_x)
0425A1             0060*  ;     ld (sprite_x),hl
0425A1             0061*  ; ; did laser just die?
0425A1             0062*  ;     ld a,(laser_collisions)
0425A1             0063*  ;     bit 1,a ; z if laser didn't just die
0425A1             0064*  ;     jr z,laser_not_dead_yet
0425A1             0065*  ; ; yes laser died
0425A1             0066*  ;     call kill_laser
0425A1             0067*  ;     ret ; done
0425A1             0068*  ; laser_not_dead_yet:
0425A1             0069*  ; ; draw it
0425A1             0070*  ; ; update laser y position
0425A1             0071*  ;     ld hl,(laser_y) ; grab laser y position
0425A1             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
0425A1             0073*  ;     add hl,de ; add y velocity to y pos
0425A1             0074*  ;     ld (sprite_y),hl ; update laser y position
0425A1             0075*  ;     ld (laser_y),hl ; update laser y position
0425A1             0076*  ; ; are we at top of screen?
0425A1             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
0425A1             0078*  ;     sub h ; no carry if above threshold
0425A1             0079*  ;     jr c,finally_draw_the_frikken_laser
0425A1             0080*  ;     ; if at top of screen,laser dies
0425A1             0081*  ;     call kill_laser
0425A1             0082*  ;     ret
0425A1             0083*  ; ; otherwise,finally draw the frikken laser
0425A1             0084*  ; finally_draw_the_frikken_laser:
0425A1             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0425A1             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0425A1             0087*  ; ; all done
0425A1             0088*  ;     ret
0425A1             0089*  
0425A1             0090*  ; kill_laser:
0425A1             0091*  ; ; update status to inactive
0425A1             0092*  ;     xor a ; zero out a
0425A1             0093*  ;     ld (laser_collisions),a
0425A1             0094*  ;     ret
0425A1             0038       include "levels.inc"
0425A1 00          0001*  tiles_level_00: db 0 ; number of rows, 0 is max of 256
0425A2 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0425B2 00 00 00 00 0003*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
0425C2 00 00 00 00 0004*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
0425D2 00 00 00 07 0005*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0425E2 00 00 00 03 0006*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
0425F2 00 00 00 03 0007*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042602 00 00 00 01 0008*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042612 00 00 00 03 0009*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
042622 00 00 00 03 0010*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
042632 01 02 02 01 0011*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042642 03 04 05 03 0012*      db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
042652 03 05 04 03 0013*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
042662 01 02 02 01 0014*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
042672 00 00 00 00 0015*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
042682 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042692 00 00 00 00 0017*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0426A2 00 00 00 00 0018*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0426B2 00 00 00 00 0019*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0426C2 00 00 00 00 0020*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0426D2 00 00 00 00 0021*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
0426E2 00 00 00 00 0022*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
0426F2 00 00 00 00 0023*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
042702 00 00 00 00 0024*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
042712 00 00 00 00 0025*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042722 00 00 00 00 0026*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
042732 00 00 00 00 0027*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042742 00 00 00 01 0028*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
042752 00 00 00 03 0029*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042762 00 00 00 03 0030*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042772 00 00 00 01 0031*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042782 00 00 00 03 0032*      db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
042792 00 00 00 03 0033*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0427A2 00 00 00 01 0034*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0427B2 00 00 00 00 0035*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0427C2 00 00 00 00 0036*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0427D2 00 00 00 00 0037*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0427E2 00 00 00 00 0038*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0427F2 00 00 00 00 0039*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042802 00 00 00 00 0040*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042812 00 00 00 00 0041*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042822 00 00 00 00 0042*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042832 00 00 00 01 0043*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042842 00 00 00 03 0044*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042852 00 00 00 03 0045*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042862 07 02 02 01 0046*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042872 03 00 00 03 0047*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042882 03 00 00 03 0048*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042892 01 02 02 01 0049*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0428A2 00 00 00 03 0050*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428B2 00 00 00 03 0051*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0428C2 00 00 00 06 0052*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
0428D2 00 00 00 00 0053*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0428E2 00 00 00 00 0054*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0428F2 00 00 00 00 0055*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
042902 00 00 00 00 0056*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042912 00 00 00 00 0057*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042922 00 00 00 01 0058*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042932 00 00 00 03 0059*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
042942 00 00 00 03 0060*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042952 00 00 00 01 0061*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042962 00 00 00 03 0062*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042972 00 00 00 03 0063*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042982 00 00 00 07 0064*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042992 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429A2 00 00 00 00 0066*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429B2 00 00 00 00 0067*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0429C2 00 00 00 00 0068*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429D2 00 00 00 00 0069*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0429E2 00 00 00 00 0070*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0429F2 00 00 00 00 0071*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
042A02 00 00 00 00 0072*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
042A12 00 00 00 00 0073*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
042A22 00 00 00 00 0074*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042A32 00 00 00 00 0075*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042A42 00 00 00 00 0076*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042A52 00 00 00 00 0077*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042A62 00 00 00 00 0078*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042A72 00 00 00 07 0079*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
042A82 00 00 00 03 0080*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042A92 00 00 00 03 0081*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042AA2 00 00 00 01 0082*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042AB2 00 00 00 03 0083*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042AC2 00 00 00 03 0084*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
042AD2 00 00 00 01 0085*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
042AE2 00 00 00 00 0086*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042AF2 00 00 00 00 0087*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042B02 00 00 00 00 0088*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042B12 00 00 00 00 0089*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
042B22 00 00 00 00 0090*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
042B32 00 00 00 00 0091*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
042B42 00 00 00 00 0092*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042B52 00 00 00 00 0093*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042B62 00 00 00 00 0094*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
042B72 00 00 00 00 0095*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
042B82 00 00 00 00 0096*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
042B92 00 00 00 01 0097*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
042BA2 00 00 00 03 0098*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042BB2 00 00 00 03 0099*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042BC2 00 00 00 01 0100*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
042BD2 01 02 02 01 0101*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042BE2 03 00 00 03 0102*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042BF2 03 00 00 03 0103*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C02 01 02 02 07 0104*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C12 03 00 00 03 0105*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C22 03 00 00 03 0106*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042C32 01 02 02 01 0107*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042C42 03 00 04 03 0108*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C52 03 04 00 03 0109*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C62 01 02 02 01 0110*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
042C72 03 00 00 03 0111*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042C82 03 00 04 03 0112*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042C92 01 02 02 01 0113*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
042CA2 00 00 00 03 0114*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042CB2 00 00 00 03 0115*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042CC2 00 00 00 01 0116*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
042CD2 00 00 00 00 0117*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
042CE2 00 00 00 00 0118*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
042CF2 00 00 00 00 0119*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042D02 00 00 00 00 0120*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D12 00 00 00 00 0121*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D22 00 00 00 00 0122*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
042D32 00 00 00 00 0123*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
042D42 00 00 00 00 0124*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
042D52 00 00 00 00 0125*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
042D62 00 00 00 00 0126*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D72 00 00 00 00 0127*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042D82 00 00 00 00 0128*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042D92 00 00 00 00 0129*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042DA2 00 00 00 00 0130*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042DB2 00 00 00 01 0131*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042DC2 00 00 00 03 0132*      db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
042DD2 00 00 00 03 0133*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
042DE2 01 02 02 07 0134*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042DF2 03 04 00 03 0135*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E02 03 05 04 03 0136*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E12 01 02 02 01 0137*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E22 03 00 00 03 0138*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E32 03 00 00 03 0139*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042E42 01 02 02 01 0140*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042E52 03 00 00 03 0141*      db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
042E62 03 00 00 03 0142*      db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
042E72 01 02 02 01 0143*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
042E82 00 00 00 03 0144*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042E92 00 00 00 03 0145*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042EA2 00 00 00 06 0146*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042EB2 00 00 00 00 0147*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
042EC2 00 00 00 00 0148*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
042ED2 00 00 00 00 0149*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
042EE2 00 00 00 00 0150*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042EF2 00 00 00 00 0151*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042F02 00 00 00 00 0152*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
042F12 00 00 00 00 0153*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
042F22 00 00 00 00 0154*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
042F32 00 00 00 00 0155*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
042F42 00 00 00 00 0156*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
042F52 00 00 00 00 0157*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
042F62 00 00 00 00 0158*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
042F72 00 00 00 00 0159*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042F82 00 00 00 00 0160*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042F92 00 00 00 00 0161*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
042FA2 00 00 00 00 0162*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
042FB2 00 00 00 00 0163*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
042FC2 00 00 00 00 0164*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
042FD2 00 00 00 00 0165*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042FE2 00 00 00 00 0166*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042FF2 00 00 00 01 0167*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
043002 00 00 00 03 0168*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
043012 00 00 00 03 0169*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
043022 00 00 00 01 0170*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
043032 01 02 02 07 0171*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043042 03 00 00 03 0172*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043052 03 00 00 03 0173*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043062 01 02 02 01 0174*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043072 03 04 04 03 0175*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043082 03 04 04 03 0176*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043092 01 02 02 01 0177*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430A2 03 00 00 03 0178*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430B2 03 00 00 03 0179*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430C2 01 02 02 01 0180*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430D2 03 00 00 03 0181*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430E2 03 00 00 03 0182*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0430F2 01 02 02 07 0183*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043102 03 00 00 03 0184*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043112 03 00 00 03 0185*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043122 01 02 02 01 0186*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043132 00 00 00 03 0187*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
043142 00 00 00 03 0188*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
043152 00 00 00 01 0189*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043162 00 00 00 03 0190*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043172 00 00 00 03 0191*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043182 00 00 00 01 0192*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
043192 00 00 00 03 0193*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431A2 00 00 00 03 0194*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431B2 00 00 00 01 0195*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0431C2 00 00 00 03 0196*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
0431D2 00 00 00 03 0197*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
0431E2 00 00 00 01 0198*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0431F2 00 00 00 03 0199*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043202 00 00 00 03 0200*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043212 00 00 00 07 0201*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043222 00 00 00 03 0202*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043232 00 00 00 03 0203*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043242 00 00 00 01 0204*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043252 00 00 00 00 0205*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
043262 00 00 00 00 0206*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
043272 00 00 00 00 0207*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
043282 00 00 00 00 0208*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043292 00 00 00 00 0209*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0432A2 00 00 00 00 0210*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0432B2 00 00 00 00 0211*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
0432C2 00 00 00 00 0212*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
0432D2 00 00 00 00 0213*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
0432E2 00 00 00 00 0214*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
0432F2 00 00 00 00 0215*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
043302 00 00 00 00 0216*      db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
043312 00 00 00 00 0217*      db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
043322 00 00 00 01 0218*      db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
043332 00 00 01 05 0219*      db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
043342 01 02 02 07 0220*      db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
043352 03 00 00 03 0221*      db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
043362 03 00 00 03 0222*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043372 01 02 02 01 0223*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043382 03 00 00 03 0224*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043392 03 00 00 03 0225*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433A2 01 02 02 01 0226*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0433B2 00 00 00 03 0227*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433C2 00 00 00 03 0228*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0433D2 00 00 00 01 0229*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0433E2 00 00 00 03 0230*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0433F2 00 00 00 03 0231*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043402 00 00 00 01 0232*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
043412 00 00 00 03 0233*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043422 00 00 00 03 0234*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043432 01 02 02 01 0235*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
043442 03 00 00 03 0236*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043452 03 00 00 03 0237*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043462 07 02 02 01 0238*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043472 00 00 00 03 0239*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043482 00 00 00 03 0240*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043492 00 00 00 01 0241*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0434A2 00 00 00 03 0242*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434B2 00 00 00 03 0243*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434C2 00 00 00 01 0244*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
0434D2 00 00 00 00 0245*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434E2 00 00 00 00 0246*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0434F2 00 00 00 00 0247*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
043502 00 00 00 00 0248*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
043512 00 00 00 00 0249*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
043522 00 00 00 01 0250*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
043532 00 00 00 03 0251*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043542 00 00 00 03 0252*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043552 01 02 02 07 0253*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
043562 03 05 05 03 0254*      db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
043572 03 04 04 03 0255*      db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
043582 01 02 02 06 0256*      db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
043592 00 00 00 00 0257*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435A2             0258*  
0435A2             0259*  
0435A2 10          0260*  tiles_level_01: db 16 ; number of rows, 0 is max of 256
0435A3 00 00 00 00 0261*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435B3 00 00 00 00 0262*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435C3 00 00 00 00 0263*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435D3 00 00 00 00 0264*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435E3 00 00 00 00 0265*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435F3 00 00 00 00 0266*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043603 00 00 00 00 0267*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043613 00 00 00 00 0268*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043623 00 00 00 00 0269*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043633 00 00 00 00 0270*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043643 00 00 00 00 0271*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043653 00 00 00 00 0272*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043663 00 00 00 00 0273*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043673 00 00 00 00 0274*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043683 00 00 00 00 0275*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043693 00 00 00 00 0276*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0436A3             0277*  
0436A3             0039       include "player.inc"
0436A3             0001*  ; ######## GAME STATE VARIABLES #######
0436A3             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
0436A3 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
0436A6             0004*  ; player current shields,binary
0436A6             0005*  ; when < 0 player splodes
0436A6             0006*  ; restores to player_max_shields when new ship spawns
0436A6 10          0007*  player_shields: db 16 ; binary
0436A7             0008*  ; max player shields,binary
0436A7             0009*  ; can increase with power-ups (todo)
0436A7 10          0010*  player_max_shields: db 16 ; binary
0436A8             0011*  ; when reaches zero,game ends
0436A8             0012*  ; can increase based on TODO
0436A8 03          0013*  player_ships: db 0x03 ; binary
0436A9             0014*  
0436A9             0015*  speed_player: equ 0x000300 ; 3 pixels per frame
0436A9             0016*  
0436A9             0017*  ; ######### PLAYER SPRITE PARAMETERS ##########
0436A9             0018*  ; uses the same offsets from its table base as the main sprite table:
0436A9             0019*  player_start_variables: ; label marking beginning of table
0436A9 10          0020*  player_id:               db table_max_records
0436AA 00          0021*  player_type:             db     0x00 ; 1 bytes currently not used
0436AB 34 01 00    0022*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
0436AE 00 00 00    0023*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0436B1 00          0024*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0436B2 00          0025*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0436B3 00          0026*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0436B4 00 00 00    0027*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0436B7 00 00 00    0028*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0436BA 00 00 00    0029*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0436BD 00 00 00    0030*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0436C0 00 00 00    0031*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0436C3 00 00 00    0032*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0436C6 00 00 00    0033*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
0436C9 00          0034*  player_animation:        db     0x00 ; 1 bytes not currently used
0436CA 00          0035*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
0436CB 00          0036*  player_move_timer:       db     0x00 ; 1 bytes not currently used
0436CC 00          0037*  player_move_step:        db     0x00 ; 1 bytes not currently used
0436CD 00          0038*  player_points:           db     0x00 ; 1 bytes not currently used
0436CE 00          0039*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
0436CF             0040*  player_end_variables: ; for when we want to traverse this table in reverse
0436CF             0041*  
0436CF             0042*  ; set initial player position
0436CF             0043*  ; inputs: none,everything is hardcoded
0436CF             0044*  ; outputs: player_x/y set to bottom-left corner of screen
0436CF             0045*  ; destroys: a
0436CF             0046*  player_init:
0436CF 3A A9 36 04 0047*  	ld a,(player_id)
0436D3 CD C6 42 04 0048*  	call vdu_sprite_select
0436D7 CD D9 42 04 0049*      call vdu_sprite_clear_frames
0436DB 21 34 01 00 0050*      ld hl,BUF_SHIP_0L
0436DF CD 1B 44 04 0051*      call vdu_sprite_add_buff
0436E3 21 35 01 00 0052*      ld hl,BUF_SHIP_1C
0436E7 CD 1B 44 04 0053*      call vdu_sprite_add_buff
0436EB 21 36 01 00 0054*      ld hl,BUF_SHIP_2R
0436EF CD 1B 44 04 0055*      call vdu_sprite_add_buff
0436F3 01 00 00 00 0056*      ld bc,0
0436F7 ED 43 B4 36 0057*      ld (player_x),bc
       04          
0436FC 11 00 6F 01 0058*      ld de,sprite_bottom*256 ; max sprite y-coordinate
043700 ED 53 B7 36 0059*      ld (player_y),de
       04          
043705 CD 92 43 04 0060*      call vdu_sprite_move_abs168
043709 CD 3C 43 04 0061*      call vdu_sprite_show
04370D C9          0062*      ret
04370E             0063*  
04370E             0064*  ; process player keyboard input, set player bitmap
04370E             0065*  ; velocities and draw player bitmap at updated coordinates
04370E             0066*  ; Inputs: player_x/y set at desired position
04370E             0067*  ; Returns: player bitmap drawn at updated position
04370E             0068*  ; Destroys: probably everything except maybe iy
04370E             0069*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04370E             0070*  ; TODO: requires sprite implementation
04370E             0071*  player_input:
04370E             0072*  ; reset player component velocities to zero as the default
04370E 21 00 00 00 0073*  	ld hl,0
043712 22 BA 36 04 0074*  	ld (player_xvel),hl
043716 22 BD 36 04 0075*  	ld (player_yvel),hl
04371A             0076*  ; make ship the active sprite
04371A 3A A9 36 04 0077*      ld a,(player_id)
04371E CD C6 42 04 0078*      call vdu_sprite_select
043722             0079*  ; check for keypresses and branch accordingly
043722             0080*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043722             0081*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043722 3E 1E       0001*M 			LD	A, function
043724 5B CF       0002*M 			RST.LIL	08h
043726             0082*  ; we test all four arrow keys and add/subract velocities accordingly
043726             0083*  ; this handles the case where two opposing movement keys
043726             0084*  ; are down simultaneously (velocities will net to zero)
043726             0085*  ; and allows diagonal movement when a vertical and horizontal key are down
043726             0086*  ; it also allows movement and action keys to be detected simultaneously
043726             0087*  ; so we can walk and chew gum at the same time
043726 3E 01       0088*      ld a,1 ; set ship's default animation to center
043728             0089*          ; if left and right are both down a will net to
043728             0090*  
043728             0091*  @left:
043728 DD CB 03 4E 0092*      bit 1,(ix+3) ; keycode 26
04372C 28 0E       0093*      jr z,@right
04372E 2A BA 36 04 0094*      ld hl,(player_xvel)
043732 01 00 FD FF 0095*      ld bc,-speed_player
043736 09          0096*      add hl,bc
043737 22 BA 36 04 0097*      ld (player_xvel),hl
04373B 3D          0098*      dec a ; set ship's animation to left
04373C             0099*  @right:
04373C DD CB 0F 4E 0100*      bit 1,(ix+15) ; keycode 122
043740 28 0E       0101*  	jr z,@up
043742 2A BA 36 04 0102*      ld hl,(player_xvel)
043746 01 00 03 00 0103*      ld bc,speed_player
04374A 09          0104*      add hl,bc
04374B 22 BA 36 04 0105*      ld (player_xvel),hl
04374F 3C          0106*      inc a ; set ship's animation to right
043750             0107*  @up:
043750 DD CB 07 4E 0108*      bit 1,(ix+7) ; keycode 58
043754 28 0D       0109*  	jr z,@down
043756 2A BD 36 04 0110*      ld hl,(player_yvel)
04375A 01 00 FD FF 0111*      ld bc,-speed_player
04375E 09          0112*      add hl,bc
04375F 22 BD 36 04 0113*      ld (player_yvel),hl
043763             0114*  @down:
043763 DD CB 05 4E 0115*      bit 1,(ix+5) ; keycode 42
043767 28 0D       0116*  	jr z,@done_keyboard
043769 2A BD 36 04 0117*      ld hl,(player_yvel)
04376D 01 00 03 00 0118*      ld bc,speed_player
043771 09          0119*      add hl,bc
043772 22 BD 36 04 0120*      ld (player_yvel),hl
043776             0121*  @done_keyboard:
043776             0122*  ; a should land here loaded with the correct frame
043776 CD 29 43 04 0123*      call vdu_sprite_select_frame
04377A             0124*  ; draw player at updated position
04377A FD 21 A9 36 0125*      ld iy,player_start_variables
       04          
04377F FD 22 F7 39 0126*      ld (table_pointer),iy
       04          
043784 CD AB 3A 04 0127*      call move_sprite
043788 ED 4B B4 36 0128*      ld bc,(player_x)
       04          
04378D ED 5B B7 36 0129*      ld de,(player_y)
       04          
043792 CD 92 43 04 0130*  	call vdu_sprite_move_abs168
043796             0131*  ; end player_input
043796 C9          0132*  	ret
043797             0133*  
043797             0134*  ; ###################################################################
043797             0135*  ; TODO: the below is all stuff from the original code we need to port
043797             0136*  ; ###################################################################
043797             0137*  
043797             0138*  ; kill_player:
043797             0139*  ; ; set player status to dead
043797             0140*  ;     xor a; sets all player flags to zero
043797             0141*  ;     ld (player_collisions),a
043797             0142*  ; ; deduct a ship from the inventory
043797             0143*  ;     ld a,(player_ships)
043797             0144*  ;     dec a
043797             0145*  ;     ld (player_ships),a
043797             0146*  ; ; are we out of ships?
043797             0147*  ;     jp z,game_over
043797             0148*  ; ; wait a few ticks
043797             0149*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
043797             0150*  ;     ld (player_move_timer),a
043797             0151*  ; kill_player_loop:
043797             0152*  ;     call vdu_vblank
043797             0153*  ;     ld a,(player_move_timer)
043797             0154*  ;     dec a
043797             0155*  ;     ld (player_move_timer),a
043797             0156*  ;     jr nz,kill_player_loop
043797             0157*  ;     call player_init ; player respawn if timer zero
043797             0158*  ;     ret ; and out
043797             0159*  
043797             0160*  
043797             0161*  ; player_move:
043797             0162*  ; ; begin setting player to active sprite
043797             0163*  ;     ld hl,player
043797             0164*  ;     ld (sprite_base_bufferId),hl
043797             0165*  ;     ld hl,0 ; north
043797             0166*  ;     ld (sprite_heading),hl
043797             0167*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
043797             0168*  ;     ld (sprite_animation),a
043797             0169*  ;     ; we set position here for the time being as a default
043797             0170*  ;     ; in case the player doesn't move,or is flagged for deletion
043797             0171*  ;     ld hl,(player_x)
043797             0172*  ;     ld (sprite_x),hl
043797             0173*  ;     ld hl,(player_y)
043797             0174*  ;     ld (sprite_y),hl
043797             0175*  ; ; did we just die?
043797             0176*  ;     ld a,(player_collisions)
043797             0177*  ;     and %00000010 ; zero flag will be set if not dead
043797             0178*  ;     jr z,player_not_dead
043797             0179*  ; ; yes we died
043797             0180*  ;     call kill_player
043797             0181*  ;     ret ; done
043797             0182*  ; ; yay we didn't die
043797             0183*  ; player_not_dead:
043797             0184*  ; ; set player movements to zero by default
043797             0185*  ;     ld hl,0
043797             0186*  ;     ld (player_xvel),hl
043797             0187*  ;     ld (player_yvel),hl
043797             0188*  ; ; do we move it?
043797             0189*  ;     in a,(#82) ; keyboard
043797             0190*  ;     or a ; if zero,don't move
043797             0191*  ;     jr z,player_draw
043797             0192*  ; ; move it
043797             0193*  ;     call player_move_calc
043797             0194*  ; player_draw:
043797             0195*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043797             0196*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043797             0197*  ; player_move_done:
043797             0198*  ;     ; write updated x,y coordinates back to player table
043797             0199*  ;     ld hl,(sprite_x)
043797             0200*  ;     ld (player_x),hl
043797             0201*  ;     ld hl,(sprite_y)
043797             0202*  ;     ld (player_y),hl
043797             0203*  ;     ret
043797             0040       include "sprites.inc"
043797             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
043797             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
043797             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
043797             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
043797             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
043797             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
043797             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
043797             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
043797             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
043797             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
043797             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
043797             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043797             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043797             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
043797             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
043797             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
043797             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
043797             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
043797             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
043797             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
043797             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
043797             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
043797             0023*  
043797             0024*  ; ###### SPRITE TABLE VARIABLES ######
043797             0025*  ; maximum number of sprites
043797             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
043797             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
043797             0028*  
043797             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
043797             0030*  table_base:
043797 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439F7             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0439F7             0033*  
0439F7             0034*  ; pointer to top address of current record, initialized to table_base
0439F7 97 37 04    0035*  table_pointer: dl table_base
0439FA             0036*  ; how many active sprites
0439FA 00          0037*  table_active_sprites: db 0x00
0439FB             0038*  ; flag indicating collision with screen edge
0439FB             0039*  ; uses orientation codes to specify which edge(s)
0439FB 00          0040*  sprite_screen_edge: db #00
0439FC             0041*  ; next sprite id to use
0439FC 00          0042*  sprite_next_id: db 0
0439FD             0043*  
0439FD             0044*  ; origin_top: equ 48
0439FD             0045*  origin_top: equ 0 ; DEBUG
0439FD             0046*  origin_left: equ 128
0439FD             0047*  field_top: equ 0
0439FD             0048*  field_bottom: equ 383-origin_top
0439FD             0049*  field_left: equ 0
0439FD             0050*  field_right: equ 255
0439FD             0051*  sprite_top: equ 0
0439FD             0052*  sprite_bottom: equ field_bottom-16
0439FD             0053*  sprite_left: equ field_left
0439FD             0054*  sprite_right: equ field_right-16
0439FD             0055*  collide_top: equ %00001000
0439FD             0056*  collide_bottom: equ %00000100
0439FD             0057*  collide_left: equ %00000010
0439FD             0058*  collide_right: equ %00000001
0439FD             0059*  
0439FD             0060*  ; ######### COLLISION SPRITE PARAMETERS ##########
0439FD             0061*  ; integer coordinates are all that are needed for collision calculations
0439FD 00          0062*  collision_x: db 0x00
0439FE 00          0063*  collision_y: db 0x00
0439FF 00          0064*  collision_dim_x: db 0x00
043A00 00          0065*  collision_dim_y: db 0x00
043A01             0066*  
043A01             0067*  ; scratch variables
043A01 00          0068*  x: db 0x00 ; 8-bit signed integer
043A02 00          0069*  y: db 0x00 ; 8-bit signed integer
043A03 00 00 00    0070*  x0: dl 0x000000 ; 16.8 signed fixed place
043A06 00 00 00    0071*  y0: dl 0x000000 ; 16.8 signed fixed place
043A09 00 00 00    0072*  incx1: dl 0x000000 ; 16.8 signed fixed place
043A0C 00 00 00    0073*  incy1: dl 0x000000 ; 16.8 signed fixed place
043A0F 00 00 00    0074*  incx2: dl 0x000000 ; 16.8 signed fixed place
043A12 00 00 00    0075*  incy2: dl 0x000000 ; 16.8 signed fixed place
043A15             0076*  
043A15             0077*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
043A15 00 00 00    0078*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
043A18 00 00 00    0079*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
043A1B 00 00 00    0080*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
043A1E             0081*  
043A1E             0082*  ; gets the next available sprite id
043A1E             0083*  ; inputs; none
043A1E             0084*  ; returns: if new sprite available, a = sprite id,
043A1E             0085*  ;           ix pointing to new sprite vars, carry set
043A1E             0086*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
043A1E             0087*  ; destroys: a,b,hl,ix
043A1E             0088*  ; affects: bumps table_active_sprites by one
043A1E             0089*  table_get_next_id:
043A1E DD 21 97 37 0090*      ld ix,table_base
       04          
043A23 11 26 00 00 0091*      ld de,table_bytes_per_record
043A27 06 10       0092*      ld b,table_max_records
043A29             0093*  @loop:
043A29 DD 7E 01    0094*      ld a,(ix+sprite_type)
043A2C A7          0095*      and a
043A2D 28 06       0096*      jr z,@found
043A2F DD 19       0097*      add ix,de
043A31 10 F6       0098*      djnz @loop
043A33             0099*  @notfound:
043A33 AF          0100*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
043A34 C9          0101*      ret
043A35             0102*  @found:
043A35             0103*  ; bump number of active sprites
043A35 21 FA 39 04 0104*      ld hl,table_active_sprites
043A39 34          0105*      inc (hl)
043A3A             0106*  ; return sprite id
043A3A 3E 10       0107*      ld a,table_max_records
043A3C 90          0108*      sub b
043A3D 32 FC 39 04 0109*      ld (sprite_next_id),a
043A41 37          0110*      scf ; sets carry flag indicating we found a free sprite
043A42 C9          0111*      ret ; done
043A43             0112*  
043A43             0113*  ; deactivate the sprite with the given id
043A43             0114*  ; inputs: a = sprite id
043A43             0115*  ; outputs: nothing
043A43             0116*  ; destroys: a,ix,de
043A43             0117*  ; affects: decrements table_active_sprites by one
043A43             0118*  table_deactivate_sprite:
043A43 F5          0119*      push af ; save sprite id bc we need it later
043A44 CD C6 42 04 0120*      call vdu_sprite_select
043A48 CD 4A 43 04 0121*      call vdu_sprite_hide
043A4C F1          0122*      pop af ; restore sprite id
043A4D 11 00 00 00 0123*      ld de,0 ; clear deu
043A51 57          0124*      ld d,a
043A52 1E 26       0125*      ld e,table_bytes_per_record
043A54 ED 5C       0126*      mlt de
043A56 DD 21 97 37 0127*      ld ix,table_base
       04          
043A5B DD 19       0128*      add ix,de
043A5D AF          0129*      xor a
043A5E DD 77 01    0130*      ld (ix+sprite_type),a
043A61 DD 21 FA 39 0131*      ld ix,table_active_sprites
       04          
043A66 DD 35 00    0132*      dec (ix)
043A69 C9          0133*      ret
043A6A             0134*  
043A6A             0135*  sprites_init:
043A6A             0136*  ; initialize sprites
043A6A CD FA 43 04 0137*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
043A6E AF          0138*  	xor a
043A6F             0139*  @sprite_loop:
043A6F F5          0140*  	push af
043A70 CD C6 42 04 0141*  	call vdu_sprite_select
043A74 21 00 01 00 0142*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
043A78 CD 1B 44 04 0143*  	call vdu_sprite_add_buff
043A7C F1          0144*  	pop af
043A7D 3C          0145*  	inc a
043A7E FE 12       0146*  	cp table_max_records+2 ; tack on sprites for player and laser
043A80 20 ED       0147*  	jr nz,@sprite_loop
043A82 3C          0148*  	inc a
043A83 CD FA 42 04 0149*  	call vdu_sprite_activate
043A87             0150*  
043A87             0151*  ; define player sprite
043A87 3A A9 36 04 0152*  	ld a,(player_id)
043A8B CD C6 42 04 0153*  	call vdu_sprite_select
043A8F CD D9 42 04 0154*  	call vdu_sprite_clear_frames
043A93 21 34 01 00 0155*  	ld hl,BUF_SHIP_0L
043A97 01 03 00 00 0156*  	ld bc,3 ; three bitmaps for player ship
043A9B             0157*  @sprite_player_loop:
043A9B C5          0158*  	push bc
043A9C E5          0159*  	push hl
043A9D CD 1B 44 04 0160*  	call vdu_sprite_add_buff
043AA1 E1          0161*  	pop hl
043AA2 23          0162*  	inc hl
043AA3 C1          0163*  	pop bc
043AA4 10 F5       0164*  	djnz @sprite_player_loop
043AA6 CD 3C 43 04 0165*  	call vdu_sprite_show
043AAA             0166*  
043AAA             0167*  ; all done
043AAA C9          0168*      ret
043AAB             0169*  
043AAB             0170*  ; compute a sprite's new position based on its component x,y velocities
043AAB             0171*  ; with screen boundary checking and update its sprite table record accordingly
043AAB             0172*  ; inputs: iy pointing to sprite table record
043AAB             0173*  move_sprite:
043AAB FD 2A F7 39 0174*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043AB0             0175*  ; x-axis movement
043AB0 FD 27 0B    0176*      ld hl,(iy+sprite_x)
043AB3 FD 17 11    0177*      ld de,(iy+sprite_xvel)
043AB6 19          0178*      add hl,de
043AB7 FD 2F 0B    0179*      ld (iy+sprite_x),hl
043ABA             0180*  ; y-axis movement
043ABA FD 27 0E    0181*      ld hl,(iy+sprite_y)
043ABD FD 17 14    0182*      ld de,(iy+sprite_yvel)
043AC0 19          0183*      add hl,de
043AC1 FD 2F 0E    0184*      ld (iy+sprite_y),hl
043AC4             0185*  ; detect screen edge collisions
043AC4 AF          0186*      xor a ; reset screen edge collision flag and clear carry
043AC5 32 FB 39 04 0187*      ld (sprite_screen_edge),a
043AC9             0188*  ; y-axis first since we already have it in hl
043AC9 11 00 00 00 0189*      ld de,-sprite_top*256
043ACD ED 5A       0190*      adc hl,de
043ACF FA F9 3A 04 0191*      jp m,@top
043AD3 ED 52       0192*      sbc hl,de ; hl back to original value
043AD5 11 00 91 FE 0193*      ld de,-sprite_bottom*256
043AD9 ED 5A       0194*      adc hl,de
043ADB F2 03 3B 04 0195*      jp p,@bottom
043ADF             0196*  @xaxis:
043ADF FD 27 0B    0197*      ld hl,(iy+sprite_x)
043AE2 11 00 00 00 0198*      ld de,-sprite_left*256
043AE6 ED 5A       0199*      adc hl,de
043AE8 FA 1E 3B 04 0200*      jp m,@left
043AEC ED 52       0201*      sbc hl,de ; hl back to original value
043AEE 11 00 11 FF 0202*      ld de,-sprite_right*256
043AF2 ED 5A       0203*      adc hl,de
043AF4 F2 2C 3B 04 0204*      jp p,@right
043AF8             0205*  ; no edge collisions so go home
043AF8 C9          0206*      ret
043AF9             0207*  @top:
043AF9 3E 08       0208*      ld a,collide_top
043AFB 21 00 00 00 0209*      ld hl,sprite_top*256
043AFF C3 09 3B 04 0210*      jp @collide_y
043B03             0211*  @bottom:
043B03 3E 04       0212*      ld a,collide_bottom
043B05 21 00 6F 01 0213*      ld hl,sprite_bottom*256
043B09             0214*  @collide_y:
043B09 32 FB 39 04 0215*      ld (sprite_screen_edge),a
043B0D FD 2F 0E    0216*      ld (iy+sprite_y),hl
043B10             0217*  ; reverse y-axis velocity
043B10 FD 27 14    0218*      ld hl,(iy+sprite_yvel)
043B13 CD A4 06 04 0219*      call neg_hlu
043B17 FD 2F 14    0220*      ld (iy+sprite_yvel),hl
043B1A             0221*  ; go check for x-axis collisions
043B1A C3 DF 3A 04 0222*      jp @xaxis
043B1E             0223*  @left:
043B1E 3A FB 39 04 0224*      ld a,(sprite_screen_edge)
043B22 F6 02       0225*      or a,collide_left
043B24 21 00 00 00 0226*      ld hl,sprite_left*256
043B28 C3 36 3B 04 0227*      jp @collide_x
043B2C             0228*  @right:
043B2C 3A FB 39 04 0229*      ld a,(sprite_screen_edge)
043B30 F6 01       0230*      or a,collide_right
043B32 21 00 EF 00 0231*      ld hl,sprite_right*256
043B36             0232*  @collide_x:
043B36 32 FB 39 04 0233*      ld (sprite_screen_edge),a
043B3A FD 2F 0B    0234*      ld (iy+sprite_x),hl
043B3D             0235*  ; reverse x-axis velocity
043B3D FD 27 11    0236*      ld hl,(iy+sprite_xvel)
043B40 CD A4 06 04 0237*      call neg_hlu
043B44 FD 2F 11    0238*      ld (iy+sprite_xvel),hl
043B47             0239*  ; final collision flag to a and return
043B47 3A FB 39 04 0240*      ld a,(sprite_screen_edge)
043B4B C9          0241*      ret
043B4C             0041       include "tiles.inc"
043B4C             0001*  ; ######### TILES #########
043B4C             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
043B4C             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
043B4C 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
043B4F 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
043B50             0006*      ; initialize to zero for a maximum of 256 rows in a level
043B50 00          0007*  cur_level: db 0
043B51             0008*  num_levels: equ 2 ; number of levels,duh
043B51             0009*  
043B51             0010*  ; lookup table for level definitions
043B51 A1 25 04 A2 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       35 04       
043B57             0012*  
043B57             0013*  ; tiles_bufferId: dl 0
043B57 00 00 00    0014*  tiles_x_plot: dl 0
043B5A F1 FF FF    0015*  tiles_y_plot: dl -15
043B5D             0016*  
043B5D FF FF FF    0017*  bg_y_plot: dl -1
043B60 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
043B63             0019*  
043B63             0020*  bg_plot:
043B63             0021*  ; load current bg tile bufferId as default
043B63 2A 60 3B 04 0022*      ld hl,(bg_bufferId)
043B67             0023*  ; check whether it is time for a new background tile
043B67 3A 5D 3B 04 0024*      ld a,(bg_y_plot)
043B6B 3C          0025*      inc a
043B6C 32 5D 3B 04 0026*      ld (bg_y_plot),a
043B70 C2 88 3B 04 0027*      jp nz,@F ; not time for a new tile so draw current one
043B74             0028*  ; load the next background tile
043B74 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
043B78 CD 49 07 04 0030*      call rand_8
043B7C E6 03       0031*      and %0000011
043B7E 85          0032*      add a,l
043B7F 6F          0033*      ld l,a
043B80 3E 00       0034*      ld a,0
043B82 8C          0035*      adc a,h
043B83 67          0036*      ld h,a
043B84 22 60 3B 04 0037*      ld (bg_bufferId),hl
043B88             0038*  @@:
043B88 CD 5C 3F 04 0039*      call vdu_buff_select
043B8C 01 00 00 00 0040*      ld bc,0
043B90 ED 5B 5D 3B 0041*      ld de,(bg_y_plot)
       04          
043B95 13          0042*      inc de
043B96 CD 25 42 04 0043*      call vdu_plot_bmp
043B9A             0044*  ; all done
043B9A C9          0045*      ret
043B9B             0046*  
043B9B             0047*  ; xevious_plot:
043B9B             0048*  ; ; load current bg tile bufferId as default
043B9B             0049*  ;     ld hl,(bg_bufferId)
043B9B             0050*  ; ; check whether it is time for a new background tile
043B9B             0051*  ;     ld a,(bg_y_plot)
043B9B             0052*  ;     inc a
043B9B             0053*  ;     ld (bg_y_plot),a
043B9B             0054*  ;     jp nz,@F ; not time for a new tile so draw current one
043B9B             0055*  ; ; load the next background tile
043B9B             0056*  ;     ld hl,Xevious_tile
043B9B             0057*  ;     inc (hl)
043B9B             0058*  ;     ld a,%00011111 ; 31
043B9B             0059*  ;     and (hl)
043B9B             0060*  ;     ld hl,BUF_XEVIOUS_00
043B9B             0061*  ;     add a,l
043B9B             0062*  ;     ld l,a
043B9B             0063*  ;     ld a,0
043B9B             0064*  ;     adc a,h
043B9B             0065*  ;     ld h,a
043B9B             0066*  ;     ld (bg_bufferId),hl
043B9B             0067*  ; @@:
043B9B             0068*  ;     call vdu_buff_select
043B9B             0069*  ;     ld bc,0
043B9B             0070*  ;     ld de,(bg_y_plot)
043B9B             0071*  ;     inc de
043B9B             0072*  ;     call vdu_plot_bmp
043B9B             0073*  ; ; all done
043B9B             0074*  ;     ret
043B9B             0075*  ; Xevious_tile: db 0
043B9B             0076*  
043B9B             0077*  tiles_plot:
043B9B             0078*  ; set gfx viewport to playing field window
043B9B 01 00 00 00 0079*      ld bc,field_left
043B9F 11 00 00 00 0080*      ld de,field_top
043BA3 DD 21 FF 00 0081*      ld ix,field_right
       00          
043BA8 FD 21 7F 01 0082*      ld iy,field_bottom
       00          
043BAD CD 0F 3F 04 0083*      call vdu_set_gfx_viewport
043BB1             0084*  ; move the background down one pixel
043BB1 3E 02       0085*      ld a,2 ; current gfx viewport
043BB3 2E 02       0086*      ld l,2 ; direction=down
043BB5 26 01       0087*      ld h,1 ; speed=1 px
043BB7 CD 87 3E 04 0088*      call vdu_scroll_down
043BBB             0089*  ; set gfx viewport to one scanline to optimise plotting tiles
043BBB 01 00 00 00 0090*      ld bc,0 ; leftmost x-coord
043BBF 11 00 00 00 0091*      ld de,0 ; topmost y-coord
043BC3 DD 21 FF 00 0092*      ld ix,255 ; rightmost x-coord
       00          
043BC8 FD 21 00 00 0093*      ld iy,0 ; bottommost y-coord
       00          
043BCD CD 0F 3F 04 0094*      call vdu_set_gfx_viewport
043BD1             0095*  ; plot the background
043BD1 CD 63 3B 04 0096*      call bg_plot
043BD5             0097*      ; call xevious_plot
043BD5             0098*      ; ret ; DEBUG
043BD5             0099*  ; initialize tiles loop
043BD5 21 00 00 00 0100*      ld hl,0 ; init plotting x-coordinate
043BD9 22 57 3B 04 0101*      ld (tiles_x_plot),hl
043BDD 2A 4C 3B 04 0102*      ld hl,(tiles_row_defs)
043BE1 06 10       0103*      ld b,16 ; loop counter
043BE3             0104*  @loop:
043BE3 C5          0105*      push bc ; save the loop counter
043BE4             0106*  ; read the tile defintion for the current column
043BE4 7E          0107*      ld a,(hl) ; a has tile definition
043BE5 E5          0108*      push hl ; save pointer to tile definition
043BE6 21 00 00 00 0109*      ld hl,0 ; hlu is non-zero
043BEA 6F          0110*      ld l,a ; l is tile defintion
043BEB 26 01       0111*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
043BED CD 5C 3F 04 0112*      call vdu_buff_select ; tile bitmap buffer is now active
043BF1             0113*  ; plot the active bitmap
043BF1 ED 4B 57 3B 0114*      ld bc,(tiles_x_plot)
       04          
043BF6 ED 5B 5A 3B 0115*      ld de,(tiles_y_plot)
       04          
043BFB CD 25 42 04 0116*      call vdu_plot_bmp
043BFF             0117*  ; bump x-coords the width of one tile and save it
043BFF 2A 57 3B 04 0118*      ld hl,(tiles_x_plot)
043C03 01 10 00 00 0119*      ld bc,16
043C07 09          0120*      add hl,bc
043C08 22 57 3B 04 0121*      ld (tiles_x_plot),hl
043C0C             0122*  ; prepare to loop to next column
043C0C E1          0123*      pop hl ; get back pointer to tile def
043C0D 23          0124*      inc hl ; bump it to the next column
043C0E C1          0125*      pop bc ; snag our loop counter
043C0F 10 D2       0126*      djnz @loop
043C11             0127*  ; increment tiles plotting y-coordinate
043C11             0128*  ; when it hits zero, we go to next row of tiles in the map
043C11             0129*  ; (we use ix b/c we want to preserve hl for the next step)
043C11 DD 21 5A 3B 0130*      ld ix,tiles_y_plot
       04          
043C16 DD 34 00    0131*      inc (ix)
043C19 C0          0132*      ret nz
043C1A             0133*  ; time to bump tiles_row_defs to next row
043C1A             0134*  ; (hl was already there at the end of the loop)
043C1A 22 4C 3B 04 0135*      ld (tiles_row_defs),hl
043C1E             0136*  ; reset coords to plot next row of tiles
043C1E 21 00 00 00 0137*      ld hl,0
043C22 22 57 3B 04 0138*      ld (tiles_x_plot),hl
043C26 21 F1 FF FF 0139*      ld hl,-15
043C2A 22 5A 3B 04 0140*      ld (tiles_y_plot),hl
043C2E             0141*  ; decrement tiles row counter
043C2E 21 4F 3B 04 0142*      ld hl,tiles_row
043C32 35          0143*      dec (hl)
043C33 C0          0144*      ret nz
043C34             0145*  ; queue up next level
043C34 3A 50 3B 04 0146*      ld a,(cur_level)
043C38 FE 01       0147*      cp num_levels-1
043C3A 20 02       0148*      jr nz,@inc_level
043C3C 3E FF       0149*      ld a,-1 ; will wrap around to zero when we fall through
043C3E             0150*  @inc_level:
043C3E 3C          0151*      inc a
043C3F 32 50 3B 04 0152*      ld (cur_level),a
043C43             0153*  ; increase the number of enemy sprites
043C43 3A 85 07 04 0154*      ld a,(max_enemy_sprites)
043C47 3C          0155*      inc a
043C48 FE 10       0156*      cp table_max_records ; if we're at the global limit,skip ahead at max level
043C4A 28 04       0157*      jr z,init_level
043C4C 32 85 07 04 0158*      ld (max_enemy_sprites),a ; otherwise save the updated number
043C50             0159*  ; fall through to init_level
043C50             0160*  
043C50             0161*  init_level:
043C50             0162*  ; look up address of level's tile defintion
043C50 21 51 3B 04 0163*      ld hl,tiles_levels
043C54 3A 50 3B 04 0164*      ld a,(cur_level)
043C58 11 00 00 00 0165*      ld de,0 ; just in case deu is non-zero
043C5C 57          0166*      ld d,a
043C5D 1E 03       0167*      ld e,3
043C5F ED 5C       0168*      mlt de
043C61 19          0169*      add hl,de
043C62 ED 37       0170*      ld ix,(hl)
043C64 DD 22 4C 3B 0171*      ld (tiles_row_defs),ix
       04          
043C69             0172*  ; set tiles_row counter
043C69 DD 7E 00    0173*      ld a,(ix)
043C6C 32 4F 3B 04 0174*      ld (tiles_row),a
043C70 DD 23       0175*      inc ix ; now ix points first element of first row tile def
043C72 DD 22 4C 3B 0176*      ld (tiles_row_defs),ix ; ... so we save it
       04          
043C77             0177*  ; draw initial background tiles
043C77             0178*  ; TODO: make this a stars background
043C77 21 39 01 00 0179*      ld hl,BUF_STATION_BG_00
043C7B CD 5C 3F 04 0180*      call vdu_buff_select
043C7F 01 00 00 00 0181*      ld bc,0
043C83 11 00 00 00 0182*      ld de,field_top
043C87 CD 25 42 04 0183*      call vdu_plot_bmp
043C8B             0184*  
043C8B 21 3A 01 00 0185*      ld hl,BUF_STATION_BG_01
043C8F CD 5C 3F 04 0186*      call vdu_buff_select
043C93 01 00 00 00 0187*      ld bc,0
043C97 11 00 01 00 0188*      ld de,field_top+256
043C9B CD 25 42 04 0189*      call vdu_plot_bmp
043C9F             0190*  
043C9F C9          0191*      ret
043CA0             0192*  
043CA0             0193*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
043CA0             0194*  ; dt_is_active:
043CA0             0195*  ; ; a lands here containing a tile index in the low nibble
043CA0             0196*  ; ; we test the values for the tiles which are active
043CA0             0197*  ;     cp #07
043CA0             0198*  ;     call z,ld_act_landing_pad
043CA0             0199*  ;     cp #08
043CA0             0200*  ;     call z,ld_act_laser_turret
043CA0             0201*  ;     ; fall through
043CA0             0202*  ;     ret
043CA0             0203*  
043CA0             0204*  ; ; some tiles become active sprites,so we load those here
043CA0             0205*  ; ; sprite_x/y have already been loaded
043CA0             0206*  ; ; sprite_dim_x/y are loaded by table_add_record
043CA0             0207*  ; ; we don't want sprite drawn to background like other tiles
043CA0             0208*  ; ; so this routine only adds them to the sprite table
043CA0             0209*  ; dt_ld_act:
043CA0             0210*  ;     ld a,#48 ; top of screen + 1/2 tile height
043CA0             0211*  ;     ld (sprite_y+1),a ; just the integer part
043CA0             0212*  ;     ld (sprite_base_bufferId),hl
043CA0             0213*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043CA0             0214*  ;     call table_add_record
043CA0             0215*  ;     call sprite_variables_from_stack
043CA0             0216*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
043CA0             0217*  ;     ret ; and back
043CA0             0218*  
043CA0             0219*  ; ld_act_landing_pad:
043CA0             0220*  ;     call sprite_variables_to_stack
043CA0             0221*  
043CA0             0222*  ;     ld hl,move_landing_pad
043CA0             0223*  ;     ld (sprite_move_program),hl
043CA0             0224*  
043CA0             0225*  ;     xor a
043CA0             0226*  ;     ld (sprite_animation),a ; animation 0
043CA0             0227*  
043CA0             0228*  ;     call rand_8     ; snag a random number
043CA0             0229*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043CA0             0230*  ;     add a,64 ; range is now 64-127
043CA0             0231*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
043CA0             0232*  
043CA0             0233*  ;     ld a,%10 ; collides with laser but not player
043CA0             0234*  ;     ld (iy+sprite_collisions),a
043CA0             0235*  
043CA0             0236*  ;     ld a,#05 ; BCD
043CA0             0237*  ;     ld (sprite_points),a
043CA0             0238*  ;     ld a,0 ; binary
043CA0             0239*  ;     ld (sprite_shield_damage),a
043CA0             0240*  
043CA0             0241*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
043CA0             0242*  ;     jr dt_ld_act
043CA0             0243*  
043CA0             0244*  ; ld_act_laser_turret:
043CA0             0245*  ;     call sprite_variables_to_stack
043CA0             0246*  
043CA0             0247*  ;     ld hl,move_laser_turret
043CA0             0248*  ;     ld (sprite_move_program),hl
043CA0             0249*  
043CA0             0250*  ;     xor a
043CA0             0251*  ;     ld (sprite_animation),a
043CA0             0252*  ;     ld (sprite_move_step),a
043CA0             0253*  
043CA0             0254*  ;     call rand_8     ; snag a random number
043CA0             0255*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043CA0             0256*  ;     add a,64 ; range is now 64-127
043CA0             0257*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043CA0             0258*  
043CA0             0259*  ;     ld a,%10 ; collides with laser but not player
043CA0             0260*  ;     ld (iy+sprite_collisions),a
043CA0             0261*  
043CA0             0262*  ;     ld a,#10 ; BCD
043CA0             0263*  ;     ld (sprite_points),a
043CA0             0264*  ;     ld a,0 ; binary
043CA0             0265*  ;     ld (sprite_shield_damage),a
043CA0             0266*  
043CA0             0267*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
043CA0             0268*  ;     jp dt_ld_act
043CA0             0269*  
043CA0             0270*  
043CA0             0271*  ; moves active tile sprites down one pixel in sync with tiles movement
043CA0             0272*  ; deletes sprites from table when they wrap around to top of screen
043CA0             0273*  move_active_tiles:
043CA0             0274*  ; get current position
043CA0 3A 0F 00 00 0275*      ld a,(sprite_y+1) ; we only need the integer part
043CA4 3C          0276*      inc a
043CA5             0277*  ; are we at the bottom of the screen?
043CA5 20 06       0278*      jr nz,move_active_tiles_draw_sprite ; nope
043CA7             0279*  ; otherwise kill sprite
043CA7 3E 80       0280*      ld a,%10000000 ; any bit set in high nibble means sprite will die
043CA9 FD 77 08    0281*      ld (iy+sprite_collisions),a
043CAC C9          0282*      ret ; debug
043CAD             0283*  move_active_tiles_draw_sprite:
043CAD 32 0F 00 00 0284*      ld (sprite_y+1),a ; update tile y position integer part
043CB1             0285*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043CB1             0286*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
043CB1 C9          0287*      ret ; and done
043CB2             0042       include "timer.inc"
043CB2             0001*  ; Table 32. Timer Control Registers
043CB2             0002*  ; this constant is the base address of the timer control registers
043CB2             0003*  ; each timer takes three bytes:
043CB2             0004*  ;   0: control register
043CB2             0005*  ;   1: low byte of timer reset value
043CB2             0006*  ;   2: high byte of timer reset value
043CB2             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043CB2             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043CB2             0009*  TMR_CTL:     equ 80h
043CB2             0010*  
043CB2             0011*  ; Timer Control Register Bit Definitions
043CB2             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043CB2             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043CB2             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043CB2             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043CB2             0016*                              ; the TMRx_CTL register is read.
043CB2             0017*  
043CB2             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043CB2             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043CB2             0020*  
043CB2             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043CB2             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043CB2             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043CB2             0024*                              ; written to the counter when the end-of-count value is reached.
043CB2             0025*  
043CB2             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043CB2             0027*  CLK_DIV_256:  equ %00001100 ;
043CB2             0028*  CLK_DIV_64:   equ %00001000 ;
043CB2             0029*  CLK_DIV_16:   equ %00000100 ;
043CB2             0030*  CLK_DIV_4:    equ %00000000 ;
043CB2             0031*  
043CB2             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043CB2             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043CB2             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043CB2             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043CB2             0036*                              ; programmer must ensure that this bit is set to 1 each time
043CB2             0037*                              ; SINGLE-PASS mode is used.
043CB2             0038*  
043CB2             0039*  ; disable/enable the programmable reload timer
043CB2             0040*  PRT_EN_0:     equ %00000000 ;
043CB2             0041*  PRT_EN_1:     equ %00000001 ;
043CB2             0042*  
043CB2             0043*  ; Table 37. Timer Input Source Select Register
043CB2             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043CB2             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043CB2             0046*  ;   00: System clock / CLK_DIV
043CB2             0047*  ;   01: RTC / CLK_DIV
043CB2             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043CB2             0049*  ;   10: GPIO port B pin 1.
043CB2             0050*  ;   11: GPIO port B pin 1.
043CB2             0051*  TMR_ISS:   equ 92h ; register address
043CB2             0052*  
043CB2             0053*  ; Table 51. Real-Time Clock Control Register
043CB2             0054*  RTC_CTRL: equ EDh ; register address
043CB2             0055*  
043CB2             0056*  ; alarm interrupt disable/enable
043CB2             0057*  RTC_ALARM_0:    equ %00000000
043CB2             0058*  RTC_ALARM_1:    equ %10000000
043CB2             0059*  
043CB2             0060*  ; interrupt on alarm disable/enable
043CB2             0061*  RTC_INT_ENT_0:  equ %00000000
043CB2             0062*  RTC_INT_ENT_1:  equ %01000000
043CB2             0063*  
043CB2             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043CB2             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043CB2             0066*  
043CB2             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043CB2             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043CB2             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043CB2             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043CB2             0071*  
043CB2             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043CB2             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043CB2             0074*  
043CB2             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043CB2             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043CB2             0077*  
043CB2             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043CB2             0079*                                  ; RTC counter is enabled.
043CB2             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043CB2             0081*                                  ; RTC counter is disabled.
043CB2             0082*  
043CB2             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043CB2             0084*  
043CB2             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043CB2             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043CB2 00 00 00    0087*  prt_reload: dl 0x000000
043CB5             0088*  
043CB5             0089*  ; set PRT timer
043CB5             0090*  prt_set:
043CB5 21 00 00 00 0091*      ld hl,0
043CB9 22 03 3D 04 0092*      ld (prt_irq_counter),hl
043CBD 2A B2 3C 04 0093*      ld hl,(prt_reload)
043CC1 ED 29 84    0094*      out0 ($84),l
043CC4 ED 21 85    0095*  	out0 ($85),h
043CC7             0096*  ; disable timer
043CC7 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043CC9 ED 39 83    0098*  	out0 ($83),a
043CCC             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043CCC 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
043CCE ED 39 83    0101*  	out0 ($83),a
043CD1 C9          0102*      ret
043CD2             0103*  
043CD2             0104*  ; ===============================================
043CD2             0105*  ; PRT Timer Interrupt Handling
043CD2             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
043CD2             0107*  ; -----------------------------------------------
043CD2             0108*  prt_irq_init:
043CD2             0109*      ; set up interrupt vector table 2
043CD2 21 00 00 00 0110*  	ld hl,0
043CD6 3A 0C 01 00 0111*  	ld a,($10c)
043CDA 6F          0112*  	ld l,a
043CDB 3A 0D 01 00 0113*  	ld a,($10d)
043CDF 67          0114*  	ld h,a
043CE0             0115*  
043CE0             0116*  	; skip over CALL ($c3)
043CE0 23          0117*  	inc hl
043CE1             0118*  	; load address of jump into vector table 2 (in ram)
043CE1 ED 27       0119*  	ld hl,(hl)
043CE3             0120*  
043CE3             0121*  	; write CALL prt_irq_handler to vector table 2
043CE3 3E C3       0122*  	ld a,$c3
043CE5 77          0123*  	ld (hl),a
043CE6 23          0124*  	inc hl
043CE7 11 EE 3C 04 0125*  	ld de,prt_irq_handler
043CEB ED 1F       0126*  	ld (hl),de
043CED             0127*  
043CED C9          0128*      ret
043CEE             0129*  
043CEE             0130*  prt_irq_handler:
043CEE F3          0131*  	di
043CEF F5          0132*  	push af
043CF0 E5          0133*      push hl
043CF1 ED 38 83    0134*  	in0 a,($83)
043CF4 2A 03 3D 04 0135*  	ld hl,(prt_irq_counter)
043CF8 23          0136*  	inc hl
043CF9 22 03 3D 04 0137*  	ld (prt_irq_counter),hl
043CFD E1          0138*      pop hl
043CFE F1          0139*  	pop af
043CFF FB          0140*  	ei
043D00 5B ED 4D    0141*  	reti.l
043D03             0142*  
043D03             0143*  prt_irq_counter:
043D03 00 00 00    0144*  	.dl 0
043D06             0145*  prt_irq_counter_saved:
043D06 00 00 00    0146*      .dl 0
043D09             0147*  
043D09             0148*  prt_loop_reset:
043D09 E5          0149*      push hl
043D0A 21 00 00 00 0150*  	ld hl,0
043D0E 22 03 3D 04 0151*  	ld (prt_irq_counter),hl
043D12 22 74 3D 04 0152*      ld (prt_loop_counter),hl
043D16 22 77 3D 04 0153*      ld (prt_loops),hl
043D1A CD B5 3C 04 0154*      call prt_set
043D1E E1          0155*      pop hl
043D1F C9          0156*      ret
043D20             0157*  
043D20             0158*  prt_loop_start:
043D20 E5          0159*      push hl
043D21 21 00 00 00 0160*  	ld hl,0
043D25 22 03 3D 04 0161*  	ld (prt_irq_counter),hl
043D29 E1          0162*      pop hl
043D2A C9          0163*      ret
043D2B             0164*  
043D2B             0165*  prt_loop_stop:
043D2B E5          0166*      push hl
043D2C D5          0167*      push de
043D2D 2A 03 3D 04 0168*      ld hl,(prt_irq_counter)
043D31 ED 5B 74 3D 0169*      ld de,(prt_loop_counter)
       04          
043D36 19          0170*      add hl,de
043D37 22 74 3D 04 0171*      ld (prt_loop_counter),hl
043D3B 21 00 00 00 0172*      ld hl,0
043D3F 22 03 3D 04 0173*      ld (prt_irq_counter),hl
043D43 2A 77 3D 04 0174*      ld hl,(prt_loops)
043D47 23          0175*      inc hl
043D48 22 77 3D 04 0176*      ld (prt_loops),hl
043D4C D1          0177*      pop de
043D4D E1          0178*      pop hl
043D4E C9          0179*      ret
043D4F             0180*  
043D4F             0181*  ; inputs: bc = y,x text coordinates to print
043D4F             0182*  prt_loop_print:
043D4F F5          0183*      push af
043D50 E5          0184*      push hl
043D51 C5          0185*      push bc
043D52 D5          0186*      push de
043D53 DD E5       0187*      push ix
043D55 FD E5       0188*      push iy
043D57 CD 5B 3E 04 0189*      call vdu_move_cursor
043D5B             0190*  
043D5B 2A 74 3D 04 0191*      ld hl,(prt_loop_counter)
043D5F CD 76 01 04 0192*      call printDec
043D63             0193*  
043D63 2A 77 3D 04 0194*      ld hl,(prt_loops)
043D67 CD 76 01 04 0195*      call printDec
043D6B             0196*  
043D6B FD E1       0197*      pop iy
043D6D DD E1       0198*      pop ix
043D6F D1          0199*      pop de
043D70 C1          0200*      pop bc
043D71 E1          0201*      pop hl
043D72 F1          0202*      pop af
043D73 C9          0203*      ret
043D74             0204*  
043D74             0205*  prt_loop_counter:
043D74 00 00 00    0206*      .dl 0
043D77             0207*  prt_loops:
043D77 00 00 00    0208*      .dl 0
043D7A             0209*  
043D7A             0210*  ; ===============================================
043D7A             0211*  ; Timer functions
043D7A             0212*  ; -----------------------------------------------
043D7A             0213*  ; set a countdown timer
043D7A             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043D7A             0215*  ; returns: hl = current time
043D7A             0216*  tmr_set:
043D7A FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
043D7D             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
043D7D 3E 08       0001*M 			LD	A, function
043D7F 5B CF       0002*M 			RST.LIL	08h
043D81 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043D84 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
043D87 C9          0221*      ret
043D88             0222*  
043D88             0223*  ; gets time remaining on a countdown timer
043D88             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043D88             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043D88             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
043D88             0227*  tmr_get:
043D88             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
043D88 3E 08       0001*M 			LD	A, function
043D8A 5B CF       0002*M 			RST.LIL	08h
043D8C DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
043D8F FD 27 00    0230*      ld hl,(iy+0)            ; get start time
043D92 AF          0231*      xor a                   ; clear carry
043D93 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043D95 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
043D98 AF          0234*      xor a                   ; clear carry
043D99 ED 5A       0235*      adc hl,de               ; hl = time remaining
043D9B             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043D9B C9          0237*      ret
043D9C             0238*  
043D9C             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
043DA2             0240*  
043DA2 00 00 00    0241*  timestamp_now: dl 0
043DA5 00 00 00    0242*  timestamp_old: dl 0
043DA8 00 00 00    0243*  timestamp_chg: dl 0
043DAB             0244*  
043DAB             0245*  ; update the global timestamp from the system clock
043DAB             0246*  ; inputs: none
043DAB             0247*  ; returns: hl = time elapsed in 1/120ths of a second
043DAB             0248*  ;          de = current time
043DAB             0249*  ;          ix = pointer to syvars table
043DAB             0250*  ; destroys: af,hl,de,ix
043DAB             0251*  timestamp_tick:
043DAB ED 5B A2 3D 0252*      ld de,(timestamp_now)   ; get previous time
       04          
043DB0 ED 53 A5 3D 0253*      ld (timestamp_old),de   ; save previous time
       04          
043DB5             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043DB5 3E 08       0001*M 			LD	A, function
043DB7 5B CF       0002*M 			RST.LIL	08h
043DB9 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
043DBC 22 A2 3D 04 0256*      ld (timestamp_now),hl   ; save current time
043DC0 AF          0257*      xor a                   ; clear carry
043DC1 ED 52       0258*      sbc hl,de               ; hl = time elapsed
043DC3 22 A8 3D 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043DC7 C9          0260*      ret
043DC8             0261*  
043DC8             0262*  ; set a countdown timer
043DC8             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043DC8             0264*  ; requires: timestamp_tick to be called at least once before this function
043DC8             0265*  ; returns: hl = current time
043DC8             0266*  ; destroys: hl
043DC8             0267*  timestamp_tmr_set:
043DC8 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043DCB 2A A2 3D 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
043DCF FD 2F 00    0270*      ld (iy+0),hl            ; set start time
043DD2 C9          0271*      ret
043DD3             0272*  
043DD3             0273*  ; gets time remaining on a countdown timer following the global timestamp
043DD3             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043DD3             0275*  ; requires: timestamp_tick to be called at least once before this function
043DD3             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043DD3             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
043DD3             0278*  ; destroys: af,hl,de
043DD3             0279*  timestamp_tmr_get:
043DD3 ED 5B A2 3D 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043DD8 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043DDB AF          0282*      xor a                   ; clear carry
043DDC ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043DDE FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
043DE1 AF          0285*      xor a                   ; clear carry
043DE2 ED 5A       0286*      adc hl,de               ; hl = time remaining
043DE4             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043DE4 C9          0288*      ret
043DE5             0289*  
043DE5             0290*  ; set a stopwatch
043DE5             0291*  ; returns: hl = start time
043DE5             0292*  ; destroys: hl,ix
043DE5             0293*  stopwatch_set:
043DE5             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043DE5 3E 08       0001*M 			LD	A, function
043DE7 5B CF       0002*M 			RST.LIL	08h
043DE9 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043DEC 22 01 3E 04 0296*      ld (stopwatch_started),hl            ; set start time
043DF0 C9          0297*      ret
043DF1             0298*  
043DF1             0299*  ; gets time elapsed on a stopwatch
043DF1             0300*  ; returns: hl = time elapsed in 1/120ths of a second
043DF1             0301*  ; destroys: af,hl,de,ix
043DF1             0302*  stopwatch_get:
043DF1             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
043DF1 3E 08       0001*M 			LD	A, function
043DF3 5B CF       0002*M 			RST.LIL	08h
043DF5 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043DF8 ED 5B 01 3E 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043DFD AF          0306*      xor a                   ; clear carry
043DFE ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
043E00 C9          0308*      ret
043E01             0309*  
043E01             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043E04             0311*  
043E04             0312*  ; ------------------
043E04             0313*  ; delay routine
043E04             0314*  ; Author: Richard Turrnidge
043E04             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043E04             0316*  ; routine waits a fixed time,then returns
043E04             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043E04             0318*  ; eg. ld A,00000100b
043E04             0319*  
043E04             0320*  multiPurposeDelay:
043E04 F5          0321*      push af
043E05 C5          0322*      push bc
043E06 DD E5       0323*      push ix
043E08 47          0324*      ld b,a
043E09 3E 08       0325*      ld a,$08
043E0B 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043E0D             0327*  
043E0D             0328*  waitLoop:
043E0D             0329*  
043E0D DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
043E10             0331*  
043E10             0332*                                  ;   we check if bit set is same as last time we checked.
043E10             0333*                                  ;   bit 0 - don't use
043E10             0334*                                  ;   bit 1 - changes 64 times per second
043E10             0335*                                  ;   bit 2 - changes 32 times per second
043E10             0336*                                  ;   bit 3 - changes 16 times per second
043E10             0337*  
043E10             0338*                                  ;   bit 4 - changes 8 times per second
043E10             0339*                                  ;   bit 5 - changes 4 times per second
043E10             0340*                                  ;   bit 6 - changes 2 times per second
043E10             0341*                                  ;   bit 7 - changes 1 times per second
043E10 A0          0342*      and b
043E11 4F          0343*      ld c,a
043E12 3A 23 3E 04 0344*      ld a,(oldTimeStamp)
043E16 B9          0345*      cp c                        ; is A same as last value?
043E17 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043E19 79          0347*      ld a,c
043E1A 32 23 3E 04 0348*      ld (oldTimeStamp),a        ; set new value
043E1E             0349*  
043E1E DD E1       0350*      pop ix
043E20 C1          0351*      pop bc
043E21 F1          0352*      pop af
043E22 C9          0353*      ret
043E23             0354*  
043E23 00          0355*  oldTimeStamp:   .db 00h
043E24             0043       include "vdu.inc"
043E24             0001*  
043E24             0002*  ; VDU 30: Home cursor
043E24             0003*  vdu_home_cursor:
043E24 3E 1E       0004*      ld a,30
043E26 5B D7       0005*  	rst.lil $10
043E28 C9          0006*  	ret
043E29             0007*  
043E29             0008*  vdu_cursor_on:
043E29 21 34 3E 04 0009*  	ld hl,@cmd
043E2D 01 03 00 00 0010*  	ld bc,@end-@cmd
043E31 5B DF       0011*  	rst.lil $18
043E33 C9          0012*  	ret
043E34             0013*  @cmd:
043E34 17 01 01    0014*  	db 23,1,1
043E37             0015*  @end:
043E37             0016*  
043E37             0017*  vdu_cursor_off:
043E37 21 42 3E 04 0018*  	ld hl,@cmd
043E3B 01 03 00 00 0019*  	ld bc,@end-@cmd
043E3F 5B DF       0020*  	rst.lil $18
043E41 C9          0021*  	ret
043E42             0022*  @cmd:
043E42 17 01 00    0023*  	db 23,1,0
043E45             0024*  @end:
043E45             0025*  
043E45             0026*  ; VDU 5: Write text at graphics cursor
043E45             0027*  ; inputs: a is the character to write to the screen
043E45             0028*  ; prerequisites: the graphics cursor at the intended position on screen
043E45             0029*  ; outputs: see the name of the function
043E45             0030*  ; destroys: a, hl, bc
043E45             0031*  vdu_char_to_gfx_cursor:
043E45 32 55 3E 04 0032*  	ld (@arg),a
043E49 21 54 3E 04 0033*  	ld hl,@cmd
043E4D 01 02 00 00 0034*  	ld bc,@end-@cmd
043E51 5B DF       0035*  	rst.lil $18
043E53 C9          0036*  	ret
043E54 05          0037*  @cmd: db 5
043E55 00          0038*  @arg: db 0
043E56             0039*  @end:
043E56             0040*  ; VDU 9: Move cursor forward one character
043E56             0041*  vdu_cursor_forward:
043E56 3E 09       0042*      ld a,9
043E58 5B D7       0043*  	rst.lil $10
043E5A C9          0044*  	ret
043E5B             0045*  
043E5B             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
043E5B             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
043E5B             0048*  vdu_move_cursor:
043E5B ED 43 6C 3E 0049*      ld (@x0),bc
       04          
043E60 21 6B 3E 04 0050*  	ld hl,@cmd
043E64 01 03 00 00 0051*  	ld bc,@end-@cmd
043E68 5B DF       0052*  	rst.lil $18
043E6A C9          0053*  	ret
043E6B 1F          0054*  @cmd: 	db 31
043E6C 00          0055*  @x0:	db 0
043E6D 00          0056*  @y0: 	db 0
043E6E 00          0057*  @end: 	db 0 ; padding
043E6F             0058*  
043E6F             0059*  ; VDU 12: Clear text area (CLS)
043E6F             0060*  vdu_cls:
043E6F 3E 0C       0061*      ld a,12
043E71 5B D7       0062*  	rst.lil $10
043E73 C9          0063*  	ret
043E74             0064*  
043E74             0065*  vdu_flip:
043E74 21 7F 3E 04 0066*  	ld hl,@cmd
043E78 01 03 00 00 0067*  	ld bc,@end-@cmd
043E7C 5B DF       0068*  	rst.lil $18
043E7E C9          0069*  	ret
043E7F 17 00 C3    0070*  @cmd: db 23,0,0xC3
043E82             0071*  @end:
043E82             0072*  
043E82             0073*  ; VDU 16: Clear graphics area (CLG)
043E82             0074*  vdu_clg:
043E82 3E 10       0075*      ld a,16
043E84 5B D7       0076*  	rst.lil $10
043E86 C9          0077*  	ret
043E87             0078*  
043E87             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
043E87             0080*  ; VDU 23, 7: Scrolling
043E87             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
043E87             0082*  ; inputs: a, extent; l, direction; h; speed
043E87             0083*  vdu_scroll_down:
043E87 32 9C 3E 04 0084*  	ld (@extent),a
043E8B 22 9D 3E 04 0085*  	ld (@dir),hl ; implicitly populates @speed
043E8F 21 9A 3E 04 0086*  	ld hl,@cmd
043E93 01 05 00 00 0087*  	ld bc,@end-@cmd
043E97 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
043E99 C9          0089*  	ret
043E9A 17 07       0090*  @cmd:       db 23,7
043E9C 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
043E9D 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
043E9E 00          0093*  @speed:     db 0x00 ; pixels
043E9F 00          0094*  @end:		db 0x00 ; padding
043EA0             0095*  
043EA0             0096*  ; COLOUR MODES
043EA0             0097*  ; Mode	Effect
043EA0             0098*  ; 0	Set on-screen pixel to target colour value
043EA0             0099*  ; 1	OR value with the on-screen pixel
043EA0             0100*  ; 2	AND value with the on-screen pixel
043EA0             0101*  ; 3	XOR value with the on-screen pixel
043EA0             0102*  ; 4	Invert the on-screen pixel
043EA0             0103*  ; 5	No operation
043EA0             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
043EA0             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
043EA0             0106*  
043EA0             0107*  ; VDU 17, colour: Define text colour (COLOUR)
043EA0             0108*  vdu_colour_text:
043EA0 32 B0 3E 04 0109*  	ld (@arg),a
043EA4 21 AF 3E 04 0110*  	ld hl,@cmd
043EA8 01 02 00 00 0111*  	ld bc,@end-@cmd
043EAC 5B DF       0112*  	rst.lil $18
043EAE C9          0113*  	ret
043EAF 11          0114*  @cmd: db 17
043EB0 00          0115*  @arg: db 0
043EB1             0116*  @end:
043EB1             0117*  
043EB1             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
043EB1             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
043EB1             0120*  vdu_gcol:
043EB1 32 C6 3E 04 0121*  	ld (@mode),a
043EB5 79          0122*      ld a,c
043EB6 32 C7 3E 04 0123*      ld (@col),a
043EBA 21 C5 3E 04 0124*  	ld hl,@cmd
043EBE 01 03 00 00 0125*  	ld bc,@end-@cmd
043EC2 5B DF       0126*  	rst.lil $18
043EC4 C9          0127*  	ret
043EC5 12          0128*  @cmd:  db 18
043EC6 00          0129*  @mode: db 0
043EC7 00          0130*  @col:  db 0
043EC8             0131*  @end:
043EC8             0132*  
043EC8             0133*  
043EC8             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
043EC8             0135*  ; MIND THE LITTLE-ENDIANESS
043EC8             0136*  ; inputs: c=left,b=bottom,e=right,d=top
043EC8             0137*  ; outputs; nothing
043EC8             0138*  ; destroys: a might make it out alive
043EC8             0139*  vdu_set_txt_viewport:
043EC8 ED 43 DE 3E 0140*      ld (@lb),bc
       04          
043ECD ED 53 E0 3E 0141*  	ld (@rt),de
       04          
043ED2 21 DD 3E 04 0142*  	ld hl,@cmd
043ED6 01 05 00 00 0143*  	ld bc,@end-@cmd
043EDA 5B DF       0144*  	rst.lil $18
043EDC C9          0145*  	ret
043EDD 1C          0146*  @cmd:   db 28 ; set text viewport command
043EDE 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
043EE0 00 00       0148*  @rt: 	dw 0x0000 ; set by de
043EE2 00          0149*  @end:   db 0x00	  ; padding
043EE3             0150*  
043EE3             0151*  ; Wait for VBLANK interrupt
043EE3             0152*  vdu_vblank:
043EE3 DD E5       0153*      PUSH 	IX
043EE5             0154*  	MOSCALL	mos_sysvars
043EE5 3E 08       0001*M 			LD	A, function
043EE7 5B CF       0002*M 			RST.LIL	08h
043EE9 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
043EEC             0156*  @wait:
043EEC DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
043EEF 28 FB       0158*      JR	Z, @wait
043EF1 DD E1       0159*      POP	IX
043EF3 C9          0160*      RET
043EF4             0161*  
043EF4             0162*  ; VDU 29, x; y;: Set graphics origin
043EF4             0163*  ; This command sets the graphics origin.
043EF4             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
043EF4             0165*  ; inputs: bc=x0,de=y0
043EF4             0166*  ; outputs; nothing
043EF4             0167*  ; destroys: a might make it out alive
043EF4             0168*  vdu_set_gfx_origin:
043EF4 ED 43 0A 3F 0169*      ld (@x0),bc
       04          
043EF9 ED 53 0C 3F 0170*      ld (@y0),de
       04          
043EFE 21 09 3F 04 0171*      ld hl,@cmd
043F02 01 05 00 00 0172*      ld bc,@end-@cmd
043F06 5B DF       0173*      rst.lil $18
043F08 C9          0174*      ret
043F09 1D          0175*  @cmd:   db 29 ; set graphics origin command
043F0A 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
043F0C 00 00       0177*  @y0: 	dw 0x0000 ; set by de
043F0E 00          0178*  @end:   db 0x00	  ; padding
043F0F             0179*  
043F0F             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
043F0F             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
043F0F             0182*  ; 	because we have turned off logical screen scaling
043F0F             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
043F0F             0184*  ; outputs; nothing
043F0F             0185*  ; destroys: a might make it out alive
043F0F             0186*  vdu_set_gfx_viewport:
043F0F ED 43 2F 3F 0187*      ld (@x0),bc
       04          
043F14 FD 22 31 3F 0188*      ld (@y1),iy
       04          
043F19 DD 22 33 3F 0189*  	ld (@x1),ix
       04          
043F1E ED 53 35 3F 0190*  	ld (@y0),de
       04          
043F23 21 2E 3F 04 0191*  	ld hl,@cmd
043F27 01 09 00 00 0192*  	ld bc,@end-@cmd
043F2B 5B DF       0193*  	rst.lil $18
043F2D C9          0194*  	ret
043F2E 18          0195*  @cmd:   db 24 ; set graphics viewport command
043F2F 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
043F31 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
043F33 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
043F35 00 00       0199*  @y0: 	dw 0x0000 ; set by de
043F37 00          0200*  @end:   db 0x00	  ; padding
043F38             0201*  
043F38             0202*  ; SCREEN MODES
043F38             0203*  ; ===============================
043F38             0204*  ; Mode  Horz  Vert  Cols  Refresh
043F38             0205*  ; ---   ----  ----  ----  -------
043F38             0206*  ; 11    320   240   2     60hz
043F38             0207*  ; 139   320   240   2     60hz
043F38             0208*  ; 23    512   384   2     60hz
043F38             0209*  ; 151   512   384   2     60hz
043F38             0210*  ; 6     640   240   2     60hz
043F38             0211*  ; 134   640   240   2     60hz
043F38             0212*  ; 2     640   480   2     60hz
043F38             0213*  ; 130   640   480   2     60hz
043F38             0214*  ; 17    800   600   2     60hz
043F38             0215*  ; 145   800   600   2     60hz
043F38             0216*  ; 18    1024  768   2     60hz
043F38             0217*  ; 146   1024  768   2     60hz
043F38             0218*  ; ---   ----  ----  ----  -------
043F38             0219*  ; 10    320   240   4     60hz
043F38             0220*  ; 138   320   240   4     60hz
043F38             0221*  ; 22    512   384   4     60hz
043F38             0222*  ; 150   512   384   4     60hz
043F38             0223*  ; 5     640   240   4     60hz
043F38             0224*  ; 133   640   240   4     60hz
043F38             0225*  ; 1     640   480   4     60hz
043F38             0226*  ; 129   640   480   4     60hz
043F38             0227*  ; 16    800   600   4     60hz
043F38             0228*  ; 19    1024  768   4     60hz
043F38             0229*  ; ---   ----  ----  ----  -------
043F38             0230*  ; 9     320   240   16    60hz
043F38             0231*  ; 137   320   240   16    60hz
043F38             0232*  ; 21    512   384   16    60hz
043F38             0233*  ; 149   512   384   16    60hz
043F38             0234*  ; 4     640   240   16    60hz
043F38             0235*  ; 132   640   240   16    60hz
043F38             0236*  ; 0     640   480   16    60hz
043F38             0237*  ; 7     n/a   n/a   16    60hz
043F38             0238*  ; ---   ----  ----  ----  -------
043F38             0239*  ; 8     320   240   64    60hz
043F38             0240*  ; 136   320   240   64    60hz
043F38             0241*  ; 20    512   384   64    60hz
043F38             0242*  ; 3     640   240   64    60hz
043F38             0243*  ; ---   ----  ----  ----  -------
043F38             0244*  vdu_set_screen_mode:
043F38 32 48 3F 04 0245*  	ld (@arg),a
043F3C 21 47 3F 04 0246*  	ld hl,@cmd
043F40 01 02 00 00 0247*  	ld bc,@end-@cmd
043F44 5B DF       0248*  	rst.lil $18
043F46 C9          0249*  	ret
043F47 16          0250*  @cmd: db 22 ; set screen mode
043F48 00          0251*  @arg: db 0  ; screen mode parameter
043F49             0252*  @end:
043F49             0253*  
043F49             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
043F49             0255*  ; inputs: a is scaling mode, 1=on, 0=off
043F49             0256*  ; note: default setting on boot is scaling ON
043F49             0257*  vdu_set_scaling:
043F49 32 5B 3F 04 0258*  	ld (@arg),a
043F4D 21 58 3F 04 0259*  	ld hl,@cmd
043F51 01 04 00 00 0260*  	ld bc,@end-@cmd
043F55 5B DF       0261*  	rst.lil $18
043F57 C9          0262*  	ret
043F58 17 00 C0    0263*  @cmd: db 23,0,0xC0
043F5B 00          0264*  @arg: db 0  ; scaling on/off
043F5C             0265*  @end:
043F5C             0266*  
043F5C             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
043F5C             0268*  ; inputs: hl=bufferId
043F5C             0269*  vdu_buff_select:
043F5C 22 6E 3F 04 0270*  	ld (@bufferId),hl
043F60 21 6B 3F 04 0271*  	ld hl,@cmd
043F64 01 05 00 00 0272*  	ld bc,@end-@cmd
043F68 5B DF       0273*  	rst.lil $18
043F6A C9          0274*  	ret
043F6B 17 1B 20    0275*  @cmd: db 23,27,0x20
043F6E 00 00       0276*  @bufferId: dw 0x0000
043F70 00          0277*  @end: db 0x00 ; padding
043F71             0278*  
043F71             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
043F71             0280*  ; inputs: a=format; bc=width; de=height
043F71             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
043F71             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
043F71             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
043F71             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
043F71             0285*  ; 2 	Mono/Mask (1-bit per pixel)
043F71             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
043F71             0287*  vdu_bmp_create:
043F71 ED 43 8D 3F 0288*      ld (@width),bc
       04          
043F76 ED 53 8F 3F 0289*      ld (@height),de
       04          
043F7B 32 91 3F 04 0290*      ld (@fmt),a
043F7F 21 8A 3F 04 0291*  	ld hl,@cmd
043F83 01 08 00 00 0292*  	ld bc,@end-@cmd
043F87 5B DF       0293*  	rst.lil $18
043F89 C9          0294*  	ret
043F8A 17 1B 21    0295*  @cmd:       db 23,27,0x21
043F8D 00 00       0296*  @width:     dw 0x0000
043F8F 00 00       0297*  @height:    dw 0x0000
043F91 00          0298*  @fmt:       db 0x00
043F92             0299*  @end:
043F92             0300*  
043F92             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
043F92             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
043F92             0303*  vdu_load_img_rgba2_to_8:
043F92             0304*  ; backup the target buffer id and image dimensions
043F92 E5          0305*      push hl
043F93 D5          0306*      push de
043F94 C5          0307*      push bc
043F95             0308*  ; load the rgba2 image to working buffer 65534
043F95 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
043F99 CD 9C 40 04 0310*  	call vdu_load_buffer_from_file
043F9D             0311*  ; restore the image dimensions and target buffer id
043F9D C1          0312*      pop bc
043F9E D1          0313*      pop de
043F9F E1          0314*      pop hl
043FA0             0315*  ; fall through to vdu_rgba2_to_8
043FA0             0316*  
043FA0             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
043FA0             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
043FA0             0319*  ; the "expand bitmap" command is:
043FA0             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
043FA0             0321*  ; and then to reverse the byte order to fix endian-ness:
043FA0             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
043FA0             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
043FA0             0324*  ; VDU 23,27,&20,targetBufferID%;
043FA0             0325*  ; VDU 23,27,&21,width%;height%;0
043FA0             0326*  ; -------------------------------------------------------------------
043FA0             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
043FA0             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
043FA0             0329*  vdu_rgba2_to_8:
043FA0             0330*  ; load the image dimensions and buffer id parameters
043FA0 ED 43 FC 3F 0331*      ld (@width),bc
       04          
043FA5 ED 53 FE 3F 0332*      ld (@height),de
       04          
043FAA 22 E1 3F 04 0333*      ld (@bufferId0),hl
043FAE 22 EE 3F 04 0334*      ld (@bufferId2),hl
043FB2 22 F7 3F 04 0335*      ld (@bufferId1),hl
043FB6             0336*  ; clean up bytes that got stomped on by the ID loads
043FB6 3E 48       0337*      ld a,0x48
043FB8 32 E3 3F 04 0338*      ld (@bufferId0+2),a
043FBC 3E 17       0339*      ld a,23
043FBE 32 F9 3F 04 0340*      ld (@bufferId1+2),a
043FC2 3E 18       0341*      ld a,24
043FC4 32 F0 3F 04 0342*      ld (@bufferId2+2),a
043FC8 AF          0343*      xor a
043FC9 32 00 40 04 0344*      ld (@height+2),a
043FCD             0345*  ; send the vdu command strings
043FCD 21 D8 3F 04 0346*      ld hl,@beg
043FD1 01 29 00 00 0347*      ld bc,@end-@beg
043FD5 5B DF       0348*      rst.lil $18
043FD7 C9          0349*      ret
043FD8             0350*  @beg:
043FD8             0351*  ; Command 14: Consolidate blocks in a buffer
043FD8             0352*  ; VDU 23, 0, &A0, bufferId; 14
043FD8 17 00 A0    0353*      db 23,0,0xA0
043FDB FE FF       0354*      dw 65534 ; workingBufferId
043FDD 0E          0355*      db 14 ; consolidate blocks
043FDE             0356*  ; the "expand bitmap" command is:
043FDE             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
043FDE 17 00 A0    0358*      db 23,0,0xA0
043FE1 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
043FE3 48          0360*      db 0x48 ; given as decimal command 72 in the docs
043FE4 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
043FE5 FE FF       0362*      dw 65534 ; sourceBufferId
043FE7 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
043FEB             0364*  ; reverse the byte order to fix endian-ness:
043FEB             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
043FEB             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
043FEB             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
043FEB 17 00 A0    0368*      db 23,0,0xA0
043FEE 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
043FF0 18          0370*      db 24 ; reverse byte order
043FF1 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
043FF2 04 00       0372*      dw 4 ; size (4 bytes)
043FF4             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
043FF4             0374*  ; VDU 23,27,&20,targetBufferID%;
043FF4 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
043FF7 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
043FF9             0377*  ; VDU 23,27,&21,width%;height%;0
043FF9 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
043FFC 00 00       0379*  @width: dw 0x0000
043FFE 00 00       0380*  @height: dw 0x0000
044000 00          0381*      db 0x00 ; rgba8888 format
044001             0382*  @end:
044001             0383*  
044001             0384*  ; scratch variables
044001 00 00 00    0385*  bufferId0: dl 0x000000
044004 00 00 00    0386*  bufferId1: dl 0x000000
044007             0387*  
044007             0388*  ; load a vdu buffer from local memory
044007             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044007             0390*  vdu_load_buffer:
044007 ED 43 30 40 0391*      ld (@length),bc
       04          
04400C D5          0392*      push de ; save data pointer
04400D             0393*  ; send the vdu command string
04400D 7D          0394*      ld a,l
04400E 32 2D 40 04 0395*      ld (@bufferId),a
044012 7C          0396*      ld a,h
044013 32 2E 40 04 0397*      ld (@bufferId+1),a
044017 21 2A 40 04 0398*      ld hl,@cmd
04401B 01 08 00 00 0399*      ld bc,@end-@cmd
04401F 5B DF       0400*      rst.lil $18
044021             0401*  ; send the buffer data
044021 E1          0402*      pop hl ; pointer to data
044022 ED 4B 30 40 0403*      ld bc,(@length)
       04          
044027 5B DF       0404*      rst.lil $18 ; send it
044029 C9          0405*      ret
04402A             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04402A 17 00 A0    0407*  @cmd:       db 23,0,0xA0
04402D 00 00       0408*  @bufferId:	dw 0x0000
04402F 00          0409*  		    db 0 ; load buffer
044030 00 00       0410*  @length:	dw 0x0000
044032 00          0411*  @end: db 0 ; padding
044033             0412*  
044033             0413*  ; clear a buffer
044033             0414*  ; inputs: hl = bufferId
044033             0415*  vdu_clear_buffer:
044033 7D          0416*      ld a,l
044034 32 4B 40 04 0417*      ld (@bufferId),a
044038 7C          0418*      ld a,h
044039 32 4C 40 04 0419*      ld (@bufferId+1),a
04403D 21 48 40 04 0420*      ld hl,@cmd
044041 01 06 00 00 0421*      ld bc,@end-@cmd
044045 5B DF       0422*      rst.lil $18
044047 C9          0423*      ret
044048 17 00 A0    0424*  @cmd:       db 23,0,0xA0
04404B 00 00       0425*  @bufferId:	dw 0x0000
04404D 02          0426*  		    db 2 ; clear buffer
04404E             0427*  @end:
04404E             0428*  
04404E             0429*  vdu_clear_all_buffers:
04404E             0430*  ; clear all buffers
04404E 21 59 40 04 0431*      ld hl,@beg
044052 01 06 00 00 0432*      ld bc,@end-@beg
044056 5B DF       0433*      rst.lil $18
044058 C9          0434*      ret
044059 17 00 A0    0435*  @beg: db 23,0,$A0
04405C FF FF       0436*        dw -1 ; clear all buffers
04405E 02          0437*        db 2  ; command 2: clear a buffer
04405F             0438*  @end:
04405F             0439*  
04405F             0440*  ; Command 14: Consolidate blocks in a buffer
04405F             0441*  vdu_consolidate_buffer:
04405F             0442*  ; set parameters for vdu call
04405F 7D          0443*      ld a,l
044060 32 77 40 04 0444*      ld (@bufferId),a
044064 7C          0445*      ld a,h
044065 32 78 40 04 0446*      ld (@bufferId+1),a
044069 21 74 40 04 0447*      ld hl,@beg
04406D 01 06 00 00 0448*      ld bc,@end-@beg
044071 5B DF       0449*      rst.lil $18
044073 C9          0450*      ret
044074             0451*  ; VDU 23, 0, &A0, bufferId; 14
044074 17 00 A0    0452*  @beg: db 23,0,0xA0
044077 00 00       0453*  @bufferId: dw 0x0000
044079 0E          0454*             db 14
04407A             0455*  @end:
04407A             0456*  
04407A             0457*  ; load an image file to a buffer and make it a bitmap
04407A             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
04407A             0459*  vdu_load_img:
04407A             0460*  ; back up image type and dimension parameters
04407A 22 01 40 04 0461*      ld (bufferId0),hl
04407E F5          0462*      push af
04407F C5          0463*  	push bc
044080 D5          0464*  	push de
044081             0465*  ; load the image
044081 CD 9C 40 04 0466*  	call vdu_load_buffer_from_file
044085             0467*  ; now make it a bitmap
044085 2A 01 40 04 0468*      ld hl,(bufferId0)
044089 CD 5F 40 04 0469*      call vdu_consolidate_buffer
04408D 2A 01 40 04 0470*      ld hl,(bufferId0)
044091 CD 5C 3F 04 0471*      call vdu_buff_select
044095 D1          0472*  	pop de ; image height
044096 C1          0473*  	pop bc ; image width
044097 F1          0474*  	pop af ; image type
044098 C3 71 3F 04 0475*  	jp vdu_bmp_create ; will return to caller from there
04409C             0476*  
04409C             0477*  ; inputs: hl = bufferId; iy = pointer to filename
04409C             0478*  vdu_load_buffer_from_file:
04409C 22 01 40 04 0479*      ld (bufferId0),hl
0440A0             0480*  
0440A0             0481*  ; clear target buffer
0440A0 CD 33 40 04 0482*      call vdu_clear_buffer
0440A4             0483*  
0440A4             0484*  ; open the file in read mode
0440A4             0485*  ; Open a file
0440A4             0486*  ; HLU: Filename
0440A4             0487*  ;   C: Mode
0440A4             0488*  ; Returns:
0440A4             0489*  ;   A: Filehandle, or 0 if couldn't open
0440A4 FD E5       0490*  	push iy ; pointer to filename
0440A6 E1          0491*  	pop hl
0440A7 0E 01       0492*  	ld c,fa_read
0440A9             0493*      MOSCALL mos_fopen
0440A9 3E 0A       0001*M 			LD	A, function
0440AB 5B CF       0002*M 			RST.LIL	08h
0440AD 32 E8 40 04 0494*      ld (@filehandle),a
0440B1             0495*  
0440B1             0496*  @read_file:
0440B1             0497*  ; Read a block of data from a file
0440B1             0498*  ;   C: Filehandle
0440B1             0499*  ; HLU: Pointer to where to write the data to
0440B1             0500*  ; DEU: Number of bytes to read
0440B1             0501*  ; Returns:
0440B1             0502*  ; DEU: Number of bytes read
0440B1 3A E8 40 04 0503*      ld a,(@filehandle)
0440B5 4F          0504*      ld c,a
0440B6 21 00 E0 B7 0505*      ld hl,filedata
0440BA 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0440BE             0507*      MOSCALL mos_fread
0440BE 3E 1A       0001*M 			LD	A, function
0440C0 5B CF       0002*M 			RST.LIL	08h
0440C2             0508*  
0440C2             0509*  ; test de for zero bytes read
0440C2 21 00 00 00 0510*      ld hl,0
0440C6 AF          0511*      xor a ; clear carry
0440C7 ED 52       0512*      sbc hl,de
0440C9 CA DF 40 04 0513*      jp z,@close_file
0440CD             0514*  
0440CD             0515*  ; load a vdu buffer from local memory
0440CD             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0440CD 2A 01 40 04 0517*      ld hl,(bufferId0)
0440D1 D5          0518*      push de ; chunksize
0440D2 C1          0519*      pop bc
0440D3 11 00 E0 B7 0520*      ld de,filedata
0440D7 CD 07 40 04 0521*      call vdu_load_buffer
0440DB             0522*  
0440DB             0523*  ; read the next block
0440DB C3 B1 40 04 0524*      jp @read_file
0440DF             0525*  
0440DF             0526*  ; close the file
0440DF             0527*  @close_file:
0440DF 3A E8 40 04 0528*      ld a,(@filehandle)
0440E3             0529*      MOSCALL mos_fclose
0440E3 3E 0B       0001*M 			LD	A, function
0440E5 5B CF       0002*M 			RST.LIL	08h
0440E7 C9          0530*      ret ; vdu_load_buffer_from_file
0440E8             0531*  
0440E8 00          0532*  @filehandle: db 0 ; file handle
0440E9 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
0440EC             0534*  
0440EC 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
0440EF             0536*  
0440EF             0537*  ; File information structure (FILINFO)
0440EF             0538*  @filinfo:
0440EF 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0440F3 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0440F5 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0440F7 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0440F8 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
044105 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044205             0044       include "vdu_plot.inc"
044205             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044205             0002*  ; PLOT code 	(Decimal) 	Effect
044205             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
044205             0004*  plot_sl_both: equ 0x00
044205             0005*  
044205             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
044205             0007*  plot_sl_first: equ 0x08
044205             0008*  
044205             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
044205             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
044205             0011*  
044205             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
044205             0013*  plot_sl_last: equ 0x20
044205             0014*  
044205             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
044205             0016*  plot_sl_none: equ 0x28
044205             0017*  
044205             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
044205             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
044205             0020*  
044205             0021*  ; &40-&47 	64-71 	Point plot
044205             0022*  plot_pt: equ 0x40
044205             0023*  
044205             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
044205             0025*  plot_lf_lr_non_bg: equ 0x48
044205             0026*  
044205             0027*  ; &50-&57 	80-87 	Triangle fill
044205             0028*  plot_tf: equ 0x50
044205             0029*  
044205             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
044205             0031*  plot_lf_r_bg: equ 0x58
044205             0032*  
044205             0033*  ; &60-&67 	96-103 	Rectangle fill
044205             0034*  plot_rf: equ 0x60
044205             0035*  
044205             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
044205             0037*  plot_lf_lr_fg: equ 0x60
044205             0038*  
044205             0039*  ; &70-&77 	112-119 	Parallelogram fill
044205             0040*  plot_pf: equ 0x70
044205             0041*  
044205             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
044205             0043*  plot_lf_r_non_fg: equ 0x78
044205             0044*  
044205             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
044205             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
044205             0047*  
044205             0048*  ; &90-&97 	144-151 	Circle outline
044205             0049*  plot_co: equ 0x90
044205             0050*  
044205             0051*  ; &98-&9F 	152-159 	Circle fill
044205             0052*  plot_cf: equ 0x98
044205             0053*  
044205             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
044205             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
044205             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
044205             0057*  
044205             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
044205             0059*  plot_rcm: equ 0xB8
044205             0060*  
044205             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
044205             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
044205             0063*  ; &D0-&D7 	208-215 	Not defined
044205             0064*  ; &D8-&DF 	216-223 	Not defined
044205             0065*  ; &E0-&E7 	224-231 	Not defined
044205             0066*  
044205             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
044205             0068*  plot_bmp: equ 0xE8
044205             0069*  
044205             0070*  ; &F0-&F7 	240-247 	Not defined
044205             0071*  ; &F8-&FF 	248-255 	Not defined
044205             0072*  
044205             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
044205             0074*  ; Agon Console8 VDP 2.2.0
044205             0075*  
044205             0076*  ; Within each group of eight plot codes, the effects are as follows:
044205             0077*  ; Plot code 	Effect
044205             0078*  ; 0 	Move relative
044205             0079*  mv_rel: equ 0
044205             0080*  
044205             0081*  ; 1 	Plot relative in current foreground colour
044205             0082*  dr_rel_fg: equ 1
044205             0083*  
044205             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
044205             0085*  ; 3 	Plot relative in current background colour
044205             0086*  dr_rel_bg: equ 3
044205             0087*  
044205             0088*  ; 4 	Move absolute
044205             0089*  mv_abs: equ 4
044205             0090*  
044205             0091*  ; 5 	Plot absolute in current foreground colour
044205             0092*  dr_abs_fg: equ 5
044205             0093*  
044205             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
044205             0095*  ; 7 	Plot absolute in current background colour
044205             0096*  dr_abs_bg: equ 7
044205             0097*  
044205             0098*  ; Codes 0-3 use the position data provided as part of the command
044205             0099*  ; as a relative position, adding the position given to the current
044205             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
044205             0101*  ; as part of the command as an absolute position, setting the current
044205             0102*  ; graphical cursor position to the position given.
044205             0103*  
044205             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
044205             0105*  ; current pixel colour. These operations cannot currently be supported
044205             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
044205             0107*  ; supported. Support for these codes may be added in a future version
044205             0108*  ; of the VDP firmware.
044205             0109*  
044205             0110*  ; 16 colour palette constants
044205             0111*  c_black: equ 0
044205             0112*  c_red_dk: equ 1
044205             0113*  c_green_dk: equ 2
044205             0114*  c_yellow_dk: equ 3
044205             0115*  c_blue_dk: equ 4
044205             0116*  c_magenta_dk: equ 5
044205             0117*  c_cyan_dk: equ 6
044205             0118*  c_grey: equ 7
044205             0119*  c_grey_dk: equ 8
044205             0120*  c_red: equ 9
044205             0121*  c_green: equ 10
044205             0122*  c_yellow: equ 11
044205             0123*  c_blue: equ 12
044205             0124*  c_magenta: equ 13
044205             0125*  c_cyan: equ 14
044205             0126*  c_white: equ 15
044205             0127*  
044205             0128*  ; VDU 25, mode, x; y;: PLOT command
044205             0129*  ; inputs: a=mode, bc=x0, de=y0
044205             0130*  vdu_plot:
044205 32 1F 42 04 0131*      ld (@mode),a
044209 ED 43 20 42 0132*      ld (@x0),bc
       04          
04420E ED 53 22 42 0133*      ld (@y0),de
       04          
044213 21 1E 42 04 0134*  	ld hl,@cmd
044217 01 06 00 00 0135*  	ld bc,@end-@cmd
04421B 5B DF       0136*  	rst.lil $18
04421D C9          0137*  	ret
04421E 19          0138*  @cmd:   db 25
04421F 00          0139*  @mode:  db 0
044220 00 00       0140*  @x0: 	dw 0
044222 00 00       0141*  @y0: 	dw 0
044224 00          0142*  @end:   db 0 ; extra byte to soak up deu
044225             0143*  
044225             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044225             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
044225             0146*  ; VDU 25, mode, x; y;: PLOT command
044225             0147*  ; inputs: bc=x0, de=y0
044225             0148*  ; prerequisites: vdu_buff_select
044225             0149*  vdu_plot_bmp:
044225 ED 43 3C 42 0150*      ld (@x0),bc
       04          
04422A ED 53 3E 42 0151*      ld (@y0),de
       04          
04422F 21 3A 42 04 0152*  	ld hl,@cmd
044233 01 06 00 00 0153*  	ld bc,@end-@cmd
044237 5B DF       0154*  	rst.lil $18
044239 C9          0155*  	ret
04423A 19          0156*  @cmd:   db 25
04423B ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04423C 00 00       0158*  @x0: 	dw 0x0000
04423E 00 00       0159*  @y0: 	dw 0x0000
044240 00          0160*  @end:   db 0x00 ; padding
044241             0161*  
044241             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044241             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
044241             0164*  ; VDU 25, mode, x; y;: PLOT command
044241             0165*  ; inputs: bc=x0, de=y0
044241             0166*  ; USING 16.8 FIXED POINT COORDINATES
044241             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
044241             0168*  ;   the fractional portiion of the inputs are truncated
044241             0169*  ;   leaving only the 16-bit integer portion
044241             0170*  ; prerequisites: vdu_buff_select
044241             0171*  vdu_plot_bmp168:
044241             0172*  ; populate in the reverse of normal to keep the
044241             0173*  ; inputs from stomping on each other
044241 ED 53 5F 42 0174*      ld (@y0-1),de
       04          
044246 ED 43 5D 42 0175*      ld (@x0-1),bc
       04          
04424B 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
04424D 32 5D 42 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
044251 21 5C 42 04 0178*  	ld hl,@cmd
044255 01 06 00 00 0179*  	ld bc,@end-@cmd
044259 5B DF       0180*  	rst.lil $18
04425B C9          0181*  	ret
04425C 19          0182*  @cmd:   db 25
04425D ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04425E 00 00       0184*  @x0: 	dw 0x0000
044260 00 00       0185*  @y0: 	dw 0x0000
044262             0186*  @end:  ; no padding required b/c we shifted de right
044262             0187*  
044262             0188*  ; draw a filled rectangle
044262             0189*  vdu_plot_rf:
044262 ED 43 89 42 0190*      ld (@x0),bc
       04          
044267 ED 53 8B 42 0191*      ld (@y0),de
       04          
04426C DD 22 8F 42 0192*      ld (@x1),ix
       04          
044271 FD 22 91 42 0193*      ld (@y1),iy
       04          
044276 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
044278 32 8D 42 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04427C 21 87 42 04 0196*  	ld hl,@cmd0
044280 01 0C 00 00 0197*  	ld bc,@end-@cmd0
044284 5B DF       0198*  	rst.lil $18
044286 C9          0199*      ret
044287 19          0200*  @cmd0:  db 25 ; plot
044288 04          0201*  @arg0:  db plot_sl_both+mv_abs
044289 00 00       0202*  @x0:    dw 0x0000
04428B 00 00       0203*  @y0:    dw 0x0000
04428D 19          0204*  @cmd1:  db 25 ; plot
04428E 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04428F 00 00       0206*  @x1:    dw 0x0000
044291 00 00       0207*  @y1:    dw 0x0000
044293 00          0208*  @end:   db 0x00 ; padding
044294             0209*  
044294             0210*  ; draw a filled circle
044294             0211*  vdu_plot_cf:
044294 ED 43 BB 42 0212*      ld (@x0),bc
       04          
044299 ED 53 BD 42 0213*      ld (@y0),de
       04          
04429E DD 22 C1 42 0214*      ld (@x1),ix
       04          
0442A3 FD 22 C3 42 0215*      ld (@y1),iy
       04          
0442A8 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0442AA 32 BF 42 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0442AE 21 B9 42 04 0218*  	ld hl,@cmd0
0442B2 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0442B6 5B DF       0220*  	rst.lil $18
0442B8 C9          0221*      ret
0442B9 19          0222*  @cmd0:  db 25 ; plot
0442BA 04          0223*  @arg0:  db plot_sl_both+mv_abs
0442BB 00 00       0224*  @x0:    dw 0x0000
0442BD 00 00       0225*  @y0:    dw 0x0000
0442BF 19          0226*  @cmd1:  db 25 ; plot
0442C0 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0442C1 00 00       0228*  @x1:    dw 0x0000
0442C3 00 00       0229*  @y1:    dw 0x0000
0442C5 00          0230*  @end:   db 0x00 ; padding
0442C6             0045       include "vdu_sprites.inc"
0442C6             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
0442C6             0002*  ; the VDP can support up to 256 sprites. They must be defined
0442C6             0003*  ; contiguously, and so the first sprite is sprite 0.
0442C6             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
0442C6             0005*  ; Once a selection of sprites have been defined, you can activate
0442C6             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
0442C6             0007*  ; of sprites to activate. This will activate the first n sprites,
0442C6             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
0442C6             0009*  
0442C6             0010*  ; A single sprite can have multiple "frames", referring to
0442C6             0011*  ; different bitmaps.
0442C6             0012*  ; (These bitmaps do not need to be the same size.)
0442C6             0013*  ; This allows a sprite to include an animation sequence,
0442C6             0014*  ; which can be stepped through one frame at a time, or picked
0442C6             0015*  ; in any order.
0442C6             0016*  
0442C6             0017*  ; Any format of bitmap can be used as a sprite frame. It should
0442C6             0018*  ; be noted however that "native" format bitmaps are not
0442C6             0019*  ; recommended for use as sprite frames, as they cannot get
0442C6             0020*  ; erased from the screen. (As noted above, the "native" bitmap
0442C6             0021*  ; format is not really intended for general use.) This is part
0442C6             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
0442C6             0023*  ; screen are now stored in RGBA2222 format.
0442C6             0024*  
0442C6             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
0442C6             0026*  ; and then later shown again.
0442C6             0027*  
0442C6             0028*  ; Moving sprites around the screen is done by changing the
0442C6             0029*  ; position of the sprite. This can be done either by setting
0442C6             0030*  ; the absolute position of the sprite, or by moving the sprite
0442C6             0031*  ; by a given number of pixels. (Sprites are positioned using
0442C6             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
0442C6             0033*  ; In the current sprite system, sprites will not update their
0442C6             0034*  ; position on-screen until either another drawing operation is
0442C6             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
0442C6             0036*  
0442C6             0037*  ; VDU 23, 27, 4, n: Select sprite n
0442C6             0038*  ; inputs: a is the 8-bit sprite id
0442C6             0039*  vdu_sprite_select:
0442C6 32 D8 42 04 0040*      ld (@sprite),a
0442CA 21 D5 42 04 0041*      ld hl,@cmd
0442CE 01 04 00 00 0042*      ld bc,@end-@cmd
0442D2 5B DF       0043*      rst.lil $18
0442D4 C9          0044*      ret
0442D5 17 1B 04    0045*  @cmd:    db 23,27,4
0442D8 00          0046*  @sprite: db 0x00
0442D9             0047*  @end:
0442D9             0048*  
0442D9             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
0442D9             0050*  ; inputs: none
0442D9             0051*  ; prerequisites: vdu_sprite_select
0442D9             0052*  vdu_sprite_clear_frames:
0442D9 21 E4 42 04 0053*      ld hl,@cmd
0442DD 01 03 00 00 0054*      ld bc,@end-@cmd
0442E1 5B DF       0055*      rst.lil $18
0442E3 C9          0056*      ret
0442E4 17 1B 05    0057*  @cmd: db 23,27,5
0442E7             0058*  @end:
0442E7             0059*  
0442E7             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0442E7             0061*  ; inputs: a is the 8-bit bitmap number
0442E7             0062*  ; prerequisites: vdu_sprite_select
0442E7             0063*  vdu_sprite_add_bmp:
0442E7 32 F9 42 04 0064*      ld (@bmp),a
0442EB 21 F6 42 04 0065*      ld hl,@cmd
0442EF 01 04 00 00 0066*      ld bc,@end-@cmd
0442F3 5B DF       0067*      rst.lil $18
0442F5 C9          0068*      ret
0442F6 17 1B 06    0069*  @cmd: db 23,27,6
0442F9 00          0070*  @bmp: db 0x00
0442FA             0071*  @end:
0442FA             0072*  
0442FA             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0442FA             0074*  ; inputs: a is the number of sprites to activate
0442FA             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0442FA             0076*  vdu_sprite_activate:
0442FA 32 0C 43 04 0077*      ld (@num),a
0442FE 21 09 43 04 0078*      ld hl,@cmd
044302 01 04 00 00 0079*      ld bc,@end-@cmd
044306 5B DF       0080*      rst.lil $18
044308 C9          0081*      ret
044309 17 1B 07    0082*  @cmd: db 23,27,7
04430C 00          0083*  @num: db 0x00
04430D             0084*  @end:
04430D             0085*  
04430D             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
04430D             0087*  ; inputs: none
04430D             0088*  ; prerequisites: vdu_sprite_select
04430D             0089*  vdu_sprite_next_frame:
04430D 21 18 43 04 0090*      ld hl,@cmd
044311 01 03 00 00 0091*      ld bc,@end-@cmd
044315 5B DF       0092*      rst.lil $18
044317 C9          0093*      ret
044318 17 1B 08    0094*  @cmd: db 23,27,8
04431B             0095*  @end:
04431B             0096*  
04431B             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04431B             0098*  ; inputs: none
04431B             0099*  ; prerequisites: vdu_sprite_select
04431B             0100*  vdu_sprite_prev_frame:
04431B 21 26 43 04 0101*      ld hl,@cmd
04431F 01 03 00 00 0102*      ld bc,@end-@cmd
044323 5B DF       0103*      rst.lil $18
044325 C9          0104*      ret
044326 17 1B 09    0105*  @cmd: db 23,27,9
044329             0106*  @end:
044329             0107*  
044329             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
044329             0109*  ; inputs: a is frame number to select
044329             0110*  ; prerequisites: vdu_sprite_select
044329             0111*  vdu_sprite_select_frame:
044329 32 3B 43 04 0112*      ld (@frame),a
04432D 21 38 43 04 0113*      ld hl,@cmd
044331 01 04 00 00 0114*      ld bc,@end-@cmd
044335 5B DF       0115*      rst.lil $18
044337 C9          0116*      ret
044338 17 1B 0A    0117*  @cmd:    db 23,27,10
04433B 00          0118*  @frame:  db 0x00
04433C             0119*  @end:
04433C             0120*  
04433C             0121*  ; VDU 23, 27, 11: Show current sprite
04433C             0122*  ; inputs: none
04433C             0123*  ; prerequisites: vdu_sprite_select
04433C             0124*  vdu_sprite_show:
04433C 21 47 43 04 0125*      ld hl,@cmd
044340 01 03 00 00 0126*      ld bc,@end-@cmd
044344 5B DF       0127*      rst.lil $18
044346 C9          0128*      ret
044347 17 1B 0B    0129*  @cmd: db 23,27,11
04434A             0130*  @end:
04434A             0131*  
04434A             0132*  ; VDU 23, 27, 12: Hide current sprite
04434A             0133*  ; inputs: none
04434A             0134*  ; prerequisites: vdu_sprite_select
04434A             0135*  vdu_sprite_hide:
04434A 21 55 43 04 0136*      ld hl,@cmd
04434E 01 03 00 00 0137*      ld bc,@end-@cmd
044352 5B DF       0138*      rst.lil $18
044354 C9          0139*      ret
044355 17 1B 0C    0140*  @cmd: db 23,27,12
044358             0141*  @end:
044358             0142*  
044358             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044358             0144*  ; inputs: bc is x coordinate, de is y coordinate
044358             0145*  ; prerequisites: vdu_sprite_select
044358             0146*  vdu_sprite_move_abs:
044358 ED 43 70 43 0147*      ld (@xpos),bc
       04          
04435D ED 53 72 43 0148*      ld (@ypos),de
       04          
044362 21 6D 43 04 0149*      ld hl,@cmd
044366 01 07 00 00 0150*      ld bc,@end-@cmd
04436A 5B DF       0151*      rst.lil $18
04436C C9          0152*      ret
04436D 17 1B 0D    0153*  @cmd:  db 23,27,13
044370 00 00       0154*  @xpos: dw 0x0000
044372 00 00       0155*  @ypos: dw 0x0000
044374 00          0156*  @end:  db 0x00 ; padding
044375             0157*  
044375             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
044375             0159*  ; inputs: bc is x coordinate, de is y coordinate
044375             0160*  ; prerequisites: vdu_sprite_select
044375             0161*  vdu_sprite_move_rel:
044375 ED 43 8D 43 0162*      ld (@dx),bc
       04          
04437A ED 53 8F 43 0163*      ld (@dy),de
       04          
04437F 21 8A 43 04 0164*      ld hl,@cmd
044383 01 07 00 00 0165*      ld bc,@end-@cmd
044387 5B DF       0166*      rst.lil $18
044389 C9          0167*      ret
04438A 17 1B 0E    0168*  @cmd: db 23,27,14
04438D 00 00       0169*  @dx:  dw 0x0000
04438F 00 00       0170*  @dy:  dw 0x0000
044391 00          0171*  @end: db 0x00 ; padding
044392             0172*  
044392             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044392             0174*  ; USING 16.8 FIXED POINT COORDINATES
044392             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
044392             0176*  ;   the fractional portiion of the inputs are truncated
044392             0177*  ;   leaving only the 16-bit integer portion
044392             0178*  ; prerequisites: vdu_sprite_select
044392             0179*  vdu_sprite_move_abs168:
044392             0180*  ; offset inputs by the gfx origin
044392             0181*  ; y coordinate
044392 21 00 00 00 0182*      ld hl,origin_top*256
044396 19          0183*      add hl,de
044397 22 B9 43 04 0184*      ld (@ypos-1),hl
04439B             0185*  ; x coordinate
04439B 21 00 80 00 0186*      ld hl,origin_left*256
04439F 09          0187*      add hl,bc
0443A0 22 B7 43 04 0188*      ld (@xpos-1),hl
0443A4             0189*  ; prepare vdu command
0443A4 3E 0D       0190*      ld a,13       ; restore the final byte of the command
0443A6 32 B7 43 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
0443AA 21 B5 43 04 0192*      ld hl,@cmd
0443AE 01 07 00 00 0193*      ld bc,@end-@cmd
0443B2 5B DF       0194*      rst.lil $18
0443B4 C9          0195*      ret
0443B5 17 1B 0D    0196*  @cmd:  db 23,27,13
0443B8 00 00       0197*  @xpos: dw 0x0000
0443BA 00 00       0198*  @ypos: dw 0x0000
0443BC             0199*  @end:  ; no padding required b/c we shifted de right
0443BC             0200*  
0443BC             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0443BC             0202*  ; USING 16.8 FIXED POINT COORDINATES
0443BC             0203*  ; inputs: ub.c is dx, ud.e is dy
0443BC             0204*  ;   the fractional portiion of the inputs are truncated
0443BC             0205*  ;   leaving only the 16-bit integer portion
0443BC             0206*  ; prerequisites: vdu_sprite_select
0443BC             0207*  vdu_sprite_move_rel168:
0443BC             0208*  ; populate in the reverse of normal to keep the
0443BC             0209*  ; inputs from stomping on each other
0443BC ED 53 DB 43 0210*      ld (@dy-1),de
       04          
0443C1 ED 43 D9 43 0211*      ld (@dx-1),bc
       04          
0443C6 3E 0E       0212*      ld a,14       ; restore the final byte of the command
0443C8 32 D9 43 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
0443CC 21 D7 43 04 0214*      ld hl,@cmd
0443D0 01 07 00 00 0215*      ld bc,@end-@cmd
0443D4 5B DF       0216*      rst.lil $18
0443D6 C9          0217*      ret
0443D7 17 1B 0E    0218*  @cmd:  db 23,27,14
0443DA 00 00       0219*  @dx: dw 0x0000
0443DC 00 00       0220*  @dy: dw 0x0000
0443DE             0221*  @end:  ; no padding required b/c we shifted de right
0443DE             0222*  
0443DE             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
0443DE             0224*  ; inputs: none
0443DE             0225*  vdu_sprite_update:
0443DE 21 E9 43 04 0226*      ld hl,@cmd
0443E2 01 03 00 00 0227*      ld bc,@end-@cmd
0443E6 5B DF       0228*      rst.lil $18
0443E8 C9          0229*      ret
0443E9 17 1B 0F    0230*  @cmd: db 23,27,15
0443EC             0231*  @end:
0443EC             0232*  
0443EC             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0443EC             0234*  ; inputs: none
0443EC             0235*  vdu_sprite_bmp_reset:
0443EC 21 F7 43 04 0236*      ld hl,@cmd
0443F0 01 03 00 00 0237*      ld bc,@end-@cmd
0443F4 5B DF       0238*      rst.lil $18
0443F6 C9          0239*      ret
0443F7 17 1B 10    0240*  @cmd: db 23,27,16
0443FA             0241*  @end:
0443FA             0242*  
0443FA             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0443FA             0244*  ; inputs: none
0443FA             0245*  vdu_sprite_reset:
0443FA 21 05 44 04 0246*      ld hl,@cmd
0443FE 01 03 00 00 0247*      ld bc,@end-@cmd
044402 5B DF       0248*      rst.lil $18
044404 C9          0249*      ret
044405 17 1B 11    0250*  @cmd: db 23,27,17
044408             0251*  @end:
044408             0252*  
044408             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
044408             0254*  ; inputs: a is the GCOL paint mode
044408             0255*  ; prerequisites: vdu_sprite_select
044408             0256*  vdu_sprite_set_gcol:
044408 32 1A 44 04 0257*      ld (@mode),a
04440C 21 17 44 04 0258*      ld hl,@cmd
044410 01 04 00 00 0259*      ld bc,@end-@cmd
044414 5B DF       0260*      rst.lil $18
044416 C9          0261*      ret
044417 17 1B 12    0262*  @cmd:  db 23,27,18
04441A 00          0263*  @mode: db 0x00
04441B             0264*  @end:
04441B             0265*  
04441B             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
04441B             0267*  ; inputs: hl=bufferId
04441B             0268*  ; prerequisites: vdu_sprite_select
04441B             0269*  vdu_sprite_add_buff:
04441B 22 2D 44 04 0270*      ld (@bufferId),hl
04441F 21 2A 44 04 0271*      ld hl,@cmd
044423 01 05 00 00 0272*      ld bc,@end-@cmd
044427 5B DF       0273*      rst.lil $18
044429 C9          0274*      ret
04442A 17 1B 26    0275*  @cmd:      db 23,27,0x26
04442D 00 00       0276*  @bufferId: dw 0x0000
04442F 00          0277*  @end:      db 0x00 ; padding
044430             0046   
044430 57 65 6C 63 0047   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
04444B 4C 6F 61 64 0048   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044456 4C 6F 61 64 0049   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
044464 50 72 65 73 0050   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
04447F             0051   
04447F             0052   init:
04447F             0053   ; clear all buffers
04447F CD 4E 40 04 0054       call vdu_clear_all_buffers
044483             0055   
044483             0056   ; set up the display
044483 3E 08       0057       ld a,8;+128 ; 136   320   240   64    60hz double-buffered
044485 CD 38 3F 04 0058       call vdu_set_screen_mode
044489 AF          0059       xor a
04448A CD 49 3F 04 0060       call vdu_set_scaling
04448E             0061   
04448E             0062   ; ; enable additional audio channels
04448E             0063   ; 	call vdu_enable_channels
04448E             0064   
04448E             0065   ; set text background color
04448E 3E 9A       0066       ld a,26+128 ; violet
044490 CD A0 3E 04 0067       call vdu_colour_text
044494             0068   
044494             0069   ; set text foreground color
044494 3E 2F       0070       ld a,47 ; aaaaff lavenderish
044496 CD A0 3E 04 0071       call vdu_colour_text
04449A             0072   
04449A             0073   ; set gfx bg color
04449A AF          0074       xor a ; plotting mode 0
04449B 3E 9A       0075       ld a,26+128 ; violet
04449D CD B1 3E 04 0076       call vdu_gcol
0444A1 CD 6F 3E 04 0077       call vdu_cls
0444A5             0078   
0444A5             0079   ; set the cursor off
0444A5 CD 37 3E 04 0080       call vdu_cursor_off
0444A9             0081   
0444A9             0082   ; VDU 28, left, bottom, right, top: Set text viewport **
0444A9             0083   ; MIND THE LITTLE-ENDIANESS
0444A9             0084   ; inputs: c=left,b=bottom,e=right,d=top
0444A9 0E 00       0085       ld c,0 ; left
0444AB 16 1D       0086       ld d,29 ; top
0444AD 1E 27       0087       ld e,39 ; right
0444AF 06 1D       0088       ld b,29; bottom
0444B1 CD C8 3E 04 0089       call vdu_set_txt_viewport
0444B5             0090   
0444B5             0091   ; print loading ui message
0444B5 21 4B 44 04 0092       ld hl,loading_ui
0444B9 CD 77 00 04 0093       call printString
0444BD CD 74 3E 04 0094       call vdu_flip
0444C1             0095   
0444C1             0096   ; load UI images
0444C1 CD F7 13 04 0097       call load_ui_images
0444C5             0098   
0444C5             0099   ; ; load fonts ; TODO
0444C5             0100   ; 	call load_font_rc
0444C5             0101   
0444C5             0102   ; load sprites
0444C5 CD A0 14 04 0103       call img_load_init ; sets up the animated load screen
0444C9 CD 12 14 04 0104       call load_sprite_images
0444CD             0105   
0444CD             0106   ; ; load sound effects ; TODO
0444CD             0107   ; 	ld bc,SFX_num_buffers
0444CD             0108   ; 	ld hl,SFX_buffer_id_lut
0444CD             0109   ; 	ld (cur_buffer_id_lut),hl
0444CD             0110   ; 	ld hl,SFX_load_routines_table
0444CD             0111   ; 	ld (cur_load_jump_table),hl
0444CD             0112   ; 	call sfx_load_main
0444CD             0113   
0444CD             0114   ; print loading complete message and wait for user keypress
0444CD CD 6F 3E 04 0115       call vdu_cls
0444D1 21 64 44 04 0116       ld hl,loading_complete
0444D5 CD 77 00 04 0117       call printString
0444D9 CD 74 3E 04 0118       call vdu_flip
0444DD CD 15 06 04 0119       call waitKeypress
0444E1             0120   
0444E1             0121   ; set up display for gameplay
0444E1             0122       ; ld a,8
0444E1 3E 14       0123       ld a,20
0444E3 CD 38 3F 04 0124       call vdu_set_screen_mode
0444E7 AF          0125       xor a
0444E8 CD 49 3F 04 0126       call vdu_set_scaling
0444EC CD 37 3E 04 0127       call vdu_cursor_off
0444F0             0128   ; plot bezel art
0444F0 21 00 00 00 0129       ld hl,BUF_BEZEL_L
0444F4 CD 5C 3F 04 0130       call vdu_buff_select
0444F8 01 00 00 00 0131       ld bc,0
0444FC 11 00 00 00 0132       ld de,0
044500 CD 25 42 04 0133       call vdu_plot_bmp
044504 21 01 00 00 0134       ld hl,BUF_BEZEL_R
044508 CD 5C 3F 04 0135       call vdu_buff_select
04450C 01 80 01 00 0136       ld bc,384
044510 11 00 00 00 0137       ld de,0
044514 CD 25 42 04 0138       call vdu_plot_bmp
044518             0139   ; set gfx origin and viewport to playing field window
044518 01 80 00 00 0140       ld bc,origin_left
04451C 11 00 00 00 0141       ld de,origin_top
044520 CD F4 3E 04 0142       call vdu_set_gfx_origin
044524 01 00 00 00 0143       ld bc,field_left
044528 11 00 00 00 0144       ld de,field_top
04452C DD 21 FF 00 0145       ld ix,field_right
       00          
044531 FD 21 7F 01 0146       ld iy,field_bottom
       00          
044536 CD 0F 3F 04 0147       call vdu_set_gfx_viewport
04453A             0148   ; set background color
04453A 3E 9A       0149       ld a,26+128 ; violet
04453C CD B1 3E 04 0150       call vdu_gcol
044540 CD 82 3E 04 0151       call vdu_clg
044544             0152   ; VDU 28, left, bottom, right, top: Set text viewport **
044544 0E 00       0153       ld c,0 ; left
044546 16 00       0154       ld d,0 ; top
044548 1E 3E       0155       ld e,62 ; right
04454A 06 07       0156       ld b,7; bottom
04454C CD C8 3E 04 0157       call vdu_set_txt_viewport
044550             0158   
044550 C9          0159       ret
044551             0160   
044551             0161   
044551             0162   
044551             0163   main:
044551             0164   ; start a new game
044551 CD 7B 45 04 0165       call new_game
044555             0166   
044555             0167   main_loop:
044555             0168   ; scroll tiles
044555 CD 9B 3B 04 0169       call tiles_plot
044559             0170   
044559             0171   ; get player input and update sprite position
044559 CD 0E 37 04 0172       call player_input
04455D             0173   
04455D             0174   ; move enemies
04455D CD AA 07 04 0175       call move_enemies
044561             0176   
044561             0177   ; wait for the next vblank mitigate flicker and for loop timing
044561 CD E3 3E 04 0178       call vdu_vblank
044565             0179   
044565             0180   ; poll keyboard
044565 3E 08       0181       ld a, $08 ; code to send to MOS
044567 5B CF       0182       rst.lil $08 ; get IX pointer to System Variables
044569             0183   
044569 DD 7E 05    0184       ld a, (ix + $05) ; get ASCII code of key pressed
04456C FE 1B       0185       cp 27 ; check if 27 (ascii code for ESC)
04456E CA 76 45 04 0186       jp z, main_end ; if pressed, jump to exit
044572             0187   
044572 C3 55 45 04 0188       jp main_loop
044576             0189   
044576             0190   main_end:
044576 CD 29 3E 04 0191       call vdu_cursor_on
04457A C9          0192       ret
04457B             0193   
04457B             0194   new_game:
04457B             0195   ; initialize sprites
04457B CD 6A 3A 04 0196       call sprites_init
04457F             0197   
04457F             0198   ; initialize the first level
04457F AF          0199       xor a
044580 32 50 3B 04 0200       ld (cur_level),a
044584 CD 50 3C 04 0201       call init_level
044588             0202   
044588             0203   ; initialize player
044588 CD CF 36 04 0204       call player_init
04458C             0205   
04458C             0206   ; spawn an enemy sprite
04458C 06 10       0207       ld b,table_max_records
04458E             0208   @spawn_enemy_loop:
04458E C5          0209       push bc
04458F CD 8C 08 04 0210       call enemy_init_from_landing_pad
044593 C1          0211       pop bc
044594 10 F8       0212       djnz @spawn_enemy_loop
044596             0213   
044596 C9          0214       ret
044597             0215   
044597             0216   ; ; ###### INITIALIZE GAME #######
044597             0217   ; ; clear the screen
044597             0218   ;     ld a,3
044597             0219   ;     out (81h),a
044597             0220   
044597             0221   ; ; reset the sprite table
044597             0222   ;     xor a
044597             0223   ;     ld (table_active_sprites),a
044597             0224   ;     ld hl,table_limit
044597             0225   ;     ld (table_base),hl
044597             0226   ;     ld (table_pointer),hl
044597             0227   
044597             0228   ; ; draw a starfield over the entire screen
044597             0229   ;     ld b,#50 ; first row of visible screen
044597             0230   ; new_game_draw_stars_loop:
044597             0231   ;     push bc
044597             0232   ;     call draw_stars
044597             0233   ;     pop bc
044597             0234   ;     ld a,#10
044597             0235   ;     add a,b
044597             0236   ;     ld b,a
044597             0237   ;     jr nz,new_game_draw_stars_loop
044597             0238   
044597             0239   ; ; ; print a welcome message
044597             0240   ; ;     ld de,msg_welcome
044597             0241   ; ;     ld hl,#581C
044597             0242   ; ;     ld c,218 ; a bright pastel purple d677e3
044597             0243   ; ;     call print_string
044597             0244   
044597             0245   ; ; push all that to frame buffer
044597             0246   ;     ld a,#01 ; send video to frame buffer
044597             0247   ;     out (81h),a
044597             0248   
044597             0249   ; ; reset score, lives, shields
044597             0250   ;     xor a
044597             0251   ;     ld hl,player_score
044597             0252   ;     ld (hl),a ; player_score 0
044597             0253   ;     inc hl
044597             0254   ;     ld (hl),a ; player_score 1
044597             0255   ;     inc hl
044597             0256   ;     ld (hl),a ; player_score 3
044597             0257   ;     inc hl
044597             0258   ;     ld a,16
044597             0259   ;     ld (hl),a ; player_shields
044597             0260   ;     inc hl
044597             0261   ;     ld (hl),a ; player_max_shields
044597             0262   ;     inc hl
044597             0263   ;     ld a,3
044597             0264   ;     ld (hl),a ; player_ships
044597             0265   ;     inc hl
044597             0266   
044597             0267   ; ; initialize first level
044597             0268   ;     ld a,1 ; levels are zero-based, so this will wrap around
044597             0269   ;     ld (cur_level),a
044597             0270   ;     ld a,3 ; set max enemy sprites to easy street
044597             0271   ;     ld (max_enemy_sprites),a
044597             0272   ;     call dt_next_level
044597             0273   ;     call dt
044597             0274   
044597             0275   ; ; spawn our intrepid hero
044597             0276   ;     call player_init
044597             0277   
044597             0278   
044597             0279   ; ; #### BEGIN GAME MAIN LOOP ####
044597             0280   ; main_loop:
044597             0281   ; ; ; debug: start execution counter
044597             0282   ; ;     ld a,1
044597             0283   ; ;     out (#e0),a ; start counting instructions
044597             0284   
044597             0285   ; ; refresh background from frame buffer
044597             0286   ;     ld a,#02
044597             0287   ;     out (81h),a
044597             0288   ;     call move_background ; now move it
044597             0289   ;     ld a,#01
044597             0290   ;     out (81h),a ; save it back to buffer
044597             0291   ; ; do all the things
044597             0292   ;     call move_enemies
044597             0293   ;     call player_move
044597             0294   ;     call laser_control
044597             0295   ;     call print_score
044597             0296   ;     call draw_shields
044597             0297   ;     call draw_lives
044597             0298   ; ; ; debug: stop execution counter and print results
044597             0299   ; ;     ld a,0
044597             0300   ; ;     out (#e0),a ; stop counting instructions
044597             0301   
044597             0302   ; ; ; debug: start execution counter
044597             0303   ; ;     ld a,1
044597             0304   ; ;     out (#e0),a ; start counting instructions
044597             0305   
044597             0306   ;     call vdu_vblank
044597             0307   ; ; ; debug: stop execution counter and print results
044597             0308   ; ;     ld a,0
044597             0309   ; ;     out (#e0),a ; stop counting instructions
044597             0310   
044597             0311   ;     jr main_loop
044597             0312   ; #### END GAME MAIN LOOP ####
044597             0313   
044597             0314   ; draws the player's shields level
044597             0315   ; draw_shields:
044597             0316   ; TODO: Agonize this routine
044597             0317   ; ; prep the loop to draw the bars
044597             0318   ;     ld a,(player_shields) ; snag shields
044597             0319   ;     and a
044597             0320   ;     ret z ; don't draw if zero shields
044597             0321   ; ; set loop counter and drawing position
044597             0322   ;     ld b,a ; loop counter
044597             0323   ;     ld hl,#5300+48+12
044597             0324   ; ; set color based on bars remaining
044597             0325   ;     ld c,103 ; bright green 28fe0a
044597             0326   ;     cp 9
044597             0327   ;     jp p,draw_shields_loop
044597             0328   ;     ld c,74 ; bright yellow eafe5b
044597             0329   ;     cp 3
044597             0330   ;     jp p,draw_shields_loop
044597             0331   ;     ld c,28 ; bright red fe0a0a
044597             0332   ; draw_shields_loop:
044597             0333   ;     push bc ; yup,outta
044597             0334   ;     push hl ; registers again
044597             0335   ;     ; ld a,#A8 ; ▀,168
044597             0336   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
044597             0337   ;     ; call draw_char
044597             0338   ;     call draw_num ; we nuked draw_char for the time being
044597             0339   ;     pop hl
044597             0340   ;     ld a,8
044597             0341   ;     add a,l
044597             0342   ;     ld l,a
044597             0343   ;     pop bc
044597             0344   ;     djnz draw_shields_loop
044597             0345       ; ret
044597             0346   
044597             0347   ; prints the player's score
044597             0348   ; print_score:
044597             0349   ; TODO: Agonize this
044597             0350   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
044597             0351   ;     ld c,42 ; dark orange b74400
044597             0352   ;     ld hl,#5200+1+8+6*6
044597             0353   ;     ld a,3 ; print 6 bdc digits
044597             0354   ;     ld de,player_score
044597             0355   ;     call print_num
044597             0356   
044597             0357   ;     ld c,58 ; golden yellow fec10a
044597             0358   ;     ld hl,#5100+8+6*6
044597             0359   ;     ld a,3 ; print 6 bdc digits
044597             0360   ;     ld de,player_score
044597             0361   ;     call print_num
044597             0362       ; ret
044597             0363   
044597             0364   ; draw_lives:
044597             0365   ;     ld hl,player_small ; make small yellow ship the active sprite
044597             0366   ;     ld (sprite_base_bufferId),hl
044597             0367   ;     ; ld a,#80 ; northern orientation
044597             0368   ;     ; ld (sprite_orientation),a
044597             0369   ;     ld hl,0 ; north
044597             0370   ;     ld (sprite_heading),hl
044597             0371   ;     xor a
044597             0372   ;     ld (sprite_animation),a
044597             0373   ;     ld a,#56 ; top of visible screen
044597             0374   ;     ld (sprite_y+1),a
044597             0375   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
044597             0376   ;     ld a,(player_ships)
044597             0377   ;     dec a ; we draw one fewer ships than lives
044597             0378   ;     ret z ; nothing to draw here, move along
044597             0379   ;     ld b,a ; loop counter
044597             0380   ;     ld a,256-16 ; initial x position
044597             0381   ; draw_lives_loop:
044597             0382   ;     ld (sprite_x+1),a
044597             0383   ;     push af
044597             0384   ;     push bc
044597             0385   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
044597             0386   ;     pop bc
044597             0387   ;     pop af
044597             0388   ;     sub 10
044597             0389   ;     djnz draw_lives_loop
044597             0390   ;     ret
