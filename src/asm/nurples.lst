PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000 C3 45 00 04 0004       jp start
040004 FF FF FF FF 0005       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0006       db "MOS"
040043 00          0007       db 00h
040044 01          0008       db 01h
040045             0009   
040045             0010   start:
040045 F5          0011       push af
040046 C5          0012       push bc
040047 D5          0013       push de
040048 DD E5       0014       push ix
04004A FD E5       0015       push iy
04004C CD FA 4C 04 0016   	call	init
040050 CD CC 4D 04 0017   	call 	main
040054             0018   
040054             0019   exit:
040054 FD E1       0020       pop iy
040056 DD E1       0021       pop ix
040058 D1          0022       pop de
040059 C1          0023       pop bc
04005A F1          0024       pop af
04005B 21 00 00 00 0025       ld hl,0
04005F             0026   
04005F C9          0027       ret
040060             0028   
040060             0029   	include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*          LD A, char
040060             0004*          RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*          ld bc,$+7     ; Address of first instruction after the jump
040060             0013*          push bc       ; which constitutes the return address
040060             0014*          jp   (hl)     ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*          ld bc,$+7     ; Address of first instruction after the jump
040060             0023*          push bc       ; which constitutes the return address
040060             0024*          jp   (ix)     ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*          ld bc,$+7     ; Address of first instruction after the jump
040060             0033*          push bc       ; which constitutes the return address
040060             0034*          jp   (iy)     ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*          push hl ; 4 cycles
040060             0041*          inc sp ; 1 cycle
040060             0042*          pop af  ; 4 cycles
040060             0043*          dec sp ; 1 cycle
040060             0044*                 ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*          ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*          ex af,af'
040070             0068*          exx
040070             0069*          push af
040070             0070*          push hl
040070             0071*          push bc
040070             0072*          push de
040070             0073*  
040070             0074*          ex af,af'
040070             0075*          exx
040070             0076*          push af
040070             0077*          push hl
040070             0078*          push bc
040070             0079*          push de
040070             0080*          push ix
040070             0081*          push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*          pop iy
040070             0086*          pop ix
040070             0087*          pop de
040070             0088*          pop bc
040070             0089*          pop hl
040070             0090*          pop af
040070             0091*          ex af,af'
040070             0092*          exx
040070             0093*  
040070             0094*          pop de
040070             0095*          pop bc
040070             0096*          pop hl
040070             0097*          pop af
040070             0098*          ex af,af'
040070             0099*          exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*  	PUSH	BC
040078 01 00 00 00 0119*  	LD		BC,0
04007C 3E 00       0120*  	LD 	 	A,0
04007E 5B DF       0121*  	RST.LIL 18h
040080 C1          0122*  	POP		BC
040081 C9          0123*  	RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*  	PUSH	BC
040083 01 00 00 00 0128*  	LD		BC, 0
040087 4E          0129*  	LD		C, (HL)
040088 5B DF       0130*  	RST.LIL	18h
04008A C1          0131*  	POP		BC
04008B C9          0132*  	RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*  	LD	A, '\r'
04008F 5B D7       0137*  	RST.LIL 10h
040091 3E 0A       0138*  	LD	A, '\n'
040093 5B D7       0139*  	RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*  	RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M         push hl ; 4 cycles
040098 33          0002*M         inc sp ; 1 cycle
040099 F1          0003*M         pop af  ; 4 cycles
04009A 3B          0004*M         dec sp ; 1 cycle
04009B             0005*M                ; 10 cycles total
04009B CD A5 00 04 0147*  	CALL	printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*  	LD		A,H
0400A0 CD A5 00 04 0152*  	CALL	printHex8
0400A4 7D          0153*  	LD		A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*  	LD		C,A
0400A6 1F          0158*  	RRA
0400A7 1F          0159*  	RRA
0400A8 1F          0160*  	RRA
0400A9 1F          0161*  	RRA
0400AA CD AF 00 04 0162*  	CALL	@F
0400AE 79          0163*  	LD		A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*  	AND		0Fh
0400B1 C6 90       0166*  	ADD		A,90h
0400B3 27          0167*  	DAA
0400B4 CE 40       0168*  	ADC		A,40h
0400B6 27          0169*  	DAA
0400B7 5B D7       0170*  	RST.LIL	10h
0400B9 C9          0171*  	RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*  	LD	A, '0'
04016F 5B D7       0290*  	RST.LIL 10h
040171 3E 78       0291*  	LD	A, 'x'
040173 5B D7       0292*  	RST.LIL 10h
040175 C9          0293*  	RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*          push hl
040176             0297*          push bc
040176             0298*          pop hl
040176             0299*          call printDec
040176             0300*          pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*          push hl
040176             0305*          push de
040176             0306*          pop hl
040176             0307*          call printDec
040176             0308*          pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*          call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*          push hl
040176             0317*          push ix
040176             0318*          pop hl
040176             0319*          call printDec
040176             0320*          pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*          push hl
040176             0325*          push iy
040176             0326*          pop hl
040176             0327*          call printDec
040176             0328*          pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*  	LD	 DE, _printDecBuffer
04017E CD B2 01 04 0344*  	CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD	 HL, _printDecBuffer
040186 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD	 A, (HL)
040189 FE 30       0351*      CP	 '0'
04018B C2 95 01 04 0352*      JP	 NZ, @done
04018F 3E 20       0353*      LD   A, ' '
040191 77          0354*      LD	 (HL), A
040192 23          0355*      INC	 HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*  	LD	 HL, _printDecBuffer
040199 CD 77 00 04 0361*  	CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*  	RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*  	LD	 BC,-10000000
0401B6 CD E9 01 04 0379*  	CALL @one_digit
0401BA 01 C0 BD F0 0380*  	LD	 BC,-1000000
0401BE CD E9 01 04 0381*  	CALL @one_digit
0401C2 01 60 79 FE 0382*  	LD	 BC,-100000
0401C6 CD E9 01 04 0383*  	CALL @one_digit
0401CA 01 F0 D8 FF 0384*  	LD   BC,-10000
0401CE CD E9 01 04 0385*  	CALL @one_digit
0401D2 01 18 FC FF 0386*  	LD   BC,-1000
0401D6 CD E9 01 04 0387*  	CALL @one_digit
0401DA 01 9C FF FF 0388*  	LD   BC,-100
0401DE CD E9 01 04 0389*  	CALL @one_digit
0401E2 0E F6       0390*  	LD   C,-10
0401E4 CD E9 01 04 0391*  	CALL @one_digit
0401E8 48          0392*  	LD   C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*  	LD   A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*  	INC  A
0401EC 09          0397*  	ADD  HL,BC
0401ED 38 FC       0398*  	JR   C,@divide_me
0401EF ED 42       0399*  	SBC  HL,BC
0401F1 12          0400*  	LD   (DE),A
0401F2 13          0401*  	INC  DE
0401F3 C9          0402*  	RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
040212 CD FB 06 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld   bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld   bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld   bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld   c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld   c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp   @frac            ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc  a
040240 09          0443*      add  hl, bc           ; Accumulate until overflow
040241 38 FC       0444*      jr   c, @divide_me
040243 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
040245 12          0446*      ld   (de), a          ; Store ASCII digit
040246 13          0447*      inc  de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld   a, '.'           ; Decimal point
04024A 12          0452*      ld   (de), a
04024B 13          0453*      inc  de
04024C E1          0454*      pop  hl               ; Restore HL with original fraction
04024D 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld   a, '0'
040255 84          0460*      add  a, h             ; Convert integer part to ASCII
040256 12          0461*      ld   (de), a
040257 13          0462*      inc  de
040258 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor  a                ; Null terminator
04025B 12          0466*      ld   (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 94 06 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8      ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
04031B             0602*                  ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*  	ld hl,@cmd
04032B 01 08 00 00 0615*  	ld bc,@end-@cmd
04032F 5B DF       0616*  	rst.lil $18
040331 C9          0617*  	ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8      ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
040340             0627*                  ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*  	ld hl,@cmd
040350 01 08 00 00 0640*  	ld bc,@end-@cmd
040354 5B DF       0641*  	rst.lil $18
040356 C9          0642*  	ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl  ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*  	MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl  ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
04056B 5B D7       0903*  	rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*  	call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0030   	include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*          add hl,de
04068E             0007*          or a
04068E             0008*          sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret         ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af     ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af      ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de     ; save de
0406A5 EB          0045*      ex de,hl    ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0     ; clear hl
0406AA AF          0047*      xor a       ; clear carry
0406AB ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
0406AD D1          0049*      pop de      ; get de back
0406AE C9          0050*      ret         ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*  	ld		(scratch1),hl
0406B3 21 90 06 04 0057*  	ld		hl,scratch1+2
0406B7 CB 1E       0058*  	rr		(hl)
0406B9 2B          0059*  	dec		hl
0406BA CB 1E       0060*  	rr		(hl)
0406BC 2B          0061*  	dec		hl
0406BD CB 1E       0062*  	rr		(hl)
0406BF 23          0063*  	inc		hl
0406C0 23          0064*  	inc		hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M         add hl,de
0406E6 B7          0002*M         or a
0406E7 ED 52       0003*M         sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*  	xor a
0406FC 32 0D 07 04 0105*  	ld (@buffer+3),a
040700 7D          0106*  	ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*  	ld (@buffer),hl
040705 2A 0B 07 04 0108*  	ld hl,(@buffer+1)
040709 C9          0109*  	ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*          add hl,hl ; * 2
04070E             0114*          add hl,hl ; * 4
04070E             0115*          add hl,hl ; * 8
04070E             0116*          add hl,hl ; * 16
04070E             0117*          add hl,hl ; * 32
04070E             0118*          add hl,hl ; * 64
04070E             0119*          add hl,hl ; * 128
04070E             0120*          add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*  	or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*  	ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0031   	include "enemies.inc"
040785 10          0001*  max_enemy_sprites: db 16
040786             0002*  
040786             0003*  ; sprite_type
040786             0004*  enemy_dead: equ 0
040786             0005*  enemy_small: equ 1
040786             0006*  enemy_medium: equ 2
040786             0007*  enemy_large: equ 3
040786             0008*  landing_pad: equ 4
040786             0009*  laser_turret: equ 5
040786             0010*  fireballs: equ 6
040786             0011*  explosion: equ 7
040786             0012*  
040786             0013*  
040786             0014*  respawn_countdown:
040786 2A A7 07 04 0015*      ld hl,(respawn_timer)
04078A 2B          0016*      dec hl
04078B 22 A7 07 04 0017*      ld (respawn_timer),hl
04078F             0018*  ; check hl for zero
04078F 19          0019*      add hl,de
040790 B7          0020*      or a
040791 ED 52       0021*      sbc hl,de
040793 C0          0022*      ret nz
040794 06 10       0023*      ld b,table_max_records
040796             0024*  @respawn_loop:
040796 C5          0025*      push bc
040797 CD 29 09 04 0026*      call enemy_init_from_landing_pad
04079B C1          0027*      pop bc
04079C 10 F8       0028*      djnz @respawn_loop
04079E 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
0407A2 22 A7 07 04 0030*      ld (respawn_timer),hl
0407A6 C9          0031*      ret
0407A7 3C 00 00    0032*  respawn_timer: dl 1*60
0407AA             0033*  
0407AA             0034*  move_enemies:
0407AA             0035*  ; are there any active enemies or explosions?
0407AA 21 00 00 00 0036*      ld hl,0
0407AE 3A 02 43 04 0037*      ld a,(table_active_sprites)
0407B2 6F          0038*      ld l,a
0407B3             0039*      ; call dumpRegistersHex
0407B3 A7          0040*      and a ; will be zero if no alive enemies or explosions
0407B4             0041*      ; ret z ; so nothing to do but go back
0407B4             0042*      ; ld hl,(respawn_timer)
0407B4             0043*      ; call dumpRegistersHex
0407B4 20 05       0044*      jr nz,move_enemies_do
0407B6 CD 86 07 04 0045*      call respawn_countdown
0407BA C9          0046*      ret
0407BB             0047*  move_enemies_do:
0407BB             0048*  ; initialize pointers and loop counter
0407BB FD 21 9F 40 0049*      ld iy,table_base ; set iy to first record in table
       04          
0407C0 06 10       0050*      ld b,table_max_records ; loop counter
0407C2             0051*  move_enemies_loop:
0407C2 FD 22 FF 42 0052*      ld (table_pointer),iy ; update table pointer
       04          
0407C7 C5          0053*      push bc ; backup loop counter
0407C8             0054*  ; check sprite_type to see if sprite is active
0407C8 FD 7E 01    0055*      ld a,(iy+sprite_type)
0407CB A7          0056*      and a ; if zero, sprite is dead
0407CC 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
0407CE             0058*  ; otherwise we prepare to move the sprite
0407CE FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
0407D1 CD 41 4B 04 0060*      call vdu_sprite_select ; select sprite
0407D5 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0407D8 E9          0062*      jp (hl)  ; ... and jump to it
0407D9             0063*  ; we always jp back here from behavior subroutines
0407D9             0064*  move_enemies_loop_return:
0407D9 FD 2A FF 42 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
0407DE             0066*  ; now we check results of all the moves
0407DE FD 7E 08    0067*      ld a,(iy+sprite_collisions)
0407E1 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
0407E3 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0407E6 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0407E8 CD 4B 43 04 0071*      call table_deactivate_sprite ; otherwise we ded
0407EC AF          0072*      xor a ; zero a so that we can ...
0407ED FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
0407F0 18 0A       0074*      jr move_enemies_next_record ; and to the next record
0407F2             0075*  move_enemies_draw_sprite:
0407F2             0076*  ; if we got here sprite will have already been activated
0407F2             0077*  ; so all we need to do is set its coordinates and draw it
0407F2 FD 07 0B    0078*      ld bc,(iy+sprite_x)
0407F5 FD 17 0E    0079*      ld de,(iy+sprite_y)
0407F8 CD 0D 4C 04 0080*      call vdu_sprite_move_abs168
0407FC             0081*  ; fall through to next record
0407FC             0082*  move_enemies_next_record:
0407FC 11 26 00 00 0083*      ld de,table_bytes_per_record
040800 FD 19       0084*      add iy,de ; point to next record
040802 AF          0085*      xor a ; clears carry flag
040803 32 03 43 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
040807 C1          0087*      pop bc ; get back our loop counter
040808 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
04080A C9          0089*      ret ; and we're out
04080B             0090*  
04080B             0091*  en_nav_zigzag_start:
04080B FD 2A FF 42 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040810 CD 49 07 04 0093*      call rand_8
040814 E6 3F       0094*      and %00111111 ; limit it to 64
040816 CB DF       0095*      set 3,a ; make sure it's at least 8
040818 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
04081B             0097*      ; fall through to en_nav_zigzag
04081B             0098*  en_nav_zigzag:
04081B FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
04081E 3D          0100*      dec a
04081F FD 77 22    0101*      ld (iy+sprite_move_timer),a
040822 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
040824             0103*      ; otherwise flip direction and restart timer
040824 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
040827 EE 01       0105*      xor %1 ; flips bit one
040829 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
04082C 20 09       0107*      jr nz,en_nav_zigzag_right
04082E             0108*  ;otherwise zag left
04082E 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
040832 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
040835 18 D4       0111*      jr en_nav_zigzag_start
040837             0112*  en_nav_zigzag_right:
040837 21 00 60 00 0113*      ld hl,0x006000; southeast heading
04083B FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
04083E 18 CB       0115*      jr en_nav_zigzag_start
040840             0116*  en_nav_zigzag_no_switch:
040840             0117*      ; ld a,(sprite_orientation)
040840 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
040843 18 13       0119*      jr en_nav_computevelocities
040845             0120*  
040845             0121*  ; contains the logic for how to move the enemy
040845             0122*  ; and then does the moving
040845             0123*  ; inputs: a fully-populated active sprite table
040845             0124*  ;         player position variables
040845             0125*  ; destroys: everything except index registers
040845             0126*  ; outputs: moving enemies
040845             0127*  en_nav:
040845             0128*  ; set velocity and orientation by player's relative location
040845             0129*  ; move enemies y-axis
040845             0130*  ; where is player relative to us?
040845 CD AC 09 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
040849             0132*  ; is player above or below us?
040849 ED 53 A5 05 0133*      ld (ude),de ; dy
       04          
04084E 3A A7 05 04 0134*      ld a,(ude+2) ; deu
040852 17          0135*      rla ; shift sign bit into carry
040853 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
040855             0137*  ; player is even or above,so home in on current heading
040855 FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
040858             0139*  
040858             0140*  ; we land here from zig-zag program so as not to
040858             0141*  ; redundantly save orientation and heading
040858             0142*  en_nav_computevelocities:
040858             0143*  ; set x/y component velocities based on bearing to player
040858 FD 2A FF 42 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04085D E5          0145*      push hl ; we need it back to set rotation frame
04085E FD 17 17    0146*      ld de,(iy+sprite_vel)
040861 CD 3F 0C 04 0147*      call polar_to_cartesian
040865 FD 2A FF 42 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04086A FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
04086D FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
040870             0151*  ; change the animation frame to match heading
040870             0152*  ; by dividng the heading by 8
040870 E1          0153*      pop hl ; get back Heading
040871 7C          0154*      ld a,h
040872 CB 3F       0155*      srl a
040874 CB 3F       0156*      srl a
040876 CB 3F       0157*      srl a
040878 CD A4 4B 04 0158*      call vdu_sprite_select_frame
04087C             0159*  
04087C             0160*  move_enemy_sprite:
04087C FD 2A FF 42 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040881             0162*  ; x-axis movement
040881 FD 27 0B    0163*      ld hl,(iy+sprite_x)
040884 FD 17 11    0164*      ld de,(iy+sprite_xvel)
040887 19          0165*      add hl,de
040888 FD 2F 0B    0166*      ld (iy+sprite_x),hl
04088B             0167*  ; y-axis movement
04088B FD 27 0E    0168*      ld hl,(iy+sprite_y)
04088E FD 17 14    0169*      ld de,(iy+sprite_yvel)
040891 19          0170*      add hl,de
040892 FD 2F 0E    0171*      ld (iy+sprite_y),hl
040895             0172*  ; detect screen edge collisions
040895 AF          0173*      xor a  ; reset screen edge collision flag and clear carry
040896 32 03 43 04 0174*      ld (sprite_screen_edge),a
04089A             0175*  ; y-axis first since we already have it in hl
04089A 11 00 00 00 0176*      ld de,-sprite_top*256
04089E ED 5A       0177*      adc hl,de
0408A0 FA CA 08 04 0178*      jp m,@top
0408A4 ED 52       0179*      sbc hl,de ; hl back to original value
0408A6 11 00 91 FE 0180*      ld de,-sprite_bottom*256
0408AA ED 5A       0181*      adc hl,de
0408AC F2 D4 08 04 0182*      jp p,@bottom
0408B0             0183*  @xaxis:
0408B0 FD 27 0B    0184*      ld hl,(iy+sprite_x)
0408B3 11 00 00 00 0185*      ld de,-sprite_left*256
0408B7 ED 5A       0186*      adc hl,de
0408B9 FA EF 08 04 0187*      jp m,@left
0408BD ED 52       0188*      sbc hl,de ; hl back to original value
0408BF 11 00 11 FF 0189*      ld de,-sprite_right*256
0408C3 ED 5A       0190*      adc hl,de
0408C5 F2 FD 08 04 0191*      jp p,@right
0408C9             0192*  ; no edge collisions so go home
0408C9 C9          0193*      ret
0408CA             0194*  @top:
0408CA 3E 08       0195*      ld a,collide_top
0408CC 21 00 00 00 0196*      ld hl,sprite_top*256
0408D0 C3 DA 08 04 0197*      jp @collide_y
0408D4             0198*  @bottom:
0408D4 3E 04       0199*      ld a,collide_bottom
0408D6 21 00 6F 01 0200*      ld hl,sprite_bottom*256
0408DA             0201*  @collide_y:
0408DA 32 03 43 04 0202*      ld (sprite_screen_edge),a
0408DE FD 2F 0E    0203*      ld (iy+sprite_y),hl
0408E1             0204*  ; reverse y-axis velocity
0408E1 FD 27 14    0205*      ld hl,(iy+sprite_yvel)
0408E4 CD A4 06 04 0206*      call neg_hlu
0408E8 FD 2F 14    0207*      ld (iy+sprite_yvel),hl
0408EB             0208*  ; go check for x-axis collisions
0408EB C3 B0 08 04 0209*      jp @xaxis
0408EF             0210*  @left:
0408EF 3A 03 43 04 0211*      ld a,(sprite_screen_edge)
0408F3 F6 02       0212*      or a,collide_left
0408F5 21 00 00 00 0213*      ld hl,sprite_left*256
0408F9 C3 07 09 04 0214*      jp @collide_x
0408FD             0215*  @right:
0408FD 3A 03 43 04 0216*      ld a,(sprite_screen_edge)
040901 F6 01       0217*      or a,collide_right
040903 21 00 EF 00 0218*      ld hl,sprite_right*256
040907             0219*  @collide_x:
040907 32 03 43 04 0220*      ld (sprite_screen_edge),a
04090B FD 2F 0B    0221*      ld (iy+sprite_x),hl
04090E             0222*  ; reverse x-axis velocity
04090E FD 27 11    0223*      ld hl,(iy+sprite_xvel)
040911 CD A4 06 04 0224*      call neg_hlu
040915 FD 2F 11    0225*      ld (iy+sprite_xvel),hl
040918             0226*  ; final collision flag to a and return
040918 3A 03 43 04 0227*      ld a,(sprite_screen_edge)
04091C C9          0228*      ret
04091D             0229*  
04091D             0230*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
04091D             0231*  ; ; each sprite in the table must have one of these defined
04091D             0232*  ; ; but they need not be unique to a particular sprite
04091D             0233*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
04091D             0234*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
04091D             0235*  ; ; but they can call anything they want between those two endpoints
04091D             0236*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
04091D             0237*  
04091D             0238*  ; move_nop: ; does nothing but burn a few cycles changing the PC
04091D             0239*  ;     jp move_enemies_loop_return
04091D             0240*  
04091D             0241*  ; move_explosion:
04091D             0242*  ;     call animate_explosion
04091D             0243*  ;     jp move_enemies_loop_return
04091D             0244*  
04091D             0245*  move_enemy_small:
04091D CD 45 08 04 0246*      call en_nav
040921 CD 45 0A 04 0247*      call check_collisions
040925 C3 D9 07 04 0248*      jp move_enemies_loop_return
040929             0249*  
040929             0250*  ; move_enemy_medium:
040929             0251*  ;     call en_nav
040929             0252*  ;     call check_collisions
040929             0253*  ;     jp move_enemies_loop_return
040929             0254*  
040929             0255*  ; move_enemy_large:
040929             0256*  ;     call en_nav
040929             0257*  ;     call check_collisions
040929             0258*  ;     jp move_enemies_loop_return
040929             0259*  
040929             0260*  ; move_landing_pad:
040929             0261*  ;     call move_active_tiles
040929             0262*  ;     call check_collisions
040929             0263*  ; ; is it time to launch an enemy?
040929             0264*  ;     ld hl,sprite_move_timer
040929             0265*  ;     dec (hl)
040929             0266*  ;     jp nz,move_enemies_loop_return
040929             0267*  ;     call enemy_init_from_landing_pad
040929             0268*  ;     ; reset move timer so can spawn again if player doesn't take us out
040929             0269*  ;     call rand_8     ; snag a random number
040929             0270*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
040929             0271*  ;     add a,64 ; range is now 64-127
040929             0272*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
040929             0273*  ;     jp move_enemies_loop_return
040929             0274*  
040929             0275*  enemy_init_from_landing_pad:
040929             0276*  ; get next available spriteId
040929 CD 26 43 04 0277*      call table_get_next_id
04092D D0          0278*      ret nc ; no carry means no free sprite slots, so we go home
04092E             0279*  ; ix comes back with the pointer to the new sprite variables
04092E DD E5       0280*      push ix ; de picks it up when we're ready for the copy to the table
040930             0281*  ; a comes back with the spriteId of the new sprite
040930 32 86 09 04 0282*      ld (@id),a
040934             0283*  ; initialize the new sprite
040934 CD 41 4B 04 0284*      call vdu_sprite_select
040938 CD 54 4B 04 0285*      call vdu_sprite_clear_frames
04093C 21 14 01 00 0286*      ld hl,BUF_SEEKER_000
040940 06 20       0287*      ld b,32
040942             0288*  @load_frames:
040942 C5          0289*      push bc
040943 E5          0290*      push hl
040944 CD 96 4C 04 0291*      call vdu_sprite_add_buff
040948 E1          0292*      pop hl
040949 23          0293*      inc hl
04094A C1          0294*      pop bc
04094B 10 F5       0295*      djnz @load_frames
04094D             0296*  ; copy coordinates of active sprite to new sprite
04094D FD 2A FF 42 0297*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040952             0298*      ; ld hl,(iy+sprite_x)
040952             0299*  	; ld hl,0x008000 ; debug
040952             0300*  
040952 CD 49 07 04 0301*      call rand_8
040956 21 00 00 00 0302*      ld hl,0
04095A 67          0303*      ld h,a
04095B             0304*  
04095B 22 91 09 04 0305*      ld (@x),hl
04095F             0306*      ; ld hl,(iy+sprite_y)
04095F             0307*      ; ld hl,0x002000 ; debug
04095F             0308*  
04095F CD 49 07 04 0309*      call rand_8
040963 21 00 00 00 0310*      ld hl,0
040967 67          0311*      ld h,a
040968             0312*  
040968 22 94 09 04 0313*      ld (@y),hl
04096C CD 49 07 04 0314*      call rand_8
040970 E6 01       0315*      and %00000001 ; 50/50 chance of moving left or right on spanw
040972 32 A9 09 04 0316*      ld (@move_step),a
040976             0317*  ; now copy to the table
040976 21 86 09 04 0318*      ld hl,@id ; address to copy from
04097A D1          0319*      pop de ; address to copy to (was ix)
04097B 01 26 00 00 0320*      ld bc,table_bytes_per_record ; number of bytes to copy
04097F ED B0       0321*      ldir ; copy the records from local scratch to sprite table
040981             0322*  ; finally, make the new sprite visible
040981 CD B7 4B 04 0323*      call vdu_sprite_show
040985 C9          0324*      ret
040986 00          0325*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
040987 01          0326*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
040988 14 01 00    0327*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
04098B 1D 09 04    0328*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
04098E 03          0329*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
04098F 10          0330*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
040990 10          0331*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
040991 00 00 00    0332*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
040994 00 00 00    0333*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
040997 00 00 00    0334*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04099A 00 00 00    0335*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04099D 80 02 00    0336*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
0409A0 00 80 00    0337*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0409A3 00 80 00    0338*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
0409A6 00          0339*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
0409A7 00          0340*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
0409A8 01          0341*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
0409A9 00          0342*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
0409AA 20          0343*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
0409AB 02          0344*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
0409AC             0345*  
0409AC             0346*  ; move_laser_turret:
0409AC             0347*  ; ; compute orientation to player
0409AC             0348*  ;     call orientation_to_player
0409AC             0349*  ; ; h.l 8.8 fixed angle256 to player
0409AC             0350*  ; ; bc and de as signed 16-bit integers
0409AC             0351*  ; ; representing delta-x/y *to* target respectively
0409AC             0352*  ;     ld (Bearing_t),hl
0409AC             0353*  ;     ld hl,0x0400
0409AC             0354*  ;     ld (Vp),hl
0409AC             0355*  ;     call targeting_computer
0409AC             0356*  ;     ld (sprite_heading),hl ; store bearing to player
0409AC             0357*  ; ; is it time to launch a fireball?
0409AC             0358*  ;     ld hl,sprite_move_timer
0409AC             0359*  ;     dec (hl)
0409AC             0360*  ;     jp nz,move_laser_turret_boilerplate
0409AC             0361*  ;     call fireballs_init
0409AC             0362*  ;     ; reset move timer so can fire again if player doesn't take us out
0409AC             0363*  ;     call rand_8     ; snag a random number
0409AC             0364*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0409AC             0365*  ;     add a,64 ; range is now 64-127
0409AC             0366*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0409AC             0367*  ; move_laser_turret_boilerplate:
0409AC             0368*  ;     call move_active_tiles
0409AC             0369*  ;     call check_collisions
0409AC             0370*  ;     jp move_enemies_loop_return
0409AC             0371*  
0409AC             0372*  ; fireballs_init:
0409AC             0373*  ;     call sprite_variables_to_stack
0409AC             0374*  
0409AC             0375*  ;     ld hl,fireballs
0409AC             0376*  ;     ld (sprite_base_bufferId),hl
0409AC             0377*  
0409AC             0378*  ;     ld hl,move_fireballs
0409AC             0379*  ;     ld (sprite_move_program),hl
0409AC             0380*  
0409AC             0381*  ;     ld a,%11 ; collides with laser and player
0409AC             0382*  ;     ; ld a,%10 ; collides with laser DEBUG
0409AC             0383*  ;     ld (iy+sprite_collisions),a
0409AC             0384*  
0409AC             0385*  ;     ld hl,(Vp)
0409AC             0386*  ;     ld (sprite_vel),hl
0409AC             0387*  ;     ld hl,(Vp_x)
0409AC             0388*  ;     ld (sprite_xvel),hl
0409AC             0389*  ;     ld hl,(Vp_y)
0409AC             0390*  ;     inc h ; account for ground movement
0409AC             0391*  ;     ld (sprite_yvel),hl
0409AC             0392*  
0409AC             0393*  ;     xor a ; zero a
0409AC             0394*  ;     ld (sprite_animation),a
0409AC             0395*  ;     ld (sprite_move_step),a
0409AC             0396*  ;     ld (sprite_move_timer),a
0409AC             0397*  
0409AC             0398*  ;     ld a,6 ; 1/10th of a second timer
0409AC             0399*  ;     ld (sprite_animation_timer),a
0409AC             0400*  
0409AC             0401*  ;     ld a,0x00 ; BCD
0409AC             0402*  ;     ld (sprite_points),a
0409AC             0403*  ;     ld a,1 ; binary
0409AC             0404*  ;     ld (sprite_shield_damage),a
0409AC             0405*  
0409AC             0406*  ;     call table_add_record ; plops that on the sprite stack for later
0409AC             0407*  ;     call sprite_variables_from_stack ; come back to where we started
0409AC             0408*  ;     ret
0409AC             0409*  
0409AC             0410*  ; move_fireballs:
0409AC             0411*  ;     call move_enemy_sprite ; move sprite
0409AC             0412*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
0409AC             0413*  ;     and a ; if zero we're still within screen bounds
0409AC             0414*  ;     jr z,move_fireballs_alive
0409AC             0415*  ; ; otherwise kill sprite
0409AC             0416*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
0409AC             0417*  ;     ld (iy+sprite_collisions),a
0409AC             0418*  ;     jp move_enemies_loop_return
0409AC             0419*  ; move_fireballs_alive:
0409AC             0420*  ;     ld a,(sprite_animation_timer)
0409AC             0421*  ;     dec a
0409AC             0422*  ;     ld (sprite_animation_timer),a
0409AC             0423*  ;     jr nz,move_fireballs_draw
0409AC             0424*  ;     ld a,(sprite_animation)
0409AC             0425*  ;     xor %1
0409AC             0426*  ;     ld (sprite_animation),a
0409AC             0427*  ;     ld a,6 ; 1/10th of a second timer
0409AC             0428*  ;     ld (sprite_animation_timer),a
0409AC             0429*  ;     ; fall through
0409AC             0430*  
0409AC             0431*  ; move_fireballs_draw:
0409AC             0432*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0409AC             0433*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0409AC             0434*  ;     call check_collisions
0409AC             0435*  ;     jp move_enemies_loop_return
0409AC             0436*  
0409AC             0437*  ; compute orientation to player
0409AC             0438*  ; based on relative positions
0409AC             0439*  ; returns: h.l 16.8 fixed angle256 to player
0409AC             0440*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0409AC             0441*  ;    representing delta-x/y *to* target respectively
0409AC             0442*  orientation_to_player:
0409AC FD 2A FF 42 0443*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0409B1 FD 07 0B    0444*      ld bc,(iy+sprite_x)
0409B4 FD 17 0E    0445*      ld de,(iy+sprite_y)
0409B7 DD 2A AE 3F 0446*      ld ix,(player_x)
       04          
0409BC FD 2A B1 3F 0447*      ld iy,(player_y)
       04          
0409C1 CD 74 0C 04 0448*      call dxy168
0409C5 C5          0449*      push bc
0409C6 D5          0450*      push de
0409C7 CD D1 0C 04 0451*      call atan2_168fast
0409CB D1          0452*      pop de
0409CC C1          0453*      pop bc
0409CD FD 2A FF 42 0454*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0409D2 C9          0455*      ret
0409D3             0456*  
0409D3             0457*  
0409D3             0458*  ; targeting_computer scratch variables
0409D3 00 00       0459*  Bearing_t: dw #0000 ; 8.8 fixed
0409D5 00 00       0460*  Heading_t: dw #0000 ; 8.8 fixed
0409D7 00 00       0461*  Vp: dw #0000 ; 8.8 fixed
0409D9 00 00       0462*  Vp_x: dw #0000 ; 8.8 fixed
0409DB 00 00       0463*  Vp_y: dw #0000 ; 8.8 fixed
0409DD 00 00       0464*  Vt: dw #0000 ; 8.8 fixed
0409DF 00 00       0465*  Vt_x: dw #0000 ; 8.8 fixed
0409E1 00 00       0466*  Vt_y: dw #0000 ; 8.8 fixed
0409E3             0467*  
0409E3             0468*  
0409E3             0469*  ; ; Inputs:   see scratch variables
0409E3             0470*  ; ; Note:     a call to orientation_to_player provides these inputs
0409E3             0471*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
0409E3             0472*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
0409E3             0473*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
0409E3             0474*  ; targeting_computer:
0409E3             0475*  ; ; compute target velocity from x,y component velocities
0409E3             0476*  ;     ld bc,(player_xvel)
0409E3             0477*  ;     ld de,(player_yvel)
0409E3             0478*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
0409E3             0479*  
0409E3             0480*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
0409E3             0481*  ;     ld (Heading_t),bc
0409E3             0482*  ;     ld (Vt),de
0409E3             0483*  
0409E3             0484*  ; ; compute Heading_t-Bearing_t
0409E3             0485*  ;     ld h,b
0409E3             0486*  ;     ld l,c
0409E3             0487*  ;     ld bc,(Bearing_t)
0409E3             0488*  ;     and a ; clear carry
0409E3             0489*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
0409E3             0490*  
0409E3             0491*  ; ; compute sin(Heading_t-Bearing_t)
0409E3             0492*  ;     ld b,h
0409E3             0493*  ;     ld c,l
0409E3             0494*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
0409E3             0495*  
0409E3             0496*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
0409E3             0497*  ;     ex de,hl
0409E3             0498*  ;     ld bc,(Vt)
0409E3             0499*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
0409E3             0500*  
0409E3             0501*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
0409E3             0502*  ;     ld b,h
0409E3             0503*  ;     ld c,l
0409E3             0504*  ;     ld de,(Vp)
0409E3             0505*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
0409E3             0506*  ; ; answer is in radians, convert to degrees256
0409E3             0507*  ;     ex de,hl
0409E3             0508*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
0409E3             0509*  ;     call BC_Mul_DE_88
0409E3             0510*  
0409E3             0511*  ; ; add lead angle to target bearing
0409E3             0512*  ;     ld de,(Bearing_t)
0409E3             0513*  ;     add hl,de ; h.l=lead angle+target bearing
0409E3             0514*  ;     push hl
0409E3             0515*  
0409E3             0516*  ; ; compute component projectile velocities
0409E3             0517*  ;     ld b,h
0409E3             0518*  ;     ld c,l
0409E3             0519*  ;     ld de,(Vp)
0409E3             0520*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
0409E3             0521*  
0409E3             0522*  ;     ld (Vp_x),bc
0409E3             0523*  ;     ld (Vp_y),de
0409E3             0524*  ;     pop hl ; h.l=lead angle+target bearing
0409E3             0525*  ;     ret
0409E3             0526*  
0409E3             0527*  ; this routine vanquishes the enemy sprite
0409E3             0528*  ; and replaces it with an animated explosion
0409E3             0529*  ; we jump here instead of call because
0409E3             0530*  ; we want to return to differing locations in the loop
0409E3             0531*  ; depending on whether we're still sploding
0409E3             0532*  ; destroys: everything except index registers
0409E3             0533*  ; returns: an incandescent ball of debris and gas
0409E3             0534*  kill_nurple:
0409E3             0535*  ; ; tally up points
0409E3             0536*  ;     ld bc,0
0409E3             0537*  ;     ld a,(sprite_points)
0409E3             0538*  ;     ld e,a
0409E3             0539*  ;     ld d,0
0409E3             0540*  ;     ld hl,add_bcd_arg2
0409E3             0541*  ;     call set_bcd
0409E3             0542*  ;     ld hl,player_score
0409E3             0543*  ;     ld de,add_bcd_arg2
0409E3             0544*  ;     ld a,3 ; number of bytes to add
0409E3             0545*  ;     call add_bcd
0409E3             0546*  ; ; initialize explosion
0409E3             0547*  ; init_explosion:
0409E3             0548*  ;     ld hl,explosion
0409E3             0549*  ;     ld (sprite_base_bufferId),hl
0409E3             0550*  ;     ld hl,move_explosion
0409E3             0551*  ;     ld (sprite_move_program),hl
0409E3             0552*  ;     ld a,%00000000 ; collides with nothing
0409E3             0553*  ;     ld (iy+sprite_collisions),a
0409E3             0554*  ;     ld hl,0 ; north
0409E3             0555*  ;     ld (sprite_heading),hl
0409E3             0556*  ;     ld a,0x04 ; will decrement to 03
0409E3             0557*  ;     ld (sprite_animation),a
0409E3             0558*  ;     ld a,0x07 ; 7/60th of a second timer
0409E3             0559*  ;     ld (sprite_animation_timer),a
0409E3             0560*  ;     xor a
0409E3             0561*  ;     ld (sprite_move_timer),a
0409E3             0562*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0409E3             0563*  ; ; fall through to next_explosion
0409E3             0564*  ; next_explosion:
0409E3             0565*  ;     ld a,(sprite_animation)
0409E3             0566*  ;     dec a ; if rolled negative from zero,we're done sploding
0409E3             0567*  ;     jp m,done_explosion
0409E3             0568*  ;     ld (sprite_animation),a
0409E3             0569*  ;     ld a,0x7 ; 7/60th of a second timer
0409E3             0570*  ;     ld (sprite_animation_timer),a
0409E3             0571*  ; ; fall through to animate_explosion
0409E3             0572*  ; animate_explosion:
0409E3             0573*  ;     ld hl,sprite_y+1
0409E3             0574*  ;     inc (hl) ; move explosion down 1 pixel
0409E3             0575*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
0409E3             0576*  ;     ld hl,sprite_animation_timer
0409E3             0577*  ;     dec (hl) ; if timer is zero,we do next animation
0409E3             0578*  ;     jr z,next_explosion
0409E3             0579*  ;     ;otherwise we fall through to draw the current one
0409E3             0580*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0409E3             0581*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0409E3             0582*  ;     ret ; now we go back to caller
0409E3             0583*  ; done_explosion:
0409E3 3E 80       0584*      ld a,%10000000 ; high bit set is non-specific kill-me flag
0409E5 FD 2A FF 42 0585*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
0409EA FD 77 08    0586*      ld (iy+sprite_collisions),a
0409ED C9          0587*      ret ; now we go back to caller
0409EE             0588*  
0409EE             0589*  ; game_over:
0409EE             0590*  ;     jp new_game
0409EE             0591*  
0409EE             0592*  ; it's presumed we've already checked that laser is alive
0409EE             0593*  collision_enemy_with_laser:
0409EE DD 2A 80 2E 0594*      ld ix,(laser_x)
       04          
0409F3 FD 2A 83 2E 0595*      ld iy,(laser_y)
       04          
0409F8 3A 7E 2E 04 0596*      ld a,(laser_dim_x)
0409FC CB 2F       0597*      sra a ; divide by 2
0409FE F5          0598*      push af ; we need this later
0409FF C3 14 0A 04 0599*      jp collision_enemy
040A03             0600*  
040A03             0601*  ; it's presumed we've already checked that player is alive
040A03             0602*  collision_enemy_with_player:
040A03 DD 2A AE 3F 0603*      ld ix,(player_x)
       04          
040A08 FD 2A B1 3F 0604*      ld iy,(player_y)
       04          
040A0D 3A AC 3F 04 0605*      ld a,(player_dim_x)
040A11 CB 2F       0606*      sra a ; divide by 2
040A13 F5          0607*      push af ; we need this later
040A14             0608*      ; fall through to collision_enemy
040A14             0609*  
040A14             0610*  ; compute the distance between the two sprites' centers
040A14             0611*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
040A14             0612*  collision_enemy:
040A14             0613*  ; back up iy because we need it as the sprite table pointer
040A14 FD E5       0614*      push iy
040A16 FD 2A FF 42 0615*      ld iy,(table_pointer)
       04          
040A1B FD 27 0B    0616*      ld hl,(iy+sprite_x)
040A1E FD 7E 09    0617*      ld a,(iy+sprite_dim_x)
040A21 CB 2F       0618*      sra a
040A23 F5          0619*      push af ; we need this later
040A24 E5          0620*      push hl
040A25 C1          0621*      pop bc ; bc = x0
040A26 FD 27 0E    0622*      ld hl,(iy+sprite_y)
040A29 FD 7E 0A    0623*      ld a,(iy+sprite_dim_y)
040A2C EB          0624*      ex de,hl ; de = y0
040A2D F1          0625*      pop af ; TODO: srsly, this is the best way to do this?
040A2E FD E1       0626*      pop iy
040A30 F5          0627*      push af
040A31 CD 9B 0C 04 0628*      call distance168
040A35             0629*  
040A35             0630*  ; ; subtract sum of radii from distance between centers
040A35             0631*  ;     ld de,0
040A35             0632*  ;     pop af ; radius of enemy sprite
040A35             0633*  ;     ld e,a
040A35             0634*  ;     pop af ; radius of player or laser sprite
040A35             0635*  ;     add a,e
040A35             0636*  ;     ld e,a
040A35             0637*  ;     and a ; clear carry
040A35             0638*  ;     sbc hl,de
040A35             0639*  ;     jr c,collision_enemy_is
040A35             0640*  ;     xor a
040A35             0641*  ;     ret
040A35             0642*  ; temp fix TODO: remove this
040A35 F1          0643*      pop af
040A36 F1          0644*      pop af
040A37 11 00 10 00 0645*      ld de,16*256
040A3B A7          0646*      and a
040A3C ED 52       0647*      sbc hl,de
040A3E 38 02       0648*      jr c,collision_enemy_is
040A40 AF          0649*      xor a
040A41 C9          0650*      ret
040A42             0651*  collision_enemy_is:
040A42 AF          0652*      xor a
040A43 3C          0653*      inc a
040A44 C9          0654*      ret
040A45             0655*  
040A45             0656*  ; ; looks up what enemy sprite collides with
040A45             0657*  ; ; detects collisions
040A45             0658*  ; ; and sets things to sploding accordingly
040A45             0659*  ; check_collisions:
040A45             0660*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
040A45             0661*  ;     and a ; if this is zero,
040A45             0662*  ;     ret z ; there's nothing to do
040A45             0663*  ;     and %01 ; do we collide with player?
040A45             0664*  ;     jr z,move_enemies_laser ; if not,check laser collision
040A45             0665*  ;     call collision_enemy_with_player ; otherwise see if we hit player
040A45             0666*  ;     and a ; was there a collision?
040A45             0667*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
040A45             0668*  ; ; yes collision with player
040A45             0669*  ;     ; deduct shield damage
040A45             0670*  ;     ld hl,sprite_shield_damage
040A45             0671*  ;     ld a,(player_shields)
040A45             0672*  ;     sub (hl)
040A45             0673*  ;     ld (player_shields),a
040A45             0674*  ; ; if shields >= 0,player survives
040A45             0675*  ;     jp p,check_collisions_kill_nurple
040A45             0676*  ; ; otherwise update player status so it will die
040A45             0677*  ;     ld a,(player_collisions)
040A45             0678*  ;     or %10 ; sets bit 1,meaning player just died
040A45             0679*  ;     ld (player_collisions),a
040A45             0680*  ;     ; fall through
040A45             0681*  ; check_collisions_kill_nurple:
040A45             0682*  ; ; kill enemy and replace with explosion
040A45             0683*  ;     call kill_nurple
040A45             0684*  ;     ret ; and out
040A45             0685*  
040A45             0686*  check_collisions:
040A45 CD 03 0A 04 0687*      call collision_enemy_with_player ; did we hit the player?
040A49 A7          0688*      and a ; was there a collision?
040A4A C8          0689*      ret z ; if not,we're done
040A4B CD E3 09 04 0690*      call kill_nurple ; otherwise kill enemy
040A4F C9          0691*      ret
040A50             0692*  
040A50             0693*  ; did we hit the laser?
040A50             0694*  move_enemies_laser:
040A50 FD 7E 08    0695*      ld a,(iy+sprite_collisions) ; snag what we collide with again
040A53 E6 02       0696*      and %10 ; do we even collide with laser?
040A55 C8          0697*      ret z ; if not,we're out
040A56 3A 7D 2E 04 0698*      ld a,(laser_collisions) ; is laser alive?
040A5A E6 01       0699*      and %1 ; if bit 0 is not set laser is dead
040A5C C8          0700*      ret z ; so we're out
040A5D CD EE 09 04 0701*      call collision_enemy_with_laser ; otherwise check for collision
040A61 A7          0702*      and a ; was there a collision?
040A62 C8          0703*      ret z ; if not,we're done
040A63             0704*  ; otherwise we mark laser for termination and kill enemy
040A63             0705*  ; update laser status so it will die
040A63 3A 7D 2E 04 0706*      ld a,(laser_collisions)
040A67 F6 02       0707*      or %10 ; bit 1 set means laser just died
040A69 32 7D 2E 04 0708*      ld (laser_collisions),a
040A6D CD E3 09 04 0709*      call kill_nurple ; yes there was a collision,so kill enemy
040A71 C9          0710*      ret ; we're outta' here
040A72             0032   	include "files.inc"
040A72             0001*  ; load to onboard 8k sram
040A72             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
040A72             0033   	include "fixed168.inc"
040A72             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A72             0002*  ; uses EZ80 MLT instruction for speed
040A72             0003*  ; operation: UHL * A --> UHL
040A72             0004*  ; destroys: AF, HL
040A72             0005*  smul24x8:
040A72             0006*  ; make hl positive and store sign flag
040A72 CD 94 06 04 0007*  	call hlu_abs
040A76 F5          0008*  	push af
040A77             0009*  ; do the division
040A77 CD 82 0A 04 0010*      call mul24x8 ; hl = product
040A7B             0011*  ; adjust sign of result
040A7B F1          0012*  	pop af ; sign de
040A7C F0          0013*  	ret p ; hl was positive, nothing to do
040A7D CD A4 06 04 0014*  	call neg_hlu ; result is negative
040A81 C9          0015*  	ret
040A82             0016*  
040A82             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A82             0018*  ; uses EZ80 MLT instruction for speed
040A82             0019*  ; operation: UHL * A --> AUHL
040A82             0020*  ; destroys: AF, HL
040A82             0021*  mul24x8:
040A82 D5          0022*  	push de ; preserve de
040A83             0023*  ; low byte
040A83 5D          0024*  	ld e,l
040A84 57          0025*  	ld d,a
040A85 ED 5C       0026*  	mlt de
040A87 6B          0027*  	ld l,e ; product low byte
040A88 08          0028*  	ex af,af' ; save multiplier
040A89 7A          0029*  	ld a,d ; carry
040A8A 08          0030*  	ex af,af' ; save carry, restore multiplier
040A8B             0031*  ; high byte
040A8B 5C          0032*  	ld e,h
040A8C 57          0033*  	ld d,a
040A8D ED 5C       0034*  	mlt de
040A8F 08          0035*  	ex af,af' ; save multiplier, restore carry
040A90 83          0036*  	add a,e ; add carry
040A91 67          0037*  	ld h,a ; product middle byte
040A92 7A          0038*  	ld a,d ; carry
040A93 08          0039*  	ex af,af' ; save carry, restore multiplier
040A94             0040*  ; upper byte
040A94 22 AF 0A 04 0041*      ld (@scratch),hl ; 7 cycles
040A98 5F          0042*  	ld e,a
040A99 3A B1 0A 04 0043*  	ld a,(@scratch+2)
040A9D 57          0044*  	ld d,a
040A9E ED 5C       0045*  	mlt de
040AA0 08          0046*  	ex af,af' ; restore carry
040AA1 8B          0047*  	adc a,e ; add carry
040AA2 32 B1 0A 04 0048*      ld (@scratch+2),a ; 5 cycles
040AA6 2A AF 0A 04 0049*      ld hl,(@scratch) ; 7 cycles
040AAA             0050*  ; highest byte
040AAA 3E 00       0051*  	ld a,0 ; preserve carry flag
040AAC 8A          0052*  	adc a,d ; product highest byte
040AAD D1          0053*  	pop de ; restore de
040AAE C9          0054*  	ret
040AAF             0055*  @scratch: ds 3
040AB2             0056*  
040AB2 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
040AB8             0058*  
040AB8             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040AB8             0060*  ; operation: UHL * UDE --> mul24out
040AB8             0061*  mul24:
040AB8 DD E5       0062*  	push ix ; preserve
040ABA             0063*  ; point to output buffer and clear it
040ABA DD 21 B2 0A 0064*  	ld ix,mul24out
       04          
040ABF C5          0065*  	push bc
040AC0 01 00 00 00 0066*  	ld bc,0
040AC4 DD 0F 00    0067*  	ld (ix),bc
040AC7 DD 0F 03    0068*  	ld (ix+3),bc
040ACA C1          0069*  	pop bc
040ACB             0070*  ; STEP 1: UHL * E
040ACB 7B          0071*  	ld a,e
040ACC E5          0072*  	push hl
040ACD CD 82 0A 04 0073*  	call mul24x8
040AD1 DD 2F 00    0074*  	ld (ix+0),hl
040AD4 DD 77 03    0075*  	ld (ix+3),a
040AD7             0076*  ; STEP 2: UHL * D
040AD7 E1          0077*  	pop hl
040AD8 E5          0078*  	push hl
040AD9 7A          0079*  	ld a,d
040ADA CD 82 0A 04 0080*  	call mul24x8
040ADE CD F7 0A 04 0081*  	call @accumulate
040AE2             0082*  ; STEP 3: UHL * DEU
040AE2 E1          0083*  	pop hl
040AE3 ED 53 27 0B 0084*  	ld (@de),de
       04          
040AE8 3A 29 0B 04 0085*  	ld a,(@de+2)
040AEC CD 82 0A 04 0086*  	call mul24x8
040AF0 CD F7 0A 04 0087*  	call @accumulate
040AF4             0088*  ; all done
040AF4 DD E1       0089*  	pop ix ; restore
040AF6 C9          0090*  	ret
040AF7             0091*  @accumulate:
040AF7 DD 23       0092*  	inc ix
040AF9             0093*  ; highest byte of product to carry
040AF9 DD 77 03    0094*  	ld (ix+3),a
040AFC             0095*  ; low byte of product
040AFC 7D          0096*  	ld a,l
040AFD DD 86 00    0097*  	add a,(ix+0)
040B00 DD 77 00    0098*  	ld (ix+0),a
040B03             0099*  ; high byte of product
040B03 7C          0100*  	ld a,h
040B04 DD 8E 01    0101*  	adc a,(ix+1)
040B07 DD 77 01    0102*  	ld (ix+1),a
040B0A             0103*  ; uppper byte of product
040B0A 22 24 0B 04 0104*  	ld (@hl),hl
040B0E 3A 26 0B 04 0105*  	ld a,(@hl+2)
040B12 DD 8E 02    0106*  	adc a,(ix+2)
040B15 DD 77 02    0107*  	ld (ix+2),a
040B18             0108*  ; carry
040B18 3E 00       0109*  	ld a,0 ; preserve flags
040B1A DD 8E 03    0110*  	adc a,(ix+3)
040B1D DD 77 03    0111*  	ld (ix+3),a
040B20 C9          0112*  	ret
040B21             0113*  
040B21 00 00 00    0114*  @ix: dl 0
040B24 00 00 00    0115*  @hl: dl 0
040B27 00 00 00    0116*  @de: dl 0
040B2A             0117*  
040B2A             0118*  ; UHL * UDE --> UHL (unsigned)
040B2A             0119*  umul24:
040B2A CD B8 0A 04 0120*  	call mul24
040B2E 2A B2 0A 04 0121*  	ld hl,(mul24out)
040B32 C9          0122*  	ret
040B33             0123*  
040B33             0124*  ; UH.L = UH.L*UD.E (unsigned)
040B33             0125*  umul168:
040B33 CD B8 0A 04 0126*  	call mul24
040B37 2A B3 0A 04 0127*  	ld hl,(mul24out+1)
040B3B C9          0128*  	ret
040B3C             0129*  
040B3C             0130*  ; UH.L * UD.E --> UH.L (signed)
040B3C             0131*  smul168:
040B3C             0132*  ; make everything positive and store sign flags
040B3C CD 94 06 04 0133*  	call hlu_abs
040B40 F5          0134*  	push af
040B41 EB          0135*  	ex de,hl
040B42 CD 94 06 04 0136*  	call hlu_abs
040B46 EB          0137*  	ex de,hl
040B47 F5          0138*  	push af
040B48             0139*  ; do the division
040B48 CD 33 0B 04 0140*      call umul168 ; hl = product
040B4C             0141*  ; adjust sign of result
040B4C F1          0142*  	pop af ; sign de
040B4D FA 58 0B 04 0143*  	jp m,@de_neg
040B51 F1          0144*  	pop af ; sign hl
040B52 F0          0145*  	ret p ; both positive, nothing to do
040B53             0146*  @hl_neg:
040B53 CD A4 06 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
040B57 C9          0148*      ret
040B58             0149*  @de_neg:
040B58 F1          0150*  	pop af
040B59 F8          0151*  	ret m ; both negative, nothing to do
040B5A CD A4 06 04 0152*  	call neg_hlu ; result is negative
040B5E C9          0153*  	ret
040B5F             0154*  
040B5F             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040B5F             0156*  ; perform unsigned division of 16.8 fixed place values
040B5F             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040B5F             0158*  udiv168:
040B5F             0159*  ; back up divisor
040B5F ED 53 96 0B 0160*  	ld (@ude),de
       04          
040B64             0161*  ; get the 16-bit integer part of the quotient
040B64 CD C7 0B 04 0162*      call udiv24 ; de = quotient, hl = remainder
040B68             0163*  ; load quotient to upper three bytes of output
040B68 ED 53 9D 0B 0164*      ld (div168_out+1),de
       04          
040B6D             0165*  @div256:
040B6D             0166*  ; multiply remainder by 256
040B6D             0167*  	hlu_mul256
040B6D 29          0001*M         add hl,hl ; * 2
040B6E 29          0002*M         add hl,hl ; * 4
040B6F 29          0003*M         add hl,hl ; * 8
040B70 29          0004*M         add hl,hl ; * 16
040B71 29          0005*M         add hl,hl ; * 32
040B72 29          0006*M         add hl,hl ; * 64
040B73 29          0007*M         add hl,hl ; * 128
040B74 29          0008*M         add hl,hl ; * 256
040B75             0168*  ; skip fractional computation if remainder is zero
040B75             0169*      sign_hlu
040B75 19          0001*M         add hl,de
040B76 B7          0002*M         or a
040B77 ED 52       0003*M         sbc hl,de
040B79 20 03       0170*      jr nz,@div_frac
040B7B AF          0171*      xor a
040B7C 18 0A       0172*      jr @write_frac
040B7E             0173*  ; now divide the shifted remainder by the divisor
040B7E             0174*  @div_frac:
040B7E ED 5B 96 0B 0175*  	ld de,(@ude) ; get back divisor
       04          
040B83 CD C7 0B 04 0176*      call udiv24 ; de = quotient, hl = remainder
040B87             0177*  ; load low byte of quotient to low byte of output
040B87 7B          0178*      ld a,e
040B88             0179*  @write_frac:
040B88 32 9C 0B 04 0180*      ld (div168_out),a
040B8C             0181*  ; load de with return value
040B8C ED 5B 9C 0B 0182*      ld de,(div168_out)
       04          
040B91             0183*  ; load a with any overflow
040B91 3A 9F 0B 04 0184*      ld a,(div168_out+3)
040B95 C9          0185*      ret ; ud.e is the 16.8 result
040B96             0186*  @ude: ds 6
040B9C             0187*  div168_out: ds 4 ; the extra byte is for overflow
040BA0             0188*  
040BA0             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040BA0             0190*  ; perform signed division of 16.8 fixed place values
040BA0             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040BA0             0192*  sdiv168:
040BA0             0193*  ; make everything positive and store sign flags
040BA0 CD 94 06 04 0194*  	call hlu_abs
040BA4 F5          0195*  	push af
040BA5 EB          0196*  	ex de,hl
040BA6 CD 94 06 04 0197*  	call hlu_abs
040BAA EB          0198*  	ex de,hl
040BAB F5          0199*  	push af
040BAC             0200*  ; do the division
040BAC CD 5F 0B 04 0201*      call udiv168 ; de = quotient, hl = remainder
040BB0             0202*  ; adjust sign of result
040BB0 F1          0203*  	pop af ; sign de
040BB1 FA BE 0B 04 0204*  	jp m,@de_neg
040BB5 F1          0205*  	pop af ; sign hl
040BB6 F0          0206*  	ret p ; both positive, nothing to do
040BB7             0207*  @hl_neg:
040BB7 EB          0208*      ex de,hl ; hl = quotient, de = remainder
040BB8 CD A4 06 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
040BBC EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
040BBD C9          0211*      ret
040BBE             0212*  @de_neg:
040BBE F1          0213*  	pop af
040BBF F8          0214*  	ret m ; both negative, nothing to do
040BC0 EB          0215*      ex de,hl ; hl = quotient, de = remainder
040BC1 CD A4 06 04 0216*  	call neg_hlu ; result is negative
040BC5 EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
040BC6 C9          0218*  	ret
040BC7             0219*  
040BC7             0220*  ;------------------------------------------------------------------------
040BC7             0221*  ;  arith24.asm
040BC7             0222*  ;  24-bit ez80 arithmetic routines
040BC7             0223*  ;  Copyright (c) Shawn Sijnstra 2024
040BC7             0224*  ;  MIT license
040BC7             0225*  ;
040BC7             0226*  ;  This library was created as a tool to help make ez80
040BC7             0227*  ;  24-bit native assembly routines for simple mathematical problems
040BC7             0228*  ;  more widely available.
040BC7             0229*  ;
040BC7             0230*  ;------------------------------------------------------------------------
040BC7             0231*  ;
040BC7             0232*  ;------------------------------------------------------------------------
040BC7             0233*  ; udiv24
040BC7             0234*  ; Unsigned 24-bit division
040BC7             0235*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040BC7             0236*  ;
040BC7             0237*  ; Uses AF BC DE HL
040BC7             0238*  ; Uses Restoring Division algorithm
040BC7             0239*  ;------------------------------------------------------------------------
040BC7             0240*  
040BC7             0241*  udiv24:
040BC7 E5          0242*  	push	hl
040BC8 C1          0243*  	pop		bc	;move dividend to BCU
040BC9 21 00 00 00 0244*  	ld		hl,0	;result
040BCD A7          0245*  	and		a
040BCE ED 52       0246*  	sbc		hl,de	;test for div by 0
040BD0 C8          0247*  	ret		z		;it's zero, carry flag is clear
040BD1 19          0248*  	add		hl,de	;HL is 0 again
040BD2 3E 18       0249*  	ld		a,24	;number of loops through.
040BD4             0250*  udiv1:
040BD4 C5          0251*  	push	bc	;complicated way of doing this because of lack of access to top bits
040BD5 E3          0252*  	ex		(sp),hl
040BD6 37          0253*  	scf
040BD7 ED 6A       0254*  	adc	hl,hl
040BD9 E3          0255*  	ex	(sp),hl
040BDA C1          0256*  	pop	bc		;we now have bc = (bc * 2) + 1
040BDB             0257*  
040BDB ED 6A       0258*  	adc	hl,hl
040BDD A7          0259*  	and	a		;is this the bug
040BDE ED 52       0260*  	sbc	hl,de
040BE0 30 02       0261*  	jr	nc,udiv2
040BE2 19          0262*  	add	hl,de
040BE3             0263*  ;	dec	c
040BE3 0B          0264*  	dec	bc
040BE4             0265*  udiv2:
040BE4 3D          0266*  	dec	a
040BE5 20 ED       0267*  	jr	nz,udiv1
040BE7 37          0268*  	scf		;flag used for div0 error
040BE8 C5          0269*  	push	bc
040BE9 D1          0270*  	pop		de	;remainder
040BEA C9          0271*  	ret
040BEB             0272*  
040BEB             0273*  ;------------------------------------------------------------------------
040BEB             0274*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
040BEB             0275*  ;------------------------------------------------------------------------
040BEB             0276*  
040BEB             0277*  
040BEB             0278*      ; include "trig24fast.inc"
040BEB             0279*  
040BEB             0280*  
040BEB             0281*  ; convert signed angles from a 360 to 256 degree circle
040BEB             0282*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040BEB             0283*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040BEB             0284*  ; destroys: TODO
040BEB             0285*  deg_360_to_256:
040BEB D5          0286*  	push de ; preserve de
040BEC             0287*  ; make angle positive and store sign flag
040BEC CD 94 06 04 0288*  	call hlu_abs
040BF0 F5          0289*  	push af
040BF1             0290*  ; multiply by coversion factor of 256/360
040BF1 11 B6 00 00 0291*  	ld de,0x0000B6 ; 0.711
040BF5 CD 33 0B 04 0292*  	call umul168 ; uh.l = uh.l * 0.711
040BF9             0293*  ; restore sign flag and adjust output accordingly
040BF9 F1          0294*  	pop af
040BFA F2 02 0C 04 0295*  	jp p,@pos ; positive number
040BFE CD A4 06 04 0296*  	call neg_hlu
040C02             0297*  @pos:
040C02             0298*  ; restore de and return uh.l as the result
040C02 D1          0299*  	pop de
040C03 C9          0300*  	ret
040C04             0301*  
040C04             0302*  ; convert signed angles from a 256 to 360 degree circle
040C04             0303*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040C04             0304*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040C04             0305*  ; destroys: TODO
040C04             0306*  deg_256_to_360:
040C04 D5          0307*  	push de ; preserve de
040C05             0308*  ; make angle positive and store sign flag
040C05 CD 94 06 04 0309*  	call hlu_abs
040C09 F5          0310*  	push af
040C0A             0311*  ; multiply by coversion factor of 360/256
040C0A 11 68 01 00 0312*      ld de,0x000168 ; 1.406
040C0E CD 33 0B 04 0313*  	call umul168 ; uh.l = uh.l * 1.406
040C12             0314*  ; restore sign flag and adjust output accordingly
040C12 F1          0315*  	pop af
040C13 F2 1B 0C 04 0316*  	jp p,@pos ; positive number
040C17 CD A4 06 04 0317*  	call neg_hlu
040C1B             0318*  @pos:
040C1B             0319*  ; restore de and return uh.l as the result
040C1B D1          0320*  	pop de
040C1C C9          0321*  	ret
040C1D             0322*  
040C1D             0323*  ; fixed 16.8 routine
040C1D             0324*  ; cos(uh.l) --> uh.l
040C1D             0325*  ; destroys: f, hl
040C1D             0326*  cos168:
040C1D D5          0327*      push de ; preserve de
040C1E             0328*  ; for cos we simply increment the angle by 90 degrees
040C1E             0329*  ; or 0x004000 in 16.8 degrees256
040C1E             0330*  ; which makes it a sin problem
040C1E 11 00 40 00 0331*      ld de,0x004000
040C22 19          0332*      add hl,de ; modulo 256 happens below
040C23 D1          0333*      pop de ; restore de
040C24             0334*  ; fall through to sin168
040C24             0335*  
040C24             0336*  ; ---------------------
040C24             0337*  ; fixed 16.8 routine
040C24             0338*  ; sin(uh.l) --> uh.l
040C24             0339*  ; destroys: f, hl
040C24             0340*  sin168:
040C24 D5          0341*  	push de
040C25             0342*  ; handle negative angles appropriately
040C25 CD 94 06 04 0343*  	call hlu_abs
040C29 F2 32 0C 04 0344*  	jp p,@F
040C2D 11 00 00 FF 0345*  	ld de,-256*256
040C31 19          0346*  	add hl,de
040C32             0347*  @@:
040C32 2E 03       0348*  	ld l,3 ; multiply by 3 to get our lookup index
040C34 ED 6C       0349*      mlt hl
040C36 11 82 0E 04 0350*      ld de,sin_lut_168 ; grab the lut address
040C3A 19          0351*      add hl,de ; bump hl by the index
040C3B ED 27       0352*      ld hl,(hl) ; don't try this on a z80!
040C3D D1          0353*      pop de
040C3E C9          0354*      ret
040C3F             0355*  
040C3F             0356*  ; 16.8 fixed inputs / outputs
040C3F             0357*  ; takes: uh.l as angle in degrees 256
040C3F             0358*  ;        ud.e as radius
040C3F             0359*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040C3F             0360*  ;        displacements from origin (0,0)
040C3F             0361*  ; destroys: everything except indexes
040C3F             0362*  polar_to_cartesian:
040C3F             0363*  ; back up input parameters
040C3F 22 6E 0C 04 0364*      ld (@angle), hl
040C43 ED 53 71 0C 0365*      ld (@radius), de
       04          
040C48             0366*  ; compute dx = sin(uh.l) * ud.e
040C48 CD 24 0C 04 0367*      call sin168 ; uh.l = sin(uh.l)
040C4C ED 5B 71 0C 0368*  	ld de,(@radius)
       04          
040C51 CD 3C 0B 04 0369*  	call smul168 ; uh.l = dx
040C55 E5          0370*      push hl
040C56             0371*  ; compute dy = -cos(uh.l) * ud.e
040C56 2A 6E 0C 04 0372*      ld hl,(@angle)
040C5A CD 1D 0C 04 0373*      call cos168 ; uh.l = cos(uh.l)
040C5E ED 5B 71 0C 0374*      ld de,(@radius)
       04          
040C63 CD 3C 0B 04 0375*      call smul168    ; uh.l = dy
040C67 CD A4 06 04 0376*      call neg_hlu ; invert dy for screen coords convention
040C6B EB          0377*      ex de,hl       ; de = dy for output
040C6C C1          0378*      pop bc          ; bc = dx for output
040C6D             0379*  ; and out
040C6D C9          0380*      ret
040C6E             0381*  @angle: ds 3
040C71             0382*  @radius: ds 3
040C74             0383*  
040C74             0384*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C74             0385*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C74             0386*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C74             0387*  ;         also populates scratch locations dx168 and dy168
040C74             0388*  ; destroys: a,hl,bc,de
040C74             0389*  dxy168:
040C74             0390*  ; compute dx = x1-x0
040C74 AF          0391*      xor a ; clear carry
040C75 DD E5       0392*      push ix ; move ix to hl via the stack
040C77 E1          0393*      pop hl ; hl = x1
040C78 ED 42       0394*      sbc hl,bc ; hl = dx
040C7A 22 8F 0C 04 0395*      ld (dx168),hl ; dx to scratch
040C7E             0396*  ; compute dy = y1-y0
040C7E AF          0397*      xor a ; clear carry
040C7F FD E5       0398*      push iy ; move iy to hl via the stack
040C81 E1          0399*      pop hl ; hl = y1
040C82 ED 52       0400*      sbc hl,de ; hl = dy
040C84 22 95 0C 04 0401*      ld (dy168),hl ; dy to scratch
040C88             0402*  ; populate output registers and return
040C88 EB          0403*      ex de,hl        ; ud.e = dy
040C89 ED 4B 8F 0C 0404*      ld bc,(dx168)   ; ub.c = dx
       04          
040C8E C9          0405*      ret
040C8F 00 00 00 00 0406*  dx168: blkb 6,0
       00 00       
040C95 00 00 00 00 0407*  dy168: blkb 6,0
       00 00       
040C9B             0408*  
040C9B             0409*  ; compute the euclidian distance between two cartesian coordinates
040C9B             0410*  ; using the formula d = sqrt(dx^2+dy^2)
040C9B             0411*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C9B             0412*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C9B             0413*  ; output; uh.l is the 16.8 fixed format distance
040C9B             0414*  ;         also populates scratch locations dx168 and dy168
040C9B             0415*  ; destroys: a,hl,bc,de
040C9B             0416*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C9B             0417*  ;       thus the result will always be an integer, albeit in 16.8 format
040C9B             0418*  distance168:
040C9B CD 74 0C 04 0419*  	call dxy168 ; ub.c = dx, ud.e = dy
040C9F             0420*  ; compute dy^2
040C9F EB          0421*  	ex de,hl
040CA0 CD 94 06 04 0422*  	call hlu_abs
040CA4 CD FB 06 04 0423*  	call hlu_udiv256 ; make integer to avoid overflow
040CA8 E5          0424*  	push hl
040CA9 D1          0425*  	pop de
040CAA CD 2A 0B 04 0426*  	call umul24 ; hl = dy^2
040CAE E5          0427*  	push hl ; save dy^2
040CAF             0428*  ; compute dx^2
040CAF 2A 8F 0C 04 0429*  	ld hl,(dx168)
040CB3 CD 94 06 04 0430*  	call hlu_abs
040CB7 CD FB 06 04 0431*  	call hlu_udiv256 ; make integer to avoid overflow
040CBB E5          0432*  	push hl
040CBC D1          0433*  	pop de
040CBD CD 2A 0B 04 0434*  	call umul24 ; hl = dx^2
040CC1             0435*  ; add dx^2 and dy^2
040CC1 D1          0436*  	pop de ; de = dy^2 (was hl)
040CC2 19          0437*  	add hl,de ; hl = dx^2 + dy^2
040CC3             0438*  ; compute the square root
040CC3 CD 9C 0D 04 0439*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
040CC7 EB          0440*      ex de,hl ; hl = distance
040CC8             0441*      hlu_mul256 ; convert back to 16.8 fixed
040CC8 29          0001*M         add hl,hl ; * 2
040CC9 29          0002*M         add hl,hl ; * 4
040CCA 29          0003*M         add hl,hl ; * 8
040CCB 29          0004*M         add hl,hl ; * 16
040CCC 29          0005*M         add hl,hl ; * 32
040CCD 29          0006*M         add hl,hl ; * 64
040CCE 29          0007*M         add hl,hl ; * 128
040CCF 29          0008*M         add hl,hl ; * 256
040CD0 C9          0442*  	ret
040CD1             0443*  
040CD1             0444*  ; atan2_(ub.c,ud.e) --> uh.l
040CD1             0445*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CD1             0446*  ;   whether inputs are integers or fractional doesn't matter
040CD1             0447*  ;   so long as the sign bit of the upper byte is correct
040CD1             0448*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040CD1             0449*  ; angles are COMPASS HEADINGS based on
040CD1             0450*  ; screen coordinate conventions,where the y axis is flipped
040CD1             0451*  ; #E0 315      0       45 #20
040CD1             0452*  ;        -x,-y | +x,-y
040CD1             0453*  ; #C0 270------+------ 90 #40
040CD1             0454*  ;        -x,+y | +x,+y
040CD1             0455*  ; #A0 225   180 #80   135 #60
040CD1             0456*  atan2_168fast:
040CD1             0457*  ; get signs and make everything positive
040CD1             0458*  ; get abs(x) and store its original sign
040CD1 C5          0459*      push bc
040CD2 E1          0460*      pop hl
040CD3 CD 94 06 04 0461*      call hlu_abs ; if x was negative this also sets the sign flag
040CD7 E5          0462*      push hl ; store abs(x)
040CD8 C1          0463*      pop bc ; bc = abs(x)
040CD9 F5          0464*      push af ; store sign of x
040CDA             0465*  ; get abs(y) and store its original sign
040CDA EB          0466*      ex de,hl ; hl = y
040CDB CD 94 06 04 0467*      call hlu_abs ; if y was negative this also sets the sign flag
040CDF EB          0468*      ex de,hl ; de = abs(y)
040CE0 F5          0469*      push af ; store sign of y
040CE1             0470*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CE1             0471*  ; this ensures that our lookup value is between 0 and 1 inclusive
040CE1 AF          0472*      xor a ; clear the carry flag
040CE2 D5          0473*      push de
040CE3 E1          0474*      pop hl
040CE4 ED 42       0475*      sbc hl,bc
040CE6 F5          0476*      push af ; save sign of de - bc
040CE7 F2 F0 0C 04 0477*      jp p,@1 ; bc <= de, so we skip ahead
040CEB             0478*  ; otherwise we swap bc and de
040CEB C5          0479*      push bc
040CEC E1          0480*      pop hl
040CED EB          0481*      ex de,hl
040CEE E5          0482*      push hl
040CEF C1          0483*      pop bc
040CF0             0484*  @1:
040CF0             0485*  ; now we're ready to snag our preliminary result
040CF0 C5          0486*  	push bc
040CF1 E1          0487*  	pop hl
040CF2 CD 60 0D 04 0488*      call atan_168fast ; uh.l comes back with prelim result
040CF6             0489*  ; now we adjust uh.l based on sign of de - bc
040CF6 F1          0490*      pop af
040CF7 F2 03 0D 04 0491*      jp p,@2 ; bc <= de,so we skip ahead
040CFB EB          0492*      ex de,hl
040CFC 21 00 40 00 0493*      ld hl,0x004000 ; 90 degrees
040D00 AF          0494*      xor a ; clear the carry flag
040D01 ED 52       0495*      sbc hl,de ; subtract result from 90 degrees
040D03             0496*  @2:
040D03             0497*  ; now the fun part of adjusting the result
040D03             0498*  ; based on which quadrant (x,y) is in
040D03             0499*  ; #E0 315      0       45 #20
040D03             0500*  ;        -x,-y | +x,-y
040D03             0501*  ; #C0 270------+------ 90 #40
040D03             0502*  ;        -x,+y | +x,+y
040D03             0503*  ; #A0 225   180 #80   135 #60
040D03 F1          0504*      pop af ; sign of y
040D04 CA 41 0D 04 0505*      jp z,@y_zero
040D08 F2 21 0D 04 0506*      jp p,@y_pos
040D0C             0507*  ; y neg,check x
040D0C F1          0508*      pop af ; sign of x
040D0D CA 1B 0D 04 0509*      jp z,@y_neg_x_zero
040D11 F2 20 0D 04 0510*      jp p,@y_neg_x_pos
040D15             0511*  ; y neg,x neg
040D15             0512*  ; angle is 270-360
040D15             0513*  ; negating the intermediate does the trick
040D15 CD A4 06 04 0514*      call neg_hlu
040D19 18 31       0515*      jr @zero_hlu
040D1B             0516*  
040D1B             0517*  @y_neg_x_zero:
040D1B             0518*  ; y neg,x zero
040D1B             0519*  ; angle is 0
040D1B 21 00 00 00 0520*      ld hl,0
040D1F C9          0521*      ret
040D20             0522*  @y_neg_x_pos:
040D20             0523*  ; y neg,x pos
040D20             0524*  ; angle is 0 to 90
040D20             0525*  ; so we're good
040D20 C9          0526*      ret
040D21             0527*  
040D21             0528*  @y_pos:
040D21 F1          0529*      pop af ; sign of x
040D22 CA 31 0D 04 0530*      jp z,@y_pos_x_zero
040D26 F2 36 0D 04 0531*      jp p,@y_pos_x_pos
040D2A             0532*  ; y pos,x neg
040D2A             0533*  ; angle is 180-270
040D2A             0534*  ; so we add 180 to intermediate
040D2A 11 00 80 00 0535*      ld de,0x008000
040D2E 19          0536*      add hl,de
040D2F 18 1B       0537*      jr @zero_hlu
040D31             0538*  @y_pos_x_zero:
040D31             0539*  ; y pos,x zero
040D31             0540*  ; angle is 180
040D31 21 00 80 00 0541*      ld hl,0x008000
040D35 C9          0542*      ret
040D36             0543*  @y_pos_x_pos:
040D36             0544*  ; y pos,x pos
040D36             0545*  ; angle is 90-180
040D36             0546*  ; neg the intermediate and add 180 degrees
040D36 CD A4 06 04 0547*      call neg_hlu
040D3A 11 00 80 00 0548*      ld de,0x008000
040D3E 19          0549*      add hl,de
040D3F 18 0B       0550*      jr @zero_hlu
040D41             0551*  
040D41             0552*  @y_zero:
040D41 F1          0553*      pop af ; sign of x
040D42 FA 47 0D 04 0554*      jp m,@y_zero_x_neg
040D46             0555*  ; y zero,x pos
040D46             0556*  ; angle is 90,nothing to do
040D46 C9          0557*      ret
040D47             0558*  @y_zero_x_neg:
040D47             0559*  ; y zero ,x neg
040D47             0560*  ; angle is 270
040D47 21 00 C0 00 0561*      ld hl,0x00C000
040D4B C9          0562*      ret
040D4C             0563*  @zero_hlu:
040D4C AF          0564*      xor a
040D4D 22 5A 0D 04 0565*      ld (@scratch),hl
040D51 32 5C 0D 04 0566*      ld (@scratch+2),a
040D55 2A 5A 0D 04 0567*      ld hl,(@scratch)
040D59 C9          0568*      ret
040D5A             0569*  @scratch: ds 6
040D60             0570*  
040D60             0571*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D60             0572*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D60             0573*  ; destroys: a,hl,bc,de
040D60             0574*  ; note: only works for angles from 0 to 32 (45) degrees
040D60             0575*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D60             0576*  atan_168fast:
040D60             0577*  ; because we use compass headings instead of geometric angles
040D60             0578*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040D60             0579*  ; we can do faster unsigned division here because we know dx and dy are positive
040D60 CD 5F 0B 04 0580*  	call udiv168 ; ud.e = dx/dy
040D64 EB          0581*  	ex de,hl ; uh.l = dx/dy
040D65             0582*  ; test uh.l for 0
040D65 19          0583*      add hl,de
040D66 B7          0584*      or a
040D67 ED 52       0585*      sbc hl,de
040D69 28 22       0586*      jr z,@is_zero
040D6B             0587*  ; test uh.l for 1
040D6B AF          0588*      xor a ; clear carry
040D6C EB          0589*      ex de,hl
040D6D 21 00 01 00 0590*      ld hl,0x000100 ; 1 in 16.8 fixed format
040D71 ED 52       0591*      sbc hl,de
040D73 28 13       0592*      jr z,@is_45
040D75 EB          0593*  	ex de,hl
040D76             0594*  ; no special cases so we move on
040D76             0595*  ; l contains the fractional portion of tan(uh.l)
040D76             0596*  ; we multiply it by three to get our lookup table index
040D76 26 03       0597*      ld h,3
040D78 ED 6C       0598*      mlt hl ; gosh that is handy
040D7A 11 00 00 00 0599*      ld de,0 ; clear deu
040D7E 54          0600*      ld d,h ; copy hl to de
040D7F 5D          0601*      ld e,l ; de contains our index
040D80 21 85 11 04 0602*      ld hl,atan_lut_168 ; grab the lut address
040D84 19          0603*      add hl,de ; bump hl by the index
040D85 ED 27       0604*      ld hl,(hl) ; don't try this on a z80!
040D87 C9          0605*      ret ; and out
040D88             0606*  @is_45:
040D88 21 00 20 00 0607*      ld hl,0x002000 ; 45 degrees decimal
040D8C C9          0608*      ret
040D8D             0609*  ; for the case tan(0)
040D8D             0610*  @is_zero:
040D8D 21 00 00 00 0611*      ld hl,0x000000
040D91 C9          0612*      ret
040D92             0613*  
040D92             0614*  ; Expects  ADL mode
040D92             0615*  ; Inputs:  UH.L
040D92             0616*  ; Outputs: UH.L is the 16.8 square root
040D92             0617*  ;          UDE is the integer difference inputHL-DE^2
040D92             0618*  sqrt168:
040D92 CD 9C 0D 04 0619*      call sqrt24
040D96 EB          0620*      ex de,hl
040D97 29          0621*      add hl,hl
040D98 29          0622*      add hl,hl
040D99 29          0623*      add hl,hl
040D9A 29          0624*      add hl,hl
040D9B C9          0625*      ret
040D9C             0626*  
040D9C             0627*  ; credit: xeda112358
040D9C             0628*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D9C             0629*  sqrt24:
040D9C             0630*  ; Expects ADL mode
040D9C             0631*  ; Inputs: HL
040D9C             0632*  ; Outputs: DE is the integer square root
040D9C             0633*  ;  HL is the difference inputHL-DE^2
040D9C             0634*  ;  c flag reset
040D9C 01 00 00 00 0635*  	ld bc,0 ; clear bcu
040DA0 11 00 00 00 0636*  	ld de,0 ; clear deu
040DA4 AF          0637*      xor a
040DA5 45          0638*      ld b,l
040DA6 C5          0639*      push bc
040DA7 47          0640*      ld b,a
040DA8 6F          0641*      ld l,a
040DA9             0642*  ; Iteration 1
040DA9 29          0643*      add hl,hl
040DAA CB 11       0644*      rl c
040DAC 29          0645*      add hl,hl
040DAD CB 11       0646*      rl c
040DAF 91          0647*      sub c
040DB0 30 04       0648*      jr nc,$+6
040DB2 1C          0649*      inc e
040DB3 1C          0650*      inc e
040DB4 2F          0651*      cpl
040DB5 4F          0652*      ld c,a
040DB6             0653*  ; Iteration 2
040DB6 29          0654*      add hl,hl
040DB7 CB 11       0655*      rl c
040DB9 29          0656*      add hl,hl
040DBA CB 11       0657*      rl c
040DBC CB 13       0658*      rl e
040DBE 7B          0659*      ld a,e
040DBF 91          0660*      sub c
040DC0 30 04       0661*      jr nc,$+6
040DC2 1C          0662*      inc e
040DC3 1C          0663*      inc e
040DC4 2F          0664*      cpl
040DC5 4F          0665*      ld c,a
040DC6             0666*  ; Iteration 3
040DC6 29          0667*      add hl,hl
040DC7 CB 11       0668*      rl c
040DC9 29          0669*      add hl,hl
040DCA CB 11       0670*      rl c
040DCC CB 13       0671*      rl e
040DCE 7B          0672*      ld a,e
040DCF 91          0673*      sub c
040DD0 30 04       0674*      jr nc,$+6
040DD2 1C          0675*      inc e
040DD3 1C          0676*      inc e
040DD4 2F          0677*      cpl
040DD5 4F          0678*      ld c,a
040DD6             0679*  ; Iteration 4
040DD6 29          0680*      add hl,hl
040DD7 CB 11       0681*      rl c
040DD9 29          0682*      add hl,hl
040DDA CB 11       0683*      rl c
040DDC CB 13       0684*      rl e
040DDE 7B          0685*      ld a,e
040DDF 91          0686*      sub c
040DE0 30 04       0687*      jr nc,$+6
040DE2 1C          0688*      inc e
040DE3 1C          0689*      inc e
040DE4 2F          0690*      cpl
040DE5 4F          0691*      ld c,a
040DE6             0692*  ; Iteration 5
040DE6 29          0693*      add hl,hl
040DE7 CB 11       0694*      rl c
040DE9 29          0695*      add hl,hl
040DEA CB 11       0696*      rl c
040DEC CB 13       0697*      rl e
040DEE 7B          0698*      ld a,e
040DEF 91          0699*      sub c
040DF0 30 04       0700*      jr nc,$+6
040DF2 1C          0701*      inc e
040DF3 1C          0702*      inc e
040DF4 2F          0703*      cpl
040DF5 4F          0704*      ld c,a
040DF6             0705*  ; Iteration 6
040DF6 29          0706*      add hl,hl
040DF7 CB 11       0707*      rl c
040DF9 29          0708*      add hl,hl
040DFA CB 11       0709*      rl c
040DFC CB 13       0710*      rl e
040DFE 7B          0711*      ld a,e
040DFF 91          0712*      sub c
040E00 30 04       0713*      jr nc,$+6
040E02 1C          0714*      inc e
040E03 1C          0715*      inc e
040E04 2F          0716*      cpl
040E05 4F          0717*      ld c,a
040E06             0718*  ; Iteration 7
040E06 29          0719*      add hl,hl
040E07 CB 11       0720*      rl c
040E09 29          0721*      add hl,hl
040E0A CB 11       0722*      rl c
040E0C CB 10       0723*      rl b
040E0E EB          0724*      ex de,hl
040E0F 29          0725*      add hl,hl
040E10 E5          0726*      push hl
040E11 ED 42       0727*      sbc hl,bc
040E13 30 06       0728*      jr nc,$+8
040E15 7C          0729*      ld a,h
040E16 2F          0730*      cpl
040E17 47          0731*      ld b,a
040E18 7D          0732*      ld a,l
040E19 2F          0733*      cpl
040E1A 4F          0734*      ld c,a
040E1B E1          0735*      pop hl
040E1C 30 02       0736*      jr nc,$+4
040E1E 23          0737*      inc hl
040E1F 23          0738*      inc hl
040E20 EB          0739*      ex de,hl
040E21             0740*  ; Iteration 8
040E21 29          0741*      add hl,hl
040E22 69          0742*      ld l,c
040E23 60          0743*      ld h,b
040E24 ED 6A       0744*      adc hl,hl
040E26 ED 6A       0745*      adc hl,hl
040E28 EB          0746*      ex de,hl
040E29 29          0747*      add hl,hl
040E2A ED 52       0748*      sbc hl,de
040E2C 19          0749*      add hl,de
040E2D EB          0750*      ex de,hl
040E2E 30 04       0751*      jr nc,$+6
040E30 ED 52       0752*      sbc hl,de
040E32 13          0753*      inc de
040E33 13          0754*      inc de
040E34             0755*  ; Iteration 9
040E34 F1          0756*      pop af
040E35 17          0757*      rla
040E36 ED 6A       0758*      adc hl,hl
040E38 17          0759*      rla
040E39 ED 6A       0760*      adc hl,hl
040E3B EB          0761*      ex de,hl
040E3C 29          0762*      add hl,hl
040E3D ED 52       0763*      sbc hl,de
040E3F 19          0764*      add hl,de
040E40 EB          0765*      ex de,hl
040E41 30 04       0766*      jr nc,$+6
040E43 ED 52       0767*      sbc hl,de
040E45 13          0768*      inc de
040E46 13          0769*      inc de
040E47             0770*  ; Iteration 10
040E47 17          0771*      rla
040E48 ED 6A       0772*      adc hl,hl
040E4A 17          0773*      rla
040E4B ED 6A       0774*      adc hl,hl
040E4D EB          0775*      ex de,hl
040E4E 29          0776*      add hl,hl
040E4F ED 52       0777*      sbc hl,de
040E51 19          0778*      add hl,de
040E52 EB          0779*      ex de,hl
040E53 30 04       0780*      jr nc,$+6
040E55 ED 52       0781*      sbc hl,de
040E57 13          0782*      inc de
040E58 13          0783*      inc de
040E59             0784*  ; Iteration 11
040E59 17          0785*      rla
040E5A ED 6A       0786*      adc hl,hl
040E5C 17          0787*      rla
040E5D ED 6A       0788*      adc hl,hl
040E5F EB          0789*      ex de,hl
040E60 29          0790*      add hl,hl
040E61 ED 52       0791*      sbc hl,de
040E63 19          0792*      add hl,de
040E64 EB          0793*      ex de,hl
040E65 30 04       0794*      jr nc,$+6
040E67 ED 52       0795*      sbc hl,de
040E69 13          0796*      inc de
040E6A 13          0797*      inc de
040E6B             0798*  ; Iteration 12
040E6B 17          0799*      rla
040E6C ED 6A       0800*      adc hl,hl
040E6E 17          0801*      rla
040E6F ED 6A       0802*      adc hl,hl
040E71 EB          0803*      ex de,hl
040E72 29          0804*      add hl,hl
040E73 ED 52       0805*      sbc hl,de
040E75 19          0806*      add hl,de
040E76 EB          0807*      ex de,hl
040E77 30 04       0808*      jr nc,$+6
040E79 ED 52       0809*      sbc hl,de
040E7B 13          0810*      inc de
040E7C 13          0811*      inc de
040E7D CB 1A       0812*      rr d
040E7F CB 1B       0813*      rr e
040E81 C9          0814*      ret
040E82             0815*  
040E82             0816*  sin_lut_168:
040E82 00 00 00    0817*  	dl 0x000000 ; 0.000 00, 0.000
040E85 06 00 00    0818*  	dl 0x000006 ; 1.406 01, 0.025
040E88 0C 00 00    0819*  	dl 0x00000C ; 2.813 02, 0.049
040E8B 12 00 00    0820*  	dl 0x000012 ; 4.219 03, 0.074
040E8E 19 00 00    0821*  	dl 0x000019 ; 5.625 04, 0.098
040E91 1F 00 00    0822*  	dl 0x00001F ; 7.031 05, 0.122
040E94 25 00 00    0823*  	dl 0x000025 ; 8.438 06, 0.147
040E97 2B 00 00    0824*  	dl 0x00002B ; 9.844 07, 0.171
040E9A 31 00 00    0825*  	dl 0x000031 ; 11.250 08, 0.195
040E9D 38 00 00    0826*  	dl 0x000038 ; 12.656 09, 0.219
040EA0 3E 00 00    0827*  	dl 0x00003E ; 14.063 0A, 0.243
040EA3 44 00 00    0828*  	dl 0x000044 ; 15.469 0B, 0.267
040EA6 4A 00 00    0829*  	dl 0x00004A ; 16.875 0C, 0.290
040EA9 50 00 00    0830*  	dl 0x000050 ; 18.281 0D, 0.314
040EAC 56 00 00    0831*  	dl 0x000056 ; 19.688 0E, 0.337
040EAF 5C 00 00    0832*  	dl 0x00005C ; 21.094 0F, 0.360
040EB2 61 00 00    0833*  	dl 0x000061 ; 22.500 10, 0.383
040EB5 67 00 00    0834*  	dl 0x000067 ; 23.906 11, 0.405
040EB8 6D 00 00    0835*  	dl 0x00006D ; 25.313 12, 0.428
040EBB 73 00 00    0836*  	dl 0x000073 ; 26.719 13, 0.450
040EBE 78 00 00    0837*  	dl 0x000078 ; 28.125 14, 0.471
040EC1 7E 00 00    0838*  	dl 0x00007E ; 29.531 15, 0.493
040EC4 83 00 00    0839*  	dl 0x000083 ; 30.938 16, 0.514
040EC7 88 00 00    0840*  	dl 0x000088 ; 32.344 17, 0.535
040ECA 8E 00 00    0841*  	dl 0x00008E ; 33.750 18, 0.556
040ECD 93 00 00    0842*  	dl 0x000093 ; 35.156 19, 0.576
040ED0 98 00 00    0843*  	dl 0x000098 ; 36.563 1A, 0.596
040ED3 9D 00 00    0844*  	dl 0x00009D ; 37.969 1B, 0.615
040ED6 A2 00 00    0845*  	dl 0x0000A2 ; 39.375 1C, 0.634
040ED9 A7 00 00    0846*  	dl 0x0000A7 ; 40.781 1D, 0.653
040EDC AB 00 00    0847*  	dl 0x0000AB ; 42.188 1E, 0.672
040EDF B0 00 00    0848*  	dl 0x0000B0 ; 43.594 1F, 0.690
040EE2 B5 00 00    0849*  	dl 0x0000B5 ; 45.000 20, 0.707
040EE5 B9 00 00    0850*  	dl 0x0000B9 ; 46.406 21, 0.724
040EE8 BD 00 00    0851*  	dl 0x0000BD ; 47.813 22, 0.741
040EEB C1 00 00    0852*  	dl 0x0000C1 ; 49.219 23, 0.757
040EEE C5 00 00    0853*  	dl 0x0000C5 ; 50.625 24, 0.773
040EF1 C9 00 00    0854*  	dl 0x0000C9 ; 52.031 25, 0.788
040EF4 CD 00 00    0855*  	dl 0x0000CD ; 53.438 26, 0.803
040EF7 D1 00 00    0856*  	dl 0x0000D1 ; 54.844 27, 0.818
040EFA D4 00 00    0857*  	dl 0x0000D4 ; 56.250 28, 0.831
040EFD D8 00 00    0858*  	dl 0x0000D8 ; 57.656 29, 0.845
040F00 DB 00 00    0859*  	dl 0x0000DB ; 59.063 2A, 0.858
040F03 DE 00 00    0860*  	dl 0x0000DE ; 60.469 2B, 0.870
040F06 E1 00 00    0861*  	dl 0x0000E1 ; 61.875 2C, 0.882
040F09 E4 00 00    0862*  	dl 0x0000E4 ; 63.281 2D, 0.893
040F0C E7 00 00    0863*  	dl 0x0000E7 ; 64.688 2E, 0.904
040F0F EA 00 00    0864*  	dl 0x0000EA ; 66.094 2F, 0.914
040F12 EC 00 00    0865*  	dl 0x0000EC ; 67.500 30, 0.924
040F15 EE 00 00    0866*  	dl 0x0000EE ; 68.906 31, 0.933
040F18 F1 00 00    0867*  	dl 0x0000F1 ; 70.313 32, 0.942
040F1B F3 00 00    0868*  	dl 0x0000F3 ; 71.719 33, 0.950
040F1E F4 00 00    0869*  	dl 0x0000F4 ; 73.125 34, 0.957
040F21 F6 00 00    0870*  	dl 0x0000F6 ; 74.531 35, 0.964
040F24 F8 00 00    0871*  	dl 0x0000F8 ; 75.938 36, 0.970
040F27 F9 00 00    0872*  	dl 0x0000F9 ; 77.344 37, 0.976
040F2A FB 00 00    0873*  	dl 0x0000FB ; 78.750 38, 0.981
040F2D FC 00 00    0874*  	dl 0x0000FC ; 80.156 39, 0.985
040F30 FD 00 00    0875*  	dl 0x0000FD ; 81.563 3A, 0.989
040F33 FE 00 00    0876*  	dl 0x0000FE ; 82.969 3B, 0.992
040F36 FE 00 00    0877*  	dl 0x0000FE ; 84.375 3C, 0.995
040F39 FF 00 00    0878*  	dl 0x0000FF ; 85.781 3D, 0.997
040F3C FF 00 00    0879*  	dl 0x0000FF ; 87.188 3E, 0.999
040F3F FF 00 00    0880*  	dl 0x0000FF ; 88.594 3F, 1.000
040F42 00 01 00    0881*  	dl 0x000100 ; 90.000 40, 1.000
040F45 FF 00 00    0882*  	dl 0x0000FF ; 91.406 41, 1.000
040F48 FF 00 00    0883*  	dl 0x0000FF ; 92.813 42, 0.999
040F4B FF 00 00    0884*  	dl 0x0000FF ; 94.219 43, 0.997
040F4E FE 00 00    0885*  	dl 0x0000FE ; 95.625 44, 0.995
040F51 FE 00 00    0886*  	dl 0x0000FE ; 97.031 45, 0.992
040F54 FD 00 00    0887*  	dl 0x0000FD ; 98.438 46, 0.989
040F57 FC 00 00    0888*  	dl 0x0000FC ; 99.844 47, 0.985
040F5A FB 00 00    0889*  	dl 0x0000FB ; 101.250 48, 0.981
040F5D F9 00 00    0890*  	dl 0x0000F9 ; 102.656 49, 0.976
040F60 F8 00 00    0891*  	dl 0x0000F8 ; 104.063 4A, 0.970
040F63 F6 00 00    0892*  	dl 0x0000F6 ; 105.469 4B, 0.964
040F66 F4 00 00    0893*  	dl 0x0000F4 ; 106.875 4C, 0.957
040F69 F3 00 00    0894*  	dl 0x0000F3 ; 108.281 4D, 0.950
040F6C F1 00 00    0895*  	dl 0x0000F1 ; 109.688 4E, 0.942
040F6F EE 00 00    0896*  	dl 0x0000EE ; 111.094 4F, 0.933
040F72 EC 00 00    0897*  	dl 0x0000EC ; 112.500 50, 0.924
040F75 EA 00 00    0898*  	dl 0x0000EA ; 113.906 51, 0.914
040F78 E7 00 00    0899*  	dl 0x0000E7 ; 115.313 52, 0.904
040F7B E4 00 00    0900*  	dl 0x0000E4 ; 116.719 53, 0.893
040F7E E1 00 00    0901*  	dl 0x0000E1 ; 118.125 54, 0.882
040F81 DE 00 00    0902*  	dl 0x0000DE ; 119.531 55, 0.870
040F84 DB 00 00    0903*  	dl 0x0000DB ; 120.938 56, 0.858
040F87 D8 00 00    0904*  	dl 0x0000D8 ; 122.344 57, 0.845
040F8A D4 00 00    0905*  	dl 0x0000D4 ; 123.750 58, 0.831
040F8D D1 00 00    0906*  	dl 0x0000D1 ; 125.156 59, 0.818
040F90 CD 00 00    0907*  	dl 0x0000CD ; 126.563 5A, 0.803
040F93 C9 00 00    0908*  	dl 0x0000C9 ; 127.969 5B, 0.788
040F96 C5 00 00    0909*  	dl 0x0000C5 ; 129.375 5C, 0.773
040F99 C1 00 00    0910*  	dl 0x0000C1 ; 130.781 5D, 0.757
040F9C BD 00 00    0911*  	dl 0x0000BD ; 132.188 5E, 0.741
040F9F B9 00 00    0912*  	dl 0x0000B9 ; 133.594 5F, 0.724
040FA2 B5 00 00    0913*  	dl 0x0000B5 ; 135.000 60, 0.707
040FA5 B0 00 00    0914*  	dl 0x0000B0 ; 136.406 61, 0.690
040FA8 AB 00 00    0915*  	dl 0x0000AB ; 137.813 62, 0.672
040FAB A7 00 00    0916*  	dl 0x0000A7 ; 139.219 63, 0.653
040FAE A2 00 00    0917*  	dl 0x0000A2 ; 140.625 64, 0.634
040FB1 9D 00 00    0918*  	dl 0x00009D ; 142.031 65, 0.615
040FB4 98 00 00    0919*  	dl 0x000098 ; 143.438 66, 0.596
040FB7 93 00 00    0920*  	dl 0x000093 ; 144.844 67, 0.576
040FBA 8E 00 00    0921*  	dl 0x00008E ; 146.250 68, 0.556
040FBD 88 00 00    0922*  	dl 0x000088 ; 147.656 69, 0.535
040FC0 83 00 00    0923*  	dl 0x000083 ; 149.063 6A, 0.514
040FC3 7E 00 00    0924*  	dl 0x00007E ; 150.469 6B, 0.493
040FC6 78 00 00    0925*  	dl 0x000078 ; 151.875 6C, 0.471
040FC9 73 00 00    0926*  	dl 0x000073 ; 153.281 6D, 0.450
040FCC 6D 00 00    0927*  	dl 0x00006D ; 154.688 6E, 0.428
040FCF 67 00 00    0928*  	dl 0x000067 ; 156.094 6F, 0.405
040FD2 61 00 00    0929*  	dl 0x000061 ; 157.500 70, 0.383
040FD5 5C 00 00    0930*  	dl 0x00005C ; 158.906 71, 0.360
040FD8 56 00 00    0931*  	dl 0x000056 ; 160.313 72, 0.337
040FDB 50 00 00    0932*  	dl 0x000050 ; 161.719 73, 0.314
040FDE 4A 00 00    0933*  	dl 0x00004A ; 163.125 74, 0.290
040FE1 44 00 00    0934*  	dl 0x000044 ; 164.531 75, 0.267
040FE4 3E 00 00    0935*  	dl 0x00003E ; 165.938 76, 0.243
040FE7 38 00 00    0936*  	dl 0x000038 ; 167.344 77, 0.219
040FEA 31 00 00    0937*  	dl 0x000031 ; 168.750 78, 0.195
040FED 2B 00 00    0938*  	dl 0x00002B ; 170.156 79, 0.171
040FF0 25 00 00    0939*  	dl 0x000025 ; 171.563 7A, 0.147
040FF3 1F 00 00    0940*  	dl 0x00001F ; 172.969 7B, 0.122
040FF6 19 00 00    0941*  	dl 0x000019 ; 174.375 7C, 0.098
040FF9 12 00 00    0942*  	dl 0x000012 ; 175.781 7D, 0.074
040FFC 0C 00 00    0943*  	dl 0x00000C ; 177.188 7E, 0.049
040FFF 06 00 00    0944*  	dl 0x000006 ; 178.594 7F, 0.025
041002 00 00 00    0945*  	dl 0x000000 ; 180.000 80, 0.000
041005 FA FF FF    0946*  	dl 0xFFFFFA ; 181.406 81, -0.025
041008 F4 FF FF    0947*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04100B EE FF FF    0948*  	dl 0xFFFFEE ; 184.219 83, -0.074
04100E E7 FF FF    0949*  	dl 0xFFFFE7 ; 185.625 84, -0.098
041011 E1 FF FF    0950*  	dl 0xFFFFE1 ; 187.031 85, -0.122
041014 DB FF FF    0951*  	dl 0xFFFFDB ; 188.438 86, -0.147
041017 D5 FF FF    0952*  	dl 0xFFFFD5 ; 189.844 87, -0.171
04101A CF FF FF    0953*  	dl 0xFFFFCF ; 191.250 88, -0.195
04101D C8 FF FF    0954*  	dl 0xFFFFC8 ; 192.656 89, -0.219
041020 C2 FF FF    0955*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
041023 BC FF FF    0956*  	dl 0xFFFFBC ; 195.469 8B, -0.267
041026 B6 FF FF    0957*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
041029 B0 FF FF    0958*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04102C AA FF FF    0959*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04102F A4 FF FF    0960*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
041032 9F FF FF    0961*  	dl 0xFFFF9F ; 202.500 90, -0.383
041035 99 FF FF    0962*  	dl 0xFFFF99 ; 203.906 91, -0.405
041038 93 FF FF    0963*  	dl 0xFFFF93 ; 205.313 92, -0.428
04103B 8D FF FF    0964*  	dl 0xFFFF8D ; 206.719 93, -0.450
04103E 88 FF FF    0965*  	dl 0xFFFF88 ; 208.125 94, -0.471
041041 82 FF FF    0966*  	dl 0xFFFF82 ; 209.531 95, -0.493
041044 7D FF FF    0967*  	dl 0xFFFF7D ; 210.938 96, -0.514
041047 78 FF FF    0968*  	dl 0xFFFF78 ; 212.344 97, -0.535
04104A 72 FF FF    0969*  	dl 0xFFFF72 ; 213.750 98, -0.556
04104D 6D FF FF    0970*  	dl 0xFFFF6D ; 215.156 99, -0.576
041050 68 FF FF    0971*  	dl 0xFFFF68 ; 216.563 9A, -0.596
041053 63 FF FF    0972*  	dl 0xFFFF63 ; 217.969 9B, -0.615
041056 5E FF FF    0973*  	dl 0xFFFF5E ; 219.375 9C, -0.634
041059 59 FF FF    0974*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04105C 55 FF FF    0975*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04105F 50 FF FF    0976*  	dl 0xFFFF50 ; 223.594 9F, -0.690
041062 4B FF FF    0977*  	dl 0xFFFF4B ; 225.000 A0, -0.707
041065 47 FF FF    0978*  	dl 0xFFFF47 ; 226.406 A1, -0.724
041068 43 FF FF    0979*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04106B 3F FF FF    0980*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04106E 3B FF FF    0981*  	dl 0xFFFF3B ; 230.625 A4, -0.773
041071 37 FF FF    0982*  	dl 0xFFFF37 ; 232.031 A5, -0.788
041074 33 FF FF    0983*  	dl 0xFFFF33 ; 233.438 A6, -0.803
041077 2F FF FF    0984*  	dl 0xFFFF2F ; 234.844 A7, -0.818
04107A 2C FF FF    0985*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04107D 28 FF FF    0986*  	dl 0xFFFF28 ; 237.656 A9, -0.845
041080 25 FF FF    0987*  	dl 0xFFFF25 ; 239.063 AA, -0.858
041083 22 FF FF    0988*  	dl 0xFFFF22 ; 240.469 AB, -0.870
041086 1F FF FF    0989*  	dl 0xFFFF1F ; 241.875 AC, -0.882
041089 1C FF FF    0990*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04108C 19 FF FF    0991*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04108F 16 FF FF    0992*  	dl 0xFFFF16 ; 246.094 AF, -0.914
041092 14 FF FF    0993*  	dl 0xFFFF14 ; 247.500 B0, -0.924
041095 12 FF FF    0994*  	dl 0xFFFF12 ; 248.906 B1, -0.933
041098 0F FF FF    0995*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04109B 0D FF FF    0996*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04109E 0C FF FF    0997*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0410A1 0A FF FF    0998*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0410A4 08 FF FF    0999*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0410A7 07 FF FF    1000*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0410AA 05 FF FF    1001*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0410AD 04 FF FF    1002*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0410B0 03 FF FF    1003*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0410B3 02 FF FF    1004*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0410B6 02 FF FF    1005*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0410B9 01 FF FF    1006*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0410BC 01 FF FF    1007*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0410BF 01 FF FF    1008*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0410C2 00 FF FF    1009*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0410C5 01 FF FF    1010*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0410C8 01 FF FF    1011*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0410CB 01 FF FF    1012*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0410CE 02 FF FF    1013*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0410D1 02 FF FF    1014*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0410D4 03 FF FF    1015*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0410D7 04 FF FF    1016*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0410DA 05 FF FF    1017*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0410DD 07 FF FF    1018*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0410E0 08 FF FF    1019*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0410E3 0A FF FF    1020*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0410E6 0C FF FF    1021*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0410E9 0D FF FF    1022*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0410EC 0F FF FF    1023*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0410EF 12 FF FF    1024*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0410F2 14 FF FF    1025*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0410F5 16 FF FF    1026*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0410F8 19 FF FF    1027*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0410FB 1C FF FF    1028*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0410FE 1F FF FF    1029*  	dl 0xFFFF1F ; 298.125 D4, -0.882
041101 22 FF FF    1030*  	dl 0xFFFF22 ; 299.531 D5, -0.870
041104 25 FF FF    1031*  	dl 0xFFFF25 ; 300.938 D6, -0.858
041107 28 FF FF    1032*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04110A 2C FF FF    1033*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04110D 2F FF FF    1034*  	dl 0xFFFF2F ; 305.156 D9, -0.818
041110 33 FF FF    1035*  	dl 0xFFFF33 ; 306.563 DA, -0.803
041113 37 FF FF    1036*  	dl 0xFFFF37 ; 307.969 DB, -0.788
041116 3B FF FF    1037*  	dl 0xFFFF3B ; 309.375 DC, -0.773
041119 3F FF FF    1038*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04111C 43 FF FF    1039*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04111F 47 FF FF    1040*  	dl 0xFFFF47 ; 313.594 DF, -0.724
041122 4B FF FF    1041*  	dl 0xFFFF4B ; 315.000 E0, -0.707
041125 50 FF FF    1042*  	dl 0xFFFF50 ; 316.406 E1, -0.690
041128 55 FF FF    1043*  	dl 0xFFFF55 ; 317.813 E2, -0.672
04112B 59 FF FF    1044*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04112E 5E FF FF    1045*  	dl 0xFFFF5E ; 320.625 E4, -0.634
041131 63 FF FF    1046*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041134 68 FF FF    1047*  	dl 0xFFFF68 ; 323.438 E6, -0.596
041137 6D FF FF    1048*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04113A 72 FF FF    1049*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04113D 78 FF FF    1050*  	dl 0xFFFF78 ; 327.656 E9, -0.535
041140 7D FF FF    1051*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041143 82 FF FF    1052*  	dl 0xFFFF82 ; 330.469 EB, -0.493
041146 88 FF FF    1053*  	dl 0xFFFF88 ; 331.875 EC, -0.471
041149 8D FF FF    1054*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04114C 93 FF FF    1055*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04114F 99 FF FF    1056*  	dl 0xFFFF99 ; 336.094 EF, -0.405
041152 9F FF FF    1057*  	dl 0xFFFF9F ; 337.500 F0, -0.383
041155 A4 FF FF    1058*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
041158 AA FF FF    1059*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04115B B0 FF FF    1060*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04115E B6 FF FF    1061*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
041161 BC FF FF    1062*  	dl 0xFFFFBC ; 344.531 F5, -0.267
041164 C2 FF FF    1063*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
041167 C8 FF FF    1064*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04116A CF FF FF    1065*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04116D D5 FF FF    1066*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
041170 DB FF FF    1067*  	dl 0xFFFFDB ; 351.563 FA, -0.147
041173 E1 FF FF    1068*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
041176 E7 FF FF    1069*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
041179 EE FF FF    1070*  	dl 0xFFFFEE ; 355.781 FD, -0.074
04117C F4 FF FF    1071*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
04117F FA FF FF    1072*  	dl 0xFFFFFA ; 358.594 FF, -0.025
041182 00 00 00    1073*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
041185             1074*  
041185             1075*  atan_lut_168:
041185 00 00 00    1076*  	dl 0x000000 ; 000000, 0.000
041188 28 00 00    1077*  	dl 0x000028 ; 000001, 0.224
04118B 51 00 00    1078*  	dl 0x000051 ; 000002, 0.448
04118E 7A 00 00    1079*  	dl 0x00007A ; 000003, 0.671
041191 A2 00 00    1080*  	dl 0x0000A2 ; 000004, 0.895
041194 CB 00 00    1081*  	dl 0x0000CB ; 000005, 1.119
041197 F4 00 00    1082*  	dl 0x0000F4 ; 000006, 1.343
04119A 1D 01 00    1083*  	dl 0x00011D ; 000007, 1.566
04119D 45 01 00    1084*  	dl 0x000145 ; 000008, 1.790
0411A0 6E 01 00    1085*  	dl 0x00016E ; 000009, 2.013
0411A3 97 01 00    1086*  	dl 0x000197 ; 00000A, 2.237
0411A6 BF 01 00    1087*  	dl 0x0001BF ; 00000B, 2.460
0411A9 E8 01 00    1088*  	dl 0x0001E8 ; 00000C, 2.684
0411AC 11 02 00    1089*  	dl 0x000211 ; 00000D, 2.907
0411AF 39 02 00    1090*  	dl 0x000239 ; 00000E, 3.130
0411B2 62 02 00    1091*  	dl 0x000262 ; 00000F, 3.353
0411B5 8B 02 00    1092*  	dl 0x00028B ; 000010, 3.576
0411B8 B3 02 00    1093*  	dl 0x0002B3 ; 000011, 3.799
0411BB DC 02 00    1094*  	dl 0x0002DC ; 000012, 4.022
0411BE 04 03 00    1095*  	dl 0x000304 ; 000013, 4.245
0411C1 2D 03 00    1096*  	dl 0x00032D ; 000014, 4.467
0411C4 55 03 00    1097*  	dl 0x000355 ; 000015, 4.690
0411C7 7E 03 00    1098*  	dl 0x00037E ; 000016, 4.912
0411CA A6 03 00    1099*  	dl 0x0003A6 ; 000017, 5.134
0411CD CE 03 00    1100*  	dl 0x0003CE ; 000018, 5.356
0411D0 F7 03 00    1101*  	dl 0x0003F7 ; 000019, 5.578
0411D3 1F 04 00    1102*  	dl 0x00041F ; 00001A, 5.799
0411D6 48 04 00    1103*  	dl 0x000448 ; 00001B, 6.021
0411D9 70 04 00    1104*  	dl 0x000470 ; 00001C, 6.242
0411DC 98 04 00    1105*  	dl 0x000498 ; 00001D, 6.463
0411DF C0 04 00    1106*  	dl 0x0004C0 ; 00001E, 6.684
0411E2 E8 04 00    1107*  	dl 0x0004E8 ; 00001F, 6.905
0411E5 11 05 00    1108*  	dl 0x000511 ; 000020, 7.125
0411E8 39 05 00    1109*  	dl 0x000539 ; 000021, 7.345
0411EB 61 05 00    1110*  	dl 0x000561 ; 000022, 7.565
0411EE 89 05 00    1111*  	dl 0x000589 ; 000023, 7.785
0411F1 B1 05 00    1112*  	dl 0x0005B1 ; 000024, 8.005
0411F4 D9 05 00    1113*  	dl 0x0005D9 ; 000025, 8.224
0411F7 01 06 00    1114*  	dl 0x000601 ; 000026, 8.443
0411FA 28 06 00    1115*  	dl 0x000628 ; 000027, 8.662
0411FD 50 06 00    1116*  	dl 0x000650 ; 000028, 8.881
041200 78 06 00    1117*  	dl 0x000678 ; 000029, 9.099
041203 A0 06 00    1118*  	dl 0x0006A0 ; 00002A, 9.317
041206 C7 06 00    1119*  	dl 0x0006C7 ; 00002B, 9.535
041209 EF 06 00    1120*  	dl 0x0006EF ; 00002C, 9.752
04120C 16 07 00    1121*  	dl 0x000716 ; 00002D, 9.970
04120F 3E 07 00    1122*  	dl 0x00073E ; 00002E, 10.187
041212 65 07 00    1123*  	dl 0x000765 ; 00002F, 10.403
041215 8D 07 00    1124*  	dl 0x00078D ; 000030, 10.620
041218 B4 07 00    1125*  	dl 0x0007B4 ; 000031, 10.836
04121B DB 07 00    1126*  	dl 0x0007DB ; 000032, 11.051
04121E 03 08 00    1127*  	dl 0x000803 ; 000033, 11.267
041221 2A 08 00    1128*  	dl 0x00082A ; 000034, 11.482
041224 51 08 00    1129*  	dl 0x000851 ; 000035, 11.697
041227 78 08 00    1130*  	dl 0x000878 ; 000036, 11.911
04122A 9F 08 00    1131*  	dl 0x00089F ; 000037, 12.125
04122D C6 08 00    1132*  	dl 0x0008C6 ; 000038, 12.339
041230 ED 08 00    1133*  	dl 0x0008ED ; 000039, 12.553
041233 13 09 00    1134*  	dl 0x000913 ; 00003A, 12.766
041236 3A 09 00    1135*  	dl 0x00093A ; 00003B, 12.978
041239 61 09 00    1136*  	dl 0x000961 ; 00003C, 13.191
04123C 87 09 00    1137*  	dl 0x000987 ; 00003D, 13.403
04123F AE 09 00    1138*  	dl 0x0009AE ; 00003E, 13.614
041242 D4 09 00    1139*  	dl 0x0009D4 ; 00003F, 13.825
041245 FB 09 00    1140*  	dl 0x0009FB ; 000040, 14.036
041248 21 0A 00    1141*  	dl 0x000A21 ; 000041, 14.247
04124B 47 0A 00    1142*  	dl 0x000A47 ; 000042, 14.457
04124E 6D 0A 00    1143*  	dl 0x000A6D ; 000043, 14.666
041251 94 0A 00    1144*  	dl 0x000A94 ; 000044, 14.876
041254 BA 0A 00    1145*  	dl 0x000ABA ; 000045, 15.085
041257 E0 0A 00    1146*  	dl 0x000AE0 ; 000046, 15.293
04125A 05 0B 00    1147*  	dl 0x000B05 ; 000047, 15.501
04125D 2B 0B 00    1148*  	dl 0x000B2B ; 000048, 15.709
041260 51 0B 00    1149*  	dl 0x000B51 ; 000049, 15.916
041263 77 0B 00    1150*  	dl 0x000B77 ; 00004A, 16.123
041266 9C 0B 00    1151*  	dl 0x000B9C ; 00004B, 16.329
041269 C2 0B 00    1152*  	dl 0x000BC2 ; 00004C, 16.535
04126C E7 0B 00    1153*  	dl 0x000BE7 ; 00004D, 16.740
04126F 0C 0C 00    1154*  	dl 0x000C0C ; 00004E, 16.945
041272 32 0C 00    1155*  	dl 0x000C32 ; 00004F, 17.150
041275 57 0C 00    1156*  	dl 0x000C57 ; 000050, 17.354
041278 7C 0C 00    1157*  	dl 0x000C7C ; 000051, 17.558
04127B A1 0C 00    1158*  	dl 0x000CA1 ; 000052, 17.761
04127E C6 0C 00    1159*  	dl 0x000CC6 ; 000053, 17.964
041281 EB 0C 00    1160*  	dl 0x000CEB ; 000054, 18.166
041284 0F 0D 00    1161*  	dl 0x000D0F ; 000055, 18.368
041287 34 0D 00    1162*  	dl 0x000D34 ; 000056, 18.569
04128A 58 0D 00    1163*  	dl 0x000D58 ; 000057, 18.770
04128D 7D 0D 00    1164*  	dl 0x000D7D ; 000058, 18.970
041290 A1 0D 00    1165*  	dl 0x000DA1 ; 000059, 19.170
041293 C6 0D 00    1166*  	dl 0x000DC6 ; 00005A, 19.370
041296 EA 0D 00    1167*  	dl 0x000DEA ; 00005B, 19.569
041299 0E 0E 00    1168*  	dl 0x000E0E ; 00005C, 19.767
04129C 32 0E 00    1169*  	dl 0x000E32 ; 00005D, 19.965
04129F 56 0E 00    1170*  	dl 0x000E56 ; 00005E, 20.163
0412A2 7A 0E 00    1171*  	dl 0x000E7A ; 00005F, 20.360
0412A5 9E 0E 00    1172*  	dl 0x000E9E ; 000060, 20.556
0412A8 C1 0E 00    1173*  	dl 0x000EC1 ; 000061, 20.752
0412AB E5 0E 00    1174*  	dl 0x000EE5 ; 000062, 20.947
0412AE 08 0F 00    1175*  	dl 0x000F08 ; 000063, 21.142
0412B1 2C 0F 00    1176*  	dl 0x000F2C ; 000064, 21.337
0412B4 4F 0F 00    1177*  	dl 0x000F4F ; 000065, 21.531
0412B7 72 0F 00    1178*  	dl 0x000F72 ; 000066, 21.724
0412BA 95 0F 00    1179*  	dl 0x000F95 ; 000067, 21.917
0412BD B8 0F 00    1180*  	dl 0x000FB8 ; 000068, 22.109
0412C0 DB 0F 00    1181*  	dl 0x000FDB ; 000069, 22.301
0412C3 FE 0F 00    1182*  	dl 0x000FFE ; 00006A, 22.493
0412C6 21 10 00    1183*  	dl 0x001021 ; 00006B, 22.683
0412C9 44 10 00    1184*  	dl 0x001044 ; 00006C, 22.874
0412CC 66 10 00    1185*  	dl 0x001066 ; 00006D, 23.063
0412CF 89 10 00    1186*  	dl 0x001089 ; 00006E, 23.253
0412D2 AB 10 00    1187*  	dl 0x0010AB ; 00006F, 23.441
0412D5 CD 10 00    1188*  	dl 0x0010CD ; 000070, 23.629
0412D8 EF 10 00    1189*  	dl 0x0010EF ; 000071, 23.817
0412DB 11 11 00    1190*  	dl 0x001111 ; 000072, 24.004
0412DE 33 11 00    1191*  	dl 0x001133 ; 000073, 24.191
0412E1 55 11 00    1192*  	dl 0x001155 ; 000074, 24.376
0412E4 77 11 00    1193*  	dl 0x001177 ; 000075, 24.562
0412E7 99 11 00    1194*  	dl 0x001199 ; 000076, 24.747
0412EA BA 11 00    1195*  	dl 0x0011BA ; 000077, 24.931
0412ED DC 11 00    1196*  	dl 0x0011DC ; 000078, 25.115
0412F0 FD 11 00    1197*  	dl 0x0011FD ; 000079, 25.298
0412F3 1E 12 00    1198*  	dl 0x00121E ; 00007A, 25.481
0412F6 3F 12 00    1199*  	dl 0x00123F ; 00007B, 25.663
0412F9 60 12 00    1200*  	dl 0x001260 ; 00007C, 25.844
0412FC 81 12 00    1201*  	dl 0x001281 ; 00007D, 26.025
0412FF A2 12 00    1202*  	dl 0x0012A2 ; 00007E, 26.206
041302 C3 12 00    1203*  	dl 0x0012C3 ; 00007F, 26.386
041305 E4 12 00    1204*  	dl 0x0012E4 ; 000080, 26.565
041308 04 13 00    1205*  	dl 0x001304 ; 000081, 26.744
04130B 25 13 00    1206*  	dl 0x001325 ; 000082, 26.922
04130E 45 13 00    1207*  	dl 0x001345 ; 000083, 27.100
041311 65 13 00    1208*  	dl 0x001365 ; 000084, 27.277
041314 85 13 00    1209*  	dl 0x001385 ; 000085, 27.453
041317 A5 13 00    1210*  	dl 0x0013A5 ; 000086, 27.629
04131A C5 13 00    1211*  	dl 0x0013C5 ; 000087, 27.805
04131D E5 13 00    1212*  	dl 0x0013E5 ; 000088, 27.979
041320 05 14 00    1213*  	dl 0x001405 ; 000089, 28.154
041323 24 14 00    1214*  	dl 0x001424 ; 00008A, 28.327
041326 44 14 00    1215*  	dl 0x001444 ; 00008B, 28.501
041329 63 14 00    1216*  	dl 0x001463 ; 00008C, 28.673
04132C 83 14 00    1217*  	dl 0x001483 ; 00008D, 28.845
04132F A2 14 00    1218*  	dl 0x0014A2 ; 00008E, 29.017
041332 C1 14 00    1219*  	dl 0x0014C1 ; 00008F, 29.187
041335 E0 14 00    1220*  	dl 0x0014E0 ; 000090, 29.358
041338 FF 14 00    1221*  	dl 0x0014FF ; 000091, 29.527
04133B 1E 15 00    1222*  	dl 0x00151E ; 000092, 29.697
04133E 3C 15 00    1223*  	dl 0x00153C ; 000093, 29.865
041341 5B 15 00    1224*  	dl 0x00155B ; 000094, 30.033
041344 79 15 00    1225*  	dl 0x001579 ; 000095, 30.201
041347 98 15 00    1226*  	dl 0x001598 ; 000096, 30.368
04134A B6 15 00    1227*  	dl 0x0015B6 ; 000097, 30.534
04134D D4 15 00    1228*  	dl 0x0015D4 ; 000098, 30.700
041350 F2 15 00    1229*  	dl 0x0015F2 ; 000099, 30.865
041353 10 16 00    1230*  	dl 0x001610 ; 00009A, 31.030
041356 2E 16 00    1231*  	dl 0x00162E ; 00009B, 31.194
041359 4C 16 00    1232*  	dl 0x00164C ; 00009C, 31.357
04135C 6A 16 00    1233*  	dl 0x00166A ; 00009D, 31.520
04135F 87 16 00    1234*  	dl 0x001687 ; 00009E, 31.682
041362 A5 16 00    1235*  	dl 0x0016A5 ; 00009F, 31.844
041365 C2 16 00    1236*  	dl 0x0016C2 ; 0000A0, 32.005
041368 DF 16 00    1237*  	dl 0x0016DF ; 0000A1, 32.166
04136B FC 16 00    1238*  	dl 0x0016FC ; 0000A2, 32.326
04136E 19 17 00    1239*  	dl 0x001719 ; 0000A3, 32.486
041371 36 17 00    1240*  	dl 0x001736 ; 0000A4, 32.645
041374 53 17 00    1241*  	dl 0x001753 ; 0000A5, 32.803
041377 70 17 00    1242*  	dl 0x001770 ; 0000A6, 32.961
04137A 8C 17 00    1243*  	dl 0x00178C ; 0000A7, 33.118
04137D A9 17 00    1244*  	dl 0x0017A9 ; 0000A8, 33.275
041380 C5 17 00    1245*  	dl 0x0017C5 ; 0000A9, 33.431
041383 E2 17 00    1246*  	dl 0x0017E2 ; 0000AA, 33.587
041386 FE 17 00    1247*  	dl 0x0017FE ; 0000AB, 33.742
041389 1A 18 00    1248*  	dl 0x00181A ; 0000AC, 33.896
04138C 36 18 00    1249*  	dl 0x001836 ; 0000AD, 34.050
04138F 52 18 00    1250*  	dl 0x001852 ; 0000AE, 34.203
041392 6E 18 00    1251*  	dl 0x00186E ; 0000AF, 34.356
041395 8A 18 00    1252*  	dl 0x00188A ; 0000B0, 34.509
041398 A5 18 00    1253*  	dl 0x0018A5 ; 0000B1, 34.660
04139B C1 18 00    1254*  	dl 0x0018C1 ; 0000B2, 34.811
04139E DC 18 00    1255*  	dl 0x0018DC ; 0000B3, 34.962
0413A1 F7 18 00    1256*  	dl 0x0018F7 ; 0000B4, 35.112
0413A4 13 19 00    1257*  	dl 0x001913 ; 0000B5, 35.262
0413A7 2E 19 00    1258*  	dl 0x00192E ; 0000B6, 35.410
0413AA 49 19 00    1259*  	dl 0x001949 ; 0000B7, 35.559
0413AD 64 19 00    1260*  	dl 0x001964 ; 0000B8, 35.707
0413B0 7F 19 00    1261*  	dl 0x00197F ; 0000B9, 35.854
0413B3 99 19 00    1262*  	dl 0x001999 ; 0000BA, 36.001
0413B6 B4 19 00    1263*  	dl 0x0019B4 ; 0000BB, 36.147
0413B9 CE 19 00    1264*  	dl 0x0019CE ; 0000BC, 36.293
0413BC E9 19 00    1265*  	dl 0x0019E9 ; 0000BD, 36.438
0413BF 03 1A 00    1266*  	dl 0x001A03 ; 0000BE, 36.582
0413C2 1D 1A 00    1267*  	dl 0x001A1D ; 0000BF, 36.726
0413C5 37 1A 00    1268*  	dl 0x001A37 ; 0000C0, 36.870
0413C8 51 1A 00    1269*  	dl 0x001A51 ; 0000C1, 37.013
0413CB 6B 1A 00    1270*  	dl 0x001A6B ; 0000C2, 37.155
0413CE 85 1A 00    1271*  	dl 0x001A85 ; 0000C3, 37.297
0413D1 9F 1A 00    1272*  	dl 0x001A9F ; 0000C4, 37.439
0413D4 B9 1A 00    1273*  	dl 0x001AB9 ; 0000C5, 37.579
0413D7 D2 1A 00    1274*  	dl 0x001AD2 ; 0000C6, 37.720
0413DA EC 1A 00    1275*  	dl 0x001AEC ; 0000C7, 37.859
0413DD 05 1B 00    1276*  	dl 0x001B05 ; 0000C8, 37.999
0413E0 1E 1B 00    1277*  	dl 0x001B1E ; 0000C9, 38.137
0413E3 37 1B 00    1278*  	dl 0x001B37 ; 0000CA, 38.276
0413E6 50 1B 00    1279*  	dl 0x001B50 ; 0000CB, 38.413
0413E9 69 1B 00    1280*  	dl 0x001B69 ; 0000CC, 38.550
0413EC 82 1B 00    1281*  	dl 0x001B82 ; 0000CD, 38.687
0413EF 9B 1B 00    1282*  	dl 0x001B9B ; 0000CE, 38.823
0413F2 B4 1B 00    1283*  	dl 0x001BB4 ; 0000CF, 38.959
0413F5 CC 1B 00    1284*  	dl 0x001BCC ; 0000D0, 39.094
0413F8 E5 1B 00    1285*  	dl 0x001BE5 ; 0000D1, 39.228
0413FB FD 1B 00    1286*  	dl 0x001BFD ; 0000D2, 39.362
0413FE 16 1C 00    1287*  	dl 0x001C16 ; 0000D3, 39.496
041401 2E 1C 00    1288*  	dl 0x001C2E ; 0000D4, 39.629
041404 46 1C 00    1289*  	dl 0x001C46 ; 0000D5, 39.762
041407 5E 1C 00    1290*  	dl 0x001C5E ; 0000D6, 39.894
04140A 76 1C 00    1291*  	dl 0x001C76 ; 0000D7, 40.025
04140D 8E 1C 00    1292*  	dl 0x001C8E ; 0000D8, 40.156
041410 A5 1C 00    1293*  	dl 0x001CA5 ; 0000D9, 40.286
041413 BD 1C 00    1294*  	dl 0x001CBD ; 0000DA, 40.416
041416 D5 1C 00    1295*  	dl 0x001CD5 ; 0000DB, 40.546
041419 EC 1C 00    1296*  	dl 0x001CEC ; 0000DC, 40.675
04141C 04 1D 00    1297*  	dl 0x001D04 ; 0000DD, 40.803
04141F 1B 1D 00    1298*  	dl 0x001D1B ; 0000DE, 40.931
041422 32 1D 00    1299*  	dl 0x001D32 ; 0000DF, 41.059
041425 49 1D 00    1300*  	dl 0x001D49 ; 0000E0, 41.186
041428 60 1D 00    1301*  	dl 0x001D60 ; 0000E1, 41.312
04142B 77 1D 00    1302*  	dl 0x001D77 ; 0000E2, 41.438
04142E 8E 1D 00    1303*  	dl 0x001D8E ; 0000E3, 41.564
041431 A5 1D 00    1304*  	dl 0x001DA5 ; 0000E4, 41.689
041434 BB 1D 00    1305*  	dl 0x001DBB ; 0000E5, 41.814
041437 D2 1D 00    1306*  	dl 0x001DD2 ; 0000E6, 41.938
04143A E9 1D 00    1307*  	dl 0x001DE9 ; 0000E7, 42.061
04143D FF 1D 00    1308*  	dl 0x001DFF ; 0000E8, 42.184
041440 15 1E 00    1309*  	dl 0x001E15 ; 0000E9, 42.307
041443 2C 1E 00    1310*  	dl 0x001E2C ; 0000EA, 42.429
041446 42 1E 00    1311*  	dl 0x001E42 ; 0000EB, 42.551
041449 58 1E 00    1312*  	dl 0x001E58 ; 0000EC, 42.672
04144C 6E 1E 00    1313*  	dl 0x001E6E ; 0000ED, 42.793
04144F 84 1E 00    1314*  	dl 0x001E84 ; 0000EE, 42.913
041452 99 1E 00    1315*  	dl 0x001E99 ; 0000EF, 43.033
041455 AF 1E 00    1316*  	dl 0x001EAF ; 0000F0, 43.152
041458 C5 1E 00    1317*  	dl 0x001EC5 ; 0000F1, 43.271
04145B DA 1E 00    1318*  	dl 0x001EDA ; 0000F2, 43.390
04145E F0 1E 00    1319*  	dl 0x001EF0 ; 0000F3, 43.508
041461 05 1F 00    1320*  	dl 0x001F05 ; 0000F4, 43.625
041464 1B 1F 00    1321*  	dl 0x001F1B ; 0000F5, 43.742
041467 30 1F 00    1322*  	dl 0x001F30 ; 0000F6, 43.859
04146A 45 1F 00    1323*  	dl 0x001F45 ; 0000F7, 43.975
04146D 5A 1F 00    1324*  	dl 0x001F5A ; 0000F8, 44.091
041470 6F 1F 00    1325*  	dl 0x001F6F ; 0000F9, 44.206
041473 84 1F 00    1326*  	dl 0x001F84 ; 0000FA, 44.321
041476 99 1F 00    1327*  	dl 0x001F99 ; 0000FB, 44.435
041479 AD 1F 00    1328*  	dl 0x001FAD ; 0000FC, 44.549
04147C C2 1F 00    1329*  	dl 0x001FC2 ; 0000FD, 44.662
04147F D7 1F 00    1330*  	dl 0x001FD7 ; 0000FE, 44.775
041482 EB 1F 00    1331*  	dl 0x001FEB ; 0000FF, 44.888
041485 00 20 00    1332*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
041488             0034   	include "images.inc"
041488             0001*  image_type: equ 0
041488             0002*  image_width: equ image_type+3
041488             0003*  image_height: equ image_width+3
041488             0004*  image_filesize: equ image_height+3
041488             0005*  image_filename: equ image_filesize+3
041488             0006*  image_bufferId: equ image_filename+3
041488             0007*  image_record_size: equ image_bufferId+3
041488             0008*  
041488 00 00 00    0009*  cur_image_list: dl 0
04148B 00 00 00    0010*  cur_file_idx: dl 0
04148E 00 00 00    0011*  cur_filename: dl 0
041491 00 00 00    0012*  cur_buffer_id: dl 0
041494             0013*  
041494             0014*  load_ui_images:
041494             0015*  ; initialize image loading variables
041494 21 00 00 00 0016*  	ld hl,0
041498 22 8B 14 04 0017*  	ld (cur_file_idx),hl
04149C 21 E3 2D 04 0018*  	ld hl,ui_image_list
0414A0 22 88 14 04 0019*  	ld (cur_image_list),hl
0414A4             0020*  ; load images
0414A4 06 04       0021*  	ld b,ui_num_images
0414A6             0022*  @loop:
0414A6 C5          0023*  	push bc
0414A7 CD 05 15 04 0024*  	call load_next_image
0414AB C1          0025*  	pop bc
0414AC 10 F8       0026*  	djnz @loop
0414AE C9          0027*  	ret
0414AF             0028*  
0414AF             0029*  load_sprite_images:
0414AF             0030*  ; initialize image loading variables
0414AF 21 00 00 00 0031*  	ld hl,0
0414B3 22 8B 14 04 0032*  	ld (cur_file_idx),hl
0414B7 21 96 15 04 0033*  	ld hl,sprites_image_list
0414BB 22 88 14 04 0034*  	ld (cur_image_list),hl
0414BF 01 8E 00 00 0035*  	ld bc,sprites_num_images
0414C3             0036*  ; load images
0414C3 CD C8 14 04 0037*  	call img_load_main
0414C7 C9          0038*  	ret
0414C8             0039*  
0414C8             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0414C8             0041*  img_load_main:
0414C8 AF          0042*  	xor a
0414C9 32 8B 14 04 0043*      ld (cur_file_idx),a
0414CD             0044*  
0414CD             0045*  img_load_main_loop:
0414CD             0046*  ; back up loop counter
0414CD C5          0047*      push bc
0414CE             0048*  
0414CE             0049*  ; load the next image
0414CE CD 05 15 04 0050*      call load_next_image
0414D2             0051*  
0414D2             0052*  ; plot the background
0414D2 CD EA 46 04 0053*  	call vdu_cls
0414D6 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
0414DA CD D7 47 04 0055*      call vdu_buff_select
0414DE 01 00 00 00 0056*      ld bc,0
0414E2 11 00 00 00 0057*      ld de,0
0414E6 CD A0 4A 04 0058*      call vdu_plot_bmp
0414EA             0059*  
0414EA             0060*  ; ; draw the most recently loaded image
0414EA             0061*  ; 	ld hl,(cur_buffer_id)
0414EA             0062*  ; 	call vdu_buff_select
0414EA             0063*  ; 	ld bc,0
0414EA             0064*  ; 	ld de,0
0414EA             0065*  ; 	call vdu_plot_bmp
0414EA             0066*  
0414EA             0067*  ; move logo
0414EA CD 65 15 04 0068*  	call move_logo
0414EE             0069*  
0414EE             0070*  ; print current filename
0414EE 2A 8E 14 04 0071*  	ld hl,(cur_filename)
0414F2 CD 77 00 04 0072*  	call printString
0414F6             0073*  
0414F6             0074*  ; flip the framebuffer
0414F6             0075*  	; call vdu_flip
0414F6             0076*  
0414F6             0077*  ; decrement loop counter
0414F6 C1          0078*      pop bc
0414F7 0B          0079*  	dec bc
0414F8 79          0080*      ld a,c
0414F9 B7          0081*      or a
0414FA C2 CD 14 04 0082*      jp nz,img_load_main_loop
0414FE 78          0083*      ld a,b
0414FF B7          0084*      or a
041500 C2 CD 14 04 0085*      jp nz,img_load_main_loop
041504 C9          0086*      ret
041505             0087*  
041505             0088*  load_next_image:
041505 16 12       0089*      ld d,image_record_size
041507 3A 8B 14 04 0090*  	ld a,(cur_file_idx)
04150B 5F          0091*  	ld e,a
04150C ED 5C       0092*      mlt de
04150E FD 2A 88 14 0093*      ld iy,(cur_image_list)
       04          
041513 FD 19       0094*      add iy,de
041515             0095*  
041515 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
041518 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
04151B FD 17 06    0098*      ld de,(iy+image_height) ; get image height
04151E FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
041521 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
041524 22 91 14 04 0101*  	ld (cur_buffer_id),hl
041528 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
04152B FD 22 8E 14 0103*  	ld (cur_filename),iy
       04          
041530 CD F5 48 04 0104*      call vdu_load_img
041534 FD 21 8B 14 0105*      ld iy,cur_file_idx
       04          
041539 FD 34 00    0106*  	inc (iy)
04153C C9          0107*  	ret
04153D             0108*  
04153D             0109*  img_load_init:
04153D             0110*  ; initialize logo's position parameters
04153D 21 00 00 00 0111*  	ld hl,0
041541 22 8A 15 04 0112*  	ld (logo_xvel),hl
041545 22 8D 15 04 0113*  	ld (logo_xpos),hl
041549             0114*  ; begin 16.8 maths to determine logo's y position and velocity
041549 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
04154D 22 93 15 04 0116*  	ld (logo_ypos),hl
041551 EB          0117*  	ex de,hl
041552 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
041556 19          0119*  	add hl,de ; distance for logo to travel
041557 11 00 72 FF 0120*  	ld de,-sprites_num_images*256
04155B CD A0 0B 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
04155F ED 53 90 15 0122*  	ld (logo_yvel),de
       04          
041564             0123*  ; all done
041564 C9          0124*      ret
041565             0125*  
041565             0126*  move_logo:
041565             0127*  ; activate logo bitmap
041565 21 03 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
041569 CD D7 47 04 0129*  	call vdu_buff_select
04156D             0130*  ; update position based on velocity parameters
04156D 2A 93 15 04 0131*  	ld hl,(logo_ypos)
041571 ED 5B 90 15 0132*  	ld de,(logo_yvel)
       04          
041576 19          0133*  	add hl,de
041577 22 93 15 04 0134*  	ld (logo_ypos),hl
04157B             0135*  ; draw logo
04157B ED 4B 8D 15 0136*  	ld bc,(logo_xpos)
       04          
041580 ED 5B 93 15 0137*  	ld de,(logo_ypos)
       04          
041585 CD BC 4A 04 0138*  	call vdu_plot_bmp168
041589 C9          0139*  	ret
04158A             0140*  
04158A 00 00 00    0141*  logo_xvel: dl 0
04158D 00 00 00    0142*  logo_xpos: dl 0
041590             0143*  
041590 00 00 00    0144*  logo_yvel: dl 0
041593 00 00 00    0145*  logo_ypos: dl 0
041596             0035   	include "images_sprites.inc"
041596             0001*  ; Generated by make_images.py
041596             0002*  
041596             0003*  sprites_num_images: equ 142
041596             0004*  
041596             0005*  ; buffer_ids:
041596             0006*  BUF_0TILE_EMPTY: equ 256
041596             0007*  BUF_1TILE_CROSS: equ 257
041596             0008*  BUF_2TILE_HORIZ: equ 258
041596             0009*  BUF_3TILE_VERT: equ 259
041596             0010*  BUF_4TILE_SQUARE: equ 260
041596             0011*  BUF_5TILE_CIRCLE: equ 261
041596             0012*  BUF_6TILE_PAD: equ 262
041596             0013*  BUF_7TILE_TURRET: equ 263
041596             0014*  BUF_CIRCLE: equ 264
041596             0015*  BUF_CRATER: equ 265
041596             0016*  BUF_EXPLOSION_A: equ 266
041596             0017*  BUF_EXPLOSION_B: equ 267
041596             0018*  BUF_EXPLOSION_C: equ 268
041596             0019*  BUF_EXPLOSION_D: equ 269
041596             0020*  BUF_EXPLOSION_E: equ 270
041596             0021*  BUF_FIREBALL_A: equ 271
041596             0022*  BUF_FIREBALL_B: equ 272
041596             0023*  BUF_LASER_A: equ 273
041596             0024*  BUF_LASER_B: equ 274
041596             0025*  BUF_PAD: equ 275
041596             0026*  BUF_SEEKER_000: equ 276
041596             0027*  BUF_SEEKER_008: equ 277
041596             0028*  BUF_SEEKER_016: equ 278
041596             0029*  BUF_SEEKER_024: equ 279
041596             0030*  BUF_SEEKER_032: equ 280
041596             0031*  BUF_SEEKER_040: equ 281
041596             0032*  BUF_SEEKER_048: equ 282
041596             0033*  BUF_SEEKER_056: equ 283
041596             0034*  BUF_SEEKER_064: equ 284
041596             0035*  BUF_SEEKER_072: equ 285
041596             0036*  BUF_SEEKER_080: equ 286
041596             0037*  BUF_SEEKER_088: equ 287
041596             0038*  BUF_SEEKER_096: equ 288
041596             0039*  BUF_SEEKER_104: equ 289
041596             0040*  BUF_SEEKER_112: equ 290
041596             0041*  BUF_SEEKER_120: equ 291
041596             0042*  BUF_SEEKER_128: equ 292
041596             0043*  BUF_SEEKER_136: equ 293
041596             0044*  BUF_SEEKER_144: equ 294
041596             0045*  BUF_SEEKER_152: equ 295
041596             0046*  BUF_SEEKER_160: equ 296
041596             0047*  BUF_SEEKER_168: equ 297
041596             0048*  BUF_SEEKER_176: equ 298
041596             0049*  BUF_SEEKER_184: equ 299
041596             0050*  BUF_SEEKER_192: equ 300
041596             0051*  BUF_SEEKER_200: equ 301
041596             0052*  BUF_SEEKER_208: equ 302
041596             0053*  BUF_SEEKER_216: equ 303
041596             0054*  BUF_SEEKER_224: equ 304
041596             0055*  BUF_SEEKER_232: equ 305
041596             0056*  BUF_SEEKER_240: equ 306
041596             0057*  BUF_SEEKER_248: equ 307
041596             0058*  BUF_SHIP_0L: equ 308
041596             0059*  BUF_SHIP_1C: equ 309
041596             0060*  BUF_SHIP_2R: equ 310
041596             0061*  BUF_SHIP_SMALL: equ 311
041596             0062*  BUF_STAR: equ 312
041596             0063*  BUF_STATION_BG_00: equ 313
041596             0064*  BUF_STATION_BG_01: equ 314
041596             0065*  BUF_STATION_BG_02: equ 315
041596             0066*  BUF_STATION_BG_03: equ 316
041596             0067*  BUF_STATION_BG_04: equ 317
041596             0068*  BUF_STATION_BG_05: equ 318
041596             0069*  BUF_TURRET_000: equ 319
041596             0070*  BUF_TURRET_008: equ 320
041596             0071*  BUF_TURRET_016: equ 321
041596             0072*  BUF_TURRET_024: equ 322
041596             0073*  BUF_TURRET_032: equ 323
041596             0074*  BUF_TURRET_040: equ 324
041596             0075*  BUF_TURRET_048: equ 325
041596             0076*  BUF_TURRET_056: equ 326
041596             0077*  BUF_TURRET_064: equ 327
041596             0078*  BUF_TURRET_072: equ 328
041596             0079*  BUF_TURRET_080: equ 329
041596             0080*  BUF_TURRET_088: equ 330
041596             0081*  BUF_TURRET_096: equ 331
041596             0082*  BUF_TURRET_104: equ 332
041596             0083*  BUF_TURRET_112: equ 333
041596             0084*  BUF_TURRET_120: equ 334
041596             0085*  BUF_TURRET_128: equ 335
041596             0086*  BUF_TURRET_136: equ 336
041596             0087*  BUF_TURRET_144: equ 337
041596             0088*  BUF_TURRET_152: equ 338
041596             0089*  BUF_TURRET_160: equ 339
041596             0090*  BUF_TURRET_168: equ 340
041596             0091*  BUF_TURRET_176: equ 341
041596             0092*  BUF_TURRET_184: equ 342
041596             0093*  BUF_TURRET_192: equ 343
041596             0094*  BUF_TURRET_200: equ 344
041596             0095*  BUF_TURRET_208: equ 345
041596             0096*  BUF_TURRET_216: equ 346
041596             0097*  BUF_TURRET_224: equ 347
041596             0098*  BUF_TURRET_232: equ 348
041596             0099*  BUF_TURRET_240: equ 349
041596             0100*  BUF_TURRET_248: equ 350
041596             0101*  BUF_XEVIOUS_00: equ 351
041596             0102*  BUF_XEVIOUS_01: equ 352
041596             0103*  BUF_XEVIOUS_02: equ 353
041596             0104*  BUF_XEVIOUS_03: equ 354
041596             0105*  BUF_XEVIOUS_04: equ 355
041596             0106*  BUF_XEVIOUS_05: equ 356
041596             0107*  BUF_XEVIOUS_06: equ 357
041596             0108*  BUF_XEVIOUS_07: equ 358
041596             0109*  BUF_XEVIOUS_08: equ 359
041596             0110*  BUF_XEVIOUS_09: equ 360
041596             0111*  BUF_XEVIOUS_10: equ 361
041596             0112*  BUF_XEVIOUS_11: equ 362
041596             0113*  BUF_XEVIOUS_12: equ 363
041596             0114*  BUF_XEVIOUS_13: equ 364
041596             0115*  BUF_XEVIOUS_14: equ 365
041596             0116*  BUF_XEVIOUS_15: equ 366
041596             0117*  BUF_XEVIOUS_16: equ 367
041596             0118*  BUF_XEVIOUS_17: equ 368
041596             0119*  BUF_XEVIOUS_18: equ 369
041596             0120*  BUF_XEVIOUS_19: equ 370
041596             0121*  BUF_XEVIOUS_20: equ 371
041596             0122*  BUF_XEVIOUS_21: equ 372
041596             0123*  BUF_XEVIOUS_22: equ 373
041596             0124*  BUF_XEVIOUS_23: equ 374
041596             0125*  BUF_XEVIOUS_24: equ 375
041596             0126*  BUF_XEVIOUS_25: equ 376
041596             0127*  BUF_XEVIOUS_26: equ 377
041596             0128*  BUF_XEVIOUS_27: equ 378
041596             0129*  BUF_XEVIOUS_28: equ 379
041596             0130*  BUF_XEVIOUS_29: equ 380
041596             0131*  BUF_XEVIOUS_30: equ 381
041596             0132*  BUF_XEVIOUS_31: equ 382
041596             0133*  BUF_XEVIOUS_SPRITE_065: equ 383
041596             0134*  BUF_XEVIOUS_SPRITE_066: equ 384
041596             0135*  BUF_XEVIOUS_SPRITE_067: equ 385
041596             0136*  BUF_XEVIOUS_SPRITE_068: equ 386
041596             0137*  BUF_XEVIOUS_SPRITE_069: equ 387
041596             0138*  BUF_XEVIOUS_SPRITE_070: equ 388
041596             0139*  BUF_XEVIOUS_SPRITE_071: equ 389
041596             0140*  BUF_XEVIOUS_SPRITE_072: equ 390
041596             0141*  BUF_XEVIOUS_SPRITE_073: equ 391
041596             0142*  BUF_XEVIOUS_SPRITE_074: equ 392
041596             0143*  BUF_XEVIOUS_SPRITE_075: equ 393
041596             0144*  BUF_XEVIOUS_SPRITE_076: equ 394
041596             0145*  BUF_XEVIOUS_SPRITE_077: equ 395
041596             0146*  BUF_XEVIOUS_SPRITE_078: equ 396
041596             0147*  BUF_XEVIOUS_SPRITE_079: equ 397
041596             0148*  
041596             0149*  sprites_image_list: ; type; width; height; filename; bufferId:
041596 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       92 1F 04 00 
       01 00       
0415A8 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       AC 1F 04 01 
       01 00       
0415BA 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       C6 1F 04 02 
       01 00       
0415CC 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       E0 1F 04 03 
       01 00       
0415DE 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       F9 1F 04 04 
       01 00       
0415F0 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       14 20 04 05 
       01 00       
041602 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       2F 20 04 06 
       01 00       
041614 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       47 20 04 07 
       01 00       
041626 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       62 20 04 08 
       01 00       
041638 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       77 20 04 09 
       01 00       
04164A 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       8C 20 04 0A 
       01 00       
04165C 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       A6 20 04 0B 
       01 00       
04166E 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       C0 20 04 0C 
       01 00       
041680 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       DA 20 04 0D 
       01 00       
041692 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       F4 20 04 0E 
       01 00       
0416A4 01 00 00 07 0165*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       0E 21 04 0F 
       01 00       
0416B6 01 00 00 07 0166*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       27 21 04 10 
       01 00       
0416C8 01 00 00 05 0167*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       40 21 04 11 
       01 00       
0416DA 01 00 00 05 0168*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       56 21 04 12 
       01 00       
0416EC 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       6C 21 04 13 
       01 00       
0416FE 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       7E 21 04 14 
       01 00       
041710 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       97 21 04 15 
       01 00       
041722 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       B0 21 04 16 
       01 00       
041734 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       C9 21 04 17 
       01 00       
041746 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       E2 21 04 18 
       01 00       
041758 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       FB 21 04 19 
       01 00       
04176A 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       14 22 04 1A 
       01 00       
04177C 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       2D 22 04 1B 
       01 00       
04178E 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       46 22 04 1C 
       01 00       
0417A0 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       5F 22 04 1D 
       01 00       
0417B2 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       78 22 04 1E 
       01 00       
0417C4 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       91 22 04 1F 
       01 00       
0417D6 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       AA 22 04 20 
       01 00       
0417E8 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       C3 22 04 21 
       01 00       
0417FA 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       DC 22 04 22 
       01 00       
04180C 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       F5 22 04 23 
       01 00       
04181E 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       0E 23 04 24 
       01 00       
041830 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       27 23 04 25 
       01 00       
041842 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       40 23 04 26 
       01 00       
041854 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       59 23 04 27 
       01 00       
041866 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       72 23 04 28 
       01 00       
041878 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       8B 23 04 29 
       01 00       
04188A 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       A4 23 04 2A 
       01 00       
04189C 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       BD 23 04 2B 
       01 00       
0418AE 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       D6 23 04 2C 
       01 00       
0418C0 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       EF 23 04 2D 
       01 00       
0418D2 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       08 24 04 2E 
       01 00       
0418E4 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       21 24 04 2F 
       01 00       
0418F6 01 00 00 10 0198*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       3A 24 04 30 
       01 00       
041908 01 00 00 10 0199*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       53 24 04 31 
       01 00       
04191A 01 00 00 10 0200*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       6C 24 04 32 
       01 00       
04192C 01 00 00 10 0201*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       85 24 04 33 
       01 00       
04193E 01 00 00 10 0202*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       9E 24 04 34 
       01 00       
041950 01 00 00 10 0203*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       B4 24 04 35 
       01 00       
041962 01 00 00 10 0204*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       CA 24 04 36 
       01 00       
041974 01 00 00 08 0205*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       E0 24 04 37 
       01 00       
041986 01 00 00 05 0206*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       F9 24 04 38 
       01 00       
041998 01 00 00 00 0207*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       0C 25 04 39 
       01 00       
0419AA 01 00 00 00 0208*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       28 25 04 3A 
       01 00       
0419BC 01 00 00 00 0209*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       44 25 04 3B 
       01 00       
0419CE 01 00 00 00 0210*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       60 25 04 3C 
       01 00       
0419E0 01 00 00 00 0211*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       7C 25 04 3D 
       01 00       
0419F2 01 00 00 00 0212*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       98 25 04 3E 
       01 00       
041A04 01 00 00 10 0213*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       B4 25 04 3F 
       01 00       
041A16 01 00 00 10 0214*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       CD 25 04 40 
       01 00       
041A28 01 00 00 10 0215*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       E6 25 04 41 
       01 00       
041A3A 01 00 00 10 0216*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       FF 25 04 42 
       01 00       
041A4C 01 00 00 10 0217*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       18 26 04 43 
       01 00       
041A5E 01 00 00 10 0218*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       31 26 04 44 
       01 00       
041A70 01 00 00 10 0219*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       4A 26 04 45 
       01 00       
041A82 01 00 00 10 0220*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       63 26 04 46 
       01 00       
041A94 01 00 00 10 0221*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       7C 26 04 47 
       01 00       
041AA6 01 00 00 10 0222*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       95 26 04 48 
       01 00       
041AB8 01 00 00 10 0223*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       AE 26 04 49 
       01 00       
041ACA 01 00 00 10 0224*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       C7 26 04 4A 
       01 00       
041ADC 01 00 00 10 0225*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       E0 26 04 4B 
       01 00       
041AEE 01 00 00 10 0226*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       F9 26 04 4C 
       01 00       
041B00 01 00 00 10 0227*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       12 27 04 4D 
       01 00       
041B12 01 00 00 10 0228*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       2B 27 04 4E 
       01 00       
041B24 01 00 00 10 0229*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       44 27 04 4F 
       01 00       
041B36 01 00 00 10 0230*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       5D 27 04 50 
       01 00       
041B48 01 00 00 10 0231*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       76 27 04 51 
       01 00       
041B5A 01 00 00 10 0232*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       8F 27 04 52 
       01 00       
041B6C 01 00 00 10 0233*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       A8 27 04 53 
       01 00       
041B7E 01 00 00 10 0234*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       C1 27 04 54 
       01 00       
041B90 01 00 00 10 0235*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       DA 27 04 55 
       01 00       
041BA2 01 00 00 10 0236*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       F3 27 04 56 
       01 00       
041BB4 01 00 00 10 0237*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       0C 28 04 57 
       01 00       
041BC6 01 00 00 10 0238*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       25 28 04 58 
       01 00       
041BD8 01 00 00 10 0239*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       3E 28 04 59 
       01 00       
041BEA 01 00 00 10 0240*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       57 28 04 5A 
       01 00       
041BFC 01 00 00 10 0241*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       70 28 04 5B 
       01 00       
041C0E 01 00 00 10 0242*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       89 28 04 5C 
       01 00       
041C20 01 00 00 10 0243*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       A2 28 04 5D 
       01 00       
041C32 01 00 00 10 0244*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       BB 28 04 5E 
       01 00       
041C44 01 00 00 00 0245*  	dl 1, 256, 256, 65536, fn_xevious_00, 351
       01 00 00 01 
       00 00 00 01 
       D4 28 04 5F 
       01 00       
041C56 01 00 00 00 0246*  	dl 1, 256, 256, 65536, fn_xevious_01, 352
       01 00 00 01 
       00 00 00 01 
       ED 28 04 60 
       01 00       
041C68 01 00 00 00 0247*  	dl 1, 256, 256, 65536, fn_xevious_02, 353
       01 00 00 01 
       00 00 00 01 
       06 29 04 61 
       01 00       
041C7A 01 00 00 00 0248*  	dl 1, 256, 256, 65536, fn_xevious_03, 354
       01 00 00 01 
       00 00 00 01 
       1F 29 04 62 
       01 00       
041C8C 01 00 00 00 0249*  	dl 1, 256, 256, 65536, fn_xevious_04, 355
       01 00 00 01 
       00 00 00 01 
       38 29 04 63 
       01 00       
041C9E 01 00 00 00 0250*  	dl 1, 256, 256, 65536, fn_xevious_05, 356
       01 00 00 01 
       00 00 00 01 
       51 29 04 64 
       01 00       
041CB0 01 00 00 00 0251*  	dl 1, 256, 256, 65536, fn_xevious_06, 357
       01 00 00 01 
       00 00 00 01 
       6A 29 04 65 
       01 00       
041CC2 01 00 00 00 0252*  	dl 1, 256, 256, 65536, fn_xevious_07, 358
       01 00 00 01 
       00 00 00 01 
       83 29 04 66 
       01 00       
041CD4 01 00 00 00 0253*  	dl 1, 256, 256, 65536, fn_xevious_08, 359
       01 00 00 01 
       00 00 00 01 
       9C 29 04 67 
       01 00       
041CE6 01 00 00 00 0254*  	dl 1, 256, 256, 65536, fn_xevious_09, 360
       01 00 00 01 
       00 00 00 01 
       B5 29 04 68 
       01 00       
041CF8 01 00 00 00 0255*  	dl 1, 256, 256, 65536, fn_xevious_10, 361
       01 00 00 01 
       00 00 00 01 
       CE 29 04 69 
       01 00       
041D0A 01 00 00 00 0256*  	dl 1, 256, 256, 65536, fn_xevious_11, 362
       01 00 00 01 
       00 00 00 01 
       E7 29 04 6A 
       01 00       
041D1C 01 00 00 00 0257*  	dl 1, 256, 256, 65536, fn_xevious_12, 363
       01 00 00 01 
       00 00 00 01 
       00 2A 04 6B 
       01 00       
041D2E 01 00 00 00 0258*  	dl 1, 256, 256, 65536, fn_xevious_13, 364
       01 00 00 01 
       00 00 00 01 
       19 2A 04 6C 
       01 00       
041D40 01 00 00 00 0259*  	dl 1, 256, 256, 65536, fn_xevious_14, 365
       01 00 00 01 
       00 00 00 01 
       32 2A 04 6D 
       01 00       
041D52 01 00 00 00 0260*  	dl 1, 256, 256, 65536, fn_xevious_15, 366
       01 00 00 01 
       00 00 00 01 
       4B 2A 04 6E 
       01 00       
041D64 01 00 00 00 0261*  	dl 1, 256, 256, 65536, fn_xevious_16, 367
       01 00 00 01 
       00 00 00 01 
       64 2A 04 6F 
       01 00       
041D76 01 00 00 00 0262*  	dl 1, 256, 256, 65536, fn_xevious_17, 368
       01 00 00 01 
       00 00 00 01 
       7D 2A 04 70 
       01 00       
041D88 01 00 00 00 0263*  	dl 1, 256, 256, 65536, fn_xevious_18, 369
       01 00 00 01 
       00 00 00 01 
       96 2A 04 71 
       01 00       
041D9A 01 00 00 00 0264*  	dl 1, 256, 256, 65536, fn_xevious_19, 370
       01 00 00 01 
       00 00 00 01 
       AF 2A 04 72 
       01 00       
041DAC 01 00 00 00 0265*  	dl 1, 256, 256, 65536, fn_xevious_20, 371
       01 00 00 01 
       00 00 00 01 
       C8 2A 04 73 
       01 00       
041DBE 01 00 00 00 0266*  	dl 1, 256, 256, 65536, fn_xevious_21, 372
       01 00 00 01 
       00 00 00 01 
       E1 2A 04 74 
       01 00       
041DD0 01 00 00 00 0267*  	dl 1, 256, 256, 65536, fn_xevious_22, 373
       01 00 00 01 
       00 00 00 01 
       FA 2A 04 75 
       01 00       
041DE2 01 00 00 00 0268*  	dl 1, 256, 256, 65536, fn_xevious_23, 374
       01 00 00 01 
       00 00 00 01 
       13 2B 04 76 
       01 00       
041DF4 01 00 00 00 0269*  	dl 1, 256, 256, 65536, fn_xevious_24, 375
       01 00 00 01 
       00 00 00 01 
       2C 2B 04 77 
       01 00       
041E06 01 00 00 00 0270*  	dl 1, 256, 256, 65536, fn_xevious_25, 376
       01 00 00 01 
       00 00 00 01 
       45 2B 04 78 
       01 00       
041E18 01 00 00 00 0271*  	dl 1, 256, 256, 65536, fn_xevious_26, 377
       01 00 00 01 
       00 00 00 01 
       5E 2B 04 79 
       01 00       
041E2A 01 00 00 00 0272*  	dl 1, 256, 256, 65536, fn_xevious_27, 378
       01 00 00 01 
       00 00 00 01 
       77 2B 04 7A 
       01 00       
041E3C 01 00 00 00 0273*  	dl 1, 256, 256, 65536, fn_xevious_28, 379
       01 00 00 01 
       00 00 00 01 
       90 2B 04 7B 
       01 00       
041E4E 01 00 00 00 0274*  	dl 1, 256, 256, 65536, fn_xevious_29, 380
       01 00 00 01 
       00 00 00 01 
       A9 2B 04 7C 
       01 00       
041E60 01 00 00 00 0275*  	dl 1, 256, 256, 65536, fn_xevious_30, 381
       01 00 00 01 
       00 00 00 01 
       C2 2B 04 7D 
       01 00       
041E72 01 00 00 00 0276*  	dl 1, 256, 256, 65536, fn_xevious_31, 382
       01 00 00 01 
       00 00 00 01 
       DB 2B 04 7E 
       01 00       
041E84 01 00 00 20 0277*  	dl 1, 32, 32, 1024, fn_xevious_sprite_065, 383
       00 00 20 00 
       00 00 04 00 
       F4 2B 04 7F 
       01 00       
041E96 01 00 00 20 0278*  	dl 1, 32, 32, 1024, fn_xevious_sprite_066, 384
       00 00 20 00 
       00 00 04 00 
       15 2C 04 80 
       01 00       
041EA8 01 00 00 20 0279*  	dl 1, 32, 32, 1024, fn_xevious_sprite_067, 385
       00 00 20 00 
       00 00 04 00 
       36 2C 04 81 
       01 00       
041EBA 01 00 00 20 0280*  	dl 1, 32, 32, 1024, fn_xevious_sprite_068, 386
       00 00 20 00 
       00 00 04 00 
       57 2C 04 82 
       01 00       
041ECC 01 00 00 20 0281*  	dl 1, 32, 32, 1024, fn_xevious_sprite_069, 387
       00 00 20 00 
       00 00 04 00 
       78 2C 04 83 
       01 00       
041EDE 01 00 00 20 0282*  	dl 1, 32, 32, 1024, fn_xevious_sprite_070, 388
       00 00 20 00 
       00 00 04 00 
       99 2C 04 84 
       01 00       
041EF0 01 00 00 20 0283*  	dl 1, 32, 32, 1024, fn_xevious_sprite_071, 389
       00 00 20 00 
       00 00 04 00 
       BA 2C 04 85 
       01 00       
041F02 01 00 00 20 0284*  	dl 1, 32, 32, 1024, fn_xevious_sprite_072, 390
       00 00 20 00 
       00 00 04 00 
       DB 2C 04 86 
       01 00       
041F14 01 00 00 20 0285*  	dl 1, 32, 32, 1024, fn_xevious_sprite_073, 391
       00 00 20 00 
       00 00 04 00 
       FC 2C 04 87 
       01 00       
041F26 01 00 00 20 0286*  	dl 1, 32, 32, 1024, fn_xevious_sprite_074, 392
       00 00 20 00 
       00 00 04 00 
       1D 2D 04 88 
       01 00       
041F38 01 00 00 20 0287*  	dl 1, 32, 32, 1024, fn_xevious_sprite_075, 393
       00 00 20 00 
       00 00 04 00 
       3E 2D 04 89 
       01 00       
041F4A 01 00 00 20 0288*  	dl 1, 32, 32, 1024, fn_xevious_sprite_076, 394
       00 00 20 00 
       00 00 04 00 
       5F 2D 04 8A 
       01 00       
041F5C 01 00 00 20 0289*  	dl 1, 32, 32, 1024, fn_xevious_sprite_077, 395
       00 00 20 00 
       00 00 04 00 
       80 2D 04 8B 
       01 00       
041F6E 01 00 00 20 0290*  	dl 1, 32, 32, 1024, fn_xevious_sprite_078, 396
       00 00 20 00 
       00 00 04 00 
       A1 2D 04 8C 
       01 00       
041F80 01 00 00 20 0291*  	dl 1, 32, 32, 1024, fn_xevious_sprite_079, 397
       00 00 20 00 
       00 00 04 00 
       C2 2D 04 8D 
       01 00       
041F92             0292*  
041F92             0293*  ; files_list: ; filename:
041F92 73 70 72 69 0294*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
041FAC 73 70 72 69 0295*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
041FC6 73 70 72 69 0296*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
041FE0 73 70 72 69 0297*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
041FF9 73 70 72 69 0298*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
042014 73 70 72 69 0299*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
04202F 73 70 72 69 0300*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
042047 73 70 72 69 0301*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
042062 73 70 72 69 0302*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
042077 73 70 72 69 0303*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
04208C 73 70 72 69 0304*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
0420A6 73 70 72 69 0305*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
0420C0 73 70 72 69 0306*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
0420DA 73 70 72 69 0307*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
0420F4 73 70 72 69 0308*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
04210E 73 70 72 69 0309*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
042127 73 70 72 69 0310*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
042140 73 70 72 69 0311*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
042156 73 70 72 69 0312*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
04216C 73 70 72 69 0313*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
04217E 73 70 72 69 0314*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
042197 73 70 72 69 0315*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0421B0 73 70 72 69 0316*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0421C9 73 70 72 69 0317*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
0421E2 73 70 72 69 0318*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
0421FB 73 70 72 69 0319*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
042214 73 70 72 69 0320*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
04222D 73 70 72 69 0321*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
042246 73 70 72 69 0322*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
04225F 73 70 72 69 0323*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
042278 73 70 72 69 0324*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
042291 73 70 72 69 0325*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0422AA 73 70 72 69 0326*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0422C3 73 70 72 69 0327*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
0422DC 73 70 72 69 0328*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0422F5 73 70 72 69 0329*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
04230E 73 70 72 69 0330*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
042327 73 70 72 69 0331*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
042340 73 70 72 69 0332*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
042359 73 70 72 69 0333*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
042372 73 70 72 69 0334*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
04238B 73 70 72 69 0335*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0423A4 73 70 72 69 0336*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0423BD 73 70 72 69 0337*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
0423D6 73 70 72 69 0338*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0423EF 73 70 72 69 0339*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
042408 73 70 72 69 0340*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042421 73 70 72 69 0341*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04243A 73 70 72 69 0342*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042453 73 70 72 69 0343*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
04246C 73 70 72 69 0344*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
042485 73 70 72 69 0345*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
04249E 73 70 72 69 0346*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0424B4 73 70 72 69 0347*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0424CA 73 70 72 69 0348*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
0424E0 73 70 72 69 0349*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
0424F9 73 70 72 69 0350*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
04250C 73 70 72 69 0351*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
042528 73 70 72 69 0352*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
042544 73 70 72 69 0353*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
042560 73 70 72 69 0354*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
04257C 73 70 72 69 0355*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
042598 73 70 72 69 0356*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
0425B4 73 70 72 69 0357*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0425CD 73 70 72 69 0358*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0425E6 73 70 72 69 0359*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0425FF 73 70 72 69 0360*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
042618 73 70 72 69 0361*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
042631 73 70 72 69 0362*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
04264A 73 70 72 69 0363*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
042663 73 70 72 69 0364*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
04267C 73 70 72 69 0365*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
042695 73 70 72 69 0366*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0426AE 73 70 72 69 0367*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0426C7 73 70 72 69 0368*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0426E0 73 70 72 69 0369*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0426F9 73 70 72 69 0370*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
042712 73 70 72 69 0371*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
04272B 73 70 72 69 0372*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042744 73 70 72 69 0373*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04275D 73 70 72 69 0374*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
042776 73 70 72 69 0375*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
04278F 73 70 72 69 0376*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0427A8 73 70 72 69 0377*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0427C1 73 70 72 69 0378*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0427DA 73 70 72 69 0379*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0427F3 73 70 72 69 0380*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
04280C 73 70 72 69 0381*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
042825 73 70 72 69 0382*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04283E 73 70 72 69 0383*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042857 73 70 72 69 0384*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
042870 73 70 72 69 0385*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042889 73 70 72 69 0386*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0428A2 73 70 72 69 0387*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0428BB 73 70 72 69 0388*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0428D4 73 70 72 69 0389*  fn_xevious_00: db "sprites/xevious_00.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 30 2E 72 
       67 62 61 32 
       00          
0428ED 73 70 72 69 0390*  fn_xevious_01: db "sprites/xevious_01.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 31 2E 72 
       67 62 61 32 
       00          
042906 73 70 72 69 0391*  fn_xevious_02: db "sprites/xevious_02.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 32 2E 72 
       67 62 61 32 
       00          
04291F 73 70 72 69 0392*  fn_xevious_03: db "sprites/xevious_03.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 33 2E 72 
       67 62 61 32 
       00          
042938 73 70 72 69 0393*  fn_xevious_04: db "sprites/xevious_04.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 34 2E 72 
       67 62 61 32 
       00          
042951 73 70 72 69 0394*  fn_xevious_05: db "sprites/xevious_05.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 35 2E 72 
       67 62 61 32 
       00          
04296A 73 70 72 69 0395*  fn_xevious_06: db "sprites/xevious_06.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 36 2E 72 
       67 62 61 32 
       00          
042983 73 70 72 69 0396*  fn_xevious_07: db "sprites/xevious_07.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 37 2E 72 
       67 62 61 32 
       00          
04299C 73 70 72 69 0397*  fn_xevious_08: db "sprites/xevious_08.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 38 2E 72 
       67 62 61 32 
       00          
0429B5 73 70 72 69 0398*  fn_xevious_09: db "sprites/xevious_09.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       30 39 2E 72 
       67 62 61 32 
       00          
0429CE 73 70 72 69 0399*  fn_xevious_10: db "sprites/xevious_10.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 30 2E 72 
       67 62 61 32 
       00          
0429E7 73 70 72 69 0400*  fn_xevious_11: db "sprites/xevious_11.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 31 2E 72 
       67 62 61 32 
       00          
042A00 73 70 72 69 0401*  fn_xevious_12: db "sprites/xevious_12.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 32 2E 72 
       67 62 61 32 
       00          
042A19 73 70 72 69 0402*  fn_xevious_13: db "sprites/xevious_13.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 33 2E 72 
       67 62 61 32 
       00          
042A32 73 70 72 69 0403*  fn_xevious_14: db "sprites/xevious_14.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 34 2E 72 
       67 62 61 32 
       00          
042A4B 73 70 72 69 0404*  fn_xevious_15: db "sprites/xevious_15.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 35 2E 72 
       67 62 61 32 
       00          
042A64 73 70 72 69 0405*  fn_xevious_16: db "sprites/xevious_16.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 36 2E 72 
       67 62 61 32 
       00          
042A7D 73 70 72 69 0406*  fn_xevious_17: db "sprites/xevious_17.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 37 2E 72 
       67 62 61 32 
       00          
042A96 73 70 72 69 0407*  fn_xevious_18: db "sprites/xevious_18.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 38 2E 72 
       67 62 61 32 
       00          
042AAF 73 70 72 69 0408*  fn_xevious_19: db "sprites/xevious_19.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       31 39 2E 72 
       67 62 61 32 
       00          
042AC8 73 70 72 69 0409*  fn_xevious_20: db "sprites/xevious_20.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 30 2E 72 
       67 62 61 32 
       00          
042AE1 73 70 72 69 0410*  fn_xevious_21: db "sprites/xevious_21.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 31 2E 72 
       67 62 61 32 
       00          
042AFA 73 70 72 69 0411*  fn_xevious_22: db "sprites/xevious_22.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 32 2E 72 
       67 62 61 32 
       00          
042B13 73 70 72 69 0412*  fn_xevious_23: db "sprites/xevious_23.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 33 2E 72 
       67 62 61 32 
       00          
042B2C 73 70 72 69 0413*  fn_xevious_24: db "sprites/xevious_24.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 34 2E 72 
       67 62 61 32 
       00          
042B45 73 70 72 69 0414*  fn_xevious_25: db "sprites/xevious_25.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 35 2E 72 
       67 62 61 32 
       00          
042B5E 73 70 72 69 0415*  fn_xevious_26: db "sprites/xevious_26.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 36 2E 72 
       67 62 61 32 
       00          
042B77 73 70 72 69 0416*  fn_xevious_27: db "sprites/xevious_27.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 37 2E 72 
       67 62 61 32 
       00          
042B90 73 70 72 69 0417*  fn_xevious_28: db "sprites/xevious_28.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 38 2E 72 
       67 62 61 32 
       00          
042BA9 73 70 72 69 0418*  fn_xevious_29: db "sprites/xevious_29.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       32 39 2E 72 
       67 62 61 32 
       00          
042BC2 73 70 72 69 0419*  fn_xevious_30: db "sprites/xevious_30.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       33 30 2E 72 
       67 62 61 32 
       00          
042BDB 73 70 72 69 0420*  fn_xevious_31: db "sprites/xevious_31.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       33 31 2E 72 
       67 62 61 32 
       00          
042BF4 73 70 72 69 0421*  fn_xevious_sprite_065: db "sprites/xevious_sprite_065.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       36 35 2E 72 
       67 62 61 32 
       00          
042C15 73 70 72 69 0422*  fn_xevious_sprite_066: db "sprites/xevious_sprite_066.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       36 36 2E 72 
       67 62 61 32 
       00          
042C36 73 70 72 69 0423*  fn_xevious_sprite_067: db "sprites/xevious_sprite_067.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       36 37 2E 72 
       67 62 61 32 
       00          
042C57 73 70 72 69 0424*  fn_xevious_sprite_068: db "sprites/xevious_sprite_068.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       36 38 2E 72 
       67 62 61 32 
       00          
042C78 73 70 72 69 0425*  fn_xevious_sprite_069: db "sprites/xevious_sprite_069.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       36 39 2E 72 
       67 62 61 32 
       00          
042C99 73 70 72 69 0426*  fn_xevious_sprite_070: db "sprites/xevious_sprite_070.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 30 2E 72 
       67 62 61 32 
       00          
042CBA 73 70 72 69 0427*  fn_xevious_sprite_071: db "sprites/xevious_sprite_071.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 31 2E 72 
       67 62 61 32 
       00          
042CDB 73 70 72 69 0428*  fn_xevious_sprite_072: db "sprites/xevious_sprite_072.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
042CFC 73 70 72 69 0429*  fn_xevious_sprite_073: db "sprites/xevious_sprite_073.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 33 2E 72 
       67 62 61 32 
       00          
042D1D 73 70 72 69 0430*  fn_xevious_sprite_074: db "sprites/xevious_sprite_074.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 34 2E 72 
       67 62 61 32 
       00          
042D3E 73 70 72 69 0431*  fn_xevious_sprite_075: db "sprites/xevious_sprite_075.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 35 2E 72 
       67 62 61 32 
       00          
042D5F 73 70 72 69 0432*  fn_xevious_sprite_076: db "sprites/xevious_sprite_076.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 36 2E 72 
       67 62 61 32 
       00          
042D80 73 70 72 69 0433*  fn_xevious_sprite_077: db "sprites/xevious_sprite_077.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 37 2E 72 
       67 62 61 32 
       00          
042DA1 73 70 72 69 0434*  fn_xevious_sprite_078: db "sprites/xevious_sprite_078.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 38 2E 72 
       67 62 61 32 
       00          
042DC2 73 70 72 69 0435*  fn_xevious_sprite_079: db "sprites/xevious_sprite_079.rgba2",0
       74 65 73 2F 
       78 65 76 69 
       6F 75 73 5F 
       73 70 72 69 
       74 65 5F 30 
       37 39 2E 72 
       67 62 61 32 
       00          
042DE3             0036   	include "images_ui.inc"
042DE3             0001*  ; Generated by make_images.py
042DE3             0002*  
042DE3             0003*  ui_num_images: equ 4
042DE3             0004*  
042DE3             0005*  ; buffer_ids:
042DE3             0006*  BUF_BEZEL_L: equ 0
042DE3             0007*  BUF_BEZEL_R: equ 1
042DE3             0008*  BUF_SPLASH_BG: equ 2
042DE3             0009*  BUF_SPLASH_LOGO: equ 3
042DE3             0010*  
042DE3             0011*  ui_image_list: ; type; width; height; filename; bufferId:
042DE3 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       2B 2E 04 00 
       00 00       
042DF5 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       3C 2E 04 01 
       00 00       
042E07 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       4D 2E 04 02 
       00 00       
042E19 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       60 2E 04 03 
       00 00       
042E2B             0016*  
042E2B             0017*  ; files_list: ; filename:
042E2B 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
042E3C 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
042E4D 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
042E60 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
042E75             0037   	include "laser.inc"
042E75             0001*  ; ##### LASER SPRITE PARAMETERS #####
042E75             0002*  ; uses the same offsets from its table base as the main sprite table:
042E75             0003*  laser_start_variables: ; label marking beginning of table
042E75 11          0004*  laser_id:               db table_max_records+1
042E76 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
042E77 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
042E7A 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
042E7D 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042E7E 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042E7F 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042E80 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042E83 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042E86 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042E89 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042E8C 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
042E8F 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042E92 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
042E95 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
042E96 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
042E97 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
042E98 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
042E99 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
042E9A 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
042E9B             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
042E9B             0025*  
042E9B             0026*  ; laser_control:
042E9B             0027*  ; ; is laser already active?
042E9B             0028*  ;     ld a,(laser_collisions)
042E9B             0029*  ;     and %00000001 ; bit zero is lit if laser is active
042E9B             0030*  ;     jr nz,laser_move ; move laser if not zero
042E9B             0031*  ; ; otherwise check if laser fired
042E9B             0032*  ;     in a,(#82) ; keyboard
042E9B             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
042E9B             0034*  ;     ret z ; go back if laser not fired
042E9B             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
042E9B             0036*  ; ; set laser status to active (set bit 0)
042E9B             0037*  ;     ld a,%1
042E9B             0038*  ;     ld (laser_collisions),a
042E9B             0039*  ; ; initialize laser position
042E9B             0040*  ;     ld a,(player_x+1) ; we only need the integer part
042E9B             0041*  ;     ; add a,6 ; horizontal center with player sprite
042E9B             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
042E9B             0043*  ;     ld a,(player_y+1) ; we only need the integer part
042E9B             0044*  ;     add a,-6 ; set laser y a few pixels above player
042E9B             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
042E9B             0046*  ;     ; fall through to laser_move
042E9B             0047*  
042E9B             0048*  ; laser_move:
042E9B             0049*  ; ; begin setting laser to active sprite
042E9B             0050*  ;     ld hl,lasers
042E9B             0051*  ;     ld (sprite_base_bufferId),hl
042E9B             0052*  ;     ld hl,0 ; north
042E9B             0053*  ;     ld (sprite_heading),hl
042E9B             0054*  ;     xor a ; laser has no animations yet :-(
042E9B             0055*  ;     ld (sprite_animation),a
042E9B             0056*  ;     ; we set position here for the time being as a default
042E9B             0057*  ;     ; in case the laser is flagged for deletion
042E9B             0058*  ;     ; load sprite_x with laser x position (we do y further down)
042E9B             0059*  ;     ld hl,(laser_x)
042E9B             0060*  ;     ld (sprite_x),hl
042E9B             0061*  ; ; did laser just die?
042E9B             0062*  ;     ld a,(laser_collisions)
042E9B             0063*  ;     bit 1,a ; z if laser didn't just die
042E9B             0064*  ;     jr z,laser_not_dead_yet
042E9B             0065*  ; ; yes laser died
042E9B             0066*  ;     call kill_laser
042E9B             0067*  ;     ret ; done
042E9B             0068*  ; laser_not_dead_yet:
042E9B             0069*  ; ; draw it
042E9B             0070*  ; ; update laser y position
042E9B             0071*  ;     ld hl,(laser_y) ; grab laser y position
042E9B             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
042E9B             0073*  ;     add hl,de ; add y velocity to y pos
042E9B             0074*  ;     ld (sprite_y),hl ; update laser y position
042E9B             0075*  ;     ld (laser_y),hl ; update laser y position
042E9B             0076*  ; ; are we at top of screen?
042E9B             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
042E9B             0078*  ;     sub h ; no carry if above threshold
042E9B             0079*  ;     jr c,finally_draw_the_frikken_laser
042E9B             0080*  ;     ; if at top of screen,laser dies
042E9B             0081*  ;     call kill_laser
042E9B             0082*  ;     ret
042E9B             0083*  ; ; otherwise,finally draw the frikken laser
042E9B             0084*  ; finally_draw_the_frikken_laser:
042E9B             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042E9B             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042E9B             0087*  ; ; all done
042E9B             0088*  ;     ret
042E9B             0089*  
042E9B             0090*  ; kill_laser:
042E9B             0091*  ; ; update status to inactive
042E9B             0092*  ;     xor a ; zero out a
042E9B             0093*  ;     ld (laser_collisions),a
042E9B             0094*  ;     ret
042E9B             0038   	include "levels.inc"
042E9B 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
042E9C 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
042EAC 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
042EBC 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
042ECC 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042EDC 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
042EEC 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042EFC 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042F0C 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
042F1C 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
042F2C 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
042F3C 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
042F4C 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
042F5C 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
042F6C 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
042F7C 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042F8C 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
042F9C 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
042FAC 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
042FBC 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042FCC 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
042FDC 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
042FEC 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
042FFC 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
04300C 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04301C 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
04302C 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04303C 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
04304C 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04305C 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04306C 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04307C 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
04308C 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
04309C 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0430AC 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0430BC 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0430CC 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0430DC 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0430EC 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0430FC 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04310C 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04311C 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04312C 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04313C 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04314C 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04315C 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04316C 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04317C 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04318C 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04319C 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431AC 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0431BC 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
0431CC 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0431DC 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0431EC 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0431FC 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04320C 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04321C 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04322C 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04323C 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04324C 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04325C 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04326C 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04327C 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
04328C 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04329C 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0432AC 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0432BC 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0432CC 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0432DC 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0432EC 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
0432FC 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
04330C 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
04331C 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04332C 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04333C 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04334C 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04335C 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04336C 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04337C 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04338C 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04339C 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0433AC 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0433BC 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0433CC 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0433DC 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0433EC 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0433FC 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04340C 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
04341C 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
04342C 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
04343C 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04344C 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04345C 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
04346C 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
04347C 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
04348C 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
04349C 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
0434AC 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
0434BC 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
0434CC 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0434DC 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0434EC 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0434FC 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04350C 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04351C 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04352C 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04353C 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04354C 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04355C 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
04356C 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04357C 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04358C 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
04359C 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
0435AC 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
0435BC 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0435CC 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
0435DC 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
0435EC 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0435FC 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04360C 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04361C 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
04362C 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
04363C 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
04364C 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
04365C 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04366C 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04367C 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04368C 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04369C 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0436AC 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0436BC 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
0436CC 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
0436DC 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0436EC 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0436FC 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04370C 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04371C 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04372C 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04373C 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04374C 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
04375C 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
04376C 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04377C 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04378C 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04379C 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0437AC 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
0437BC 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
0437CC 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
0437DC 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0437EC 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0437FC 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
04380C 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
04381C 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
04382C 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
04383C 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
04384C 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
04385C 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
04386C 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04387C 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04388C 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
04389C 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
0438AC 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
0438BC 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
0438CC 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
0438DC 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
0438EC 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
0438FC 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
04390C 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
04391C 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
04392C 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04393C 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04394C 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04395C 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04396C 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04397C 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04398C 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04399C 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439AC 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439BC 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439CC 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439DC 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439EC 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0439FC 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043A0C 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043A1C 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043A2C 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
043A3C 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
043A4C 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043A5C 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043A6C 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043A7C 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
043A8C 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043A9C 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043AAC 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043ABC 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
043ACC 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
043ADC 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043AEC 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043AFC 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043B0C 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043B1C 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043B2C 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
043B3C 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
043B4C 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
043B5C 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
043B6C 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
043B7C 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043B8C 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043B9C 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
043BAC 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
043BBC 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
043BCC 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
043BDC 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
043BEC 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
043BFC 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
043C0C 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
043C1C 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
043C2C 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
043C3C 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
043C4C 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
043C5C 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043C6C 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043C7C 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043C8C 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043C9C 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
043CAC 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043CBC 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043CCC 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
043CDC 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043CEC 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043CFC 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
043D0C 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043D1C 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043D2C 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
043D3C 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043D4C 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043D5C 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
043D6C 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043D7C 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
043D8C 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
043D9C 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043DAC 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043DBC 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
043DCC 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043DDC 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043DEC 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
043DFC 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
043E0C 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
043E1C 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
043E2C 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043E3C 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
043E4C 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
043E5C 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
043E6C 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
043E7C 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
043E8C 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043E9C             0258*  
043E9C             0259*  
043E9C 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
043E9D 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043EAD 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043EBD 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043ECD 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043EDD 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043EED 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043EFD 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F0D 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F1D 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F2D 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F3D 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F4D 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F5D 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F6D 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F7D 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F8D 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043F9D             0277*  
043F9D             0039   	include "player.inc"
043F9D             0001*  ; ######## GAME STATE VARIABLES #######
043F9D             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
043F9D 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
043FA0             0004*  ; player current shields,binary
043FA0             0005*  ; when < 0 player splodes
043FA0             0006*  ; restores to player_max_shields when new ship spawns
043FA0 10          0007*  player_shields: db 16 ; binary
043FA1             0008*  ; max player shields,binary
043FA1             0009*  ; can increase with power-ups (todo)
043FA1 10          0010*  player_max_shields: db 16 ; binary
043FA2             0011*  ; when reaches zero,game ends
043FA2             0012*  ; can increase based on TODO
043FA2 03          0013*  player_ships: db 0x03 ; binary
043FA3             0014*  
043FA3             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
043FA3             0016*  ; uses the same offsets from its table base as the main sprite table:
043FA3             0017*  player_start_variables: ; label marking beginning of table
043FA3 10          0018*  player_id:               db table_max_records
043FA4 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
043FA5 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
043FA8 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
043FAB 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
043FAC 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043FAD 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043FAE 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043FB1 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043FB4 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043FB7 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043FBA 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
043FBD 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043FC0 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
043FC3 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
043FC4 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
043FC5 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
043FC6 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
043FC7 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
043FC8 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
043FC9             0038*  player_end_variables: ; for when we want to traverse this table in reverse
043FC9             0039*  
043FC9             0040*  ; set initial player position
043FC9             0041*  ; inputs: none,everything is hardcoded
043FC9             0042*  ; outputs: player_x/y set to bottom-left corner of screen
043FC9             0043*  ; destroys: a
043FC9             0044*  player_init:
043FC9 3A A3 3F 04 0045*  	ld a,(player_id)
043FCD CD 41 4B 04 0046*  	call vdu_sprite_select
043FD1 CD 54 4B 04 0047*      call vdu_sprite_clear_frames
043FD5 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
043FD9 CD 96 4C 04 0049*      call vdu_sprite_add_buff
043FDD 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
043FE1 CD 96 4C 04 0051*      call vdu_sprite_add_buff
043FE5 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
043FE9 CD 96 4C 04 0053*      call vdu_sprite_add_buff
043FED 01 00 00 00 0054*      ld bc,0
043FF1 ED 43 AE 3F 0055*      ld (player_x),bc
       04          
043FF6 11 00 DF 00 0056*      ld de,0x00DF00
043FFA ED 53 B1 3F 0057*      ld (player_y),de
       04          
043FFF CD 0D 4C 04 0058*      call vdu_sprite_move_abs168
044003 CD B7 4B 04 0059*      call vdu_sprite_show
044007 C9          0060*      ret
044008             0061*  
044008             0062*  ; process player keyboard input, set player bitmap
044008             0063*  ; velocities and draw player bitmap at updated coordinates
044008             0064*  ; Inputs: player_x/y set at desired position
044008             0065*  ; Returns: player bitmap drawn at updated position
044008             0066*  ; Destroys: probably everything except maybe iy
044008             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
044008             0068*  ; TODO: requires sprite implementation
044008             0069*  player_input:
044008             0070*  ; reset player component velocities to zero as the default
044008 21 00 00 00 0071*  	ld hl,0
04400C 22 B4 3F 04 0072*  	ld (player_xvel),hl
044010 22 B7 3F 04 0073*  	ld (player_yvel),hl
044014             0074*  ; make ship the active sprite
044014 3A A3 3F 04 0075*      ld a,(player_id)
044018 CD 41 4B 04 0076*      call vdu_sprite_select
04401C             0077*  ; check for keypresses and branch accordingly
04401C             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04401C             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04401C 3E 1E       0001*M 			LD	A, function
04401E 5B CF       0002*M 			RST.LIL	08h
044020             0080*  ; we test all four arrow keys and add/subract velocities accordingly
044020             0081*  ; this handles the case where two opposing movement keys
044020             0082*  ; are down simultaneously (velocities will net to zero)
044020             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
044020             0084*  ; it also allows movement and action keys to be detected simultaneously
044020             0085*  ; so we can walk and chew gum at the same time
044020 3E 01       0086*      ld a,1 ; set ship's default animation to center
044022             0087*          ; if left and right are both down a will net to
044022             0088*  
044022             0089*  @left:
044022 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
044026 28 0E       0091*      jr z,@right
044028 2A B4 3F 04 0092*      ld hl,(player_xvel)
04402C 01 00 FD FF 0093*      ld bc,-speed_player
044030 09          0094*      add hl,bc
044031 22 B4 3F 04 0095*      ld (player_xvel),hl
044035 3D          0096*      dec a ; set ship's animation to left
044036             0097*  @right:
044036 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
04403A 28 0E       0099*  	jr z,@up
04403C 2A B4 3F 04 0100*      ld hl,(player_xvel)
044040 01 00 03 00 0101*      ld bc,speed_player
044044 09          0102*      add hl,bc
044045 22 B4 3F 04 0103*      ld (player_xvel),hl
044049 3C          0104*      inc a ; set ship's animation to right
04404A             0105*  @up:
04404A DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
04404E 28 0D       0107*  	jr z,@down
044050 2A B7 3F 04 0108*      ld hl,(player_yvel)
044054 01 00 FD FF 0109*      ld bc,-speed_player
044058 09          0110*      add hl,bc
044059 22 B7 3F 04 0111*      ld (player_yvel),hl
04405D             0112*  @down:
04405D DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
044061 28 0D       0114*  	jr z,@done_keyboard
044063 2A B7 3F 04 0115*      ld hl,(player_yvel)
044067 01 00 03 00 0116*      ld bc,speed_player
04406B 09          0117*      add hl,bc
04406C 22 B7 3F 04 0118*      ld (player_yvel),hl
044070             0119*  @done_keyboard:
044070             0120*  ; move player sprite according to velocities set by keypresses
044070 2A B4 3F 04 0121*      ld hl,(player_xvel)
044074             0122*  ; compute new x position
044074 ED 5B AE 3F 0123*      ld de,(player_x)
       04          
044079 19          0124*      add hl,de ; hl = player_x + player_xvel
04407A             0125*      ; check for horizontal screen edge collisions
04407A             0126*      ; and adjust coordinate as necessary
04407A             0127*  ; TODO: make this work using 24-bit registers
04407A             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
04407A             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
04407A             0130*      ; ld a,8 ; set x to leftmost allowable position
04407A             0131*  ; @check_right:
04407A             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
04407A             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
04407A             0134*  ;     ld a,248 ; set x to rightmost allowable position
04407A             0135*  @x_ok:
04407A             0136*  ; save the updated drawing coordinate
04407A 22 AE 3F 04 0137*      ld (player_x),hl
04407E             0138*  ;compute new y position
04407E 2A B1 3F 04 0139*      ld hl,(player_y)
044082 ED 5B B7 3F 0140*      ld de,(player_yvel)
       04          
044087 19          0141*      add hl,de ; hl = player_y + player_yvel
044088             0142*  ; TODO: make this work using 24-bit registers
044088             0143*  ;     ; check for vertical screen edge collisions
044088             0144*  ;     ; and adjust coordinate as necessary
044088             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
044088             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
044088             0147*  ;     ld a,8 ; set y to topmost allowable position
044088             0148*  ; @check_top:
044088             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
044088             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
044088             0151*  ;     ld a,232 ; set y to bottommost allowable position
044088             0152*  @y_ok:
044088 22 B1 3F 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
04408C             0154*  ; a should land here loaded with the correct frame
04408C CD A4 4B 04 0155*      call vdu_sprite_select_frame
044090             0156*  ; draw player at updated position
044090 ED 4B AE 3F 0157*      ld bc,(player_x)
       04          
044095 ED 5B B1 3F 0158*  	ld de,(player_y)
       04          
04409A             0159*  
04409A             0160*      ; call dumpRegistersHex
04409A             0161*  
04409A CD 0D 4C 04 0162*  	call vdu_sprite_move_abs168
04409E             0163*  
04409E             0164*  ; end player_input
04409E C9          0165*  	ret
04409F             0166*  
04409F             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
04409F             0168*  ; ; INSTEAD OF FRACTIONAL
04409F             0169*  ; ; ----------------------------------------------------------------
04409F             0170*  ; ; process player keyboard input, set player bitmap
04409F             0171*  ; ; velocities and draw player bitmap at updated coordinates
04409F             0172*  ; ; Inputs: player_x/y set at desired position
04409F             0173*  ; ; Returns: player bitmap drawn at updated position
04409F             0174*  ; ; Destroys: probably everything except maybe iy
04409F             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04409F             0176*  ; ; TODO: requires sprite implementation
04409F             0177*  ; player_input:
04409F             0178*  ; ; reset player component velocities to zero as the default
04409F             0179*  ; 	ld hl,0
04409F             0180*  ; 	ld (player_xvel),hl
04409F             0181*  ; 	ld (player_yvel),hl
04409F             0182*  ; ; check for keypresses and branch accordingly
04409F             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04409F             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04409F             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
04409F             0186*  ; ; this handles the case where two opposing movement keys
04409F             0187*  ; ; are down simultaneously (velocities will net to zero)
04409F             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
04409F             0189*  ; ; it also allows movement and action keys to be detected simultaneously
04409F             0190*  ; ; so we can walk and chew gum at the same time
04409F             0191*  ; @left:
04409F             0192*  ;     bit 1,(ix+3) ; keycode 26
04409F             0193*  ;     jr z,@right
04409F             0194*  ;     ld hl,(player_xvel)
04409F             0195*  ;     ld bc,-3
04409F             0196*  ;     add hl,bc
04409F             0197*  ;     ld (player_xvel),hl
04409F             0198*  ; @right:
04409F             0199*  ;     bit 1,(ix+15) ; keycode 122
04409F             0200*  ; 	jr z,@up
04409F             0201*  ;     ld hl,(player_xvel)
04409F             0202*  ;     ld bc,3
04409F             0203*  ;     add hl,bc
04409F             0204*  ;     ld (player_xvel),hl
04409F             0205*  ; @up:
04409F             0206*  ;     bit 1,(ix+7) ; keycode 58
04409F             0207*  ; 	jr z,@down
04409F             0208*  ;     ld hl,(player_yvel)
04409F             0209*  ;     ld bc,-3
04409F             0210*  ;     add hl,bc
04409F             0211*  ;     ld (player_yvel),hl
04409F             0212*  ; @down:
04409F             0213*  ;     bit 1,(ix+5) ; keycode 42
04409F             0214*  ; 	jr z,@done_keyboard
04409F             0215*  ;     ld hl,(player_yvel)
04409F             0216*  ;     ld bc,3
04409F             0217*  ;     add hl,bc
04409F             0218*  ;     ld (player_yvel),hl
04409F             0219*  ; @done_keyboard:
04409F             0220*  ; ; move player sprite according to velocities set by keypresses
04409F             0221*  ;     ld hl,(player_xvel)
04409F             0222*  ; ; compute new x position
04409F             0223*  ;     ld de,(player_x)
04409F             0224*  ;     add hl,de ; hl = player_x + player_xvel
04409F             0225*  ;     ; check for horizontal screen edge collisions
04409F             0226*  ;     ; and adjust coordinate as necessary
04409F             0227*  ; ; TODO: make this work using 24-bit registers
04409F             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
04409F             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
04409F             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
04409F             0231*  ; ; @check_right:
04409F             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
04409F             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
04409F             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
04409F             0235*  ; @x_ok:
04409F             0236*  ;     ; save the updated drawing coordinate
04409F             0237*  ;     ld (player_x),hl
04409F             0238*  ; ;compute new y position
04409F             0239*  ;     ld hl,(player_y)
04409F             0240*  ;     ld de,(player_yvel)
04409F             0241*  ;     add hl,de ; hl = player_y + player_yvel
04409F             0242*  ; ; TODO: make this work using 24-bit registers
04409F             0243*  ; ;     ; check for vertical screen edge collisions
04409F             0244*  ; ;     ; and adjust coordinate as necessary
04409F             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
04409F             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
04409F             0247*  ; ;     ld a,8 ; set y to topmost allowable position
04409F             0248*  ; ; @check_top:
04409F             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
04409F             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
04409F             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
04409F             0252*  ; @y_ok:
04409F             0253*  ;     ld (player_y),hl
04409F             0254*  ; ; draw player at updated position
04409F             0255*  ;     ld a,(player_id)
04409F             0256*  ;     call vdu_sprite_select
04409F             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
04409F             0258*  ;     call get_sign_hlu ; to set the proper animation
04409F             0259*  ;     add a,1 ; ...
04409F             0260*  ;     call vdu_sprite_select_frame
04409F             0261*  ;     ld bc,(player_x)
04409F             0262*  ; 	ld de,(player_y)
04409F             0263*  ; 	call vdu_sprite_move_abs
04409F             0264*  ; ; end player_input
04409F             0265*  ; 	ret
04409F             0266*  
04409F             0267*  
04409F             0268*  ; ###################################################################
04409F             0269*  ; TODO: the below is all stuff from the original code we need to port
04409F             0270*  ; ###################################################################
04409F             0271*  
04409F             0272*  ; kill_player:
04409F             0273*  ; ; set player status to dead
04409F             0274*  ;     xor a; sets all player flags to zero
04409F             0275*  ;     ld (player_collisions),a
04409F             0276*  ; ; deduct a ship from the inventory
04409F             0277*  ;     ld a,(player_ships)
04409F             0278*  ;     dec a
04409F             0279*  ;     ld (player_ships),a
04409F             0280*  ; ; are we out of ships?
04409F             0281*  ;     jp z,game_over
04409F             0282*  ; ; wait a few ticks
04409F             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
04409F             0284*  ;     ld (player_move_timer),a
04409F             0285*  ; kill_player_loop:
04409F             0286*  ;     call vdu_vblank
04409F             0287*  ;     ld a,(player_move_timer)
04409F             0288*  ;     dec a
04409F             0289*  ;     ld (player_move_timer),a
04409F             0290*  ;     jr nz,kill_player_loop
04409F             0291*  ;     call player_init ; player respawn if timer zero
04409F             0292*  ;     ret ; and out
04409F             0293*  
04409F             0294*  
04409F             0295*  ; player_move:
04409F             0296*  ; ; begin setting player to active sprite
04409F             0297*  ;     ld hl,player
04409F             0298*  ;     ld (sprite_base_bufferId),hl
04409F             0299*  ;     ld hl,0 ; north
04409F             0300*  ;     ld (sprite_heading),hl
04409F             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
04409F             0302*  ;     ld (sprite_animation),a
04409F             0303*  ;     ; we set position here for the time being as a default
04409F             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
04409F             0305*  ;     ld hl,(player_x)
04409F             0306*  ;     ld (sprite_x),hl
04409F             0307*  ;     ld hl,(player_y)
04409F             0308*  ;     ld (sprite_y),hl
04409F             0309*  ; ; did we just die?
04409F             0310*  ;     ld a,(player_collisions)
04409F             0311*  ;     and %00000010 ; zero flag will be set if not dead
04409F             0312*  ;     jr z,player_not_dead
04409F             0313*  ; ; yes we died
04409F             0314*  ;     call kill_player
04409F             0315*  ;     ret ; done
04409F             0316*  ; ; yay we didn't die
04409F             0317*  ; player_not_dead:
04409F             0318*  ; ; set player movements to zero by default
04409F             0319*  ;     ld hl,0
04409F             0320*  ;     ld (player_xvel),hl
04409F             0321*  ;     ld (player_yvel),hl
04409F             0322*  ; ; do we move it?
04409F             0323*  ;     in a,(#82) ; keyboard
04409F             0324*  ;     or a ; if zero,don't move
04409F             0325*  ;     jr z,player_draw
04409F             0326*  ; ; move it
04409F             0327*  ;     call player_move_calc
04409F             0328*  ; player_draw:
04409F             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04409F             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04409F             0331*  ; player_move_done:
04409F             0332*  ;     ; write updated x,y coordinates back to player table
04409F             0333*  ;     ld hl,(sprite_x)
04409F             0334*  ;     ld (player_x),hl
04409F             0335*  ;     ld hl,(sprite_y)
04409F             0336*  ;     ld (player_y),hl
04409F             0337*  ;     ret
04409F             0040   	include "sprites.inc"
04409F             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
04409F             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
04409F             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
04409F             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
04409F             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
04409F             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
04409F             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
04409F             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
04409F             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
04409F             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
04409F             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
04409F             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04409F             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04409F             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
04409F             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
04409F             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
04409F             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
04409F             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
04409F             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
04409F             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
04409F             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
04409F             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
04409F             0023*  
04409F             0024*  ; ###### SPRITE TABLE VARIABLES ######
04409F             0025*  ; maximum number of sprites
04409F             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
04409F             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
04409F             0028*  
04409F             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
04409F             0030*  table_base:
04409F 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0442FF             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0442FF             0033*  
0442FF             0034*  ; pointer to top address of current record, initialized to table_base
0442FF 9F 40 04    0035*  table_pointer: dl table_base
044302             0036*  ; how many active sprites
044302 00          0037*  table_active_sprites: db 0x00
044303             0038*  ; flag indicating collision with screen edge
044303             0039*  ; uses orientation codes to specify which edge(s)
044303 00          0040*  sprite_screen_edge: db #00
044304             0041*  ; next sprite id to use
044304 00          0042*  sprite_next_id: db 0
044305             0043*  
044305             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
044305             0045*  ; integer coordinates are all that are needed for collision calculations
044305 00          0046*  collision_x: db 0x00
044306 00          0047*  collision_y: db 0x00
044307 00          0048*  collision_dim_x: db 0x00
044308 00          0049*  collision_dim_y: db 0x00
044309             0050*  
044309             0051*  ; scratch variables
044309 00          0052*  x: db 0x00 ; 8-bit signed integer
04430A 00          0053*  y: db 0x00 ; 8-bit signed integer
04430B 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
04430E 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
044311 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
044314 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
044317 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
04431A 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
04431D             0060*  
04431D             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
04431D 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
044320 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
044323 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
044326             0065*  
044326             0066*  ; gets the next available sprite id
044326             0067*  ; inputs; none
044326             0068*  ; returns: if new sprite available, a = sprite id,
044326             0069*  ;           ix pointing to new sprite vars, carry set
044326             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
044326             0071*  ; destroys: a,b,hl,ix
044326             0072*  ; affects: bumps table_active_sprites by one
044326             0073*  table_get_next_id:
044326 DD 21 9F 40 0074*      ld ix,table_base
       04          
04432B 11 26 00 00 0075*      ld de,table_bytes_per_record
04432F 06 10       0076*      ld b,table_max_records
044331             0077*  @loop:
044331 DD 7E 01    0078*      ld a,(ix+sprite_type)
044334 A7          0079*      and a
044335 28 06       0080*      jr z,@found
044337 DD 19       0081*      add ix,de
044339 10 F6       0082*      djnz @loop
04433B             0083*  @notfound:
04433B AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
04433C C9          0085*      ret
04433D             0086*  @found:
04433D             0087*  ; bump number of active sprites
04433D 21 02 43 04 0088*      ld hl,table_active_sprites
044341 34          0089*      inc (hl)
044342             0090*  ; return sprite id
044342 3E 10       0091*      ld a,table_max_records
044344 90          0092*      sub b
044345 32 04 43 04 0093*      ld (sprite_next_id),a
044349 37          0094*      scf ; sets carry flag indicating we found a free sprite
04434A C9          0095*      ret ; done
04434B             0096*  
04434B             0097*  ; deactivate the sprite with the given id
04434B             0098*  ; inputs: a = sprite id
04434B             0099*  ; outputs: nothing
04434B             0100*  ; destroys: a,ix,de
04434B             0101*  ; affects: decrements table_active_sprites by one
04434B             0102*  table_deactivate_sprite:
04434B F5          0103*      push af ; save sprite id bc we need it later
04434C CD 41 4B 04 0104*      call vdu_sprite_select
044350 CD C5 4B 04 0105*      call vdu_sprite_hide
044354 F1          0106*      pop af ; restore sprite id
044355 11 00 00 00 0107*      ld de,0 ; clear deu
044359 57          0108*      ld d,a
04435A 1E 26       0109*      ld e,table_bytes_per_record
04435C ED 5C       0110*      mlt de
04435E DD 21 9F 40 0111*      ld ix,table_base
       04          
044363 DD 19       0112*      add ix,de
044365 AF          0113*      xor a
044366 DD 77 01    0114*      ld (ix+sprite_type),a
044369 DD 21 02 43 0115*      ld ix,table_active_sprites
       04          
04436E DD 35 00    0116*      dec (ix)
044371 C9          0117*      ret
044372             0118*  
044372             0119*  sprites_init:
044372             0120*  ; initialize sprites
044372 CD 75 4C 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
044376 AF          0122*  	xor a
044377             0123*  @sprite_loop:
044377 F5          0124*  	push af
044378 CD 41 4B 04 0125*  	call vdu_sprite_select
04437C 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
044380 CD 96 4C 04 0127*  	call vdu_sprite_add_buff
044384 F1          0128*  	pop af
044385 3C          0129*  	inc a
044386 FE 12       0130*  	cp table_max_records+2 ; tack on sprites for player and laser
044388 20 ED       0131*  	jr nz,@sprite_loop
04438A 3C          0132*  	inc a
04438B CD 75 4B 04 0133*  	call vdu_sprite_activate
04438F             0134*  
04438F             0135*  ; define player sprite
04438F 3A A3 3F 04 0136*  	ld a,(player_id)
044393 CD 41 4B 04 0137*  	call vdu_sprite_select
044397 CD 54 4B 04 0138*  	call vdu_sprite_clear_frames
04439B 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
04439F 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0443A3             0141*  @sprite_player_loop:
0443A3 C5          0142*  	push bc
0443A4 E5          0143*  	push hl
0443A5 CD 96 4C 04 0144*  	call vdu_sprite_add_buff
0443A9 E1          0145*  	pop hl
0443AA 23          0146*  	inc hl
0443AB C1          0147*  	pop bc
0443AC 10 F5       0148*  	djnz @sprite_player_loop
0443AE CD B7 4B 04 0149*  	call vdu_sprite_show
0443B2             0150*  
0443B2             0151*  ; all done
0443B2 C9          0152*      ret
0443B3             0041   	include "tiles.inc"
0443B3             0001*  ; ######### TILES #########
0443B3             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
0443B3             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
0443B3 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
0443B6 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
0443B7             0006*                          ; initialize to zero for a maximum of 256 rows in a level
0443B7 00          0007*  cur_level: db 0
0443B8             0008*  num_levels: equ 2 ; number of levels,duh
0443B8             0009*  
0443B8             0010*  ; lookup table for level definitions
0443B8 9B 2E 04 9C 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       3E 04       
0443BE             0012*  
0443BE             0013*  ; tiles_bufferId: dl 0
0443BE 00 00 00    0014*  tiles_x_plot: dl 0
0443C1 F1 FF FF    0015*  tiles_y_plot: dl -15
0443C4             0016*  
0443C4 FF FF FF    0017*  bg_y_plot: dl -1
0443C7 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
0443CA             0019*  
0443CA             0020*  bg_plot:
0443CA             0021*  ; load current bg tile bufferId as default
0443CA 2A C7 43 04 0022*      ld hl,(bg_bufferId)
0443CE             0023*  ; check whether it is time for a new background tile
0443CE 3A C4 43 04 0024*      ld a,(bg_y_plot)
0443D2 3C          0025*      inc a
0443D3 32 C4 43 04 0026*      ld (bg_y_plot),a
0443D7 C2 EF 43 04 0027*      jp nz,@F ; not time for a new tile so draw current one
0443DB             0028*  ; load the next background tile
0443DB 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
0443DF CD 49 07 04 0030*      call rand_8
0443E3 E6 03       0031*      and %0000011
0443E5 85          0032*      add a,l
0443E6 6F          0033*      ld l,a
0443E7 3E 00       0034*      ld a,0
0443E9 8C          0035*      adc a,h
0443EA 67          0036*      ld h,a
0443EB 22 C7 43 04 0037*      ld (bg_bufferId),hl
0443EF             0038*  @@:
0443EF CD D7 47 04 0039*      call vdu_buff_select
0443F3 01 00 00 00 0040*      ld bc,0
0443F7 ED 5B C4 43 0041*      ld de,(bg_y_plot)
       04          
0443FC 13          0042*      inc de
0443FD CD A0 4A 04 0043*      call vdu_plot_bmp
044401             0044*  ; all done
044401 C9          0045*      ret
044402             0046*  
044402             0047*  xevious_plot:
044402             0048*  ; load current bg tile bufferId as default
044402 2A C7 43 04 0049*      ld hl,(bg_bufferId)
044406             0050*  ; check whether it is time for a new background tile
044406 3A C4 43 04 0051*      ld a,(bg_y_plot)
04440A 3C          0052*      inc a
04440B 32 C4 43 04 0053*      ld (bg_y_plot),a
04440F C2 29 44 04 0054*      jp nz,@F ; not time for a new tile so draw current one
044413             0055*  ; load the next background tile
044413 21 3C 44 04 0056*      ld hl,Xevious_tile
044417 34          0057*      inc (hl)
044418 3E 1F       0058*      ld a,%00011111 ; 31
04441A A6          0059*      and (hl)
04441B 21 5F 01 00 0060*      ld hl,BUF_XEVIOUS_00
04441F 85          0061*      add a,l
044420 6F          0062*      ld l,a
044421 3E 00       0063*      ld a,0
044423 8C          0064*      adc a,h
044424 67          0065*      ld h,a
044425 22 C7 43 04 0066*      ld (bg_bufferId),hl
044429             0067*  @@:
044429 CD D7 47 04 0068*      call vdu_buff_select
04442D 01 00 00 00 0069*      ld bc,0
044431 ED 5B C4 43 0070*      ld de,(bg_y_plot)
       04          
044436 13          0071*      inc de
044437 CD A0 4A 04 0072*      call vdu_plot_bmp
04443B             0073*  ; all done
04443B C9          0074*      ret
04443C 00          0075*  Xevious_tile: db 0
04443D             0076*  
04443D             0077*  tiles_plot:
04443D             0078*  ; set gfx viewport to playing field window
04443D 01 00 00 00 0079*  	ld bc,field_left
044441 11 00 00 00 0080*  	ld de,field_top
044445 DD 21 FF 00 0081*  	ld ix,field_right
       00          
04444A FD 21 7F 01 0082*  	ld iy,field_bottom
       00          
04444F CD 8A 47 04 0083*  	call vdu_set_gfx_viewport
044453             0084*  ; move the background down one pixel
044453 3E 02       0085*  	ld a,2 ; current gfx viewport
044455 2E 02       0086*  	ld l,2 ; direction=down
044457 26 01       0087*  	ld h,1 ; speed=1 px
044459 CD 02 47 04 0088*  	call vdu_scroll_down
04445D             0089*  ; set gfx viewport to one scanline to optimise plotting tiles
04445D 01 00 00 00 0090*  	ld bc,0 ; leftmost x-coord
044461 11 00 00 00 0091*  	ld de,0 ; topmost y-coord
044465 DD 21 FF 00 0092*  	ld ix,255 ; rightmost x-coord
       00          
04446A FD 21 00 00 0093*  	ld iy,0 ; bottommost y-coord
       00          
04446F CD 8A 47 04 0094*  	call vdu_set_gfx_viewport
044473             0095*  ; plot the background
044473             0096*      ; call bg_plot
044473 CD 02 44 04 0097*      call xevious_plot
044477 C9          0098*      ret ; DEBUG
044478             0099*  ; initialize tiles loop
044478 21 00 00 00 0100*      ld hl,0 ; init plotting x-coordinate
04447C 22 BE 43 04 0101*      ld (tiles_x_plot),hl
044480 2A B3 43 04 0102*      ld hl,(tiles_row_defs)
044484 06 10       0103*  	ld b,16 ; loop counter
044486             0104*  @loop:
044486 C5          0105*  	push bc ; save the loop counter
044487             0106*  ; read the tile defintion for the current column
044487 7E          0107*      ld a,(hl) ; a has tile definition
044488 E5          0108*      push hl  ; save pointer to tile definition
044489 21 00 00 00 0109*      ld hl,0 ; hlu is non-zero
04448D 6F          0110*      ld l,a ; l is tile defintion
04448E 26 01       0111*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
044490 CD D7 47 04 0112*      call vdu_buff_select ; tile bitmap buffer is now active
044494             0113*  ; plot the active bitmap
044494 ED 4B BE 43 0114*      ld bc,(tiles_x_plot)
       04          
044499 ED 5B C1 43 0115*      ld de,(tiles_y_plot)
       04          
04449E CD A0 4A 04 0116*      call vdu_plot_bmp
0444A2             0117*  ; bump x-coords the width of one tile and save it
0444A2 2A BE 43 04 0118*      ld hl,(tiles_x_plot)
0444A6 01 10 00 00 0119*      ld bc,16
0444AA 09          0120*      add hl,bc
0444AB 22 BE 43 04 0121*      ld (tiles_x_plot),hl
0444AF             0122*  ; prepare to loop to next column
0444AF E1          0123*      pop hl ; get back pointer to tile def
0444B0 23          0124*      inc hl ; bump it to the next column
0444B1 C1          0125*  	pop bc ; snag our loop counter
0444B2 10 D2       0126*      djnz @loop
0444B4             0127*  ; increment tiles plotting y-coordinate
0444B4             0128*  ; when it hits zero, we go to next row of tiles in the map
0444B4             0129*  ; (we use ix b/c we want to preserve hl for the next step)
0444B4 DD 21 C1 43 0130*  	ld ix,tiles_y_plot
       04          
0444B9 DD 34 00    0131*  	inc (ix)
0444BC C0          0132*  	ret nz
0444BD             0133*  ; time to bump tiles_row_defs to next row
0444BD             0134*  ; (hl was already there at the end of the loop)
0444BD 22 B3 43 04 0135*      ld (tiles_row_defs),hl
0444C1             0136*  ; reset coords to plot next row of tiles
0444C1 21 00 00 00 0137*      ld hl,0
0444C5 22 BE 43 04 0138*      ld (tiles_x_plot),hl
0444C9 21 F1 FF FF 0139*      ld hl,-15
0444CD 22 C1 43 04 0140*      ld (tiles_y_plot),hl
0444D1             0141*  ; decrement tiles row counter
0444D1 21 B6 43 04 0142*      ld hl,tiles_row
0444D5 35          0143*      dec (hl)
0444D6 C0          0144*      ret nz
0444D7             0145*  ; queue up next level
0444D7 3A B7 43 04 0146*      ld a,(cur_level)
0444DB FE 01       0147*      cp num_levels-1
0444DD 20 02       0148*      jr nz,@inc_level
0444DF 3E FF       0149*      ld a,-1 ; will wrap around to zero when we fall through
0444E1             0150*  @inc_level:
0444E1 3C          0151*      inc a
0444E2 32 B7 43 04 0152*      ld (cur_level),a
0444E6             0153*  ; increase the number of enemy sprites
0444E6 3A 85 07 04 0154*      ld a,(max_enemy_sprites)
0444EA 3C          0155*      inc a
0444EB FE 10       0156*      cp table_max_records ; if we're at the global limit,skip ahead at max level
0444ED 28 04       0157*      jr z,init_level
0444EF 32 85 07 04 0158*      ld (max_enemy_sprites),a ; otherwise save the updated number
0444F3             0159*  ; fall through to init_level
0444F3             0160*  
0444F3             0161*  init_level:
0444F3             0162*  ; look up address of level's tile defintion
0444F3 21 B8 43 04 0163*      ld hl,tiles_levels
0444F7 3A B7 43 04 0164*      ld a,(cur_level)
0444FB 11 00 00 00 0165*      ld de,0 ; just in case deu is non-zero
0444FF 57          0166*      ld d,a
044500 1E 03       0167*      ld e,3
044502 ED 5C       0168*      mlt de
044504 19          0169*      add hl,de
044505 ED 37       0170*      ld ix,(hl)
044507 DD 22 B3 43 0171*      ld (tiles_row_defs),ix
       04          
04450C             0172*  ; set tiles_row counter
04450C DD 7E 00    0173*      ld a,(ix)
04450F 32 B6 43 04 0174*      ld (tiles_row),a
044513 DD 23       0175*      inc ix ; now ix points first element of first row tile def
044515 DD 22 B3 43 0176*      ld (tiles_row_defs),ix ; ... so we save it
       04          
04451A C9          0177*      ret
04451B             0178*  
04451B             0179*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
04451B             0180*  ; dt_is_active:
04451B             0181*  ; ; a lands here containing a tile index in the low nibble
04451B             0182*  ; ; we test the values for the tiles which are active
04451B             0183*  ;     cp #07
04451B             0184*  ;     call z,ld_act_landing_pad
04451B             0185*  ;     cp #08
04451B             0186*  ;     call z,ld_act_laser_turret
04451B             0187*  ;     ; fall through
04451B             0188*  ;     ret
04451B             0189*  
04451B             0190*  ; ; some tiles become active sprites,so we load those here
04451B             0191*  ; ; sprite_x/y have already been loaded
04451B             0192*  ; ; sprite_dim_x/y are loaded by table_add_record
04451B             0193*  ; ; we don't want sprite drawn to background like other tiles
04451B             0194*  ; ; so this routine only adds them to the sprite table
04451B             0195*  ; dt_ld_act:
04451B             0196*  ;     ld a,#48 ; top of screen + 1/2 tile height
04451B             0197*  ;     ld (sprite_y+1),a ; just the integer part
04451B             0198*  ;     ld (sprite_base_bufferId),hl
04451B             0199*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04451B             0200*  ;     call table_add_record
04451B             0201*  ;     call sprite_variables_from_stack
04451B             0202*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
04451B             0203*  ;     ret ; and back
04451B             0204*  
04451B             0205*  ; ld_act_landing_pad:
04451B             0206*  ;     call sprite_variables_to_stack
04451B             0207*  
04451B             0208*  ;     ld hl,move_landing_pad
04451B             0209*  ;     ld (sprite_move_program),hl
04451B             0210*  
04451B             0211*  ;     xor a
04451B             0212*  ;     ld (sprite_animation),a ; animation 0
04451B             0213*  
04451B             0214*  ;     call rand_8     ; snag a random number
04451B             0215*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04451B             0216*  ;     add a,64 ; range is now 64-127
04451B             0217*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04451B             0218*  
04451B             0219*  ;     ld a,%10 ; collides with laser but not player
04451B             0220*  ;     ld (iy+sprite_collisions),a
04451B             0221*  
04451B             0222*  ;     ld a,#05 ; BCD
04451B             0223*  ;     ld (sprite_points),a
04451B             0224*  ;     ld a,0 ; binary
04451B             0225*  ;     ld (sprite_shield_damage),a
04451B             0226*  
04451B             0227*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
04451B             0228*  ;     jr dt_ld_act
04451B             0229*  
04451B             0230*  ; ld_act_laser_turret:
04451B             0231*  ;     call sprite_variables_to_stack
04451B             0232*  
04451B             0233*  ;     ld hl,move_laser_turret
04451B             0234*  ;     ld (sprite_move_program),hl
04451B             0235*  
04451B             0236*  ;     xor a
04451B             0237*  ;     ld (sprite_animation),a
04451B             0238*  ;     ld (sprite_move_step),a
04451B             0239*  
04451B             0240*  ;     call rand_8     ; snag a random number
04451B             0241*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04451B             0242*  ;     add a,64 ; range is now 64-127
04451B             0243*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04451B             0244*  
04451B             0245*  ;     ld a,%10 ; collides with laser but not player
04451B             0246*  ;     ld (iy+sprite_collisions),a
04451B             0247*  
04451B             0248*  ;     ld a,#10 ; BCD
04451B             0249*  ;     ld (sprite_points),a
04451B             0250*  ;     ld a,0 ; binary
04451B             0251*  ;     ld (sprite_shield_damage),a
04451B             0252*  
04451B             0253*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
04451B             0254*  ;     jp dt_ld_act
04451B             0255*  
04451B             0256*  
04451B             0257*  ; moves active tile sprites down one pixel in sync with tiles movement
04451B             0258*  ; deletes sprites from table when they wrap around to top of screen
04451B             0259*  move_active_tiles:
04451B             0260*  ; get current position
04451B 3A 0F 00 00 0261*      ld a,(sprite_y+1) ; we only need the integer part
04451F 3C          0262*      inc a
044520             0263*  ; are we at the bottom of the screen?
044520 20 06       0264*      jr nz,move_active_tiles_draw_sprite ; nope
044522             0265*  ; otherwise kill sprite
044522 3E 80       0266*      ld a,%10000000 ; any bit set in high nibble means sprite will die
044524 FD 77 08    0267*      ld (iy+sprite_collisions),a
044527 C9          0268*      ret ; debug
044528             0269*  move_active_tiles_draw_sprite:
044528 32 0F 00 00 0270*      ld (sprite_y+1),a ; update tile y position integer part
04452C             0271*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04452C             0272*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
04452C C9          0273*      ret ; and done
04452D             0042   	include "timer.inc"
04452D             0001*  ; Table 32. Timer Control Registers
04452D             0002*  ; this constant is the base address of the timer control registers
04452D             0003*  ; each timer takes three bytes:
04452D             0004*  ;   0: control register
04452D             0005*  ;   1: low byte of timer reset value
04452D             0006*  ;   2: high byte of timer reset value
04452D             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
04452D             0008*  ; which correctly force the high and upper bytes of the address bus to zero
04452D             0009*  TMR_CTL:     equ 80h
04452D             0010*  
04452D             0011*  ; Timer Control Register Bit Definitions
04452D             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
04452D             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
04452D             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
04452D             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
04452D             0016*                              ; the TMRx_CTL register is read.
04452D             0017*  
04452D             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
04452D             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
04452D             0020*  
04452D             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
04452D             0022*                              ;  0,and counting stops when the end-of-count value is reached.
04452D             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
04452D             0024*                              ; written to the counter when the end-of-count value is reached.
04452D             0025*  
04452D             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
04452D             0027*  CLK_DIV_256:  equ %00001100 ;
04452D             0028*  CLK_DIV_64:   equ %00001000 ;
04452D             0029*  CLK_DIV_16:   equ %00000100 ;
04452D             0030*  CLK_DIV_4:    equ %00000000 ;
04452D             0031*  
04452D             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
04452D             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
04452D             0034*                              ; When a 1 is written to this bit,the values in the reload registers
04452D             0035*                              ;  are loaded into the downcounter when the timer restarts. The
04452D             0036*                              ; programmer must ensure that this bit is set to 1 each time
04452D             0037*                              ; SINGLE-PASS mode is used.
04452D             0038*  
04452D             0039*  ; disable/enable the programmable reload timer
04452D             0040*  PRT_EN_0:     equ %00000000 ;
04452D             0041*  PRT_EN_1:     equ %00000001 ;
04452D             0042*  
04452D             0043*  ; Table 37. Timer Input Source Select Register
04452D             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
04452D             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
04452D             0046*  ;   00: System clock / CLK_DIV
04452D             0047*  ;   01: RTC / CLK_DIV
04452D             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
04452D             0049*  ;   10: GPIO port B pin 1.
04452D             0050*  ;   11: GPIO port B pin 1.
04452D             0051*  TMR_ISS:   equ 92h ; register address
04452D             0052*  
04452D             0053*  ; Table 51. Real-Time Clock Control Register
04452D             0054*  RTC_CTRL: equ EDh ; register address
04452D             0055*  
04452D             0056*  ; alarm interrupt disable/enable
04452D             0057*  RTC_ALARM_0:    equ %00000000
04452D             0058*  RTC_ALARM_1:    equ %10000000
04452D             0059*  
04452D             0060*  ; interrupt on alarm disable/enable
04452D             0061*  RTC_INT_ENT_0:  equ %00000000
04452D             0062*  RTC_INT_ENT_1:  equ %01000000
04452D             0063*  
04452D             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
04452D             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
04452D             0066*  
04452D             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
04452D             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
04452D             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
04452D             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
04452D             0071*  
04452D             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
04452D             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
04452D             0074*  
04452D             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
04452D             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
04452D             0077*  
04452D             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
04452D             0079*                                  ; RTC counter is enabled.
04452D             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
04452D             0081*                                  ; RTC counter is disabled.
04452D             0082*  
04452D             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
04452D             0084*  
04452D             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
04452D             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
04452D 00 00 00    0087*  prt_reload: dl 0x000000
044530             0088*  
044530             0089*  ; set PRT timer
044530             0090*  prt_set:
044530 21 00 00 00 0091*      ld hl,0
044534 22 7E 45 04 0092*      ld (prt_irq_counter),hl
044538 2A 2D 45 04 0093*      ld hl,(prt_reload)
04453C ED 29 84    0094*      out0 ($84),l
04453F ED 21 85    0095*  	out0 ($85),h
044542             0096*  ; disable timer
044542 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
044544 ED 39 83    0098*  	out0 ($83),a
044547             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
044547 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
044549 ED 39 83    0101*  	out0 ($83),a
04454C C9          0102*      ret
04454D             0103*  
04454D             0104*  ; ===============================================
04454D             0105*  ; PRT Timer Interrupt Handling
04454D             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
04454D             0107*  ; -----------------------------------------------
04454D             0108*  prt_irq_init:
04454D             0109*      ; set up interrupt vector table 2
04454D 21 00 00 00 0110*  	ld hl,0
044551 3A 0C 01 00 0111*  	ld a,($10c)
044555 6F          0112*  	ld l,a
044556 3A 0D 01 00 0113*  	ld a,($10d)
04455A 67          0114*  	ld h,a
04455B             0115*  
04455B             0116*  	; skip over CALL ($c3)
04455B 23          0117*  	inc hl
04455C             0118*  	; load address of jump into vector table 2 (in ram)
04455C ED 27       0119*  	ld hl,(hl)
04455E             0120*  
04455E             0121*  	; write CALL prt_irq_handler to vector table 2
04455E 3E C3       0122*  	ld a,$c3
044560 77          0123*  	ld (hl),a
044561 23          0124*  	inc hl
044562 11 69 45 04 0125*  	ld de,prt_irq_handler
044566 ED 1F       0126*  	ld (hl),de
044568             0127*  
044568 C9          0128*      ret
044569             0129*  
044569             0130*  prt_irq_handler:
044569 F3          0131*  	di
04456A F5          0132*  	push af
04456B E5          0133*      push hl
04456C ED 38 83    0134*  	in0 a,($83)
04456F 2A 7E 45 04 0135*  	ld hl,(prt_irq_counter)
044573 23          0136*  	inc hl
044574 22 7E 45 04 0137*  	ld (prt_irq_counter),hl
044578 E1          0138*      pop hl
044579 F1          0139*  	pop af
04457A FB          0140*  	ei
04457B 5B ED 4D    0141*  	reti.l
04457E             0142*  
04457E             0143*  prt_irq_counter:
04457E 00 00 00    0144*  	.dl 0
044581             0145*  prt_irq_counter_saved:
044581 00 00 00    0146*      .dl 0
044584             0147*  
044584             0148*  prt_loop_reset:
044584 E5          0149*      push hl
044585 21 00 00 00 0150*  	ld hl,0
044589 22 7E 45 04 0151*  	ld (prt_irq_counter),hl
04458D 22 EF 45 04 0152*      ld (prt_loop_counter),hl
044591 22 F2 45 04 0153*      ld (prt_loops),hl
044595 CD 30 45 04 0154*      call prt_set
044599 E1          0155*      pop hl
04459A C9          0156*      ret
04459B             0157*  
04459B             0158*  prt_loop_start:
04459B E5          0159*      push hl
04459C 21 00 00 00 0160*  	ld hl,0
0445A0 22 7E 45 04 0161*  	ld (prt_irq_counter),hl
0445A4 E1          0162*      pop hl
0445A5 C9          0163*      ret
0445A6             0164*  
0445A6             0165*  prt_loop_stop:
0445A6 E5          0166*      push hl
0445A7 D5          0167*      push de
0445A8 2A 7E 45 04 0168*      ld hl,(prt_irq_counter)
0445AC ED 5B EF 45 0169*      ld de,(prt_loop_counter)
       04          
0445B1 19          0170*      add hl,de
0445B2 22 EF 45 04 0171*      ld (prt_loop_counter),hl
0445B6 21 00 00 00 0172*      ld hl,0
0445BA 22 7E 45 04 0173*      ld (prt_irq_counter),hl
0445BE 2A F2 45 04 0174*      ld hl,(prt_loops)
0445C2 23          0175*      inc hl
0445C3 22 F2 45 04 0176*      ld (prt_loops),hl
0445C7 D1          0177*      pop de
0445C8 E1          0178*      pop hl
0445C9 C9          0179*      ret
0445CA             0180*  
0445CA             0181*  ; inputs: bc = y,x text coordinates to print
0445CA             0182*  prt_loop_print:
0445CA F5          0183*      push af
0445CB E5          0184*      push hl
0445CC C5          0185*      push bc
0445CD D5          0186*      push de
0445CE DD E5       0187*      push ix
0445D0 FD E5       0188*      push iy
0445D2 CD D6 46 04 0189*      call vdu_move_cursor
0445D6             0190*  
0445D6 2A EF 45 04 0191*      ld hl,(prt_loop_counter)
0445DA CD 76 01 04 0192*      call printDec
0445DE             0193*  
0445DE 2A F2 45 04 0194*      ld hl,(prt_loops)
0445E2 CD 76 01 04 0195*      call printDec
0445E6             0196*  
0445E6 FD E1       0197*      pop iy
0445E8 DD E1       0198*      pop ix
0445EA D1          0199*      pop de
0445EB C1          0200*      pop bc
0445EC E1          0201*      pop hl
0445ED F1          0202*      pop af
0445EE C9          0203*      ret
0445EF             0204*  
0445EF             0205*  prt_loop_counter:
0445EF 00 00 00    0206*      .dl 0
0445F2             0207*  prt_loops:
0445F2 00 00 00    0208*      .dl 0
0445F5             0209*  
0445F5             0210*  ; ===============================================
0445F5             0211*  ; Timer functions
0445F5             0212*  ; -----------------------------------------------
0445F5             0213*  ; set a countdown timer
0445F5             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0445F5             0215*  ; returns: hl = current time
0445F5             0216*  tmr_set:
0445F5 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0445F8             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0445F8 3E 08       0001*M 			LD	A, function
0445FA 5B CF       0002*M 			RST.LIL	08h
0445FC DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0445FF FD 2F 00    0220*      ld (iy+0),hl            ; set start time
044602 C9          0221*      ret
044603             0222*  
044603             0223*  ; gets time remaining on a countdown timer
044603             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
044603             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
044603             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
044603             0227*  tmr_get:
044603             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
044603 3E 08       0001*M 			LD	A, function
044605 5B CF       0002*M 			RST.LIL	08h
044607 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
04460A FD 27 00    0230*      ld hl,(iy+0)            ; get start time
04460D AF          0231*      xor a                   ; clear carry
04460E ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
044610 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
044613 AF          0234*      xor a                   ; clear carry
044614 ED 5A       0235*      adc hl,de               ; hl = time remaining
044616             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
044616 C9          0237*      ret
044617             0238*  
044617             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
04461D             0240*  
04461D 00 00 00    0241*  timestamp_now: dl 0
044620 00 00 00    0242*  timestamp_old: dl 0
044623 00 00 00    0243*  timestamp_chg: dl 0
044626             0244*  
044626             0245*  ; update the global timestamp from the system clock
044626             0246*  ; inputs: none
044626             0247*  ; returns: hl = time elapsed in 1/120ths of a second
044626             0248*  ;          de = current time
044626             0249*  ;          ix = pointer to syvars table
044626             0250*  ; destroys: af,hl,de,ix
044626             0251*  timestamp_tick:
044626 ED 5B 1D 46 0252*      ld de,(timestamp_now)   ; get previous time
       04          
04462B ED 53 20 46 0253*      ld (timestamp_old),de   ; save previous time
       04          
044630             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
044630 3E 08       0001*M 			LD	A, function
044632 5B CF       0002*M 			RST.LIL	08h
044634 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
044637 22 1D 46 04 0256*      ld (timestamp_now),hl   ; save current time
04463B AF          0257*      xor a                   ; clear carry
04463C ED 52       0258*      sbc hl,de               ; hl = time elapsed
04463E 22 23 46 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
044642 C9          0260*      ret
044643             0261*  
044643             0262*  ; set a countdown timer
044643             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
044643             0264*  ; requires: timestamp_tick to be called at least once before this function
044643             0265*  ; returns: hl = current time
044643             0266*  ; destroys: hl
044643             0267*  timestamp_tmr_set:
044643 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
044646 2A 1D 46 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
04464A FD 2F 00    0270*      ld (iy+0),hl            ; set start time
04464D C9          0271*      ret
04464E             0272*  
04464E             0273*  ; gets time remaining on a countdown timer following the global timestamp
04464E             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04464E             0275*  ; requires: timestamp_tick to be called at least once before this function
04464E             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04464E             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
04464E             0278*  ; destroys: af,hl,de
04464E             0279*  timestamp_tmr_get:
04464E ED 5B 1D 46 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
044653 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
044656 AF          0282*      xor a                   ; clear carry
044657 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
044659 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
04465C AF          0285*      xor a                   ; clear carry
04465D ED 5A       0286*      adc hl,de               ; hl = time remaining
04465F             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04465F C9          0288*      ret
044660             0289*  
044660             0290*  ; set a stopwatch
044660             0291*  ; returns: hl = start time
044660             0292*  ; destroys: hl,ix
044660             0293*  stopwatch_set:
044660             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
044660 3E 08       0001*M 			LD	A, function
044662 5B CF       0002*M 			RST.LIL	08h
044664 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
044667 22 7C 46 04 0296*      ld (stopwatch_started),hl            ; set start time
04466B C9          0297*      ret
04466C             0298*  
04466C             0299*  ; gets time elapsed on a stopwatch
04466C             0300*  ; returns: hl = time elapsed in 1/120ths of a second
04466C             0301*  ; destroys: af,hl,de,ix
04466C             0302*  stopwatch_get:
04466C             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
04466C 3E 08       0001*M 			LD	A, function
04466E 5B CF       0002*M 			RST.LIL	08h
044670 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
044673 ED 5B 7C 46 0305*      ld de,(stopwatch_started)            ; get start time
       04          
044678 AF          0306*      xor a                   ; clear carry
044679 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04467B C9          0308*      ret
04467C             0309*  
04467C             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04467F             0311*  
04467F             0312*  ; ------------------
04467F             0313*  ; delay routine
04467F             0314*  ; Author: Richard Turrnidge
04467F             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04467F             0316*  ; routine waits a fixed time,then returns
04467F             0317*  ; arrive with A =  the delay byte. One bit to be set only.
04467F             0318*  ; eg. ld A,00000100b
04467F             0319*  
04467F             0320*  multiPurposeDelay:
04467F F5          0321*      push af
044680 C5          0322*      push bc
044681 DD E5       0323*      push ix
044683 47          0324*      ld b,a
044684 3E 08       0325*      ld a,$08
044686 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
044688             0327*  
044688             0328*  waitLoop:
044688             0329*  
044688 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04468B             0331*  
04468B             0332*                                  ;   we check if bit set is same as last time we checked.
04468B             0333*                                  ;   bit 0 - don't use
04468B             0334*                                  ;   bit 1 - changes 64 times per second
04468B             0335*                                  ;   bit 2 - changes 32 times per second
04468B             0336*                                  ;   bit 3 - changes 16 times per second
04468B             0337*  
04468B             0338*                                  ;   bit 4 - changes 8 times per second
04468B             0339*                                  ;   bit 5 - changes 4 times per second
04468B             0340*                                  ;   bit 6 - changes 2 times per second
04468B             0341*                                  ;   bit 7 - changes 1 times per second
04468B A0          0342*      and b
04468C 4F          0343*      ld c,a
04468D 3A 9E 46 04 0344*      ld a,(oldTimeStamp)
044691 B9          0345*      cp c                        ; is A same as last value?
044692 28 F4       0346*      jr z,waitLoop              ; loop here if it is
044694 79          0347*      ld a,c
044695 32 9E 46 04 0348*      ld (oldTimeStamp),a        ; set new value
044699             0349*  
044699 DD E1       0350*      pop ix
04469B C1          0351*      pop bc
04469C F1          0352*      pop af
04469D C9          0353*      ret
04469E             0354*  
04469E 00          0355*  oldTimeStamp:   .db 00h
04469F             0043   	include "vdu.inc"
04469F             0001*  
04469F             0002*  ; VDU 30: Home cursor
04469F             0003*  vdu_home_cursor:
04469F 3E 1E       0004*      ld a,30
0446A1 5B D7       0005*  	rst.lil $10
0446A3 C9          0006*  	ret
0446A4             0007*  
0446A4             0008*  vdu_cursor_on:
0446A4 21 AF 46 04 0009*  	ld hl,@cmd
0446A8 01 03 00 00 0010*  	ld bc,@end-@cmd
0446AC 5B DF       0011*  	rst.lil $18
0446AE C9          0012*  	ret
0446AF             0013*  @cmd:
0446AF 17 01 01    0014*  	db 23,1,1
0446B2             0015*  @end:
0446B2             0016*  
0446B2             0017*  vdu_cursor_off:
0446B2 21 BD 46 04 0018*  	ld hl,@cmd
0446B6 01 03 00 00 0019*  	ld bc,@end-@cmd
0446BA 5B DF       0020*  	rst.lil $18
0446BC C9          0021*  	ret
0446BD             0022*  @cmd:
0446BD 17 01 00    0023*  	db 23,1,0
0446C0             0024*  @end:
0446C0             0025*  
0446C0             0026*  ; VDU 5: Write text at graphics cursor
0446C0             0027*  ; inputs: a is the character to write to the screen
0446C0             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0446C0             0029*  ; outputs: see the name of the function
0446C0             0030*  ; destroys: a, hl, bc
0446C0             0031*  vdu_char_to_gfx_cursor:
0446C0 32 D0 46 04 0032*  	ld (@arg),a
0446C4 21 CF 46 04 0033*  	ld hl,@cmd
0446C8 01 02 00 00 0034*  	ld bc,@end-@cmd
0446CC 5B DF       0035*  	rst.lil $18
0446CE C9          0036*  	ret
0446CF 05          0037*  @cmd: db 5
0446D0 00          0038*  @arg: db 0
0446D1             0039*  @end:
0446D1             0040*  ; VDU 9: Move cursor forward one character
0446D1             0041*  vdu_cursor_forward:
0446D1 3E 09       0042*      ld a,9
0446D3 5B D7       0043*  	rst.lil $10
0446D5 C9          0044*  	ret
0446D6             0045*  
0446D6             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0446D6             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0446D6             0048*  vdu_move_cursor:
0446D6 ED 43 E7 46 0049*      ld (@x0),bc
       04          
0446DB 21 E6 46 04 0050*  	ld hl,@cmd
0446DF 01 03 00 00 0051*  	ld bc,@end-@cmd
0446E3 5B DF       0052*  	rst.lil $18
0446E5 C9          0053*  	ret
0446E6 1F          0054*  @cmd: 	db 31
0446E7 00          0055*  @x0:	db 0
0446E8 00          0056*  @y0: 	db 0
0446E9 00          0057*  @end: 	db 0 ; padding
0446EA             0058*  
0446EA             0059*  ; VDU 12: Clear text area (CLS)
0446EA             0060*  vdu_cls:
0446EA 3E 0C       0061*      ld a,12
0446EC 5B D7       0062*  	rst.lil $10
0446EE C9          0063*  	ret
0446EF             0064*  
0446EF             0065*  vdu_flip:
0446EF 21 FA 46 04 0066*  	ld hl,@cmd
0446F3 01 03 00 00 0067*  	ld bc,@end-@cmd
0446F7 5B DF       0068*  	rst.lil $18
0446F9 C9          0069*  	ret
0446FA 17 00 C3    0070*  @cmd: db 23,0,0xC3
0446FD             0071*  @end:
0446FD             0072*  
0446FD             0073*  ; VDU 16: Clear graphics area (CLG)
0446FD             0074*  vdu_clg:
0446FD 3E 10       0075*      ld a,16
0446FF 5B D7       0076*  	rst.lil $10
044701 C9          0077*  	ret
044702             0078*  
044702             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
044702             0080*  ; VDU 23, 7: Scrolling
044702             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
044702             0082*  ; inputs: a, extent; l, direction; h; speed
044702             0083*  vdu_scroll_down:
044702 32 17 47 04 0084*  	ld (@extent),a
044706 22 18 47 04 0085*  	ld (@dir),hl ; implicitly populates @speed
04470A 21 15 47 04 0086*  	ld hl,@cmd
04470E 01 05 00 00 0087*  	ld bc,@end-@cmd
044712 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
044714 C9          0089*  	ret
044715 17 07       0090*  @cmd:       db 23,7
044717 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
044718 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
044719 00          0093*  @speed:     db 0x00 ; pixels
04471A 00          0094*  @end:		db 0x00 ; padding
04471B             0095*  
04471B             0096*  ; COLOUR MODES
04471B             0097*  ; Mode	Effect
04471B             0098*  ; 0	Set on-screen pixel to target colour value
04471B             0099*  ; 1	OR value with the on-screen pixel
04471B             0100*  ; 2	AND value with the on-screen pixel
04471B             0101*  ; 3	XOR value with the on-screen pixel
04471B             0102*  ; 4	Invert the on-screen pixel
04471B             0103*  ; 5	No operation
04471B             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
04471B             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
04471B             0106*  
04471B             0107*  ; VDU 17, colour: Define text colour (COLOUR)
04471B             0108*  vdu_colour_text:
04471B 32 2B 47 04 0109*  	ld (@arg),a
04471F 21 2A 47 04 0110*  	ld hl,@cmd
044723 01 02 00 00 0111*  	ld bc,@end-@cmd
044727 5B DF       0112*  	rst.lil $18
044729 C9          0113*  	ret
04472A 11          0114*  @cmd: db 17
04472B 00          0115*  @arg: db 0
04472C             0116*  @end:
04472C             0117*  
04472C             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04472C             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04472C             0120*  vdu_gcol:
04472C 32 41 47 04 0121*  	ld (@mode),a
044730 79          0122*      ld a,c
044731 32 42 47 04 0123*      ld (@col),a
044735 21 40 47 04 0124*  	ld hl,@cmd
044739 01 03 00 00 0125*  	ld bc,@end-@cmd
04473D 5B DF       0126*  	rst.lil $18
04473F C9          0127*  	ret
044740 12          0128*  @cmd:  db 18
044741 00          0129*  @mode: db 0
044742 00          0130*  @col:  db 0
044743             0131*  @end:
044743             0132*  
044743             0133*  
044743             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
044743             0135*  ; MIND THE LITTLE-ENDIANESS
044743             0136*  ; inputs: c=left,b=bottom,e=right,d=top
044743             0137*  ; outputs; nothing
044743             0138*  ; destroys: a might make it out alive
044743             0139*  vdu_set_txt_viewport:
044743 ED 43 59 47 0140*      ld (@lb),bc
       04          
044748 ED 53 5B 47 0141*  	ld (@rt),de
       04          
04474D 21 58 47 04 0142*  	ld hl,@cmd
044751 01 05 00 00 0143*  	ld bc,@end-@cmd
044755 5B DF       0144*  	rst.lil $18
044757 C9          0145*  	ret
044758 1C          0146*  @cmd:   db 28 ; set text viewport command
044759 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
04475B 00 00       0148*  @rt: 	dw 0x0000 ; set by de
04475D 00          0149*  @end:   db 0x00	  ; padding
04475E             0150*  
04475E             0151*  ; Wait for VBLANK interrupt
04475E             0152*  vdu_vblank:
04475E DD E5       0153*      PUSH 	IX
044760             0154*  	MOSCALL	mos_sysvars
044760 3E 08       0001*M 			LD	A, function
044762 5B CF       0002*M 			RST.LIL	08h
044764 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
044767             0156*  @wait:
044767 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
04476A 28 FB       0158*      JR	Z, @wait
04476C DD E1       0159*      POP	IX
04476E C9          0160*      RET
04476F             0161*  
04476F             0162*  ; VDU 29, x; y;: Set graphics origin
04476F             0163*  ; This command sets the graphics origin.
04476F             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04476F             0165*  ; inputs: bc=x0,de=y0
04476F             0166*  ; outputs; nothing
04476F             0167*  ; destroys: a might make it out alive
04476F             0168*  vdu_set_gfx_origin:
04476F ED 43 85 47 0169*      ld (@x0),bc
       04          
044774 ED 53 87 47 0170*      ld (@y0),de
       04          
044779 21 84 47 04 0171*      ld hl,@cmd
04477D 01 05 00 00 0172*      ld bc,@end-@cmd
044781 5B DF       0173*      rst.lil $18
044783 C9          0174*      ret
044784 1D          0175*  @cmd:   db 29 ; set graphics origin command
044785 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
044787 00 00       0177*  @y0: 	dw 0x0000 ; set by de
044789 00          0178*  @end:   db 0x00	  ; padding
04478A             0179*  
04478A             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04478A             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04478A             0182*  ; 	because we have turned off logical screen scaling
04478A             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04478A             0184*  ; outputs; nothing
04478A             0185*  ; destroys: a might make it out alive
04478A             0186*  vdu_set_gfx_viewport:
04478A ED 43 AA 47 0187*      ld (@x0),bc
       04          
04478F FD 22 AC 47 0188*      ld (@y1),iy
       04          
044794 DD 22 AE 47 0189*  	ld (@x1),ix
       04          
044799 ED 53 B0 47 0190*  	ld (@y0),de
       04          
04479E 21 A9 47 04 0191*  	ld hl,@cmd
0447A2 01 09 00 00 0192*  	ld bc,@end-@cmd
0447A6 5B DF       0193*  	rst.lil $18
0447A8 C9          0194*  	ret
0447A9 18          0195*  @cmd:   db 24 ; set graphics viewport command
0447AA 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
0447AC 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
0447AE 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
0447B0 00 00       0199*  @y0: 	dw 0x0000 ; set by de
0447B2 00          0200*  @end:   db 0x00	  ; padding
0447B3             0201*  
0447B3             0202*  ; SCREEN MODES
0447B3             0203*  ; ===============================
0447B3             0204*  ; Mode  Horz  Vert  Cols  Refresh
0447B3             0205*  ; ---   ----  ----  ----  -------
0447B3             0206*  ; 11    320   240   2     60hz
0447B3             0207*  ; 139   320   240   2     60hz
0447B3             0208*  ; 23    512   384   2     60hz
0447B3             0209*  ; 151   512   384   2     60hz
0447B3             0210*  ; 6     640   240   2     60hz
0447B3             0211*  ; 134   640   240   2     60hz
0447B3             0212*  ; 2     640   480   2     60hz
0447B3             0213*  ; 130   640   480   2     60hz
0447B3             0214*  ; 17    800   600   2     60hz
0447B3             0215*  ; 145   800   600   2     60hz
0447B3             0216*  ; 18    1024  768   2     60hz
0447B3             0217*  ; 146   1024  768   2     60hz
0447B3             0218*  ; ---   ----  ----  ----  -------
0447B3             0219*  ; 10    320   240   4     60hz
0447B3             0220*  ; 138   320   240   4     60hz
0447B3             0221*  ; 22    512   384   4     60hz
0447B3             0222*  ; 150   512   384   4     60hz
0447B3             0223*  ; 5     640   240   4     60hz
0447B3             0224*  ; 133   640   240   4     60hz
0447B3             0225*  ; 1     640   480   4     60hz
0447B3             0226*  ; 129   640   480   4     60hz
0447B3             0227*  ; 16    800   600   4     60hz
0447B3             0228*  ; 19    1024  768   4     60hz
0447B3             0229*  ; ---   ----  ----  ----  -------
0447B3             0230*  ; 9     320   240   16    60hz
0447B3             0231*  ; 137   320   240   16    60hz
0447B3             0232*  ; 21    512   384   16    60hz
0447B3             0233*  ; 149   512   384   16    60hz
0447B3             0234*  ; 4     640   240   16    60hz
0447B3             0235*  ; 132   640   240   16    60hz
0447B3             0236*  ; 0     640   480   16    60hz
0447B3             0237*  ; 7     n/a   n/a   16    60hz
0447B3             0238*  ; ---   ----  ----  ----  -------
0447B3             0239*  ; 8     320   240   64    60hz
0447B3             0240*  ; 136   320   240   64    60hz
0447B3             0241*  ; 20    512   384   64    60hz
0447B3             0242*  ; 3     640   240   64    60hz
0447B3             0243*  ; ---   ----  ----  ----  -------
0447B3             0244*  vdu_set_screen_mode:
0447B3 32 C3 47 04 0245*  	ld (@arg),a
0447B7 21 C2 47 04 0246*  	ld hl,@cmd
0447BB 01 02 00 00 0247*  	ld bc,@end-@cmd
0447BF 5B DF       0248*  	rst.lil $18
0447C1 C9          0249*  	ret
0447C2 16          0250*  @cmd: db 22 ; set screen mode
0447C3 00          0251*  @arg: db 0  ; screen mode parameter
0447C4             0252*  @end:
0447C4             0253*  
0447C4             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0447C4             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0447C4             0256*  ; note: default setting on boot is scaling ON
0447C4             0257*  vdu_set_scaling:
0447C4 32 D6 47 04 0258*  	ld (@arg),a
0447C8 21 D3 47 04 0259*  	ld hl,@cmd
0447CC 01 04 00 00 0260*  	ld bc,@end-@cmd
0447D0 5B DF       0261*  	rst.lil $18
0447D2 C9          0262*  	ret
0447D3 17 00 C0    0263*  @cmd: db 23,0,0xC0
0447D6 00          0264*  @arg: db 0  ; scaling on/off
0447D7             0265*  @end:
0447D7             0266*  
0447D7             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0447D7             0268*  ; inputs: hl=bufferId
0447D7             0269*  vdu_buff_select:
0447D7 22 E9 47 04 0270*  	ld (@bufferId),hl
0447DB 21 E6 47 04 0271*  	ld hl,@cmd
0447DF 01 05 00 00 0272*  	ld bc,@end-@cmd
0447E3 5B DF       0273*  	rst.lil $18
0447E5 C9          0274*  	ret
0447E6 17 1B 20    0275*  @cmd: db 23,27,0x20
0447E9 00 00       0276*  @bufferId: dw 0x0000
0447EB 00          0277*  @end: db 0x00 ; padding
0447EC             0278*  
0447EC             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0447EC             0280*  ; inputs: a=format; bc=width; de=height
0447EC             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0447EC             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0447EC             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0447EC             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0447EC             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0447EC             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
0447EC             0287*  vdu_bmp_create:
0447EC ED 43 08 48 0288*      ld (@width),bc
       04          
0447F1 ED 53 0A 48 0289*      ld (@height),de
       04          
0447F6 32 0C 48 04 0290*      ld (@fmt),a
0447FA 21 05 48 04 0291*  	ld hl,@cmd
0447FE 01 08 00 00 0292*  	ld bc,@end-@cmd
044802 5B DF       0293*  	rst.lil $18
044804 C9          0294*  	ret
044805 17 1B 21    0295*  @cmd:       db 23,27,0x21
044808 00 00       0296*  @width:     dw 0x0000
04480A 00 00       0297*  @height:    dw 0x0000
04480C 00          0298*  @fmt:       db 0x00
04480D             0299*  @end:
04480D             0300*  
04480D             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04480D             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04480D             0303*  vdu_load_img_rgba2_to_8:
04480D             0304*  ; backup the target buffer id and image dimensions
04480D E5          0305*      push hl
04480E D5          0306*      push de
04480F C5          0307*      push bc
044810             0308*  ; load the rgba2 image to working buffer 65534
044810 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
044814 CD 17 49 04 0310*  	call vdu_load_buffer_from_file
044818             0311*  ; restore the image dimensions and target buffer id
044818 C1          0312*      pop bc
044819 D1          0313*      pop de
04481A E1          0314*      pop hl
04481B             0315*  ; fall through to vdu_rgba2_to_8
04481B             0316*  
04481B             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04481B             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04481B             0319*  ; the "expand bitmap" command is:
04481B             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04481B             0321*  ; and then to reverse the byte order to fix endian-ness:
04481B             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04481B             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04481B             0324*  ; VDU 23,27,&20,targetBufferID%;
04481B             0325*  ; VDU 23,27,&21,width%;height%;0
04481B             0326*  ; -------------------------------------------------------------------
04481B             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
04481B             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04481B             0329*  vdu_rgba2_to_8:
04481B             0330*  ; load the image dimensions and buffer id parameters
04481B ED 43 77 48 0331*      ld (@width),bc
       04          
044820 ED 53 79 48 0332*      ld (@height),de
       04          
044825 22 5C 48 04 0333*      ld (@bufferId0),hl
044829 22 69 48 04 0334*      ld (@bufferId2),hl
04482D 22 72 48 04 0335*      ld (@bufferId1),hl
044831             0336*  ; clean up bytes that got stomped on by the ID loads
044831 3E 48       0337*      ld a,0x48
044833 32 5E 48 04 0338*      ld (@bufferId0+2),a
044837 3E 17       0339*      ld a,23
044839 32 74 48 04 0340*      ld (@bufferId1+2),a
04483D 3E 18       0341*      ld a,24
04483F 32 6B 48 04 0342*      ld (@bufferId2+2),a
044843 AF          0343*      xor a
044844 32 7B 48 04 0344*      ld (@height+2),a
044848             0345*  ; send the vdu command strings
044848 21 53 48 04 0346*      ld hl,@beg
04484C 01 29 00 00 0347*      ld bc,@end-@beg
044850 5B DF       0348*      rst.lil $18
044852 C9          0349*      ret
044853             0350*  @beg:
044853             0351*  ; Command 14: Consolidate blocks in a buffer
044853             0352*  ; VDU 23, 0, &A0, bufferId; 14
044853 17 00 A0    0353*      db 23,0,0xA0
044856 FE FF       0354*      dw 65534 ; workingBufferId
044858 0E          0355*      db 14 ; consolidate blocks
044859             0356*  ; the "expand bitmap" command is:
044859             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
044859 17 00 A0    0358*      db 23,0,0xA0
04485C 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04485E 48          0360*      db 0x48 ; given as decimal command 72 in the docs
04485F 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
044860 FE FF       0362*      dw 65534 ; sourceBufferId
044862 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
044866             0364*  ; reverse the byte order to fix endian-ness:
044866             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
044866             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
044866             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
044866 17 00 A0    0368*      db 23,0,0xA0
044869 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04486B 18          0370*      db 24 ; reverse byte order
04486C 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04486D 04 00       0372*      dw 4 ; size (4 bytes)
04486F             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04486F             0374*  ; VDU 23,27,&20,targetBufferID%;
04486F 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
044872 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
044874             0377*  ; VDU 23,27,&21,width%;height%;0
044874 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
044877 00 00       0379*  @width: dw 0x0000
044879 00 00       0380*  @height: dw 0x0000
04487B 00          0381*      db 0x00 ; rgba8888 format
04487C             0382*  @end:
04487C             0383*  
04487C             0384*  ; scratch variables
04487C 00 00 00    0385*  bufferId0: dl 0x000000
04487F 00 00 00    0386*  bufferId1: dl 0x000000
044882             0387*  
044882             0388*  ; load a vdu buffer from local memory
044882             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044882             0390*  vdu_load_buffer:
044882 ED 43 AB 48 0391*      ld (@length),bc
       04          
044887 D5          0392*      push de ; save data pointer
044888             0393*  ; send the vdu command string
044888 7D          0394*      ld a,l
044889 32 A8 48 04 0395*      ld (@bufferId),a
04488D 7C          0396*      ld a,h
04488E 32 A9 48 04 0397*      ld (@bufferId+1),a
044892 21 A5 48 04 0398*      ld hl,@cmd
044896 01 08 00 00 0399*      ld bc,@end-@cmd
04489A 5B DF       0400*      rst.lil $18
04489C             0401*  ; send the buffer data
04489C E1          0402*      pop hl ; pointer to data
04489D ED 4B AB 48 0403*      ld bc,(@length)
       04          
0448A2 5B DF       0404*      rst.lil $18 ; send it
0448A4 C9          0405*      ret
0448A5             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0448A5 17 00 A0    0407*  @cmd:       db 23,0,0xA0
0448A8 00 00       0408*  @bufferId:	dw 0x0000
0448AA 00          0409*  		    db 0 ; load buffer
0448AB 00 00       0410*  @length:	dw 0x0000
0448AD 00          0411*  @end: db 0 ; padding
0448AE             0412*  
0448AE             0413*  ; clear a buffer
0448AE             0414*  ; inputs: hl = bufferId
0448AE             0415*  vdu_clear_buffer:
0448AE 7D          0416*      ld a,l
0448AF 32 C6 48 04 0417*      ld (@bufferId),a
0448B3 7C          0418*      ld a,h
0448B4 32 C7 48 04 0419*      ld (@bufferId+1),a
0448B8 21 C3 48 04 0420*      ld hl,@cmd
0448BC 01 06 00 00 0421*      ld bc,@end-@cmd
0448C0 5B DF       0422*      rst.lil $18
0448C2 C9          0423*      ret
0448C3 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0448C6 00 00       0425*  @bufferId:	dw 0x0000
0448C8 02          0426*  		    db 2 ; clear buffer
0448C9             0427*  @end:
0448C9             0428*  
0448C9             0429*  vdu_clear_all_buffers:
0448C9             0430*  ; clear all buffers
0448C9 21 D4 48 04 0431*      ld hl,@beg
0448CD 01 06 00 00 0432*      ld bc,@end-@beg
0448D1 5B DF       0433*      rst.lil $18
0448D3 C9          0434*      ret
0448D4 17 00 A0    0435*  @beg: db 23,0,$A0
0448D7 FF FF       0436*        dw -1 ; clear all buffers
0448D9 02          0437*        db 2  ; command 2: clear a buffer
0448DA             0438*  @end:
0448DA             0439*  
0448DA             0440*  ; Command 14: Consolidate blocks in a buffer
0448DA             0441*  vdu_consolidate_buffer:
0448DA             0442*  ; set parameters for vdu call
0448DA 7D          0443*      ld a,l
0448DB 32 F2 48 04 0444*      ld (@bufferId),a
0448DF 7C          0445*      ld a,h
0448E0 32 F3 48 04 0446*      ld (@bufferId+1),a
0448E4 21 EF 48 04 0447*      ld hl,@beg
0448E8 01 06 00 00 0448*      ld bc,@end-@beg
0448EC 5B DF       0449*      rst.lil $18
0448EE C9          0450*      ret
0448EF             0451*  ; VDU 23, 0, &A0, bufferId; 14
0448EF 17 00 A0    0452*  @beg: db 23,0,0xA0
0448F2 00 00       0453*  @bufferId: dw 0x0000
0448F4 0E          0454*             db 14
0448F5             0455*  @end:
0448F5             0456*  
0448F5             0457*  ; load an image file to a buffer and make it a bitmap
0448F5             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0448F5             0459*  vdu_load_img:
0448F5             0460*  ; back up image type and dimension parameters
0448F5 22 7C 48 04 0461*      ld (bufferId0),hl
0448F9 F5          0462*      push af
0448FA C5          0463*  	push bc
0448FB D5          0464*  	push de
0448FC             0465*  ; load the image
0448FC CD 17 49 04 0466*  	call vdu_load_buffer_from_file
044900             0467*  ; now make it a bitmap
044900 2A 7C 48 04 0468*      ld hl,(bufferId0)
044904 CD DA 48 04 0469*      call vdu_consolidate_buffer
044908 2A 7C 48 04 0470*      ld hl,(bufferId0)
04490C CD D7 47 04 0471*      call vdu_buff_select
044910 D1          0472*  	pop de ; image height
044911 C1          0473*  	pop bc ; image width
044912 F1          0474*  	pop af ; image type
044913 C3 EC 47 04 0475*  	jp vdu_bmp_create ; will return to caller from there
044917             0476*  
044917             0477*  ; inputs: hl = bufferId; iy = pointer to filename
044917             0478*  vdu_load_buffer_from_file:
044917 22 7C 48 04 0479*      ld (bufferId0),hl
04491B             0480*  
04491B             0481*  ; clear target buffer
04491B CD AE 48 04 0482*      call vdu_clear_buffer
04491F             0483*  
04491F             0484*  ; open the file in read mode
04491F             0485*  ; Open a file
04491F             0486*  ; HLU: Filename
04491F             0487*  ;   C: Mode
04491F             0488*  ; Returns:
04491F             0489*  ;   A: Filehandle, or 0 if couldn't open
04491F FD E5       0490*  	push iy ; pointer to filename
044921 E1          0491*  	pop hl
044922 0E 01       0492*  	ld c,fa_read
044924             0493*      MOSCALL mos_fopen
044924 3E 0A       0001*M 			LD	A, function
044926 5B CF       0002*M 			RST.LIL	08h
044928 32 63 49 04 0494*      ld (@filehandle),a
04492C             0495*  
04492C             0496*  @read_file:
04492C             0497*  ; Read a block of data from a file
04492C             0498*  ;   C: Filehandle
04492C             0499*  ; HLU: Pointer to where to write the data to
04492C             0500*  ; DEU: Number of bytes to read
04492C             0501*  ; Returns:
04492C             0502*  ; DEU: Number of bytes read
04492C 3A 63 49 04 0503*      ld a,(@filehandle)
044930 4F          0504*      ld c,a
044931 21 00 E0 B7 0505*      ld hl,filedata
044935 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
044939             0507*      MOSCALL mos_fread
044939 3E 1A       0001*M 			LD	A, function
04493B 5B CF       0002*M 			RST.LIL	08h
04493D             0508*  
04493D             0509*  ; test de for zero bytes read
04493D 21 00 00 00 0510*      ld hl,0
044941 AF          0511*      xor a ; clear carry
044942 ED 52       0512*      sbc hl,de
044944 CA 5A 49 04 0513*      jp z,@close_file
044948             0514*  
044948             0515*  ; load a vdu buffer from local memory
044948             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044948 2A 7C 48 04 0517*      ld hl,(bufferId0)
04494C D5          0518*      push de ; chunksize
04494D C1          0519*      pop bc
04494E 11 00 E0 B7 0520*      ld de,filedata
044952 CD 82 48 04 0521*      call vdu_load_buffer
044956             0522*  
044956             0523*  ; read the next block
044956 C3 2C 49 04 0524*      jp @read_file
04495A             0525*  
04495A             0526*  ; close the file
04495A             0527*  @close_file:
04495A 3A 63 49 04 0528*      ld a,(@filehandle)
04495E             0529*      MOSCALL mos_fclose
04495E 3E 0B       0001*M 			LD	A, function
044960 5B CF       0002*M 			RST.LIL	08h
044962 C9          0530*      ret ; vdu_load_buffer_from_file
044963             0531*  
044963 00          0532*  @filehandle: db 0 ; file handle
044964 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
044967             0534*  
044967 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
04496A             0536*  
04496A             0537*  ; File information structure (FILINFO)
04496A             0538*  @filinfo:
04496A 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04496E 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
044970 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
044972 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
044973 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
044980 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A80             0044   	include "vdu_plot.inc"
044A80             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044A80             0002*  ; PLOT code 	(Decimal) 	Effect
044A80             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
044A80             0004*  plot_sl_both: equ 0x00
044A80             0005*  
044A80             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
044A80             0007*  plot_sl_first: equ 0x08
044A80             0008*  
044A80             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
044A80             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
044A80             0011*  
044A80             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
044A80             0013*  plot_sl_last: equ 0x20
044A80             0014*  
044A80             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
044A80             0016*  plot_sl_none: equ 0x28
044A80             0017*  
044A80             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
044A80             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
044A80             0020*  
044A80             0021*  ; &40-&47 	64-71 	Point plot
044A80             0022*  plot_pt: equ 0x40
044A80             0023*  
044A80             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
044A80             0025*  plot_lf_lr_non_bg: equ 0x48
044A80             0026*  
044A80             0027*  ; &50-&57 	80-87 	Triangle fill
044A80             0028*  plot_tf: equ 0x50
044A80             0029*  
044A80             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
044A80             0031*  plot_lf_r_bg: equ 0x58
044A80             0032*  
044A80             0033*  ; &60-&67 	96-103 	Rectangle fill
044A80             0034*  plot_rf: equ 0x60
044A80             0035*  
044A80             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
044A80             0037*  plot_lf_lr_fg: equ 0x60
044A80             0038*  
044A80             0039*  ; &70-&77 	112-119 	Parallelogram fill
044A80             0040*  plot_pf: equ 0x70
044A80             0041*  
044A80             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
044A80             0043*  plot_lf_r_non_fg: equ 0x78
044A80             0044*  
044A80             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
044A80             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
044A80             0047*  
044A80             0048*  ; &90-&97 	144-151 	Circle outline
044A80             0049*  plot_co: equ 0x90
044A80             0050*  
044A80             0051*  ; &98-&9F 	152-159 	Circle fill
044A80             0052*  plot_cf: equ 0x98
044A80             0053*  
044A80             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
044A80             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
044A80             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
044A80             0057*  
044A80             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
044A80             0059*  plot_rcm: equ 0xB8
044A80             0060*  
044A80             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
044A80             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
044A80             0063*  ; &D0-&D7 	208-215 	Not defined
044A80             0064*  ; &D8-&DF 	216-223 	Not defined
044A80             0065*  ; &E0-&E7 	224-231 	Not defined
044A80             0066*  
044A80             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
044A80             0068*  plot_bmp: equ 0xE8
044A80             0069*  
044A80             0070*  ; &F0-&F7 	240-247 	Not defined
044A80             0071*  ; &F8-&FF 	248-255 	Not defined
044A80             0072*  
044A80             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
044A80             0074*  ; Agon Console8 VDP 2.2.0
044A80             0075*  
044A80             0076*  ; Within each group of eight plot codes, the effects are as follows:
044A80             0077*  ; Plot code 	Effect
044A80             0078*  ; 0 	Move relative
044A80             0079*  mv_rel: equ 0
044A80             0080*  
044A80             0081*  ; 1 	Plot relative in current foreground colour
044A80             0082*  dr_rel_fg: equ 1
044A80             0083*  
044A80             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
044A80             0085*  ; 3 	Plot relative in current background colour
044A80             0086*  dr_rel_bg: equ 3
044A80             0087*  
044A80             0088*  ; 4 	Move absolute
044A80             0089*  mv_abs: equ 4
044A80             0090*  
044A80             0091*  ; 5 	Plot absolute in current foreground colour
044A80             0092*  dr_abs_fg: equ 5
044A80             0093*  
044A80             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
044A80             0095*  ; 7 	Plot absolute in current background colour
044A80             0096*  dr_abs_bg: equ 7
044A80             0097*  
044A80             0098*  ; Codes 0-3 use the position data provided as part of the command
044A80             0099*  ; as a relative position, adding the position given to the current
044A80             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
044A80             0101*  ; as part of the command as an absolute position, setting the current
044A80             0102*  ; graphical cursor position to the position given.
044A80             0103*  
044A80             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
044A80             0105*  ; current pixel colour. These operations cannot currently be supported
044A80             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
044A80             0107*  ; supported. Support for these codes may be added in a future version
044A80             0108*  ; of the VDP firmware.
044A80             0109*  
044A80             0110*  ; 16 colour palette constants
044A80             0111*  c_black: equ 0
044A80             0112*  c_red_dk: equ 1
044A80             0113*  c_green_dk: equ 2
044A80             0114*  c_yellow_dk: equ 3
044A80             0115*  c_blue_dk: equ 4
044A80             0116*  c_magenta_dk: equ 5
044A80             0117*  c_cyan_dk: equ 6
044A80             0118*  c_grey: equ 7
044A80             0119*  c_grey_dk: equ 8
044A80             0120*  c_red: equ 9
044A80             0121*  c_green: equ 10
044A80             0122*  c_yellow: equ 11
044A80             0123*  c_blue: equ 12
044A80             0124*  c_magenta: equ 13
044A80             0125*  c_cyan: equ 14
044A80             0126*  c_white: equ 15
044A80             0127*  
044A80             0128*  ; VDU 25, mode, x; y;: PLOT command
044A80             0129*  ; inputs: a=mode, bc=x0, de=y0
044A80             0130*  vdu_plot:
044A80 32 9A 4A 04 0131*      ld (@mode),a
044A84 ED 43 9B 4A 0132*      ld (@x0),bc
       04          
044A89 ED 53 9D 4A 0133*      ld (@y0),de
       04          
044A8E 21 99 4A 04 0134*  	ld hl,@cmd
044A92 01 06 00 00 0135*  	ld bc,@end-@cmd
044A96 5B DF       0136*  	rst.lil $18
044A98 C9          0137*  	ret
044A99 19          0138*  @cmd:   db 25
044A9A 00          0139*  @mode:  db 0
044A9B 00 00       0140*  @x0: 	dw 0
044A9D 00 00       0141*  @y0: 	dw 0
044A9F 00          0142*  @end:   db 0 ; extra byte to soak up deu
044AA0             0143*  
044AA0             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044AA0             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
044AA0             0146*  ; VDU 25, mode, x; y;: PLOT command
044AA0             0147*  ; inputs: bc=x0, de=y0
044AA0             0148*  ; prerequisites: vdu_buff_select
044AA0             0149*  vdu_plot_bmp:
044AA0 ED 43 B7 4A 0150*      ld (@x0),bc
       04          
044AA5 ED 53 B9 4A 0151*      ld (@y0),de
       04          
044AAA 21 B5 4A 04 0152*  	ld hl,@cmd
044AAE 01 06 00 00 0153*  	ld bc,@end-@cmd
044AB2 5B DF       0154*  	rst.lil $18
044AB4 C9          0155*  	ret
044AB5 19          0156*  @cmd:   db 25
044AB6 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
044AB7 00 00       0158*  @x0: 	dw 0x0000
044AB9 00 00       0159*  @y0: 	dw 0x0000
044ABB 00          0160*  @end:   db 0x00 ; padding
044ABC             0161*  
044ABC             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
044ABC             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
044ABC             0164*  ; VDU 25, mode, x; y;: PLOT command
044ABC             0165*  ; inputs: bc=x0, de=y0
044ABC             0166*  ; USING 16.8 FIXED POINT COORDINATES
044ABC             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
044ABC             0168*  ;   the fractional portiion of the inputs are truncated
044ABC             0169*  ;   leaving only the 16-bit integer portion
044ABC             0170*  ; prerequisites: vdu_buff_select
044ABC             0171*  vdu_plot_bmp168:
044ABC             0172*  ; populate in the reverse of normal to keep the
044ABC             0173*  ; inputs from stomping on each other
044ABC ED 53 DA 4A 0174*      ld (@y0-1),de
       04          
044AC1 ED 43 D8 4A 0175*      ld (@x0-1),bc
       04          
044AC6 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
044AC8 32 D8 4A 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
044ACC 21 D7 4A 04 0178*  	ld hl,@cmd
044AD0 01 06 00 00 0179*  	ld bc,@end-@cmd
044AD4 5B DF       0180*  	rst.lil $18
044AD6 C9          0181*  	ret
044AD7 19          0182*  @cmd:   db 25
044AD8 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
044AD9 00 00       0184*  @x0: 	dw 0x0000
044ADB 00 00       0185*  @y0: 	dw 0x0000
044ADD             0186*  @end:  ; no padding required b/c we shifted de right
044ADD             0187*  
044ADD             0188*  ; draw a filled rectangle
044ADD             0189*  vdu_plot_rf:
044ADD ED 43 04 4B 0190*      ld (@x0),bc
       04          
044AE2 ED 53 06 4B 0191*      ld (@y0),de
       04          
044AE7 DD 22 0A 4B 0192*      ld (@x1),ix
       04          
044AEC FD 22 0C 4B 0193*      ld (@y1),iy
       04          
044AF1 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
044AF3 32 08 4B 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
044AF7 21 02 4B 04 0196*  	ld hl,@cmd0
044AFB 01 0C 00 00 0197*  	ld bc,@end-@cmd0
044AFF 5B DF       0198*  	rst.lil $18
044B01 C9          0199*      ret
044B02 19          0200*  @cmd0:  db 25 ; plot
044B03 04          0201*  @arg0:  db plot_sl_both+mv_abs
044B04 00 00       0202*  @x0:    dw 0x0000
044B06 00 00       0203*  @y0:    dw 0x0000
044B08 19          0204*  @cmd1:  db 25 ; plot
044B09 65          0205*  @arg1:  db plot_rf+dr_abs_fg
044B0A 00 00       0206*  @x1:    dw 0x0000
044B0C 00 00       0207*  @y1:    dw 0x0000
044B0E 00          0208*  @end:   db 0x00 ; padding
044B0F             0209*  
044B0F             0210*  ; draw a filled circle
044B0F             0211*  vdu_plot_cf:
044B0F ED 43 36 4B 0212*      ld (@x0),bc
       04          
044B14 ED 53 38 4B 0213*      ld (@y0),de
       04          
044B19 DD 22 3C 4B 0214*      ld (@x1),ix
       04          
044B1E FD 22 3E 4B 0215*      ld (@y1),iy
       04          
044B23 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
044B25 32 3A 4B 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
044B29 21 34 4B 04 0218*  	ld hl,@cmd0
044B2D 01 0C 00 00 0219*  	ld bc,@end-@cmd0
044B31 5B DF       0220*  	rst.lil $18
044B33 C9          0221*      ret
044B34 19          0222*  @cmd0:  db 25 ; plot
044B35 04          0223*  @arg0:  db plot_sl_both+mv_abs
044B36 00 00       0224*  @x0:    dw 0x0000
044B38 00 00       0225*  @y0:    dw 0x0000
044B3A 19          0226*  @cmd1:  db 25 ; plot
044B3B 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
044B3C 00 00       0228*  @x1:    dw 0x0000
044B3E 00 00       0229*  @y1:    dw 0x0000
044B40 00          0230*  @end:   db 0x00 ; padding
044B41             0045   	include "vdu_sprites.inc"
044B41             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
044B41             0002*  ; the VDP can support up to 256 sprites. They must be defined
044B41             0003*  ; contiguously, and so the first sprite is sprite 0.
044B41             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
044B41             0005*  ; Once a selection of sprites have been defined, you can activate
044B41             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
044B41             0007*  ; of sprites to activate. This will activate the first n sprites,
044B41             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
044B41             0009*  
044B41             0010*  ; A single sprite can have multiple "frames", referring to
044B41             0011*  ; different bitmaps.
044B41             0012*  ; (These bitmaps do not need to be the same size.)
044B41             0013*  ; This allows a sprite to include an animation sequence,
044B41             0014*  ; which can be stepped through one frame at a time, or picked
044B41             0015*  ; in any order.
044B41             0016*  
044B41             0017*  ; Any format of bitmap can be used as a sprite frame. It should
044B41             0018*  ; be noted however that "native" format bitmaps are not
044B41             0019*  ; recommended for use as sprite frames, as they cannot get
044B41             0020*  ; erased from the screen. (As noted above, the "native" bitmap
044B41             0021*  ; format is not really intended for general use.) This is part
044B41             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
044B41             0023*  ; screen are now stored in RGBA2222 format.
044B41             0024*  
044B41             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
044B41             0026*  ; and then later shown again.
044B41             0027*  
044B41             0028*  ; Moving sprites around the screen is done by changing the
044B41             0029*  ; position of the sprite. This can be done either by setting
044B41             0030*  ; the absolute position of the sprite, or by moving the sprite
044B41             0031*  ; by a given number of pixels. (Sprites are positioned using
044B41             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
044B41             0033*  ; In the current sprite system, sprites will not update their
044B41             0034*  ; position on-screen until either another drawing operation is
044B41             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
044B41             0036*  
044B41             0037*  ; VDU 23, 27, 4, n: Select sprite n
044B41             0038*  ; inputs: a is the 8-bit sprite id
044B41             0039*  vdu_sprite_select:
044B41 32 53 4B 04 0040*      ld (@sprite),a
044B45 21 50 4B 04 0041*      ld hl,@cmd
044B49 01 04 00 00 0042*      ld bc,@end-@cmd
044B4D 5B DF       0043*      rst.lil $18
044B4F C9          0044*      ret
044B50 17 1B 04    0045*  @cmd:    db 23,27,4
044B53 00          0046*  @sprite: db 0x00
044B54             0047*  @end:
044B54             0048*  
044B54             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
044B54             0050*  ; inputs: none
044B54             0051*  ; prerequisites: vdu_sprite_select
044B54             0052*  vdu_sprite_clear_frames:
044B54 21 5F 4B 04 0053*      ld hl,@cmd
044B58 01 03 00 00 0054*      ld bc,@end-@cmd
044B5C 5B DF       0055*      rst.lil $18
044B5E C9          0056*      ret
044B5F 17 1B 05    0057*  @cmd: db 23,27,5
044B62             0058*  @end:
044B62             0059*  
044B62             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
044B62             0061*  ; inputs: a is the 8-bit bitmap number
044B62             0062*  ; prerequisites: vdu_sprite_select
044B62             0063*  vdu_sprite_add_bmp:
044B62 32 74 4B 04 0064*      ld (@bmp),a
044B66 21 71 4B 04 0065*      ld hl,@cmd
044B6A 01 04 00 00 0066*      ld bc,@end-@cmd
044B6E 5B DF       0067*      rst.lil $18
044B70 C9          0068*      ret
044B71 17 1B 06    0069*  @cmd: db 23,27,6
044B74 00          0070*  @bmp: db 0x00
044B75             0071*  @end:
044B75             0072*  
044B75             0073*  ; VDU 23, 27, 7, n: Activate n sprites
044B75             0074*  ; inputs: a is the number of sprites to activate
044B75             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
044B75             0076*  vdu_sprite_activate:
044B75 32 87 4B 04 0077*      ld (@num),a
044B79 21 84 4B 04 0078*      ld hl,@cmd
044B7D 01 04 00 00 0079*      ld bc,@end-@cmd
044B81 5B DF       0080*      rst.lil $18
044B83 C9          0081*      ret
044B84 17 1B 07    0082*  @cmd: db 23,27,7
044B87 00          0083*  @num: db 0x00
044B88             0084*  @end:
044B88             0085*  
044B88             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
044B88             0087*  ; inputs: none
044B88             0088*  ; prerequisites: vdu_sprite_select
044B88             0089*  vdu_sprite_next_frame:
044B88 21 93 4B 04 0090*      ld hl,@cmd
044B8C 01 03 00 00 0091*      ld bc,@end-@cmd
044B90 5B DF       0092*      rst.lil $18
044B92 C9          0093*      ret
044B93 17 1B 08    0094*  @cmd: db 23,27,8
044B96             0095*  @end:
044B96             0096*  
044B96             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
044B96             0098*  ; inputs: none
044B96             0099*  ; prerequisites: vdu_sprite_select
044B96             0100*  vdu_sprite_prev_frame:
044B96 21 A1 4B 04 0101*      ld hl,@cmd
044B9A 01 03 00 00 0102*      ld bc,@end-@cmd
044B9E 5B DF       0103*      rst.lil $18
044BA0 C9          0104*      ret
044BA1 17 1B 09    0105*  @cmd: db 23,27,9
044BA4             0106*  @end:
044BA4             0107*  
044BA4             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
044BA4             0109*  ; inputs: a is frame number to select
044BA4             0110*  ; prerequisites: vdu_sprite_select
044BA4             0111*  vdu_sprite_select_frame:
044BA4 32 B6 4B 04 0112*      ld (@frame),a
044BA8 21 B3 4B 04 0113*      ld hl,@cmd
044BAC 01 04 00 00 0114*      ld bc,@end-@cmd
044BB0 5B DF       0115*      rst.lil $18
044BB2 C9          0116*      ret
044BB3 17 1B 0A    0117*  @cmd:    db 23,27,10
044BB6 00          0118*  @frame:  db 0x00
044BB7             0119*  @end:
044BB7             0120*  
044BB7             0121*  ; VDU 23, 27, 11: Show current sprite
044BB7             0122*  ; inputs: none
044BB7             0123*  ; prerequisites: vdu_sprite_select
044BB7             0124*  vdu_sprite_show:
044BB7 21 C2 4B 04 0125*      ld hl,@cmd
044BBB 01 03 00 00 0126*      ld bc,@end-@cmd
044BBF 5B DF       0127*      rst.lil $18
044BC1 C9          0128*      ret
044BC2 17 1B 0B    0129*  @cmd: db 23,27,11
044BC5             0130*  @end:
044BC5             0131*  
044BC5             0132*  ; VDU 23, 27, 12: Hide current sprite
044BC5             0133*  ; inputs: none
044BC5             0134*  ; prerequisites: vdu_sprite_select
044BC5             0135*  vdu_sprite_hide:
044BC5 21 D0 4B 04 0136*      ld hl,@cmd
044BC9 01 03 00 00 0137*      ld bc,@end-@cmd
044BCD 5B DF       0138*      rst.lil $18
044BCF C9          0139*      ret
044BD0 17 1B 0C    0140*  @cmd: db 23,27,12
044BD3             0141*  @end:
044BD3             0142*  
044BD3             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044BD3             0144*  ; inputs: bc is x coordinate, de is y coordinate
044BD3             0145*  ; prerequisites: vdu_sprite_select
044BD3             0146*  vdu_sprite_move_abs:
044BD3 ED 43 EB 4B 0147*      ld (@xpos),bc
       04          
044BD8 ED 53 ED 4B 0148*      ld (@ypos),de
       04          
044BDD 21 E8 4B 04 0149*      ld hl,@cmd
044BE1 01 07 00 00 0150*      ld bc,@end-@cmd
044BE5 5B DF       0151*      rst.lil $18
044BE7 C9          0152*      ret
044BE8 17 1B 0D    0153*  @cmd:  db 23,27,13
044BEB 00 00       0154*  @xpos: dw 0x0000
044BED 00 00       0155*  @ypos: dw 0x0000
044BEF 00          0156*  @end:  db 0x00 ; padding
044BF0             0157*  
044BF0             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
044BF0             0159*  ; inputs: bc is x coordinate, de is y coordinate
044BF0             0160*  ; prerequisites: vdu_sprite_select
044BF0             0161*  vdu_sprite_move_rel:
044BF0 ED 43 08 4C 0162*      ld (@dx),bc
       04          
044BF5 ED 53 0A 4C 0163*      ld (@dy),de
       04          
044BFA 21 05 4C 04 0164*      ld hl,@cmd
044BFE 01 07 00 00 0165*      ld bc,@end-@cmd
044C02 5B DF       0166*      rst.lil $18
044C04 C9          0167*      ret
044C05 17 1B 0E    0168*  @cmd: db 23,27,14
044C08 00 00       0169*  @dx:  dw 0x0000
044C0A 00 00       0170*  @dy:  dw 0x0000
044C0C 00          0171*  @end: db 0x00 ; padding
044C0D             0172*  
044C0D             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044C0D             0174*  ; USING 16.8 FIXED POINT COORDINATES
044C0D             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
044C0D             0176*  ;   the fractional portiion of the inputs are truncated
044C0D             0177*  ;   leaving only the 16-bit integer portion
044C0D             0178*  ; prerequisites: vdu_sprite_select
044C0D             0179*  vdu_sprite_move_abs168:
044C0D             0180*  ; offset inputs by the gfx origin
044C0D             0181*  ; y coordinate
044C0D 21 00 00 00 0182*      ld hl,origin_top*256
044C11 19          0183*      add hl,de
044C12 22 34 4C 04 0184*      ld (@ypos-1),hl
044C16             0185*  ; x coordinate
044C16 21 00 80 00 0186*      ld hl,origin_left*256
044C1A 09          0187*      add hl,bc
044C1B 22 32 4C 04 0188*      ld (@xpos-1),hl
044C1F             0189*  ; prepare vdu command
044C1F 3E 0D       0190*      ld a,13       ; restore the final byte of the command
044C21 32 32 4C 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
044C25 21 30 4C 04 0192*      ld hl,@cmd
044C29 01 07 00 00 0193*      ld bc,@end-@cmd
044C2D 5B DF       0194*      rst.lil $18
044C2F C9          0195*      ret
044C30 17 1B 0D    0196*  @cmd:  db 23,27,13
044C33 00 00       0197*  @xpos: dw 0x0000
044C35 00 00       0198*  @ypos: dw 0x0000
044C37             0199*  @end:  ; no padding required b/c we shifted de right
044C37             0200*  
044C37             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
044C37             0202*  ; USING 16.8 FIXED POINT COORDINATES
044C37             0203*  ; inputs: ub.c is dx, ud.e is dy
044C37             0204*  ;   the fractional portiion of the inputs are truncated
044C37             0205*  ;   leaving only the 16-bit integer portion
044C37             0206*  ; prerequisites: vdu_sprite_select
044C37             0207*  vdu_sprite_move_rel168:
044C37             0208*  ; populate in the reverse of normal to keep the
044C37             0209*  ; inputs from stomping on each other
044C37 ED 53 56 4C 0210*      ld (@dy-1),de
       04          
044C3C ED 43 54 4C 0211*      ld (@dx-1),bc
       04          
044C41 3E 0E       0212*      ld a,14       ; restore the final byte of the command
044C43 32 54 4C 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
044C47 21 52 4C 04 0214*      ld hl,@cmd
044C4B 01 07 00 00 0215*      ld bc,@end-@cmd
044C4F 5B DF       0216*      rst.lil $18
044C51 C9          0217*      ret
044C52 17 1B 0E    0218*  @cmd:  db 23,27,14
044C55 00 00       0219*  @dx: dw 0x0000
044C57 00 00       0220*  @dy: dw 0x0000
044C59             0221*  @end:  ; no padding required b/c we shifted de right
044C59             0222*  
044C59             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
044C59             0224*  ; inputs: none
044C59             0225*  vdu_sprite_update:
044C59 21 64 4C 04 0226*      ld hl,@cmd
044C5D 01 03 00 00 0227*      ld bc,@end-@cmd
044C61 5B DF       0228*      rst.lil $18
044C63 C9          0229*      ret
044C64 17 1B 0F    0230*  @cmd: db 23,27,15
044C67             0231*  @end:
044C67             0232*  
044C67             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
044C67             0234*  ; inputs: none
044C67             0235*  vdu_sprite_bmp_reset:
044C67 21 72 4C 04 0236*      ld hl,@cmd
044C6B 01 03 00 00 0237*      ld bc,@end-@cmd
044C6F 5B DF       0238*      rst.lil $18
044C71 C9          0239*      ret
044C72 17 1B 10    0240*  @cmd: db 23,27,16
044C75             0241*  @end:
044C75             0242*  
044C75             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
044C75             0244*  ; inputs: none
044C75             0245*  vdu_sprite_reset:
044C75 21 80 4C 04 0246*      ld hl,@cmd
044C79 01 03 00 00 0247*      ld bc,@end-@cmd
044C7D 5B DF       0248*      rst.lil $18
044C7F C9          0249*      ret
044C80 17 1B 11    0250*  @cmd: db 23,27,17
044C83             0251*  @end:
044C83             0252*  
044C83             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
044C83             0254*  ; inputs: a is the GCOL paint mode
044C83             0255*  ; prerequisites: vdu_sprite_select
044C83             0256*  vdu_sprite_set_gcol:
044C83 32 95 4C 04 0257*      ld (@mode),a
044C87 21 92 4C 04 0258*      ld hl,@cmd
044C8B 01 04 00 00 0259*      ld bc,@end-@cmd
044C8F 5B DF       0260*      rst.lil $18
044C91 C9          0261*      ret
044C92 17 1B 12    0262*  @cmd:  db 23,27,18
044C95 00          0263*  @mode: db 0x00
044C96             0264*  @end:
044C96             0265*  
044C96             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
044C96             0267*  ; inputs: hl=bufferId
044C96             0268*  ; prerequisites: vdu_sprite_select
044C96             0269*  vdu_sprite_add_buff:
044C96 22 A8 4C 04 0270*      ld (@bufferId),hl
044C9A 21 A5 4C 04 0271*      ld hl,@cmd
044C9E 01 05 00 00 0272*      ld bc,@end-@cmd
044CA2 5B DF       0273*      rst.lil $18
044CA4 C9          0274*      ret
044CA5 17 1B 26    0275*  @cmd:      db 23,27,0x26
044CA8 00 00       0276*  @bufferId: dw 0x0000
044CAA 00          0277*  @end:      db 0x00 ; padding
044CAB             0046   
044CAB 57 65 6C 63 0047   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
044CC6 4C 6F 61 64 0048   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044CD1 4C 6F 61 64 0049   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
044CDF 50 72 65 73 0050   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
044CFA             0051   
044CFA             0052   init:
044CFA             0053   ; clear all buffers
044CFA CD C9 48 04 0054       call vdu_clear_all_buffers
044CFE             0055   
044CFE             0056   ; set up the display
044CFE 3E 08       0057       ld a,8;+128 ; 136   320   240   64    60hz double-buffered
044D00 CD B3 47 04 0058       call vdu_set_screen_mode
044D04 AF          0059       xor a
044D05 CD C4 47 04 0060       call vdu_set_scaling
044D09             0061   
044D09             0062   ; ; enable additional audio channels
044D09             0063   ; 	call vdu_enable_channels
044D09             0064   
044D09             0065   ; set text background color
044D09 3E 9A       0066   	ld a,26+128 ; violet
044D0B CD 1B 47 04 0067   	call vdu_colour_text
044D0F             0068   
044D0F             0069   ; set text foreground color
044D0F 3E 2F       0070   	ld a,47 ; aaaaff lavenderish
044D11 CD 1B 47 04 0071   	call vdu_colour_text
044D15             0072   
044D15             0073   ; set gfx bg color
044D15 AF          0074   	xor a ; plotting mode 0
044D16 3E 9A       0075   	ld a,26+128 ; violet
044D18 CD 2C 47 04 0076   	call vdu_gcol
044D1C CD EA 46 04 0077   	call vdu_cls
044D20             0078   
044D20             0079   ; set the cursor off
044D20 CD B2 46 04 0080   	call vdu_cursor_off
044D24             0081   
044D24             0082   ; VDU 28, left, bottom, right, top: Set text viewport **
044D24             0083   ; MIND THE LITTLE-ENDIANESS
044D24             0084   ; inputs: c=left,b=bottom,e=right,d=top
044D24 0E 00       0085   	ld c,0 ; left
044D26 16 1D       0086   	ld d,29 ; top
044D28 1E 27       0087   	ld e,39 ; right
044D2A 06 1D       0088   	ld b,29; bottom
044D2C CD 43 47 04 0089   	call vdu_set_txt_viewport
044D30             0090   
044D30             0091   ; print loading ui message
044D30 21 C6 4C 04 0092   	ld hl,loading_ui
044D34 CD 77 00 04 0093   	call printString
044D38 CD EF 46 04 0094   	call vdu_flip
044D3C             0095   
044D3C             0096   ; load UI images
044D3C CD 94 14 04 0097   	call load_ui_images
044D40             0098   
044D40             0099   ; ; load fonts ; TODO
044D40             0100   ; 	call load_font_rc
044D40             0101   
044D40             0102   ; load sprites
044D40 CD 3D 15 04 0103   	call img_load_init ; sets up the animated load screen
044D44 CD AF 14 04 0104   	call load_sprite_images
044D48             0105   
044D48             0106   ; ; load sound effects ; TODO
044D48             0107   ; 	ld bc,SFX_num_buffers
044D48             0108   ; 	ld hl,SFX_buffer_id_lut
044D48             0109   ; 	ld (cur_buffer_id_lut),hl
044D48             0110   ; 	ld hl,SFX_load_routines_table
044D48             0111   ; 	ld (cur_load_jump_table),hl
044D48             0112   ; 	call sfx_load_main
044D48             0113   
044D48             0114   ; print loading complete message and wait for user keypress
044D48 CD EA 46 04 0115   	call vdu_cls
044D4C 21 DF 4C 04 0116   	ld hl,loading_complete
044D50 CD 77 00 04 0117   	call printString
044D54 CD EF 46 04 0118   	call vdu_flip
044D58 CD 15 06 04 0119   	call waitKeypress
044D5C             0120   
044D5C             0121   ; set up display for gameplay
044D5C             0122       ; ld a,8
044D5C 3E 14       0123   	ld a,20
044D5E CD B3 47 04 0124       call vdu_set_screen_mode
044D62 AF          0125       xor a
044D63 CD C4 47 04 0126       call vdu_set_scaling
044D67 CD B2 46 04 0127   	call vdu_cursor_off
044D6B             0128   ; plot bezel art
044D6B 21 00 00 00 0129   	ld hl,BUF_BEZEL_L
044D6F CD D7 47 04 0130   	call vdu_buff_select
044D73 01 00 00 00 0131   	ld bc,0
044D77 11 00 00 00 0132   	ld de,0
044D7B CD A0 4A 04 0133   	call vdu_plot_bmp
044D7F 21 01 00 00 0134   	ld hl,BUF_BEZEL_R
044D83 CD D7 47 04 0135   	call vdu_buff_select
044D87 01 80 01 00 0136   	ld bc,384
044D8B 11 00 00 00 0137   	ld de,0
044D8F CD A0 4A 04 0138   	call vdu_plot_bmp
044D93             0139   ; set gfx origin and viewport to playing field window
044D93 01 80 00 00 0140   	ld bc,origin_left
044D97 11 00 00 00 0141   	ld de,origin_top
044D9B CD 6F 47 04 0142   	call vdu_set_gfx_origin
044D9F 01 00 00 00 0143   	ld bc,field_left
044DA3 11 00 00 00 0144   	ld de,field_top
044DA7 DD 21 FF 00 0145   	ld ix,field_right
       00          
044DAC FD 21 7F 01 0146   	ld iy,field_bottom
       00          
044DB1 CD 8A 47 04 0147   	call vdu_set_gfx_viewport
044DB5             0148   ; set background color
044DB5 3E 9A       0149   	ld a,26+128 ; violet
044DB7 CD 2C 47 04 0150   	call vdu_gcol
044DBB CD FD 46 04 0151   	call vdu_clg
044DBF             0152   ; VDU 28, left, bottom, right, top: Set text viewport **
044DBF 0E 00       0153   	ld c,0 ; left
044DC1 16 00       0154   	ld d,0 ; top
044DC3 1E 3E       0155   	ld e,62 ; right
044DC5 06 07       0156   	ld b,7; bottom
044DC7 CD 43 47 04 0157   	call vdu_set_txt_viewport
044DCB             0158   
044DCB C9          0159   	ret
044DCC             0160   
044DCC             0161   ; origin_top: equ 48
044DCC             0162   origin_top: equ 0 ; DEBUG
044DCC             0163   origin_left: equ 128
044DCC             0164   field_top: equ 0
044DCC             0165   field_bottom: equ 383-origin_top
044DCC             0166   field_left: equ 0
044DCC             0167   field_right: equ 255
044DCC             0168   sprite_top: equ 0
044DCC             0169   sprite_bottom: equ field_bottom-16
044DCC             0170   sprite_left: equ field_left
044DCC             0171   sprite_right: equ field_right-16
044DCC             0172   collide_top: equ %00001000
044DCC             0173   collide_bottom: equ %00000100
044DCC             0174   collide_left: equ %00000010
044DCC             0175   collide_right: equ %00000001
044DCC             0176   
044DCC             0177   ; ; #### BEGIN GAME VARIABLES ####
044DCC             0178   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
044DCC             0179   speed_player: equ 0x000300 ; 3 pixels per frame
044DCC             0180   
044DCC             0181   main:
044DCC             0182   ; start a new game
044DCC CD F6 4D 04 0183   	call new_game
044DD0             0184   
044DD0             0185   main_loop:
044DD0             0186   ; scroll tiles
044DD0 CD 3D 44 04 0187   	call tiles_plot
044DD4             0188   
044DD4             0189   ; get player input and update sprite position
044DD4 CD 08 40 04 0190   	call player_input
044DD8             0191   
044DD8             0192   ; move enemies
044DD8 CD AA 07 04 0193   	call move_enemies
044DDC             0194   
044DDC             0195   ; wait for the next vblank mitigate flicker and for loop timing
044DDC CD 5E 47 04 0196   	call vdu_vblank
044DE0             0197   
044DE0             0198   ; poll keyboard
044DE0 3E 08       0199       ld a, $08                           ; code to send to MOS
044DE2 5B CF       0200       rst.lil $08                         ; get IX pointer to System Variables
044DE4             0201   
044DE4 DD 7E 05    0202       ld a, (ix + $05)                    ; get ASCII code of key pressed
044DE7 FE 1B       0203       cp 27                               ; check if 27 (ascii code for ESC)
044DE9 CA F1 4D 04 0204       jp z, main_end                      ; if pressed, jump to exit
044DED             0205   
044DED C3 D0 4D 04 0206       jp main_loop
044DF1             0207   
044DF1             0208   main_end:
044DF1 CD A4 46 04 0209       call vdu_cursor_on
044DF5 C9          0210   	ret
044DF6             0211   
044DF6             0212   new_game:
044DF6             0213   ; initialize sprites
044DF6 CD 72 43 04 0214   	call sprites_init
044DFA             0215   
044DFA             0216   ; initialize the first level
044DFA AF          0217   	xor a
044DFB 32 B7 43 04 0218   	ld (cur_level),a
044DFF CD F3 44 04 0219   	call init_level
044E03             0220   
044E03             0221   ; initialize player
044E03 CD C9 3F 04 0222   	call player_init
044E07             0223   
044E07             0224   ; spawn an enemy sprite
044E07 06 10       0225   	ld b,table_max_records
044E09             0226   @spawn_enemy_loop:
044E09 C5          0227   	push bc
044E0A CD 29 09 04 0228   	call enemy_init_from_landing_pad
044E0E C1          0229   	pop bc
044E0F 10 F8       0230   	djnz @spawn_enemy_loop
044E11             0231   
044E11 C9          0232   	ret
044E12             0233   
044E12             0234   ; ; ###### INITIALIZE GAME #######
044E12             0235   ; ; clear the screen
044E12             0236   ;     ld a,3
044E12             0237   ;     out (81h),a
044E12             0238   
044E12             0239   ; ; reset the sprite table
044E12             0240   ;     xor a
044E12             0241   ;     ld (table_active_sprites),a
044E12             0242   ;     ld hl,table_limit
044E12             0243   ;     ld (table_base),hl
044E12             0244   ;     ld (table_pointer),hl
044E12             0245   
044E12             0246   ; ; draw a starfield over the entire screen
044E12             0247   ;     ld b,#50 ; first row of visible screen
044E12             0248   ; new_game_draw_stars_loop:
044E12             0249   ;     push bc
044E12             0250   ;     call draw_stars
044E12             0251   ;     pop bc
044E12             0252   ;     ld a,#10
044E12             0253   ;     add a,b
044E12             0254   ;     ld b,a
044E12             0255   ;     jr nz,new_game_draw_stars_loop
044E12             0256   
044E12             0257   ; ; ; print a welcome message
044E12             0258   ; ;     ld de,msg_welcome
044E12             0259   ; ;     ld hl,#581C
044E12             0260   ; ;     ld c,218 ; a bright pastel purple d677e3
044E12             0261   ; ;     call print_string
044E12             0262   
044E12             0263   ; ; push all that to frame buffer
044E12             0264   ;     ld a,#01 ; send video to frame buffer
044E12             0265   ;     out (81h),a
044E12             0266   
044E12             0267   ; ; reset score, lives, shields
044E12             0268   ;     xor a
044E12             0269   ;     ld hl,player_score
044E12             0270   ;     ld (hl),a ; player_score 0
044E12             0271   ;     inc hl
044E12             0272   ;     ld (hl),a ; player_score 1
044E12             0273   ;     inc hl
044E12             0274   ;     ld (hl),a ; player_score 3
044E12             0275   ;     inc hl
044E12             0276   ;     ld a,16
044E12             0277   ;     ld (hl),a ; player_shields
044E12             0278   ;     inc hl
044E12             0279   ;     ld (hl),a ; player_max_shields
044E12             0280   ;     inc hl
044E12             0281   ;     ld a,3
044E12             0282   ;     ld (hl),a ; player_ships
044E12             0283   ;     inc hl
044E12             0284   
044E12             0285   ; ; initialize first level
044E12             0286   ;     ld a,1 ; levels are zero-based, so this will wrap around
044E12             0287   ;     ld (cur_level),a
044E12             0288   ;     ld a,3 ; set max enemy sprites to easy street
044E12             0289   ;     ld (max_enemy_sprites),a
044E12             0290   ;     call dt_next_level
044E12             0291   ;     call dt
044E12             0292   
044E12             0293   ; ; spawn our intrepid hero
044E12             0294   ;     call player_init
044E12             0295   
044E12             0296   
044E12             0297   ; ; #### BEGIN GAME MAIN LOOP ####
044E12             0298   ; main_loop:
044E12             0299   ; ; ; debug: start execution counter
044E12             0300   ; ;     ld a,1
044E12             0301   ; ;     out (#e0),a ; start counting instructions
044E12             0302   
044E12             0303   ; ; refresh background from frame buffer
044E12             0304   ;     ld a,#02
044E12             0305   ;     out (81h),a
044E12             0306   ;     call move_background ; now move it
044E12             0307   ;     ld a,#01
044E12             0308   ;     out (81h),a ; save it back to buffer
044E12             0309   ; ; do all the things
044E12             0310   ;     call move_enemies
044E12             0311   ;     call player_move
044E12             0312   ;     call laser_control
044E12             0313   ;     call print_score
044E12             0314   ;     call draw_shields
044E12             0315   ;     call draw_lives
044E12             0316   ; ; ; debug: stop execution counter and print results
044E12             0317   ; ;     ld a,0
044E12             0318   ; ;     out (#e0),a ; stop counting instructions
044E12             0319   
044E12             0320   ; ; ; debug: start execution counter
044E12             0321   ; ;     ld a,1
044E12             0322   ; ;     out (#e0),a ; start counting instructions
044E12             0323   
044E12             0324   ;     call vdu_vblank
044E12             0325   ; ; ; debug: stop execution counter and print results
044E12             0326   ; ;     ld a,0
044E12             0327   ; ;     out (#e0),a ; stop counting instructions
044E12             0328   
044E12             0329   ;     jr main_loop
044E12             0330   ; #### END GAME MAIN LOOP ####
044E12             0331   
044E12             0332   ; draws the player's shields level
044E12             0333   ; draw_shields:
044E12             0334   ; TODO: Agonize this routine
044E12             0335   ; ; prep the loop to draw the bars
044E12             0336   ;     ld a,(player_shields) ; snag shields
044E12             0337   ;     and a
044E12             0338   ;     ret z ; don't draw if zero shields
044E12             0339   ; ; set loop counter and drawing position
044E12             0340   ;     ld b,a ; loop counter
044E12             0341   ;     ld hl,#5300+48+12
044E12             0342   ; ; set color based on bars remaining
044E12             0343   ;     ld c,103 ; bright green 28fe0a
044E12             0344   ;     cp 9
044E12             0345   ;     jp p,draw_shields_loop
044E12             0346   ;     ld c,74 ; bright yellow eafe5b
044E12             0347   ;     cp 3
044E12             0348   ;     jp p,draw_shields_loop
044E12             0349   ;     ld c,28 ; bright red fe0a0a
044E12             0350   ; draw_shields_loop:
044E12             0351   ;     push bc ; yup,outta
044E12             0352   ;     push hl ; registers again
044E12             0353   ;     ; ld a,#A8 ; ▀,168
044E12             0354   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
044E12             0355   ;     ; call draw_char
044E12             0356   ;     call draw_num ; we nuked draw_char for the time being
044E12             0357   ;     pop hl
044E12             0358   ;     ld a,8
044E12             0359   ;     add a,l
044E12             0360   ;     ld l,a
044E12             0361   ;     pop bc
044E12             0362   ;     djnz draw_shields_loop
044E12             0363       ; ret
044E12             0364   
044E12             0365   ; prints the player's score
044E12             0366   ; print_score:
044E12             0367   ; TODO: Agonize this
044E12             0368   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
044E12             0369   ;     ld c,42 ; dark orange b74400
044E12             0370   ;     ld hl,#5200+1+8+6*6
044E12             0371   ;     ld a,3 ; print 6 bdc digits
044E12             0372   ;     ld de,player_score
044E12             0373   ;     call print_num
044E12             0374   
044E12             0375   ;     ld c,58 ; golden yellow fec10a
044E12             0376   ;     ld hl,#5100+8+6*6
044E12             0377   ;     ld a,3 ; print 6 bdc digits
044E12             0378   ;     ld de,player_score
044E12             0379   ;     call print_num
044E12             0380       ; ret
044E12             0381   
044E12             0382   ; draw_lives:
044E12             0383   ;     ld hl,player_small ; make small yellow ship the active sprite
044E12             0384   ;     ld (sprite_base_bufferId),hl
044E12             0385   ;     ; ld a,#80 ; northern orientation
044E12             0386   ;     ; ld (sprite_orientation),a
044E12             0387   ;     ld hl,0 ; north
044E12             0388   ;     ld (sprite_heading),hl
044E12             0389   ;     xor a
044E12             0390   ;     ld (sprite_animation),a
044E12             0391   ;     ld a,#56 ; top of visible screen
044E12             0392   ;     ld (sprite_y+1),a
044E12             0393   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
044E12             0394   ;     ld a,(player_ships)
044E12             0395   ;     dec a ; we draw one fewer ships than lives
044E12             0396   ;     ret z ; nothing to draw here, move along
044E12             0397   ;     ld b,a ; loop counter
044E12             0398   ;     ld a,256-16 ; initial x position
044E12             0399   ; draw_lives_loop:
044E12             0400   ;     ld (sprite_x+1),a
044E12             0401   ;     push af
044E12             0402   ;     push bc
044E12             0403   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
044E12             0404   ;     pop bc
044E12             0405   ;     pop af
044E12             0406   ;     sub 10
044E12             0407   ;     djnz draw_lives_loop
044E12             0408   ;     ret
