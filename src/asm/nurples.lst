PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 71 49 04 0030   	call	init			; Initialization code
040050 CD 43 4A 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041842             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041842             0033*  
041842             0034*  ; pointer to top address of current record, initialized to table_base
041842 E2 15 04    0035*  table_pointer: dl table_base
041845             0036*  ; how many active sprites
041845 00          0037*  table_active_sprites: db 0x00
041846             0038*  ; flag indicating collision with screen edge
041846             0039*  ; uses orientation codes to specify which edge(s)
041846 00          0040*  sprite_screen_edge: db #00
041847             0041*  ; next sprite id to use
041847 00          0042*  sprite_next_id: db 0
041848             0043*  
041848             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041848             0045*  ; integer coordinates are all that are needed for collision calculations
041848 00          0046*  collision_x: db 0x00
041849 00          0047*  collision_y: db 0x00
04184A 00          0048*  collision_dim_x: db 0x00
04184B 00          0049*  collision_dim_y: db 0x00
04184C             0050*  
04184C             0051*  ; scratch variables
04184C 00          0052*  x: db 0x00 ; 8-bit signed integer
04184D 00          0053*  y: db 0x00 ; 8-bit signed integer
04184E 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041851 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
041854 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
041857 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
04185A 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
04185D 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041860             0060*  
041860             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041860 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041863 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
041866 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
041869             0065*  
041869             0066*  ; gets the next available sprite id
041869             0067*  ; inputs; none
041869             0068*  ; returns: if new sprite available, a = sprite id,
041869             0069*  ;           ix pointing to new sprite vars, carry set
041869             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
041869             0071*  ; destroys: a,b,hl,ix
041869             0072*  ; affects: bumps table_active_sprites by one
041869             0073*  table_get_next_id:
041869 DD 21 E2 15 0074*      ld ix,table_base
       04          
04186E 11 26 00 00 0075*      ld de,table_bytes_per_record
041872 06 10       0076*      ld b,table_max_records
041874             0077*  @loop:
041874 DD 7E 01    0078*      ld a,(ix+sprite_type)
041877 A7          0079*      and a
041878 28 06       0080*      jr z,@found
04187A DD 19       0081*      add ix,de
04187C 10 F6       0082*      djnz @loop
04187E             0083*  @notfound:
04187E AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
04187F C9          0085*      ret
041880             0086*  @found:
041880             0087*  ; bump number of active sprites
041880 21 45 18 04 0088*      ld hl,table_active_sprites
041884 34          0089*      inc (hl)
041885             0090*  ; return sprite id
041885 3E 10       0091*      ld a,table_max_records
041887 90          0092*      sub b
041888 32 47 18 04 0093*      ld (sprite_next_id),a
04188C 37          0094*      scf ; sets carry flag indicating we found a free sprite
04188D C9          0095*      ret ; done
04188E             0096*  
04188E             0097*  ; deactivate the sprite with the given id
04188E             0098*  ; inputs: a = sprite id
04188E             0099*  ; outputs: nothing
04188E             0100*  ; destroys: a,ix,de
04188E             0101*  ; affects: decrements table_active_sprites by one
04188E             0102*  table_deactivate_sprite:
04188E F5          0103*      push af ; save sprite id bc we need it later
04188F CD C6 23 04 0104*      call vdu_sprite_select
041893 CD 4A 24 04 0105*      call vdu_sprite_hide
041897 F1          0106*      pop af ; restore sprite id
041898 11 00 00 00 0107*      ld de,0 ; clear deu
04189C 57          0108*      ld d,a
04189D 1E 26       0109*      ld e,table_bytes_per_record
04189F ED 5C       0110*      mlt de
0418A1 DD 21 E2 15 0111*      ld ix,table_base
       04          
0418A6 DD 19       0112*      add ix,de
0418A8 AF          0113*      xor a
0418A9 DD 77 01    0114*      ld (ix+sprite_type),a
0418AC DD 21 45 18 0115*      ld ix,table_active_sprites
       04          
0418B1 DD 35 00    0116*      dec (ix)
0418B4 C9          0117*      ret
0418B5             0118*  
0418B5             0119*  sprites_init:
0418B5             0120*  ; initialize sprites
0418B5 CD FA 24 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0418B9 AF          0122*  	xor a
0418BA             0123*  @sprite_loop:
0418BA F5          0124*  	push af
0418BB CD C6 23 04 0125*  	call vdu_sprite_select
0418BF 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0418C3 CD 1B 25 04 0127*  	call vdu_sprite_add_buff
0418C7 F1          0128*  	pop af
0418C8 3C          0129*  	inc a
0418C9 FE 12       0130*  	cp table_max_records+2 ; tack on sprites for player and laser
0418CB 20 ED       0131*  	jr nz,@sprite_loop
0418CD 3C          0132*  	inc a
0418CE CD FA 23 04 0133*  	call vdu_sprite_activate
0418D2             0134*  
0418D2             0135*  ; define player sprite
0418D2 3A D0 30 04 0136*  	ld a,(player_id)
0418D6 CD C6 23 04 0137*  	call vdu_sprite_select
0418DA CD D9 23 04 0138*  	call vdu_sprite_clear_frames
0418DE 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0418E2 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0418E6             0141*  @sprite_player_loop:
0418E6 C5          0142*  	push bc
0418E7 E5          0143*  	push hl
0418E8 CD 1B 25 04 0144*  	call vdu_sprite_add_buff
0418EC E1          0145*  	pop hl
0418ED 23          0146*  	inc hl
0418EE C1          0147*  	pop bc
0418EF 10 F5       0148*  	djnz @sprite_player_loop
0418F1 CD 3C 24 04 0149*  	call vdu_sprite_show
0418F5             0150*  
0418F5             0151*  ; all done
0418F5 C9          0152*      ret
0418F6             0050   ; API includes
0418F6             0051       include "mos_api.inc"
0418F6             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0418F6             0002*  ; Title:	AGON MOS - API for user projects
0418F6             0003*  ; Author:	Dean Belfield
0418F6             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0418F6             0005*  ;			Added MOS error codes for return in HL
0418F6             0006*  ; Created:	03/08/2022
0418F6             0007*  ; Last Updated:	10/08/2023
0418F6             0008*  ;
0418F6             0009*  ; Modinfo:
0418F6             0010*  ; 05/08/2022:	Added mos_feof
0418F6             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0418F6             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0418F6             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0418F6             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0418F6             0015*  ; 13/10/2022:	Added mos_oscli
0418F6             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0418F6             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0418F6             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0418F6             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0418F6             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0418F6             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0418F6             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0418F6             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0418F6             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0418F6             0025*  ; 19/05/2023:	Added sysvar_scrMode
0418F6             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0418F6             0027*  ; 03/08/2023:	Added mos_setkbvector
0418F6             0028*  ; 10/08/2023:	Added mos_getkbmap
0418F6             0029*  
0418F6             0030*  ; VDP control (VDU 23, 0, n)
0418F6             0031*  ;
0418F6             0032*  vdp_gp:				EQU 80h
0418F6             0033*  vdp_keycode:		EQU 81h
0418F6             0034*  vdp_cursor:			EQU	82h
0418F6             0035*  vdp_scrchar:		EQU	83h
0418F6             0036*  vdp_scrpixel:		EQU	84h
0418F6             0037*  vdp_audio:			EQU	85h
0418F6             0038*  vdp_mode:			EQU	86h
0418F6             0039*  vdp_rtc:			EQU	87h
0418F6             0040*  vdp_keystate:		EQU	88h
0418F6             0041*  vdp_logicalcoords:	EQU	C0h
0418F6             0042*  vdp_terminalmode:	EQU	FFh
0418F6             0043*  
0418F6             0044*  ; MOS high level functions
0418F6             0045*  ;
0418F6             0046*  mos_getkey:			EQU	00h
0418F6             0047*  mos_load:			EQU	01h
0418F6             0048*  mos_save:			EQU	02h
0418F6             0049*  mos_cd:				EQU	03h
0418F6             0050*  mos_dir:			EQU	04h
0418F6             0051*  mos_del:			EQU	05h
0418F6             0052*  mos_ren:			EQU	06h
0418F6             0053*  mos_mkdir:			EQU	07h
0418F6             0054*  mos_sysvars:		EQU	08h
0418F6             0055*  mos_editline:		EQU	09h
0418F6             0056*  mos_fopen:			EQU	0Ah
0418F6             0057*  mos_fclose:			EQU	0Bh
0418F6             0058*  mos_fgetc:			EQU	0Ch
0418F6             0059*  mos_fputc:			EQU	0Dh
0418F6             0060*  mos_feof:			EQU	0Eh
0418F6             0061*  mos_getError:		EQU	0Fh
0418F6             0062*  mos_oscli:			EQU	10h
0418F6             0063*  mos_copy:			EQU	11h
0418F6             0064*  mos_getrtc:			EQU	12h
0418F6             0065*  mos_setrtc:			EQU	13h
0418F6             0066*  mos_setintvector:	EQU	14h
0418F6             0067*  mos_uopen:			EQU	15h
0418F6             0068*  mos_uclose:			EQU	16h
0418F6             0069*  mos_ugetc:			EQU	17h
0418F6             0070*  mos_uputc:			EQU	18h
0418F6             0071*  mos_getfil:			EQU	19h
0418F6             0072*  mos_fread:			EQU	1Ah
0418F6             0073*  mos_fwrite:			EQU	1Bh
0418F6             0074*  mos_flseek:			EQU	1Ch
0418F6             0075*  mos_setkbvector:	EQU	1Dh
0418F6             0076*  mos_getkbmap:		EQU	1Eh
0418F6             0077*  
0418F6             0078*  ; MOS program exit codes
0418F6             0079*  ;
0418F6             0080*  EXIT_OK:				EQU  0;	"OK",
0418F6             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0418F6             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0418F6             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0418F6             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0418F6             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0418F6             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0418F6             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0418F6             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0418F6             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0418F6             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0418F6             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0418F6             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0418F6             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0418F6             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0418F6             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0418F6             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0418F6             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0418F6             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0418F6             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0418F6             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0418F6             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0418F6             0102*  ; FatFS file access functions
0418F6             0103*  ;
0418F6             0104*  ffs_fopen:			EQU	80h
0418F6             0105*  ffs_fclose:			EQU	81h
0418F6             0106*  ffs_fread:			EQU	82h
0418F6             0107*  ffs_fwrite:			EQU	83h
0418F6             0108*  ffs_flseek:			EQU	84h
0418F6             0109*  ffs_ftruncate:		EQU	85h
0418F6             0110*  ffs_fsync:			EQU	86h
0418F6             0111*  ffs_fforward:		EQU	87h
0418F6             0112*  ffs_fexpand:		EQU	88h
0418F6             0113*  ffs_fgets:			EQU	89h
0418F6             0114*  ffs_fputc:			EQU	8Ah
0418F6             0115*  ffs_fputs:			EQU	8Bh
0418F6             0116*  ffs_fprintf:		EQU	8Ch
0418F6             0117*  ffs_ftell:			EQU	8Dh
0418F6             0118*  ffs_feof:			EQU	8Eh
0418F6             0119*  ffs_fsize:			EQU	8Fh
0418F6             0120*  ffs_ferror:			EQU	90h
0418F6             0121*  
0418F6             0122*  ; FatFS directory access functions
0418F6             0123*  ;
0418F6             0124*  ffs_dopen:			EQU	91h
0418F6             0125*  ffs_dclose:			EQU	92h
0418F6             0126*  ffs_dread:			EQU	93h
0418F6             0127*  ffs_dfindfirst:		EQU	94h
0418F6             0128*  ffs_dfindnext:		EQU	95h
0418F6             0129*  
0418F6             0130*  ; FatFS file and directory management functions
0418F6             0131*  ;
0418F6             0132*  ffs_stat:			EQU	96h
0418F6             0133*  ffs_unlink:			EQU	97h
0418F6             0134*  ffs_rename:			EQU	98h
0418F6             0135*  ffs_chmod:			EQU	99h
0418F6             0136*  ffs_utime:			EQU	9Ah
0418F6             0137*  ffs_mkdir:			EQU	9Bh
0418F6             0138*  ffs_chdir:			EQU	9Ch
0418F6             0139*  ffs_chdrive:		EQU	9Dh
0418F6             0140*  ffs_getcwd:			EQU	9Eh
0418F6             0141*  
0418F6             0142*  ; FatFS volume management and system configuration functions
0418F6             0143*  ;
0418F6             0144*  ffs_mount:			EQU	9Fh
0418F6             0145*  ffs_mkfs:			EQU	A0h
0418F6             0146*  ffs_fdisk:			EQU	A1h
0418F6             0147*  ffs_getfree:		EQU	A2h
0418F6             0148*  ffs_getlabel:		EQU	A3h
0418F6             0149*  ffs_setlabel:		EQU	A4h
0418F6             0150*  ffs_setcp:			EQU	A5h
0418F6             0151*  
0418F6             0152*  ; File access modes
0418F6             0153*  ;
0418F6             0154*  fa_read:			EQU	01h
0418F6             0155*  fa_write:			EQU	02h
0418F6             0156*  fa_open_existing:	EQU	00h
0418F6             0157*  fa_create_new:		EQU	04h
0418F6             0158*  fa_create_always:	EQU	08h
0418F6             0159*  fa_open_always:		EQU	10h
0418F6             0160*  fa_open_append:		EQU	30h
0418F6             0161*  
0418F6             0162*  ; System variable indexes for api_sysvars
0418F6             0163*  ; Index into _sysvars in globals.inc
0418F6             0164*  ;
0418F6             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0418F6             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0418F6             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0418F6             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0418F6             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0418F6             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0418F6             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0418F6             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0418F6             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0418F6             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0418F6             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0418F6             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0418F6             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0418F6             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0418F6             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0418F6             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0418F6             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0418F6             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0418F6             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0418F6             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0418F6             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0418F6             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0418F6             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0418F6             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0418F6             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0418F6             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0418F6             0191*  
0418F6             0192*  ; Flags for the VPD protocol
0418F6             0193*  ;
0418F6             0194*  vdp_pflag_cursor:		EQU	00000001b
0418F6             0195*  vdp_pflag_scrchar:		EQU	00000010b
0418F6             0196*  vdp_pflag_point:		EQU	00000100b
0418F6             0197*  vdp_pflag_audio:		EQU	00001000b
0418F6             0198*  vdp_pflag_mode:			EQU	00010000b
0418F6             0199*  vdp_pflag_rtc:			EQU	00100000b
0418F6             0200*  
0418F6             0201*  ;
0418F6             0202*  ; FatFS structures
0418F6             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0418F6             0204*  ;
0418F6             0205*  ; Object ID and allocation information (FFOBJID)
0418F6             0206*  ;
0418F6             0207*  ; Indexes into FFOBJID structure
0418F6             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0418F6             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0418F6             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0418F6             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0418F6             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0418F6             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0418F6             0214*  ;
0418F6             0215*  ; File object structure (FIL)
0418F6             0216*  ;
0418F6             0217*  ; Indexes into FIL structure
0418F6             0218*  fil_obj:		EQU 0	; 15: Object identifier
0418F6             0219*  fil_flag:		EQU	15 	;  1: File status flags
0418F6             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0418F6             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0418F6             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0418F6             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0418F6             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0418F6             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0418F6             0226*  ;
0418F6             0227*  ; Directory object structure (DIR)
0418F6             0228*  ; Indexes into DIR structure
0418F6             0229*  dir_obj:		EQU  0	; 15: Object identifier
0418F6             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0418F6             0231*  dir_clust:		EQU	19	;  4: Current cluster
0418F6             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0418F6             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0418F6             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0418F6             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0418F6             0236*  ;
0418F6             0237*  ; File information structure (FILINFO)
0418F6             0238*  ;
0418F6             0239*  ; Indexes into FILINFO structure
0418F6             0240*  filinfo_fsize:		EQU 0	;   4: File size
0418F6             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0418F6             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0418F6             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0418F6             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0418F6             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0418F6             0246*  ;
0418F6             0247*  ; Macro for calling the API
0418F6             0248*  ; Parameters:
0418F6             0249*  ; - function: One of the function numbers listed above
0418F6             0250*  ;
0418F6             0251*  	MACRO	MOSCALL	function
0418F6             0252*  			LD	A, function
0418F6             0253*  			RST.LIL	08h
0418F6             0254*  	ENDMACRO
0418F6             0052       include "functions.inc"
0418F6             0001*  
0418F6             0002*      MACRO printChar char
0418F6             0003*          LD A, char
0418F6             0004*          RST.LIL 10h
0418F6             0005*      ENDMACRO
0418F6             0006*  
0418F6             0007*  ; Simulated call to subroutine at HL
0418F6             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0418F6             0009*  ; outputs: whatever the subroutine does, including HL and BC
0418F6             0010*  ; destroys: only what the subroutine does, but always BC
0418F6             0011*      MACRO callHL
0418F6             0012*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0013*          push bc       ; which constitutes the return address
0418F6             0014*          jp   (hl)     ; Jump to the address in HL
0418F6             0015*      ENDMACRO
0418F6             0016*  
0418F6             0017*  ; Simulated call to subroutine at IX
0418F6             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0418F6             0019*  ; outputs: whatever the subroutine does, including IX and BC
0418F6             0020*  ; destroys: only what the subroutine does, but always BC
0418F6             0021*      MACRO callIX
0418F6             0022*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0023*          push bc       ; which constitutes the return address
0418F6             0024*          jp   (ix)     ; Jump to the address in IX
0418F6             0025*      ENDMACRO
0418F6             0026*  
0418F6             0027*  ; Simulated call to soubroutinte at IY
0418F6             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0418F6             0029*  ; outputs: whatever the subroutine does, including IY and BC
0418F6             0030*  ; destroys: only what the subroutine does, but always BC
0418F6             0031*      MACRO callIY
0418F6             0032*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0033*          push bc       ; which constitutes the return address
0418F6             0034*          jp   (iy)     ; Jump to the address in IY
0418F6             0035*      ENDMACRO
0418F6             0036*  
0418F6             0037*  ; put the value in HLU into the accumulator
0418F6             0038*  ; destroys: af
0418F6             0039*      MACRO HLU_TO_A
0418F6             0040*          push hl ; 4 cycles
0418F6             0041*          inc sp ; 1 cycle
0418F6             0042*          pop af  ; 4 cycles
0418F6             0043*          dec sp ; 1 cycle
0418F6             0044*                 ; 10 cycles total
0418F6             0045*      ENDMACRO
0418F6             0046*  
0418F6             0047*  A_TO_HLU:
0418F6             0048*      ; call is 7 cycles
0418F6 22 03 19 04 0049*      ld (@scratch),hl ; 7 cycles
0418FA 32 05 19 04 0050*      ld (@scratch+2),a ; 5 cycles
0418FE 2A 03 19 04 0051*      ld hl,(@scratch) ; 7 cycles
041902 C9          0052*      ret ; 6 cycles
041903             0053*          ; 25 cycles total
041903 00 00 00    0054*  @scratch: dl 0
041906             0055*  
041906             0056*      ; TODO: implement this
041906             0057*      ; MACRO A_TO_HLU
041906             0058*      ;     push.s af
041906             0059*      ;     inc sp
041906             0060*      ;     push.s hl
041906             0061*      ;     pop hl
041906             0062*      ;     inc sp
041906             0063*      ;     inc sp
041906             0064*      ; ENDMACRO
041906             0065*  
041906             0066*      MACRO PUSH_ALL
041906             0067*          ex af,af'
041906             0068*          exx
041906             0069*          push af
041906             0070*          push hl
041906             0071*          push bc
041906             0072*          push de
041906             0073*  
041906             0074*          ex af,af'
041906             0075*          exx
041906             0076*          push af
041906             0077*          push hl
041906             0078*          push bc
041906             0079*          push de
041906             0080*          push ix
041906             0081*          push iy
041906             0082*      ENDMACRO
041906             0083*  
041906             0084*      MACRO POP_ALL
041906             0085*          pop iy
041906             0086*          pop ix
041906             0087*          pop de
041906             0088*          pop bc
041906             0089*          pop hl
041906             0090*          pop af
041906             0091*          ex af,af'
041906             0092*          exx
041906             0093*  
041906             0094*          pop de
041906             0095*          pop bc
041906             0096*          pop hl
041906             0097*          pop af
041906             0098*          ex af,af'
041906             0099*          exx
041906             0100*      ENDMACRO
041906             0101*  
041906             0102*  ; Print a zero-terminated string inline with code, e.g.:
041906             0103*  ;
041906             0104*  ;    call printInline
041906             0105*  ;    ASCIZ "Hello, world!\r\n"
041906             0106*  ;
041906             0107*  ; Destroys: HL,AF
041906             0108*  printInline:
041906 E1          0109*      pop hl ; get the return address = pointer to start of string
041907 CD 0D 19 04 0110*      call printString ; HL advances to end of string
04190B E5          0111*      push hl ; restore the return address = pointer to end of string
04190C C9          0112*      ret
04190D             0113*  
04190D             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04190D             0115*  ; Print a zero-terminated string
04190D             0116*  ; HL: Pointer to string
04190D             0117*  printString:
04190D C5          0118*  	PUSH	BC
04190E 01 00 00 00 0119*  	LD		BC,0
041912 3E 00       0120*  	LD 	 	A,0
041914 5B DF       0121*  	RST.LIL 18h
041916 C1          0122*  	POP		BC
041917 C9          0123*  	RET
041918             0124*  ; print a VDU sequence
041918             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
041918             0126*  sendVDUsequence:
041918 C5          0127*  	PUSH	BC
041919 01 00 00 00 0128*  	LD		BC, 0
04191D 4E          0129*  	LD		C, (HL)
04191E 5B DF       0130*  	RST.LIL	18h
041920 C1          0131*  	POP		BC
041921 C9          0132*  	RET
041922             0133*  ; Print Newline sequence to VDP
041922             0134*  printNewLine:
041922 F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
041923 3E 0D       0136*  	LD	A, '\r'
041925 5B D7       0137*  	RST.LIL 10h
041927 3E 0A       0138*  	LD	A, '\n'
041929 5B D7       0139*  	RST.LIL 10h
04192B F1          0140*      pop af
04192C C9          0141*  	RET
04192D             0142*  
04192D             0143*  ; Print a 24-bit HEX number
04192D             0144*  ; HLU: Number to print
04192D             0145*  printHex24:
04192D             0146*      HLU_TO_A
04192D E5          0001*M         push hl ; 4 cycles
04192E 33          0002*M         inc sp ; 1 cycle
04192F F1          0003*M         pop af  ; 4 cycles
041930 3B          0004*M         dec sp ; 1 cycle
041931             0005*M                ; 10 cycles total
041931 CD 3B 19 04 0147*  	CALL	printHex8
041935             0148*  ; Print a 16-bit HEX number
041935             0149*  ; HL: Number to print
041935             0150*  printHex16:
041935 7C          0151*  	LD		A,H
041936 CD 3B 19 04 0152*  	CALL	printHex8
04193A 7D          0153*  	LD		A,L
04193B             0154*  ; Print an 8-bit HEX number
04193B             0155*  ; A: Number to print
04193B             0156*  printHex8:
04193B 4F          0157*  	LD		C,A
04193C 1F          0158*  	RRA
04193D 1F          0159*  	RRA
04193E 1F          0160*  	RRA
04193F 1F          0161*  	RRA
041940 CD 45 19 04 0162*  	CALL	@F
041944 79          0163*  	LD		A,C
041945             0164*  @@:
041945 E6 0F       0165*  	AND		0Fh
041947 C6 90       0166*  	ADD		A,90h
041949 27          0167*  	DAA
04194A CE 40       0168*  	ADC		A,40h
04194C 27          0169*  	DAA
04194D 5B D7       0170*  	RST.LIL	10h
04194F C9          0171*  	RET
041950             0172*  
041950             0173*  printHexA:
041950 F5          0174*      push af
041951 C5          0175*      push bc
041952 CD 3B 19 04 0176*      call printHex8
041956 3E 20       0177*      ld a,' '
041958 5B D7       0178*      rst.lil 10h
04195A C1          0179*      pop bc
04195B F1          0180*      pop af
04195C C9          0181*      ret
04195D             0182*  
04195D             0183*  printHexHL:
04195D F5          0184*      push af
04195E C5          0185*      push bc
04195F CD 35 19 04 0186*      call printHex16
041963 3E 20       0187*      ld a,' '
041965 5B D7       0188*      rst.lil 10h
041967 C1          0189*      pop bc
041968 F1          0190*      pop af
041969 C9          0191*      ret
04196A             0192*  
04196A             0193*  printHexUHL:
04196A F5          0194*      push af
04196B C5          0195*      push bc
04196C CD 2D 19 04 0196*      call printHex24
041970 3E 20       0197*      ld a,' '
041972 5B D7       0198*      rst.lil 10h
041974 C1          0199*      pop bc
041975 F1          0200*      pop af
041976 C9          0201*      ret
041977             0202*  
041977             0203*  printHexAUHL:
041977 F5          0204*      push af
041978 C5          0205*      push bc
041979 CD 3B 19 04 0206*      call printHex8
04197D 3E 2E       0207*      ld a,'.'
04197F 5B D7       0208*      rst.lil 10h
041981 CD 2D 19 04 0209*      call printHex24
041985 3E 20       0210*      ld a,' '
041987 5B D7       0211*      rst.lil 10h
041989 C1          0212*      pop bc
04198A F1          0213*      pop af
04198B C9          0214*      ret
04198C             0215*  
04198C             0216*  printHexABHL:
04198C             0217*  ; preserve registers
04198C C5          0218*      push bc ; b will be ok c will not
04198D F5          0219*      push af ; will get totally destroyed
04198E             0220*  ; print a
04198E CD 3B 19 04 0221*      call printHex8
041992             0222*  ; print b
041992 78          0223*      ld a,b
041993 CD 3B 19 04 0224*      call printHex8
041997             0225*  ; print hl
041997 CD 35 19 04 0226*      call printHex16
04199B             0227*  ; restore registers
04199B F1          0228*      pop af
04199C C1          0229*      pop bc
04199D C9          0230*      ret
04199E             0231*  
04199E             0232*  printHexBHL:
04199E             0233*  ; preserve registers
04199E C5          0234*      push bc ; b will be ok c will not
04199F F5          0235*      push af ; will get totally destroyed
0419A0             0236*  ; print b
0419A0 78          0237*      ld a,b
0419A1 CD 3B 19 04 0238*      call printHex8
0419A5             0239*  ; print hl
0419A5 CD 35 19 04 0240*      call printHex16
0419A9             0241*  ; restore registers
0419A9 F1          0242*      pop af
0419AA C1          0243*      pop bc
0419AB C9          0244*      ret
0419AC             0245*  
0419AC             0246*  printHexCDE:
0419AC             0247*  ; preserve registers
0419AC C5          0248*      push bc ; b will be ok c will not
0419AD F5          0249*      push af ; will get totally destroyed
0419AE             0250*  ; print c
0419AE 79          0251*      ld a,c
0419AF CD 3B 19 04 0252*      call printHex8
0419B3             0253*  ; print de
0419B3 EB          0254*      ex de,hl
0419B4 CD 35 19 04 0255*      call printHex16
0419B8 EB          0256*      ex de,hl
0419B9             0257*  ; restore registers
0419B9 F1          0258*      pop af
0419BA C1          0259*      pop bc
0419BB C9          0260*      ret
0419BC             0261*  
0419BC             0262*  printHexUIX:
0419BC             0263*  ; store everything in scratch
0419BC 22 35 1E 04 0264*      ld (uhl),hl
0419C0 ED 43 38 1E 0265*      ld (ubc),bc
       04          
0419C5 ED 53 3B 1E 0266*      ld (ude),de
       04          
0419CA DD 22 3E 1E 0267*      ld (uix),ix
       04          
0419CF FD 22 41 1E 0268*      ld (uiy),iy
       04          
0419D4 F5          0269*      push af ; fml
0419D5             0270*  
0419D5 21 CC 1D 04 0271*      ld hl,str_ixu
0419D9 CD 0D 19 04 0272*      call printString
0419DD 2A 3E 1E 04 0273*      ld hl,(uix)
0419E1 CD 2D 19 04 0274*      call printHex24
0419E5 CD 22 19 04 0275*      call printNewLine
0419E9             0276*  
0419E9             0277*  ; restore everything
0419E9 2A 35 1E 04 0278*      ld hl, (uhl)
0419ED ED 4B 38 1E 0279*      ld bc, (ubc)
       04          
0419F2 ED 5B 3B 1E 0280*      ld de, (ude)
       04          
0419F7 DD 2A 3E 1E 0281*      ld ix, (uix)
       04          
0419FC FD 2A 41 1E 0282*      ld iy, (uiy)
       04          
041A01 F1          0283*      pop af
041A02             0284*  ; all done
041A02 C9          0285*      ret
041A03             0286*  
041A03             0287*  ; Print a 0x HEX prefix
041A03             0288*  DisplayHexPrefix:
041A03 3E 30       0289*  	LD	A, '0'
041A05 5B D7       0290*  	RST.LIL 10h
041A07 3E 78       0291*  	LD	A, 'x'
041A09 5B D7       0292*  	RST.LIL 10h
041A0B C9          0293*  	RET
041A0C             0294*  
041A0C             0295*      MACRO printDecBC
041A0C             0296*          push hl
041A0C             0297*          push bc
041A0C             0298*          pop hl
041A0C             0299*          call printDec
041A0C             0300*          pop hl
041A0C             0301*      ENDMACRO
041A0C             0302*  
041A0C             0303*      MACRO printDecDE
041A0C             0304*          push hl
041A0C             0305*          push de
041A0C             0306*          pop hl
041A0C             0307*          call printDec
041A0C             0308*          pop hl
041A0C             0309*      ENDMACRO
041A0C             0310*  
041A0C             0311*      MACRO printDecHL
041A0C             0312*          call printDec
041A0C             0313*      ENDMACRO
041A0C             0314*  
041A0C             0315*      MACRO printDecIX
041A0C             0316*          push hl
041A0C             0317*          push ix
041A0C             0318*          pop hl
041A0C             0319*          call printDec
041A0C             0320*          pop hl
041A0C             0321*      ENDMACRO
041A0C             0322*  
041A0C             0323*      MACRO printDecIY
041A0C             0324*          push hl
041A0C             0325*          push iy
041A0C             0326*          pop hl
041A0C             0327*          call printDec
041A0C             0328*          pop hl
041A0C             0329*      ENDMACRO
041A0C             0330*  
041A0C             0331*  
041A0C             0332*  ; Prints the right justified decimal value in HL without leading zeroes
041A0C             0333*  ; HL : Value to print
041A0C             0334*  ; preserves all registers and flags
041A0C             0335*  printDec:
041A0C             0336*  ; BEGIN MY CODE
041A0C             0337*  ; back up all the things
041A0C F5          0338*      push af
041A0D C5          0339*      push bc
041A0E D5          0340*      push de
041A0F E5          0341*      push hl
041A10             0342*  ; END MY CODE
041A10 11 38 1A 04 0343*  	LD	 DE, _printDecBuffer
041A14 CD 48 1A 04 0344*  	CALL u24_to_ascii
041A18             0345*  ; BEGIN MY CODE
041A18             0346*  ; replace leading zeroes with spaces
041A18 21 38 1A 04 0347*      LD	 HL, _printDecBuffer
041A1C 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
041A1E             0349*  @loop:
041A1E 7E          0350*      LD	 A, (HL)
041A1F FE 30       0351*      CP	 '0'
041A21 C2 2B 1A 04 0352*      JP	 NZ, @done
041A25 3E 20       0353*      LD   A, ' '
041A27 77          0354*      LD	 (HL), A
041A28 23          0355*      INC	 HL
041A29             0356*      ; CALL vdu_cursor_forward
041A29 10 F3       0357*      DJNZ @loop
041A2B             0358*  @done:
041A2B             0359*  ; END MY CODE
041A2B 21 38 1A 04 0360*  	LD	 HL, _printDecBuffer
041A2F CD 0D 19 04 0361*  	CALL printString
041A33             0362*  ; BEGIN MY CODE
041A33             0363*  ; restore all the things
041A33 E1          0364*      pop hl
041A34 D1          0365*      pop de
041A35 C1          0366*      pop bc
041A36 F1          0367*      pop af
041A37             0368*  ; END MY CODE
041A37 C9          0369*  	RET
041A38 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A48             0371*  
041A48             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
041A48             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041A48             0374*  ; so it will allways be 8 characters length
041A48             0375*  ; HL : Value to convert to string
041A48             0376*  ; DE : pointer to buffer, at least 8 byte + 0
041A48             0377*  u24_to_ascii:
041A48 01 80 69 67 0378*  	LD	 BC,-10000000
041A4C CD 7F 1A 04 0379*  	CALL @one_digit
041A50 01 C0 BD F0 0380*  	LD	 BC,-1000000
041A54 CD 7F 1A 04 0381*  	CALL @one_digit
041A58 01 60 79 FE 0382*  	LD	 BC,-100000
041A5C CD 7F 1A 04 0383*  	CALL @one_digit
041A60 01 F0 D8 FF 0384*  	LD   BC,-10000
041A64 CD 7F 1A 04 0385*  	CALL @one_digit
041A68 01 18 FC FF 0386*  	LD   BC,-1000
041A6C CD 7F 1A 04 0387*  	CALL @one_digit
041A70 01 9C FF FF 0388*  	LD   BC,-100
041A74 CD 7F 1A 04 0389*  	CALL @one_digit
041A78 0E F6       0390*  	LD   C,-10
041A7A CD 7F 1A 04 0391*  	CALL @one_digit
041A7E 48          0392*  	LD   C,B
041A7F             0393*  @one_digit:
041A7F 3E 2F       0394*  	LD   A,'0'-1
041A81             0395*  @divide_me:
041A81 3C          0396*  	INC  A
041A82 09          0397*  	ADD  HL,BC
041A83 38 FC       0398*  	JR   C,@divide_me
041A85 ED 42       0399*  	SBC  HL,BC
041A87 12          0400*  	LD   (DE),A
041A88 13          0401*  	INC  DE
041A89 C9          0402*  	RET
041A8A             0403*  
041A8A             0404*  print_u24:
041A8A D5          0405*      push de
041A8B E5          0406*      push hl
041A8C 11 38 1A 04 0407*      ld de,_printDecBuffer
041A90 CD 48 1A 04 0408*      call u24_to_ascii
041A94 21 38 1A 04 0409*      ld hl,_printDecBuffer
041A98 CD 0D 19 04 0410*      call printString
041A9C 3E 20       0411*      ld a,' '
041A9E 5B D7       0412*      rst.lil 10h
041AA0 E1          0413*      pop hl
041AA1 D1          0414*      pop de
041AA2 C9          0415*      ret
041AA3             0416*  
041AA3             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
041AA3             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
041AA3             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
041AA3             0420*  u168_to_ascii:
041AA3             0421*  ; add a leading space to make room for sign flag if needed
041AA3 3E 20       0422*      ld a,' '
041AA5 12          0423*      ld (de),a
041AA6 13          0424*      inc de
041AA7             0425*  ; Convert integer part
041AA7 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
041AA8 CD 9D 25 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
041AAC 01 F0 D8 FF 0428*      ld   bc, -10000
041AB0 CD D3 1A 04 0429*      call @one_int
041AB4 01 18 FC FF 0430*      ld   bc, -1000
041AB8 CD D3 1A 04 0431*      call @one_int
041ABC 01 9C FF FF 0432*      ld   bc, -100
041AC0 CD D3 1A 04 0433*      call @one_int
041AC4 0E F6       0434*      ld   c, -10
041AC6 CD D3 1A 04 0435*      call @one_int
041ACA 48          0436*      ld   c, b
041ACB CD D3 1A 04 0437*      call @one_int
041ACF C3 DE 1A 04 0438*      jp   @frac            ; Jump to fractional part conversion
041AD3             0439*  @one_int:
041AD3 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
041AD5             0441*  @divide_me:
041AD5 3C          0442*      inc  a
041AD6 09          0443*      add  hl, bc           ; Accumulate until overflow
041AD7 38 FC       0444*      jr   c, @divide_me
041AD9 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
041ADB 12          0446*      ld   (de), a          ; Store ASCII digit
041ADC 13          0447*      inc  de
041ADD C9          0448*      ret
041ADE             0449*  ; Convert fractional part
041ADE             0450*  @frac:
041ADE 3E 2E       0451*      ld   a, '.'           ; Decimal point
041AE0 12          0452*      ld   (de), a
041AE1 13          0453*      inc  de
041AE2 E1          0454*      pop  hl               ; Restore HL with original fraction
041AE3 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
041AE5             0456*  @frac_loop:
041AE5 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
041AE7 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
041AE9 3E 30       0459*      ld   a, '0'
041AEB 84          0460*      add  a, h             ; Convert integer part to ASCII
041AEC 12          0461*      ld   (de), a
041AED 13          0462*      inc  de
041AEE 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
041AF0             0464*  ; Add null terminator
041AF0 AF          0465*      xor  a                ; Null terminator
041AF1 12          0466*      ld   (de), a
041AF2 C9          0467*      ret
041AF3             0468*  
041AF3             0469*  print_u168:
041AF3 D5          0470*      push de
041AF4 E5          0471*      push hl
041AF5 11 38 1A 04 0472*      ld de,_printDecBuffer
041AF9 CD A3 1A 04 0473*      call u168_to_ascii
041AFD 21 38 1A 04 0474*      ld hl,_printDecBuffer
041B01 CD 0D 19 04 0475*      call printString
041B05 E1          0476*      pop hl
041B06 D1          0477*      pop de
041B07 C9          0478*      ret
041B08             0479*  
041B08             0480*  ; signed version of u168_to_ascii
041B08             0481*  s168_to_ascii:
041B08 D5          0482*      push de ; save starting address of buffer
041B09 CD 36 25 04 0483*      call hlu_abs
041B0D F5          0484*      push af ; save sign flag
041B0E CD A3 1A 04 0485*      call u168_to_ascii
041B12 F1          0486*      pop af ; restore sign flag
041B13 D1          0487*      pop de ; restore starting address of buffer
041B14 F0          0488*      ret p ; hlu was positive so nothing to do
041B15 3E 2D       0489*      ld a,'-'
041B17 12          0490*      ld (de),a
041B18 C9          0491*      ret
041B19             0492*  
041B19             0493*  print_s168:
041B19 D5          0494*      push de
041B1A E5          0495*      push hl
041B1B 11 38 1A 04 0496*      ld de,_printDecBuffer
041B1F CD 08 1B 04 0497*      call s168_to_ascii
041B23 21 38 1A 04 0498*      ld hl,_printDecBuffer
041B27 CD 0D 19 04 0499*      call printString
041B2B E1          0500*      pop hl
041B2C D1          0501*      pop de
041B2D C9          0502*      ret
041B2E             0503*  
041B2E             0504*  print_s168_hl:
041B2E F5          0505*      push af
041B2F E5          0506*      push hl
041B30 CD 19 1B 04 0507*      call print_s168
041B34 3E 20       0508*      ld a,' '
041B36 5B D7       0509*      rst.lil 10h
041B38 E1          0510*      pop hl
041B39 F1          0511*      pop af
041B3A C9          0512*      ret
041B3B             0513*  
041B3B             0514*  print_s168_bc:
041B3B F5          0515*      push af
041B3C C5          0516*      push bc
041B3D E5          0517*      push hl
041B3E C5          0518*      push bc
041B3F E1          0519*      pop hl
041B40 CD 19 1B 04 0520*      call print_s168
041B44 3E 20       0521*      ld a,' '
041B46 5B D7       0522*      rst.lil 10h
041B48 E1          0523*      pop hl
041B49 C1          0524*      pop bc
041B4A F1          0525*      pop af
041B4B C9          0526*      ret
041B4C             0527*  
041B4C             0528*  print_s168_de:
041B4C F5          0529*      push af
041B4D D5          0530*      push de
041B4E E5          0531*      push hl
041B4F EB          0532*      ex de,hl
041B50 CD 19 1B 04 0533*      call print_s168
041B54 3E 20       0534*      ld a,' '
041B56 5B D7       0535*      rst.lil 10h
041B58 E1          0536*      pop hl
041B59 D1          0537*      pop de
041B5A F1          0538*      pop af
041B5B C9          0539*      ret
041B5C             0540*  
041B5C             0541*  print_s168_hl_bc_de:
041B5C F5          0542*      push af
041B5D C5          0543*      push bc
041B5E D5          0544*      push de
041B5F E5          0545*      push hl
041B60 CD 19 1B 04 0546*      call print_s168
041B64 3E 20       0547*      ld a,' '
041B66 5B D7       0548*      rst.lil 10h
041B68 C5          0549*      push bc
041B69 E1          0550*      pop hl
041B6A CD 19 1B 04 0551*      call print_s168
041B6E 3E 20       0552*      ld a,' '
041B70 5B D7       0553*      rst.lil 10h
041B72 EB          0554*      ex de,hl
041B73 CD 19 1B 04 0555*      call print_s168
041B77 3E 20       0556*      ld a,' '
041B79 5B D7       0557*      rst.lil 10h
041B7B E1          0558*      pop hl
041B7C D1          0559*      pop de
041B7D C1          0560*      pop bc
041B7E F1          0561*      pop af
041B7F C9          0562*      ret
041B80             0563*  
041B80             0564*  print_s168_bc_de:
041B80 F5          0565*      push af
041B81 C5          0566*      push bc
041B82 D5          0567*      push de
041B83 C5          0568*      push bc
041B84 E1          0569*      pop hl
041B85 CD 19 1B 04 0570*      call print_s168
041B89 3E 20       0571*      ld a,' '
041B8B 5B D7       0572*      rst.lil 10h
041B8D EB          0573*      ex de,hl
041B8E CD 19 1B 04 0574*      call print_s168
041B92 3E 20       0575*      ld a,' '
041B94 5B D7       0576*      rst.lil 10h
041B96 E1          0577*      pop hl
041B97 D1          0578*      pop de
041B98 C1          0579*      pop bc
041B99 F1          0580*      pop af
041B9A C9          0581*      ret
041B9B             0582*  
041B9B             0583*  print_s168_a:
041B9B F5          0584*      push af
041B9C C5          0585*      push bc
041B9D E5          0586*      push hl
041B9E 21 00 00 00 0587*      ld hl,0
041BA2 6F          0588*      ld l,a
041BA3 CD 2E 1B 04 0589*      call print_s168_hl
041BA7 E1          0590*      pop hl
041BA8 C1          0591*      pop bc
041BA9 F1          0592*      pop af
041BAA C9          0593*      ret
041BAB             0594*  
041BAB             0595*  ; #### new functions added by Brandon R. Gates ####
041BAB             0596*  
041BAB             0597*  ; print the binary representation of the 8-bit value in a
041BAB             0598*  ; destroys a, hl, bc
041BAB             0599*  printBin8:
041BAB 06 08       0600*      ld b,8      ; loop counter for 8 bits
041BAD 21 C8 1B 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
041BB1             0602*                  ; (which will be the high bit of the value in a)
041BB1             0603*  @loop:
041BB1 07          0604*      rlca ; put the next highest bit into carry
041BB2 38 04       0605*      jr c,@one
041BB4 36 30       0606*      ld (hl),'0'
041BB6 18 02       0607*      jr @next_bit
041BB8             0608*  @one:
041BB8 36 31       0609*      ld (hl),'1'
041BBA             0610*  @next_bit:
041BBA 23          0611*      inc hl
041BBB 10 F4       0612*      djnz @loop
041BBD             0613*  ; print it
041BBD 21 C8 1B 04 0614*  	ld hl,@cmd
041BC1 01 08 00 00 0615*  	ld bc,@end-@cmd
041BC5 5B DF       0616*  	rst.lil $18
041BC7 C9          0617*  	ret
041BC8             0618*  @cmd: ds 8 ; eight bytes for eight bits
041BD0             0619*  @end:
041BD0             0620*  
041BD0             0621*  ; print the binary representation of the 8-bit value in a
041BD0             0622*  ; in reverse order (lsb first)
041BD0             0623*  ; destroys a, hl, bc
041BD0             0624*  printBin8Rev:
041BD0 06 08       0625*      ld b,8      ; loop counter for 8 bits
041BD2 21 ED 1B 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
041BD6             0627*                  ; (which will be the high bit of the value in a)
041BD6             0628*  @loop:
041BD6 0F          0629*      rrca ; put the next lowest bit into carry
041BD7 38 04       0630*      jr c,@one
041BD9 36 30       0631*      ld (hl),'0'
041BDB 18 02       0632*      jr @next_bit
041BDD             0633*  @one:
041BDD 36 31       0634*      ld (hl),'1'
041BDF             0635*  @next_bit:
041BDF 23          0636*      inc hl
041BE0 10 F4       0637*      djnz @loop
041BE2             0638*  ; print it
041BE2 21 ED 1B 04 0639*  	ld hl,@cmd
041BE6 01 08 00 00 0640*  	ld bc,@end-@cmd
041BEA 5B DF       0641*  	rst.lil $18
041BEC C9          0642*  	ret
041BED             0643*  @cmd: ds 8 ; eight bytes for eight bits
041BF5             0644*  @end:
041BF5             0645*  
041BF5             0646*  ; print registers to screen in hexidecimal format
041BF5             0647*  ; inputs: none
041BF5             0648*  ; outputs: values of every register printed to screen
041BF5             0649*  ;    values of each register in global scratch memory
041BF5             0650*  ; destroys: nothing
041BF5             0651*  stepRegistersHex:
041BF5             0652*  ; store everything in scratch
041BF5 22 35 1E 04 0653*      ld (uhl),hl
041BF9 ED 43 38 1E 0654*      ld (ubc),bc
       04          
041BFE ED 53 3B 1E 0655*      ld (ude),de
       04          
041C03 DD 22 3E 1E 0656*      ld (uix),ix
       04          
041C08 FD 22 41 1E 0657*      ld (uiy),iy
       04          
041C0D F5          0658*      push af ; fml
041C0E E1          0659*      pop hl  ; thanks, zilog
041C0F 22 32 1E 04 0660*      ld (uaf),hl
041C13 F5          0661*      push af ; dammit
041C14             0662*  
041C14             0663*  ; home the cursor
041C14             0664*      ; call vdu_home_cursor
041C14             0665*  
041C14             0666*  ; print each register
041C14 21 B8 1D 04 0667*      ld hl,str_afu
041C18 CD 0D 19 04 0668*      call printString
041C1C 2A 32 1E 04 0669*      ld hl,(uaf)
041C20 CD 2D 19 04 0670*      call printHex24
041C24 CD 22 19 04 0671*      call printNewLine
041C28             0672*  
041C28 21 BD 1D 04 0673*      ld hl,str_hlu
041C2C CD 0D 19 04 0674*      call printString
041C30 2A 35 1E 04 0675*      ld hl,(uhl)
041C34 CD 2D 19 04 0676*      call printHex24
041C38 CD 22 19 04 0677*      call printNewLine
041C3C             0678*  
041C3C 21 C2 1D 04 0679*      ld hl,str_bcu
041C40 CD 0D 19 04 0680*      call printString
041C44 2A 38 1E 04 0681*      ld hl,(ubc)
041C48 CD 2D 19 04 0682*      call printHex24
041C4C CD 22 19 04 0683*      call printNewLine
041C50             0684*  
041C50 21 C7 1D 04 0685*      ld hl,str_deu
041C54 CD 0D 19 04 0686*      call printString
041C58 2A 3B 1E 04 0687*      ld hl,(ude)
041C5C CD 2D 19 04 0688*      call printHex24
041C60 CD 22 19 04 0689*      call printNewLine
041C64             0690*  
041C64 21 CC 1D 04 0691*      ld hl,str_ixu
041C68 CD 0D 19 04 0692*      call printString
041C6C 2A 3E 1E 04 0693*      ld hl,(uix)
041C70 CD 2D 19 04 0694*      call printHex24
041C74 CD 22 19 04 0695*      call printNewLine
041C78             0696*  
041C78 21 D1 1D 04 0697*      ld hl,str_iyu
041C7C CD 0D 19 04 0698*      call printString
041C80 2A 41 1E 04 0699*      ld hl,(uiy)
041C84 CD 2D 19 04 0700*      call printHex24
041C88 CD 22 19 04 0701*      call printNewLine
041C8C             0702*  
041C8C             0703*      ; call vsync
041C8C             0704*  
041C8C CD 22 19 04 0705*      call printNewLine
041C90             0706*  
041C90             0707*  ; check for right shift key and quit if pressed
041C90             0708*  	MOSCALL mos_getkbmap
041C90 3E 1E       0001*M 			LD	A, function
041C92 5B CF       0002*M 			RST.LIL	08h
041C94             0709*  @stayhere:
041C94             0710*  ; 7 RightShift
041C94 DD CB 00 76 0711*      bit 6,(ix+0)
041C98 20 02       0712*      jr nz,@RightShift
041C9A 18 F8       0713*      jr @stayhere
041C9C             0714*  @RightShift:
041C9C DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
041CA0 3E 80       0716*      ld a,%10000000
041CA2             0717*      ; call multiPurposeDelay
041CA2             0718*  
041CA2             0719*  ; restore everything
041CA2 2A 35 1E 04 0720*      ld hl, (uhl)
041CA6 ED 4B 38 1E 0721*      ld bc, (ubc)
       04          
041CAB ED 5B 3B 1E 0722*      ld de, (ude)
       04          
041CB0 DD 2A 3E 1E 0723*      ld ix, (uix)
       04          
041CB5 FD 2A 41 1E 0724*      ld iy, (uiy)
       04          
041CBA F1          0725*      pop af
041CBB             0726*  ; all done
041CBB C9          0727*      ret
041CBC             0728*  
041CBC             0729*  ; print registers to screen in hexidecimal format
041CBC             0730*  ; inputs: none
041CBC             0731*  ; outputs: values of every register printed to screen
041CBC             0732*  ;    values of each register in global scratch memory
041CBC             0733*  ; destroys: nothing
041CBC             0734*  dumpRegistersHex:
041CBC             0735*  ; store everything in scratch
041CBC 22 35 1E 04 0736*      ld (uhl),hl
041CC0 ED 43 38 1E 0737*      ld (ubc),bc
       04          
041CC5 ED 53 3B 1E 0738*      ld (ude),de
       04          
041CCA DD 22 3E 1E 0739*      ld (uix),ix
       04          
041CCF FD 22 41 1E 0740*      ld (uiy),iy
       04          
041CD4 F5          0741*      push af ; fml
041CD5 E1          0742*      pop hl  ; thanks, zilog
041CD6 22 32 1E 04 0743*      ld (uaf),hl
041CDA F5          0744*      push af ; dammit
041CDB             0745*  
041CDB             0746*  ; home the cursor
041CDB             0747*      ; call vdu_home_cursor
041CDB             0748*      ; call printNewLine
041CDB             0749*  
041CDB             0750*  ; print each register
041CDB 21 B8 1D 04 0751*      ld hl,str_afu
041CDF CD 0D 19 04 0752*      call printString
041CE3 2A 32 1E 04 0753*      ld hl,(uaf)
041CE7 CD 2D 19 04 0754*      call printHex24
041CEB             0755*      ; call printNewLine
041CEB             0756*  
041CEB 21 BD 1D 04 0757*      ld hl,str_hlu
041CEF CD 0D 19 04 0758*      call printString
041CF3 2A 35 1E 04 0759*      ld hl,(uhl)
041CF7 CD 2D 19 04 0760*      call printHex24
041CFB             0761*      ; call printNewLine
041CFB             0762*  
041CFB 21 C2 1D 04 0763*      ld hl,str_bcu
041CFF CD 0D 19 04 0764*      call printString
041D03 2A 38 1E 04 0765*      ld hl,(ubc)
041D07 CD 2D 19 04 0766*      call printHex24
041D0B             0767*      ; call printNewLine
041D0B             0768*  
041D0B 21 C7 1D 04 0769*      ld hl,str_deu
041D0F CD 0D 19 04 0770*      call printString
041D13 2A 3B 1E 04 0771*      ld hl,(ude)
041D17 CD 2D 19 04 0772*      call printHex24
041D1B             0773*      ; call printNewLine
041D1B             0774*  
041D1B 21 CC 1D 04 0775*      ld hl,str_ixu
041D1F CD 0D 19 04 0776*      call printString
041D23 2A 3E 1E 04 0777*      ld hl,(uix)
041D27 CD 2D 19 04 0778*      call printHex24
041D2B             0779*      ; call printNewLine
041D2B             0780*  
041D2B 21 D1 1D 04 0781*      ld hl,str_iyu
041D2F CD 0D 19 04 0782*      call printString
041D33 2A 41 1E 04 0783*      ld hl,(uiy)
041D37 CD 2D 19 04 0784*      call printHex24
041D3B             0785*      ; call printNewLine
041D3B             0786*  
041D3B             0787*      ; call vdu_vblank
041D3B             0788*  
041D3B CD 22 19 04 0789*      call printNewLine
041D3F             0790*  ; restore everything
041D3F 2A 35 1E 04 0791*      ld hl, (uhl)
041D43 ED 4B 38 1E 0792*      ld bc, (ubc)
       04          
041D48 ED 5B 3B 1E 0793*      ld de, (ude)
       04          
041D4D DD 2A 3E 1E 0794*      ld ix, (uix)
       04          
041D52 FD 2A 41 1E 0795*      ld iy, (uiy)
       04          
041D57 F1          0796*      pop af
041D58             0797*  ; all done
041D58 C9          0798*      ret
041D59             0799*  
041D59             0800*  dumpRegistersHexPrime:
041D59 D9          0801*      exx
041D5A 08          0802*      ex af,af'
041D5B CD BC 1C 04 0803*      call dumpRegistersHex
041D5F 08          0804*      ex af,af'
041D60 D9          0805*      exx
041D61 C9          0806*      ret
041D62             0807*  
041D62             0808*  ; additionally dump prime registers
041D62             0809*  ; inputs: none
041D62             0810*  ; outputs: values of every register printed to screen
041D62             0811*  ; destroys: nothing
041D62             0812*  dumpRegistersHexAll:
041D62 CD BC 1C 04 0813*      call dumpRegistersHex
041D66 08          0814*      ex af,af'
041D67 D9          0815*      exx
041D68 CD BC 1C 04 0816*      call dumpRegistersHex
041D6C 08          0817*      ex af,af'
041D6D D9          0818*      exx
041D6E C9          0819*      ret
041D6F             0820*  
041D6F             0821*  ; print hlu to screen in hexidecimal format
041D6F             0822*  ; inputs: none
041D6F             0823*  ; destroys: nothing
041D6F             0824*  print_hex_hl:
041D6F F5          0825*      push af
041D70 E5          0826*      push hl
041D71 21 BD 1D 04 0827*      ld hl,str_hlu
041D75 CD 0D 19 04 0828*      call printString
041D79 E1          0829*      pop hl
041D7A E5          0830*      push hl
041D7B CD 2D 19 04 0831*      call printHex24
041D7F 3E 20       0832*      ld a,' '
041D81 5B D7       0833*      rst.lil 10h
041D83 E1          0834*      pop hl
041D84 F1          0835*      pop af
041D85 C9          0836*      ret
041D86             0837*  
041D86             0838*  ; print bcu to screen in hexidecimal format
041D86             0839*  ; inputs: none
041D86             0840*  ; destroys: nothing
041D86             0841*  print_hex_bc:
041D86 F5          0842*      push af
041D87 E5          0843*      push hl
041D88 C5          0844*      push bc
041D89 21 C2 1D 04 0845*      ld hl,str_bcu
041D8D CD 0D 19 04 0846*      call printString
041D91 E1          0847*      pop hl
041D92 E5          0848*      push hl
041D93 CD 2D 19 04 0849*      call printHex24
041D97 3E 20       0850*      ld a,' '
041D99 5B D7       0851*      rst.lil 10h
041D9B C1          0852*      pop bc
041D9C E1          0853*      pop hl
041D9D F1          0854*      pop af
041D9E C9          0855*      ret
041D9F             0856*  
041D9F             0857*  ; print deu to screen in hexidecimal format
041D9F             0858*  ; inputs: none
041D9F             0859*  ; destroys: nothing
041D9F             0860*  print_hex_de:
041D9F F5          0861*      push af
041DA0 E5          0862*      push hl
041DA1 D5          0863*      push de
041DA2 21 C7 1D 04 0864*      ld hl,str_deu
041DA6 CD 0D 19 04 0865*      call printString
041DAA E1          0866*      pop hl
041DAB E5          0867*      push hl
041DAC CD 2D 19 04 0868*      call printHex24
041DB0 3E 20       0869*      ld a,' '
041DB2 5B D7       0870*      rst.lil 10h
041DB4 D1          0871*      pop de
041DB5 E1          0872*      pop hl
041DB6 F1          0873*      pop af
041DB7 C9          0874*      ret
041DB8             0875*  
041DB8 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
041DBD 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
041DC2 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
041DC7 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
041DCC 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
041DD1 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
041DD6             0882*  
041DD6             0883*  ; print udeuhl to screen in hexidecimal format
041DD6             0884*  ; inputs: none
041DD6             0885*  ; outputs: concatenated hexidecimal udeuhl
041DD6             0886*  ; destroys: nothing
041DD6             0887*  dumpUDEUHLHex:
041DD6             0888*  ; store everything in scratch
041DD6 22 35 1E 04 0889*      ld (uhl),hl
041DDA ED 43 38 1E 0890*      ld (ubc),bc
       04          
041DDF ED 53 3B 1E 0891*      ld (ude),de
       04          
041DE4 DD 22 3E 1E 0892*      ld (uix),ix
       04          
041DE9 FD 22 41 1E 0893*      ld (uiy),iy
       04          
041DEE F5          0894*      push af
041DEF             0895*  
041DEF             0896*  ; print each register
041DEF             0897*  
041DEF 21 29 1E 04 0898*      ld hl,str_udeuhl
041DF3 CD 0D 19 04 0899*      call printString
041DF7 2A 3B 1E 04 0900*      ld hl,(ude)
041DFB CD 2D 19 04 0901*      call printHex24
041DFF 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
041E01 5B D7       0903*  	rst.lil 10h
041E03 2A 35 1E 04 0904*      ld hl,(uhl)
041E07 CD 2D 19 04 0905*      call printHex24
041E0B CD 22 19 04 0906*      call printNewLine
041E0F             0907*  
041E0F             0908*  ; restore everything
041E0F 2A 35 1E 04 0909*      ld hl, (uhl)
041E13 ED 4B 38 1E 0910*      ld bc, (ubc)
       04          
041E18 ED 5B 3B 1E 0911*      ld de, (ude)
       04          
041E1D DD 2A 3E 1E 0912*      ld ix, (uix)
       04          
041E22 FD 2A 41 1E 0913*      ld iy, (uiy)
       04          
041E27 F1          0914*      pop af
041E28             0915*  ; all done
041E28 C9          0916*      ret
041E29             0917*  
041E29 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041E32             0919*  
041E32             0920*  ; global scratch memory for registers
041E32 00 00 00    0921*  uaf: dl 0
041E35 00 00 00    0922*  uhl: dl 0
041E38 00 00 00    0923*  ubc: dl 0
041E3B 00 00 00    0924*  ude: dl 0
041E3E 00 00 00    0925*  uix: dl 0
041E41 00 00 00    0926*  uiy: dl 0
041E44 00 00 00    0927*  usp: dl 0
041E47 00 00 00    0928*  upc: dl 0
041E4A             0929*  
041E4A             0930*  ; inputs: whatever is in the flags register
041E4A             0931*  ; outputs: binary representation of flags
041E4A             0932*  ;          with a header so we know which is what
041E4A             0933*  ; destroys: nothing
041E4A             0934*  ; preserves: everything
041E4A             0935*  dumpFlags:
041E4A             0936*  ; first we curse zilog for not giving direct access to flags
041E4A F5          0937*      push af ; this is so we can send it back unharmed
041E4B F5          0938*      push af ; this is so we can pop it to hl
041E4C             0939*  ; store everything in scratch
041E4C 22 35 1E 04 0940*      ld (uhl),hl
041E50 ED 43 38 1E 0941*      ld (ubc),bc
       04          
041E55 ED 53 3B 1E 0942*      ld (ude),de
       04          
041E5A DD 22 3E 1E 0943*      ld (uix),ix
       04          
041E5F FD 22 41 1E 0944*      ld (uiy),iy
       04          
041E64             0945*  ; next we print the header
041E64 21 90 1E 04 0946*      ld hl,@header
041E68 CD 0D 19 04 0947*      call printString
041E6C E1          0948*      pop hl ; flags are now in l
041E6D 7D          0949*      ld a,l ; flags are now in a
041E6E CD AB 1B 04 0950*      call printBin8
041E72 CD 22 19 04 0951*  	call printNewLine
041E76             0952*  ; restore everything
041E76 2A 35 1E 04 0953*      ld hl, (uhl)
041E7A ED 4B 38 1E 0954*      ld bc, (ubc)
       04          
041E7F ED 5B 3B 1E 0955*      ld de, (ude)
       04          
041E84 DD 2A 3E 1E 0956*      ld ix, (uix)
       04          
041E89 FD 2A 41 1E 0957*      ld iy, (uiy)
       04          
041E8E F1          0958*      pop af ; send her home the way she came
041E8F C9          0959*      ret
041E90             0960*  ; Bit 7 (S): Sign flag
041E90             0961*  ; Bit 6 (Z): Zero flag
041E90             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041E90             0963*  ; Bit 4 (H): Half Carry flag
041E90             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041E90             0965*  ; Bit 2 (PV): Parity/Overflow flag
041E90             0966*  ; Bit 1 (N): Subtract flag
041E90             0967*  ; Bit 0 (C): Carry flag
041E90 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041E9B             0969*  
041E9B             0970*  ; set all the bits in the flag register
041E9B             0971*  ; more of an academic exercise than anything useful
041E9B             0972*  ; inputs; none
041E9B             0973*  ; outputs; a=0,f=255
041E9B             0974*  ; destroys: flags, hl
041E9B             0975*  ; preserves: a, because why not
041E9B             0976*  setAllFlags:
041E9B 21 FF 00 00 0977*      ld hl,255
041E9F 67          0978*      ld h,a ; four cycles to preserve a is cheap
041EA0 E5          0979*      push hl
041EA1 F1          0980*      pop af
041EA2 C9          0981*      ret
041EA3             0982*  
041EA3             0983*  ; reset all the bits in the flag register
041EA3             0984*  ; unlike its inverse counterpart, this may actually be useful
041EA3             0985*  ; inputs; none
041EA3             0986*  ; outputs; a=0,f=0
041EA3             0987*  ; destroys: flags, hl
041EA3             0988*  ; preserves: a, because why not
041EA3             0989*  resetAllFlags:
041EA3 21 00 00 00 0990*      ld hl,0
041EA7 67          0991*      ld h,a ; four cycles to preserve a is cheap
041EA8 E5          0992*      push hl
041EA9 F1          0993*      pop af
041EAA C9          0994*      ret
041EAB             0995*  
041EAB             0996*  ; wait until user presses a key
041EAB             0997*  ; inputs: none
041EAB             0998*  ; outputs: ascii code of key pressed in a
041EAB             0999*  ; destroys: af,ix
041EAB             1000*  waitKeypress:
041EAB             1001*      MOSCALL mos_getkey
041EAB 3E 00       0001*M 			LD	A, function
041EAD 5B CF       0002*M 			RST.LIL	08h
041EAF C9          1002*      ret
041EB0             1003*  
041EB0             1004*  ; print bytes from an address to the screen in hexidecimal format
041EB0             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EB0             1006*  ; outputs: values of each byte printed to screen separated by spaces
041EB0             1007*  ; destroys: nothing
041EB0             1008*  dumpMemoryHex:
041EB0             1009*  ; save registers to the stack
041EB0 C5          1010*      push bc
041EB1 E5          1011*      push hl
041EB2 F5          1012*      push af
041EB3             1013*  
041EB3             1014*  ; print the address and separator
041EB3 CD 2D 19 04 1015*      call printHex24
041EB7 3E 3A       1016*      ld a,':'
041EB9 5B D7       1017*      rst.lil 10h
041EBB 3E 20       1018*      ld a,' '
041EBD 5B D7       1019*      rst.lil 10h
041EBF             1020*  
041EBF             1021*  ; set b to be our loop counter
041EBF F1          1022*      pop af
041EC0 47          1023*      ld b,a
041EC1 E1          1024*      pop hl
041EC2 E5          1025*      push hl
041EC3 F5          1026*      push af
041EC4             1027*  @loop:
041EC4             1028*  ; print the byte
041EC4 7E          1029*      ld a,(hl)
041EC5 CD 3B 19 04 1030*      call printHex8
041EC9             1031*  ; print a space
041EC9 3E 20       1032*      ld a,' '
041ECB 5B D7       1033*      rst.lil 10h
041ECD 23          1034*      inc hl
041ECE 10 F4       1035*      djnz @loop
041ED0 CD 22 19 04 1036*      call printNewLine
041ED4             1037*  
041ED4             1038*  ; restore everything
041ED4 F1          1039*      pop af
041ED5 E1          1040*      pop hl
041ED6 C1          1041*      pop bc
041ED7             1042*  
041ED7             1043*  ; all done
041ED7 C9          1044*      ret
041ED8             1045*  
041ED8             1046*  
041ED8             1047*  ; print bytes from an address to the screen in binary format
041ED8             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041ED8             1049*  ; outputs: values of each byte printed to screen separated by spaces
041ED8             1050*  ; destroys: nothing
041ED8             1051*  dumpMemoryBin:
041ED8             1052*  ; save all registers to the stack
041ED8 F5          1053*      push af
041ED9 C5          1054*      push bc
041EDA D5          1055*      push de
041EDB E5          1056*      push hl
041EDC DD E5       1057*      push ix
041EDE FD E5       1058*      push iy
041EE0             1059*  
041EE0             1060*  ; set b to be our loop counter
041EE0 47          1061*      ld b,a
041EE1             1062*  @loop:
041EE1             1063*  ; print the byte
041EE1 7E          1064*      ld a,(hl)
041EE2 E5          1065*      push hl
041EE3 C5          1066*      push bc
041EE4 CD AB 1B 04 1067*      call printBin8
041EE8 C1          1068*      pop bc
041EE9             1069*  ; print a space
041EE9 3E 20       1070*      ld a,' '
041EEB 5B D7       1071*      rst.lil 10h
041EED E1          1072*      pop hl
041EEE 23          1073*      inc hl
041EEF 10 F0       1074*      djnz @loop
041EF1 CD 22 19 04 1075*      call printNewLine
041EF5             1076*  
041EF5             1077*  ; restore everything
041EF5 FD E1       1078*      pop iy
041EF7 DD E1       1079*      pop ix
041EF9 E1          1080*      pop hl
041EFA D1          1081*      pop de
041EFB C1          1082*      pop bc
041EFC F1          1083*      pop af
041EFD             1084*  ; all done
041EFD C9          1085*      ret
041EFE             1086*  
041EFE             1087*  ; print bytes from an address to the screen in binary format
041EFE             1088*  ; with the bits of each byte in reverse order (lsb first)
041EFE             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EFE             1090*  ; outputs: values of each byte printed to screen separated by spaces
041EFE             1091*  ; destroys: nothing
041EFE             1092*  dumpMemoryBinRev:
041EFE             1093*  ; save all registers to the stack
041EFE F5          1094*      push af
041EFF C5          1095*      push bc
041F00 D5          1096*      push de
041F01 E5          1097*      push hl
041F02 DD E5       1098*      push ix
041F04 FD E5       1099*      push iy
041F06             1100*  
041F06             1101*  ; set b to be our loop counter
041F06 47          1102*      ld b,a
041F07             1103*  @loop:
041F07             1104*  ; print the byte
041F07 7E          1105*      ld a,(hl)
041F08 E5          1106*      push hl
041F09 C5          1107*      push bc
041F0A CD D0 1B 04 1108*      call printBin8Rev
041F0E C1          1109*      pop bc
041F0F             1110*  ; print a space
041F0F 3E 20       1111*      ld a,' '
041F11 5B D7       1112*      rst.lil 10h
041F13 E1          1113*      pop hl
041F14 23          1114*      inc hl
041F15 10 F0       1115*      djnz @loop
041F17 CD 22 19 04 1116*      call printNewLine
041F1B             1117*  
041F1B             1118*  ; restore everything
041F1B FD E1       1119*      pop iy
041F1D DD E1       1120*      pop ix
041F1F E1          1121*      pop hl
041F20 D1          1122*      pop de
041F21 C1          1123*      pop bc
041F22 F1          1124*      pop af
041F23             1125*  ; all done
041F23 C9          1126*      ret
041F24             0053       include "vdu.inc"
041F24             0001*  
041F24             0002*  ; VDU 30: Home cursor
041F24             0003*  vdu_home_cursor:
041F24 3E 1E       0004*      ld a,30
041F26 5B D7       0005*  	rst.lil $10
041F28 C9          0006*  	ret
041F29             0007*  
041F29             0008*  vdu_cursor_on:
041F29 21 34 1F 04 0009*  	ld hl,@cmd
041F2D 01 03 00 00 0010*  	ld bc,@end-@cmd
041F31 5B DF       0011*  	rst.lil $18
041F33 C9          0012*  	ret
041F34             0013*  @cmd:
041F34 17 01 01    0014*  	db 23,1,1
041F37             0015*  @end:
041F37             0016*  
041F37             0017*  vdu_cursor_off:
041F37 21 42 1F 04 0018*  	ld hl,@cmd
041F3B 01 03 00 00 0019*  	ld bc,@end-@cmd
041F3F 5B DF       0020*  	rst.lil $18
041F41 C9          0021*  	ret
041F42             0022*  @cmd:
041F42 17 01 00    0023*  	db 23,1,0
041F45             0024*  @end:
041F45             0025*  
041F45             0026*  ; VDU 5: Write text at graphics cursor
041F45             0027*  ; inputs: a is the character to write to the screen
041F45             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041F45             0029*  ; outputs: see the name of the function
041F45             0030*  ; destroys: a, hl, bc
041F45             0031*  vdu_char_to_gfx_cursor:
041F45 32 55 1F 04 0032*  	ld (@arg),a
041F49 21 54 1F 04 0033*  	ld hl,@cmd
041F4D 01 02 00 00 0034*  	ld bc,@end-@cmd
041F51 5B DF       0035*  	rst.lil $18
041F53 C9          0036*  	ret
041F54 05          0037*  @cmd: db 5
041F55 00          0038*  @arg: db 0
041F56             0039*  @end:
041F56             0040*  ; VDU 9: Move cursor forward one character
041F56             0041*  vdu_cursor_forward:
041F56 3E 09       0042*      ld a,9
041F58 5B D7       0043*  	rst.lil $10
041F5A C9          0044*  	ret
041F5B             0045*  
041F5B             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041F5B             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041F5B             0048*  vdu_move_cursor:
041F5B ED 43 6C 1F 0049*      ld (@x0),bc
       04          
041F60 21 6B 1F 04 0050*  	ld hl,@cmd
041F64 01 03 00 00 0051*  	ld bc,@end-@cmd
041F68 5B DF       0052*  	rst.lil $18
041F6A C9          0053*  	ret
041F6B 1F          0054*  @cmd: 	db 31
041F6C 00          0055*  @x0:	db 0
041F6D 00          0056*  @y0: 	db 0
041F6E 00          0057*  @end: 	db 0 ; padding
041F6F             0058*  
041F6F             0059*  ; VDU 12: Clear text area (CLS)
041F6F             0060*  vdu_cls:
041F6F 3E 0C       0061*      ld a,12
041F71 5B D7       0062*  	rst.lil $10
041F73 C9          0063*  	ret
041F74             0064*  
041F74             0065*  vdu_flip:
041F74 21 7F 1F 04 0066*  	ld hl,@cmd
041F78 01 03 00 00 0067*  	ld bc,@end-@cmd
041F7C 5B DF       0068*  	rst.lil $18
041F7E C9          0069*  	ret
041F7F 17 00 C3    0070*  @cmd: db 23,0,0xC3
041F82             0071*  @end:
041F82             0072*  
041F82             0073*  ; VDU 16: Clear graphics area (CLG)
041F82             0074*  vdu_clg:
041F82 3E 10       0075*      ld a,16
041F84 5B D7       0076*  	rst.lil $10
041F86 C9          0077*  	ret
041F87             0078*  
041F87             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041F87             0080*  ; VDU 23, 7: Scrolling
041F87             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041F87             0082*  ; inputs: a, extent; l, direction; h; speed
041F87             0083*  vdu_scroll_down:
041F87 32 9C 1F 04 0084*  	ld (@extent),a
041F8B 22 9D 1F 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041F8F 21 9A 1F 04 0086*  	ld hl,@cmd
041F93 01 05 00 00 0087*  	ld bc,@end-@cmd
041F97 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041F99 C9          0089*  	ret
041F9A 17 07       0090*  @cmd:       db 23,7
041F9C 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041F9D 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041F9E 00          0093*  @speed:     db 0x00 ; pixels
041F9F 00          0094*  @end:		db 0x00 ; padding
041FA0             0095*  
041FA0             0096*  ; COLOUR MODES
041FA0             0097*  ; Mode	Effect
041FA0             0098*  ; 0	Set on-screen pixel to target colour value
041FA0             0099*  ; 1	OR value with the on-screen pixel
041FA0             0100*  ; 2	AND value with the on-screen pixel
041FA0             0101*  ; 3	XOR value with the on-screen pixel
041FA0             0102*  ; 4	Invert the on-screen pixel
041FA0             0103*  ; 5	No operation
041FA0             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041FA0             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041FA0             0106*  
041FA0             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041FA0             0108*  vdu_colour_text:
041FA0 32 B0 1F 04 0109*  	ld (@arg),a
041FA4 21 AF 1F 04 0110*  	ld hl,@cmd
041FA8 01 02 00 00 0111*  	ld bc,@end-@cmd
041FAC 5B DF       0112*  	rst.lil $18
041FAE C9          0113*  	ret
041FAF 11          0114*  @cmd: db 17
041FB0 00          0115*  @arg: db 0
041FB1             0116*  @end:
041FB1             0117*  
041FB1             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041FB1             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041FB1             0120*  vdu_gcol:
041FB1 32 C6 1F 04 0121*  	ld (@mode),a
041FB5 79          0122*      ld a,c
041FB6 32 C7 1F 04 0123*      ld (@col),a
041FBA 21 C5 1F 04 0124*  	ld hl,@cmd
041FBE 01 03 00 00 0125*  	ld bc,@end-@cmd
041FC2 5B DF       0126*  	rst.lil $18
041FC4 C9          0127*  	ret
041FC5 12          0128*  @cmd:  db 18
041FC6 00          0129*  @mode: db 0
041FC7 00          0130*  @col:  db 0
041FC8             0131*  @end:
041FC8             0132*  
041FC8             0133*  
041FC8             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041FC8             0135*  ; MIND THE LITTLE-ENDIANESS
041FC8             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041FC8             0137*  ; outputs; nothing
041FC8             0138*  ; destroys: a might make it out alive
041FC8             0139*  vdu_set_txt_viewport:
041FC8 ED 43 DE 1F 0140*      ld (@lb),bc
       04          
041FCD ED 53 E0 1F 0141*  	ld (@rt),de
       04          
041FD2 21 DD 1F 04 0142*  	ld hl,@cmd
041FD6 01 05 00 00 0143*  	ld bc,@end-@cmd
041FDA 5B DF       0144*  	rst.lil $18
041FDC C9          0145*  	ret
041FDD 1C          0146*  @cmd:   db 28 ; set text viewport command
041FDE 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041FE0 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041FE2 00          0149*  @end:   db 0x00	  ; padding
041FE3             0150*  
041FE3             0151*  ; Wait for VBLANK interrupt
041FE3             0152*  vdu_vblank:
041FE3 DD E5       0153*      PUSH 	IX
041FE5             0154*  	MOSCALL	mos_sysvars
041FE5 3E 08       0001*M 			LD	A, function
041FE7 5B CF       0002*M 			RST.LIL	08h
041FE9 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041FEC             0156*  @wait:
041FEC DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041FEF 28 FB       0158*      JR	Z, @wait
041FF1 DD E1       0159*      POP	IX
041FF3 C9          0160*      RET
041FF4             0161*  
041FF4             0162*  ; VDU 29, x; y;: Set graphics origin
041FF4             0163*  ; This command sets the graphics origin.
041FF4             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041FF4             0165*  ; inputs: bc=x0,de=y0
041FF4             0166*  ; outputs; nothing
041FF4             0167*  ; destroys: a might make it out alive
041FF4             0168*  vdu_set_gfx_origin:
041FF4 ED 43 0A 20 0169*      ld (@x0),bc
       04          
041FF9 ED 53 0C 20 0170*      ld (@y0),de
       04          
041FFE 21 09 20 04 0171*      ld hl,@cmd
042002 01 05 00 00 0172*      ld bc,@end-@cmd
042006 5B DF       0173*      rst.lil $18
042008 C9          0174*      ret
042009 1D          0175*  @cmd:   db 29 ; set graphics origin command
04200A 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
04200C 00 00       0177*  @y0: 	dw 0x0000 ; set by de
04200E 00          0178*  @end:   db 0x00	  ; padding
04200F             0179*  
04200F             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04200F             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04200F             0182*  ; 	because we have turned off logical screen scaling
04200F             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04200F             0184*  ; outputs; nothing
04200F             0185*  ; destroys: a might make it out alive
04200F             0186*  vdu_set_gfx_viewport:
04200F ED 43 2F 20 0187*      ld (@x0),bc
       04          
042014 FD 22 31 20 0188*      ld (@y1),iy
       04          
042019 DD 22 33 20 0189*  	ld (@x1),ix
       04          
04201E ED 53 35 20 0190*  	ld (@y0),de
       04          
042023 21 2E 20 04 0191*  	ld hl,@cmd
042027 01 09 00 00 0192*  	ld bc,@end-@cmd
04202B 5B DF       0193*  	rst.lil $18
04202D C9          0194*  	ret
04202E 18          0195*  @cmd:   db 24 ; set graphics viewport command
04202F 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
042031 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
042033 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
042035 00 00       0199*  @y0: 	dw 0x0000 ; set by de
042037 00          0200*  @end:   db 0x00	  ; padding
042038             0201*  
042038             0202*  ; SCREEN MODES
042038             0203*  ; ===============================
042038             0204*  ; Mode  Horz  Vert  Cols  Refresh
042038             0205*  ; ---   ----  ----  ----  -------
042038             0206*  ; 11    320   240   2     60hz
042038             0207*  ; 139   320   240   2     60hz
042038             0208*  ; 23    512   384   2     60hz
042038             0209*  ; 151   512   384   2     60hz
042038             0210*  ; 6     640   240   2     60hz
042038             0211*  ; 134   640   240   2     60hz
042038             0212*  ; 2     640   480   2     60hz
042038             0213*  ; 130   640   480   2     60hz
042038             0214*  ; 17    800   600   2     60hz
042038             0215*  ; 145   800   600   2     60hz
042038             0216*  ; 18    1024  768   2     60hz
042038             0217*  ; 146   1024  768   2     60hz
042038             0218*  ; ---   ----  ----  ----  -------
042038             0219*  ; 10    320   240   4     60hz
042038             0220*  ; 138   320   240   4     60hz
042038             0221*  ; 22    512   384   4     60hz
042038             0222*  ; 150   512   384   4     60hz
042038             0223*  ; 5     640   240   4     60hz
042038             0224*  ; 133   640   240   4     60hz
042038             0225*  ; 1     640   480   4     60hz
042038             0226*  ; 129   640   480   4     60hz
042038             0227*  ; 16    800   600   4     60hz
042038             0228*  ; 19    1024  768   4     60hz
042038             0229*  ; ---   ----  ----  ----  -------
042038             0230*  ; 9     320   240   16    60hz
042038             0231*  ; 137   320   240   16    60hz
042038             0232*  ; 21    512   384   16    60hz
042038             0233*  ; 149   512   384   16    60hz
042038             0234*  ; 4     640   240   16    60hz
042038             0235*  ; 132   640   240   16    60hz
042038             0236*  ; 0     640   480   16    60hz
042038             0237*  ; 7     n/a   n/a   16    60hz
042038             0238*  ; ---   ----  ----  ----  -------
042038             0239*  ; 8     320   240   64    60hz
042038             0240*  ; 136   320   240   64    60hz
042038             0241*  ; 20    512   384   64    60hz
042038             0242*  ; 3     640   240   64    60hz
042038             0243*  ; ---   ----  ----  ----  -------
042038             0244*  vdu_set_screen_mode:
042038 32 48 20 04 0245*  	ld (@arg),a
04203C 21 47 20 04 0246*  	ld hl,@cmd
042040 01 02 00 00 0247*  	ld bc,@end-@cmd
042044 5B DF       0248*  	rst.lil $18
042046 C9          0249*  	ret
042047 16          0250*  @cmd: db 22 ; set screen mode
042048 00          0251*  @arg: db 0  ; screen mode parameter
042049             0252*  @end:
042049             0253*  
042049             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
042049             0255*  ; inputs: a is scaling mode, 1=on, 0=off
042049             0256*  ; note: default setting on boot is scaling ON
042049             0257*  vdu_set_scaling:
042049 32 5B 20 04 0258*  	ld (@arg),a
04204D 21 58 20 04 0259*  	ld hl,@cmd
042051 01 04 00 00 0260*  	ld bc,@end-@cmd
042055 5B DF       0261*  	rst.lil $18
042057 C9          0262*  	ret
042058 17 00 C0    0263*  @cmd: db 23,0,0xC0
04205B 00          0264*  @arg: db 0  ; scaling on/off
04205C             0265*  @end:
04205C             0266*  
04205C             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04205C             0268*  ; inputs: hl=bufferId
04205C             0269*  vdu_buff_select:
04205C 22 6E 20 04 0270*  	ld (@bufferId),hl
042060 21 6B 20 04 0271*  	ld hl,@cmd
042064 01 05 00 00 0272*  	ld bc,@end-@cmd
042068 5B DF       0273*  	rst.lil $18
04206A C9          0274*  	ret
04206B 17 1B 20    0275*  @cmd: db 23,27,0x20
04206E 00 00       0276*  @bufferId: dw 0x0000
042070 00          0277*  @end: db 0x00 ; padding
042071             0278*  
042071             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
042071             0280*  ; inputs: a=format; bc=width; de=height
042071             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
042071             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
042071             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
042071             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
042071             0285*  ; 2 	Mono/Mask (1-bit per pixel)
042071             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
042071             0287*  vdu_bmp_create:
042071 ED 43 8D 20 0288*      ld (@width),bc
       04          
042076 ED 53 8F 20 0289*      ld (@height),de
       04          
04207B 32 91 20 04 0290*      ld (@fmt),a
04207F 21 8A 20 04 0291*  	ld hl,@cmd
042083 01 08 00 00 0292*  	ld bc,@end-@cmd
042087 5B DF       0293*  	rst.lil $18
042089 C9          0294*  	ret
04208A 17 1B 21    0295*  @cmd:       db 23,27,0x21
04208D 00 00       0296*  @width:     dw 0x0000
04208F 00 00       0297*  @height:    dw 0x0000
042091 00          0298*  @fmt:       db 0x00
042092             0299*  @end:
042092             0300*  
042092             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
042092             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
042092             0303*  vdu_load_img_rgba2_to_8:
042092             0304*  ; backup the target buffer id and image dimensions
042092 E5          0305*      push hl
042093 D5          0306*      push de
042094 C5          0307*      push bc
042095             0308*  ; load the rgba2 image to working buffer 65534
042095 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
042099 CD 9C 21 04 0310*  	call vdu_load_buffer_from_file
04209D             0311*  ; restore the image dimensions and target buffer id
04209D C1          0312*      pop bc
04209E D1          0313*      pop de
04209F E1          0314*      pop hl
0420A0             0315*  ; fall through to vdu_rgba2_to_8
0420A0             0316*  
0420A0             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0420A0             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0420A0             0319*  ; the "expand bitmap" command is:
0420A0             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420A0             0321*  ; and then to reverse the byte order to fix endian-ness:
0420A0             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420A0             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420A0             0324*  ; VDU 23,27,&20,targetBufferID%;
0420A0             0325*  ; VDU 23,27,&21,width%;height%;0
0420A0             0326*  ; -------------------------------------------------------------------
0420A0             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0420A0             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0420A0             0329*  vdu_rgba2_to_8:
0420A0             0330*  ; load the image dimensions and buffer id parameters
0420A0 ED 43 FC 20 0331*      ld (@width),bc
       04          
0420A5 ED 53 FE 20 0332*      ld (@height),de
       04          
0420AA 22 E1 20 04 0333*      ld (@bufferId0),hl
0420AE 22 EE 20 04 0334*      ld (@bufferId2),hl
0420B2 22 F7 20 04 0335*      ld (@bufferId1),hl
0420B6             0336*  ; clean up bytes that got stomped on by the ID loads
0420B6 3E 48       0337*      ld a,0x48
0420B8 32 E3 20 04 0338*      ld (@bufferId0+2),a
0420BC 3E 17       0339*      ld a,23
0420BE 32 F9 20 04 0340*      ld (@bufferId1+2),a
0420C2 3E 18       0341*      ld a,24
0420C4 32 F0 20 04 0342*      ld (@bufferId2+2),a
0420C8 AF          0343*      xor a
0420C9 32 00 21 04 0344*      ld (@height+2),a
0420CD             0345*  ; send the vdu command strings
0420CD 21 D8 20 04 0346*      ld hl,@beg
0420D1 01 29 00 00 0347*      ld bc,@end-@beg
0420D5 5B DF       0348*      rst.lil $18
0420D7 C9          0349*      ret
0420D8             0350*  @beg:
0420D8             0351*  ; Command 14: Consolidate blocks in a buffer
0420D8             0352*  ; VDU 23, 0, &A0, bufferId; 14
0420D8 17 00 A0    0353*      db 23,0,0xA0
0420DB FE FF       0354*      dw 65534 ; workingBufferId
0420DD 0E          0355*      db 14 ; consolidate blocks
0420DE             0356*  ; the "expand bitmap" command is:
0420DE             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420DE 17 00 A0    0358*      db 23,0,0xA0
0420E1 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
0420E3 48          0360*      db 0x48 ; given as decimal command 72 in the docs
0420E4 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0420E5 FE FF       0362*      dw 65534 ; sourceBufferId
0420E7 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0420EB             0364*  ; reverse the byte order to fix endian-ness:
0420EB             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
0420EB             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0420EB             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420EB 17 00 A0    0368*      db 23,0,0xA0
0420EE 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
0420F0 18          0370*      db 24 ; reverse byte order
0420F1 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0420F2 04 00       0372*      dw 4 ; size (4 bytes)
0420F4             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420F4             0374*  ; VDU 23,27,&20,targetBufferID%;
0420F4 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
0420F7 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
0420F9             0377*  ; VDU 23,27,&21,width%;height%;0
0420F9 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
0420FC 00 00       0379*  @width: dw 0x0000
0420FE 00 00       0380*  @height: dw 0x0000
042100 00          0381*      db 0x00 ; rgba8888 format
042101             0382*  @end:
042101             0383*  
042101             0384*  ; scratch variables
042101 00 00 00    0385*  bufferId0: dl 0x000000
042104 00 00 00    0386*  bufferId1: dl 0x000000
042107             0387*  
042107             0388*  ; load a vdu buffer from local memory
042107             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042107             0390*  vdu_load_buffer:
042107 ED 43 30 21 0391*      ld (@length),bc
       04          
04210C D5          0392*      push de ; save data pointer
04210D             0393*  ; send the vdu command string
04210D 7D          0394*      ld a,l
04210E 32 2D 21 04 0395*      ld (@bufferId),a
042112 7C          0396*      ld a,h
042113 32 2E 21 04 0397*      ld (@bufferId+1),a
042117 21 2A 21 04 0398*      ld hl,@cmd
04211B 01 08 00 00 0399*      ld bc,@end-@cmd
04211F 5B DF       0400*      rst.lil $18
042121             0401*  ; send the buffer data
042121 E1          0402*      pop hl ; pointer to data
042122 ED 4B 30 21 0403*      ld bc,(@length)
       04          
042127 5B DF       0404*      rst.lil $18 ; send it
042129 C9          0405*      ret
04212A             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04212A 17 00 A0    0407*  @cmd:       db 23,0,0xA0
04212D 00 00       0408*  @bufferId:	dw 0x0000
04212F 00          0409*  		    db 0 ; load buffer
042130 00 00       0410*  @length:	dw 0x0000
042132 00          0411*  @end: db 0 ; padding
042133             0412*  
042133             0413*  ; clear a buffer
042133             0414*  ; inputs: hl = bufferId
042133             0415*  vdu_clear_buffer:
042133 7D          0416*      ld a,l
042134 32 4B 21 04 0417*      ld (@bufferId),a
042138 7C          0418*      ld a,h
042139 32 4C 21 04 0419*      ld (@bufferId+1),a
04213D 21 48 21 04 0420*      ld hl,@cmd
042141 01 06 00 00 0421*      ld bc,@end-@cmd
042145 5B DF       0422*      rst.lil $18
042147 C9          0423*      ret
042148 17 00 A0    0424*  @cmd:       db 23,0,0xA0
04214B 00 00       0425*  @bufferId:	dw 0x0000
04214D 02          0426*  		    db 2 ; clear buffer
04214E             0427*  @end:
04214E             0428*  
04214E             0429*  vdu_clear_all_buffers:
04214E             0430*  ; clear all buffers
04214E 21 59 21 04 0431*      ld hl,@beg
042152 01 06 00 00 0432*      ld bc,@end-@beg
042156 5B DF       0433*      rst.lil $18
042158 C9          0434*      ret
042159 17 00 A0    0435*  @beg: db 23,0,$A0
04215C FF FF       0436*        dw -1 ; clear all buffers
04215E 02          0437*        db 2  ; command 2: clear a buffer
04215F             0438*  @end:
04215F             0439*  
04215F             0440*  ; Command 14: Consolidate blocks in a buffer
04215F             0441*  vdu_consolidate_buffer:
04215F             0442*  ; set parameters for vdu call
04215F 7D          0443*      ld a,l
042160 32 77 21 04 0444*      ld (@bufferId),a
042164 7C          0445*      ld a,h
042165 32 78 21 04 0446*      ld (@bufferId+1),a
042169 21 74 21 04 0447*      ld hl,@beg
04216D 01 06 00 00 0448*      ld bc,@end-@beg
042171 5B DF       0449*      rst.lil $18
042173 C9          0450*      ret
042174             0451*  ; VDU 23, 0, &A0, bufferId; 14
042174 17 00 A0    0452*  @beg: db 23,0,0xA0
042177 00 00       0453*  @bufferId: dw 0x0000
042179 0E          0454*             db 14
04217A             0455*  @end:
04217A             0456*  
04217A             0457*  ; load an image file to a buffer and make it a bitmap
04217A             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
04217A             0459*  vdu_load_img:
04217A             0460*  ; back up image type and dimension parameters
04217A 22 01 21 04 0461*      ld (bufferId0),hl
04217E F5          0462*      push af
04217F C5          0463*  	push bc
042180 D5          0464*  	push de
042181             0465*  ; load the image
042181 CD 9C 21 04 0466*  	call vdu_load_buffer_from_file
042185             0467*  ; now make it a bitmap
042185 2A 01 21 04 0468*      ld hl,(bufferId0)
042189 CD 5F 21 04 0469*      call vdu_consolidate_buffer
04218D 2A 01 21 04 0470*      ld hl,(bufferId0)
042191 CD 5C 20 04 0471*      call vdu_buff_select
042195 D1          0472*  	pop de ; image height
042196 C1          0473*  	pop bc ; image width
042197 F1          0474*  	pop af ; image type
042198 C3 71 20 04 0475*  	jp vdu_bmp_create ; will return to caller from there
04219C             0476*  
04219C             0477*  ; inputs: hl = bufferId; iy = pointer to filename
04219C             0478*  vdu_load_buffer_from_file:
04219C 22 01 21 04 0479*      ld (bufferId0),hl
0421A0             0480*  
0421A0             0481*  ; clear target buffer
0421A0 CD 33 21 04 0482*      call vdu_clear_buffer
0421A4             0483*  
0421A4             0484*  ; open the file in read mode
0421A4             0485*  ; Open a file
0421A4             0486*  ; HLU: Filename
0421A4             0487*  ;   C: Mode
0421A4             0488*  ; Returns:
0421A4             0489*  ;   A: Filehandle, or 0 if couldn't open
0421A4 FD E5       0490*  	push iy ; pointer to filename
0421A6 E1          0491*  	pop hl
0421A7 0E 01       0492*  	ld c,fa_read
0421A9             0493*      MOSCALL mos_fopen
0421A9 3E 0A       0001*M 			LD	A, function
0421AB 5B CF       0002*M 			RST.LIL	08h
0421AD 32 E8 21 04 0494*      ld (@filehandle),a
0421B1             0495*  
0421B1             0496*  @read_file:
0421B1             0497*  ; Read a block of data from a file
0421B1             0498*  ;   C: Filehandle
0421B1             0499*  ; HLU: Pointer to where to write the data to
0421B1             0500*  ; DEU: Number of bytes to read
0421B1             0501*  ; Returns:
0421B1             0502*  ; DEU: Number of bytes read
0421B1 3A E8 21 04 0503*      ld a,(@filehandle)
0421B5 4F          0504*      ld c,a
0421B6 21 00 E0 B7 0505*      ld hl,filedata
0421BA 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0421BE             0507*      MOSCALL mos_fread
0421BE 3E 1A       0001*M 			LD	A, function
0421C0 5B CF       0002*M 			RST.LIL	08h
0421C2             0508*  
0421C2             0509*  ; test de for zero bytes read
0421C2 21 00 00 00 0510*      ld hl,0
0421C6 AF          0511*      xor a ; clear carry
0421C7 ED 52       0512*      sbc hl,de
0421C9 CA DF 21 04 0513*      jp z,@close_file
0421CD             0514*  
0421CD             0515*  ; load a vdu buffer from local memory
0421CD             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0421CD 2A 01 21 04 0517*      ld hl,(bufferId0)
0421D1 D5          0518*      push de ; chunksize
0421D2 C1          0519*      pop bc
0421D3 11 00 E0 B7 0520*      ld de,filedata
0421D7 CD 07 21 04 0521*      call vdu_load_buffer
0421DB             0522*  
0421DB             0523*  ; read the next block
0421DB C3 B1 21 04 0524*      jp @read_file
0421DF             0525*  
0421DF             0526*  ; close the file
0421DF             0527*  @close_file:
0421DF 3A E8 21 04 0528*      ld a,(@filehandle)
0421E3             0529*      MOSCALL mos_fclose
0421E3 3E 0B       0001*M 			LD	A, function
0421E5 5B CF       0002*M 			RST.LIL	08h
0421E7 C9          0530*      ret ; vdu_load_buffer_from_file
0421E8             0531*  
0421E8 00          0532*  @filehandle: db 0 ; file handle
0421E9 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
0421EC             0534*  
0421EC 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
0421EF             0536*  
0421EF             0537*  ; File information structure (FILINFO)
0421EF             0538*  @filinfo:
0421EF 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0421F3 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0421F5 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0421F7 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0421F8 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042205 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042305             0054       include "vdu_plot.inc"
042305             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042305             0002*  ; PLOT code 	(Decimal) 	Effect
042305             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
042305             0004*  plot_sl_both: equ 0x00
042305             0005*  
042305             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
042305             0007*  plot_sl_first: equ 0x08
042305             0008*  
042305             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
042305             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
042305             0011*  
042305             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
042305             0013*  plot_sl_last: equ 0x20
042305             0014*  
042305             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
042305             0016*  plot_sl_none: equ 0x28
042305             0017*  
042305             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
042305             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
042305             0020*  
042305             0021*  ; &40-&47 	64-71 	Point plot
042305             0022*  plot_pt: equ 0x40
042305             0023*  
042305             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
042305             0025*  plot_lf_lr_non_bg: equ 0x48
042305             0026*  
042305             0027*  ; &50-&57 	80-87 	Triangle fill
042305             0028*  plot_tf: equ 0x50
042305             0029*  
042305             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
042305             0031*  plot_lf_r_bg: equ 0x58
042305             0032*  
042305             0033*  ; &60-&67 	96-103 	Rectangle fill
042305             0034*  plot_rf: equ 0x60
042305             0035*  
042305             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
042305             0037*  plot_lf_lr_fg: equ 0x60
042305             0038*  
042305             0039*  ; &70-&77 	112-119 	Parallelogram fill
042305             0040*  plot_pf: equ 0x70
042305             0041*  
042305             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
042305             0043*  plot_lf_r_non_fg: equ 0x78
042305             0044*  
042305             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
042305             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
042305             0047*  
042305             0048*  ; &90-&97 	144-151 	Circle outline
042305             0049*  plot_co: equ 0x90
042305             0050*  
042305             0051*  ; &98-&9F 	152-159 	Circle fill
042305             0052*  plot_cf: equ 0x98
042305             0053*  
042305             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
042305             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
042305             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
042305             0057*  
042305             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
042305             0059*  plot_rcm: equ 0xB8
042305             0060*  
042305             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
042305             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
042305             0063*  ; &D0-&D7 	208-215 	Not defined
042305             0064*  ; &D8-&DF 	216-223 	Not defined
042305             0065*  ; &E0-&E7 	224-231 	Not defined
042305             0066*  
042305             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
042305             0068*  plot_bmp: equ 0xE8
042305             0069*  
042305             0070*  ; &F0-&F7 	240-247 	Not defined
042305             0071*  ; &F8-&FF 	248-255 	Not defined
042305             0072*  
042305             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
042305             0074*  ; Agon Console8 VDP 2.2.0
042305             0075*  
042305             0076*  ; Within each group of eight plot codes, the effects are as follows:
042305             0077*  ; Plot code 	Effect
042305             0078*  ; 0 	Move relative
042305             0079*  mv_rel: equ 0
042305             0080*  
042305             0081*  ; 1 	Plot relative in current foreground colour
042305             0082*  dr_rel_fg: equ 1
042305             0083*  
042305             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
042305             0085*  ; 3 	Plot relative in current background colour
042305             0086*  dr_rel_bg: equ 3
042305             0087*  
042305             0088*  ; 4 	Move absolute
042305             0089*  mv_abs: equ 4
042305             0090*  
042305             0091*  ; 5 	Plot absolute in current foreground colour
042305             0092*  dr_abs_fg: equ 5
042305             0093*  
042305             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
042305             0095*  ; 7 	Plot absolute in current background colour
042305             0096*  dr_abs_bg: equ 7
042305             0097*  
042305             0098*  ; Codes 0-3 use the position data provided as part of the command
042305             0099*  ; as a relative position, adding the position given to the current
042305             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
042305             0101*  ; as part of the command as an absolute position, setting the current
042305             0102*  ; graphical cursor position to the position given.
042305             0103*  
042305             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
042305             0105*  ; current pixel colour. These operations cannot currently be supported
042305             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
042305             0107*  ; supported. Support for these codes may be added in a future version
042305             0108*  ; of the VDP firmware.
042305             0109*  
042305             0110*  ; 16 colour palette constants
042305             0111*  c_black: equ 0
042305             0112*  c_red_dk: equ 1
042305             0113*  c_green_dk: equ 2
042305             0114*  c_yellow_dk: equ 3
042305             0115*  c_blue_dk: equ 4
042305             0116*  c_magenta_dk: equ 5
042305             0117*  c_cyan_dk: equ 6
042305             0118*  c_grey: equ 7
042305             0119*  c_grey_dk: equ 8
042305             0120*  c_red: equ 9
042305             0121*  c_green: equ 10
042305             0122*  c_yellow: equ 11
042305             0123*  c_blue: equ 12
042305             0124*  c_magenta: equ 13
042305             0125*  c_cyan: equ 14
042305             0126*  c_white: equ 15
042305             0127*  
042305             0128*  ; VDU 25, mode, x; y;: PLOT command
042305             0129*  ; inputs: a=mode, bc=x0, de=y0
042305             0130*  vdu_plot:
042305 32 1F 23 04 0131*      ld (@mode),a
042309 ED 43 20 23 0132*      ld (@x0),bc
       04          
04230E ED 53 22 23 0133*      ld (@y0),de
       04          
042313 21 1E 23 04 0134*  	ld hl,@cmd
042317 01 06 00 00 0135*  	ld bc,@end-@cmd
04231B 5B DF       0136*  	rst.lil $18
04231D C9          0137*  	ret
04231E 19          0138*  @cmd:   db 25
04231F 00          0139*  @mode:  db 0
042320 00 00       0140*  @x0: 	dw 0
042322 00 00       0141*  @y0: 	dw 0
042324 00          0142*  @end:   db 0 ; extra byte to soak up deu
042325             0143*  
042325             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042325             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
042325             0146*  ; VDU 25, mode, x; y;: PLOT command
042325             0147*  ; inputs: bc=x0, de=y0
042325             0148*  ; prerequisites: vdu_buff_select
042325             0149*  vdu_plot_bmp:
042325 ED 43 3C 23 0150*      ld (@x0),bc
       04          
04232A ED 53 3E 23 0151*      ld (@y0),de
       04          
04232F 21 3A 23 04 0152*  	ld hl,@cmd
042333 01 06 00 00 0153*  	ld bc,@end-@cmd
042337 5B DF       0154*  	rst.lil $18
042339 C9          0155*  	ret
04233A 19          0156*  @cmd:   db 25
04233B ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04233C 00 00       0158*  @x0: 	dw 0x0000
04233E 00 00       0159*  @y0: 	dw 0x0000
042340 00          0160*  @end:   db 0x00 ; padding
042341             0161*  
042341             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042341             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
042341             0164*  ; VDU 25, mode, x; y;: PLOT command
042341             0165*  ; inputs: bc=x0, de=y0
042341             0166*  ; USING 16.8 FIXED POINT COORDINATES
042341             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042341             0168*  ;   the fractional portiion of the inputs are truncated
042341             0169*  ;   leaving only the 16-bit integer portion
042341             0170*  ; prerequisites: vdu_buff_select
042341             0171*  vdu_plot_bmp168:
042341             0172*  ; populate in the reverse of normal to keep the
042341             0173*  ; inputs from stomping on each other
042341 ED 53 5F 23 0174*      ld (@y0-1),de
       04          
042346 ED 43 5D 23 0175*      ld (@x0-1),bc
       04          
04234B 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
04234D 32 5D 23 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
042351 21 5C 23 04 0178*  	ld hl,@cmd
042355 01 06 00 00 0179*  	ld bc,@end-@cmd
042359 5B DF       0180*  	rst.lil $18
04235B C9          0181*  	ret
04235C 19          0182*  @cmd:   db 25
04235D ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04235E 00 00       0184*  @x0: 	dw 0x0000
042360 00 00       0185*  @y0: 	dw 0x0000
042362             0186*  @end:  ; no padding required b/c we shifted de right
042362             0187*  
042362             0188*  ; draw a filled rectangle
042362             0189*  vdu_plot_rf:
042362 ED 43 89 23 0190*      ld (@x0),bc
       04          
042367 ED 53 8B 23 0191*      ld (@y0),de
       04          
04236C DD 22 8F 23 0192*      ld (@x1),ix
       04          
042371 FD 22 91 23 0193*      ld (@y1),iy
       04          
042376 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
042378 32 8D 23 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04237C 21 87 23 04 0196*  	ld hl,@cmd0
042380 01 0C 00 00 0197*  	ld bc,@end-@cmd0
042384 5B DF       0198*  	rst.lil $18
042386 C9          0199*      ret
042387 19          0200*  @cmd0:  db 25 ; plot
042388 04          0201*  @arg0:  db plot_sl_both+mv_abs
042389 00 00       0202*  @x0:    dw 0x0000
04238B 00 00       0203*  @y0:    dw 0x0000
04238D 19          0204*  @cmd1:  db 25 ; plot
04238E 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04238F 00 00       0206*  @x1:    dw 0x0000
042391 00 00       0207*  @y1:    dw 0x0000
042393 00          0208*  @end:   db 0x00 ; padding
042394             0209*  
042394             0210*  ; draw a filled circle
042394             0211*  vdu_plot_cf:
042394 ED 43 BB 23 0212*      ld (@x0),bc
       04          
042399 ED 53 BD 23 0213*      ld (@y0),de
       04          
04239E DD 22 C1 23 0214*      ld (@x1),ix
       04          
0423A3 FD 22 C3 23 0215*      ld (@y1),iy
       04          
0423A8 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0423AA 32 BF 23 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0423AE 21 B9 23 04 0218*  	ld hl,@cmd0
0423B2 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0423B6 5B DF       0220*  	rst.lil $18
0423B8 C9          0221*      ret
0423B9 19          0222*  @cmd0:  db 25 ; plot
0423BA 04          0223*  @arg0:  db plot_sl_both+mv_abs
0423BB 00 00       0224*  @x0:    dw 0x0000
0423BD 00 00       0225*  @y0:    dw 0x0000
0423BF 19          0226*  @cmd1:  db 25 ; plot
0423C0 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0423C1 00 00       0228*  @x1:    dw 0x0000
0423C3 00 00       0229*  @y1:    dw 0x0000
0423C5 00          0230*  @end:   db 0x00 ; padding
0423C6             0055   	include "vdu_sprites.inc"
0423C6             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
0423C6             0002*  ; the VDP can support up to 256 sprites. They must be defined
0423C6             0003*  ; contiguously, and so the first sprite is sprite 0.
0423C6             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
0423C6             0005*  ; Once a selection of sprites have been defined, you can activate
0423C6             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
0423C6             0007*  ; of sprites to activate. This will activate the first n sprites,
0423C6             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
0423C6             0009*  
0423C6             0010*  ; A single sprite can have multiple "frames", referring to
0423C6             0011*  ; different bitmaps.
0423C6             0012*  ; (These bitmaps do not need to be the same size.)
0423C6             0013*  ; This allows a sprite to include an animation sequence,
0423C6             0014*  ; which can be stepped through one frame at a time, or picked
0423C6             0015*  ; in any order.
0423C6             0016*  
0423C6             0017*  ; Any format of bitmap can be used as a sprite frame. It should
0423C6             0018*  ; be noted however that "native" format bitmaps are not
0423C6             0019*  ; recommended for use as sprite frames, as they cannot get
0423C6             0020*  ; erased from the screen. (As noted above, the "native" bitmap
0423C6             0021*  ; format is not really intended for general use.) This is part
0423C6             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
0423C6             0023*  ; screen are now stored in RGBA2222 format.
0423C6             0024*  
0423C6             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
0423C6             0026*  ; and then later shown again.
0423C6             0027*  
0423C6             0028*  ; Moving sprites around the screen is done by changing the
0423C6             0029*  ; position of the sprite. This can be done either by setting
0423C6             0030*  ; the absolute position of the sprite, or by moving the sprite
0423C6             0031*  ; by a given number of pixels. (Sprites are positioned using
0423C6             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
0423C6             0033*  ; In the current sprite system, sprites will not update their
0423C6             0034*  ; position on-screen until either another drawing operation is
0423C6             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
0423C6             0036*  
0423C6             0037*  ; VDU 23, 27, 4, n: Select sprite n
0423C6             0038*  ; inputs: a is the 8-bit sprite id
0423C6             0039*  vdu_sprite_select:
0423C6 32 D8 23 04 0040*      ld (@sprite),a
0423CA 21 D5 23 04 0041*      ld hl,@cmd
0423CE 01 04 00 00 0042*      ld bc,@end-@cmd
0423D2 5B DF       0043*      rst.lil $18
0423D4 C9          0044*      ret
0423D5 17 1B 04    0045*  @cmd:    db 23,27,4
0423D8 00          0046*  @sprite: db 0x00
0423D9             0047*  @end:
0423D9             0048*  
0423D9             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
0423D9             0050*  ; inputs: none
0423D9             0051*  ; prerequisites: vdu_sprite_select
0423D9             0052*  vdu_sprite_clear_frames:
0423D9 21 E4 23 04 0053*      ld hl,@cmd
0423DD 01 03 00 00 0054*      ld bc,@end-@cmd
0423E1 5B DF       0055*      rst.lil $18
0423E3 C9          0056*      ret
0423E4 17 1B 05    0057*  @cmd: db 23,27,5
0423E7             0058*  @end:
0423E7             0059*  
0423E7             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0423E7             0061*  ; inputs: a is the 8-bit bitmap number
0423E7             0062*  ; prerequisites: vdu_sprite_select
0423E7             0063*  vdu_sprite_add_bmp:
0423E7 32 F9 23 04 0064*      ld (@bmp),a
0423EB 21 F6 23 04 0065*      ld hl,@cmd
0423EF 01 04 00 00 0066*      ld bc,@end-@cmd
0423F3 5B DF       0067*      rst.lil $18
0423F5 C9          0068*      ret
0423F6 17 1B 06    0069*  @cmd: db 23,27,6
0423F9 00          0070*  @bmp: db 0x00
0423FA             0071*  @end:
0423FA             0072*  
0423FA             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0423FA             0074*  ; inputs: a is the number of sprites to activate
0423FA             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0423FA             0076*  vdu_sprite_activate:
0423FA 32 0C 24 04 0077*      ld (@num),a
0423FE 21 09 24 04 0078*      ld hl,@cmd
042402 01 04 00 00 0079*      ld bc,@end-@cmd
042406 5B DF       0080*      rst.lil $18
042408 C9          0081*      ret
042409 17 1B 07    0082*  @cmd: db 23,27,7
04240C 00          0083*  @num: db 0x00
04240D             0084*  @end:
04240D             0085*  
04240D             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
04240D             0087*  ; inputs: none
04240D             0088*  ; prerequisites: vdu_sprite_select
04240D             0089*  vdu_sprite_next_frame:
04240D 21 18 24 04 0090*      ld hl,@cmd
042411 01 03 00 00 0091*      ld bc,@end-@cmd
042415 5B DF       0092*      rst.lil $18
042417 C9          0093*      ret
042418 17 1B 08    0094*  @cmd: db 23,27,8
04241B             0095*  @end:
04241B             0096*  
04241B             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04241B             0098*  ; inputs: none
04241B             0099*  ; prerequisites: vdu_sprite_select
04241B             0100*  vdu_sprite_prev_frame:
04241B 21 26 24 04 0101*      ld hl,@cmd
04241F 01 03 00 00 0102*      ld bc,@end-@cmd
042423 5B DF       0103*      rst.lil $18
042425 C9          0104*      ret
042426 17 1B 09    0105*  @cmd: db 23,27,9
042429             0106*  @end:
042429             0107*  
042429             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
042429             0109*  ; inputs: a is frame number to select
042429             0110*  ; prerequisites: vdu_sprite_select
042429             0111*  vdu_sprite_select_frame:
042429 32 3B 24 04 0112*      ld (@frame),a
04242D 21 38 24 04 0113*      ld hl,@cmd
042431 01 04 00 00 0114*      ld bc,@end-@cmd
042435 5B DF       0115*      rst.lil $18
042437 C9          0116*      ret
042438 17 1B 0A    0117*  @cmd:    db 23,27,10
04243B 00          0118*  @frame:  db 0x00
04243C             0119*  @end:
04243C             0120*  
04243C             0121*  ; VDU 23, 27, 11: Show current sprite
04243C             0122*  ; inputs: none
04243C             0123*  ; prerequisites: vdu_sprite_select
04243C             0124*  vdu_sprite_show:
04243C 21 47 24 04 0125*      ld hl,@cmd
042440 01 03 00 00 0126*      ld bc,@end-@cmd
042444 5B DF       0127*      rst.lil $18
042446 C9          0128*      ret
042447 17 1B 0B    0129*  @cmd: db 23,27,11
04244A             0130*  @end:
04244A             0131*  
04244A             0132*  ; VDU 23, 27, 12: Hide current sprite
04244A             0133*  ; inputs: none
04244A             0134*  ; prerequisites: vdu_sprite_select
04244A             0135*  vdu_sprite_hide:
04244A 21 55 24 04 0136*      ld hl,@cmd
04244E 01 03 00 00 0137*      ld bc,@end-@cmd
042452 5B DF       0138*      rst.lil $18
042454 C9          0139*      ret
042455 17 1B 0C    0140*  @cmd: db 23,27,12
042458             0141*  @end:
042458             0142*  
042458             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042458             0144*  ; inputs: bc is x coordinate, de is y coordinate
042458             0145*  ; prerequisites: vdu_sprite_select
042458             0146*  vdu_sprite_move_abs:
042458 ED 43 70 24 0147*      ld (@xpos),bc
       04          
04245D ED 53 72 24 0148*      ld (@ypos),de
       04          
042462 21 6D 24 04 0149*      ld hl,@cmd
042466 01 07 00 00 0150*      ld bc,@end-@cmd
04246A 5B DF       0151*      rst.lil $18
04246C C9          0152*      ret
04246D 17 1B 0D    0153*  @cmd:  db 23,27,13
042470 00 00       0154*  @xpos: dw 0x0000
042472 00 00       0155*  @ypos: dw 0x0000
042474 00          0156*  @end:  db 0x00 ; padding
042475             0157*  
042475             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042475             0159*  ; inputs: bc is x coordinate, de is y coordinate
042475             0160*  ; prerequisites: vdu_sprite_select
042475             0161*  vdu_sprite_move_rel:
042475 ED 43 8D 24 0162*      ld (@dx),bc
       04          
04247A ED 53 8F 24 0163*      ld (@dy),de
       04          
04247F 21 8A 24 04 0164*      ld hl,@cmd
042483 01 07 00 00 0165*      ld bc,@end-@cmd
042487 5B DF       0166*      rst.lil $18
042489 C9          0167*      ret
04248A 17 1B 0E    0168*  @cmd: db 23,27,14
04248D 00 00       0169*  @dx:  dw 0x0000
04248F 00 00       0170*  @dy:  dw 0x0000
042491 00          0171*  @end: db 0x00 ; padding
042492             0172*  
042492             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042492             0174*  ; USING 16.8 FIXED POINT COORDINATES
042492             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042492             0176*  ;   the fractional portiion of the inputs are truncated
042492             0177*  ;   leaving only the 16-bit integer portion
042492             0178*  ; prerequisites: vdu_sprite_select
042492             0179*  vdu_sprite_move_abs168:
042492             0180*  ; offset inputs by the gfx origin
042492             0181*  ; y coordinate
042492 21 00 30 00 0182*      ld hl,origin_top*256
042496 19          0183*      add hl,de
042497 22 B9 24 04 0184*      ld (@ypos-1),hl
04249B             0185*  ; x coordinate
04249B 21 00 80 00 0186*      ld hl,origin_left*256
04249F 09          0187*      add hl,bc
0424A0 22 B7 24 04 0188*      ld (@xpos-1),hl
0424A4             0189*  ; prepare vdu command
0424A4 3E 0D       0190*      ld a,13       ; restore the final byte of the command
0424A6 32 B7 24 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
0424AA 21 B5 24 04 0192*      ld hl,@cmd
0424AE 01 07 00 00 0193*      ld bc,@end-@cmd
0424B2 5B DF       0194*      rst.lil $18
0424B4 C9          0195*      ret
0424B5 17 1B 0D    0196*  @cmd:  db 23,27,13
0424B8 00 00       0197*  @xpos: dw 0x0000
0424BA 00 00       0198*  @ypos: dw 0x0000
0424BC             0199*  @end:  ; no padding required b/c we shifted de right
0424BC             0200*  
0424BC             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0424BC             0202*  ; USING 16.8 FIXED POINT COORDINATES
0424BC             0203*  ; inputs: ub.c is dx, ud.e is dy
0424BC             0204*  ;   the fractional portiion of the inputs are truncated
0424BC             0205*  ;   leaving only the 16-bit integer portion
0424BC             0206*  ; prerequisites: vdu_sprite_select
0424BC             0207*  vdu_sprite_move_rel168:
0424BC             0208*  ; populate in the reverse of normal to keep the
0424BC             0209*  ; inputs from stomping on each other
0424BC ED 53 DB 24 0210*      ld (@dy-1),de
       04          
0424C1 ED 43 D9 24 0211*      ld (@dx-1),bc
       04          
0424C6 3E 0E       0212*      ld a,14       ; restore the final byte of the command
0424C8 32 D9 24 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
0424CC 21 D7 24 04 0214*      ld hl,@cmd
0424D0 01 07 00 00 0215*      ld bc,@end-@cmd
0424D4 5B DF       0216*      rst.lil $18
0424D6 C9          0217*      ret
0424D7 17 1B 0E    0218*  @cmd:  db 23,27,14
0424DA 00 00       0219*  @dx: dw 0x0000
0424DC 00 00       0220*  @dy: dw 0x0000
0424DE             0221*  @end:  ; no padding required b/c we shifted de right
0424DE             0222*  
0424DE             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
0424DE             0224*  ; inputs: none
0424DE             0225*  vdu_sprite_update:
0424DE 21 E9 24 04 0226*      ld hl,@cmd
0424E2 01 03 00 00 0227*      ld bc,@end-@cmd
0424E6 5B DF       0228*      rst.lil $18
0424E8 C9          0229*      ret
0424E9 17 1B 0F    0230*  @cmd: db 23,27,15
0424EC             0231*  @end:
0424EC             0232*  
0424EC             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0424EC             0234*  ; inputs: none
0424EC             0235*  vdu_sprite_bmp_reset:
0424EC 21 F7 24 04 0236*      ld hl,@cmd
0424F0 01 03 00 00 0237*      ld bc,@end-@cmd
0424F4 5B DF       0238*      rst.lil $18
0424F6 C9          0239*      ret
0424F7 17 1B 10    0240*  @cmd: db 23,27,16
0424FA             0241*  @end:
0424FA             0242*  
0424FA             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0424FA             0244*  ; inputs: none
0424FA             0245*  vdu_sprite_reset:
0424FA 21 05 25 04 0246*      ld hl,@cmd
0424FE 01 03 00 00 0247*      ld bc,@end-@cmd
042502 5B DF       0248*      rst.lil $18
042504 C9          0249*      ret
042505 17 1B 11    0250*  @cmd: db 23,27,17
042508             0251*  @end:
042508             0252*  
042508             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042508             0254*  ; inputs: a is the GCOL paint mode
042508             0255*  ; prerequisites: vdu_sprite_select
042508             0256*  vdu_sprite_set_gcol:
042508 32 1A 25 04 0257*      ld (@mode),a
04250C 21 17 25 04 0258*      ld hl,@cmd
042510 01 04 00 00 0259*      ld bc,@end-@cmd
042514 5B DF       0260*      rst.lil $18
042516 C9          0261*      ret
042517 17 1B 12    0262*  @cmd:  db 23,27,18
04251A 00          0263*  @mode: db 0x00
04251B             0264*  @end:
04251B             0265*  
04251B             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
04251B             0267*  ; inputs: hl=bufferId
04251B             0268*  ; prerequisites: vdu_sprite_select
04251B             0269*  vdu_sprite_add_buff:
04251B 22 2D 25 04 0270*      ld (@bufferId),hl
04251F 21 2A 25 04 0271*      ld hl,@cmd
042523 01 05 00 00 0272*      ld bc,@end-@cmd
042527 5B DF       0273*      rst.lil $18
042529 C9          0274*      ret
04252A 17 1B 26    0275*  @cmd:      db 23,27,0x26
04252D 00 00       0276*  @bufferId: dw 0x0000
04252F 00          0277*  @end:      db 0x00 ; padding
042530             0056   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
042530             0057   	include "maths.inc"
042530             0001*  ; test the sign of HL
042530             0002*  ; inputs: HL obviously
042530             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
042530             0004*  ; destroys: flags
042530             0005*      MACRO sign_hlu
042530             0006*          add hl,de
042530             0007*          or a
042530             0008*          sbc hl,de
042530             0009*      ENDMACRO
042530             0010*  
042530             0011*  
042530             0012*  ;------------------------------------------------------------------------
042530             0013*  ; Scratch area for calculations
042530             0014*  ;------------------------------------------------------------------------
042530 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
042533 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
042536             0017*  
042536             0018*  ; absolute value of hlu
042536             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
042536             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
042536             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
042536             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
042536             0023*  ; destroys: a
042536             0024*  hlu_abs:
042536 19          0025*      add hl,de
042537 B7          0026*      or a
042538 ED 52       0027*      sbc hl,de
04253A FA 3F 25 04 0028*      jp m,@is_neg
04253E C9          0029*      ret         ; hlu is positive or zero so we're done
04253F             0030*  @is_neg:
04253F F5          0031*      push af     ; otherwise, save current flags for return
042540 CD 46 25 04 0032*      call neg_hlu ; negate hlu
042544 F1          0033*      pop af      ; get back flags
042545 C9          0034*      ret
042546             0035*  
042546             0036*  ; flip the sign of hlu
042546             0037*  ; inputs: hlu
042546             0038*  ; returns: 0-hlu, flags set appropriately for the result:
042546             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
042546             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
042546             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
042546             0042*  ; destroys a
042546             0043*  neg_hlu:
042546 D5          0044*      push de     ; save de
042547 EB          0045*      ex de,hl    ; put hl into de
042548 21 00 00 00 0046*      ld hl,0     ; clear hl
04254C AF          0047*      xor a       ; clear carry
04254D ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
04254F D1          0049*      pop de      ; get de back
042550 C9          0050*      ret         ; easy peasy
042551             0051*  
042551             0052*  ;------------------------------------------------------------------------
042551             0053*  ; divide hlu by 2, inspired by above
042551             0054*  ;------------------------------------------------------------------------
042551             0055*  hlu_div2:
042551 22 30 25 04 0056*  	ld		(scratch1),hl
042555 21 32 25 04 0057*  	ld		hl,scratch1+2
042559 CB 1E       0058*  	rr		(hl)
04255B 2B          0059*  	dec		hl
04255C CB 1E       0060*  	rr		(hl)
04255E 2B          0061*  	dec		hl
04255F CB 1E       0062*  	rr		(hl)
042561 23          0063*  	inc		hl
042562 23          0064*  	inc		hl
042563 2A 30 25 04 0065*      ld hl,(scratch1)
042567 C9          0066*      ret
042568             0067*  
042568             0068*  ; this is my little hack to divide by 16
042568             0069*  hlu_div16:
042568 AF          0070*      xor a
042569 29          0071*      add hl,hl
04256A 17          0072*      rla
04256B 29          0073*      add hl,hl
04256C 17          0074*      rla
04256D 29          0075*      add hl,hl
04256E 17          0076*      rla
04256F 29          0077*      add hl,hl
042570 17          0078*      rla
042571 22 7E 25 04 0079*      ld (@scratch),hl
042575 32 81 25 04 0080*      ld (@scratch+3),a
042579 2A 7F 25 04 0081*      ld hl,(@scratch+1)
04257D C9          0082*      ret
04257E             0083*  @scratch: ds 4
042582             0084*  
042582             0085*  ; hlu signed division by 256
042582             0086*  ; returns: hlu / 256
042582             0087*  ; destroys: af
042582             0088*  hlu_sdiv256:
042582 AF          0089*      xor a ; assume hl is positive
042583 22 99 25 04 0090*      ld (@buffer),hl
042587             0091*      sign_hlu
042587 19          0001*M         add hl,de
042588 B7          0002*M         or a
042589 ED 52       0003*M         sbc hl,de
04258B F2 90 25 04 0092*      jp p,@hl_pos
04258F 3D          0093*      dec a
042590             0094*  @hl_pos:
042590 32 9C 25 04 0095*      ld (@buffer+3),a
042594 2A 9A 25 04 0096*      ld hl,(@buffer+1)
042598 C9          0097*      ret
042599             0098*  @buffer: ds 4
04259D             0099*  
04259D             0100*  ; hlu 1 byte right shift, unsigned
04259D             0101*  ; returns: hlu / 256, fractional portion in a
04259D             0102*  ; destroys: af
04259D             0103*  hlu_udiv256:
04259D AF          0104*  	xor a
04259E 32 AF 25 04 0105*  	ld (@buffer+3),a
0425A2 7D          0106*  	ld a,l ; save the fractional portion
0425A3 22 AC 25 04 0107*  	ld (@buffer),hl
0425A7 2A AD 25 04 0108*  	ld hl,(@buffer+1)
0425AB C9          0109*  	ret
0425AC             0110*  @buffer: ds 4
0425B0             0111*  
0425B0             0112*      MACRO hlu_mul256
0425B0             0113*          add hl,hl ; * 2
0425B0             0114*          add hl,hl ; * 4
0425B0             0115*          add hl,hl ; * 8
0425B0             0116*          add hl,hl ; * 16
0425B0             0117*          add hl,hl ; * 32
0425B0             0118*          add hl,hl ; * 64
0425B0             0119*          add hl,hl ; * 128
0425B0             0120*          add hl,hl ; * 256
0425B0             0121*      ENDMACRO
0425B0             0122*  
0425B0             0123*  ; compute the modulo of hlu by deu
0425B0             0124*  ; outputs: hlu = hlu % deu
0425B0             0125*  ; destroys: f, hl
0425B0             0126*  hlu_mod:
0425B0 B7          0127*  	or a ; clear carry
0425B1             0128*  @loop:
0425B1 ED 52       0129*      sbc hl,de
0425B3 DA BB 25 04 0130*      jp c, @end
0425B7 C3 B1 25 04 0131*      jp @loop
0425BB             0132*  @end:
0425BB 19          0133*      add hl,de
0425BC C9          0134*  	ret
0425BD             0135*  
0425BD             0136*  
0425BD 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
0425C1 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
0425C5             0139*  
0425C5             0140*  ; set bcd values in a scratch memory address from registers bcde
0425C5             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
0425C5             0142*  ; destroys ; hl
0425C5             0143*  set_bcd:
0425C5 73          0144*      ld (hl),e
0425C6 23          0145*      inc hl
0425C7 72          0146*      ld (hl),d
0425C8 23          0147*      inc hl
0425C9 71          0148*      ld (hl),c
0425CA 23          0149*      inc hl
0425CB 70          0150*      ld (hl),b
0425CC C9          0151*      ret
0425CD             0152*  
0425CD             0153*  ; load bcd values from a scratch memory address to bcde
0425CD             0154*  ; input: hl; scratch address
0425CD             0155*  ; output: bcde; 8-place bcd number
0425CD             0156*  ; destroys: hl
0425CD             0157*  get_bcd:
0425CD 5E          0158*      ld e,(hl)
0425CE 23          0159*      inc hl
0425CF 56          0160*      ld d,(hl)
0425D0 23          0161*      inc hl
0425D1 4E          0162*      ld c,(hl)
0425D2 23          0163*      inc hl
0425D3 46          0164*      ld b,(hl)
0425D4 C9          0165*      ret
0425D5             0166*  
0425D5             0167*  ; BCD addition
0425D5             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425D5             0169*  ;       a is the number of bytes holding each number (number of places/2)
0425D5             0170*  ; outputs: (hl) + (de) --> (hl)
0425D5             0171*  ; destroys: a,b,de,hl
0425D5             0172*  add_bcd:
0425D5 47          0173*      ld b,a ; loop counter
0425D6 AF          0174*      xor a ; reset a, clear carry flag
0425D7             0175*  adcec:
0425D7 1A          0176*      ld a,(de) ; addend to acc
0425D8 8E          0177*      adc a,(hl) ; add (hl) to acc
0425D9 27          0178*      daa ; adjust result to bcd
0425DA 77          0179*      ld (hl),a ; store result
0425DB 23          0180*      inc hl ; advance memory pointers
0425DC 13          0181*      inc de
0425DD 10 F8       0182*      djnz adcec ; loop until b == 0
0425DF C9          0183*      ret
0425E0             0184*  
0425E0             0185*  ; BCD subtraction
0425E0             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425E0             0187*  ;       a is the number of bytes holding each number (number of places/2)
0425E0             0188*  ; outputs: (hl) - (de) --> (hl)
0425E0             0189*  ; destroys: a,b,de,hl
0425E0             0190*  sub_bcd:
0425E0 47          0191*      ld b,a ; loop counter
0425E1 AF          0192*      xor a ; reset a,clear carry flag
0425E2             0193*  subdec:
0425E2 1A          0194*      ld a,(de) ; subtrahend to acc
0425E3 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0425E4 27          0196*      daa ; adjust result to bcd
0425E5 77          0197*      ld (hl),a ; store result
0425E6 23          0198*      inc hl ; advance memory pointers
0425E7 13          0199*      inc de
0425E8 10 F8       0200*      djnz subdec ; loop until b == 0
0425EA C9          0201*      ret
0425EB             0202*  
0425EB             0203*  ; http://www.z80.info/pseudo-random.txt
0425EB             0204*  rand_8:
0425EB C5          0205*      push bc
0425EC 3A FF 25 04 0206*      ld a,(r_seed)
0425F0 4F          0207*      ld c,a
0425F1             0208*  
0425F1 0F          0209*      rrca ; multiply by 32
0425F2 0F          0210*      rrca
0425F3 0F          0211*      rrca
0425F4 EE 1F       0212*      xor 0x1f
0425F6             0213*  
0425F6 81          0214*      add a,c
0425F7 DE FF       0215*      sbc a,255 ; carry
0425F9             0216*  
0425F9 32 FF 25 04 0217*      ld (r_seed),a
0425FD C1          0218*      pop bc
0425FE C9          0219*      ret
0425FF 50          0220*  r_seed: defb $50
042600             0058   	include "trig24fast.inc"
042600             0001*  
042600             0002*  ; convert signed angles from a 360 to 256 degree circle
042600             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
042600             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
042600             0005*  ; destroys: TODO
042600             0006*  deg_360_to_256:
042600 D5          0007*  	push de ; preserve de
042601             0008*  ; make angle positive and store sign flag
042601 CD 36 25 04 0009*  	call hlu_abs
042605 F5          0010*  	push af
042606             0011*  ; multiply by 256 first to keep precision
042606             0012*  	hlu_mul256 ; uh.l = uh.l * 256
042606 29          0001*M         add hl,hl ; * 2
042607 29          0002*M         add hl,hl ; * 4
042608 29          0003*M         add hl,hl ; * 8
042609 29          0004*M         add hl,hl ; * 16
04260A 29          0005*M         add hl,hl ; * 32
04260B 29          0006*M         add hl,hl ; * 64
04260C 29          0007*M         add hl,hl ; * 128
04260D 29          0008*M         add hl,hl ; * 256
04260E             0013*  ; divide uh.l by 360
04260E 11 68 01 00 0014*  	ld de,360
042612 CD A6 30 04 0015*  	call udiv24 ; ud.e = degrees / 360
042616 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
042617             0017*  ; restore sign flag and adjust output accordingly
042617 F1          0018*  	pop af
042618 F2 20 26 04 0019*  	jp p,@pos ; positive number
04261C CD 46 25 04 0020*  	call neg_hlu
042620             0021*  @pos:
042620             0022*  ; restore de and return uh.l as the result
042620 D1          0023*  	pop de
042621 C9          0024*  	ret
042622             0025*  
042622             0026*  ; fixed 16.8 routine
042622             0027*  ; cos(uh.l) --> uh.l
042622             0028*  ; destroys: f, hl
042622             0029*  cos168:
042622 D5          0030*      push de ; preserve de
042623             0031*  ; for cos we simply increment the angle by 90 degrees
042623             0032*  ; or 0x004000 in 16.8 degrees256
042623             0033*  ; which makes it a sin problem
042623 11 00 40 00 0034*      ld de,0x004000
042627 19          0035*      add hl,de ; modulo 256 happens below
042628 D1          0036*      pop de ; restore de
042629             0037*  ; fall through to sin168
042629             0038*  
042629             0039*  ; ---------------------
042629             0040*  ; fixed 16.8 routine
042629             0041*  ; sin(uh.l) --> uh.l
042629             0042*  ; destroys: f, hl
042629             0043*  sin168:
042629 D5          0044*  	push de
04262A             0045*  ; handle negative angles appropriately
04262A CD 36 25 04 0046*  	call hlu_abs
04262E F2 37 26 04 0047*  	jp p,@F
042632 11 00 00 FF 0048*  	ld de,-256*256
042636 19          0049*  	add hl,de
042637             0050*  @@:
042637 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
042639 ED 6C       0052*      mlt hl
04263B 11 71 28 04 0053*      ld de,sin_lut_168 ; grab the lut address
04263F 19          0054*      add hl,de ; bump hl by the index
042640 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
042642 D1          0056*      pop de
042643 C9          0057*      ret
042644             0058*  
042644             0059*  ; 16.8 fixed inputs / outputs
042644             0060*  ; takes: uh.l as angle in degrees 256
042644             0061*  ;        ud.e as radius
042644             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
042644             0063*  ;        displacements from origin (0,0)
042644             0064*  ; destroys: everything except indexes
042644             0065*  polar_to_cartesian:
042644             0066*  ; back up input parameters
042644 22 73 26 04 0067*      ld (@angle), hl
042648 ED 53 76 26 0068*      ld (@radius), de
       04          
04264D             0069*  ; compute dx = sin(uh.l) * ud.e
04264D CD 29 26 04 0070*      call sin168 ; uh.l = sin(uh.l)
042651 ED 5B 76 26 0071*  	ld de,(@radius)
       04          
042656 CD 1B 30 04 0072*  	call smul168 ; uh.l = dx
04265A E5          0073*      push hl
04265B             0074*  ; compute dy = -cos(uh.l) * ud.e
04265B 2A 73 26 04 0075*      ld hl,(@angle)
04265F CD 22 26 04 0076*      call cos168 ; uh.l = cos(uh.l)
042663 ED 5B 76 26 0077*      ld de,(@radius)
       04          
042668 CD 1B 30 04 0078*      call smul168    ; uh.l = dy
04266C CD 46 25 04 0079*      call neg_hlu ; invert dy for screen coords convention
042670 EB          0080*      ex de,hl       ; de = dy for output
042671 C1          0081*      pop bc          ; bc = dx for output
042672             0082*  ; and out
042672 C9          0083*      ret
042673             0084*  @angle: ds 3
042676             0085*  @radius: ds 3
042679             0086*  
042679             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042679             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042679             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042679             0090*  ;         also populates scratch locations dx168 and dy168
042679             0091*  ; destroys: a,hl,bc,de
042679             0092*  dxy168:
042679             0093*  ; compute dx = x1-x0
042679 AF          0094*      xor a ; clear carry
04267A DD E5       0095*      push ix ; move ix to hl via the stack
04267C E1          0096*      pop hl ; hl = x1
04267D ED 42       0097*      sbc hl,bc ; hl = dx
04267F 22 94 26 04 0098*      ld (dx168),hl ; dx to scratch
042683             0099*  ; compute dy = y1-y0
042683 AF          0100*      xor a ; clear carry
042684 FD E5       0101*      push iy ; move iy to hl via the stack
042686 E1          0102*      pop hl ; hl = y1
042687 ED 52       0103*      sbc hl,de ; hl = dy
042689 22 9A 26 04 0104*      ld (dy168),hl ; dy to scratch
04268D             0105*  ; populate output registers and return
04268D EB          0106*      ex de,hl        ; ud.e = dy
04268E ED 4B 94 26 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
042693 C9          0108*      ret
042694 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
04269A 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
0426A0             0111*  
0426A0             0112*  ; compute the euclidian distance between two cartesian coordinates
0426A0             0113*  ; using the formula d = sqrt(dx^2+dy^2
0426A0             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0426A0             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0426A0             0116*  ; output; uh.l is the 16.8 fixed format distance
0426A0             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
0426A0             0118*  ; destroys: a,hl,bc,de
0426A0             0119*  distance168:
0426A0 CD 79 26 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
0426A4             0121*  ; compute dy^2
0426A4 EB          0122*  	ex de,hl
0426A5 CD 36 25 04 0123*  	call hlu_abs
0426A9 E5          0124*  	push hl
0426AA D1          0125*  	pop de
0426AB CD 13 30 04 0126*  	call umul168 ; hl = dy^2
0426AF E5          0127*  	push hl ; save dy^2
0426B0             0128*  ; compute dx^2
0426B0 2A 94 26 04 0129*  	ld hl,(dx168)
0426B4 CD 36 25 04 0130*  	call hlu_abs
0426B8 E5          0131*  	push hl
0426B9 D1          0132*  	pop de
0426BA CD 13 30 04 0133*  	call umul168 ; hl = dx^2
0426BE             0134*  ; add dx^2 and dy^2
0426BE D1          0135*  	pop de ; de = dy^2
0426BF 19          0136*  	add hl,de ; hl = dx^2 + dy^2
0426C0             0137*  ; compute the square root
0426C0 CD 86 27 04 0138*  	call sqrt168
0426C4 C9          0139*  	ret
0426C5             0140*  
0426C5             0141*  ; atan2_(ub.c,ud.e) --> uh.l
0426C5             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0426C5             0143*  ;   whether inputs are integers or fractional doesn't matter
0426C5             0144*  ;   so long as the sign bit of the upper byte is correct
0426C5             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0426C5             0146*  ; angles are COMPASS HEADINGS based on
0426C5             0147*  ; screen coordinate conventions,where the y axis is flipped
0426C5             0148*  ; #E0 315      0       45 #20
0426C5             0149*  ;        -x,-y | +x,-y
0426C5             0150*  ; #C0 270------+------ 90 #40
0426C5             0151*  ;        -x,+y | +x,+y
0426C5             0152*  ; #A0 225   180 #80   135 #60
0426C5             0153*  atan2_168fast:
0426C5             0154*  ; get signs and make everything positive
0426C5             0155*  ; get abs(x) and store its original sign
0426C5 C5          0156*      push bc
0426C6 E1          0157*      pop hl
0426C7 CD 36 25 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
0426CB E5          0159*      push hl ; store abs(x)
0426CC C1          0160*      pop bc ; bc = abs(x)
0426CD F5          0161*      push af ; store sign of x
0426CE             0162*  ; get abs(y) and store its original sign
0426CE EB          0163*      ex de,hl ; hl = y
0426CF CD 36 25 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
0426D3 EB          0165*      ex de,hl ; de = abs(y)
0426D4 F5          0166*      push af ; store sign of y
0426D5             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0426D5             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
0426D5 AF          0169*      xor a ; clear the carry flag
0426D6 D5          0170*      push de
0426D7 E1          0171*      pop hl
0426D8 ED 42       0172*      sbc hl,bc
0426DA F5          0173*      push af ; save sign of de - bc
0426DB F2 E4 26 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
0426DF             0175*  ; otherwise we swap bc and de
0426DF C5          0176*      push bc
0426E0 E1          0177*      pop hl
0426E1 EB          0178*      ex de,hl
0426E2 E5          0179*      push hl
0426E3 C1          0180*      pop bc
0426E4             0181*  @1:
0426E4             0182*  ; now we're ready to snag our preliminary result
0426E4 C5          0183*  	push bc
0426E5 E1          0184*  	pop hl
0426E6 CD 54 27 04 0185*      call atan_168fast ; uh.l comes back with prelim result
0426EA             0186*  ; now we adjust uh.l based on sign of de - bc
0426EA F1          0187*      pop af
0426EB F2 F7 26 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
0426EF EB          0189*      ex de,hl
0426F0 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
0426F4 AF          0191*      xor a ; clear the carry flag
0426F5 ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
0426F7             0193*  @2:
0426F7             0194*  ; now the fun part of adjusting the result
0426F7             0195*  ; based on which quadrant (x,y) is in
0426F7             0196*  ; #E0 315      0       45 #20
0426F7             0197*  ;        -x,-y | +x,-y
0426F7             0198*  ; #C0 270------+------ 90 #40
0426F7             0199*  ;        -x,+y | +x,+y
0426F7             0200*  ; #A0 225   180 #80   135 #60
0426F7 F1          0201*      pop af ; sign of y
0426F8 CA 35 27 04 0202*      jp z,@y_zero
0426FC F2 15 27 04 0203*      jp p,@y_pos
042700             0204*  ; y neg,check x
042700 F1          0205*      pop af ; sign of x
042701 CA 0F 27 04 0206*      jp z,@y_neg_x_zero
042705 F2 14 27 04 0207*      jp p,@y_neg_x_pos
042709             0208*  ; y neg,x neg
042709             0209*  ; angle is 270-360
042709             0210*  ; negating the intermediate does the trick
042709 CD 46 25 04 0211*      call neg_hlu
04270D 18 31       0212*      jr @zero_hlu
04270F             0213*  
04270F             0214*  @y_neg_x_zero:
04270F             0215*  ; y neg,x zero
04270F             0216*  ; angle is 0
04270F 21 00 00 00 0217*      ld hl,0
042713 C9          0218*      ret
042714             0219*  @y_neg_x_pos:
042714             0220*  ; y neg,x pos
042714             0221*  ; angle is 0 to 90
042714             0222*  ; so we're good
042714 C9          0223*      ret
042715             0224*  
042715             0225*  @y_pos:
042715 F1          0226*      pop af ; sign of x
042716 CA 25 27 04 0227*      jp z,@y_pos_x_zero
04271A F2 2A 27 04 0228*      jp p,@y_pos_x_pos
04271E             0229*  ; y pos,x neg
04271E             0230*  ; angle is 180-270
04271E             0231*  ; so we add 180 to intermediate
04271E 11 00 80 00 0232*      ld de,0x008000
042722 19          0233*      add hl,de
042723 18 1B       0234*      jr @zero_hlu
042725             0235*  @y_pos_x_zero:
042725             0236*  ; y pos,x zero
042725             0237*  ; angle is 180
042725 21 00 80 00 0238*      ld hl,0x008000
042729 C9          0239*      ret
04272A             0240*  @y_pos_x_pos:
04272A             0241*  ; y pos,x pos
04272A             0242*  ; angle is 90-180
04272A             0243*  ; neg the intermediate and add 180 degrees
04272A CD 46 25 04 0244*      call neg_hlu
04272E 11 00 80 00 0245*      ld de,0x008000
042732 19          0246*      add hl,de
042733 18 0B       0247*      jr @zero_hlu
042735             0248*  
042735             0249*  @y_zero:
042735 F1          0250*      pop af ; sign of x
042736 FA 3B 27 04 0251*      jp m,@y_zero_x_neg
04273A             0252*  ; y zero,x pos
04273A             0253*  ; angle is 90,nothing to do
04273A C9          0254*      ret
04273B             0255*  @y_zero_x_neg:
04273B             0256*  ; y zero ,x neg
04273B             0257*  ; angle is 270
04273B 21 00 C0 00 0258*      ld hl,0x00C000
04273F C9          0259*      ret
042740             0260*  @zero_hlu:
042740 AF          0261*      xor a
042741 22 4E 27 04 0262*      ld (@scratch),hl
042745 32 50 27 04 0263*      ld (@scratch+2),a
042749 2A 4E 27 04 0264*      ld hl,(@scratch)
04274D C9          0265*      ret
04274E             0266*  @scratch: ds 6
042754             0267*  
042754             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042754             0269*  ; output: uh.l is the 16.8 fixed format angle
042754             0270*  ; destroys: a,hl,bc,de
042754             0271*  ; the following note was written by github copilot:
042754             0272*  ; note: this routine is a bit of a hack
042754             0273*  ;      but it works
042754             0274*  ;      and it's fast
042754             0275*  ;      and it's small
042754             0276*  ;      and it's accurate
042754             0277*  ;      and it's easy to understand
042754             0278*  ;      and it's easy to modify
042754             0279*  ;      and it's easy to use
042754             0280*  ;      and it's easy to remember
042754             0281*  ;      and it's easy to love
042754             0282*  ;      and it's easy to hate
042754             0283*  ;      and it's easy to ignore
042754             0284*  ;      and it's easy to forget
042754             0285*  ;      and it's easy to remember
042754             0286*  ;      and it's easy to forget
042754             0287*  ;      and it's easy to remember
042754             0288*  ;      (ok the bot is stuck in a loop)
042754             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
042754             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
042754             0291*  atan_168fast:
042754             0292*  ; because we use compass headings instead of geometric angles
042754             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
042754             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
042754 CD 3E 30 04 0295*  	call udiv168 ; ud.e = dx/dy
042758 EB          0296*  	ex de,hl ; uh.l = dx/dy
042759             0297*  ; test uh.l for 0
042759 19          0298*      add hl,de
04275A B7          0299*      or a
04275B ED 52       0300*      sbc hl,de
04275D 28 22       0301*      jr z,@is_zero
04275F             0302*  ; test uh.l for 1
04275F AF          0303*      xor a ; clear carry
042760 EB          0304*      ex de,hl
042761 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
042765 ED 52       0306*      sbc hl,de
042767 28 13       0307*      jr z,@is_45
042769 EB          0308*  	ex de,hl
04276A             0309*  ; no special cases so we move on
04276A             0310*  ; l contains the fractional portion of tan(uh.l)
04276A             0311*  ; we multiply it by three to get our lookup table index
04276A 26 03       0312*      ld h,3
04276C ED 6C       0313*      mlt hl ; gosh that is handy
04276E 11 00 00 00 0314*      ld de,0 ; clear deu
042772 54          0315*      ld d,h ; copy hl to de
042773 5D          0316*      ld e,l ; de contains our index
042774 21 74 2B 04 0317*      ld hl,atan_lut_168 ; grab the lut address
042778 19          0318*      add hl,de ; bump hl by the index
042779 ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
04277B C9          0320*      ret ; and out
04277C             0321*  @is_45:
04277C 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
042780 C9          0323*      ret
042781             0324*  ; for the case tan(0)
042781             0325*  @is_zero:
042781 21 00 00 00 0326*      ld hl,0x000000
042785 C9          0327*      ret
042786             0328*  
042786             0329*  ; Expects  ADL mode
042786             0330*  ; Inputs:  UH.L
042786             0331*  ; Outputs: UH.L is the 16.8 square root
042786             0332*  ;          UD.E is the difference inputHL-DE^2
042786             0333*  ;          c flag reset
042786             0334*  sqrt168:
042786 CD 90 27 04 0335*      call sqrt24
04278A EB          0336*      ex de,hl
04278B 29          0337*      add hl,hl
04278C 29          0338*      add hl,hl
04278D 29          0339*      add hl,hl
04278E 29          0340*      add hl,hl
04278F C9          0341*      ret
042790             0342*  
042790             0343*  ; Expects  ADL mode
042790             0344*  ; Inputs:  HL
042790             0345*  ; Outputs: DE is the integer square root
042790             0346*  ;          HL is the difference inputHL-DE^2
042790             0347*  ;          c flag reset
042790             0348*  sqrt24:
042790 AF          0349*      xor a
042791 45          0350*      ld b,l
042792 C5          0351*      push bc
042793 47          0352*      ld b,a
042794 57          0353*      ld d,a
042795 4F          0354*      ld c,a
042796 6F          0355*      ld l,a
042797 5F          0356*      ld e,a
042798             0357*  
042798             0358*      ;Iteration 1
042798 29          0359*      add hl,hl
042799 CB 11       0360*      rl c
04279B 29          0361*      add hl,hl
04279C CB 11       0362*      rl c
04279E 91          0363*      sub c
04279F 30 04       0364*      jr nc,$+6
0427A1 1C          0365*      inc e
0427A2 1C          0366*      inc e
0427A3 2F          0367*      cpl
0427A4 4F          0368*      ld c,a
0427A5             0369*  
0427A5             0370*      ;Iteration 2
0427A5 29          0371*      add hl,hl
0427A6 CB 11       0372*      rl c
0427A8 29          0373*      add hl,hl
0427A9 CB 11       0374*      rl c
0427AB CB 13       0375*      rl e
0427AD 7B          0376*      ld a,e
0427AE 91          0377*      sub c
0427AF 30 04       0378*      jr nc,$+6
0427B1 1C          0379*      inc e
0427B2 1C          0380*      inc e
0427B3 2F          0381*      cpl
0427B4 4F          0382*      ld c,a
0427B5             0383*  
0427B5             0384*      ;Iteration 3
0427B5 29          0385*      add hl,hl
0427B6 CB 11       0386*      rl c
0427B8 29          0387*      add hl,hl
0427B9 CB 11       0388*      rl c
0427BB CB 13       0389*      rl e
0427BD 7B          0390*      ld a,e
0427BE 91          0391*      sub c
0427BF 30 04       0392*      jr nc,$+6
0427C1 1C          0393*      inc e
0427C2 1C          0394*      inc e
0427C3 2F          0395*      cpl
0427C4 4F          0396*      ld c,a
0427C5             0397*  
0427C5             0398*      ;Iteration 4
0427C5 29          0399*      add hl,hl
0427C6 CB 11       0400*      rl c
0427C8 29          0401*      add hl,hl
0427C9 CB 11       0402*      rl c
0427CB CB 13       0403*      rl e
0427CD 7B          0404*      ld a,e
0427CE 91          0405*      sub c
0427CF 30 04       0406*      jr nc,$+6
0427D1 1C          0407*      inc e
0427D2 1C          0408*      inc e
0427D3 2F          0409*      cpl
0427D4 4F          0410*      ld c,a
0427D5             0411*  
0427D5             0412*      ;Iteration 5
0427D5 29          0413*      add hl,hl
0427D6 CB 11       0414*      rl c
0427D8 29          0415*      add hl,hl
0427D9 CB 11       0416*      rl c
0427DB CB 13       0417*      rl e
0427DD 7B          0418*      ld a,e
0427DE 91          0419*      sub c
0427DF 30 04       0420*      jr nc,$+6
0427E1 1C          0421*      inc e
0427E2 1C          0422*      inc e
0427E3 2F          0423*      cpl
0427E4 4F          0424*      ld c,a
0427E5             0425*  
0427E5             0426*      ;Iteration 6
0427E5 29          0427*      add hl,hl
0427E6 CB 11       0428*      rl c
0427E8 29          0429*      add hl,hl
0427E9 CB 11       0430*      rl c
0427EB CB 13       0431*      rl e
0427ED 7B          0432*      ld a,e
0427EE 91          0433*      sub c
0427EF 30 04       0434*      jr nc,$+6
0427F1 1C          0435*      inc e
0427F2 1C          0436*      inc e
0427F3 2F          0437*      cpl
0427F4 4F          0438*      ld c,a
0427F5             0439*  
0427F5             0440*      ;Iteration 7
0427F5 29          0441*      add hl,hl
0427F6 CB 11       0442*      rl c
0427F8 29          0443*      add hl,hl
0427F9 CB 11       0444*      rl c
0427FB CB 10       0445*      rl b
0427FD EB          0446*      ex de,hl
0427FE 29          0447*      add hl,hl
0427FF E5          0448*      push hl
042800 ED 42       0449*      sbc hl,bc
042802 30 06       0450*      jr nc,$+8
042804 7C          0451*      ld a,h
042805 2F          0452*      cpl
042806 47          0453*      ld b,a
042807 7D          0454*      ld a,l
042808 2F          0455*      cpl
042809 4F          0456*      ld c,a
04280A E1          0457*      pop hl
04280B 30 02       0458*      jr nc,$+4
04280D 23          0459*      inc hl
04280E 23          0460*      inc hl
04280F EB          0461*      ex de,hl
042810             0462*  
042810             0463*      ;Iteration 8
042810 29          0464*      add hl,hl
042811 69          0465*      ld l,c
042812 60          0466*      ld h,b
042813 ED 6A       0467*      adc hl,hl
042815 ED 6A       0468*      adc hl,hl
042817 EB          0469*      ex de,hl
042818 29          0470*      add hl,hl
042819 ED 52       0471*      sbc hl,de
04281B 19          0472*      add hl,de
04281C EB          0473*      ex de,hl
04281D 30 04       0474*      jr nc,$+6
04281F ED 52       0475*      sbc hl,de
042821 13          0476*      inc de
042822 13          0477*      inc de
042823             0478*  
042823             0479*      ;Iteration 9
042823 F1          0480*      pop af
042824 17          0481*      rla
042825 ED 6A       0482*      adc hl,hl
042827 17          0483*      rla
042828 ED 6A       0484*      adc hl,hl
04282A EB          0485*      ex de,hl
04282B 29          0486*      add hl,hl
04282C ED 52       0487*      sbc hl,de
04282E 19          0488*      add hl,de
04282F EB          0489*      ex de,hl
042830 30 04       0490*      jr nc,$+6
042832 ED 52       0491*      sbc hl,de
042834 13          0492*      inc de
042835 13          0493*      inc de
042836             0494*  
042836             0495*      ;Iteration 10
042836 17          0496*      rla
042837 ED 6A       0497*      adc hl,hl
042839 17          0498*      rla
04283A ED 6A       0499*      adc hl,hl
04283C EB          0500*      ex de,hl
04283D 29          0501*      add hl,hl
04283E ED 52       0502*      sbc hl,de
042840 19          0503*      add hl,de
042841 EB          0504*      ex de,hl
042842 30 04       0505*      jr nc,$+6
042844 ED 52       0506*      sbc hl,de
042846 13          0507*      inc de
042847 13          0508*      inc de
042848             0509*  
042848             0510*      ;Iteration 11
042848 17          0511*      rla
042849 ED 6A       0512*      adc hl,hl
04284B 17          0513*      rla
04284C ED 6A       0514*      adc hl,hl
04284E EB          0515*      ex de,hl
04284F 29          0516*      add hl,hl
042850 ED 52       0517*      sbc hl,de
042852 19          0518*      add hl,de
042853 EB          0519*      ex de,hl
042854 30 04       0520*      jr nc,$+6
042856 ED 52       0521*      sbc hl,de
042858 13          0522*      inc de
042859 13          0523*      inc de
04285A             0524*  
04285A             0525*      ;Iteration 11
04285A 17          0526*      rla
04285B ED 6A       0527*      adc hl,hl
04285D 17          0528*      rla
04285E ED 6A       0529*      adc hl,hl
042860 EB          0530*      ex de,hl
042861 29          0531*      add hl,hl
042862 ED 52       0532*      sbc hl,de
042864 19          0533*      add hl,de
042865 EB          0534*      ex de,hl
042866 30 04       0535*      jr nc,$+6
042868 ED 52       0536*      sbc hl,de
04286A 13          0537*      inc de
04286B 13          0538*      inc de
04286C             0539*  
04286C CB 1A       0540*      rr d
04286E CB 1B       0541*      rr e
042870 C9          0542*      ret
042871             0543*  
042871             0544*  sin_lut_168:
042871 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
042874 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
042877 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
04287A 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
04287D 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
042880 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
042883 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
042886 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
042889 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
04288C 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
04288F 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
042892 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
042895 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
042898 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
04289B 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
04289E 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
0428A1 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
0428A4 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
0428A7 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
0428AA 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
0428AD 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
0428B0 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
0428B3 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
0428B6 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
0428B9 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
0428BC 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
0428BF 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
0428C2 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
0428C5 A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
0428C8 A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
0428CB AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
0428CE B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
0428D1 B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
0428D4 B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
0428D7 BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
0428DA C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
0428DD C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
0428E0 C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
0428E3 CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
0428E6 D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
0428E9 D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
0428EC D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
0428EF DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
0428F2 DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
0428F5 E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
0428F8 E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
0428FB E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
0428FE EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
042901 EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
042904 EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
042907 F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
04290A F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
04290D F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
042910 F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
042913 F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
042916 F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
042919 FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
04291C FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
04291F FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
042922 FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
042925 FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
042928 FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
04292B FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
04292E FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
042931 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
042934 FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
042937 FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
04293A FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
04293D FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
042940 FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
042943 FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
042946 FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
042949 FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
04294C F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
04294F F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
042952 F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
042955 F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
042958 F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
04295B F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
04295E EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
042961 EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
042964 EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
042967 E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
04296A E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
04296D E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
042970 DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
042973 DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
042976 D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
042979 D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
04297C D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
04297F CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
042982 C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
042985 C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
042988 C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
04298B BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
04298E B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
042991 B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
042994 B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
042997 AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
04299A A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
04299D A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
0429A0 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
0429A3 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
0429A6 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
0429A9 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
0429AC 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
0429AF 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
0429B2 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
0429B5 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
0429B8 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
0429BB 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
0429BE 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
0429C1 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
0429C4 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
0429C7 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
0429CA 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
0429CD 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
0429D0 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
0429D3 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
0429D6 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
0429D9 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
0429DC 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
0429DF 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
0429E2 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
0429E5 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
0429E8 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
0429EB 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
0429EE 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
0429F1 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
0429F4 FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
0429F7 F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0429FA EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
0429FD E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
042A00 E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
042A03 DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
042A06 D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
042A09 CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
042A0C C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
042A0F C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
042A12 BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
042A15 B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
042A18 B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042A1B AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
042A1E A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
042A21 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
042A24 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
042A27 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
042A2A 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
042A2D 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
042A30 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
042A33 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
042A36 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
042A39 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
042A3C 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
042A3F 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042A42 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042A45 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
042A48 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042A4B 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
042A4E 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
042A51 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042A54 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
042A57 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
042A5A 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042A5D 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
042A60 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042A63 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
042A66 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
042A69 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
042A6C 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042A6F 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042A72 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042A75 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
042A78 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
042A7B 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042A7E 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042A81 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042A84 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
042A87 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
042A8A 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042A8D 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042A90 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042A93 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042A96 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
042A99 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042A9C 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042A9F 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042AA2 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042AA5 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
042AA8 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042AAB 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042AAE 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042AB1 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042AB4 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
042AB7 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
042ABA 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
042ABD 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
042AC0 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042AC3 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042AC6 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042AC9 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042ACC 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
042ACF 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
042AD2 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042AD5 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042AD8 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042ADB 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
042ADE 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
042AE1 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042AE4 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
042AE7 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
042AEA 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
042AED 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
042AF0 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
042AF3 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
042AF6 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
042AF9 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042AFC 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
042AFF 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
042B02 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042B05 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
042B08 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
042B0B 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
042B0E 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
042B11 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
042B14 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
042B17 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
042B1A 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
042B1D 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
042B20 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
042B23 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
042B26 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
042B29 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
042B2C 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
042B2F 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
042B32 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
042B35 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
042B38 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
042B3B 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
042B3E 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
042B41 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042B44 A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
042B47 AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
042B4A B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042B4D B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
042B50 BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042B53 C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042B56 C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
042B59 CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
042B5C D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
042B5F DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042B62 E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
042B65 E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
042B68 EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
042B6B F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042B6E FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042B71 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042B74             0802*  
042B74             0803*  atan_lut_168:
042B74 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
042B77 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
042B7A 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
042B7D 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
042B80 A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
042B83 CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
042B86 F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
042B89 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
042B8C 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
042B8F 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
042B92 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
042B95 BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
042B98 E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
042B9B 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
042B9E 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
042BA1 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
042BA4 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
042BA7 B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
042BAA DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
042BAD 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
042BB0 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
042BB3 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
042BB6 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
042BB9 A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
042BBC CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
042BBF F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
042BC2 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
042BC5 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
042BC8 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
042BCB 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
042BCE C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
042BD1 E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
042BD4 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
042BD7 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
042BDA 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
042BDD 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
042BE0 B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
042BE3 D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
042BE6 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
042BE9 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
042BEC 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
042BEF 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
042BF2 A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
042BF5 C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
042BF8 EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
042BFB 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
042BFE 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
042C01 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
042C04 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
042C07 B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
042C0A DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
042C0D 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
042C10 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
042C13 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
042C16 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
042C19 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
042C1C C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
042C1F ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
042C22 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
042C25 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
042C28 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
042C2B 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
042C2E AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
042C31 D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
042C34 FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
042C37 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
042C3A 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
042C3D 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
042C40 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
042C43 BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
042C46 E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
042C49 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
042C4C 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
042C4F 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
042C52 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
042C55 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
042C58 C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
042C5B E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
042C5E 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
042C61 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
042C64 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
042C67 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
042C6A A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
042C6D C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
042C70 EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
042C73 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
042C76 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
042C79 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
042C7C 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
042C7F A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
042C82 C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
042C85 EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
042C88 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
042C8B 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
042C8E 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
042C91 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
042C94 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
042C97 C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
042C9A E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
042C9D 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
042CA0 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
042CA3 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
042CA6 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
042CA9 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
042CAC B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
042CAF DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
042CB2 FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
042CB5 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
042CB8 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
042CBB 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
042CBE 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
042CC1 AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
042CC4 CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
042CC7 EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
042CCA 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
042CCD 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
042CD0 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
042CD3 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
042CD6 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
042CD9 BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
042CDC DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
042CDF FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
042CE2 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
042CE5 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
042CE8 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
042CEB 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
042CEE A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
042CF1 C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
042CF4 E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
042CF7 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
042CFA 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
042CFD 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
042D00 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
042D03 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
042D06 A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
042D09 C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
042D0C E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
042D0F 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
042D12 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
042D15 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
042D18 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
042D1B 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
042D1E A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
042D21 C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
042D24 E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
042D27 FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
042D2A 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
042D2D 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
042D30 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
042D33 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
042D36 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
042D39 B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
042D3C D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
042D3F F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
042D42 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
042D45 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
042D48 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
042D4B 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
042D4E 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
042D51 A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
042D54 C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
042D57 DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
042D5A FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
042D5D 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
042D60 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
042D63 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
042D66 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
042D69 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
042D6C A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
042D6F C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
042D72 E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
042D75 FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
042D78 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
042D7B 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
042D7E 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
042D81 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
042D84 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
042D87 A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
042D8A C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
042D8D DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
042D90 F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
042D93 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
042D96 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
042D99 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
042D9C 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
042D9F 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
042DA2 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
042DA5 B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
042DA8 CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
042DAB E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
042DAE 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
042DB1 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
042DB4 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
042DB7 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
042DBA 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
042DBD 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
042DC0 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
042DC3 B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
042DC6 D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
042DC9 EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
042DCC 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
042DCF 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
042DD2 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
042DD5 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
042DD8 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
042DDB 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
042DDE 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
042DE1 B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
042DE4 CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
042DE7 E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
042DEA FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
042DED 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
042DF0 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
042DF3 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
042DF6 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
042DF9 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
042DFC 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
042DFF A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
042E02 BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
042E05 D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
042E08 EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
042E0B 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
042E0E 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
042E11 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
042E14 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
042E17 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
042E1A 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
042E1D 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
042E20 A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
042E23 BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
042E26 D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
042E29 E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
042E2C FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
042E2F 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
042E32 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
042E35 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
042E38 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
042E3B 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
042E3E 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
042E41 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
042E44 AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
042E47 C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
042E4A DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
042E4D F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
042E50 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
042E53 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
042E56 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
042E59 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
042E5C 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
042E5F 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
042E62 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
042E65 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
042E68 AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
042E6B C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
042E6E D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
042E71 EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
042E74 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042E77             0059   	include "fixed24.inc"
042E77             0001*  arith24uaf: ds 6
042E7D             0002*  arith24uhl: ds 6
042E83             0003*  arith24ubc: ds 6
042E89             0004*  arith24ude: ds 6
042E8F             0005*  arith24uix: ds 6
042E95             0006*  arith24uiy: ds 6
042E9B             0007*  arith24usp: ds 6
042EA1             0008*  arith24upc: ds 6
042EA7             0009*  
042EA7             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042EA7             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042EA7             0012*  ; inputs: hlu = 24-bit number to shift
042EA7             0013*  ;         a = signed number of bits to shift
042EA7             0014*  ;         ix = output buffer address
042EA7             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042EA7             0016*  shift_hlu:
042EA7 C5          0017*      push bc ; preserve
042EA8 47          0018*      ld b,a            ; store shift value in b for later
042EA9             0019*  
042EA9             0020*  ; Initialize DE to zero and clear output buffer
042EA9 11 00 00 00 0021*      ld de, 0
042EAD DD 1F FD    0022*      ld (ix-3), de
042EB0 DD 1F 03    0023*      ld (ix+3), de
042EB3             0024*  
042EB3             0025*  ; Get absolute value of a and save its original sign
042EB3 B7          0026*      or a
042EB4 F5          0027*      push af ; save sign flag
042EB5 F2 BB 2E 04 0028*      jp p,@F ; If a is positive do nothing
042EB9 ED 44       0029*      neg ; If a is negative, negate it
042EBB             0030*  @@:
042EBB             0031*  
042EBB             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042EBB CD 36 25 04 0033*      call hlu_abs
042EBF F5          0034*      push af ; save sign of HLU
042EC0 DD 2F 00    0035*      ld (ix), hl
042EC3             0036*  
042EC3             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042EC3 78          0038*      ld a,b            ; Restore original shift value into 'a'
042EC4 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042EC6 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042EC8 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042ECA 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042ECB             0043*  
042ECB             0044*  ; Calculate remainder of a (original shift) mod 8
042ECB E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042ECD 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042ECE 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042ED2             0048*  
042ED2             0049*  ; Get back the original sign of the byte shift
042ED2 F1          0050*      pop af            ; Restore sign flag
042ED3 F2 E1 2E 04 0051*      jp p,@F           ; If a was positive, we're done
042ED7 79          0052*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042ED8 ED 44       0053*      neg               ; Negate the number of whole bytes to shift
042EDA 3D          0054*      dec a             ; Subtract 1 because that's just how this works
042EDB 4F          0055*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042EDC 1B          0056*      dec de            ; DE = -1 to make the signed addition below work
042EDD 3E 08       0057*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042EDF 90          0058*      sub b
042EE0 47          0059*      ld b,a            ; b is the number of bits to shift back up
042EE1             0060*  
042EE1             0061*  @@:
042EE1             0062*  
042EE1             0063*  ; Add the byte offset to the base address of output buffer
042EE1 59          0064*      ld e,c            ; DEU and D were properly signed above
042EE2 DD 19       0065*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042EE4             0066*  
042EE4             0067*  ; Read the byte-aligned result into HL and shift in the required number of bits
042EE4 DD 27 00    0068*      ld hl,(ix)        ; Byte-aligned result
042EE7             0069*  
042EE7             0070*  ; Check whether we're already byte-aligned
042EE7 AF          0071*      xor a
042EE8 B0          0072*      or b
042EE9 28 08       0073*      jr z,@end         ; If no bits to shift, we're done
042EEB             0074*  
042EEB             0075*  ; Otherwise shiften zee bitzen
042EEB DD 7E FF    0076*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042EEE             0077*  @loop:
042EEE 07          0078*      rlca              ; One bit to carry
042EEF             0079*  
042EEF ED 6A       0080*      adc hl,hl         ; Shift the carry into the result
042EF1             0081*  
042EF1 10 FB       0082*      djnz @loop        ; Loop until all bits are shifted up
042EF3             0083*  
042EF3             0084*  @end:
042EF3             0085*  
042EF3             0086*  ; get back HLU's original sign and negate if necessary
042EF3 F1          0087*      pop af
042EF4 F2 FC 2E 04 0088*      jp p,@F
042EF8 CD 46 25 04 0089*      call neg_hlu
042EFC             0090*  @@:
042EFC             0091*  ; return the result
042EFC DD 2F 00    0092*      ld (ix),hl        ; Store the shifted result
042EFF C1          0093*      pop bc              ; Restore BC
042F00 C9          0094*      ret
042F01             0095*  
042F01             0096*  ; operation: UHL * UDE --> UHL
042F01             0097*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042F01             0098*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042F01             0099*  ; inputs: hl = 24-bit number, de = 24-bit number,
042F01             0100*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042F01             0101*  ; outputs: umulfxout = 48-bit intermediate
042F01             0102*  ; destroys: af, hl, bc, de
042F01             0103*  umulfx:
042F01 DD E5       0104*      push ix ; preserve
042F03 F5          0105*      push af ; need later
042F04             0106*  
042F04             0107*  ; do the multiplication
042F04 CD BB 2F 04 0108*      call umul24x24
042F08             0109*  
042F08             0110*  ; shift the result to the required output precision
042F08 78          0111*      ld a,b
042F09 81          0112*      add a,c ; a is left shift from the multiplication
042F0A C1          0113*      pop bc ; b is the output precision (was a)
042F0B 90          0114*      sub b ; a is the net shift of the output
042F0C             0115*  
042F0C             0116*  ; Get absolute value of a and save its original sign
042F0C B7          0117*      or a
042F0D F5          0118*      push af ; save sign flag
042F0E F2 14 2F 04 0119*      jp p,@F ; If a is positive do nothing
042F12 ED 44       0120*      neg ; If a is negative, negate it
042F14             0121*  @@:
042F14             0122*  
042F14             0123*  ; Divide a by 8 to get the whole byte shift and bit remainder
042F14 47          0124*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042F15 CB 3F       0125*      srl a             ; a = a / 2 (shift right 1 bit)
042F17 CB 3F       0126*      srl a             ; a = a / 4 (shift right another bit)
042F19 CB 3F       0127*      srl a             ; a = a / 8 (final shift for division by 8)
042F1B 4F          0128*      ld c,a            ; c holds the number of whole bytes to shift
042F1C             0129*  
042F1C             0130*  ; Calculate remainder of a (original shift) mod 8
042F1C 78          0131*      ld a,b            ; Restore original shift value into 'a'
042F1D E6 07       0132*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042F1F 47          0133*      ld b,a            ; 'b' now holds the number of bits to shift back up
042F20 11 00 00 00 0134*      ld de,0           ; Clear deu for computing the offset address later
042F24             0135*  
042F24             0136*  ; Get back the original sign of the byte shift
042F24 F1          0137*      pop af            ; Restore sign flag
042F25 F2 33 2F 04 0138*      jp p,@F           ; If a was positive, we're done
042F29 79          0139*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042F2A ED 44       0140*      neg               ; Negate the number of whole bytes to shift
042F2C 3D          0141*      dec a             ; Subtract 1 because that's just how this works
042F2D 4F          0142*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042F2E 1B          0143*      dec de            ; DE = -1 to make the signed addition below work
042F2F 3E 08       0144*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042F31 90          0145*      sub b
042F32 47          0146*      ld b,a            ; b is the number of bits to shift back up
042F33             0147*  
042F33             0148*  @@:
042F33             0149*  
042F33             0150*  ; Add the byte offset to the base address of umulfxout
042F33 59          0151*      ld e,c            ; DEU and D were properly signed above
042F34 DD 21 50 2F 0152*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042F39 DD 19       0153*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042F3B             0154*  
042F3B             0155*  ; Read the byte-aligned result into HL and shift in the required number of bits
042F3B DD 27 00    0156*      ld hl,(ix)        ; Byte-aligned result
042F3E DD 7E FF    0157*      ld a,(ix-1)       ; One byte below
042F41             0158*  
042F41             0159*  ; Check whether we're already byte-aligned
042F41 AF          0160*      xor a
042F42 B0          0161*      or b
042F43 28 05       0162*      jr z,@end         ; If no bits to shift, we're done
042F45             0163*  
042F45             0164*  ; Otherwise shiften zee bitzen
042F45             0165*  @loop:
042F45             0166*  
042F45 07          0167*      rlca              ; One bit to carry
042F46 ED 6A       0168*      adc hl,hl         ; Shift the carry into the result
042F48             0169*  
042F48 10 FB       0170*      djnz @loop        ; Loop until all bits are shifted up
042F4A             0171*  
042F4A             0172*  @end:
042F4A             0173*  ; return the result
042F4A DD E1       0174*      pop ix ; restore
042F4C C9          0175*      ret
042F4D             0176*  
042F4D 00 00 00    0177*      dl 0 ; padding
042F50 00 00 00 00 0178*  umulfxout: blkb 6,0
       00 00       
042F56 00 00 00    0179*      dl 0 ; padding
042F59             0180*  
042F59             0181*  ; operation: UHL * UDE --> UHL
042F59             0182*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042F59             0183*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042F59             0184*  ; inputs: hl = 24-bit number, de = 24-bit number,
042F59             0185*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042F59             0186*  ; outputs: umulfxout = 48-bit intermediate
042F59             0187*  ; destroys: af, hl, bc, de
042F59             0188*  smulfx:
042F59             0189*  ; make everything positive and store sign flags
042F59 CD 36 25 04 0190*  	call hlu_abs
042F5D F5          0191*  	push af
042F5E EB          0192*  	ex de,hl
042F5F CD 36 25 04 0193*  	call hlu_abs
042F63 EB          0194*  	ex de,hl
042F64 F5          0195*  	push af
042F65             0196*  ; do the division
042F65 CD 01 2F 04 0197*      call umulfx ; hl = product
042F69             0198*  ; adjust sign of result
042F69 F1          0199*  	pop af ; sign de
042F6A FA 75 2F 04 0200*  	jp m,@de_neg
042F6E F1          0201*  	pop af ; sign hl
042F6F F0          0202*  	ret p ; both positive, nothing to do
042F70             0203*  @hl_neg:
042F70 CD 46 25 04 0204*      call neg_hlu ; de pos, hl neg, result is negative
042F74 C9          0205*      ret
042F75             0206*  @de_neg:
042F75 F1          0207*  	pop af
042F76 F8          0208*  	ret m ; both negative, nothing to do
042F77 CD 46 25 04 0209*  	call neg_hlu ; result is negative
042F7B C9          0210*  	ret
042F7C             0211*  
042F7C             0212*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042F7C             0213*  ; uses EZ80 MLT instruction for speed
042F7C             0214*  ; operation: UHL * A --> UHL
042F7C             0215*  ; destroys: AF, HL
042F7C             0216*  smul24x8:
042F7C             0217*  ; make hl positive and store sign flag
042F7C CD 36 25 04 0218*  	call hlu_abs
042F80 F5          0219*  	push af
042F81             0220*  ; do the division
042F81 CD 8C 2F 04 0221*      call umul24x8 ; hl = product
042F85             0222*  ; adjust sign of result
042F85 F1          0223*  	pop af ; sign de
042F86 F0          0224*  	ret p ; hl was positive, nothing to do
042F87 CD 46 25 04 0225*  	call neg_hlu ; result is negative
042F8B C9          0226*  	ret
042F8C             0227*  
042F8C             0228*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042F8C             0229*  ; uses EZ80 MLT instruction for speed
042F8C             0230*  ; operation: UHL * A --> AUHL
042F8C             0231*  ; destroys: AF, HL
042F8C             0232*  umul24x8:
042F8C D5          0233*  	push de ; preserve de
042F8D             0234*  ; low byte
042F8D 5D          0235*  	ld e,l
042F8E 57          0236*  	ld d,a
042F8F ED 5C       0237*  	mlt de
042F91 6B          0238*  	ld l,e ; product low byte
042F92 08          0239*  	ex af,af' ; save multiplier
042F93 7A          0240*  	ld a,d ; carry
042F94 08          0241*  	ex af,af' ; save carry, restore multiplier
042F95             0242*  ; high byte
042F95 5C          0243*  	ld e,h
042F96 57          0244*  	ld d,a
042F97 ED 5C       0245*  	mlt de
042F99 08          0246*  	ex af,af' ; save multiplier, restore carry
042F9A 83          0247*  	add a,e ; add carry
042F9B 67          0248*  	ld h,a ; product middle byte
042F9C 7A          0249*  	ld a,d ; carry
042F9D 08          0250*  	ex af,af' ; save carry, restore multiplier
042F9E             0251*  ; upper byte
042F9E E5          0252*  	push hl
042F9F 33          0253*  	inc sp
042FA0 D1          0254*  	pop de ; d = hlu
042FA1 3B          0255*  	dec sp
042FA2 5F          0256*  	ld e,a
042FA3 ED 5C       0257*  	mlt de
042FA5 08          0258*  	ex af,af' ; restore carry
042FA6 8B          0259*  	adc a,e ; add carry
042FA7 22 B8 2F 04 0260*      ld (@scratch),hl ; 7 cycles
042FAB 32 BA 2F 04 0261*      ld (@scratch+2),a ; 5 cycles
042FAF 2A B8 2F 04 0262*      ld hl,(@scratch) ; 7 cycles
042FB3             0263*  ; highest byte
042FB3 3E 00       0264*  	ld a,0 ; preserve carry flag
042FB5 8A          0265*  	adc a,d ; product highest byte
042FB6 D1          0266*  	pop de ; restore de
042FB7 C9          0267*  	ret
042FB8             0268*  @scratch: ds 3
042FBB             0269*  
042FBB             0270*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042FBB             0271*  ; operation: UHL * UDE --> umulfxout
042FBB             0272*  umul24x24:
042FBB FD 21 50 2F 0273*  	ld iy,umulfxout ; point to output buffer
       04          
042FC0 C5          0274*  	push bc
042FC1 01 00 00 00 0275*  	ld bc,0
042FC5 FD 0F 00    0276*  	ld (iy),bc
042FC8 FD 0F 03    0277*  	ld (iy+3),bc
042FCB C1          0278*  	pop bc
042FCC             0279*  
042FCC             0280*  ; STEP 1: UHL * E
042FCC 7B          0281*  	ld a,e
042FCD E5          0282*  	push hl
042FCE CD 8C 2F 04 0283*  	call umul24x8
042FD2 FD 2F 00    0284*  	ld (iy+0),hl
042FD5 FD 77 03    0285*  	ld (iy+3),a
042FD8             0286*  
042FD8             0287*  ; STEP 2: UHL * D
042FD8 E1          0288*  	pop hl
042FD9 E5          0289*  	push hl
042FDA 7A          0290*  	ld a,d
042FDB CD 8C 2F 04 0291*  	call umul24x8
042FDF CD EC 2F 04 0292*  	call @accumulate
042FE3             0293*  
042FE3             0294*  ; STEP 3: UHL * DEU
042FE3 E1          0295*  	pop hl
042FE4 D5          0296*  	push de
042FE5 33          0297*  	inc sp
042FE6 F1          0298*  	pop af
042FE7 3B          0299*  	dec sp
042FE8 CD 8C 2F 04 0300*  	call umul24x8
042FEC             0301*  
042FEC             0302*  @accumulate:
042FEC FD 23       0303*  	inc iy
042FEE             0304*  ; highest byte of product to carry
042FEE FD 77 03    0305*  	ld (iy+3),a
042FF1             0306*  ; low byte of product
042FF1 7D          0307*  	ld a,l
042FF2 FD 86 00    0308*  	add a,(iy+0)
042FF5 FD 77 00    0309*  	ld (iy+0),a
042FF8             0310*  ; high byte of product
042FF8 7C          0311*  	ld a,h
042FF9 FD 8E 01    0312*  	adc a,(iy+1)
042FFC FD 77 01    0313*  	ld (iy+1),a
042FFF             0314*  ; uppper byte of product
042FFF E5          0315*  	push hl
043000 33          0316*  	inc sp
043001 E1          0317*  	pop hl
043002 3B          0318*  	dec sp
043003 7C          0319*  	ld a,h
043004 FD 8E 02    0320*  	adc a,(iy+2)
043007 FD 77 02    0321*  	ld (iy+2),a
04300A             0322*  ; carry
04300A 3E 00       0323*  	ld a,0 ; preserve flags
04300C FD 8E 03    0324*  	adc a,(iy+3)
04300F FD 77 03    0325*  	ld (iy+3),a
043012 C9          0326*  	ret
043013             0327*  
043013             0328*  ; UH.L = UH.L*UD.E (unsigned)
043013             0329*  umul168:
043013 CD BB 2F 04 0330*  	call umul24x24
043017 FD 27 FF    0331*  	ld hl,(iy-1)
04301A C9          0332*  	ret
04301B             0333*  
04301B             0334*  ; UH.L * UD.E --> UH.L (signed)
04301B             0335*  smul168:
04301B             0336*  ; make everything positive and store sign flags
04301B CD 36 25 04 0337*  	call hlu_abs
04301F F5          0338*  	push af
043020 EB          0339*  	ex de,hl
043021 CD 36 25 04 0340*  	call hlu_abs
043025 EB          0341*  	ex de,hl
043026 F5          0342*  	push af
043027             0343*  ; do the division
043027 CD 13 30 04 0344*      call umul168 ; hl = product
04302B             0345*  ; adjust sign of result
04302B F1          0346*  	pop af ; sign de
04302C FA 37 30 04 0347*  	jp m,@de_neg
043030 F1          0348*  	pop af ; sign hl
043031 F0          0349*  	ret p ; both positive, nothing to do
043032             0350*  @hl_neg:
043032 CD 46 25 04 0351*      call neg_hlu ; de pos, hl neg, result is negative
043036 C9          0352*      ret
043037             0353*  @de_neg:
043037 F1          0354*  	pop af
043038 F8          0355*  	ret m ; both negative, nothing to do
043039 CD 46 25 04 0356*  	call neg_hlu ; result is negative
04303D C9          0357*  	ret
04303E             0358*  
04303E             0359*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
04303E             0360*  ; perform unsigned division of 16.8 fixed place values
04303E             0361*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
04303E             0362*  udiv168:
04303E             0363*  ; back up divisor
04303E ED 53 75 30 0364*  	ld (@ude),de
       04          
043043             0365*  ; get the 16-bit integer part of the quotient
043043 CD A6 30 04 0366*      call udiv24 ; de = quotient, hl = remainder
043047             0367*  ; load quotient to upper three bytes of output
043047 ED 53 7C 30 0368*      ld (div168_out+1),de
       04          
04304C             0369*  @div256:
04304C             0370*  ; multiply remainder by 256
04304C             0371*  	hlu_mul256
04304C 29          0001*M         add hl,hl ; * 2
04304D 29          0002*M         add hl,hl ; * 4
04304E 29          0003*M         add hl,hl ; * 8
04304F 29          0004*M         add hl,hl ; * 16
043050 29          0005*M         add hl,hl ; * 32
043051 29          0006*M         add hl,hl ; * 64
043052 29          0007*M         add hl,hl ; * 128
043053 29          0008*M         add hl,hl ; * 256
043054             0372*  ; skip fractional computation if remainder is zero
043054             0373*      sign_hlu
043054 19          0001*M         add hl,de
043055 B7          0002*M         or a
043056 ED 52       0003*M         sbc hl,de
043058 20 03       0374*      jr nz,@div_frac
04305A AF          0375*      xor a
04305B 18 0A       0376*      jr @write_frac
04305D             0377*  ; now divide the shifted remainder by the divisor
04305D             0378*  @div_frac:
04305D ED 5B 75 30 0379*  	ld de,(@ude) ; get back divisor
       04          
043062 CD A6 30 04 0380*      call udiv24 ; de = quotient, hl = remainder
043066             0381*  ; load low byte of quotient to low byte of output
043066 7B          0382*      ld a,e
043067             0383*  @write_frac:
043067 32 7B 30 04 0384*      ld (div168_out),a
04306B             0385*  ; load de with return value
04306B ED 5B 7B 30 0386*      ld de,(div168_out)
       04          
043070             0387*  ; load a with any overflow
043070 3A 7E 30 04 0388*      ld a,(div168_out+3)
043074 C9          0389*      ret ; ud.e is the 16.8 result
043075             0390*  @ude: ds 6
04307B             0391*  div168_out: ds 4 ; the extra byte is for overflow
04307F             0392*  
04307F             0393*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
04307F             0394*  ; perform signed division of 16.8 fixed place values
04307F             0395*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
04307F             0396*  sdiv168:
04307F             0397*  ; make everything positive and store sign flags
04307F CD 36 25 04 0398*  	call hlu_abs
043083 F5          0399*  	push af
043084 EB          0400*  	ex de,hl
043085 CD 36 25 04 0401*  	call hlu_abs
043089 EB          0402*  	ex de,hl
04308A F5          0403*  	push af
04308B             0404*  ; do the division
04308B CD 3E 30 04 0405*      call udiv168 ; de = quotient, hl = remainder
04308F             0406*  ; adjust sign of result
04308F F1          0407*  	pop af ; sign de
043090 FA 9D 30 04 0408*  	jp m,@de_neg
043094 F1          0409*  	pop af ; sign hl
043095 F0          0410*  	ret p ; both positive, nothing to do
043096             0411*  @hl_neg:
043096 EB          0412*      ex de,hl ; hl = quotient, de = remainder
043097 CD 46 25 04 0413*      call neg_hlu ; de pos, hl neg, result is negative
04309B EB          0414*      ex de,hl ; de = negated quotient, hl = remainder
04309C C9          0415*      ret
04309D             0416*  @de_neg:
04309D F1          0417*  	pop af
04309E F8          0418*  	ret m ; both negative, nothing to do
04309F EB          0419*      ex de,hl ; hl = quotient, de = remainder
0430A0 CD 46 25 04 0420*  	call neg_hlu ; result is negative
0430A4 EB          0421*      ex de,hl ; de = negated quotient, hl = remainder
0430A5 C9          0422*  	ret
0430A6             0423*  
0430A6             0424*  ;------------------------------------------------------------------------
0430A6             0425*  ;  arith24.asm
0430A6             0426*  ;  24-bit ez80 arithmetic routines
0430A6             0427*  ;  Copyright (c) Shawn Sijnstra 2024
0430A6             0428*  ;  MIT license
0430A6             0429*  ;
0430A6             0430*  ;  This library was created as a tool to help make ez80
0430A6             0431*  ;  24-bit native assembly routines for simple mathematical problems
0430A6             0432*  ;  more widely available.
0430A6             0433*  ;
0430A6             0434*  ;------------------------------------------------------------------------
0430A6             0435*  ;
0430A6             0436*  ;------------------------------------------------------------------------
0430A6             0437*  ; udiv24
0430A6             0438*  ; Unsigned 24-bit division
0430A6             0439*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0430A6             0440*  ;
0430A6             0441*  ; Uses AF BC DE HL
0430A6             0442*  ; Uses Restoring Division algorithm
0430A6             0443*  ;------------------------------------------------------------------------
0430A6             0444*  
0430A6             0445*  udiv24:
0430A6 E5          0446*  	push	hl
0430A7 C1          0447*  	pop		bc	;move dividend to BCU
0430A8 21 00 00 00 0448*  	ld		hl,0	;result
0430AC A7          0449*  	and		a
0430AD ED 52       0450*  	sbc		hl,de	;test for div by 0
0430AF C8          0451*  	ret		z		;it's zero, carry flag is clear
0430B0 19          0452*  	add		hl,de	;HL is 0 again
0430B1 3E 18       0453*  	ld		a,24	;number of loops through.
0430B3             0454*  udiv1:
0430B3 C5          0455*  	push	bc	;complicated way of doing this because of lack of access to top bits
0430B4 E3          0456*  	ex		(sp),hl
0430B5 37          0457*  	scf
0430B6 ED 6A       0458*  	adc	hl,hl
0430B8 E3          0459*  	ex	(sp),hl
0430B9 C1          0460*  	pop	bc		;we now have bc = (bc * 2) + 1
0430BA             0461*  
0430BA ED 6A       0462*  	adc	hl,hl
0430BC A7          0463*  	and	a		;is this the bug
0430BD ED 52       0464*  	sbc	hl,de
0430BF 30 02       0465*  	jr	nc,udiv2
0430C1 19          0466*  	add	hl,de
0430C2             0467*  ;	dec	c
0430C2 0B          0468*  	dec	bc
0430C3             0469*  udiv2:
0430C3 3D          0470*  	dec	a
0430C4 20 ED       0471*  	jr	nz,udiv1
0430C6 37          0472*  	scf		;flag used for div0 error
0430C7 C5          0473*  	push	bc
0430C8 D1          0474*  	pop		de	;remainder
0430C9 C9          0475*  	ret
0430CA             0060   ; App-specific includes
0430CA             0061   	include "player.inc"
0430CA             0001*  ; ######## GAME STATE VARIABLES #######
0430CA             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
0430CA 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
0430CD             0004*  ; player current shields,binary
0430CD             0005*  ; when < 0 player splodes
0430CD             0006*  ; restores to player_max_shields when new ship spawns
0430CD 10          0007*  player_shields: db 16 ; binary
0430CE             0008*  ; max player shields,binary
0430CE             0009*  ; can increase with power-ups (todo)
0430CE 10          0010*  player_max_shields: db 16 ; binary
0430CF             0011*  ; when reaches zero,game ends
0430CF             0012*  ; can increase based on TODO
0430CF 03          0013*  player_ships: db 0x03 ; binary
0430D0             0014*  
0430D0             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
0430D0             0016*  ; uses the same offsets from its table base as the main sprite table:
0430D0             0017*  player_start_variables: ; label marking beginning of table
0430D0 10          0018*  player_id:               db table_max_records
0430D1 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
0430D2 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
0430D5 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0430D8 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0430D9 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0430DA 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0430DB 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0430DE 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0430E1 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0430E4 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0430E7 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0430EA 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0430ED 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
0430F0 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
0430F1 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
0430F2 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
0430F3 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
0430F4 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
0430F5 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
0430F6             0038*  player_end_variables: ; for when we want to traverse this table in reverse
0430F6             0039*  
0430F6             0040*  ; set initial player position
0430F6             0041*  ; inputs: none,everything is hardcoded
0430F6             0042*  ; outputs: player_x/y set to bottom-left corner of screen
0430F6             0043*  ; destroys: a
0430F6             0044*  player_init:
0430F6 3A D0 30 04 0045*  	ld a,(player_id)
0430FA CD C6 23 04 0046*  	call vdu_sprite_select
0430FE CD D9 23 04 0047*      call vdu_sprite_clear_frames
043102 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
043106 CD 1B 25 04 0049*      call vdu_sprite_add_buff
04310A 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
04310E CD 1B 25 04 0051*      call vdu_sprite_add_buff
043112 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
043116 CD 1B 25 04 0053*      call vdu_sprite_add_buff
04311A 01 00 00 00 0054*      ld bc,0
04311E ED 43 DB 30 0055*      ld (player_x),bc
       04          
043123 11 00 DF 00 0056*      ld de,0x00DF00
043127 ED 53 DE 30 0057*      ld (player_y),de
       04          
04312C CD 92 24 04 0058*      call vdu_sprite_move_abs168
043130 CD 3C 24 04 0059*      call vdu_sprite_show
043134 C9          0060*      ret
043135             0061*  
043135             0062*  ; process player keyboard input, set player bitmap
043135             0063*  ; velocities and draw player bitmap at updated coordinates
043135             0064*  ; Inputs: player_x/y set at desired position
043135             0065*  ; Returns: player bitmap drawn at updated position
043135             0066*  ; Destroys: probably everything except maybe iy
043135             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
043135             0068*  ; TODO: requires sprite implementation
043135             0069*  player_input:
043135             0070*  ; reset player component velocities to zero as the default
043135 21 00 00 00 0071*  	ld hl,0
043139 22 E1 30 04 0072*  	ld (player_xvel),hl
04313D 22 E4 30 04 0073*  	ld (player_yvel),hl
043141             0074*  ; make ship the active sprite
043141 3A D0 30 04 0075*      ld a,(player_id)
043145 CD C6 23 04 0076*      call vdu_sprite_select
043149             0077*  ; check for keypresses and branch accordingly
043149             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043149             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043149 3E 1E       0001*M 			LD	A, function
04314B 5B CF       0002*M 			RST.LIL	08h
04314D             0080*  ; we test all four arrow keys and add/subract velocities accordingly
04314D             0081*  ; this handles the case where two opposing movement keys
04314D             0082*  ; are down simultaneously (velocities will net to zero)
04314D             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
04314D             0084*  ; it also allows movement and action keys to be detected simultaneously
04314D             0085*  ; so we can walk and chew gum at the same time
04314D 3E 01       0086*      ld a,1 ; set ship's default animation to center
04314F             0087*          ; if left and right are both down a will net to
04314F             0088*  
04314F             0089*  @left:
04314F DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
043153 28 0E       0091*      jr z,@right
043155 2A E1 30 04 0092*      ld hl,(player_xvel)
043159 01 00 FD FF 0093*      ld bc,-speed_player
04315D 09          0094*      add hl,bc
04315E 22 E1 30 04 0095*      ld (player_xvel),hl
043162 3D          0096*      dec a ; set ship's animation to left
043163             0097*  @right:
043163 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
043167 28 0E       0099*  	jr z,@up
043169 2A E1 30 04 0100*      ld hl,(player_xvel)
04316D 01 00 03 00 0101*      ld bc,speed_player
043171 09          0102*      add hl,bc
043172 22 E1 30 04 0103*      ld (player_xvel),hl
043176 3C          0104*      inc a ; set ship's animation to right
043177             0105*  @up:
043177 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
04317B 28 0D       0107*  	jr z,@down
04317D 2A E4 30 04 0108*      ld hl,(player_yvel)
043181 01 00 FD FF 0109*      ld bc,-speed_player
043185 09          0110*      add hl,bc
043186 22 E4 30 04 0111*      ld (player_yvel),hl
04318A             0112*  @down:
04318A DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
04318E 28 0D       0114*  	jr z,@done_keyboard
043190 2A E4 30 04 0115*      ld hl,(player_yvel)
043194 01 00 03 00 0116*      ld bc,speed_player
043198 09          0117*      add hl,bc
043199 22 E4 30 04 0118*      ld (player_yvel),hl
04319D             0119*  @done_keyboard:
04319D             0120*  ; move player sprite according to velocities set by keypresses
04319D 2A E1 30 04 0121*      ld hl,(player_xvel)
0431A1             0122*  ; compute new x position
0431A1 ED 5B DB 30 0123*      ld de,(player_x)
       04          
0431A6 19          0124*      add hl,de ; hl = player_x + player_xvel
0431A7             0125*      ; check for horizontal screen edge collisions
0431A7             0126*      ; and adjust coordinate as necessary
0431A7             0127*  ; TODO: make this work using 24-bit registers
0431A7             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
0431A7             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
0431A7             0130*      ; ld a,8 ; set x to leftmost allowable position
0431A7             0131*  ; @check_right:
0431A7             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
0431A7             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
0431A7             0134*  ;     ld a,248 ; set x to rightmost allowable position
0431A7             0135*  @x_ok:
0431A7             0136*  ; save the updated drawing coordinate
0431A7 22 DB 30 04 0137*      ld (player_x),hl
0431AB             0138*  ;compute new y position
0431AB 2A DE 30 04 0139*      ld hl,(player_y)
0431AF ED 5B E4 30 0140*      ld de,(player_yvel)
       04          
0431B4 19          0141*      add hl,de ; hl = player_y + player_yvel
0431B5             0142*  ; TODO: make this work using 24-bit registers
0431B5             0143*  ;     ; check for vertical screen edge collisions
0431B5             0144*  ;     ; and adjust coordinate as necessary
0431B5             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
0431B5             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0431B5             0147*  ;     ld a,8 ; set y to topmost allowable position
0431B5             0148*  ; @check_top:
0431B5             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
0431B5             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
0431B5             0151*  ;     ld a,232 ; set y to bottommost allowable position
0431B5             0152*  @y_ok:
0431B5 22 DE 30 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
0431B9             0154*  ; a should land here loaded with the correct frame
0431B9 CD 29 24 04 0155*      call vdu_sprite_select_frame
0431BD             0156*  ; draw player at updated position
0431BD ED 4B DB 30 0157*      ld bc,(player_x)
       04          
0431C2 ED 5B DE 30 0158*  	ld de,(player_y)
       04          
0431C7             0159*  
0431C7             0160*      ; call dumpRegistersHex
0431C7             0161*  
0431C7 CD 92 24 04 0162*  	call vdu_sprite_move_abs168
0431CB             0163*  
0431CB             0164*  ; end player_input
0431CB C9          0165*  	ret
0431CC             0166*  
0431CC             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
0431CC             0168*  ; ; INSTEAD OF FRACTIONAL
0431CC             0169*  ; ; ----------------------------------------------------------------
0431CC             0170*  ; ; process player keyboard input, set player bitmap
0431CC             0171*  ; ; velocities and draw player bitmap at updated coordinates
0431CC             0172*  ; ; Inputs: player_x/y set at desired position
0431CC             0173*  ; ; Returns: player bitmap drawn at updated position
0431CC             0174*  ; ; Destroys: probably everything except maybe iy
0431CC             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
0431CC             0176*  ; ; TODO: requires sprite implementation
0431CC             0177*  ; player_input:
0431CC             0178*  ; ; reset player component velocities to zero as the default
0431CC             0179*  ; 	ld hl,0
0431CC             0180*  ; 	ld (player_xvel),hl
0431CC             0181*  ; 	ld (player_yvel),hl
0431CC             0182*  ; ; check for keypresses and branch accordingly
0431CC             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0431CC             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0431CC             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
0431CC             0186*  ; ; this handles the case where two opposing movement keys
0431CC             0187*  ; ; are down simultaneously (velocities will net to zero)
0431CC             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
0431CC             0189*  ; ; it also allows movement and action keys to be detected simultaneously
0431CC             0190*  ; ; so we can walk and chew gum at the same time
0431CC             0191*  ; @left:
0431CC             0192*  ;     bit 1,(ix+3) ; keycode 26
0431CC             0193*  ;     jr z,@right
0431CC             0194*  ;     ld hl,(player_xvel)
0431CC             0195*  ;     ld bc,-3
0431CC             0196*  ;     add hl,bc
0431CC             0197*  ;     ld (player_xvel),hl
0431CC             0198*  ; @right:
0431CC             0199*  ;     bit 1,(ix+15) ; keycode 122
0431CC             0200*  ; 	jr z,@up
0431CC             0201*  ;     ld hl,(player_xvel)
0431CC             0202*  ;     ld bc,3
0431CC             0203*  ;     add hl,bc
0431CC             0204*  ;     ld (player_xvel),hl
0431CC             0205*  ; @up:
0431CC             0206*  ;     bit 1,(ix+7) ; keycode 58
0431CC             0207*  ; 	jr z,@down
0431CC             0208*  ;     ld hl,(player_yvel)
0431CC             0209*  ;     ld bc,-3
0431CC             0210*  ;     add hl,bc
0431CC             0211*  ;     ld (player_yvel),hl
0431CC             0212*  ; @down:
0431CC             0213*  ;     bit 1,(ix+5) ; keycode 42
0431CC             0214*  ; 	jr z,@done_keyboard
0431CC             0215*  ;     ld hl,(player_yvel)
0431CC             0216*  ;     ld bc,3
0431CC             0217*  ;     add hl,bc
0431CC             0218*  ;     ld (player_yvel),hl
0431CC             0219*  ; @done_keyboard:
0431CC             0220*  ; ; move player sprite according to velocities set by keypresses
0431CC             0221*  ;     ld hl,(player_xvel)
0431CC             0222*  ; ; compute new x position
0431CC             0223*  ;     ld de,(player_x)
0431CC             0224*  ;     add hl,de ; hl = player_x + player_xvel
0431CC             0225*  ;     ; check for horizontal screen edge collisions
0431CC             0226*  ;     ; and adjust coordinate as necessary
0431CC             0227*  ; ; TODO: make this work using 24-bit registers
0431CC             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
0431CC             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
0431CC             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
0431CC             0231*  ; ; @check_right:
0431CC             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
0431CC             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
0431CC             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
0431CC             0235*  ; @x_ok:
0431CC             0236*  ;     ; save the updated drawing coordinate
0431CC             0237*  ;     ld (player_x),hl
0431CC             0238*  ; ;compute new y position
0431CC             0239*  ;     ld hl,(player_y)
0431CC             0240*  ;     ld de,(player_yvel)
0431CC             0241*  ;     add hl,de ; hl = player_y + player_yvel
0431CC             0242*  ; ; TODO: make this work using 24-bit registers
0431CC             0243*  ; ;     ; check for vertical screen edge collisions
0431CC             0244*  ; ;     ; and adjust coordinate as necessary
0431CC             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
0431CC             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0431CC             0247*  ; ;     ld a,8 ; set y to topmost allowable position
0431CC             0248*  ; ; @check_top:
0431CC             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
0431CC             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
0431CC             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
0431CC             0252*  ; @y_ok:
0431CC             0253*  ;     ld (player_y),hl
0431CC             0254*  ; ; draw player at updated position
0431CC             0255*  ;     ld a,(player_id)
0431CC             0256*  ;     call vdu_sprite_select
0431CC             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
0431CC             0258*  ;     call get_sign_hlu ; to set the proper animation
0431CC             0259*  ;     add a,1 ; ...
0431CC             0260*  ;     call vdu_sprite_select_frame
0431CC             0261*  ;     ld bc,(player_x)
0431CC             0262*  ; 	ld de,(player_y)
0431CC             0263*  ; 	call vdu_sprite_move_abs
0431CC             0264*  ; ; end player_input
0431CC             0265*  ; 	ret
0431CC             0266*  
0431CC             0267*  
0431CC             0268*  ; ###################################################################
0431CC             0269*  ; TODO: the below is all stuff from the original code we need to port
0431CC             0270*  ; ###################################################################
0431CC             0271*  
0431CC             0272*  ; kill_player:
0431CC             0273*  ; ; set player status to dead
0431CC             0274*  ;     xor a; sets all player flags to zero
0431CC             0275*  ;     ld (player_collisions),a
0431CC             0276*  ; ; deduct a ship from the inventory
0431CC             0277*  ;     ld a,(player_ships)
0431CC             0278*  ;     dec a
0431CC             0279*  ;     ld (player_ships),a
0431CC             0280*  ; ; are we out of ships?
0431CC             0281*  ;     jp z,game_over
0431CC             0282*  ; ; wait a few ticks
0431CC             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
0431CC             0284*  ;     ld (player_move_timer),a
0431CC             0285*  ; kill_player_loop:
0431CC             0286*  ;     call vdu_vblank
0431CC             0287*  ;     ld a,(player_move_timer)
0431CC             0288*  ;     dec a
0431CC             0289*  ;     ld (player_move_timer),a
0431CC             0290*  ;     jr nz,kill_player_loop
0431CC             0291*  ;     call player_init ; player respawn if timer zero
0431CC             0292*  ;     ret ; and out
0431CC             0293*  
0431CC             0294*  
0431CC             0295*  ; player_move:
0431CC             0296*  ; ; begin setting player to active sprite
0431CC             0297*  ;     ld hl,player
0431CC             0298*  ;     ld (sprite_base_bufferId),hl
0431CC             0299*  ;     ld hl,0 ; north
0431CC             0300*  ;     ld (sprite_heading),hl
0431CC             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
0431CC             0302*  ;     ld (sprite_animation),a
0431CC             0303*  ;     ; we set position here for the time being as a default
0431CC             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
0431CC             0305*  ;     ld hl,(player_x)
0431CC             0306*  ;     ld (sprite_x),hl
0431CC             0307*  ;     ld hl,(player_y)
0431CC             0308*  ;     ld (sprite_y),hl
0431CC             0309*  ; ; did we just die?
0431CC             0310*  ;     ld a,(player_collisions)
0431CC             0311*  ;     and %00000010 ; zero flag will be set if not dead
0431CC             0312*  ;     jr z,player_not_dead
0431CC             0313*  ; ; yes we died
0431CC             0314*  ;     call kill_player
0431CC             0315*  ;     ret ; done
0431CC             0316*  ; ; yay we didn't die
0431CC             0317*  ; player_not_dead:
0431CC             0318*  ; ; set player movements to zero by default
0431CC             0319*  ;     ld hl,0
0431CC             0320*  ;     ld (player_xvel),hl
0431CC             0321*  ;     ld (player_yvel),hl
0431CC             0322*  ; ; do we move it?
0431CC             0323*  ;     in a,(#82) ; keyboard
0431CC             0324*  ;     or a ; if zero,don't move
0431CC             0325*  ;     jr z,player_draw
0431CC             0326*  ; ; move it
0431CC             0327*  ;     call player_move_calc
0431CC             0328*  ; player_draw:
0431CC             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0431CC             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0431CC             0331*  ; player_move_done:
0431CC             0332*  ;     ; write updated x,y coordinates back to player table
0431CC             0333*  ;     ld hl,(sprite_x)
0431CC             0334*  ;     ld (player_x),hl
0431CC             0335*  ;     ld hl,(sprite_y)
0431CC             0336*  ;     ld (player_y),hl
0431CC             0337*  ;     ret
0431CC             0062   	include "tiles.inc"
0431CC             0001*  ; ######### TILES #########
0431CC             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
0431CC             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
0431CC 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
0431CF 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
0431D0             0006*                          ; initialize to zero for a maximum of 256 rows in a level
0431D0 00          0007*  cur_level: db 0
0431D1             0008*  num_levels: equ 2 ; number of levels,duh
0431D1             0009*  
0431D1             0010*  ; lookup table for level definitions
0431D1 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
0431D7             0012*  
0431D7             0013*  ; tiles_bufferId: dl 0
0431D7 00 00 00    0014*  tiles_x_plot: dl 0
0431DA F1 FF FF    0015*  tiles_y_plot: dl -15
0431DD             0016*  
0431DD FF FF FF    0017*  bg_y_plot: dl -1
0431E0 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
0431E3             0019*  
0431E3             0020*  bg_plot:
0431E3             0021*  ; load current bg tile bufferId as default
0431E3 2A E0 31 04 0022*      ld hl,(bg_bufferId)
0431E7             0023*  ; check whether it is time for a new background tile
0431E7 3A DD 31 04 0024*      ld a,(bg_y_plot)
0431EB 3C          0025*      inc a
0431EC 32 DD 31 04 0026*      ld (bg_y_plot),a
0431F0 C2 08 32 04 0027*      jp nz,@F ; not time for a new tile so draw current one
0431F4             0028*  ; load the next background tile
0431F4 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
0431F8 CD EB 25 04 0030*      call rand_8
0431FC E6 03       0031*      and %0000011
0431FE 85          0032*      add a,l
0431FF 6F          0033*      ld l,a
043200 3E 00       0034*      ld a,0
043202 8C          0035*      adc a,h
043203 67          0036*      ld h,a
043204 22 E0 31 04 0037*      ld (bg_bufferId),hl
043208             0038*  @@:
043208 CD 5C 20 04 0039*      call vdu_buff_select
04320C 01 00 00 00 0040*      ld bc,0
043210 ED 5B DD 31 0041*      ld de,(bg_y_plot)
       04          
043215 CD 25 23 04 0042*      call vdu_plot_bmp
043219             0043*  ; all done
043219 C9          0044*      ret
04321A             0045*  
04321A             0046*  tiles_plot:
04321A             0047*  ; set gfx viewport to playing field window
04321A 01 00 00 00 0048*  	ld bc,field_left
04321E 11 00 00 00 0049*  	ld de,field_top
043222 DD 21 FF 00 0050*  	ld ix,field_right
       00          
043227 FD 21 4F 01 0051*  	ld iy,field_bottom
       00          
04322C CD 0F 20 04 0052*  	call vdu_set_gfx_viewport
043230             0053*  ; move the background down one pixel
043230 3E 02       0054*  	ld a,2 ; current gfx viewport
043232 2E 02       0055*  	ld l,2 ; direction=down
043234 26 01       0056*  	ld h,1 ; speed=1 px
043236 CD 87 1F 04 0057*  	call vdu_scroll_down
04323A             0058*  ; set gfx viewport to one scanline to optimise plotting tiles
04323A 01 00 00 00 0059*  	ld bc,0 ; leftmost x-coord
04323E 11 00 00 00 0060*  	ld de,0 ; topmost y-coord
043242 DD 21 FF 00 0061*  	ld ix,255 ; rightmost x-coord
       00          
043247 FD 21 00 00 0062*  	ld iy,0 ; bottommost y-coord
       00          
04324C CD 0F 20 04 0063*  	call vdu_set_gfx_viewport
043250             0064*  ; plot the background
043250 CD E3 31 04 0065*      call bg_plot
043254             0066*  ; initialize tiles loop
043254 21 00 00 00 0067*      ld hl,0 ; init plotting x-coordinate
043258 22 D7 31 04 0068*      ld (tiles_x_plot),hl
04325C 2A CC 31 04 0069*      ld hl,(tiles_row_defs)
043260 06 10       0070*  	ld b,16 ; loop counter
043262             0071*  @loop:
043262 C5          0072*  	push bc ; save the loop counter
043263             0073*  ; read the tile defintion for the current column
043263 7E          0074*      ld a,(hl) ; a has tile definition
043264 E5          0075*      push hl  ; save pointer to tile definition
043265 21 00 00 00 0076*      ld hl,0 ; hlu is non-zero
043269 6F          0077*      ld l,a ; l is tile defintion
04326A 26 01       0078*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
04326C CD 5C 20 04 0079*      call vdu_buff_select ; tile bitmap buffer is now active
043270             0080*  ; plot the active bitmap
043270 ED 4B D7 31 0081*      ld bc,(tiles_x_plot)
       04          
043275 ED 5B DA 31 0082*      ld de,(tiles_y_plot)
       04          
04327A CD 25 23 04 0083*      call vdu_plot_bmp
04327E             0084*  ; bump x-coords the width of one tile and save it
04327E 2A D7 31 04 0085*      ld hl,(tiles_x_plot)
043282 01 10 00 00 0086*      ld bc,16
043286 09          0087*      add hl,bc
043287 22 D7 31 04 0088*      ld (tiles_x_plot),hl
04328B             0089*  ; prepare to loop to next column
04328B E1          0090*      pop hl ; get back pointer to tile def
04328C 23          0091*      inc hl ; bump it to the next column
04328D C1          0092*  	pop bc ; snag our loop counter
04328E 10 D2       0093*      djnz @loop
043290             0094*  ; increment tiles plotting y-coordinate
043290             0095*  ; when it hits zero, we go to next row of tiles in the map
043290             0096*  ; (we use ix b/c we want to preserve hl for the next step)
043290 DD 21 DA 31 0097*  	ld ix,tiles_y_plot
       04          
043295 DD 34 00    0098*  	inc (ix)
043298 C0          0099*  	ret nz
043299             0100*  ; time to bump tiles_row_defs to next row
043299             0101*  ; (hl was already there at the end of the loop)
043299 22 CC 31 04 0102*      ld (tiles_row_defs),hl
04329D             0103*  ; reset coords to plot next row of tiles
04329D 21 00 00 00 0104*      ld hl,0
0432A1 22 D7 31 04 0105*      ld (tiles_x_plot),hl
0432A5 21 F1 FF FF 0106*      ld hl,-15
0432A9 22 DA 31 04 0107*      ld (tiles_y_plot),hl
0432AD             0108*  ; decrement tiles row counter
0432AD 21 CF 31 04 0109*      ld hl,tiles_row
0432B1 35          0110*      dec (hl)
0432B2 C0          0111*      ret nz
0432B3             0112*  ; queue up next level
0432B3 3A D0 31 04 0113*      ld a,(cur_level)
0432B7 FE 01       0114*      cp num_levels-1
0432B9 20 02       0115*      jr nz,@inc_level
0432BB 3E FF       0116*      ld a,-1 ; will wrap around to zero when we fall through
0432BD             0117*  @inc_level:
0432BD 3C          0118*      inc a
0432BE 32 D0 31 04 0119*      ld (cur_level),a
0432C2             0120*  ; increase the number of enemy sprites
0432C2 3A 09 33 04 0121*      ld a,(max_enemy_sprites)
0432C6 3C          0122*      inc a
0432C7 FE 10       0123*      cp table_max_records ; if we're at the global limit,skip ahead at max level
0432C9 28 04       0124*      jr z,init_level
0432CB 32 09 33 04 0125*      ld (max_enemy_sprites),a ; otherwise save the updated number
0432CF             0126*  ; fall through to init_level
0432CF             0127*  
0432CF             0128*  init_level:
0432CF             0129*  ; look up address of level's tile defintion
0432CF 21 D1 31 04 0130*      ld hl,tiles_levels
0432D3 3A D0 31 04 0131*      ld a,(cur_level)
0432D7 11 00 00 00 0132*      ld de,0 ; just in case deu is non-zero
0432DB 57          0133*      ld d,a
0432DC 1E 03       0134*      ld e,3
0432DE ED 5C       0135*      mlt de
0432E0 19          0136*      add hl,de
0432E1 ED 37       0137*      ld ix,(hl)
0432E3 DD 22 CC 31 0138*      ld (tiles_row_defs),ix
       04          
0432E8             0139*  ; set tiles_row counter
0432E8 DD 7E 00    0140*      ld a,(ix)
0432EB 32 CF 31 04 0141*      ld (tiles_row),a
0432EF DD 23       0142*      inc ix ; now ix points first element of first row tile def
0432F1 DD 22 CC 31 0143*      ld (tiles_row_defs),ix ; ... so we save it
       04          
0432F6 C9          0144*      ret
0432F7             0145*  
0432F7             0146*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
0432F7             0147*  ; dt_is_active:
0432F7             0148*  ; ; a lands here containing a tile index in the low nibble
0432F7             0149*  ; ; we test the values for the tiles which are active
0432F7             0150*  ;     cp #07
0432F7             0151*  ;     call z,ld_act_landing_pad
0432F7             0152*  ;     cp #08
0432F7             0153*  ;     call z,ld_act_laser_turret
0432F7             0154*  ;     ; fall through
0432F7             0155*  ;     ret
0432F7             0156*  
0432F7             0157*  ; ; some tiles become active sprites,so we load those here
0432F7             0158*  ; ; sprite_x/y have already been loaded
0432F7             0159*  ; ; sprite_dim_x/y are loaded by table_add_record
0432F7             0160*  ; ; we don't want sprite drawn to background like other tiles
0432F7             0161*  ; ; so this routine only adds them to the sprite table
0432F7             0162*  ; dt_ld_act:
0432F7             0163*  ;     ld a,#48 ; top of screen + 1/2 tile height
0432F7             0164*  ;     ld (sprite_y+1),a ; just the integer part
0432F7             0165*  ;     ld (sprite_base_bufferId),hl
0432F7             0166*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0432F7             0167*  ;     call table_add_record
0432F7             0168*  ;     call sprite_variables_from_stack
0432F7             0169*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
0432F7             0170*  ;     ret ; and back
0432F7             0171*  
0432F7             0172*  ; ld_act_landing_pad:
0432F7             0173*  ;     call sprite_variables_to_stack
0432F7             0174*  
0432F7             0175*  ;     ld hl,move_landing_pad
0432F7             0176*  ;     ld (sprite_move_program),hl
0432F7             0177*  
0432F7             0178*  ;     xor a
0432F7             0179*  ;     ld (sprite_animation),a ; animation 0
0432F7             0180*  
0432F7             0181*  ;     call rand_8     ; snag a random number
0432F7             0182*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0432F7             0183*  ;     add a,64 ; range is now 64-127
0432F7             0184*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0432F7             0185*  
0432F7             0186*  ;     ld a,%10 ; collides with laser but not player
0432F7             0187*  ;     ld (iy+sprite_collisions),a
0432F7             0188*  
0432F7             0189*  ;     ld a,#05 ; BCD
0432F7             0190*  ;     ld (sprite_points),a
0432F7             0191*  ;     ld a,0 ; binary
0432F7             0192*  ;     ld (sprite_shield_damage),a
0432F7             0193*  
0432F7             0194*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
0432F7             0195*  ;     jr dt_ld_act
0432F7             0196*  
0432F7             0197*  ; ld_act_laser_turret:
0432F7             0198*  ;     call sprite_variables_to_stack
0432F7             0199*  
0432F7             0200*  ;     ld hl,move_laser_turret
0432F7             0201*  ;     ld (sprite_move_program),hl
0432F7             0202*  
0432F7             0203*  ;     xor a
0432F7             0204*  ;     ld (sprite_animation),a
0432F7             0205*  ;     ld (sprite_move_step),a
0432F7             0206*  
0432F7             0207*  ;     call rand_8     ; snag a random number
0432F7             0208*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0432F7             0209*  ;     add a,64 ; range is now 64-127
0432F7             0210*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0432F7             0211*  
0432F7             0212*  ;     ld a,%10 ; collides with laser but not player
0432F7             0213*  ;     ld (iy+sprite_collisions),a
0432F7             0214*  
0432F7             0215*  ;     ld a,#10 ; BCD
0432F7             0216*  ;     ld (sprite_points),a
0432F7             0217*  ;     ld a,0 ; binary
0432F7             0218*  ;     ld (sprite_shield_damage),a
0432F7             0219*  
0432F7             0220*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
0432F7             0221*  ;     jp dt_ld_act
0432F7             0222*  
0432F7             0223*  
0432F7             0224*  ; moves active tile sprites down one pixel in sync with tiles movement
0432F7             0225*  ; deletes sprites from table when they wrap around to top of screen
0432F7             0226*  move_active_tiles:
0432F7             0227*  ; get current position
0432F7 3A 0F 00 00 0228*      ld a,(sprite_y+1) ; we only need the integer part
0432FB 3C          0229*      inc a
0432FC             0230*  ; are we at the bottom of the screen?
0432FC 20 06       0231*      jr nz,move_active_tiles_draw_sprite ; nope
0432FE             0232*  ; otherwise kill sprite
0432FE 3E 80       0233*      ld a,%10000000 ; any bit set in high nibble means sprite will die
043300 FD 77 08    0234*      ld (iy+sprite_collisions),a
043303 C9          0235*      ret ; debug
043304             0236*  move_active_tiles_draw_sprite:
043304 32 0F 00 00 0237*      ld (sprite_y+1),a ; update tile y position integer part
043308             0238*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043308             0239*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
043308 C9          0240*      ret ; and done
043309             0063   	include "enemies.inc"
043309 10          0001*  max_enemy_sprites: db 16
04330A             0002*  
04330A             0003*  ; sprite_type
04330A             0004*  enemy_dead: equ 0
04330A             0005*  enemy_small: equ 1
04330A             0006*  enemy_medium: equ 2
04330A             0007*  enemy_large: equ 3
04330A             0008*  landing_pad: equ 4
04330A             0009*  laser_turret: equ 5
04330A             0010*  fireballs: equ 6
04330A             0011*  explosion: equ 7
04330A             0012*  
04330A             0013*  
04330A             0014*  respawn_countdown:
04330A 2A 2B 33 04 0015*      ld hl,(respawn_timer)
04330E 2B          0016*      dec hl
04330F 22 2B 33 04 0017*      ld (respawn_timer),hl
043313             0018*  ; check hl for zero
043313 19          0019*      add hl,de
043314 B7          0020*      or a
043315 ED 52       0021*      sbc hl,de
043317 C0          0022*      ret nz
043318 06 10       0023*      ld b,table_max_records
04331A             0024*  @respawn_loop:
04331A C5          0025*      push bc
04331B CD AD 34 04 0026*      call enemy_init_from_landing_pad
04331F C1          0027*      pop bc
043320 10 F8       0028*      djnz @respawn_loop
043322 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
043326 22 2B 33 04 0030*      ld (respawn_timer),hl
04332A C9          0031*      ret
04332B 3C 00 00    0032*  respawn_timer: dl 1*60
04332E             0033*  
04332E             0034*  move_enemies:
04332E             0035*  ; are there any active enemies or explosions?
04332E 21 00 00 00 0036*      ld hl,0
043332 3A 45 18 04 0037*      ld a,(table_active_sprites)
043336 6F          0038*      ld l,a
043337             0039*      ; call dumpRegistersHex
043337 A7          0040*      and a ; will be zero if no alive enemies or explosions
043338             0041*      ; ret z ; so nothing to do but go back
043338             0042*      ; ld hl,(respawn_timer)
043338             0043*      ; call dumpRegistersHex
043338 20 05       0044*      jr nz,move_enemies_do
04333A CD 0A 33 04 0045*      call respawn_countdown
04333E C9          0046*      ret
04333F             0047*  move_enemies_do:
04333F             0048*  ; initialize pointers and loop counter
04333F FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
043344 06 10       0050*      ld b,table_max_records ; loop counter
043346             0051*  move_enemies_loop:
043346 FD 22 42 18 0052*      ld (table_pointer),iy ; update table pointer
       04          
04334B C5          0053*      push bc ; backup loop counter
04334C             0054*  ; check sprite_type to see if sprite is active
04334C FD 7E 01    0055*      ld a,(iy+sprite_type)
04334F A7          0056*      and a ; if zero, sprite is dead
043350 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
043352             0058*  ; otherwise we prepare to move the sprite
043352 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
043355 CD C6 23 04 0060*      call vdu_sprite_select ; select sprite
043359 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
04335C E9          0062*      jp (hl)  ; ... and jump to it
04335D             0063*  ; we always jp back here from behavior subroutines
04335D             0064*  move_enemies_loop_return:
04335D FD 2A 42 18 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
043362             0066*  ; now we check results of all the moves
043362 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
043365 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
043367 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
04336A 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
04336C CD 8E 18 04 0071*      call table_deactivate_sprite ; otherwise we ded
043370 AF          0072*      xor a ; zero a so that we can ...
043371 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
043374 18 0A       0074*      jr move_enemies_next_record ; and to the next record
043376             0075*  move_enemies_draw_sprite:
043376             0076*  ; if we got here sprite will have already been activated
043376             0077*  ; so all we need to do is set its coordinates and draw it
043376 FD 07 0B    0078*      ld bc,(iy+sprite_x)
043379 FD 17 0E    0079*      ld de,(iy+sprite_y)
04337C CD 92 24 04 0080*      call vdu_sprite_move_abs168
043380             0081*  ; fall through to next record
043380             0082*  move_enemies_next_record:
043380 11 26 00 00 0083*      ld de,table_bytes_per_record
043384 FD 19       0084*      add iy,de ; point to next record
043386 AF          0085*      xor a ; clears carry flag
043387 32 46 18 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
04338B C1          0087*      pop bc ; get back our loop counter
04338C 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
04338E C9          0089*      ret ; and we're out
04338F             0090*  
04338F             0091*  en_nav_zigzag_start:
04338F FD 2A 42 18 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043394 CD EB 25 04 0093*      call rand_8
043398 E6 3F       0094*      and %00111111 ; limit it to 64
04339A CB DF       0095*      set 3,a ; make sure it's at least 8
04339C FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
04339F             0097*      ; fall through to en_nav_zigzag
04339F             0098*  en_nav_zigzag:
04339F FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
0433A2 3D          0100*      dec a
0433A3 FD 77 22    0101*      ld (iy+sprite_move_timer),a
0433A6 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
0433A8             0103*      ; otherwise flip direction and restart timer
0433A8 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
0433AB EE 01       0105*      xor %1 ; flips bit one
0433AD FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
0433B0 20 09       0107*      jr nz,en_nav_zigzag_right
0433B2             0108*  ;otherwise zag left
0433B2 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
0433B6 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
0433B9 18 D4       0111*      jr en_nav_zigzag_start
0433BB             0112*  en_nav_zigzag_right:
0433BB 21 00 60 00 0113*      ld hl,0x006000; southeast heading
0433BF FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
0433C2 18 CB       0115*      jr en_nav_zigzag_start
0433C4             0116*  en_nav_zigzag_no_switch:
0433C4             0117*      ; ld a,(sprite_orientation)
0433C4 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
0433C7 18 13       0119*      jr en_nav_computevelocities
0433C9             0120*  
0433C9             0121*  ; contains the logic for how to move the enemy
0433C9             0122*  ; and then does the moving
0433C9             0123*  ; inputs: a fully-populated active sprite table
0433C9             0124*  ;         player position variables
0433C9             0125*  ; destroys: everything except index registers
0433C9             0126*  ; outputs: moving enemies
0433C9             0127*  en_nav:
0433C9             0128*  ; set velocity and orientation by player's relative location
0433C9             0129*  ; move enemies y-axis
0433C9             0130*  ; where is player relative to us?
0433C9 CD 30 35 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
0433CD             0132*  ; is player above or below us?
0433CD ED 53 3B 1E 0133*      ld (ude),de ; dy
       04          
0433D2 3A 3D 1E 04 0134*      ld a,(ude+2) ; deu
0433D6 17          0135*      rla ; shift sign bit into carry
0433D7 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
0433D9             0137*  ; player is even or above,so home in on current heading
0433D9 FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
0433DC             0139*  
0433DC             0140*  ; we land here from zig-zag program so as not to
0433DC             0141*  ; redundantly save orientation and heading
0433DC             0142*  en_nav_computevelocities:
0433DC             0143*  ; set x/y component velocities based on bearing to player
0433DC FD 2A 42 18 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0433E1 E5          0145*      push hl ; we need it back to set rotation frame
0433E2 FD 17 17    0146*      ld de,(iy+sprite_vel)
0433E5 CD 44 26 04 0147*      call polar_to_cartesian
0433E9 FD 2A 42 18 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0433EE FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
0433F1 FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
0433F4             0151*  ; change the animation frame to match heading
0433F4             0152*  ; by dividng the heading by 8
0433F4 E1          0153*      pop hl ; get back Heading
0433F5 7C          0154*      ld a,h
0433F6 CB 3F       0155*      srl a
0433F8 CB 3F       0156*      srl a
0433FA CB 3F       0157*      srl a
0433FC CD 29 24 04 0158*      call vdu_sprite_select_frame
043400             0159*  
043400             0160*  move_enemy_sprite:
043400 FD 2A 42 18 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043405             0162*  ; x-axis movement
043405 FD 27 0B    0163*      ld hl,(iy+sprite_x)
043408 FD 17 11    0164*      ld de,(iy+sprite_xvel)
04340B 19          0165*      add hl,de
04340C FD 2F 0B    0166*      ld (iy+sprite_x),hl
04340F             0167*  ; y-axis movement
04340F FD 27 0E    0168*      ld hl,(iy+sprite_y)
043412 FD 17 14    0169*      ld de,(iy+sprite_yvel)
043415 19          0170*      add hl,de
043416 FD 2F 0E    0171*      ld (iy+sprite_y),hl
043419             0172*  ; detect screen edge collisions
043419 AF          0173*      xor a  ; reset screen edge collision flag and clear carry
04341A 32 46 18 04 0174*      ld (sprite_screen_edge),a
04341E             0175*  ; y-axis first since we already have it in hl
04341E 11 00 00 00 0176*      ld de,-sprite_top*256
043422 ED 5A       0177*      adc hl,de
043424 FA 4E 34 04 0178*      jp m,@top
043428 ED 52       0179*      sbc hl,de ; hl back to original value
04342A 11 00 C1 FE 0180*      ld de,-sprite_bottom*256
04342E ED 5A       0181*      adc hl,de
043430 F2 58 34 04 0182*      jp p,@bottom
043434             0183*  @xaxis:
043434 FD 27 0B    0184*      ld hl,(iy+sprite_x)
043437 11 00 00 00 0185*      ld de,-sprite_left*256
04343B ED 5A       0186*      adc hl,de
04343D FA 73 34 04 0187*      jp m,@left
043441 ED 52       0188*      sbc hl,de ; hl back to original value
043443 11 00 11 FF 0189*      ld de,-sprite_right*256
043447 ED 5A       0190*      adc hl,de
043449 F2 81 34 04 0191*      jp p,@right
04344D             0192*  ; no edge collisions so go home
04344D C9          0193*      ret
04344E             0194*  @top:
04344E 3E 08       0195*      ld a,collide_top
043450 21 00 00 00 0196*      ld hl,sprite_top*256
043454 C3 5E 34 04 0197*      jp @collide_y
043458             0198*  @bottom:
043458 3E 04       0199*      ld a,collide_bottom
04345A 21 00 3F 01 0200*      ld hl,sprite_bottom*256
04345E             0201*  @collide_y:
04345E 32 46 18 04 0202*      ld (sprite_screen_edge),a
043462 FD 2F 0E    0203*      ld (iy+sprite_y),hl
043465             0204*  ; reverse y-axis velocity
043465 FD 27 14    0205*      ld hl,(iy+sprite_yvel)
043468 CD 46 25 04 0206*      call neg_hlu
04346C FD 2F 14    0207*      ld (iy+sprite_yvel),hl
04346F             0208*  ; go check for x-axis collisions
04346F C3 34 34 04 0209*      jp @xaxis
043473             0210*  @left:
043473 3A 46 18 04 0211*      ld a,(sprite_screen_edge)
043477 F6 02       0212*      or a,collide_left
043479 21 00 00 00 0213*      ld hl,sprite_left*256
04347D C3 8B 34 04 0214*      jp @collide_x
043481             0215*  @right:
043481 3A 46 18 04 0216*      ld a,(sprite_screen_edge)
043485 F6 01       0217*      or a,collide_right
043487 21 00 EF 00 0218*      ld hl,sprite_right*256
04348B             0219*  @collide_x:
04348B 32 46 18 04 0220*      ld (sprite_screen_edge),a
04348F FD 2F 0B    0221*      ld (iy+sprite_x),hl
043492             0222*  ; reverse x-axis velocity
043492 FD 27 11    0223*      ld hl,(iy+sprite_xvel)
043495 CD 46 25 04 0224*      call neg_hlu
043499 FD 2F 11    0225*      ld (iy+sprite_xvel),hl
04349C             0226*  ; final collision flag to a and return
04349C 3A 46 18 04 0227*      ld a,(sprite_screen_edge)
0434A0 C9          0228*      ret
0434A1             0229*  
0434A1             0230*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
0434A1             0231*  ; ; each sprite in the table must have one of these defined
0434A1             0232*  ; ; but they need not be unique to a particular sprite
0434A1             0233*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
0434A1             0234*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
0434A1             0235*  ; ; but they can call anything they want between those two endpoints
0434A1             0236*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
0434A1             0237*  
0434A1             0238*  ; move_nop: ; does nothing but burn a few cycles changing the PC
0434A1             0239*  ;     jp move_enemies_loop_return
0434A1             0240*  
0434A1             0241*  ; move_explosion:
0434A1             0242*  ;     call animate_explosion
0434A1             0243*  ;     jp move_enemies_loop_return
0434A1             0244*  
0434A1             0245*  move_enemy_small:
0434A1 CD C9 33 04 0246*      call en_nav
0434A5 CD C9 35 04 0247*      call check_collisions
0434A9 C3 5D 33 04 0248*      jp move_enemies_loop_return
0434AD             0249*  
0434AD             0250*  ; move_enemy_medium:
0434AD             0251*  ;     call en_nav
0434AD             0252*  ;     call check_collisions
0434AD             0253*  ;     jp move_enemies_loop_return
0434AD             0254*  
0434AD             0255*  ; move_enemy_large:
0434AD             0256*  ;     call en_nav
0434AD             0257*  ;     call check_collisions
0434AD             0258*  ;     jp move_enemies_loop_return
0434AD             0259*  
0434AD             0260*  ; move_landing_pad:
0434AD             0261*  ;     call move_active_tiles
0434AD             0262*  ;     call check_collisions
0434AD             0263*  ; ; is it time to launch an enemy?
0434AD             0264*  ;     ld hl,sprite_move_timer
0434AD             0265*  ;     dec (hl)
0434AD             0266*  ;     jp nz,move_enemies_loop_return
0434AD             0267*  ;     call enemy_init_from_landing_pad
0434AD             0268*  ;     ; reset move timer so can spawn again if player doesn't take us out
0434AD             0269*  ;     call rand_8     ; snag a random number
0434AD             0270*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0434AD             0271*  ;     add a,64 ; range is now 64-127
0434AD             0272*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0434AD             0273*  ;     jp move_enemies_loop_return
0434AD             0274*  
0434AD             0275*  enemy_init_from_landing_pad:
0434AD             0276*  ; get next available spriteId
0434AD CD 69 18 04 0277*      call table_get_next_id
0434B1 D0          0278*      ret nc ; no carry means no free sprite slots, so we go home
0434B2             0279*  ; ix comes back with the pointer to the new sprite variables
0434B2 DD E5       0280*      push ix ; de picks it up when we're ready for the copy to the table
0434B4             0281*  ; a comes back with the spriteId of the new sprite
0434B4 32 0A 35 04 0282*      ld (@id),a
0434B8             0283*  ; initialize the new sprite
0434B8 CD C6 23 04 0284*      call vdu_sprite_select
0434BC CD D9 23 04 0285*      call vdu_sprite_clear_frames
0434C0 21 14 01 00 0286*      ld hl,BUF_SEEKER_000
0434C4 06 20       0287*      ld b,32
0434C6             0288*  @load_frames:
0434C6 C5          0289*      push bc
0434C7 E5          0290*      push hl
0434C8 CD 1B 25 04 0291*      call vdu_sprite_add_buff
0434CC E1          0292*      pop hl
0434CD 23          0293*      inc hl
0434CE C1          0294*      pop bc
0434CF 10 F5       0295*      djnz @load_frames
0434D1             0296*  ; copy coordinates of active sprite to new sprite
0434D1 FD 2A 42 18 0297*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0434D6             0298*      ; ld hl,(iy+sprite_x)
0434D6             0299*  	; ld hl,0x008000 ; debug
0434D6             0300*  
0434D6 CD EB 25 04 0301*      call rand_8
0434DA 21 00 00 00 0302*      ld hl,0
0434DE 67          0303*      ld h,a
0434DF             0304*  
0434DF 22 15 35 04 0305*      ld (@x),hl
0434E3             0306*      ; ld hl,(iy+sprite_y)
0434E3             0307*      ; ld hl,0x002000 ; debug
0434E3             0308*  
0434E3 CD EB 25 04 0309*      call rand_8
0434E7 21 00 00 00 0310*      ld hl,0
0434EB 67          0311*      ld h,a
0434EC             0312*  
0434EC 22 18 35 04 0313*      ld (@y),hl
0434F0 CD EB 25 04 0314*      call rand_8
0434F4 E6 01       0315*      and %00000001 ; 50/50 chance of moving left or right on spanw
0434F6 32 2D 35 04 0316*      ld (@move_step),a
0434FA             0317*  ; now copy to the table
0434FA 21 0A 35 04 0318*      ld hl,@id ; address to copy from
0434FE D1          0319*      pop de ; address to copy to (was ix)
0434FF 01 26 00 00 0320*      ld bc,table_bytes_per_record ; number of bytes to copy
043503 ED B0       0321*      ldir ; copy the records from local scratch to sprite table
043505             0322*  ; finally, make the new sprite visible
043505 CD 3C 24 04 0323*      call vdu_sprite_show
043509 C9          0324*      ret
04350A 00          0325*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
04350B 01          0326*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
04350C 14 01 00    0327*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
04350F A1 34 04    0328*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
043512 03          0329*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
043513 10          0330*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
043514 10          0331*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
043515 00 00 00    0332*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
043518 00 00 00    0333*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
04351B 00 00 00    0334*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04351E 00 00 00    0335*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043521 80 02 00    0336*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
043524 00 80 00    0337*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043527 00 80 00    0338*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
04352A 00          0339*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
04352B 00          0340*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
04352C 01          0341*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
04352D 00          0342*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
04352E 20          0343*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
04352F 02          0344*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
043530             0345*  
043530             0346*  ; move_laser_turret:
043530             0347*  ; ; compute orientation to player
043530             0348*  ;     call orientation_to_player
043530             0349*  ; ; h.l 8.8 fixed angle256 to player
043530             0350*  ; ; bc and de as signed 16-bit integers
043530             0351*  ; ; representing delta-x/y *to* target respectively
043530             0352*  ;     ld (Bearing_t),hl
043530             0353*  ;     ld hl,0x0400
043530             0354*  ;     ld (Vp),hl
043530             0355*  ;     call targeting_computer
043530             0356*  ;     ld (sprite_heading),hl ; store bearing to player
043530             0357*  ; ; is it time to launch a fireball?
043530             0358*  ;     ld hl,sprite_move_timer
043530             0359*  ;     dec (hl)
043530             0360*  ;     jp nz,move_laser_turret_boilerplate
043530             0361*  ;     call fireballs_init
043530             0362*  ;     ; reset move timer so can fire again if player doesn't take us out
043530             0363*  ;     call rand_8     ; snag a random number
043530             0364*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043530             0365*  ;     add a,64 ; range is now 64-127
043530             0366*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043530             0367*  ; move_laser_turret_boilerplate:
043530             0368*  ;     call move_active_tiles
043530             0369*  ;     call check_collisions
043530             0370*  ;     jp move_enemies_loop_return
043530             0371*  
043530             0372*  ; fireballs_init:
043530             0373*  ;     call sprite_variables_to_stack
043530             0374*  
043530             0375*  ;     ld hl,fireballs
043530             0376*  ;     ld (sprite_base_bufferId),hl
043530             0377*  
043530             0378*  ;     ld hl,move_fireballs
043530             0379*  ;     ld (sprite_move_program),hl
043530             0380*  
043530             0381*  ;     ld a,%11 ; collides with laser and player
043530             0382*  ;     ; ld a,%10 ; collides with laser DEBUG
043530             0383*  ;     ld (iy+sprite_collisions),a
043530             0384*  
043530             0385*  ;     ld hl,(Vp)
043530             0386*  ;     ld (sprite_vel),hl
043530             0387*  ;     ld hl,(Vp_x)
043530             0388*  ;     ld (sprite_xvel),hl
043530             0389*  ;     ld hl,(Vp_y)
043530             0390*  ;     inc h ; account for ground movement
043530             0391*  ;     ld (sprite_yvel),hl
043530             0392*  
043530             0393*  ;     xor a ; zero a
043530             0394*  ;     ld (sprite_animation),a
043530             0395*  ;     ld (sprite_move_step),a
043530             0396*  ;     ld (sprite_move_timer),a
043530             0397*  
043530             0398*  ;     ld a,6 ; 1/10th of a second timer
043530             0399*  ;     ld (sprite_animation_timer),a
043530             0400*  
043530             0401*  ;     ld a,0x00 ; BCD
043530             0402*  ;     ld (sprite_points),a
043530             0403*  ;     ld a,1 ; binary
043530             0404*  ;     ld (sprite_shield_damage),a
043530             0405*  
043530             0406*  ;     call table_add_record ; plops that on the sprite stack for later
043530             0407*  ;     call sprite_variables_from_stack ; come back to where we started
043530             0408*  ;     ret
043530             0409*  
043530             0410*  ; move_fireballs:
043530             0411*  ;     call move_enemy_sprite ; move sprite
043530             0412*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
043530             0413*  ;     and a ; if zero we're still within screen bounds
043530             0414*  ;     jr z,move_fireballs_alive
043530             0415*  ; ; otherwise kill sprite
043530             0416*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
043530             0417*  ;     ld (iy+sprite_collisions),a
043530             0418*  ;     jp move_enemies_loop_return
043530             0419*  ; move_fireballs_alive:
043530             0420*  ;     ld a,(sprite_animation_timer)
043530             0421*  ;     dec a
043530             0422*  ;     ld (sprite_animation_timer),a
043530             0423*  ;     jr nz,move_fireballs_draw
043530             0424*  ;     ld a,(sprite_animation)
043530             0425*  ;     xor %1
043530             0426*  ;     ld (sprite_animation),a
043530             0427*  ;     ld a,6 ; 1/10th of a second timer
043530             0428*  ;     ld (sprite_animation_timer),a
043530             0429*  ;     ; fall through
043530             0430*  
043530             0431*  ; move_fireballs_draw:
043530             0432*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043530             0433*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043530             0434*  ;     call check_collisions
043530             0435*  ;     jp move_enemies_loop_return
043530             0436*  
043530             0437*  ; compute orientation to player
043530             0438*  ; based on relative positions
043530             0439*  ; returns: h.l 16.8 fixed angle256 to player
043530             0440*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
043530             0441*  ;    representing delta-x/y *to* target respectively
043530             0442*  orientation_to_player:
043530 FD 2A 42 18 0443*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043535 FD 07 0B    0444*      ld bc,(iy+sprite_x)
043538 FD 17 0E    0445*      ld de,(iy+sprite_y)
04353B DD 2A DB 30 0446*      ld ix,(player_x)
       04          
043540 FD 2A DE 30 0447*      ld iy,(player_y)
       04          
043545 CD 79 26 04 0448*      call dxy168
043549 C5          0449*      push bc
04354A D5          0450*      push de
04354B CD C5 26 04 0451*      call atan2_168fast
04354F D1          0452*      pop de
043550 C1          0453*      pop bc
043551 FD 2A 42 18 0454*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043556 C9          0455*      ret
043557             0456*  
043557             0457*  
043557             0458*  ; targeting_computer scratch variables
043557 00 00       0459*  Bearing_t: dw #0000 ; 8.8 fixed
043559 00 00       0460*  Heading_t: dw #0000 ; 8.8 fixed
04355B 00 00       0461*  Vp: dw #0000 ; 8.8 fixed
04355D 00 00       0462*  Vp_x: dw #0000 ; 8.8 fixed
04355F 00 00       0463*  Vp_y: dw #0000 ; 8.8 fixed
043561 00 00       0464*  Vt: dw #0000 ; 8.8 fixed
043563 00 00       0465*  Vt_x: dw #0000 ; 8.8 fixed
043565 00 00       0466*  Vt_y: dw #0000 ; 8.8 fixed
043567             0467*  
043567             0468*  
043567             0469*  ; ; Inputs:   see scratch variables
043567             0470*  ; ; Note:     a call to orientation_to_player provides these inputs
043567             0471*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
043567             0472*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
043567             0473*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
043567             0474*  ; targeting_computer:
043567             0475*  ; ; compute target velocity from x,y component velocities
043567             0476*  ;     ld bc,(player_xvel)
043567             0477*  ;     ld de,(player_yvel)
043567             0478*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
043567             0479*  
043567             0480*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
043567             0481*  ;     ld (Heading_t),bc
043567             0482*  ;     ld (Vt),de
043567             0483*  
043567             0484*  ; ; compute Heading_t-Bearing_t
043567             0485*  ;     ld h,b
043567             0486*  ;     ld l,c
043567             0487*  ;     ld bc,(Bearing_t)
043567             0488*  ;     and a ; clear carry
043567             0489*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
043567             0490*  
043567             0491*  ; ; compute sin(Heading_t-Bearing_t)
043567             0492*  ;     ld b,h
043567             0493*  ;     ld c,l
043567             0494*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
043567             0495*  
043567             0496*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
043567             0497*  ;     ex de,hl
043567             0498*  ;     ld bc,(Vt)
043567             0499*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
043567             0500*  
043567             0501*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
043567             0502*  ;     ld b,h
043567             0503*  ;     ld c,l
043567             0504*  ;     ld de,(Vp)
043567             0505*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
043567             0506*  ; ; answer is in radians, convert to degrees256
043567             0507*  ;     ex de,hl
043567             0508*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
043567             0509*  ;     call BC_Mul_DE_88
043567             0510*  
043567             0511*  ; ; add lead angle to target bearing
043567             0512*  ;     ld de,(Bearing_t)
043567             0513*  ;     add hl,de ; h.l=lead angle+target bearing
043567             0514*  ;     push hl
043567             0515*  
043567             0516*  ; ; compute component projectile velocities
043567             0517*  ;     ld b,h
043567             0518*  ;     ld c,l
043567             0519*  ;     ld de,(Vp)
043567             0520*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
043567             0521*  
043567             0522*  ;     ld (Vp_x),bc
043567             0523*  ;     ld (Vp_y),de
043567             0524*  ;     pop hl ; h.l=lead angle+target bearing
043567             0525*  ;     ret
043567             0526*  
043567             0527*  ; this routine vanquishes the enemy sprite
043567             0528*  ; and replaces it with an animated explosion
043567             0529*  ; we jump here instead of call because
043567             0530*  ; we want to return to differing locations in the loop
043567             0531*  ; depending on whether we're still sploding
043567             0532*  ; destroys: everything except index registers
043567             0533*  ; returns: an incandescent ball of debris and gas
043567             0534*  kill_nurple:
043567             0535*  ; ; tally up points
043567             0536*  ;     ld bc,0
043567             0537*  ;     ld a,(sprite_points)
043567             0538*  ;     ld e,a
043567             0539*  ;     ld d,0
043567             0540*  ;     ld hl,add_bcd_arg2
043567             0541*  ;     call set_bcd
043567             0542*  ;     ld hl,player_score
043567             0543*  ;     ld de,add_bcd_arg2
043567             0544*  ;     ld a,3 ; number of bytes to add
043567             0545*  ;     call add_bcd
043567             0546*  ; ; initialize explosion
043567             0547*  ; init_explosion:
043567             0548*  ;     ld hl,explosion
043567             0549*  ;     ld (sprite_base_bufferId),hl
043567             0550*  ;     ld hl,move_explosion
043567             0551*  ;     ld (sprite_move_program),hl
043567             0552*  ;     ld a,%00000000 ; collides with nothing
043567             0553*  ;     ld (iy+sprite_collisions),a
043567             0554*  ;     ld hl,0 ; north
043567             0555*  ;     ld (sprite_heading),hl
043567             0556*  ;     ld a,0x04 ; will decrement to 03
043567             0557*  ;     ld (sprite_animation),a
043567             0558*  ;     ld a,0x07 ; 7/60th of a second timer
043567             0559*  ;     ld (sprite_animation_timer),a
043567             0560*  ;     xor a
043567             0561*  ;     ld (sprite_move_timer),a
043567             0562*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043567             0563*  ; ; fall through to next_explosion
043567             0564*  ; next_explosion:
043567             0565*  ;     ld a,(sprite_animation)
043567             0566*  ;     dec a ; if rolled negative from zero,we're done sploding
043567             0567*  ;     jp m,done_explosion
043567             0568*  ;     ld (sprite_animation),a
043567             0569*  ;     ld a,0x7 ; 7/60th of a second timer
043567             0570*  ;     ld (sprite_animation_timer),a
043567             0571*  ; ; fall through to animate_explosion
043567             0572*  ; animate_explosion:
043567             0573*  ;     ld hl,sprite_y+1
043567             0574*  ;     inc (hl) ; move explosion down 1 pixel
043567             0575*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
043567             0576*  ;     ld hl,sprite_animation_timer
043567             0577*  ;     dec (hl) ; if timer is zero,we do next animation
043567             0578*  ;     jr z,next_explosion
043567             0579*  ;     ;otherwise we fall through to draw the current one
043567             0580*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043567             0581*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043567             0582*  ;     ret ; now we go back to caller
043567             0583*  ; done_explosion:
043567 3E 80       0584*      ld a,%10000000 ; high bit set is non-specific kill-me flag
043569 FD 2A 42 18 0585*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
04356E FD 77 08    0586*      ld (iy+sprite_collisions),a
043571 C9          0587*      ret ; now we go back to caller
043572             0588*  
043572             0589*  ; game_over:
043572             0590*  ;     jp new_game
043572             0591*  
043572             0592*  ; it's presumed we've already checked that laser is alive
043572             0593*  collision_enemy_with_laser:
043572 DD 2A 01 36 0594*      ld ix,(laser_x)
       04          
043577 FD 2A 04 36 0595*      ld iy,(laser_y)
       04          
04357C 3A FF 35 04 0596*      ld a,(laser_dim_x)
043580 CB 2F       0597*      sra a ; divide by 2
043582 F5          0598*      push af ; we need this later
043583 C3 98 35 04 0599*      jp collision_enemy
043587             0600*  
043587             0601*  ; it's presumed we've already checked that player is alive
043587             0602*  collision_enemy_with_player:
043587 DD 2A DB 30 0603*      ld ix,(player_x)
       04          
04358C FD 2A DE 30 0604*      ld iy,(player_y)
       04          
043591 3A D9 30 04 0605*      ld a,(player_dim_x)
043595 CB 2F       0606*      sra a ; divide by 2
043597 F5          0607*      push af ; we need this later
043598             0608*      ; fall through to collision_enemy
043598             0609*  
043598             0610*  ; compute the distance between the two sprites' centers
043598             0611*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
043598             0612*  collision_enemy:
043598             0613*  ; back up iy because we need it as the sprite table pointer
043598 FD E5       0614*      push iy
04359A FD 2A 42 18 0615*      ld iy,(table_pointer)
       04          
04359F FD 27 0B    0616*      ld hl,(iy+sprite_x)
0435A2 FD 7E 09    0617*      ld a,(iy+sprite_dim_x)
0435A5 CB 2F       0618*      sra a
0435A7 F5          0619*      push af ; we need this later
0435A8 E5          0620*      push hl
0435A9 C1          0621*      pop bc ; bc = x0
0435AA FD 27 0E    0622*      ld hl,(iy+sprite_y)
0435AD FD 7E 0A    0623*      ld a,(iy+sprite_dim_y)
0435B0 EB          0624*      ex de,hl ; de = y0
0435B1 F1          0625*      pop af ; TODO: srsly, this is the best way to do this?
0435B2 FD E1       0626*      pop iy
0435B4 F5          0627*      push af
0435B5 CD A0 26 04 0628*      call distance168
0435B9             0629*  
0435B9             0630*  ; ; subtract sum of radii from distance between centers
0435B9             0631*  ;     ld de,0
0435B9             0632*  ;     pop af ; radius of enemy sprite
0435B9             0633*  ;     ld e,a
0435B9             0634*  ;     pop af ; radius of player or laser sprite
0435B9             0635*  ;     add a,e
0435B9             0636*  ;     ld e,a
0435B9             0637*  ;     and a ; clear carry
0435B9             0638*  ;     sbc hl,de
0435B9             0639*  ;     jr c,collision_enemy_is
0435B9             0640*  ;     xor a
0435B9             0641*  ;     ret
0435B9             0642*  ; temp fix TODO: remove this
0435B9 F1          0643*      pop af
0435BA F1          0644*      pop af
0435BB 11 00 10 00 0645*      ld de,16*256
0435BF A7          0646*      and a
0435C0 ED 52       0647*      sbc hl,de
0435C2 38 02       0648*      jr c,collision_enemy_is
0435C4 AF          0649*      xor a
0435C5 C9          0650*      ret
0435C6             0651*  collision_enemy_is:
0435C6 AF          0652*      xor a
0435C7 3C          0653*      inc a
0435C8 C9          0654*      ret
0435C9             0655*  
0435C9             0656*  ; ; looks up what enemy sprite collides with
0435C9             0657*  ; ; detects collisions
0435C9             0658*  ; ; and sets things to sploding accordingly
0435C9             0659*  ; check_collisions:
0435C9             0660*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
0435C9             0661*  ;     and a ; if this is zero,
0435C9             0662*  ;     ret z ; there's nothing to do
0435C9             0663*  ;     and %01 ; do we collide with player?
0435C9             0664*  ;     jr z,move_enemies_laser ; if not,check laser collision
0435C9             0665*  ;     call collision_enemy_with_player ; otherwise see if we hit player
0435C9             0666*  ;     and a ; was there a collision?
0435C9             0667*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
0435C9             0668*  ; ; yes collision with player
0435C9             0669*  ;     ; deduct shield damage
0435C9             0670*  ;     ld hl,sprite_shield_damage
0435C9             0671*  ;     ld a,(player_shields)
0435C9             0672*  ;     sub (hl)
0435C9             0673*  ;     ld (player_shields),a
0435C9             0674*  ; ; if shields >= 0,player survives
0435C9             0675*  ;     jp p,check_collisions_kill_nurple
0435C9             0676*  ; ; otherwise update player status so it will die
0435C9             0677*  ;     ld a,(player_collisions)
0435C9             0678*  ;     or %10 ; sets bit 1,meaning player just died
0435C9             0679*  ;     ld (player_collisions),a
0435C9             0680*  ;     ; fall through
0435C9             0681*  ; check_collisions_kill_nurple:
0435C9             0682*  ; ; kill enemy and replace with explosion
0435C9             0683*  ;     call kill_nurple
0435C9             0684*  ;     ret ; and out
0435C9             0685*  
0435C9             0686*  check_collisions:
0435C9 CD 87 35 04 0687*      call collision_enemy_with_player ; did we hit the player?
0435CD A7          0688*      and a ; was there a collision?
0435CE C8          0689*      ret z ; if not,we're done
0435CF CD 67 35 04 0690*      call kill_nurple ; otherwise kill enemy
0435D3 C9          0691*      ret
0435D4             0692*  
0435D4             0693*  ; did we hit the laser?
0435D4             0694*  move_enemies_laser:
0435D4 FD 7E 08    0695*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0435D7 E6 02       0696*      and %10 ; do we even collide with laser?
0435D9 C8          0697*      ret z ; if not,we're out
0435DA 3A FE 35 04 0698*      ld a,(laser_collisions) ; is laser alive?
0435DE E6 01       0699*      and %1 ; if bit 0 is not set laser is dead
0435E0 C8          0700*      ret z ; so we're out
0435E1 CD 72 35 04 0701*      call collision_enemy_with_laser ; otherwise check for collision
0435E5 A7          0702*      and a ; was there a collision?
0435E6 C8          0703*      ret z ; if not,we're done
0435E7             0704*  ; otherwise we mark laser for termination and kill enemy
0435E7             0705*  ; update laser status so it will die
0435E7 3A FE 35 04 0706*      ld a,(laser_collisions)
0435EB F6 02       0707*      or %10 ; bit 1 set means laser just died
0435ED 32 FE 35 04 0708*      ld (laser_collisions),a
0435F1 CD 67 35 04 0709*      call kill_nurple ; yes there was a collision,so kill enemy
0435F5 C9          0710*      ret ; we're outta' here
0435F6             0064   	include "laser.inc"
0435F6             0001*  ; ##### LASER SPRITE PARAMETERS #####
0435F6             0002*  ; uses the same offsets from its table base as the main sprite table:
0435F6             0003*  laser_start_variables: ; label marking beginning of table
0435F6 11          0004*  laser_id:               db table_max_records+1
0435F7 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
0435F8 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0435FB 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0435FE 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0435FF 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043600 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043601 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043604 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043607 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04360A 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04360D 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
043610 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043613 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
043616 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
043617 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
043618 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
043619 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
04361A 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
04361B 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
04361C             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
04361C             0025*  
04361C             0026*  ; laser_control:
04361C             0027*  ; ; is laser already active?
04361C             0028*  ;     ld a,(laser_collisions)
04361C             0029*  ;     and %00000001 ; bit zero is lit if laser is active
04361C             0030*  ;     jr nz,laser_move ; move laser if not zero
04361C             0031*  ; ; otherwise check if laser fired
04361C             0032*  ;     in a,(#82) ; keyboard
04361C             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
04361C             0034*  ;     ret z ; go back if laser not fired
04361C             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
04361C             0036*  ; ; set laser status to active (set bit 0)
04361C             0037*  ;     ld a,%1
04361C             0038*  ;     ld (laser_collisions),a
04361C             0039*  ; ; initialize laser position
04361C             0040*  ;     ld a,(player_x+1) ; we only need the integer part
04361C             0041*  ;     ; add a,6 ; horizontal center with player sprite
04361C             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
04361C             0043*  ;     ld a,(player_y+1) ; we only need the integer part
04361C             0044*  ;     add a,-6 ; set laser y a few pixels above player
04361C             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
04361C             0046*  ;     ; fall through to laser_move
04361C             0047*  
04361C             0048*  ; laser_move:
04361C             0049*  ; ; begin setting laser to active sprite
04361C             0050*  ;     ld hl,lasers
04361C             0051*  ;     ld (sprite_base_bufferId),hl
04361C             0052*  ;     ld hl,0 ; north
04361C             0053*  ;     ld (sprite_heading),hl
04361C             0054*  ;     xor a ; laser has no animations yet :-(
04361C             0055*  ;     ld (sprite_animation),a
04361C             0056*  ;     ; we set position here for the time being as a default
04361C             0057*  ;     ; in case the laser is flagged for deletion
04361C             0058*  ;     ; load sprite_x with laser x position (we do y further down)
04361C             0059*  ;     ld hl,(laser_x)
04361C             0060*  ;     ld (sprite_x),hl
04361C             0061*  ; ; did laser just die?
04361C             0062*  ;     ld a,(laser_collisions)
04361C             0063*  ;     bit 1,a ; z if laser didn't just die
04361C             0064*  ;     jr z,laser_not_dead_yet
04361C             0065*  ; ; yes laser died
04361C             0066*  ;     call kill_laser
04361C             0067*  ;     ret ; done
04361C             0068*  ; laser_not_dead_yet:
04361C             0069*  ; ; draw it
04361C             0070*  ; ; update laser y position
04361C             0071*  ;     ld hl,(laser_y) ; grab laser y position
04361C             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
04361C             0073*  ;     add hl,de ; add y velocity to y pos
04361C             0074*  ;     ld (sprite_y),hl ; update laser y position
04361C             0075*  ;     ld (laser_y),hl ; update laser y position
04361C             0076*  ; ; are we at top of screen?
04361C             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
04361C             0078*  ;     sub h ; no carry if above threshold
04361C             0079*  ;     jr c,finally_draw_the_frikken_laser
04361C             0080*  ;     ; if at top of screen,laser dies
04361C             0081*  ;     call kill_laser
04361C             0082*  ;     ret
04361C             0083*  ; ; otherwise,finally draw the frikken laser
04361C             0084*  ; finally_draw_the_frikken_laser:
04361C             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04361C             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04361C             0087*  ; ; all done
04361C             0088*  ;     ret
04361C             0089*  
04361C             0090*  ; kill_laser:
04361C             0091*  ; ; update status to inactive
04361C             0092*  ;     xor a ; zero out a
04361C             0093*  ;     ld (laser_collisions),a
04361C             0094*  ;     ret
04361C             0065   	include "timer.inc"
04361C             0001*  ; Table 32. Timer Control Registers
04361C             0002*  ; this constant is the base address of the timer control registers
04361C             0003*  ; each timer takes three bytes:
04361C             0004*  ;   0: control register
04361C             0005*  ;   1: low byte of timer reset value
04361C             0006*  ;   2: high byte of timer reset value
04361C             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
04361C             0008*  ; which correctly force the high and upper bytes of the address bus to zero
04361C             0009*  TMR_CTL:     equ 80h
04361C             0010*  
04361C             0011*  ; Timer Control Register Bit Definitions
04361C             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
04361C             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
04361C             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
04361C             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
04361C             0016*                              ; the TMRx_CTL register is read.
04361C             0017*  
04361C             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
04361C             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
04361C             0020*  
04361C             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
04361C             0022*                              ;  0,and counting stops when the end-of-count value is reached.
04361C             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
04361C             0024*                              ; written to the counter when the end-of-count value is reached.
04361C             0025*  
04361C             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
04361C             0027*  CLK_DIV_256:  equ %00001100 ;
04361C             0028*  CLK_DIV_64:   equ %00001000 ;
04361C             0029*  CLK_DIV_16:   equ %00000100 ;
04361C             0030*  CLK_DIV_4:    equ %00000000 ;
04361C             0031*  
04361C             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
04361C             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
04361C             0034*                              ; When a 1 is written to this bit,the values in the reload registers
04361C             0035*                              ;  are loaded into the downcounter when the timer restarts. The
04361C             0036*                              ; programmer must ensure that this bit is set to 1 each time
04361C             0037*                              ; SINGLE-PASS mode is used.
04361C             0038*  
04361C             0039*  ; disable/enable the programmable reload timer
04361C             0040*  PRT_EN_0:     equ %00000000 ;
04361C             0041*  PRT_EN_1:     equ %00000001 ;
04361C             0042*  
04361C             0043*  ; Table 37. Timer Input Source Select Register
04361C             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
04361C             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
04361C             0046*  ;   00: System clock / CLK_DIV
04361C             0047*  ;   01: RTC / CLK_DIV
04361C             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
04361C             0049*  ;   10: GPIO port B pin 1.
04361C             0050*  ;   11: GPIO port B pin 1.
04361C             0051*  TMR_ISS:   equ 92h ; register address
04361C             0052*  
04361C             0053*  ; Table 51. Real-Time Clock Control Register
04361C             0054*  RTC_CTRL: equ EDh ; register address
04361C             0055*  
04361C             0056*  ; alarm interrupt disable/enable
04361C             0057*  RTC_ALARM_0:    equ %00000000
04361C             0058*  RTC_ALARM_1:    equ %10000000
04361C             0059*  
04361C             0060*  ; interrupt on alarm disable/enable
04361C             0061*  RTC_INT_ENT_0:  equ %00000000
04361C             0062*  RTC_INT_ENT_1:  equ %01000000
04361C             0063*  
04361C             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
04361C             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
04361C             0066*  
04361C             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
04361C             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
04361C             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
04361C             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
04361C             0071*  
04361C             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
04361C             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
04361C             0074*  
04361C             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
04361C             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
04361C             0077*  
04361C             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
04361C             0079*                                  ; RTC counter is enabled.
04361C             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
04361C             0081*                                  ; RTC counter is disabled.
04361C             0082*  
04361C             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
04361C             0084*  
04361C             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
04361C             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
04361C 00 00 00    0087*  prt_reload: dl 0x000000
04361F             0088*  
04361F             0089*  ; set PRT timer
04361F             0090*  prt_set:
04361F 21 00 00 00 0091*      ld hl,0
043623 22 6D 36 04 0092*      ld (prt_irq_counter),hl
043627 2A 1C 36 04 0093*      ld hl,(prt_reload)
04362B ED 29 84    0094*      out0 ($84),l
04362E ED 21 85    0095*  	out0 ($85),h
043631             0096*  ; disable timer
043631 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043633 ED 39 83    0098*  	out0 ($83),a
043636             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043636 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
043638 ED 39 83    0101*  	out0 ($83),a
04363B C9          0102*      ret
04363C             0103*  
04363C             0104*  ; ===============================================
04363C             0105*  ; PRT Timer Interrupt Handling
04363C             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
04363C             0107*  ; -----------------------------------------------
04363C             0108*  prt_irq_init:
04363C             0109*      ; set up interrupt vector table 2
04363C 21 00 00 00 0110*  	ld hl,0
043640 3A 0C 01 00 0111*  	ld a,($10c)
043644 6F          0112*  	ld l,a
043645 3A 0D 01 00 0113*  	ld a,($10d)
043649 67          0114*  	ld h,a
04364A             0115*  
04364A             0116*  	; skip over CALL ($c3)
04364A 23          0117*  	inc hl
04364B             0118*  	; load address of jump into vector table 2 (in ram)
04364B ED 27       0119*  	ld hl,(hl)
04364D             0120*  
04364D             0121*  	; write CALL prt_irq_handler to vector table 2
04364D 3E C3       0122*  	ld a,$c3
04364F 77          0123*  	ld (hl),a
043650 23          0124*  	inc hl
043651 11 58 36 04 0125*  	ld de,prt_irq_handler
043655 ED 1F       0126*  	ld (hl),de
043657             0127*  
043657 C9          0128*      ret
043658             0129*  
043658             0130*  prt_irq_handler:
043658 F3          0131*  	di
043659 F5          0132*  	push af
04365A E5          0133*      push hl
04365B ED 38 83    0134*  	in0 a,($83)
04365E 2A 6D 36 04 0135*  	ld hl,(prt_irq_counter)
043662 23          0136*  	inc hl
043663 22 6D 36 04 0137*  	ld (prt_irq_counter),hl
043667 E1          0138*      pop hl
043668 F1          0139*  	pop af
043669 FB          0140*  	ei
04366A 5B ED 4D    0141*  	reti.l
04366D             0142*  
04366D             0143*  prt_irq_counter:
04366D 00 00 00    0144*  	.dl 0
043670             0145*  prt_irq_counter_saved:
043670 00 00 00    0146*      .dl 0
043673             0147*  
043673             0148*  prt_loop_reset:
043673 E5          0149*      push hl
043674 21 00 00 00 0150*  	ld hl,0
043678 22 6D 36 04 0151*  	ld (prt_irq_counter),hl
04367C 22 DE 36 04 0152*      ld (prt_loop_counter),hl
043680 22 E1 36 04 0153*      ld (prt_loops),hl
043684 CD 1F 36 04 0154*      call prt_set
043688 E1          0155*      pop hl
043689 C9          0156*      ret
04368A             0157*  
04368A             0158*  prt_loop_start:
04368A E5          0159*      push hl
04368B 21 00 00 00 0160*  	ld hl,0
04368F 22 6D 36 04 0161*  	ld (prt_irq_counter),hl
043693 E1          0162*      pop hl
043694 C9          0163*      ret
043695             0164*  
043695             0165*  prt_loop_stop:
043695 E5          0166*      push hl
043696 D5          0167*      push de
043697 2A 6D 36 04 0168*      ld hl,(prt_irq_counter)
04369B ED 5B DE 36 0169*      ld de,(prt_loop_counter)
       04          
0436A0 19          0170*      add hl,de
0436A1 22 DE 36 04 0171*      ld (prt_loop_counter),hl
0436A5 21 00 00 00 0172*      ld hl,0
0436A9 22 6D 36 04 0173*      ld (prt_irq_counter),hl
0436AD 2A E1 36 04 0174*      ld hl,(prt_loops)
0436B1 23          0175*      inc hl
0436B2 22 E1 36 04 0176*      ld (prt_loops),hl
0436B6 D1          0177*      pop de
0436B7 E1          0178*      pop hl
0436B8 C9          0179*      ret
0436B9             0180*  
0436B9             0181*  ; inputs: bc = y,x text coordinates to print
0436B9             0182*  prt_loop_print:
0436B9 F5          0183*      push af
0436BA E5          0184*      push hl
0436BB C5          0185*      push bc
0436BC D5          0186*      push de
0436BD DD E5       0187*      push ix
0436BF FD E5       0188*      push iy
0436C1 CD 5B 1F 04 0189*      call vdu_move_cursor
0436C5             0190*  
0436C5 2A DE 36 04 0191*      ld hl,(prt_loop_counter)
0436C9 CD 0C 1A 04 0192*      call printDec
0436CD             0193*  
0436CD 2A E1 36 04 0194*      ld hl,(prt_loops)
0436D1 CD 0C 1A 04 0195*      call printDec
0436D5             0196*  
0436D5 FD E1       0197*      pop iy
0436D7 DD E1       0198*      pop ix
0436D9 D1          0199*      pop de
0436DA C1          0200*      pop bc
0436DB E1          0201*      pop hl
0436DC F1          0202*      pop af
0436DD C9          0203*      ret
0436DE             0204*  
0436DE             0205*  prt_loop_counter:
0436DE 00 00 00    0206*      .dl 0
0436E1             0207*  prt_loops:
0436E1 00 00 00    0208*      .dl 0
0436E4             0209*  
0436E4             0210*  ; ===============================================
0436E4             0211*  ; Timer functions
0436E4             0212*  ; -----------------------------------------------
0436E4             0213*  ; set a countdown timer
0436E4             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0436E4             0215*  ; returns: hl = current time
0436E4             0216*  tmr_set:
0436E4 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0436E7             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0436E7 3E 08       0001*M 			LD	A, function
0436E9 5B CF       0002*M 			RST.LIL	08h
0436EB DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0436EE FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0436F1 C9          0221*      ret
0436F2             0222*  
0436F2             0223*  ; gets time remaining on a countdown timer
0436F2             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0436F2             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0436F2             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0436F2             0227*  tmr_get:
0436F2             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0436F2 3E 08       0001*M 			LD	A, function
0436F4 5B CF       0002*M 			RST.LIL	08h
0436F6 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0436F9 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0436FC AF          0231*      xor a                   ; clear carry
0436FD ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0436FF FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
043702 AF          0234*      xor a                   ; clear carry
043703 ED 5A       0235*      adc hl,de               ; hl = time remaining
043705             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043705 C9          0237*      ret
043706             0238*  
043706             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
04370C             0240*  
04370C 00 00 00    0241*  timestamp_now: dl 0
04370F 00 00 00    0242*  timestamp_old: dl 0
043712 00 00 00    0243*  timestamp_chg: dl 0
043715             0244*  
043715             0245*  ; update the global timestamp from the system clock
043715             0246*  ; inputs: none
043715             0247*  ; returns: hl = time elapsed in 1/120ths of a second
043715             0248*  ;          de = current time
043715             0249*  ;          ix = pointer to syvars table
043715             0250*  ; destroys: af,hl,de,ix
043715             0251*  timestamp_tick:
043715 ED 5B 0C 37 0252*      ld de,(timestamp_now)   ; get previous time
       04          
04371A ED 53 0F 37 0253*      ld (timestamp_old),de   ; save previous time
       04          
04371F             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
04371F 3E 08       0001*M 			LD	A, function
043721 5B CF       0002*M 			RST.LIL	08h
043723 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
043726 22 0C 37 04 0256*      ld (timestamp_now),hl   ; save current time
04372A AF          0257*      xor a                   ; clear carry
04372B ED 52       0258*      sbc hl,de               ; hl = time elapsed
04372D 22 12 37 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043731 C9          0260*      ret
043732             0261*  
043732             0262*  ; set a countdown timer
043732             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043732             0264*  ; requires: timestamp_tick to be called at least once before this function
043732             0265*  ; returns: hl = current time
043732             0266*  ; destroys: hl
043732             0267*  timestamp_tmr_set:
043732 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043735 2A 0C 37 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
043739 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
04373C C9          0271*      ret
04373D             0272*  
04373D             0273*  ; gets time remaining on a countdown timer following the global timestamp
04373D             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04373D             0275*  ; requires: timestamp_tick to be called at least once before this function
04373D             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04373D             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
04373D             0278*  ; destroys: af,hl,de
04373D             0279*  timestamp_tmr_get:
04373D ED 5B 0C 37 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043742 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043745 AF          0282*      xor a                   ; clear carry
043746 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043748 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
04374B AF          0285*      xor a                   ; clear carry
04374C ED 5A       0286*      adc hl,de               ; hl = time remaining
04374E             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04374E C9          0288*      ret
04374F             0289*  
04374F             0290*  ; set a stopwatch
04374F             0291*  ; returns: hl = start time
04374F             0292*  ; destroys: hl,ix
04374F             0293*  stopwatch_set:
04374F             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
04374F 3E 08       0001*M 			LD	A, function
043751 5B CF       0002*M 			RST.LIL	08h
043753 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043756 22 6B 37 04 0296*      ld (stopwatch_started),hl            ; set start time
04375A C9          0297*      ret
04375B             0298*  
04375B             0299*  ; gets time elapsed on a stopwatch
04375B             0300*  ; returns: hl = time elapsed in 1/120ths of a second
04375B             0301*  ; destroys: af,hl,de,ix
04375B             0302*  stopwatch_get:
04375B             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
04375B 3E 08       0001*M 			LD	A, function
04375D 5B CF       0002*M 			RST.LIL	08h
04375F DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043762 ED 5B 6B 37 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043767 AF          0306*      xor a                   ; clear carry
043768 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04376A C9          0308*      ret
04376B             0309*  
04376B             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04376E             0311*  
04376E             0312*  ; ------------------
04376E             0313*  ; delay routine
04376E             0314*  ; Author: Richard Turrnidge
04376E             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04376E             0316*  ; routine waits a fixed time,then returns
04376E             0317*  ; arrive with A =  the delay byte. One bit to be set only.
04376E             0318*  ; eg. ld A,00000100b
04376E             0319*  
04376E             0320*  multiPurposeDelay:
04376E F5          0321*      push af
04376F C5          0322*      push bc
043770 DD E5       0323*      push ix
043772 47          0324*      ld b,a
043773 3E 08       0325*      ld a,$08
043775 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043777             0327*  
043777             0328*  waitLoop:
043777             0329*  
043777 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04377A             0331*  
04377A             0332*                                  ;   we check if bit set is same as last time we checked.
04377A             0333*                                  ;   bit 0 - don't use
04377A             0334*                                  ;   bit 1 - changes 64 times per second
04377A             0335*                                  ;   bit 2 - changes 32 times per second
04377A             0336*                                  ;   bit 3 - changes 16 times per second
04377A             0337*  
04377A             0338*                                  ;   bit 4 - changes 8 times per second
04377A             0339*                                  ;   bit 5 - changes 4 times per second
04377A             0340*                                  ;   bit 6 - changes 2 times per second
04377A             0341*                                  ;   bit 7 - changes 1 times per second
04377A A0          0342*      and b
04377B 4F          0343*      ld c,a
04377C 3A 8D 37 04 0344*      ld a,(oldTimeStamp)
043780 B9          0345*      cp c                        ; is A same as last value?
043781 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043783 79          0347*      ld a,c
043784 32 8D 37 04 0348*      ld (oldTimeStamp),a        ; set new value
043788             0349*  
043788 DD E1       0350*      pop ix
04378A C1          0351*      pop bc
04378B F1          0352*      pop af
04378C C9          0353*      ret
04378D             0354*  
04378D 00          0355*  oldTimeStamp:   .db 00h
04378E             0066   
04378E             0067   ; new includes
04378E             0068   	include "images.inc"
04378E             0001*  image_type: equ 0
04378E             0002*  image_width: equ image_type+3
04378E             0003*  image_height: equ image_width+3
04378E             0004*  image_filesize: equ image_height+3
04378E             0005*  image_filename: equ image_filesize+3
04378E             0006*  image_bufferId: equ image_filename+3
04378E             0007*  image_record_size: equ image_bufferId+3
04378E             0008*  
04378E 00 00 00    0009*  cur_image_list: dl 0
043791 00 00 00    0010*  cur_file_idx: dl 0
043794 00 00 00    0011*  cur_filename: dl 0
043797 00 00 00    0012*  cur_buffer_id: dl 0
04379A             0013*  
04379A             0014*  load_ui_images:
04379A             0015*  ; initialize image loading variables
04379A 21 00 00 00 0016*  	ld hl,0
04379E 22 91 37 04 0017*  	ld (cur_file_idx),hl
0437A2 21 90 48 04 0018*  	ld hl,ui_image_list
0437A6 22 8E 37 04 0019*  	ld (cur_image_list),hl
0437AA             0020*  ; load images
0437AA 06 04       0021*  	ld b,ui_num_images
0437AC             0022*  @loop:
0437AC C5          0023*  	push bc
0437AD CD 0F 38 04 0024*  	call load_next_image
0437B1 C1          0025*  	pop bc
0437B2 10 F8       0026*  	djnz @loop
0437B4 C9          0027*  	ret
0437B5             0028*  
0437B5             0029*  load_sprite_images:
0437B5             0030*  ; initialize image loading variables
0437B5 21 00 00 00 0031*  	ld hl,0
0437B9 22 91 37 04 0032*  	ld (cur_file_idx),hl
0437BD 21 A0 38 04 0033*  	ld hl,sprites_image_list
0437C1 22 8E 37 04 0034*  	ld (cur_image_list),hl
0437C5 01 5F 00 00 0035*  	ld bc,sprites_num_images
0437C9             0036*  ; load images
0437C9 CD CE 37 04 0037*  	call img_load_main
0437CD C9          0038*  	ret
0437CE             0039*  
0437CE             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0437CE             0041*  img_load_main:
0437CE AF          0042*  	xor a
0437CF 32 91 37 04 0043*      ld (cur_file_idx),a
0437D3             0044*  
0437D3             0045*  img_load_main_loop:
0437D3             0046*  ; back up loop counter
0437D3 C5          0047*      push bc
0437D4             0048*  
0437D4             0049*  ; load the next image
0437D4 CD 0F 38 04 0050*      call load_next_image
0437D8             0051*  
0437D8             0052*  ; plot the background
0437D8 CD 6F 1F 04 0053*  	call vdu_cls
0437DC 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
0437E0 CD 5C 20 04 0055*      call vdu_buff_select
0437E4 01 00 00 00 0056*      ld bc,0
0437E8 11 00 00 00 0057*      ld de,0
0437EC CD 25 23 04 0058*      call vdu_plot_bmp
0437F0             0059*  
0437F0             0060*  ; ; draw the most recently loaded image
0437F0             0061*  ; 	ld hl,(cur_buffer_id)
0437F0             0062*  ; 	call vdu_buff_select
0437F0             0063*  ; 	ld bc,0
0437F0             0064*  ; 	ld de,0
0437F0             0065*  ; 	call vdu_plot_bmp
0437F0             0066*  
0437F0             0067*  ; move logo
0437F0 CD 6F 38 04 0068*  	call move_logo
0437F4             0069*  
0437F4             0070*  ; print current filename
0437F4 2A 94 37 04 0071*  	ld hl,(cur_filename)
0437F8 CD 0D 19 04 0072*  	call printString
0437FC             0073*  
0437FC             0074*  ; flip the framebuffer
0437FC CD 74 1F 04 0075*  	call vdu_flip
043800             0076*  
043800             0077*  ; decrement loop counter
043800 C1          0078*      pop bc
043801 0B          0079*  	dec bc
043802 79          0080*      ld a,c
043803 B7          0081*      or a
043804 C2 D3 37 04 0082*      jp nz,img_load_main_loop
043808 78          0083*      ld a,b
043809 B7          0084*      or a
04380A C2 D3 37 04 0085*      jp nz,img_load_main_loop
04380E C9          0086*      ret
04380F             0087*  
04380F             0088*  load_next_image:
04380F 16 12       0089*      ld d,image_record_size
043811 3A 91 37 04 0090*  	ld a,(cur_file_idx)
043815 5F          0091*  	ld e,a
043816 ED 5C       0092*      mlt de
043818 FD 2A 8E 37 0093*      ld iy,(cur_image_list)
       04          
04381D FD 19       0094*      add iy,de
04381F             0095*  
04381F FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
043822 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
043825 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
043828 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
04382B FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
04382E 22 97 37 04 0101*  	ld (cur_buffer_id),hl
043832 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
043835 FD 22 94 37 0103*  	ld (cur_filename),iy
       04          
04383A CD 7A 21 04 0104*      call vdu_load_img
04383E FD 21 91 37 0105*      ld iy,cur_file_idx
       04          
043843 FD 34 00    0106*  	inc (iy)
043846 C9          0107*  	ret
043847             0108*  
043847             0109*  img_load_init:
043847             0110*  ; initialize logo's position parameters
043847 21 00 00 00 0111*  	ld hl,0
04384B 22 94 38 04 0112*  	ld (logo_xvel),hl
04384F 22 97 38 04 0113*  	ld (logo_xpos),hl
043853             0114*  ; begin 16.8 maths to determine logo's y position and velocity
043853 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
043857 22 9D 38 04 0116*  	ld (logo_ypos),hl
04385B EB          0117*  	ex de,hl
04385C 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
043860 19          0119*  	add hl,de ; distance for logo to travel
043861 11 00 A1 FF 0120*  	ld de,-sprites_num_images*256
043865 CD 7F 30 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
043869 ED 53 9A 38 0122*  	ld (logo_yvel),de
       04          
04386E             0123*  ; all done
04386E C9          0124*      ret
04386F             0125*  
04386F             0126*  move_logo:
04386F             0127*  ; activate logo bitmap
04386F 21 03 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
043873 CD 5C 20 04 0129*  	call vdu_buff_select
043877             0130*  ; update position based on velocity parameters
043877 2A 9D 38 04 0131*  	ld hl,(logo_ypos)
04387B ED 5B 9A 38 0132*  	ld de,(logo_yvel)
       04          
043880 19          0133*  	add hl,de
043881 22 9D 38 04 0134*  	ld (logo_ypos),hl
043885             0135*  ; draw logo
043885 ED 4B 97 38 0136*  	ld bc,(logo_xpos)
       04          
04388A ED 5B 9D 38 0137*  	ld de,(logo_ypos)
       04          
04388F CD 41 23 04 0138*  	call vdu_plot_bmp168
043893 C9          0139*  	ret
043894             0140*  
043894 00 00 00    0141*  logo_xvel: dl 0
043897 00 00 00    0142*  logo_xpos: dl 0
04389A             0143*  
04389A 00 00 00    0144*  logo_yvel: dl 0
04389D 00 00 00    0145*  logo_ypos: dl 0
0438A0             0069   	include "images_sprites.inc"
0438A0             0001*  ; Generated by make_images.py
0438A0             0002*  
0438A0             0003*  sprites_num_images: equ 95
0438A0             0004*  
0438A0             0005*  ; buffer_ids:
0438A0             0006*  BUF_0TILE_EMPTY: equ 256
0438A0             0007*  BUF_1TILE_CROSS: equ 257
0438A0             0008*  BUF_2TILE_HORIZ: equ 258
0438A0             0009*  BUF_3TILE_VERT: equ 259
0438A0             0010*  BUF_4TILE_SQUARE: equ 260
0438A0             0011*  BUF_5TILE_CIRCLE: equ 261
0438A0             0012*  BUF_6TILE_PAD: equ 262
0438A0             0013*  BUF_7TILE_TURRET: equ 263
0438A0             0014*  BUF_CIRCLE: equ 264
0438A0             0015*  BUF_CRATER: equ 265
0438A0             0016*  BUF_EXPLOSION_A: equ 266
0438A0             0017*  BUF_EXPLOSION_B: equ 267
0438A0             0018*  BUF_EXPLOSION_C: equ 268
0438A0             0019*  BUF_EXPLOSION_D: equ 269
0438A0             0020*  BUF_EXPLOSION_E: equ 270
0438A0             0021*  BUF_FIREBALL_A: equ 271
0438A0             0022*  BUF_FIREBALL_B: equ 272
0438A0             0023*  BUF_LASER_A: equ 273
0438A0             0024*  BUF_LASER_B: equ 274
0438A0             0025*  BUF_PAD: equ 275
0438A0             0026*  BUF_SEEKER_000: equ 276
0438A0             0027*  BUF_SEEKER_008: equ 277
0438A0             0028*  BUF_SEEKER_016: equ 278
0438A0             0029*  BUF_SEEKER_024: equ 279
0438A0             0030*  BUF_SEEKER_032: equ 280
0438A0             0031*  BUF_SEEKER_040: equ 281
0438A0             0032*  BUF_SEEKER_048: equ 282
0438A0             0033*  BUF_SEEKER_056: equ 283
0438A0             0034*  BUF_SEEKER_064: equ 284
0438A0             0035*  BUF_SEEKER_072: equ 285
0438A0             0036*  BUF_SEEKER_080: equ 286
0438A0             0037*  BUF_SEEKER_088: equ 287
0438A0             0038*  BUF_SEEKER_096: equ 288
0438A0             0039*  BUF_SEEKER_104: equ 289
0438A0             0040*  BUF_SEEKER_112: equ 290
0438A0             0041*  BUF_SEEKER_120: equ 291
0438A0             0042*  BUF_SEEKER_128: equ 292
0438A0             0043*  BUF_SEEKER_136: equ 293
0438A0             0044*  BUF_SEEKER_144: equ 294
0438A0             0045*  BUF_SEEKER_152: equ 295
0438A0             0046*  BUF_SEEKER_160: equ 296
0438A0             0047*  BUF_SEEKER_168: equ 297
0438A0             0048*  BUF_SEEKER_176: equ 298
0438A0             0049*  BUF_SEEKER_184: equ 299
0438A0             0050*  BUF_SEEKER_192: equ 300
0438A0             0051*  BUF_SEEKER_200: equ 301
0438A0             0052*  BUF_SEEKER_208: equ 302
0438A0             0053*  BUF_SEEKER_216: equ 303
0438A0             0054*  BUF_SEEKER_224: equ 304
0438A0             0055*  BUF_SEEKER_232: equ 305
0438A0             0056*  BUF_SEEKER_240: equ 306
0438A0             0057*  BUF_SEEKER_248: equ 307
0438A0             0058*  BUF_SHIP_0L: equ 308
0438A0             0059*  BUF_SHIP_1C: equ 309
0438A0             0060*  BUF_SHIP_2R: equ 310
0438A0             0061*  BUF_SHIP_SMALL: equ 311
0438A0             0062*  BUF_STAR: equ 312
0438A0             0063*  BUF_STATION_BG_00: equ 313
0438A0             0064*  BUF_STATION_BG_01: equ 314
0438A0             0065*  BUF_STATION_BG_02: equ 315
0438A0             0066*  BUF_STATION_BG_03: equ 316
0438A0             0067*  BUF_STATION_BG_04: equ 317
0438A0             0068*  BUF_STATION_BG_05: equ 318
0438A0             0069*  BUF_TURRET_000: equ 319
0438A0             0070*  BUF_TURRET_008: equ 320
0438A0             0071*  BUF_TURRET_016: equ 321
0438A0             0072*  BUF_TURRET_024: equ 322
0438A0             0073*  BUF_TURRET_032: equ 323
0438A0             0074*  BUF_TURRET_040: equ 324
0438A0             0075*  BUF_TURRET_048: equ 325
0438A0             0076*  BUF_TURRET_056: equ 326
0438A0             0077*  BUF_TURRET_064: equ 327
0438A0             0078*  BUF_TURRET_072: equ 328
0438A0             0079*  BUF_TURRET_080: equ 329
0438A0             0080*  BUF_TURRET_088: equ 330
0438A0             0081*  BUF_TURRET_096: equ 331
0438A0             0082*  BUF_TURRET_104: equ 332
0438A0             0083*  BUF_TURRET_112: equ 333
0438A0             0084*  BUF_TURRET_120: equ 334
0438A0             0085*  BUF_TURRET_128: equ 335
0438A0             0086*  BUF_TURRET_136: equ 336
0438A0             0087*  BUF_TURRET_144: equ 337
0438A0             0088*  BUF_TURRET_152: equ 338
0438A0             0089*  BUF_TURRET_160: equ 339
0438A0             0090*  BUF_TURRET_168: equ 340
0438A0             0091*  BUF_TURRET_176: equ 341
0438A0             0092*  BUF_TURRET_184: equ 342
0438A0             0093*  BUF_TURRET_192: equ 343
0438A0             0094*  BUF_TURRET_200: equ 344
0438A0             0095*  BUF_TURRET_208: equ 345
0438A0             0096*  BUF_TURRET_216: equ 346
0438A0             0097*  BUF_TURRET_224: equ 347
0438A0             0098*  BUF_TURRET_232: equ 348
0438A0             0099*  BUF_TURRET_240: equ 349
0438A0             0100*  BUF_TURRET_248: equ 350
0438A0             0101*  
0438A0             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
0438A0 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       4E 3F 04 00 
       01 00       
0438B2 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       68 3F 04 01 
       01 00       
0438C4 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       82 3F 04 02 
       01 00       
0438D6 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       9C 3F 04 03 
       01 00       
0438E8 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       B5 3F 04 04 
       01 00       
0438FA 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       D0 3F 04 05 
       01 00       
04390C 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       EB 3F 04 06 
       01 00       
04391E 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       03 40 04 07 
       01 00       
043930 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       1E 40 04 08 
       01 00       
043942 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       33 40 04 09 
       01 00       
043954 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       48 40 04 0A 
       01 00       
043966 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       62 40 04 0B 
       01 00       
043978 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       7C 40 04 0C 
       01 00       
04398A 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       96 40 04 0D 
       01 00       
04399C 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       B0 40 04 0E 
       01 00       
0439AE 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       CA 40 04 0F 
       01 00       
0439C0 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       E3 40 04 10 
       01 00       
0439D2 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       FC 40 04 11 
       01 00       
0439E4 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       12 41 04 12 
       01 00       
0439F6 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       28 41 04 13 
       01 00       
043A08 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       3A 41 04 14 
       01 00       
043A1A 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       53 41 04 15 
       01 00       
043A2C 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       6C 41 04 16 
       01 00       
043A3E 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       85 41 04 17 
       01 00       
043A50 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       9E 41 04 18 
       01 00       
043A62 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       B7 41 04 19 
       01 00       
043A74 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       D0 41 04 1A 
       01 00       
043A86 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       E9 41 04 1B 
       01 00       
043A98 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       02 42 04 1C 
       01 00       
043AAA 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       1B 42 04 1D 
       01 00       
043ABC 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       34 42 04 1E 
       01 00       
043ACE 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       4D 42 04 1F 
       01 00       
043AE0 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       66 42 04 20 
       01 00       
043AF2 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       7F 42 04 21 
       01 00       
043B04 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       98 42 04 22 
       01 00       
043B16 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       B1 42 04 23 
       01 00       
043B28 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       CA 42 04 24 
       01 00       
043B3A 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       E3 42 04 25 
       01 00       
043B4C 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       FC 42 04 26 
       01 00       
043B5E 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       15 43 04 27 
       01 00       
043B70 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       2E 43 04 28 
       01 00       
043B82 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       47 43 04 29 
       01 00       
043B94 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       60 43 04 2A 
       01 00       
043BA6 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       79 43 04 2B 
       01 00       
043BB8 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       92 43 04 2C 
       01 00       
043BCA 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       AB 43 04 2D 
       01 00       
043BDC 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       C4 43 04 2E 
       01 00       
043BEE 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       DD 43 04 2F 
       01 00       
043C00 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       F6 43 04 30 
       01 00       
043C12 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       0F 44 04 31 
       01 00       
043C24 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       28 44 04 32 
       01 00       
043C36 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       41 44 04 33 
       01 00       
043C48 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       5A 44 04 34 
       01 00       
043C5A 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       70 44 04 35 
       01 00       
043C6C 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       86 44 04 36 
       01 00       
043C7E 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       9C 44 04 37 
       01 00       
043C90 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       B5 44 04 38 
       01 00       
043CA2 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       C8 44 04 39 
       01 00       
043CB4 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       E4 44 04 3A 
       01 00       
043CC6 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       00 45 04 3B 
       01 00       
043CD8 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       1C 45 04 3C 
       01 00       
043CEA 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       38 45 04 3D 
       01 00       
043CFC 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       54 45 04 3E 
       01 00       
043D0E 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       70 45 04 3F 
       01 00       
043D20 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       89 45 04 40 
       01 00       
043D32 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       A2 45 04 41 
       01 00       
043D44 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       BB 45 04 42 
       01 00       
043D56 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       D4 45 04 43 
       01 00       
043D68 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       ED 45 04 44 
       01 00       
043D7A 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       06 46 04 45 
       01 00       
043D8C 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       1F 46 04 46 
       01 00       
043D9E 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       38 46 04 47 
       01 00       
043DB0 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       51 46 04 48 
       01 00       
043DC2 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       6A 46 04 49 
       01 00       
043DD4 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       83 46 04 4A 
       01 00       
043DE6 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       9C 46 04 4B 
       01 00       
043DF8 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       B5 46 04 4C 
       01 00       
043E0A 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       CE 46 04 4D 
       01 00       
043E1C 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       E7 46 04 4E 
       01 00       
043E2E 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       00 47 04 4F 
       01 00       
043E40 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       19 47 04 50 
       01 00       
043E52 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       32 47 04 51 
       01 00       
043E64 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       4B 47 04 52 
       01 00       
043E76 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       64 47 04 53 
       01 00       
043E88 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       7D 47 04 54 
       01 00       
043E9A 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       96 47 04 55 
       01 00       
043EAC 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       AF 47 04 56 
       01 00       
043EBE 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       C8 47 04 57 
       01 00       
043ED0 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       E1 47 04 58 
       01 00       
043EE2 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       FA 47 04 59 
       01 00       
043EF4 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       13 48 04 5A 
       01 00       
043F06 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       2C 48 04 5B 
       01 00       
043F18 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       45 48 04 5C 
       01 00       
043F2A 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       5E 48 04 5D 
       01 00       
043F3C 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       77 48 04 5E 
       01 00       
043F4E             0198*  
043F4E             0199*  ; files_list: ; filename:
043F4E 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043F68 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043F82 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043F9C 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043FB5 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043FD0 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043FEB 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
044003 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
04401E 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
044033 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
044048 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
044062 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
04407C 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
044096 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
0440B0 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
0440CA 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
0440E3 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
0440FC 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
044112 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
044128 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
04413A 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
044153 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
04416C 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
044185 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
04419E 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
0441B7 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
0441D0 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
0441E9 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
044202 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
04421B 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
044234 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
04424D 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
044266 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
04427F 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044298 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0442B1 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
0442CA 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
0442E3 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0442FC 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044315 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
04432E 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
044347 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
044360 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044379 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044392 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0443AB 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0443C4 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
0443DD 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0443F6 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04440F 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044428 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
044441 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
04445A 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
044470 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
044486 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
04449C 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
0444B5 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
0444C8 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
0444E4 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
044500 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
04451C 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
044538 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
044554 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
044570 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
044589 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0445A2 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0445BB 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
0445D4 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
0445ED 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
044606 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
04461F 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
044638 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
044651 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
04466A 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
044683 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04469C 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0446B5 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
0446CE 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0446E7 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044700 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
044719 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
044732 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
04474B 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
044764 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
04477D 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
044796 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0447AF 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
0447C8 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0447E1 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0447FA 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044813 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04482C 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
044845 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
04485E 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
044877 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044890             0070   	include "images_ui.inc"
044890             0001*  ; Generated by make_images.py
044890             0002*  
044890             0003*  ui_num_images: equ 4
044890             0004*  
044890             0005*  ; buffer_ids:
044890             0006*  BUF_BEZEL_L: equ 0
044890             0007*  BUF_BEZEL_R: equ 1
044890             0008*  BUF_SPLASH_BG: equ 2
044890             0009*  BUF_SPLASH_LOGO: equ 3
044890             0010*  
044890             0011*  ui_image_list: ; type; width; height; filename; bufferId:
044890 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       D8 48 04 00 
       00 00       
0448A2 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       E9 48 04 01 
       00 00       
0448B4 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       FA 48 04 02 
       00 00       
0448C6 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       0D 49 04 03 
       00 00       
0448D8             0016*  
0448D8             0017*  ; files_list: ; filename:
0448D8 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
0448E9 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
0448FA 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04490D 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
044922             0071   	include "files.inc"
044922             0001*  ; load to onboard 8k sram
044922             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
044922             0072   
044922 57 65 6C 63 0073   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
04493D 4C 6F 61 64 0074   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044948 4C 6F 61 64 0075   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
044956 50 72 65 73 0076   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
044971             0077   
044971             0078   init:
044971             0079   ; clear all buffers
044971 CD 4E 21 04 0080       call vdu_clear_all_buffers
044975             0081   
044975             0082   ; set up the display
044975 3E 88       0083       ld a,8+128 ; 136   320   240   64    60hz double-buffered
044977 CD 38 20 04 0084       call vdu_set_screen_mode
04497B AF          0085       xor a
04497C CD 49 20 04 0086       call vdu_set_scaling
044980             0087   
044980             0088   ; ; enable additional audio channels
044980             0089   ; 	call vdu_enable_channels
044980             0090   
044980             0091   ; set text background color
044980 3E 9A       0092   	ld a,26+128 ; violet
044982 CD A0 1F 04 0093   	call vdu_colour_text
044986             0094   
044986             0095   ; set text foreground color
044986 3E 2F       0096   	ld a,47 ; aaaaff lavenderish
044988 CD A0 1F 04 0097   	call vdu_colour_text
04498C             0098   
04498C             0099   ; set gfx bg color
04498C AF          0100   	xor a ; plotting mode 0
04498D 3E 9A       0101   	ld a,26+128 ; violet
04498F CD B1 1F 04 0102   	call vdu_gcol
044993 CD 6F 1F 04 0103   	call vdu_cls
044997             0104   
044997             0105   ; set the cursor off
044997 CD 37 1F 04 0106   	call vdu_cursor_off
04499B             0107   
04499B             0108   ; VDU 28, left, bottom, right, top: Set text viewport **
04499B             0109   ; MIND THE LITTLE-ENDIANESS
04499B             0110   ; inputs: c=left,b=bottom,e=right,d=top
04499B 0E 00       0111   	ld c,0 ; left
04499D 16 1D       0112   	ld d,29 ; top
04499F 1E 27       0113   	ld e,39 ; right
0449A1 06 1D       0114   	ld b,29; bottom
0449A3 CD C8 1F 04 0115   	call vdu_set_txt_viewport
0449A7             0116   
0449A7             0117   ; print loading ui message
0449A7 21 3D 49 04 0118   	ld hl,loading_ui
0449AB CD 0D 19 04 0119   	call printString
0449AF CD 74 1F 04 0120   	call vdu_flip
0449B3             0121   
0449B3             0122   ; load UI images
0449B3 CD 9A 37 04 0123   	call load_ui_images
0449B7             0124   
0449B7             0125   ; ; load fonts ; TODO
0449B7             0126   ; 	call load_font_rc
0449B7             0127   
0449B7             0128   ; load sprites
0449B7 CD 47 38 04 0129   	call img_load_init ; sets up the animated load screen
0449BB CD B5 37 04 0130   	call load_sprite_images
0449BF             0131   
0449BF             0132   ; ; load sound effects ; TODO
0449BF             0133   ; 	ld bc,SFX_num_buffers
0449BF             0134   ; 	ld hl,SFX_buffer_id_lut
0449BF             0135   ; 	ld (cur_buffer_id_lut),hl
0449BF             0136   ; 	ld hl,SFX_load_routines_table
0449BF             0137   ; 	ld (cur_load_jump_table),hl
0449BF             0138   ; 	call sfx_load_main
0449BF             0139   
0449BF             0140   ; print loading complete message and wait for user keypress
0449BF CD 6F 1F 04 0141   	call vdu_cls
0449C3 21 56 49 04 0142   	ld hl,loading_complete
0449C7 CD 0D 19 04 0143   	call printString
0449CB CD 74 1F 04 0144   	call vdu_flip
0449CF CD AB 1E 04 0145   	call waitKeypress
0449D3             0146   
0449D3             0147   ; set up display for gameplay
0449D3             0148       ; ld a,8
0449D3 3E 14       0149   	ld a,20
0449D5 CD 38 20 04 0150       call vdu_set_screen_mode
0449D9 AF          0151       xor a
0449DA CD 49 20 04 0152       call vdu_set_scaling
0449DE CD 37 1F 04 0153   	call vdu_cursor_off
0449E2             0154   ; plot bezel art
0449E2 21 00 00 00 0155   	ld hl,BUF_BEZEL_L
0449E6 CD 5C 20 04 0156   	call vdu_buff_select
0449EA 01 00 00 00 0157   	ld bc,0
0449EE 11 00 00 00 0158   	ld de,0
0449F2 CD 25 23 04 0159   	call vdu_plot_bmp
0449F6 21 01 00 00 0160   	ld hl,BUF_BEZEL_R
0449FA CD 5C 20 04 0161   	call vdu_buff_select
0449FE 01 80 01 00 0162   	ld bc,384
044A02 11 00 00 00 0163   	ld de,0
044A06 CD 25 23 04 0164   	call vdu_plot_bmp
044A0A             0165   ; set gfx origin and viewport to playing field window
044A0A 01 80 00 00 0166   	ld bc,origin_left
044A0E 11 30 00 00 0167   	ld de,origin_top
044A12 CD F4 1F 04 0168   	call vdu_set_gfx_origin
044A16 01 00 00 00 0169   	ld bc,field_left
044A1A 11 00 00 00 0170   	ld de,field_top
044A1E DD 21 FF 00 0171   	ld ix,field_right
       00          
044A23 FD 21 4F 01 0172   	ld iy,field_bottom
       00          
044A28 CD 0F 20 04 0173   	call vdu_set_gfx_viewport
044A2C             0174   ; set background color
044A2C 3E 9A       0175   	ld a,26+128 ; violet
044A2E CD B1 1F 04 0176   	call vdu_gcol
044A32 CD 82 1F 04 0177   	call vdu_clg
044A36             0178   ; VDU 28, left, bottom, right, top: Set text viewport **
044A36 0E 00       0179   	ld c,0 ; left
044A38 16 00       0180   	ld d,0 ; top
044A3A 1E 3E       0181   	ld e,62 ; right
044A3C 06 07       0182   	ld b,7; bottom
044A3E CD C8 1F 04 0183   	call vdu_set_txt_viewport
044A42             0184   
044A42 C9          0185   	ret
044A43             0186   
044A43             0187   origin_top: equ 48
044A43             0188   origin_left: equ 128
044A43             0189   field_top: equ 0
044A43             0190   field_bottom: equ 383-origin_top
044A43             0191   field_left: equ 0
044A43             0192   field_right: equ 255
044A43             0193   sprite_top: equ 0
044A43             0194   sprite_bottom: equ field_bottom-16
044A43             0195   sprite_left: equ field_left
044A43             0196   sprite_right: equ field_right-16
044A43             0197   collide_top: equ %00001000
044A43             0198   collide_bottom: equ %00000100
044A43             0199   collide_left: equ %00000010
044A43             0200   collide_right: equ %00000001
044A43             0201   
044A43             0202   ; ; #### BEGIN GAME VARIABLES ####
044A43             0203   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
044A43             0204   speed_player: equ 0x000300 ; 3 pixels per frame
044A43             0205   
044A43             0206   main:
044A43             0207   ; start a new game
044A43 CD 6D 4A 04 0208   	call new_game
044A47             0209   
044A47             0210   main_loop:
044A47             0211   ; scroll tiles
044A47 CD 1A 32 04 0212   	call tiles_plot
044A4B             0213   
044A4B             0214   ; get player input and update sprite position
044A4B CD 35 31 04 0215   	call player_input
044A4F             0216   
044A4F             0217   ; move enemies
044A4F CD 2E 33 04 0218   	call move_enemies
044A53             0219   
044A53             0220   ; wait for the next vblank mitigate flicker and for loop timing
044A53 CD E3 1F 04 0221   	call vdu_vblank
044A57             0222   
044A57             0223   ; poll keyboard
044A57 3E 08       0224       ld a, $08                           ; code to send to MOS
044A59 5B CF       0225       rst.lil $08                         ; get IX pointer to System Variables
044A5B             0226   
044A5B DD 7E 05    0227       ld a, (ix + $05)                    ; get ASCII code of key pressed
044A5E FE 1B       0228       cp 27                               ; check if 27 (ascii code for ESC)
044A60 CA 68 4A 04 0229       jp z, main_end                      ; if pressed, jump to exit
044A64             0230   
044A64 C3 47 4A 04 0231       jp main_loop
044A68             0232   
044A68             0233   main_end:
044A68 CD 29 1F 04 0234       call vdu_cursor_on
044A6C C9          0235   	ret
044A6D             0236   
044A6D             0237   new_game:
044A6D             0238   ; initialize sprites
044A6D CD B5 18 04 0239   	call sprites_init
044A71             0240   
044A71             0241   ; initialize the first level
044A71 AF          0242   	xor a
044A72 32 D0 31 04 0243   	ld (cur_level),a
044A76 CD CF 32 04 0244   	call init_level
044A7A             0245   
044A7A             0246   ; initialize player
044A7A CD F6 30 04 0247   	call player_init
044A7E             0248   
044A7E             0249   ; spawn an enemy sprite
044A7E 06 10       0250   	ld b,table_max_records
044A80             0251   @spawn_enemy_loop:
044A80 C5          0252   	push bc
044A81 CD AD 34 04 0253   	call enemy_init_from_landing_pad
044A85 C1          0254   	pop bc
044A86 10 F8       0255   	djnz @spawn_enemy_loop
044A88             0256   
044A88 C9          0257   	ret
044A89             0258   
044A89             0259   ; ; ###### INITIALIZE GAME #######
044A89             0260   ; ; clear the screen
044A89             0261   ;     ld a,3
044A89             0262   ;     out (81h),a
044A89             0263   
044A89             0264   ; ; reset the sprite table
044A89             0265   ;     xor a
044A89             0266   ;     ld (table_active_sprites),a
044A89             0267   ;     ld hl,table_limit
044A89             0268   ;     ld (table_base),hl
044A89             0269   ;     ld (table_pointer),hl
044A89             0270   
044A89             0271   ; ; draw a starfield over the entire screen
044A89             0272   ;     ld b,#50 ; first row of visible screen
044A89             0273   ; new_game_draw_stars_loop:
044A89             0274   ;     push bc
044A89             0275   ;     call draw_stars
044A89             0276   ;     pop bc
044A89             0277   ;     ld a,#10
044A89             0278   ;     add a,b
044A89             0279   ;     ld b,a
044A89             0280   ;     jr nz,new_game_draw_stars_loop
044A89             0281   
044A89             0282   ; ; ; print a welcome message
044A89             0283   ; ;     ld de,msg_welcome
044A89             0284   ; ;     ld hl,#581C
044A89             0285   ; ;     ld c,218 ; a bright pastel purple d677e3
044A89             0286   ; ;     call print_string
044A89             0287   
044A89             0288   ; ; push all that to frame buffer
044A89             0289   ;     ld a,#01 ; send video to frame buffer
044A89             0290   ;     out (81h),a
044A89             0291   
044A89             0292   ; ; reset score, lives, shields
044A89             0293   ;     xor a
044A89             0294   ;     ld hl,player_score
044A89             0295   ;     ld (hl),a ; player_score 0
044A89             0296   ;     inc hl
044A89             0297   ;     ld (hl),a ; player_score 1
044A89             0298   ;     inc hl
044A89             0299   ;     ld (hl),a ; player_score 3
044A89             0300   ;     inc hl
044A89             0301   ;     ld a,16
044A89             0302   ;     ld (hl),a ; player_shields
044A89             0303   ;     inc hl
044A89             0304   ;     ld (hl),a ; player_max_shields
044A89             0305   ;     inc hl
044A89             0306   ;     ld a,3
044A89             0307   ;     ld (hl),a ; player_ships
044A89             0308   ;     inc hl
044A89             0309   
044A89             0310   ; ; initialize first level
044A89             0311   ;     ld a,1 ; levels are zero-based, so this will wrap around
044A89             0312   ;     ld (cur_level),a
044A89             0313   ;     ld a,3 ; set max enemy sprites to easy street
044A89             0314   ;     ld (max_enemy_sprites),a
044A89             0315   ;     call dt_next_level
044A89             0316   ;     call dt
044A89             0317   
044A89             0318   ; ; spawn our intrepid hero
044A89             0319   ;     call player_init
044A89             0320   
044A89             0321   
044A89             0322   ; ; #### BEGIN GAME MAIN LOOP ####
044A89             0323   ; main_loop:
044A89             0324   ; ; ; debug: start execution counter
044A89             0325   ; ;     ld a,1
044A89             0326   ; ;     out (#e0),a ; start counting instructions
044A89             0327   
044A89             0328   ; ; refresh background from frame buffer
044A89             0329   ;     ld a,#02
044A89             0330   ;     out (81h),a
044A89             0331   ;     call move_background ; now move it
044A89             0332   ;     ld a,#01
044A89             0333   ;     out (81h),a ; save it back to buffer
044A89             0334   ; ; do all the things
044A89             0335   ;     call move_enemies
044A89             0336   ;     call player_move
044A89             0337   ;     call laser_control
044A89             0338   ;     call print_score
044A89             0339   ;     call draw_shields
044A89             0340   ;     call draw_lives
044A89             0341   ; ; ; debug: stop execution counter and print results
044A89             0342   ; ;     ld a,0
044A89             0343   ; ;     out (#e0),a ; stop counting instructions
044A89             0344   
044A89             0345   ; ; ; debug: start execution counter
044A89             0346   ; ;     ld a,1
044A89             0347   ; ;     out (#e0),a ; start counting instructions
044A89             0348   
044A89             0349   ;     call vdu_vblank
044A89             0350   ; ; ; debug: stop execution counter and print results
044A89             0351   ; ;     ld a,0
044A89             0352   ; ;     out (#e0),a ; stop counting instructions
044A89             0353   
044A89             0354   ;     jr main_loop
044A89             0355   ; #### END GAME MAIN LOOP ####
044A89             0356   
044A89             0357   ; draws the player's shields level
044A89             0358   ; draw_shields:
044A89             0359   ; TODO: Agonize this routine
044A89             0360   ; ; prep the loop to draw the bars
044A89             0361   ;     ld a,(player_shields) ; snag shields
044A89             0362   ;     and a
044A89             0363   ;     ret z ; don't draw if zero shields
044A89             0364   ; ; set loop counter and drawing position
044A89             0365   ;     ld b,a ; loop counter
044A89             0366   ;     ld hl,#5300+48+12
044A89             0367   ; ; set color based on bars remaining
044A89             0368   ;     ld c,103 ; bright green 28fe0a
044A89             0369   ;     cp 9
044A89             0370   ;     jp p,draw_shields_loop
044A89             0371   ;     ld c,74 ; bright yellow eafe5b
044A89             0372   ;     cp 3
044A89             0373   ;     jp p,draw_shields_loop
044A89             0374   ;     ld c,28 ; bright red fe0a0a
044A89             0375   ; draw_shields_loop:
044A89             0376   ;     push bc ; yup,outta
044A89             0377   ;     push hl ; registers again
044A89             0378   ;     ; ld a,#A8 ; ▀,168
044A89             0379   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
044A89             0380   ;     ; call draw_char
044A89             0381   ;     call draw_num ; we nuked draw_char for the time being
044A89             0382   ;     pop hl
044A89             0383   ;     ld a,8
044A89             0384   ;     add a,l
044A89             0385   ;     ld l,a
044A89             0386   ;     pop bc
044A89             0387   ;     djnz draw_shields_loop
044A89             0388       ; ret
044A89             0389   
044A89             0390   ; prints the player's score
044A89             0391   ; print_score:
044A89             0392   ; TODO: Agonize this
044A89             0393   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
044A89             0394   ;     ld c,42 ; dark orange b74400
044A89             0395   ;     ld hl,#5200+1+8+6*6
044A89             0396   ;     ld a,3 ; print 6 bdc digits
044A89             0397   ;     ld de,player_score
044A89             0398   ;     call print_num
044A89             0399   
044A89             0400   ;     ld c,58 ; golden yellow fec10a
044A89             0401   ;     ld hl,#5100+8+6*6
044A89             0402   ;     ld a,3 ; print 6 bdc digits
044A89             0403   ;     ld de,player_score
044A89             0404   ;     call print_num
044A89             0405       ; ret
044A89             0406   
044A89             0407   ; draw_lives:
044A89             0408   ;     ld hl,player_small ; make small yellow ship the active sprite
044A89             0409   ;     ld (sprite_base_bufferId),hl
044A89             0410   ;     ; ld a,#80 ; northern orientation
044A89             0411   ;     ; ld (sprite_orientation),a
044A89             0412   ;     ld hl,0 ; north
044A89             0413   ;     ld (sprite_heading),hl
044A89             0414   ;     xor a
044A89             0415   ;     ld (sprite_animation),a
044A89             0416   ;     ld a,#56 ; top of visible screen
044A89             0417   ;     ld (sprite_y+1),a
044A89             0418   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
044A89             0419   ;     ld a,(player_ships)
044A89             0420   ;     dec a ; we draw one fewer ships than lives
044A89             0421   ;     ret z ; nothing to draw here, move along
044A89             0422   ;     ld b,a ; loop counter
044A89             0423   ;     ld a,256-16 ; initial x position
044A89             0424   ; draw_lives_loop:
044A89             0425   ;     ld (sprite_x+1),a
044A89             0426   ;     push af
044A89             0427   ;     push bc
044A89             0428   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
044A89             0429   ;     pop bc
044A89             0430   ;     pop af
044A89             0431   ;     sub 10
044A89             0432   ;     djnz draw_lives_loop
044A89             0433   ;     ret
