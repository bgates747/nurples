PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0005   
040000             0006       MACRO PROGNAME
040000             0007       ASCIZ "flower_demo"
040000             0008       ENDMACRO
040000             0009   
040000 C3 45 00 04 0010       jp start
040004             0011   
040004             0012   _exec_name:
040004             0013   	PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010             0014   
040010 FF FF FF FF 0015       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0016       db "MOS"
040043 00          0017       db 00h
040044 01          0018       db 01h
040045             0019   
040045             0020   start:
040045 F5          0021       push af
040046 C5          0022       push bc
040047 D5          0023       push de
040048 DD E5       0024       push ix
04004A FD E5       0025       push iy
04004C             0026   
04004C CD F6 16 04 0027       call init
040050 CD F7 16 04 0028       call main
040054             0029   
040054             0030   exit:
040054             0031   
040054 FD E1       0032       pop iy
040056 DD E1       0033       pop ix
040058 D1          0034       pop de
040059 C1          0035       pop bc
04005A F1          0036       pop af
04005B 21 00 00 00 0037       ld hl,0
04005F             0038   
04005F C9          0039       ret
040060             0040   
040060             0041   ; --- MAIN PROGRAM ---
040060             0042   ; APPLICATION INCLUDES
040060             0043   ; API includes
040060             0044       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*          LD A, char
040060             0004*          RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*          ld bc,$+7     ; Address of first instruction after the jump
040060             0013*          push bc       ; which constitutes the return address
040060             0014*          jp   (hl)     ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*          ld bc,$+7     ; Address of first instruction after the jump
040060             0023*          push bc       ; which constitutes the return address
040060             0024*          jp   (ix)     ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*          ld bc,$+7     ; Address of first instruction after the jump
040060             0033*          push bc       ; which constitutes the return address
040060             0034*          jp   (iy)     ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*          push hl ; 4 cycles
040060             0041*          inc sp ; 1 cycle
040060             0042*          pop af  ; 4 cycles
040060             0043*          dec sp ; 1 cycle
040060             0044*                 ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*          ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*          ex af,af'
040070             0068*          exx
040070             0069*          push af
040070             0070*          push hl
040070             0071*          push bc
040070             0072*          push de
040070             0073*  
040070             0074*          ex af,af'
040070             0075*          exx
040070             0076*          push af
040070             0077*          push hl
040070             0078*          push bc
040070             0079*          push de
040070             0080*          push ix
040070             0081*          push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*          pop iy
040070             0086*          pop ix
040070             0087*          pop de
040070             0088*          pop bc
040070             0089*          pop hl
040070             0090*          pop af
040070             0091*          ex af,af'
040070             0092*          exx
040070             0093*  
040070             0094*          pop de
040070             0095*          pop bc
040070             0096*          pop hl
040070             0097*          pop af
040070             0098*          ex af,af'
040070             0099*          exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*  	PUSH	BC
040078 01 00 00 00 0119*  	LD		BC,0
04007C 3E 00       0120*  	LD 	 	A,0
04007E 5B DF       0121*  	RST.LIL 18h
040080 C1          0122*  	POP		BC
040081 C9          0123*  	RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*  	PUSH	BC
040083 01 00 00 00 0128*  	LD		BC, 0
040087 4E          0129*  	LD		C, (HL)
040088 5B DF       0130*  	RST.LIL	18h
04008A C1          0131*  	POP		BC
04008B C9          0132*  	RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*  	LD	A, '\r'
04008F 5B D7       0137*  	RST.LIL 10h
040091 3E 0A       0138*  	LD	A, '\n'
040093 5B D7       0139*  	RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*  	RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M         push hl ; 4 cycles
040098 33          0002*M         inc sp ; 1 cycle
040099 F1          0003*M         pop af  ; 4 cycles
04009A 3B          0004*M         dec sp ; 1 cycle
04009B             0005*M                ; 10 cycles total
04009B CD A5 00 04 0147*  	CALL	printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*  	LD		A,H
0400A0 CD A5 00 04 0152*  	CALL	printHex8
0400A4 7D          0153*  	LD		A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*  	LD		C,A
0400A6 1F          0158*  	RRA
0400A7 1F          0159*  	RRA
0400A8 1F          0160*  	RRA
0400A9 1F          0161*  	RRA
0400AA CD AF 00 04 0162*  	CALL	@F
0400AE 79          0163*  	LD		A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*  	AND		0Fh
0400B1 C6 90       0166*  	ADD		A,90h
0400B3 27          0167*  	DAA
0400B4 CE 40       0168*  	ADC		A,40h
0400B6 27          0169*  	DAA
0400B7 5B D7       0170*  	RST.LIL	10h
0400B9 C9          0171*  	RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*  	LD	A, '0'
04016F 5B D7       0290*  	RST.LIL 10h
040171 3E 78       0291*  	LD	A, 'x'
040173 5B D7       0292*  	RST.LIL 10h
040175 C9          0293*  	RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*          push hl
040176             0297*          push bc
040176             0298*          pop hl
040176             0299*          call printDec
040176             0300*          pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*          push hl
040176             0305*          push de
040176             0306*          pop hl
040176             0307*          call printDec
040176             0308*          pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*          call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*          push hl
040176             0317*          push ix
040176             0318*          pop hl
040176             0319*          call printDec
040176             0320*          pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*          push hl
040176             0325*          push iy
040176             0326*          pop hl
040176             0327*          call printDec
040176             0328*          pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*  	LD	 DE, _printDecBuffer
04017E CD B2 01 04 0344*  	CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD	 HL, _printDecBuffer
040186 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD	 A, (HL)
040189 FE 30       0351*      CP	 '0'
04018B C2 95 01 04 0352*      JP	 NZ, @done
04018F 3E 20       0353*      LD   A, ' '
040191 77          0354*      LD	 (HL), A
040192 23          0355*      INC	 HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*  	LD	 HL, _printDecBuffer
040199 CD 77 00 04 0361*  	CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*  	RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*  	LD	 BC,-10000000
0401B6 CD E9 01 04 0379*  	CALL @one_digit
0401BA 01 C0 BD F0 0380*  	LD	 BC,-1000000
0401BE CD E9 01 04 0381*  	CALL @one_digit
0401C2 01 60 79 FE 0382*  	LD	 BC,-100000
0401C6 CD E9 01 04 0383*  	CALL @one_digit
0401CA 01 F0 D8 FF 0384*  	LD   BC,-10000
0401CE CD E9 01 04 0385*  	CALL @one_digit
0401D2 01 18 FC FF 0386*  	LD   BC,-1000
0401D6 CD E9 01 04 0387*  	CALL @one_digit
0401DA 01 9C FF FF 0388*  	LD   BC,-100
0401DE CD E9 01 04 0389*  	CALL @one_digit
0401E2 0E F6       0390*  	LD   C,-10
0401E4 CD E9 01 04 0391*  	CALL @one_digit
0401E8 48          0392*  	LD   C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*  	LD   A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*  	INC  A
0401EC 09          0397*  	ADD  HL,BC
0401ED 38 FC       0398*  	JR   C,@divide_me
0401EF ED 42       0399*  	SBC  HL,BC
0401F1 12          0400*  	LD   (DE),A
0401F2 13          0401*  	INC  DE
0401F3 C9          0402*  	RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
040212 CD DC 0A 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld   bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld   bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld   bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld   c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld   c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp   @frac            ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc  a
040240 09          0443*      add  hl, bc           ; Accumulate until overflow
040241 38 FC       0444*      jr   c, @divide_me
040243 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
040245 12          0446*      ld   (de), a          ; Store ASCII digit
040246 13          0447*      inc  de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld   a, '.'           ; Decimal point
04024A 12          0452*      ld   (de), a
04024B 13          0453*      inc  de
04024C E1          0454*      pop  hl               ; Restore HL with original fraction
04024D 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld   a, '0'
040255 84          0460*      add  a, h             ; Convert integer part to ASCII
040256 12          0461*      ld   (de), a
040257 13          0462*      inc  de
040258 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor  a                ; Null terminator
04025B 12          0466*      ld   (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 75 0A 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8      ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
04031B             0602*                  ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*  	ld hl,@cmd
04032B 01 08 00 00 0615*  	ld bc,@end-@cmd
04032F 5B DF       0616*  	rst.lil $18
040331 C9          0617*  	ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8      ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
040340             0627*                  ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*  	ld hl,@cmd
040350 01 08 00 00 0640*  	ld bc,@end-@cmd
040354 5B DF       0641*  	rst.lil $18
040356 C9          0642*  	ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl  ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*  	MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl  ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
04056B 5B D7       0903*  	rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*  	call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0045       include "vdu.inc"
04068E             0001*  
04068E             0002*  ; VDU 30: Home cursor
04068E             0003*  vdu_home_cursor:
04068E 3E 1E       0004*      ld a,30
040690 5B D7       0005*  	rst.lil $10
040692 C9          0006*  	ret
040693             0007*  
040693             0008*  vdu_cursor_on:
040693 21 9E 06 04 0009*  	ld hl,@cmd
040697 01 03 00 00 0010*  	ld bc,@end-@cmd
04069B 5B DF       0011*  	rst.lil $18
04069D C9          0012*  	ret
04069E             0013*  @cmd:
04069E 17 01 01    0014*  	db 23,1,1
0406A1             0015*  @end:
0406A1             0016*  
0406A1             0017*  vdu_cursor_off:
0406A1 21 AC 06 04 0018*  	ld hl,@cmd
0406A5 01 03 00 00 0019*  	ld bc,@end-@cmd
0406A9 5B DF       0020*  	rst.lil $18
0406AB C9          0021*  	ret
0406AC             0022*  @cmd:
0406AC 17 01 00    0023*  	db 23,1,0
0406AF             0024*  @end:
0406AF             0025*  
0406AF             0026*  ; VDU 5: Write text at graphics cursor
0406AF             0027*  ; inputs: a is the character to write to the screen
0406AF             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0406AF             0029*  ; outputs: see the name of the function
0406AF             0030*  ; destroys: a, hl, bc
0406AF             0031*  vdu_char_to_gfx_cursor:
0406AF 32 BF 06 04 0032*  	ld (@arg),a
0406B3 21 BE 06 04 0033*  	ld hl,@cmd
0406B7 01 02 00 00 0034*  	ld bc,@end-@cmd
0406BB 5B DF       0035*  	rst.lil $18
0406BD C9          0036*  	ret
0406BE 05          0037*  @cmd: db 5
0406BF 00          0038*  @arg: db 0
0406C0             0039*  @end:
0406C0             0040*  ; VDU 9: Move cursor forward one character
0406C0             0041*  vdu_cursor_forward:
0406C0 3E 09       0042*      ld a,9
0406C2 5B D7       0043*  	rst.lil $10
0406C4 C9          0044*  	ret
0406C5             0045*  
0406C5             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0406C5             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0406C5             0048*  vdu_move_cursor:
0406C5 ED 43 D6 06 0049*      ld (@x0),bc
       04          
0406CA 21 D5 06 04 0050*  	ld hl,@cmd
0406CE 01 03 00 00 0051*  	ld bc,@end-@cmd
0406D2 5B DF       0052*  	rst.lil $18
0406D4 C9          0053*  	ret
0406D5 1F          0054*  @cmd: 	db 31
0406D6 00          0055*  @x0:	db 0
0406D7 00          0056*  @y0: 	db 0
0406D8 00          0057*  @end: 	db 0 ; padding
0406D9             0058*  
0406D9             0059*  ; VDU 12: Clear text area (CLS)
0406D9             0060*  vdu_cls:
0406D9 3E 0C       0061*      ld a,12
0406DB 5B D7       0062*  	rst.lil $10
0406DD C9          0063*  	ret
0406DE             0064*  
0406DE             0065*  vdu_flip:
0406DE 21 E9 06 04 0066*  	ld hl,@cmd
0406E2 01 03 00 00 0067*  	ld bc,@end-@cmd
0406E6 5B DF       0068*  	rst.lil $18
0406E8 C9          0069*  	ret
0406E9 17 00 C3    0070*  @cmd: db 23,0,0xC3
0406EC             0071*  @end:
0406EC             0072*  
0406EC             0073*  ; VDU 16: Clear graphics area (CLG)
0406EC             0074*  vdu_clg:
0406EC 3E 10       0075*      ld a,16
0406EE 5B D7       0076*  	rst.lil $10
0406F0 C9          0077*  	ret
0406F1             0078*  
0406F1             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0406F1             0080*  ; VDU 23, 7: Scrolling
0406F1             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0406F1             0082*  ; inputs: a, extent; l, direction; h; speed
0406F1             0083*  vdu_scroll_down:
0406F1 32 06 07 04 0084*  	ld (@extent),a
0406F5 22 07 07 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0406F9 21 04 07 04 0086*  	ld hl,@cmd
0406FD 01 05 00 00 0087*  	ld bc,@end-@cmd
040701 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
040703 C9          0089*  	ret
040704 17 07       0090*  @cmd:       db 23,7
040706 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
040707 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
040708 00          0093*  @speed:     db 0x00 ; pixels
040709 00          0094*  @end:		db 0x00 ; padding
04070A             0095*  
04070A             0096*  ; COLOUR MODES
04070A             0097*  ; Mode	Effect
04070A             0098*  ; 0	Set on-screen pixel to target colour value
04070A             0099*  ; 1	OR value with the on-screen pixel
04070A             0100*  ; 2	AND value with the on-screen pixel
04070A             0101*  ; 3	XOR value with the on-screen pixel
04070A             0102*  ; 4	Invert the on-screen pixel
04070A             0103*  ; 5	No operation
04070A             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
04070A             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
04070A             0106*  
04070A             0107*  ; VDU 17, colour: Define text colour (COLOUR)
04070A             0108*  vdu_colour_text:
04070A 32 1A 07 04 0109*  	ld (@arg),a
04070E 21 19 07 04 0110*  	ld hl,@cmd
040712 01 02 00 00 0111*  	ld bc,@end-@cmd
040716 5B DF       0112*  	rst.lil $18
040718 C9          0113*  	ret
040719 11          0114*  @cmd: db 17
04071A 00          0115*  @arg: db 0
04071B             0116*  @end:
04071B             0117*  
04071B             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04071B             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04071B             0120*  vdu_gcol:
04071B 32 30 07 04 0121*  	ld (@mode),a
04071F 79          0122*      ld a,c
040720 32 31 07 04 0123*      ld (@col),a
040724 21 2F 07 04 0124*  	ld hl,@cmd
040728 01 03 00 00 0125*  	ld bc,@end-@cmd
04072C 5B DF       0126*  	rst.lil $18
04072E C9          0127*  	ret
04072F 12          0128*  @cmd:  db 18
040730 00          0129*  @mode: db 0
040731 00          0130*  @col:  db 0
040732             0131*  @end:
040732             0132*  
040732             0133*  
040732             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
040732             0135*  ; MIND THE LITTLE-ENDIANESS
040732             0136*  ; inputs: c=left,b=bottom,e=right,d=top
040732             0137*  ; outputs; nothing
040732             0138*  ; destroys: a might make it out alive
040732             0139*  vdu_set_txt_viewport:
040732 ED 43 48 07 0140*      ld (@lb),bc
       04          
040737 ED 53 4A 07 0141*  	ld (@rt),de
       04          
04073C 21 47 07 04 0142*  	ld hl,@cmd
040740 01 05 00 00 0143*  	ld bc,@end-@cmd
040744 5B DF       0144*  	rst.lil $18
040746 C9          0145*  	ret
040747 1C          0146*  @cmd:   db 28 ; set text viewport command
040748 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
04074A 00 00       0148*  @rt: 	dw 0x0000 ; set by de
04074C 00          0149*  @end:   db 0x00	  ; padding
04074D             0150*  
04074D             0151*  ; Wait for VBLANK interrupt
04074D             0152*  vdu_vblank:
04074D DD E5       0153*      PUSH 	IX
04074F             0154*  	MOSCALL	mos_sysvars
04074F 3E 08       0001*M 			LD	A, function
040751 5B CF       0002*M 			RST.LIL	08h
040753 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
040756             0156*  @wait:
040756 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
040759 28 FB       0158*      JR	Z, @wait
04075B DD E1       0159*      POP	IX
04075D C9          0160*      RET
04075E             0161*  
04075E             0162*  ; VDU 29, x; y;: Set graphics origin
04075E             0163*  ; This command sets the graphics origin.
04075E             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04075E             0165*  ; inputs: bc=x0,de=y0
04075E             0166*  ; outputs; nothing
04075E             0167*  ; destroys: a might make it out alive
04075E             0168*  vdu_set_gfx_origin:
04075E ED 43 74 07 0169*      ld (@x0),bc
       04          
040763 ED 53 76 07 0170*      ld (@y0),de
       04          
040768 21 73 07 04 0171*      ld hl,@cmd
04076C 01 05 00 00 0172*      ld bc,@end-@cmd
040770 5B DF       0173*      rst.lil $18
040772 C9          0174*      ret
040773 1D          0175*  @cmd:   db 29 ; set graphics origin command
040774 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
040776 00 00       0177*  @y0: 	dw 0x0000 ; set by de
040778 00          0178*  @end:   db 0x00	  ; padding
040779             0179*  
040779             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040779             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
040779             0182*  ; 	because we have turned off logical screen scaling
040779             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040779             0184*  ; outputs; nothing
040779             0185*  ; destroys: a might make it out alive
040779             0186*  vdu_set_gfx_viewport:
040779 ED 43 99 07 0187*      ld (@x0),bc
       04          
04077E FD 22 9B 07 0188*      ld (@y1),iy
       04          
040783 DD 22 9D 07 0189*  	ld (@x1),ix
       04          
040788 ED 53 9F 07 0190*  	ld (@y0),de
       04          
04078D 21 98 07 04 0191*  	ld hl,@cmd
040791 01 09 00 00 0192*  	ld bc,@end-@cmd
040795 5B DF       0193*  	rst.lil $18
040797 C9          0194*  	ret
040798 18          0195*  @cmd:   db 24 ; set graphics viewport command
040799 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
04079B 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
04079D 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
04079F 00 00       0199*  @y0: 	dw 0x0000 ; set by de
0407A1 00          0200*  @end:   db 0x00	  ; padding
0407A2             0201*  
0407A2             0202*  ; SCREEN MODES
0407A2             0203*  ; ===============================
0407A2             0204*  ; Mode  Horz  Vert  Cols  Refresh
0407A2             0205*  ; ---   ----  ----  ----  -------
0407A2             0206*  ; 11    320   240   2     60hz
0407A2             0207*  ; 139   320   240   2     60hz
0407A2             0208*  ; 23    512   384   2     60hz
0407A2             0209*  ; 151   512   384   2     60hz
0407A2             0210*  ; 6     640   240   2     60hz
0407A2             0211*  ; 134   640   240   2     60hz
0407A2             0212*  ; 2     640   480   2     60hz
0407A2             0213*  ; 130   640   480   2     60hz
0407A2             0214*  ; 17    800   600   2     60hz
0407A2             0215*  ; 145   800   600   2     60hz
0407A2             0216*  ; 18    1024  768   2     60hz
0407A2             0217*  ; 146   1024  768   2     60hz
0407A2             0218*  ; ---   ----  ----  ----  -------
0407A2             0219*  ; 10    320   240   4     60hz
0407A2             0220*  ; 138   320   240   4     60hz
0407A2             0221*  ; 22    512   384   4     60hz
0407A2             0222*  ; 150   512   384   4     60hz
0407A2             0223*  ; 5     640   240   4     60hz
0407A2             0224*  ; 133   640   240   4     60hz
0407A2             0225*  ; 1     640   480   4     60hz
0407A2             0226*  ; 129   640   480   4     60hz
0407A2             0227*  ; 16    800   600   4     60hz
0407A2             0228*  ; 19    1024  768   4     60hz
0407A2             0229*  ; ---   ----  ----  ----  -------
0407A2             0230*  ; 9     320   240   16    60hz
0407A2             0231*  ; 137   320   240   16    60hz
0407A2             0232*  ; 21    512   384   16    60hz
0407A2             0233*  ; 149   512   384   16    60hz
0407A2             0234*  ; 4     640   240   16    60hz
0407A2             0235*  ; 132   640   240   16    60hz
0407A2             0236*  ; 0     640   480   16    60hz
0407A2             0237*  ; 7     n/a   n/a   16    60hz
0407A2             0238*  ; ---   ----  ----  ----  -------
0407A2             0239*  ; 8     320   240   64    60hz
0407A2             0240*  ; 136   320   240   64    60hz
0407A2             0241*  ; 20    512   384   64    60hz
0407A2             0242*  ; 3     640   240   64    60hz
0407A2             0243*  ; ---   ----  ----  ----  -------
0407A2             0244*  vdu_set_screen_mode:
0407A2 32 B2 07 04 0245*  	ld (@arg),a
0407A6 21 B1 07 04 0246*  	ld hl,@cmd
0407AA 01 02 00 00 0247*  	ld bc,@end-@cmd
0407AE 5B DF       0248*  	rst.lil $18
0407B0 C9          0249*  	ret
0407B1 16          0250*  @cmd: db 22 ; set screen mode
0407B2 00          0251*  @arg: db 0  ; screen mode parameter
0407B3             0252*  @end:
0407B3             0253*  
0407B3             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0407B3             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0407B3             0256*  ; note: default setting on boot is scaling ON
0407B3             0257*  vdu_set_scaling:
0407B3 32 C5 07 04 0258*  	ld (@arg),a
0407B7 21 C2 07 04 0259*  	ld hl,@cmd
0407BB 01 04 00 00 0260*  	ld bc,@end-@cmd
0407BF 5B DF       0261*  	rst.lil $18
0407C1 C9          0262*  	ret
0407C2 17 00 C0    0263*  @cmd: db 23,0,0xC0
0407C5 00          0264*  @arg: db 0  ; scaling on/off
0407C6             0265*  @end:
0407C6             0266*  
0407C6             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0407C6             0268*  ; inputs: hl=bufferId
0407C6             0269*  vdu_buff_select:
0407C6 22 D8 07 04 0270*  	ld (@bufferId),hl
0407CA 21 D5 07 04 0271*  	ld hl,@cmd
0407CE 01 05 00 00 0272*  	ld bc,@end-@cmd
0407D2 5B DF       0273*  	rst.lil $18
0407D4 C9          0274*  	ret
0407D5 17 1B 20    0275*  @cmd: db 23,27,0x20
0407D8 00 00       0276*  @bufferId: dw 0x0000
0407DA 00          0277*  @end: db 0x00 ; padding
0407DB             0278*  
0407DB             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0407DB             0280*  ; inputs: a=format; bc=width; de=height
0407DB             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0407DB             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0407DB             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0407DB             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0407DB             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0407DB             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
0407DB             0287*  vdu_bmp_create:
0407DB ED 43 F7 07 0288*      ld (@width),bc
       04          
0407E0 ED 53 F9 07 0289*      ld (@height),de
       04          
0407E5 32 FB 07 04 0290*      ld (@fmt),a
0407E9 21 F4 07 04 0291*  	ld hl,@cmd
0407ED 01 08 00 00 0292*  	ld bc,@end-@cmd
0407F1 5B DF       0293*  	rst.lil $18
0407F3 C9          0294*  	ret
0407F4 17 1B 21    0295*  @cmd:       db 23,27,0x21
0407F7 00 00       0296*  @width:     dw 0x0000
0407F9 00 00       0297*  @height:    dw 0x0000
0407FB 00          0298*  @fmt:       db 0x00
0407FC             0299*  @end:
0407FC             0300*  
0407FC             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0407FC             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0407FC             0303*  vdu_load_img_rgba2_to_8:
0407FC             0304*  ; backup the target buffer id and image dimensions
0407FC E5          0305*      push hl
0407FD D5          0306*      push de
0407FE C5          0307*      push bc
0407FF             0308*  ; load the rgba2 image to working buffer 65534
0407FF 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
040803 CD 06 09 04 0310*  	call vdu_load_buffer_from_file
040807             0311*  ; restore the image dimensions and target buffer id
040807 C1          0312*      pop bc
040808 D1          0313*      pop de
040809 E1          0314*      pop hl
04080A             0315*  ; fall through to vdu_rgba2_to_8
04080A             0316*  
04080A             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04080A             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04080A             0319*  ; the "expand bitmap" command is:
04080A             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04080A             0321*  ; and then to reverse the byte order to fix endian-ness:
04080A             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04080A             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04080A             0324*  ; VDU 23,27,&20,targetBufferID%;
04080A             0325*  ; VDU 23,27,&21,width%;height%;0
04080A             0326*  ; -------------------------------------------------------------------
04080A             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
04080A             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04080A             0329*  vdu_rgba2_to_8:
04080A             0330*  ; load the image dimensions and buffer id parameters
04080A ED 43 66 08 0331*      ld (@width),bc
       04          
04080F ED 53 68 08 0332*      ld (@height),de
       04          
040814 22 4B 08 04 0333*      ld (@bufferId0),hl
040818 22 58 08 04 0334*      ld (@bufferId2),hl
04081C 22 61 08 04 0335*      ld (@bufferId1),hl
040820             0336*  ; clean up bytes that got stomped on by the ID loads
040820 3E 48       0337*      ld a,0x48
040822 32 4D 08 04 0338*      ld (@bufferId0+2),a
040826 3E 17       0339*      ld a,23
040828 32 63 08 04 0340*      ld (@bufferId1+2),a
04082C 3E 18       0341*      ld a,24
04082E 32 5A 08 04 0342*      ld (@bufferId2+2),a
040832 AF          0343*      xor a
040833 32 6A 08 04 0344*      ld (@height+2),a
040837             0345*  ; send the vdu command strings
040837 21 42 08 04 0346*      ld hl,@beg
04083B 01 29 00 00 0347*      ld bc,@end-@beg
04083F 5B DF       0348*      rst.lil $18
040841 C9          0349*      ret
040842             0350*  @beg:
040842             0351*  ; Command 14: Consolidate blocks in a buffer
040842             0352*  ; VDU 23, 0, &A0, bufferId; 14
040842 17 00 A0    0353*      db 23,0,0xA0
040845 FE FF       0354*      dw 65534 ; workingBufferId
040847 0E          0355*      db 14 ; consolidate blocks
040848             0356*  ; the "expand bitmap" command is:
040848             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040848 17 00 A0    0358*      db 23,0,0xA0
04084B 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04084D 48          0360*      db 0x48 ; given as decimal command 72 in the docs
04084E 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04084F FE FF       0362*      dw 65534 ; sourceBufferId
040851 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040855             0364*  ; reverse the byte order to fix endian-ness:
040855             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
040855             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040855             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040855 17 00 A0    0368*      db 23,0,0xA0
040858 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04085A 18          0370*      db 24 ; reverse byte order
04085B 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04085C 04 00       0372*      dw 4 ; size (4 bytes)
04085E             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04085E             0374*  ; VDU 23,27,&20,targetBufferID%;
04085E 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
040861 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
040863             0377*  ; VDU 23,27,&21,width%;height%;0
040863 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
040866 00 00       0379*  @width: dw 0x0000
040868 00 00       0380*  @height: dw 0x0000
04086A 00          0381*      db 0x00 ; rgba8888 format
04086B             0382*  @end:
04086B             0383*  
04086B             0384*  ; scratch variables
04086B 00 00 00    0385*  bufferId0: dl 0x000000
04086E 00 00 00    0386*  bufferId1: dl 0x000000
040871             0387*  
040871             0388*  ; load a vdu buffer from local memory
040871             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040871             0390*  vdu_load_buffer:
040871 ED 43 9A 08 0391*      ld (@length),bc
       04          
040876 D5          0392*      push de ; save data pointer
040877             0393*  ; send the vdu command string
040877 7D          0394*      ld a,l
040878 32 97 08 04 0395*      ld (@bufferId),a
04087C 7C          0396*      ld a,h
04087D 32 98 08 04 0397*      ld (@bufferId+1),a
040881 21 94 08 04 0398*      ld hl,@cmd
040885 01 08 00 00 0399*      ld bc,@end-@cmd
040889 5B DF       0400*      rst.lil $18
04088B             0401*  ; send the buffer data
04088B E1          0402*      pop hl ; pointer to data
04088C ED 4B 9A 08 0403*      ld bc,(@length)
       04          
040891 5B DF       0404*      rst.lil $18 ; send it
040893 C9          0405*      ret
040894             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040894 17 00 A0    0407*  @cmd:       db 23,0,0xA0
040897 00 00       0408*  @bufferId:	dw 0x0000
040899 00          0409*  		    db 0 ; load buffer
04089A 00 00       0410*  @length:	dw 0x0000
04089C 00          0411*  @end: db 0 ; padding
04089D             0412*  
04089D             0413*  ; clear a buffer
04089D             0414*  ; inputs: hl = bufferId
04089D             0415*  vdu_clear_buffer:
04089D 7D          0416*      ld a,l
04089E 32 B5 08 04 0417*      ld (@bufferId),a
0408A2 7C          0418*      ld a,h
0408A3 32 B6 08 04 0419*      ld (@bufferId+1),a
0408A7 21 B2 08 04 0420*      ld hl,@cmd
0408AB 01 06 00 00 0421*      ld bc,@end-@cmd
0408AF 5B DF       0422*      rst.lil $18
0408B1 C9          0423*      ret
0408B2 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0408B5 00 00       0425*  @bufferId:	dw 0x0000
0408B7 02          0426*  		    db 2 ; clear buffer
0408B8             0427*  @end:
0408B8             0428*  
0408B8             0429*  vdu_clear_all_buffers:
0408B8             0430*  ; clear all buffers
0408B8 21 C3 08 04 0431*      ld hl,@beg
0408BC 01 06 00 00 0432*      ld bc,@end-@beg
0408C0 5B DF       0433*      rst.lil $18
0408C2 C9          0434*      ret
0408C3 17 00 A0    0435*  @beg: db 23,0,$A0
0408C6 FF FF       0436*        dw -1 ; clear all buffers
0408C8 02          0437*        db 2  ; command 2: clear a buffer
0408C9             0438*  @end:
0408C9             0439*  
0408C9             0440*  ; Command 14: Consolidate blocks in a buffer
0408C9             0441*  vdu_consolidate_buffer:
0408C9             0442*  ; set parameters for vdu call
0408C9 7D          0443*      ld a,l
0408CA 32 E1 08 04 0444*      ld (@bufferId),a
0408CE 7C          0445*      ld a,h
0408CF 32 E2 08 04 0446*      ld (@bufferId+1),a
0408D3 21 DE 08 04 0447*      ld hl,@beg
0408D7 01 06 00 00 0448*      ld bc,@end-@beg
0408DB 5B DF       0449*      rst.lil $18
0408DD C9          0450*      ret
0408DE             0451*  ; VDU 23, 0, &A0, bufferId; 14
0408DE 17 00 A0    0452*  @beg: db 23,0,0xA0
0408E1 00 00       0453*  @bufferId: dw 0x0000
0408E3 0E          0454*             db 14
0408E4             0455*  @end:
0408E4             0456*  
0408E4             0457*  ; load an image file to a buffer and make it a bitmap
0408E4             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0408E4             0459*  vdu_load_img:
0408E4             0460*  ; back up image type and dimension parameters
0408E4 22 6B 08 04 0461*      ld (bufferId0),hl
0408E8 F5          0462*      push af
0408E9 C5          0463*  	push bc
0408EA D5          0464*  	push de
0408EB             0465*  ; load the image
0408EB CD 06 09 04 0466*  	call vdu_load_buffer_from_file
0408EF             0467*  ; now make it a bitmap
0408EF 2A 6B 08 04 0468*      ld hl,(bufferId0)
0408F3 CD C9 08 04 0469*      call vdu_consolidate_buffer
0408F7 2A 6B 08 04 0470*      ld hl,(bufferId0)
0408FB CD C6 07 04 0471*      call vdu_buff_select
0408FF D1          0472*  	pop de ; image height
040900 C1          0473*  	pop bc ; image width
040901 F1          0474*  	pop af ; image type
040902 C3 DB 07 04 0475*  	jp vdu_bmp_create ; will return to caller from there
040906             0476*  
040906             0477*  ; inputs: hl = bufferId; iy = pointer to filename
040906             0478*  vdu_load_buffer_from_file:
040906 22 6B 08 04 0479*      ld (bufferId0),hl
04090A             0480*  
04090A             0481*  ; clear target buffer
04090A CD 9D 08 04 0482*      call vdu_clear_buffer
04090E             0483*  
04090E             0484*  ; open the file in read mode
04090E             0485*  ; Open a file
04090E             0486*  ; HLU: Filename
04090E             0487*  ;   C: Mode
04090E             0488*  ; Returns:
04090E             0489*  ;   A: Filehandle, or 0 if couldn't open
04090E FD E5       0490*  	push iy ; pointer to filename
040910 E1          0491*  	pop hl
040911 0E 01       0492*  	ld c,fa_read
040913             0493*      MOSCALL mos_fopen
040913 3E 0A       0001*M 			LD	A, function
040915 5B CF       0002*M 			RST.LIL	08h
040917 32 52 09 04 0494*      ld (@filehandle),a
04091B             0495*  
04091B             0496*  @read_file:
04091B             0497*  ; Read a block of data from a file
04091B             0498*  ;   C: Filehandle
04091B             0499*  ; HLU: Pointer to where to write the data to
04091B             0500*  ; DEU: Number of bytes to read
04091B             0501*  ; Returns:
04091B             0502*  ; DEU: Number of bytes read
04091B 3A 52 09 04 0503*      ld a,(@filehandle)
04091F 4F          0504*      ld c,a
040920 21 00 E0 B7 0505*      ld hl,filedata
040924 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
040928             0507*      MOSCALL mos_fread
040928 3E 1A       0001*M 			LD	A, function
04092A 5B CF       0002*M 			RST.LIL	08h
04092C             0508*  
04092C             0509*  ; test de for zero bytes read
04092C 21 00 00 00 0510*      ld hl,0
040930 AF          0511*      xor a ; clear carry
040931 ED 52       0512*      sbc hl,de
040933 CA 49 09 04 0513*      jp z,@close_file
040937             0514*  
040937             0515*  ; load a vdu buffer from local memory
040937             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040937 2A 6B 08 04 0517*      ld hl,(bufferId0)
04093B D5          0518*      push de ; chunksize
04093C C1          0519*      pop bc
04093D 11 00 E0 B7 0520*      ld de,filedata
040941 CD 71 08 04 0521*      call vdu_load_buffer
040945             0522*  
040945             0523*  ; read the next block
040945 C3 1B 09 04 0524*      jp @read_file
040949             0525*  
040949             0526*  ; close the file
040949             0527*  @close_file:
040949 3A 52 09 04 0528*      ld a,(@filehandle)
04094D             0529*      MOSCALL mos_fclose
04094D 3E 0B       0001*M 			LD	A, function
04094F 5B CF       0002*M 			RST.LIL	08h
040951 C9          0530*      ret ; vdu_load_buffer_from_file
040952             0531*  
040952 00          0532*  @filehandle: db 0 ; file handle
040953 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
040956             0534*  
040956 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
040959             0536*  
040959             0537*  ; File information structure (FILINFO)
040959             0538*  @filinfo:
040959 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04095D 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04095F 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040961 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040962 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04096F 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040A6F             0046   	include "maths.inc"
040A6F             0001*  ; test the sign of HL
040A6F             0002*  ; inputs: HL obviously
040A6F             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040A6F             0004*  ; destroys: flags
040A6F             0005*      MACRO sign_hlu
040A6F             0006*          add hl,de
040A6F             0007*          or a
040A6F             0008*          sbc hl,de
040A6F             0009*      ENDMACRO
040A6F             0010*  
040A6F             0011*  
040A6F             0012*  ;------------------------------------------------------------------------
040A6F             0013*  ; Scratch area for calculations
040A6F             0014*  ;------------------------------------------------------------------------
040A6F 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
040A72 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
040A75             0017*  
040A75             0018*  ; absolute value of hlu
040A75             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040A75             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040A75             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040A75             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040A75             0023*  ; destroys: a
040A75             0024*  hlu_abs:
040A75 19          0025*      add hl,de
040A76 B7          0026*      or a
040A77 ED 52       0027*      sbc hl,de
040A79 FA 7E 0A 04 0028*      jp m,@is_neg
040A7D C9          0029*      ret         ; hlu is positive or zero so we're done
040A7E             0030*  @is_neg:
040A7E F5          0031*      push af     ; otherwise, save current flags for return
040A7F CD 85 0A 04 0032*      call neg_hlu ; negate hlu
040A83 F1          0033*      pop af      ; get back flags
040A84 C9          0034*      ret
040A85             0035*  
040A85             0036*  ; flip the sign of hlu
040A85             0037*  ; inputs: hlu
040A85             0038*  ; returns: 0-hlu, flags set appropriately for the result:
040A85             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
040A85             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
040A85             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
040A85             0042*  ; destroys a
040A85             0043*  neg_hlu:
040A85 D5          0044*      push de     ; save de
040A86 EB          0045*      ex de,hl    ; put hl into de
040A87 21 00 00 00 0046*      ld hl,0     ; clear hl
040A8B AF          0047*      xor a       ; clear carry
040A8C ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
040A8E D1          0049*      pop de      ; get de back
040A8F C9          0050*      ret         ; easy peasy
040A90             0051*  
040A90             0052*  ;------------------------------------------------------------------------
040A90             0053*  ; divide hlu by 2, inspired by above
040A90             0054*  ;------------------------------------------------------------------------
040A90             0055*  hlu_div2:
040A90 22 6F 0A 04 0056*  	ld		(scratch1),hl
040A94 21 71 0A 04 0057*  	ld		hl,scratch1+2
040A98 CB 1E       0058*  	rr		(hl)
040A9A 2B          0059*  	dec		hl
040A9B CB 1E       0060*  	rr		(hl)
040A9D 2B          0061*  	dec		hl
040A9E CB 1E       0062*  	rr		(hl)
040AA0 23          0063*  	inc		hl
040AA1 23          0064*  	inc		hl
040AA2 2A 6F 0A 04 0065*      ld hl,(scratch1)
040AA6 C9          0066*      ret
040AA7             0067*  
040AA7             0068*  ; this is my little hack to divide by 16
040AA7             0069*  hlu_div16:
040AA7 AF          0070*      xor a
040AA8 29          0071*      add hl,hl
040AA9 17          0072*      rla
040AAA 29          0073*      add hl,hl
040AAB 17          0074*      rla
040AAC 29          0075*      add hl,hl
040AAD 17          0076*      rla
040AAE 29          0077*      add hl,hl
040AAF 17          0078*      rla
040AB0 22 BD 0A 04 0079*      ld (@scratch),hl
040AB4 32 C0 0A 04 0080*      ld (@scratch+3),a
040AB8 2A BE 0A 04 0081*      ld hl,(@scratch+1)
040ABC C9          0082*      ret
040ABD             0083*  @scratch: ds 4
040AC1             0084*  
040AC1             0085*  ; hlu signed division by 256
040AC1             0086*  ; returns: hlu / 256
040AC1             0087*  ; destroys: af
040AC1             0088*  hlu_sdiv256:
040AC1 AF          0089*      xor a ; assume hl is positive
040AC2 22 D8 0A 04 0090*      ld (@buffer),hl
040AC6             0091*      sign_hlu
040AC6 19          0001*M         add hl,de
040AC7 B7          0002*M         or a
040AC8 ED 52       0003*M         sbc hl,de
040ACA F2 CF 0A 04 0092*      jp p,@hl_pos
040ACE 3D          0093*      dec a
040ACF             0094*  @hl_pos:
040ACF 32 DB 0A 04 0095*      ld (@buffer+3),a
040AD3 2A D9 0A 04 0096*      ld hl,(@buffer+1)
040AD7 C9          0097*      ret
040AD8             0098*  @buffer: ds 4
040ADC             0099*  
040ADC             0100*  ; hlu 1 byte right shift, unsigned
040ADC             0101*  ; returns: hlu / 256, fractional portion in a
040ADC             0102*  ; destroys: af
040ADC             0103*  hlu_udiv256:
040ADC AF          0104*  	xor a
040ADD 32 EE 0A 04 0105*  	ld (@buffer+3),a
040AE1 7D          0106*  	ld a,l ; save the fractional portion
040AE2 22 EB 0A 04 0107*  	ld (@buffer),hl
040AE6 2A EC 0A 04 0108*  	ld hl,(@buffer+1)
040AEA C9          0109*  	ret
040AEB             0110*  @buffer: ds 4
040AEF             0111*  
040AEF             0112*      MACRO hlu_mul256
040AEF             0113*          add hl,hl ; * 2
040AEF             0114*          add hl,hl ; * 4
040AEF             0115*          add hl,hl ; * 8
040AEF             0116*          add hl,hl ; * 16
040AEF             0117*          add hl,hl ; * 32
040AEF             0118*          add hl,hl ; * 64
040AEF             0119*          add hl,hl ; * 128
040AEF             0120*          add hl,hl ; * 256
040AEF             0121*      ENDMACRO
040AEF             0122*  
040AEF             0123*  ; compute the modulo of hlu by deu
040AEF             0124*  ; outputs: hlu = hlu % deu
040AEF             0125*  ; destroys: f, hl
040AEF             0126*  hlu_mod:
040AEF B7          0127*  	or a ; clear carry
040AF0             0128*  @loop:
040AF0 ED 52       0129*      sbc hl,de
040AF2 DA FA 0A 04 0130*      jp c, @end
040AF6 C3 F0 0A 04 0131*      jp @loop
040AFA             0132*  @end:
040AFA 19          0133*      add hl,de
040AFB C9          0134*  	ret
040AFC             0135*  
040AFC             0136*  
040AFC 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
040B00 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040B04             0139*  
040B04             0140*  ; set bcd values in a scratch memory address from registers bcde
040B04             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040B04             0142*  ; destroys ; hl
040B04             0143*  set_bcd:
040B04 73          0144*      ld (hl),e
040B05 23          0145*      inc hl
040B06 72          0146*      ld (hl),d
040B07 23          0147*      inc hl
040B08 71          0148*      ld (hl),c
040B09 23          0149*      inc hl
040B0A 70          0150*      ld (hl),b
040B0B C9          0151*      ret
040B0C             0152*  
040B0C             0153*  ; load bcd values from a scratch memory address to bcde
040B0C             0154*  ; input: hl; scratch address
040B0C             0155*  ; output: bcde; 8-place bcd number
040B0C             0156*  ; destroys: hl
040B0C             0157*  get_bcd:
040B0C 5E          0158*      ld e,(hl)
040B0D 23          0159*      inc hl
040B0E 56          0160*      ld d,(hl)
040B0F 23          0161*      inc hl
040B10 4E          0162*      ld c,(hl)
040B11 23          0163*      inc hl
040B12 46          0164*      ld b,(hl)
040B13 C9          0165*      ret
040B14             0166*  
040B14             0167*  ; BCD addition
040B14             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B14             0169*  ;       a is the number of bytes holding each number (number of places/2)
040B14             0170*  ; outputs: (hl) + (de) --> (hl)
040B14             0171*  ; destroys: a,b,de,hl
040B14             0172*  add_bcd:
040B14 47          0173*      ld b,a ; loop counter
040B15 AF          0174*      xor a ; reset a, clear carry flag
040B16             0175*  adcec:
040B16 1A          0176*      ld a,(de) ; addend to acc
040B17 8E          0177*      adc a,(hl) ; add (hl) to acc
040B18 27          0178*      daa ; adjust result to bcd
040B19 77          0179*      ld (hl),a ; store result
040B1A 23          0180*      inc hl ; advance memory pointers
040B1B 13          0181*      inc de
040B1C 10 F8       0182*      djnz adcec ; loop until b == 0
040B1E C9          0183*      ret
040B1F             0184*  
040B1F             0185*  ; BCD subtraction
040B1F             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B1F             0187*  ;       a is the number of bytes holding each number (number of places/2)
040B1F             0188*  ; outputs: (hl) - (de) --> (hl)
040B1F             0189*  ; destroys: a,b,de,hl
040B1F             0190*  sub_bcd:
040B1F 47          0191*      ld b,a ; loop counter
040B20 AF          0192*      xor a ; reset a,clear carry flag
040B21             0193*  subdec:
040B21 1A          0194*      ld a,(de) ; subtrahend to acc
040B22 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040B23 27          0196*      daa ; adjust result to bcd
040B24 77          0197*      ld (hl),a ; store result
040B25 23          0198*      inc hl ; advance memory pointers
040B26 13          0199*      inc de
040B27 10 F8       0200*      djnz subdec ; loop until b == 0
040B29 C9          0201*      ret
040B2A             0202*  
040B2A             0203*  ; http://www.z80.info/pseudo-random.txt
040B2A             0204*  rand_8:
040B2A C5          0205*      push bc
040B2B 3A 3E 0B 04 0206*      ld a,(r_seed)
040B2F 4F          0207*      ld c,a
040B30             0208*  
040B30 0F          0209*      rrca ; multiply by 32
040B31 0F          0210*      rrca
040B32 0F          0211*      rrca
040B33 EE 1F       0212*      xor 0x1f
040B35             0213*  
040B35 81          0214*      add a,c
040B36 DE FF       0215*      sbc a,255 ; carry
040B38             0216*  
040B38 32 3E 0B 04 0217*      ld (r_seed),a
040B3C C1          0218*      pop bc
040B3D C9          0219*      ret
040B3E 50          0220*  r_seed: defb $50
040B3F             0221*  
040B3F             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
040B3F             0223*  prng24:
040B3F             0224*  ;;Expects ADL mode.
040B3F             0225*  ;;Output: HL
040B3F             0226*  ;;50cc
040B3F             0227*  ;;33 bytes
040B3F             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
040B3F ED 5B 60 0B 0229*      ld de,(seed1)
       04          
040B44 B7          0230*      or a
040B45 ED 62       0231*      sbc hl,hl
040B47 19          0232*      add hl,de
040B48 29          0233*      add hl,hl
040B49 29          0234*      add hl,hl
040B4A 2C          0235*      inc l
040B4B 19          0236*      add hl,de
040B4C 22 60 0B 04 0237*      ld (seed1),hl
040B50 2A 63 0B 04 0238*      ld hl,(seed2)
040B54 29          0239*      add hl,hl
040B55 9F          0240*      sbc a,a
040B56 E6 1B       0241*      and %00011011
040B58 AD          0242*      xor l
040B59 6F          0243*      ld l,a
040B5A 22 63 0B 04 0244*      ld (seed2),hl
040B5E 19          0245*      add hl,de
040B5F C9          0246*      ret
040B60 00 00 00    0247*  seed1: dl 0
040B63 00 00 00    0248*  seed2: dl 0
040B66             0047   	include "trig24fast.inc"
040B66             0001*  
040B66             0002*  ; convert signed angles from a 360 to 256 degree circle
040B66             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B66             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B66             0005*  ; destroys: TODO
040B66             0006*  deg_360_to_256:
040B66 D5          0007*  	push de ; preserve de
040B67             0008*  ; make angle positive and store sign flag
040B67 CD 75 0A 04 0009*  	call hlu_abs
040B6B F5          0010*  	push af
040B6C             0011*  ; multiply by 256 first to keep precision
040B6C             0012*  	hlu_mul256 ; uh.l = uh.l * 256
040B6C 29          0001*M         add hl,hl ; * 2
040B6D 29          0002*M         add hl,hl ; * 4
040B6E 29          0003*M         add hl,hl ; * 8
040B6F 29          0004*M         add hl,hl ; * 16
040B70 29          0005*M         add hl,hl ; * 32
040B71 29          0006*M         add hl,hl ; * 64
040B72 29          0007*M         add hl,hl ; * 128
040B73 29          0008*M         add hl,hl ; * 256
040B74             0013*  ; divide uh.l by 360
040B74 11 68 01 00 0014*  	ld de,360
040B78 CD 60 15 04 0015*  	call udiv24 ; ud.e = degrees / 360
040B7C EB          0016*  	ex de,hl    ; uh.l = degrees / 360
040B7D             0017*  ; restore sign flag and adjust output accordingly
040B7D F1          0018*  	pop af
040B7E F2 86 0B 04 0019*  	jp p,@pos ; positive number
040B82 CD 85 0A 04 0020*  	call neg_hlu
040B86             0021*  @pos:
040B86             0022*  ; restore de and return uh.l as the result
040B86 D1          0023*  	pop de
040B87 C9          0024*  	ret
040B88             0025*  
040B88             0026*  ; fixed 16.8 routine
040B88             0027*  ; cos(uh.l) --> uh.l
040B88             0028*  ; destroys: f, hl
040B88             0029*  cos168:
040B88 D5          0030*      push de ; preserve de
040B89             0031*  ; for cos we simply increment the angle by 90 degrees
040B89             0032*  ; or 0x004000 in 16.8 degrees256
040B89             0033*  ; which makes it a sin problem
040B89 11 00 40 00 0034*      ld de,0x004000
040B8D 19          0035*      add hl,de ; modulo 256 happens below
040B8E D1          0036*      pop de ; restore de
040B8F             0037*  ; fall through to sin168
040B8F             0038*  
040B8F             0039*  ; ---------------------
040B8F             0040*  ; fixed 16.8 routine
040B8F             0041*  ; sin(uh.l) --> uh.l
040B8F             0042*  ; destroys: f, hl
040B8F             0043*  sin168:
040B8F D5          0044*  	push de
040B90             0045*  ; handle negative angles appropriately
040B90 CD 75 0A 04 0046*  	call hlu_abs
040B94 F2 9D 0B 04 0047*  	jp p,@F
040B98 11 00 00 FF 0048*  	ld de,-256*256
040B9C 19          0049*  	add hl,de
040B9D             0050*  @@:
040B9D 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
040B9F ED 6C       0052*      mlt hl
040BA1 11 D7 0D 04 0053*      ld de,sin_lut_168 ; grab the lut address
040BA5 19          0054*      add hl,de ; bump hl by the index
040BA6 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
040BA8 D1          0056*      pop de
040BA9 C9          0057*      ret
040BAA             0058*  
040BAA             0059*  ; 16.8 fixed inputs / outputs
040BAA             0060*  ; takes: uh.l as angle in degrees 256
040BAA             0061*  ;        ud.e as radius
040BAA             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BAA             0063*  ;        displacements from origin (0,0)
040BAA             0064*  ; destroys: everything except indexes
040BAA             0065*  polar_to_cartesian:
040BAA             0066*  ; back up input parameters
040BAA 22 D9 0B 04 0067*      ld (@angle), hl
040BAE ED 53 DC 0B 0068*      ld (@radius), de
       04          
040BB3             0069*  ; compute dx = sin(uh.l) * ud.e
040BB3 CD 8F 0B 04 0070*      call sin168 ; uh.l = sin(uh.l)
040BB7 ED 5B DC 0B 0071*  	ld de,(@radius)
       04          
040BBC CD D5 14 04 0072*  	call smul168 ; uh.l = dx
040BC0 E5          0073*      push hl
040BC1             0074*  ; compute dy = -cos(uh.l) * ud.e
040BC1 2A D9 0B 04 0075*      ld hl,(@angle)
040BC5 CD 88 0B 04 0076*      call cos168 ; uh.l = cos(uh.l)
040BC9 ED 5B DC 0B 0077*      ld de,(@radius)
       04          
040BCE CD D5 14 04 0078*      call smul168    ; uh.l = dy
040BD2 CD 85 0A 04 0079*      call neg_hlu ; invert dy for screen coords convention
040BD6 EB          0080*      ex de,hl       ; de = dy for output
040BD7 C1          0081*      pop bc          ; bc = dx for output
040BD8             0082*  ; and out
040BD8 C9          0083*      ret
040BD9             0084*  @angle: ds 3
040BDC             0085*  @radius: ds 3
040BDF             0086*  
040BDF             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BDF             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BDF             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BDF             0090*  ;         also populates scratch locations dx168 and dy168
040BDF             0091*  ; destroys: a,hl,bc,de
040BDF             0092*  dxy168:
040BDF             0093*  ; compute dx = x1-x0
040BDF AF          0094*      xor a ; clear carry
040BE0 DD E5       0095*      push ix ; move ix to hl via the stack
040BE2 E1          0096*      pop hl ; hl = x1
040BE3 ED 42       0097*      sbc hl,bc ; hl = dx
040BE5 22 FA 0B 04 0098*      ld (dx168),hl ; dx to scratch
040BE9             0099*  ; compute dy = y1-y0
040BE9 AF          0100*      xor a ; clear carry
040BEA FD E5       0101*      push iy ; move iy to hl via the stack
040BEC E1          0102*      pop hl ; hl = y1
040BED ED 52       0103*      sbc hl,de ; hl = dy
040BEF 22 00 0C 04 0104*      ld (dy168),hl ; dy to scratch
040BF3             0105*  ; populate output registers and return
040BF3 EB          0106*      ex de,hl        ; ud.e = dy
040BF4 ED 4B FA 0B 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
040BF9 C9          0108*      ret
040BFA 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
040C00 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
040C06             0111*  
040C06             0112*  ; compute the euclidian distance between two cartesian coordinates
040C06             0113*  ; using the formula d = sqrt(dx^2+dy^2
040C06             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C06             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C06             0116*  ; output; uh.l is the 16.8 fixed format distance
040C06             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
040C06             0118*  ; destroys: a,hl,bc,de
040C06             0119*  distance168:
040C06 CD DF 0B 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
040C0A             0121*  ; compute dy^2
040C0A EB          0122*  	ex de,hl
040C0B CD 75 0A 04 0123*  	call hlu_abs
040C0F E5          0124*  	push hl
040C10 D1          0125*  	pop de
040C11 CD CC 14 04 0126*  	call umul168 ; hl = dy^2
040C15 E5          0127*  	push hl ; save dy^2
040C16             0128*  ; compute dx^2
040C16 2A FA 0B 04 0129*  	ld hl,(dx168)
040C1A CD 75 0A 04 0130*  	call hlu_abs
040C1E E5          0131*  	push hl
040C1F D1          0132*  	pop de
040C20 CD CC 14 04 0133*  	call umul168 ; hl = dx^2
040C24             0134*  ; add dx^2 and dy^2
040C24 D1          0135*  	pop de ; de = dy^2
040C25 19          0136*  	add hl,de ; hl = dx^2 + dy^2
040C26             0137*  ; compute the square root
040C26 CD EC 0C 04 0138*  	call sqrt168
040C2A C9          0139*  	ret
040C2B             0140*  
040C2B             0141*  ; atan2_(ub.c,ud.e) --> uh.l
040C2B             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C2B             0143*  ;   whether inputs are integers or fractional doesn't matter
040C2B             0144*  ;   so long as the sign bit of the upper byte is correct
040C2B             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C2B             0146*  ; angles are COMPASS HEADINGS based on
040C2B             0147*  ; screen coordinate conventions,where the y axis is flipped
040C2B             0148*  ; #E0 315      0       45 #20
040C2B             0149*  ;        -x,-y | +x,-y
040C2B             0150*  ; #C0 270------+------ 90 #40
040C2B             0151*  ;        -x,+y | +x,+y
040C2B             0152*  ; #A0 225   180 #80   135 #60
040C2B             0153*  atan2_168fast:
040C2B             0154*  ; get signs and make everything positive
040C2B             0155*  ; get abs(x) and store its original sign
040C2B C5          0156*      push bc
040C2C E1          0157*      pop hl
040C2D CD 75 0A 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
040C31 E5          0159*      push hl ; store abs(x)
040C32 C1          0160*      pop bc ; bc = abs(x)
040C33 F5          0161*      push af ; store sign of x
040C34             0162*  ; get abs(y) and store its original sign
040C34 EB          0163*      ex de,hl ; hl = y
040C35 CD 75 0A 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
040C39 EB          0165*      ex de,hl ; de = abs(y)
040C3A F5          0166*      push af ; store sign of y
040C3B             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C3B             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C3B AF          0169*      xor a ; clear the carry flag
040C3C D5          0170*      push de
040C3D E1          0171*      pop hl
040C3E ED 42       0172*      sbc hl,bc
040C40 F5          0173*      push af ; save sign of de - bc
040C41 F2 4A 0C 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
040C45             0175*  ; otherwise we swap bc and de
040C45 C5          0176*      push bc
040C46 E1          0177*      pop hl
040C47 EB          0178*      ex de,hl
040C48 E5          0179*      push hl
040C49 C1          0180*      pop bc
040C4A             0181*  @1:
040C4A             0182*  ; now we're ready to snag our preliminary result
040C4A C5          0183*  	push bc
040C4B E1          0184*  	pop hl
040C4C CD BA 0C 04 0185*      call atan_168fast ; uh.l comes back with prelim result
040C50             0186*  ; now we adjust uh.l based on sign of de - bc
040C50 F1          0187*      pop af
040C51 F2 5D 0C 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
040C55 EB          0189*      ex de,hl
040C56 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
040C5A AF          0191*      xor a ; clear the carry flag
040C5B ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
040C5D             0193*  @2:
040C5D             0194*  ; now the fun part of adjusting the result
040C5D             0195*  ; based on which quadrant (x,y) is in
040C5D             0196*  ; #E0 315      0       45 #20
040C5D             0197*  ;        -x,-y | +x,-y
040C5D             0198*  ; #C0 270------+------ 90 #40
040C5D             0199*  ;        -x,+y | +x,+y
040C5D             0200*  ; #A0 225   180 #80   135 #60
040C5D F1          0201*      pop af ; sign of y
040C5E CA 9B 0C 04 0202*      jp z,@y_zero
040C62 F2 7B 0C 04 0203*      jp p,@y_pos
040C66             0204*  ; y neg,check x
040C66 F1          0205*      pop af ; sign of x
040C67 CA 75 0C 04 0206*      jp z,@y_neg_x_zero
040C6B F2 7A 0C 04 0207*      jp p,@y_neg_x_pos
040C6F             0208*  ; y neg,x neg
040C6F             0209*  ; angle is 270-360
040C6F             0210*  ; negating the intermediate does the trick
040C6F CD 85 0A 04 0211*      call neg_hlu
040C73 18 31       0212*      jr @zero_hlu
040C75             0213*  
040C75             0214*  @y_neg_x_zero:
040C75             0215*  ; y neg,x zero
040C75             0216*  ; angle is 0
040C75 21 00 00 00 0217*      ld hl,0
040C79 C9          0218*      ret
040C7A             0219*  @y_neg_x_pos:
040C7A             0220*  ; y neg,x pos
040C7A             0221*  ; angle is 0 to 90
040C7A             0222*  ; so we're good
040C7A C9          0223*      ret
040C7B             0224*  
040C7B             0225*  @y_pos:
040C7B F1          0226*      pop af ; sign of x
040C7C CA 8B 0C 04 0227*      jp z,@y_pos_x_zero
040C80 F2 90 0C 04 0228*      jp p,@y_pos_x_pos
040C84             0229*  ; y pos,x neg
040C84             0230*  ; angle is 180-270
040C84             0231*  ; so we add 180 to intermediate
040C84 11 00 80 00 0232*      ld de,0x008000
040C88 19          0233*      add hl,de
040C89 18 1B       0234*      jr @zero_hlu
040C8B             0235*  @y_pos_x_zero:
040C8B             0236*  ; y pos,x zero
040C8B             0237*  ; angle is 180
040C8B 21 00 80 00 0238*      ld hl,0x008000
040C8F C9          0239*      ret
040C90             0240*  @y_pos_x_pos:
040C90             0241*  ; y pos,x pos
040C90             0242*  ; angle is 90-180
040C90             0243*  ; neg the intermediate and add 180 degrees
040C90 CD 85 0A 04 0244*      call neg_hlu
040C94 11 00 80 00 0245*      ld de,0x008000
040C98 19          0246*      add hl,de
040C99 18 0B       0247*      jr @zero_hlu
040C9B             0248*  
040C9B             0249*  @y_zero:
040C9B F1          0250*      pop af ; sign of x
040C9C FA A1 0C 04 0251*      jp m,@y_zero_x_neg
040CA0             0252*  ; y zero,x pos
040CA0             0253*  ; angle is 90,nothing to do
040CA0 C9          0254*      ret
040CA1             0255*  @y_zero_x_neg:
040CA1             0256*  ; y zero ,x neg
040CA1             0257*  ; angle is 270
040CA1 21 00 C0 00 0258*      ld hl,0x00C000
040CA5 C9          0259*      ret
040CA6             0260*  @zero_hlu:
040CA6 AF          0261*      xor a
040CA7 22 B4 0C 04 0262*      ld (@scratch),hl
040CAB 32 B6 0C 04 0263*      ld (@scratch+2),a
040CAF 2A B4 0C 04 0264*      ld hl,(@scratch)
040CB3 C9          0265*      ret
040CB4             0266*  @scratch: ds 6
040CBA             0267*  
040CBA             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CBA             0269*  ; output: uh.l is the 16.8 fixed format angle
040CBA             0270*  ; destroys: a,hl,bc,de
040CBA             0271*  ; the following note was written by github copilot:
040CBA             0272*  ; note: this routine is a bit of a hack
040CBA             0273*  ;      but it works
040CBA             0274*  ;      and it's fast
040CBA             0275*  ;      and it's small
040CBA             0276*  ;      and it's accurate
040CBA             0277*  ;      and it's easy to understand
040CBA             0278*  ;      and it's easy to modify
040CBA             0279*  ;      and it's easy to use
040CBA             0280*  ;      and it's easy to remember
040CBA             0281*  ;      and it's easy to love
040CBA             0282*  ;      and it's easy to hate
040CBA             0283*  ;      and it's easy to ignore
040CBA             0284*  ;      and it's easy to forget
040CBA             0285*  ;      and it's easy to remember
040CBA             0286*  ;      and it's easy to forget
040CBA             0287*  ;      and it's easy to remember
040CBA             0288*  ;      (ok the bot is stuck in a loop)
040CBA             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
040CBA             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
040CBA             0291*  atan_168fast:
040CBA             0292*  ; because we use compass headings instead of geometric angles
040CBA             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040CBA             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
040CBA CD F8 14 04 0295*  	call udiv168 ; ud.e = dx/dy
040CBE EB          0296*  	ex de,hl ; uh.l = dx/dy
040CBF             0297*  ; test uh.l for 0
040CBF 19          0298*      add hl,de
040CC0 B7          0299*      or a
040CC1 ED 52       0300*      sbc hl,de
040CC3 28 22       0301*      jr z,@is_zero
040CC5             0302*  ; test uh.l for 1
040CC5 AF          0303*      xor a ; clear carry
040CC6 EB          0304*      ex de,hl
040CC7 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
040CCB ED 52       0306*      sbc hl,de
040CCD 28 13       0307*      jr z,@is_45
040CCF EB          0308*  	ex de,hl
040CD0             0309*  ; no special cases so we move on
040CD0             0310*  ; l contains the fractional portion of tan(uh.l)
040CD0             0311*  ; we multiply it by three to get our lookup table index
040CD0 26 03       0312*      ld h,3
040CD2 ED 6C       0313*      mlt hl ; gosh that is handy
040CD4 11 00 00 00 0314*      ld de,0 ; clear deu
040CD8 54          0315*      ld d,h ; copy hl to de
040CD9 5D          0316*      ld e,l ; de contains our index
040CDA 21 DA 10 04 0317*      ld hl,atan_lut_168 ; grab the lut address
040CDE 19          0318*      add hl,de ; bump hl by the index
040CDF ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
040CE1 C9          0320*      ret ; and out
040CE2             0321*  @is_45:
040CE2 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
040CE6 C9          0323*      ret
040CE7             0324*  ; for the case tan(0)
040CE7             0325*  @is_zero:
040CE7 21 00 00 00 0326*      ld hl,0x000000
040CEB C9          0327*      ret
040CEC             0328*  
040CEC             0329*  ; Expects  ADL mode
040CEC             0330*  ; Inputs:  UH.L
040CEC             0331*  ; Outputs: UH.L is the 16.8 square root
040CEC             0332*  ;          UD.E is the difference inputHL-DE^2
040CEC             0333*  ;          c flag reset
040CEC             0334*  sqrt168:
040CEC CD F6 0C 04 0335*      call sqrt24
040CF0 EB          0336*      ex de,hl
040CF1 29          0337*      add hl,hl
040CF2 29          0338*      add hl,hl
040CF3 29          0339*      add hl,hl
040CF4 29          0340*      add hl,hl
040CF5 C9          0341*      ret
040CF6             0342*  
040CF6             0343*  ; Expects  ADL mode
040CF6             0344*  ; Inputs:  HL
040CF6             0345*  ; Outputs: DE is the integer square root
040CF6             0346*  ;          HL is the difference inputHL-DE^2
040CF6             0347*  ;          c flag reset
040CF6             0348*  sqrt24:
040CF6 AF          0349*      xor a
040CF7 45          0350*      ld b,l
040CF8 C5          0351*      push bc
040CF9 47          0352*      ld b,a
040CFA 57          0353*      ld d,a
040CFB 4F          0354*      ld c,a
040CFC 6F          0355*      ld l,a
040CFD 5F          0356*      ld e,a
040CFE             0357*  
040CFE             0358*      ;Iteration 1
040CFE 29          0359*      add hl,hl
040CFF CB 11       0360*      rl c
040D01 29          0361*      add hl,hl
040D02 CB 11       0362*      rl c
040D04 91          0363*      sub c
040D05 30 04       0364*      jr nc,$+6
040D07 1C          0365*      inc e
040D08 1C          0366*      inc e
040D09 2F          0367*      cpl
040D0A 4F          0368*      ld c,a
040D0B             0369*  
040D0B             0370*      ;Iteration 2
040D0B 29          0371*      add hl,hl
040D0C CB 11       0372*      rl c
040D0E 29          0373*      add hl,hl
040D0F CB 11       0374*      rl c
040D11 CB 13       0375*      rl e
040D13 7B          0376*      ld a,e
040D14 91          0377*      sub c
040D15 30 04       0378*      jr nc,$+6
040D17 1C          0379*      inc e
040D18 1C          0380*      inc e
040D19 2F          0381*      cpl
040D1A 4F          0382*      ld c,a
040D1B             0383*  
040D1B             0384*      ;Iteration 3
040D1B 29          0385*      add hl,hl
040D1C CB 11       0386*      rl c
040D1E 29          0387*      add hl,hl
040D1F CB 11       0388*      rl c
040D21 CB 13       0389*      rl e
040D23 7B          0390*      ld a,e
040D24 91          0391*      sub c
040D25 30 04       0392*      jr nc,$+6
040D27 1C          0393*      inc e
040D28 1C          0394*      inc e
040D29 2F          0395*      cpl
040D2A 4F          0396*      ld c,a
040D2B             0397*  
040D2B             0398*      ;Iteration 4
040D2B 29          0399*      add hl,hl
040D2C CB 11       0400*      rl c
040D2E 29          0401*      add hl,hl
040D2F CB 11       0402*      rl c
040D31 CB 13       0403*      rl e
040D33 7B          0404*      ld a,e
040D34 91          0405*      sub c
040D35 30 04       0406*      jr nc,$+6
040D37 1C          0407*      inc e
040D38 1C          0408*      inc e
040D39 2F          0409*      cpl
040D3A 4F          0410*      ld c,a
040D3B             0411*  
040D3B             0412*      ;Iteration 5
040D3B 29          0413*      add hl,hl
040D3C CB 11       0414*      rl c
040D3E 29          0415*      add hl,hl
040D3F CB 11       0416*      rl c
040D41 CB 13       0417*      rl e
040D43 7B          0418*      ld a,e
040D44 91          0419*      sub c
040D45 30 04       0420*      jr nc,$+6
040D47 1C          0421*      inc e
040D48 1C          0422*      inc e
040D49 2F          0423*      cpl
040D4A 4F          0424*      ld c,a
040D4B             0425*  
040D4B             0426*      ;Iteration 6
040D4B 29          0427*      add hl,hl
040D4C CB 11       0428*      rl c
040D4E 29          0429*      add hl,hl
040D4F CB 11       0430*      rl c
040D51 CB 13       0431*      rl e
040D53 7B          0432*      ld a,e
040D54 91          0433*      sub c
040D55 30 04       0434*      jr nc,$+6
040D57 1C          0435*      inc e
040D58 1C          0436*      inc e
040D59 2F          0437*      cpl
040D5A 4F          0438*      ld c,a
040D5B             0439*  
040D5B             0440*      ;Iteration 7
040D5B 29          0441*      add hl,hl
040D5C CB 11       0442*      rl c
040D5E 29          0443*      add hl,hl
040D5F CB 11       0444*      rl c
040D61 CB 10       0445*      rl b
040D63 EB          0446*      ex de,hl
040D64 29          0447*      add hl,hl
040D65 E5          0448*      push hl
040D66 ED 42       0449*      sbc hl,bc
040D68 30 06       0450*      jr nc,$+8
040D6A 7C          0451*      ld a,h
040D6B 2F          0452*      cpl
040D6C 47          0453*      ld b,a
040D6D 7D          0454*      ld a,l
040D6E 2F          0455*      cpl
040D6F 4F          0456*      ld c,a
040D70 E1          0457*      pop hl
040D71 30 02       0458*      jr nc,$+4
040D73 23          0459*      inc hl
040D74 23          0460*      inc hl
040D75 EB          0461*      ex de,hl
040D76             0462*  
040D76             0463*      ;Iteration 8
040D76 29          0464*      add hl,hl
040D77 69          0465*      ld l,c
040D78 60          0466*      ld h,b
040D79 ED 6A       0467*      adc hl,hl
040D7B ED 6A       0468*      adc hl,hl
040D7D EB          0469*      ex de,hl
040D7E 29          0470*      add hl,hl
040D7F ED 52       0471*      sbc hl,de
040D81 19          0472*      add hl,de
040D82 EB          0473*      ex de,hl
040D83 30 04       0474*      jr nc,$+6
040D85 ED 52       0475*      sbc hl,de
040D87 13          0476*      inc de
040D88 13          0477*      inc de
040D89             0478*  
040D89             0479*      ;Iteration 9
040D89 F1          0480*      pop af
040D8A 17          0481*      rla
040D8B ED 6A       0482*      adc hl,hl
040D8D 17          0483*      rla
040D8E ED 6A       0484*      adc hl,hl
040D90 EB          0485*      ex de,hl
040D91 29          0486*      add hl,hl
040D92 ED 52       0487*      sbc hl,de
040D94 19          0488*      add hl,de
040D95 EB          0489*      ex de,hl
040D96 30 04       0490*      jr nc,$+6
040D98 ED 52       0491*      sbc hl,de
040D9A 13          0492*      inc de
040D9B 13          0493*      inc de
040D9C             0494*  
040D9C             0495*      ;Iteration 10
040D9C 17          0496*      rla
040D9D ED 6A       0497*      adc hl,hl
040D9F 17          0498*      rla
040DA0 ED 6A       0499*      adc hl,hl
040DA2 EB          0500*      ex de,hl
040DA3 29          0501*      add hl,hl
040DA4 ED 52       0502*      sbc hl,de
040DA6 19          0503*      add hl,de
040DA7 EB          0504*      ex de,hl
040DA8 30 04       0505*      jr nc,$+6
040DAA ED 52       0506*      sbc hl,de
040DAC 13          0507*      inc de
040DAD 13          0508*      inc de
040DAE             0509*  
040DAE             0510*      ;Iteration 11
040DAE 17          0511*      rla
040DAF ED 6A       0512*      adc hl,hl
040DB1 17          0513*      rla
040DB2 ED 6A       0514*      adc hl,hl
040DB4 EB          0515*      ex de,hl
040DB5 29          0516*      add hl,hl
040DB6 ED 52       0517*      sbc hl,de
040DB8 19          0518*      add hl,de
040DB9 EB          0519*      ex de,hl
040DBA 30 04       0520*      jr nc,$+6
040DBC ED 52       0521*      sbc hl,de
040DBE 13          0522*      inc de
040DBF 13          0523*      inc de
040DC0             0524*  
040DC0             0525*      ;Iteration 11
040DC0 17          0526*      rla
040DC1 ED 6A       0527*      adc hl,hl
040DC3 17          0528*      rla
040DC4 ED 6A       0529*      adc hl,hl
040DC6 EB          0530*      ex de,hl
040DC7 29          0531*      add hl,hl
040DC8 ED 52       0532*      sbc hl,de
040DCA 19          0533*      add hl,de
040DCB EB          0534*      ex de,hl
040DCC 30 04       0535*      jr nc,$+6
040DCE ED 52       0536*      sbc hl,de
040DD0 13          0537*      inc de
040DD1 13          0538*      inc de
040DD2             0539*  
040DD2 CB 1A       0540*      rr d
040DD4 CB 1B       0541*      rr e
040DD6 C9          0542*      ret
040DD7             0543*  
040DD7             0544*  sin_lut_168:
040DD7 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
040DDA 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
040DDD 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
040DE0 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
040DE3 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
040DE6 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
040DE9 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
040DEC 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
040DEF 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
040DF2 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
040DF5 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
040DF8 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
040DFB 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
040DFE 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
040E01 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
040E04 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
040E07 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
040E0A 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
040E0D 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
040E10 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
040E13 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
040E16 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
040E19 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
040E1C 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
040E1F 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
040E22 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
040E25 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
040E28 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
040E2B A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
040E2E A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
040E31 AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
040E34 B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
040E37 B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
040E3A B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
040E3D BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
040E40 C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
040E43 C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
040E46 C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
040E49 CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
040E4C D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
040E4F D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
040E52 D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
040E55 DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
040E58 DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
040E5B E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
040E5E E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
040E61 E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
040E64 EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
040E67 EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
040E6A EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
040E6D F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
040E70 F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
040E73 F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
040E76 F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
040E79 F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
040E7C F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
040E7F FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
040E82 FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
040E85 FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
040E88 FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
040E8B FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
040E8E FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
040E91 FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
040E94 FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
040E97 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
040E9A FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
040E9D FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
040EA0 FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
040EA3 FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
040EA6 FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
040EA9 FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
040EAC FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
040EAF FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
040EB2 F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
040EB5 F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
040EB8 F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
040EBB F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
040EBE F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
040EC1 F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
040EC4 EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
040EC7 EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
040ECA EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
040ECD E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
040ED0 E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
040ED3 E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
040ED6 DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
040ED9 DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
040EDC D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
040EDF D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
040EE2 D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
040EE5 CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
040EE8 C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
040EEB C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
040EEE C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
040EF1 BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
040EF4 B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
040EF7 B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
040EFA B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
040EFD AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
040F00 A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
040F03 A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
040F06 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
040F09 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
040F0C 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
040F0F 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
040F12 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
040F15 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
040F18 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
040F1B 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
040F1E 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
040F21 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
040F24 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
040F27 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
040F2A 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
040F2D 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
040F30 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
040F33 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
040F36 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
040F39 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
040F3C 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
040F3F 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
040F42 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
040F45 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
040F48 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
040F4B 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
040F4E 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
040F51 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
040F54 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
040F57 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
040F5A FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
040F5D F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
040F60 EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
040F63 E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040F66 E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040F69 DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
040F6C D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
040F6F CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
040F72 C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040F75 C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040F78 BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040F7B B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040F7E B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
040F81 AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
040F84 A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040F87 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
040F8A 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
040F8D 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
040F90 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
040F93 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
040F96 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
040F99 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
040F9C 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
040F9F 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
040FA2 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
040FA5 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040FA8 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040FAB 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
040FAE 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
040FB1 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
040FB4 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040FB7 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040FBA 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040FBD 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
040FC0 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
040FC3 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
040FC6 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
040FC9 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
040FCC 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
040FCF 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
040FD2 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
040FD5 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
040FD8 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
040FDB 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
040FDE 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
040FE1 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
040FE4 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
040FE7 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
040FEA 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
040FED 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
040FF0 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
040FF3 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
040FF6 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
040FF9 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
040FFC 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
040FFF 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
041002 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
041005 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
041008 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
04100B 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
04100E 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
041011 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
041014 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
041017 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
04101A 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
04101D 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
041020 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
041023 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
041026 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
041029 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
04102C 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04102F 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
041032 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
041035 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
041038 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
04103B 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
04103E 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
041041 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
041044 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
041047 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
04104A 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
04104D 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
041050 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
041053 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
041056 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
041059 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
04105C 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04105F 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
041062 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
041065 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
041068 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
04106B 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
04106E 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
041071 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
041074 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
041077 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
04107A 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
04107D 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
041080 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
041083 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
041086 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041089 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
04108C 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04108F 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
041092 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
041095 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041098 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
04109B 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
04109E 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0410A1 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0410A4 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0410A7 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0410AA A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0410AD AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0410B0 B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0410B3 B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0410B6 BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0410B9 C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0410BC C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0410BF CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0410C2 D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0410C5 DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0410C8 E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0410CB E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0410CE EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0410D1 F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0410D4 FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0410D7 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0410DA             0802*  
0410DA             0803*  atan_lut_168:
0410DA 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
0410DD 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
0410E0 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
0410E3 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
0410E6 A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
0410E9 CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
0410EC F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
0410EF 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
0410F2 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
0410F5 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
0410F8 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
0410FB BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
0410FE E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
041101 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
041104 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
041107 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
04110A 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
04110D B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
041110 DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
041113 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
041116 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
041119 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
04111C 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
04111F A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
041122 CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
041125 F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
041128 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
04112B 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
04112E 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
041131 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
041134 C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
041137 E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
04113A 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
04113D 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
041140 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
041143 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
041146 B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
041149 D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
04114C 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
04114F 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
041152 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
041155 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
041158 A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
04115B C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
04115E EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
041161 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
041164 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
041167 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
04116A 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
04116D B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
041170 DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
041173 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
041176 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
041179 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
04117C 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
04117F 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
041182 C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
041185 ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
041188 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
04118B 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
04118E 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
041191 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
041194 AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
041197 D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
04119A FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
04119D 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
0411A0 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
0411A3 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
0411A6 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
0411A9 BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
0411AC E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
0411AF 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
0411B2 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
0411B5 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
0411B8 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
0411BB 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
0411BE C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
0411C1 E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
0411C4 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
0411C7 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
0411CA 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
0411CD 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
0411D0 A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
0411D3 C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
0411D6 EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
0411D9 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
0411DC 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
0411DF 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
0411E2 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
0411E5 A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
0411E8 C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
0411EB EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
0411EE 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
0411F1 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
0411F4 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
0411F7 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
0411FA 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
0411FD C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
041200 E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
041203 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
041206 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
041209 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
04120C 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
04120F 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
041212 B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
041215 DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
041218 FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
04121B 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
04121E 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
041221 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
041224 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
041227 AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
04122A CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
04122D EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
041230 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
041233 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
041236 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
041239 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
04123C 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
04123F BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
041242 DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
041245 FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
041248 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
04124B 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
04124E 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
041251 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
041254 A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
041257 C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
04125A E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
04125D 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
041260 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
041263 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
041266 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
041269 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
04126C A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
04126F C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
041272 E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
041275 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
041278 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
04127B 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
04127E 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
041281 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
041284 A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
041287 C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
04128A E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
04128D FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
041290 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
041293 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
041296 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
041299 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
04129C 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
04129F B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
0412A2 D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
0412A5 F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
0412A8 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
0412AB 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
0412AE 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
0412B1 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
0412B4 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
0412B7 A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
0412BA C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
0412BD DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
0412C0 FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
0412C3 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
0412C6 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
0412C9 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
0412CC 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
0412CF 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
0412D2 A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
0412D5 C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
0412D8 E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
0412DB FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
0412DE 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
0412E1 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
0412E4 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
0412E7 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
0412EA 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
0412ED A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
0412F0 C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
0412F3 DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
0412F6 F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
0412F9 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
0412FC 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
0412FF 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
041302 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
041305 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
041308 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
04130B B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
04130E CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
041311 E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
041314 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
041317 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
04131A 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
04131D 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
041320 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
041323 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
041326 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
041329 B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
04132C D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
04132F EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
041332 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
041335 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
041338 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
04133B 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
04133E 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
041341 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
041344 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
041347 B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
04134A CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
04134D E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
041350 FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
041353 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
041356 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
041359 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
04135C 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
04135F 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
041362 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
041365 A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
041368 BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
04136B D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
04136E EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
041371 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
041374 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
041377 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
04137A 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
04137D 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
041380 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
041383 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
041386 A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
041389 BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
04138C D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
04138F E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
041392 FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
041395 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
041398 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
04139B 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
04139E 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
0413A1 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
0413A4 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
0413A7 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
0413AA AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
0413AD C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
0413B0 DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
0413B3 F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
0413B6 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
0413B9 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
0413BC 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
0413BF 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
0413C2 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
0413C5 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
0413C8 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
0413CB 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
0413CE AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
0413D1 C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
0413D4 D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
0413D7 EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
0413DA 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0413DD             0048   	include "fixed24.inc"
0413DD             0001*  arith24uaf: ds 6
0413E3             0002*  arith24uhl: ds 6
0413E9             0003*  arith24ubc: ds 6
0413EF             0004*  arith24ude: ds 6
0413F5             0005*  arith24uix: ds 6
0413FB             0006*  arith24uiy: ds 6
041401             0007*  arith24usp: ds 6
041407             0008*  arith24upc: ds 6
04140D             0009*  
04140D             0010*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
04140D             0011*  ; uses EZ80 MLT instruction for speed
04140D             0012*  ; operation: UHL * A --> UHL
04140D             0013*  ; destroys: AF, HL
04140D             0014*  smul24x8:
04140D             0015*  ; make hl positive and store sign flag
04140D CD 75 0A 04 0016*  	call hlu_abs
041411 F5          0017*  	push af
041412             0018*  ; do the division
041412 CD 1D 14 04 0019*      call umul24x8 ; hl = product
041416             0020*  ; adjust sign of result
041416 F1          0021*  	pop af ; sign de
041417 F0          0022*  	ret p ; hl was positive, nothing to do
041418 CD 85 0A 04 0023*  	call neg_hlu ; result is negative
04141C C9          0024*  	ret
04141D             0025*  
04141D             0026*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
04141D             0027*  ; uses EZ80 MLT instruction for speed
04141D             0028*  ; operation: UHL * A --> AUHL
04141D             0029*  ; destroys: AF, HL
04141D             0030*  umul24x8:
04141D D5          0031*  	push de ; preserve de
04141E             0032*  ; low byte
04141E 5D          0033*  	ld e,l
04141F 57          0034*  	ld d,a
041420 ED 5C       0035*  	mlt de
041422 6B          0036*  	ld l,e ; product low byte
041423 08          0037*  	ex af,af' ; save multiplier
041424 7A          0038*  	ld a,d ; carry
041425 08          0039*  	ex af,af' ; save carry, restore multiplier
041426             0040*  ; high byte
041426 5C          0041*  	ld e,h
041427 57          0042*  	ld d,a
041428 ED 5C       0043*  	mlt de
04142A 08          0044*  	ex af,af' ; save multiplier, restore carry
04142B 83          0045*  	add a,e ; add carry
04142C 67          0046*  	ld h,a ; product middle byte
04142D 7A          0047*  	ld a,d ; carry
04142E 08          0048*  	ex af,af' ; save carry, restore multiplier
04142F             0049*  ; upper byte
04142F 22 4A 14 04 0050*      ld (@scratch),hl ; 7 cycles
041433 5F          0051*  	ld e,a
041434 3A 4C 14 04 0052*  	ld a,(@scratch+2)
041438 57          0053*  	ld d,a
041439 ED 5C       0054*  	mlt de
04143B 08          0055*  	ex af,af' ; restore carry
04143C 8B          0056*  	adc a,e ; add carry
04143D 32 4C 14 04 0057*      ld (@scratch+2),a ; 5 cycles
041441 2A 4A 14 04 0058*      ld hl,(@scratch) ; 7 cycles
041445             0059*  ; highest byte
041445 3E 00       0060*  	ld a,0 ; preserve carry flag
041447 8A          0061*  	adc a,d ; product highest byte
041448 D1          0062*  	pop de ; restore de
041449 C9          0063*  	ret
04144A             0064*  @scratch: ds 3
04144D             0065*  
04144D 00 00 00    0066*      dl 0 ; padding
041450 00 00 00 00 0067*  umul24x24out: blkb 6,0
       00 00       
041456 00 00 00    0068*      dl 0 ; padding
041459             0069*  
041459             0070*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
041459             0071*  ; operation: UHL * UDE --> umul24x24out
041459             0072*  umul24x24:
041459 DD 22 C3 14 0073*  	ld (@ix),ix ; preserve
       04          
04145E             0074*  	; push ix ; preserve
04145E             0075*  
04145E DD 21 50 14 0076*  	ld ix,umul24x24out ; point to output buffer
       04          
041463 C5          0077*  	push bc
041464 01 00 00 00 0078*  	ld bc,0
041468 DD 0F 00    0079*  	ld (ix),bc
04146B DD 0F 03    0080*  	ld (ix+3),bc
04146E C1          0081*  	pop bc
04146F             0082*  
04146F             0083*  ; STEP 1: UHL * E
04146F 7B          0084*  	ld a,e
041470 E5          0085*  	push hl
041471 CD 1D 14 04 0086*  	call umul24x8
041475 DD 2F 00    0087*  	ld (ix+0),hl
041478 DD 77 03    0088*  	ld (ix+3),a
04147B             0089*  
04147B             0090*  ; STEP 2: UHL * D
04147B E1          0091*  	pop hl
04147C E5          0092*  	push hl
04147D 7A          0093*  	ld a,d
04147E CD 1D 14 04 0094*  	call umul24x8
041482 CD 94 14 04 0095*  	call @accumulate
041486             0096*  
041486             0097*  ; STEP 3: UHL * DEU
041486 E1          0098*  	pop hl
041487             0099*  	; push de
041487             0100*  	; inc sp
041487             0101*  	; pop af
041487             0102*  	; dec sp
041487 ED 53 C9 14 0103*  	ld (@de),de
       04          
04148C 3A CB 14 04 0104*  	ld a,(@de+2)
041490 CD 1D 14 04 0105*  	call umul24x8
041494             0106*  
041494             0107*  @accumulate:
041494 DD 23       0108*  	inc ix
041496             0109*  ; highest byte of product to carry
041496 DD 77 03    0110*  	ld (ix+3),a
041499             0111*  ; low byte of product
041499 7D          0112*  	ld a,l
04149A DD 86 00    0113*  	add a,(ix+0)
04149D DD 77 00    0114*  	ld (ix+0),a
0414A0             0115*  ; high byte of product
0414A0 7C          0116*  	ld a,h
0414A1 DD 8E 01    0117*  	adc a,(ix+1)
0414A4 DD 77 01    0118*  	ld (ix+1),a
0414A7             0119*  ; uppper byte of product
0414A7             0120*  	; push hl ; 4 cc
0414A7             0121*  	; inc sp ; 1 cc
0414A7             0122*  	; pop hl ; 4 cc
0414A7             0123*  	; dec sp ; 1 cc
0414A7             0124*  	; ld a,h ; 1 cc
0414A7 22 C6 14 04 0125*  	ld (@hl),hl ; 7 cc
0414AB 3A C8 14 04 0126*  	ld a,(@hl+2) ; 5 cc
0414AF DD 8E 02    0127*  	adc a,(ix+2)
0414B2 DD 77 02    0128*  	ld (ix+2),a
0414B5             0129*  ; carry
0414B5 3E 00       0130*  	ld a,0 ; preserve flags
0414B7 DD 8E 03    0131*  	adc a,(ix+3)
0414BA DD 77 03    0132*  	ld (ix+3),a
0414BD             0133*  
0414BD DD 2A C3 14 0134*  	ld ix,(@ix) ; restore
       04          
0414C2             0135*  	; pop ix
0414C2 C9          0136*  	ret
0414C3             0137*  
0414C3 00 00 00    0138*  @ix: dl 0
0414C6 00 00 00    0139*  @hl: dl 0
0414C9 00 00 00    0140*  @de: dl 0
0414CC             0141*  
0414CC             0142*  ; UH.L = UH.L*UD.E (unsigned)
0414CC             0143*  umul168:
0414CC CD 59 14 04 0144*  	call umul24x24
0414D0 2A 51 14 04 0145*  	ld hl,(umul24x24out+1)
0414D4 C9          0146*  	ret
0414D5             0147*  
0414D5             0148*  ; UH.L * UD.E --> UH.L (signed)
0414D5             0149*  smul168:
0414D5             0150*  ; make everything positive and store sign flags
0414D5 CD 75 0A 04 0151*  	call hlu_abs
0414D9 F5          0152*  	push af
0414DA EB          0153*  	ex de,hl
0414DB CD 75 0A 04 0154*  	call hlu_abs
0414DF EB          0155*  	ex de,hl
0414E0 F5          0156*  	push af
0414E1             0157*  ; do the division
0414E1 CD CC 14 04 0158*      call umul168 ; hl = product
0414E5             0159*  ; adjust sign of result
0414E5 F1          0160*  	pop af ; sign de
0414E6 FA F1 14 04 0161*  	jp m,@de_neg
0414EA F1          0162*  	pop af ; sign hl
0414EB F0          0163*  	ret p ; both positive, nothing to do
0414EC             0164*  @hl_neg:
0414EC CD 85 0A 04 0165*      call neg_hlu ; de pos, hl neg, result is negative
0414F0 C9          0166*      ret
0414F1             0167*  @de_neg:
0414F1 F1          0168*  	pop af
0414F2 F8          0169*  	ret m ; both negative, nothing to do
0414F3 CD 85 0A 04 0170*  	call neg_hlu ; result is negative
0414F7 C9          0171*  	ret
0414F8             0172*  
0414F8             0173*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0414F8             0174*  ; perform unsigned division of 16.8 fixed place values
0414F8             0175*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0414F8             0176*  udiv168:
0414F8             0177*  ; back up divisor
0414F8 ED 53 2F 15 0178*  	ld (@ude),de
       04          
0414FD             0179*  ; get the 16-bit integer part of the quotient
0414FD CD 60 15 04 0180*      call udiv24 ; de = quotient, hl = remainder
041501             0181*  ; load quotient to upper three bytes of output
041501 ED 53 36 15 0182*      ld (div168_out+1),de
       04          
041506             0183*  @div256:
041506             0184*  ; multiply remainder by 256
041506             0185*  	hlu_mul256
041506 29          0001*M         add hl,hl ; * 2
041507 29          0002*M         add hl,hl ; * 4
041508 29          0003*M         add hl,hl ; * 8
041509 29          0004*M         add hl,hl ; * 16
04150A 29          0005*M         add hl,hl ; * 32
04150B 29          0006*M         add hl,hl ; * 64
04150C 29          0007*M         add hl,hl ; * 128
04150D 29          0008*M         add hl,hl ; * 256
04150E             0186*  ; skip fractional computation if remainder is zero
04150E             0187*      sign_hlu
04150E 19          0001*M         add hl,de
04150F B7          0002*M         or a
041510 ED 52       0003*M         sbc hl,de
041512 20 03       0188*      jr nz,@div_frac
041514 AF          0189*      xor a
041515 18 0A       0190*      jr @write_frac
041517             0191*  ; now divide the shifted remainder by the divisor
041517             0192*  @div_frac:
041517 ED 5B 2F 15 0193*  	ld de,(@ude) ; get back divisor
       04          
04151C CD 60 15 04 0194*      call udiv24 ; de = quotient, hl = remainder
041520             0195*  ; load low byte of quotient to low byte of output
041520 7B          0196*      ld a,e
041521             0197*  @write_frac:
041521 32 35 15 04 0198*      ld (div168_out),a
041525             0199*  ; load de with return value
041525 ED 5B 35 15 0200*      ld de,(div168_out)
       04          
04152A             0201*  ; load a with any overflow
04152A 3A 38 15 04 0202*      ld a,(div168_out+3)
04152E C9          0203*      ret ; ud.e is the 16.8 result
04152F             0204*  @ude: ds 6
041535             0205*  div168_out: ds 4 ; the extra byte is for overflow
041539             0206*  
041539             0207*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
041539             0208*  ; perform signed division of 16.8 fixed place values
041539             0209*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
041539             0210*  sdiv168:
041539             0211*  ; make everything positive and store sign flags
041539 CD 75 0A 04 0212*  	call hlu_abs
04153D F5          0213*  	push af
04153E EB          0214*  	ex de,hl
04153F CD 75 0A 04 0215*  	call hlu_abs
041543 EB          0216*  	ex de,hl
041544 F5          0217*  	push af
041545             0218*  ; do the division
041545 CD F8 14 04 0219*      call udiv168 ; de = quotient, hl = remainder
041549             0220*  ; adjust sign of result
041549 F1          0221*  	pop af ; sign de
04154A FA 57 15 04 0222*  	jp m,@de_neg
04154E F1          0223*  	pop af ; sign hl
04154F F0          0224*  	ret p ; both positive, nothing to do
041550             0225*  @hl_neg:
041550 EB          0226*      ex de,hl ; hl = quotient, de = remainder
041551 CD 85 0A 04 0227*      call neg_hlu ; de pos, hl neg, result is negative
041555 EB          0228*      ex de,hl ; de = negated quotient, hl = remainder
041556 C9          0229*      ret
041557             0230*  @de_neg:
041557 F1          0231*  	pop af
041558 F8          0232*  	ret m ; both negative, nothing to do
041559 EB          0233*      ex de,hl ; hl = quotient, de = remainder
04155A CD 85 0A 04 0234*  	call neg_hlu ; result is negative
04155E EB          0235*      ex de,hl ; de = negated quotient, hl = remainder
04155F C9          0236*  	ret
041560             0237*  
041560             0238*  ;------------------------------------------------------------------------
041560             0239*  ;  arith24.asm
041560             0240*  ;  24-bit ez80 arithmetic routines
041560             0241*  ;  Copyright (c) Shawn Sijnstra 2024
041560             0242*  ;  MIT license
041560             0243*  ;
041560             0244*  ;  This library was created as a tool to help make ez80
041560             0245*  ;  24-bit native assembly routines for simple mathematical problems
041560             0246*  ;  more widely available.
041560             0247*  ;
041560             0248*  ;------------------------------------------------------------------------
041560             0249*  ;
041560             0250*  ;------------------------------------------------------------------------
041560             0251*  ; udiv24
041560             0252*  ; Unsigned 24-bit division
041560             0253*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
041560             0254*  ;
041560             0255*  ; Uses AF BC DE HL
041560             0256*  ; Uses Restoring Division algorithm
041560             0257*  ;------------------------------------------------------------------------
041560             0258*  
041560             0259*  udiv24:
041560 E5          0260*  	push	hl
041561 C1          0261*  	pop		bc	;move dividend to BCU
041562 21 00 00 00 0262*  	ld		hl,0	;result
041566 A7          0263*  	and		a
041567 ED 52       0264*  	sbc		hl,de	;test for div by 0
041569 C8          0265*  	ret		z		;it's zero, carry flag is clear
04156A 19          0266*  	add		hl,de	;HL is 0 again
04156B 3E 18       0267*  	ld		a,24	;number of loops through.
04156D             0268*  udiv1:
04156D C5          0269*  	push	bc	;complicated way of doing this because of lack of access to top bits
04156E E3          0270*  	ex		(sp),hl
04156F 37          0271*  	scf
041570 ED 6A       0272*  	adc	hl,hl
041572 E3          0273*  	ex	(sp),hl
041573 C1          0274*  	pop	bc		;we now have bc = (bc * 2) + 1
041574             0275*  
041574 ED 6A       0276*  	adc	hl,hl
041576 A7          0277*  	and	a		;is this the bug
041577 ED 52       0278*  	sbc	hl,de
041579 30 02       0279*  	jr	nc,udiv2
04157B 19          0280*  	add	hl,de
04157C             0281*  ;	dec	c
04157C 0B          0282*  	dec	bc
04157D             0283*  udiv2:
04157D 3D          0284*  	dec	a
04157E 20 ED       0285*  	jr	nz,udiv1
041580 37          0286*  	scf		;flag used for div0 error
041581 C5          0287*  	push	bc
041582 D1          0288*  	pop		de	;remainder
041583 C9          0289*  	ret
041584             0049   	include "files.inc"
041584             0001*  ; load to onboard 8k sram
041584             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
041584             0050       include "timer.inc"
041584             0001*  ; Table 32. Timer Control Registers
041584             0002*  ; this constant is the base address of the timer control registers
041584             0003*  ; each timer takes three bytes:
041584             0004*  ;   0: control register
041584             0005*  ;   1: low byte of timer reset value
041584             0006*  ;   2: high byte of timer reset value
041584             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041584             0008*  ; which correctly force the high and upper bytes of the address bus to zero
041584             0009*  TMR_CTL:     equ 80h
041584             0010*  
041584             0011*  ; Timer Control Register Bit Definitions
041584             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041584             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
041584             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041584             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
041584             0016*                              ; the TMRx_CTL register is read.
041584             0017*  
041584             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041584             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041584             0020*  
041584             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041584             0022*                              ;  0,and counting stops when the end-of-count value is reached.
041584             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041584             0024*                              ; written to the counter when the end-of-count value is reached.
041584             0025*  
041584             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041584             0027*  CLK_DIV_256:  equ %00001100 ;
041584             0028*  CLK_DIV_64:   equ %00001000 ;
041584             0029*  CLK_DIV_16:   equ %00000100 ;
041584             0030*  CLK_DIV_4:    equ %00000000 ;
041584             0031*  
041584             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041584             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041584             0034*                              ; When a 1 is written to this bit,the values in the reload registers
041584             0035*                              ;  are loaded into the downcounter when the timer restarts. The
041584             0036*                              ; programmer must ensure that this bit is set to 1 each time
041584             0037*                              ; SINGLE-PASS mode is used.
041584             0038*  
041584             0039*  ; disable/enable the programmable reload timer
041584             0040*  PRT_EN_0:     equ %00000000 ;
041584             0041*  PRT_EN_1:     equ %00000001 ;
041584             0042*  
041584             0043*  ; Table 37. Timer Input Source Select Register
041584             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
041584             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041584             0046*  ;   00: System clock / CLK_DIV
041584             0047*  ;   01: RTC / CLK_DIV
041584             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
041584             0049*  ;   10: GPIO port B pin 1.
041584             0050*  ;   11: GPIO port B pin 1.
041584             0051*  TMR_ISS:   equ 92h ; register address
041584             0052*  
041584             0053*  ; Table 51. Real-Time Clock Control Register
041584             0054*  RTC_CTRL: equ EDh ; register address
041584             0055*  
041584             0056*  ; alarm interrupt disable/enable
041584             0057*  RTC_ALARM_0:    equ %00000000
041584             0058*  RTC_ALARM_1:    equ %10000000
041584             0059*  
041584             0060*  ; interrupt on alarm disable/enable
041584             0061*  RTC_INT_ENT_0:  equ %00000000
041584             0062*  RTC_INT_ENT_1:  equ %01000000
041584             0063*  
041584             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041584             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041584             0066*  
041584             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041584             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
041584             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041584             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
041584             0071*  
041584             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041584             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041584             0074*  
041584             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041584             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041584             0077*  
041584             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041584             0079*                                  ; RTC counter is enabled.
041584             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041584             0081*                                  ; RTC counter is disabled.
041584             0082*  
041584             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041584             0084*  
041584             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041584             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041584 00 00 00    0087*  prt_reload: dl 0x000000
041587             0088*  
041587             0089*  ; set PRT timer
041587             0090*  prt_set:
041587 21 00 00 00 0091*      ld hl,0
04158B 22 D5 15 04 0092*      ld (prt_irq_counter),hl
04158F 2A 84 15 04 0093*      ld hl,(prt_reload)
041593 ED 29 84    0094*      out0 ($84),l
041596 ED 21 85    0095*  	out0 ($85),h
041599             0096*  ; disable timer
041599 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04159B ED 39 83    0098*  	out0 ($83),a
04159E             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04159E 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0415A0 ED 39 83    0101*  	out0 ($83),a
0415A3 C9          0102*      ret
0415A4             0103*  
0415A4             0104*  ; ===============================================
0415A4             0105*  ; PRT Timer Interrupt Handling
0415A4             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0415A4             0107*  ; -----------------------------------------------
0415A4             0108*  prt_irq_init:
0415A4             0109*      ; set up interrupt vector table 2
0415A4 21 00 00 00 0110*  	ld hl,0
0415A8 3A 0C 01 00 0111*  	ld a,($10c)
0415AC 6F          0112*  	ld l,a
0415AD 3A 0D 01 00 0113*  	ld a,($10d)
0415B1 67          0114*  	ld h,a
0415B2             0115*  
0415B2             0116*  	; skip over CALL ($c3)
0415B2 23          0117*  	inc hl
0415B3             0118*  	; load address of jump into vector table 2 (in ram)
0415B3 ED 27       0119*  	ld hl,(hl)
0415B5             0120*  
0415B5             0121*  	; write CALL prt_irq_handler to vector table 2
0415B5 3E C3       0122*  	ld a,$c3
0415B7 77          0123*  	ld (hl),a
0415B8 23          0124*  	inc hl
0415B9 11 C0 15 04 0125*  	ld de,prt_irq_handler
0415BD ED 1F       0126*  	ld (hl),de
0415BF             0127*  
0415BF C9          0128*      ret
0415C0             0129*  
0415C0             0130*  prt_irq_handler:
0415C0 F3          0131*  	di
0415C1 F5          0132*  	push af
0415C2 E5          0133*      push hl
0415C3 ED 38 83    0134*  	in0 a,($83)
0415C6 2A D5 15 04 0135*  	ld hl,(prt_irq_counter)
0415CA 23          0136*  	inc hl
0415CB 22 D5 15 04 0137*  	ld (prt_irq_counter),hl
0415CF E1          0138*      pop hl
0415D0 F1          0139*  	pop af
0415D1 FB          0140*  	ei
0415D2 5B ED 4D    0141*  	reti.l
0415D5             0142*  
0415D5             0143*  prt_irq_counter:
0415D5 00 00 00    0144*  	.dl 0
0415D8             0145*  prt_irq_counter_saved:
0415D8 00 00 00    0146*      .dl 0
0415DB             0147*  
0415DB             0148*  prt_loop_reset:
0415DB E5          0149*      push hl
0415DC 21 00 00 00 0150*  	ld hl,0
0415E0 22 D5 15 04 0151*  	ld (prt_irq_counter),hl
0415E4 22 46 16 04 0152*      ld (prt_loop_counter),hl
0415E8 22 49 16 04 0153*      ld (prt_loops),hl
0415EC CD 87 15 04 0154*      call prt_set
0415F0 E1          0155*      pop hl
0415F1 C9          0156*      ret
0415F2             0157*  
0415F2             0158*  prt_loop_start:
0415F2 E5          0159*      push hl
0415F3 21 00 00 00 0160*  	ld hl,0
0415F7 22 D5 15 04 0161*  	ld (prt_irq_counter),hl
0415FB E1          0162*      pop hl
0415FC C9          0163*      ret
0415FD             0164*  
0415FD             0165*  prt_loop_stop:
0415FD E5          0166*      push hl
0415FE D5          0167*      push de
0415FF 2A D5 15 04 0168*      ld hl,(prt_irq_counter)
041603 ED 5B 46 16 0169*      ld de,(prt_loop_counter)
       04          
041608 19          0170*      add hl,de
041609 22 46 16 04 0171*      ld (prt_loop_counter),hl
04160D 21 00 00 00 0172*      ld hl,0
041611 22 D5 15 04 0173*      ld (prt_irq_counter),hl
041615 2A 49 16 04 0174*      ld hl,(prt_loops)
041619 23          0175*      inc hl
04161A 22 49 16 04 0176*      ld (prt_loops),hl
04161E D1          0177*      pop de
04161F E1          0178*      pop hl
041620 C9          0179*      ret
041621             0180*  
041621             0181*  ; inputs: bc = y,x text coordinates to print
041621             0182*  prt_loop_print:
041621 F5          0183*      push af
041622 E5          0184*      push hl
041623 C5          0185*      push bc
041624 D5          0186*      push de
041625 DD E5       0187*      push ix
041627 FD E5       0188*      push iy
041629 CD C5 06 04 0189*      call vdu_move_cursor
04162D             0190*  
04162D 2A 46 16 04 0191*      ld hl,(prt_loop_counter)
041631 CD 76 01 04 0192*      call printDec
041635             0193*  
041635 2A 49 16 04 0194*      ld hl,(prt_loops)
041639 CD 76 01 04 0195*      call printDec
04163D             0196*  
04163D FD E1       0197*      pop iy
04163F DD E1       0198*      pop ix
041641 D1          0199*      pop de
041642 C1          0200*      pop bc
041643 E1          0201*      pop hl
041644 F1          0202*      pop af
041645 C9          0203*      ret
041646             0204*  
041646             0205*  prt_loop_counter:
041646 00 00 00    0206*      .dl 0
041649             0207*  prt_loops:
041649 00 00 00    0208*      .dl 0
04164C             0209*  
04164C             0210*  ; ===============================================
04164C             0211*  ; Timer functions
04164C             0212*  ; -----------------------------------------------
04164C             0213*  ; set a countdown timer
04164C             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04164C             0215*  ; returns: hl = current time
04164C             0216*  tmr_set:
04164C FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
04164F             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
04164F 3E 08       0001*M 			LD	A, function
041651 5B CF       0002*M 			RST.LIL	08h
041653 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
041656 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
041659 C9          0221*      ret
04165A             0222*  
04165A             0223*  ; gets time remaining on a countdown timer
04165A             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04165A             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04165A             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
04165A             0227*  tmr_get:
04165A             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
04165A 3E 08       0001*M 			LD	A, function
04165C 5B CF       0002*M 			RST.LIL	08h
04165E DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
041661 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
041664 AF          0231*      xor a                   ; clear carry
041665 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041667 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
04166A AF          0234*      xor a                   ; clear carry
04166B ED 5A       0235*      adc hl,de               ; hl = time remaining
04166D             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04166D C9          0237*      ret
04166E             0238*  
04166E             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
041674             0240*  
041674 00 00 00    0241*  timestamp_now: dl 0
041677 00 00 00    0242*  timestamp_old: dl 0
04167A 00 00 00    0243*  timestamp_chg: dl 0
04167D             0244*  
04167D             0245*  ; update the global timestamp from the system clock
04167D             0246*  ; inputs: none
04167D             0247*  ; returns: hl = time elapsed in 1/120ths of a second
04167D             0248*  ;          de = current time
04167D             0249*  ;          ix = pointer to syvars table
04167D             0250*  ; destroys: af,hl,de,ix
04167D             0251*  timestamp_tick:
04167D ED 5B 74 16 0252*      ld de,(timestamp_now)   ; get previous time
       04          
041682 ED 53 77 16 0253*      ld (timestamp_old),de   ; save previous time
       04          
041687             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
041687 3E 08       0001*M 			LD	A, function
041689 5B CF       0002*M 			RST.LIL	08h
04168B DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
04168E 22 74 16 04 0256*      ld (timestamp_now),hl   ; save current time
041692 AF          0257*      xor a                   ; clear carry
041693 ED 52       0258*      sbc hl,de               ; hl = time elapsed
041695 22 7A 16 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
041699 C9          0260*      ret
04169A             0261*  
04169A             0262*  ; set a countdown timer
04169A             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04169A             0264*  ; requires: timestamp_tick to be called at least once before this function
04169A             0265*  ; returns: hl = current time
04169A             0266*  ; destroys: hl
04169A             0267*  timestamp_tmr_set:
04169A FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
04169D 2A 74 16 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
0416A1 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
0416A4 C9          0271*      ret
0416A5             0272*  
0416A5             0273*  ; gets time remaining on a countdown timer following the global timestamp
0416A5             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0416A5             0275*  ; requires: timestamp_tick to be called at least once before this function
0416A5             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0416A5             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
0416A5             0278*  ; destroys: af,hl,de
0416A5             0279*  timestamp_tmr_get:
0416A5 ED 5B 74 16 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
0416AA FD 27 00    0281*      ld hl,(iy+0)            ; get start time
0416AD AF          0282*      xor a                   ; clear carry
0416AE ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0416B0 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
0416B3 AF          0285*      xor a                   ; clear carry
0416B4 ED 5A       0286*      adc hl,de               ; hl = time remaining
0416B6             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0416B6 C9          0288*      ret
0416B7             0289*  
0416B7             0290*  ; set a stopwatch
0416B7             0291*  ; returns: hl = start time
0416B7             0292*  ; destroys: hl,ix
0416B7             0293*  stopwatch_set:
0416B7             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
0416B7 3E 08       0001*M 			LD	A, function
0416B9 5B CF       0002*M 			RST.LIL	08h
0416BB DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
0416BE 22 D3 16 04 0296*      ld (stopwatch_started),hl            ; set start time
0416C2 C9          0297*      ret
0416C3             0298*  
0416C3             0299*  ; gets time elapsed on a stopwatch
0416C3             0300*  ; returns: hl = time elapsed in 1/120ths of a second
0416C3             0301*  ; destroys: af,hl,de,ix
0416C3             0302*  stopwatch_get:
0416C3             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
0416C3 3E 08       0001*M 			LD	A, function
0416C5 5B CF       0002*M 			RST.LIL	08h
0416C7 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
0416CA ED 5B D3 16 0305*      ld de,(stopwatch_started)            ; get start time
       04          
0416CF AF          0306*      xor a                   ; clear carry
0416D0 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0416D2 C9          0308*      ret
0416D3             0309*  
0416D3             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0416D6             0311*  
0416D6             0312*  ; ------------------
0416D6             0313*  ; delay routine
0416D6             0314*  ; Author: Richard Turrnidge
0416D6             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0416D6             0316*  ; routine waits a fixed time,then returns
0416D6             0317*  ; arrive with A =  the delay byte. One bit to be set only.
0416D6             0318*  ; eg. ld A,00000100b
0416D6             0319*  
0416D6             0320*  multiPurposeDelay:
0416D6 F5          0321*      push af
0416D7 C5          0322*      push bc
0416D8 DD E5       0323*      push ix
0416DA 47          0324*      ld b,a
0416DB 3E 08       0325*      ld a,$08
0416DD 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
0416DF             0327*  
0416DF             0328*  waitLoop:
0416DF             0329*  
0416DF DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0416E2             0331*  
0416E2             0332*                                  ;   we check if bit set is same as last time we checked.
0416E2             0333*                                  ;   bit 0 - don't use
0416E2             0334*                                  ;   bit 1 - changes 64 times per second
0416E2             0335*                                  ;   bit 2 - changes 32 times per second
0416E2             0336*                                  ;   bit 3 - changes 16 times per second
0416E2             0337*  
0416E2             0338*                                  ;   bit 4 - changes 8 times per second
0416E2             0339*                                  ;   bit 5 - changes 4 times per second
0416E2             0340*                                  ;   bit 6 - changes 2 times per second
0416E2             0341*                                  ;   bit 7 - changes 1 times per second
0416E2 A0          0342*      and b
0416E3 4F          0343*      ld c,a
0416E4 3A F5 16 04 0344*      ld a,(oldTimeStamp)
0416E8 B9          0345*      cp c                        ; is A same as last value?
0416E9 28 F4       0346*      jr z,waitLoop              ; loop here if it is
0416EB 79          0347*      ld a,c
0416EC 32 F5 16 04 0348*      ld (oldTimeStamp),a        ; set new value
0416F0             0349*  
0416F0 DD E1       0350*      pop ix
0416F2 C1          0351*      pop bc
0416F3 F1          0352*      pop af
0416F4 C9          0353*      ret
0416F5             0354*  
0416F5 00          0355*  oldTimeStamp:   .db 00h
0416F6             0051   
0416F6             0052   ; --- INITIALIZATION ---
0416F6             0053   init:
0416F6 C9          0054      ret
0416F7             0055   
0416F7             0056   ; --- MAIN PROGRAM ---
0416F7             0057   main:
0416F7 21 40 03 00 0058       ld hl,3*256+64
0416FB 11 80 04 00 0059       ld de,4*256+128
0416FF CD CC 14 04 0060       call umul168
041703 CD 98 02 04 0061       call print_s168_hl
041707 CD 8C 00 04 0062       call printNewLine
04170B             0063   
04170B 21 05 00 00 0064       ld hl,5
04170F 11 02 00 00 0065       ld de,2
041713 CD F8 14 04 0066       call udiv168
041717 CD B6 02 04 0067       call print_s168_de
04171B CD 8C 00 04 0068       call printNewLine
04171F C9          0069       ret
041720             0070   
041720             0071   
041720             0072   ; testing udiv24
041720 FD 21 6E 16 0073       ld iy,tmr_test
       04          
041725 21 78 00 00 0074       ld hl,120 ; 10 seconds
041729 CD 4C 16 04 0075       call tmr_set
04172D 21 00 00 00 0076       ld hl,0
041731 E5          0077       push hl
041732 CD 4D 07 04 0078       call vdu_vblank
041736             0079   @loop:
041736 21 FF FF 00 0080       ld hl,65535
04173A 11 FF 03 00 0081       ld de,1023
04173E CD 60 15 04 0082       call udiv24
041742 E1          0083       pop hl
041743 23          0084       inc hl
041744 E5          0085       push hl
041745 FD 21 6E 16 0086       ld iy,tmr_test
       04          
04174A CD 5A 16 04 0087       call tmr_get
04174E F2 36 17 04 0088       jp p,@loop
041752 E1          0089       pop hl
041753 CD 76 01 04 0090       call printDec
041757 CD 8C 00 04 0091       call printNewLine
04175B             0092   
04175B             0093   fast_div:
04175B FD 21 6E 16 0094       ld iy,tmr_test
       04          
041760 21 78 00 00 0095       ld hl,120 ; 10 seconds
041764 CD 4C 16 04 0096       call tmr_set
041768 21 00 00 00 0097       ld hl,0
04176C E5          0098       push hl
04176D CD 4D 07 04 0099       call vdu_vblank
041771             0100   @loop:
041771 21 FF FF 00 0101       ld hl,65535
041775 0E 80       0102       ld c,128
041777 CD 95 17 04 0103       call HL_Div_C
04177B E1          0104       pop hl
04177C 23          0105       inc hl
04177D E5          0106       push hl
04177E FD 21 6E 16 0107       ld iy,tmr_test
       04          
041783 CD 5A 16 04 0108       call tmr_get
041787 F2 71 17 04 0109       jp p,@loop
04178B E1          0110       pop hl
04178C CD 76 01 04 0111       call printDec
041790 CD 8C 00 04 0112       call printNewLine
041794             0113   
041794 C9          0114       ret
041795             0115   
041795             0116   HL_Div_C:
041795             0117      ;Inputs:
041795             0118      ;     HL is the numerator
041795             0119      ;     C is the denominator
041795             0120      ;Outputs:
041795             0121      ;     A is the remainder
041795             0122      ;     B is 0
041795             0123      ;     C is not changed
041795             0124      ;     DE is not changed
041795             0125      ;     HL is the quotient
041795             0126      ;
041795 06 10       0127             ld b,16
041797 AF          0128             xor a
041798 29          0129               add hl,hl
041799 17          0130               rla
04179A B9          0131               cp c
04179B 38 02       0132               jr c,$+4
04179D 2C          0133                 inc l
04179E 91          0134                 sub c
04179F 10 F7       0135               djnz $-7
0417A1 C9          0136             ret
