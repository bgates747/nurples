PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0005   
040000             0006       MACRO PROGNAME
040000             0007       ASCIZ "flower_demo"
040000             0008       ENDMACRO
040000             0009   
040000 C3 45 00 04 0010       jp start
040004             0011   
040004             0012   _exec_name:
040004             0013   	PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010             0014   
040010 FF FF FF FF 0015       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0016       db "MOS"
040043 00          0017       db 00h
040044 01          0018       db 01h
040045             0019   
040045             0020   start:
040045 F5          0021       push af
040046 C5          0022       push bc
040047 D5          0023       push de
040048 DD E5       0024       push ix
04004A FD E5       0025       push iy
04004C             0026   
04004C CD 7B 17 04 0027       call init
040050 CD 7C 17 04 0028       call main
040054             0029   
040054             0030   exit:
040054             0031   
040054 FD E1       0032       pop iy
040056 DD E1       0033       pop ix
040058 D1          0034       pop de
040059 C1          0035       pop bc
04005A F1          0036       pop af
04005B 21 00 00 00 0037       ld hl,0
04005F             0038   
04005F C9          0039       ret
040060             0040   
040060             0041   ; --- MAIN PROGRAM ---
040060             0042   ; APPLICATION INCLUDES
040060             0043   ; API includes
040060             0044       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*          LD A, char
040060             0004*          RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*          ld bc,$+7     ; Address of first instruction after the jump
040060             0013*          push bc       ; which constitutes the return address
040060             0014*          jp   (hl)     ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*          ld bc,$+7     ; Address of first instruction after the jump
040060             0023*          push bc       ; which constitutes the return address
040060             0024*          jp   (ix)     ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*          ld bc,$+7     ; Address of first instruction after the jump
040060             0033*          push bc       ; which constitutes the return address
040060             0034*          jp   (iy)     ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*          push hl ; 4 cycles
040060             0041*          inc sp ; 1 cycle
040060             0042*          pop af  ; 4 cycles
040060             0043*          dec sp ; 1 cycle
040060             0044*                 ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*          ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*          ex af,af'
040070             0068*          exx
040070             0069*          push af
040070             0070*          push hl
040070             0071*          push bc
040070             0072*          push de
040070             0073*  
040070             0074*          ex af,af'
040070             0075*          exx
040070             0076*          push af
040070             0077*          push hl
040070             0078*          push bc
040070             0079*          push de
040070             0080*          push ix
040070             0081*          push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*          pop iy
040070             0086*          pop ix
040070             0087*          pop de
040070             0088*          pop bc
040070             0089*          pop hl
040070             0090*          pop af
040070             0091*          ex af,af'
040070             0092*          exx
040070             0093*  
040070             0094*          pop de
040070             0095*          pop bc
040070             0096*          pop hl
040070             0097*          pop af
040070             0098*          ex af,af'
040070             0099*          exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*  	PUSH	BC
040078 01 00 00 00 0119*  	LD		BC,0
04007C 3E 00       0120*  	LD 	 	A,0
04007E 5B DF       0121*  	RST.LIL 18h
040080 C1          0122*  	POP		BC
040081 C9          0123*  	RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*  	PUSH	BC
040083 01 00 00 00 0128*  	LD		BC, 0
040087 4E          0129*  	LD		C, (HL)
040088 5B DF       0130*  	RST.LIL	18h
04008A C1          0131*  	POP		BC
04008B C9          0132*  	RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*  	LD	A, '\r'
04008F 5B D7       0137*  	RST.LIL 10h
040091 3E 0A       0138*  	LD	A, '\n'
040093 5B D7       0139*  	RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*  	RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M         push hl ; 4 cycles
040098 33          0002*M         inc sp ; 1 cycle
040099 F1          0003*M         pop af  ; 4 cycles
04009A 3B          0004*M         dec sp ; 1 cycle
04009B             0005*M                ; 10 cycles total
04009B CD A5 00 04 0147*  	CALL	printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*  	LD		A,H
0400A0 CD A5 00 04 0152*  	CALL	printHex8
0400A4 7D          0153*  	LD		A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*  	LD		C,A
0400A6 1F          0158*  	RRA
0400A7 1F          0159*  	RRA
0400A8 1F          0160*  	RRA
0400A9 1F          0161*  	RRA
0400AA CD AF 00 04 0162*  	CALL	@F
0400AE 79          0163*  	LD		A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*  	AND		0Fh
0400B1 C6 90       0166*  	ADD		A,90h
0400B3 27          0167*  	DAA
0400B4 CE 40       0168*  	ADC		A,40h
0400B6 27          0169*  	DAA
0400B7 5B D7       0170*  	RST.LIL	10h
0400B9 C9          0171*  	RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*  	LD	A, '0'
04016F 5B D7       0290*  	RST.LIL 10h
040171 3E 78       0291*  	LD	A, 'x'
040173 5B D7       0292*  	RST.LIL 10h
040175 C9          0293*  	RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*          push hl
040176             0297*          push bc
040176             0298*          pop hl
040176             0299*          call printDec
040176             0300*          pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*          push hl
040176             0305*          push de
040176             0306*          pop hl
040176             0307*          call printDec
040176             0308*          pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*          call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*          push hl
040176             0317*          push ix
040176             0318*          pop hl
040176             0319*          call printDec
040176             0320*          pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*          push hl
040176             0325*          push iy
040176             0326*          pop hl
040176             0327*          call printDec
040176             0328*          pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*  	LD	 DE, _printDecBuffer
04017E CD B2 01 04 0344*  	CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD	 HL, _printDecBuffer
040186 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD	 A, (HL)
040189 FE 30       0351*      CP	 '0'
04018B C2 95 01 04 0352*      JP	 NZ, @done
04018F 3E 20       0353*      LD   A, ' '
040191 77          0354*      LD	 (HL), A
040192 23          0355*      INC	 HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*  	LD	 HL, _printDecBuffer
040199 CD 77 00 04 0361*  	CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*  	RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*  	LD	 BC,-10000000
0401B6 CD E9 01 04 0379*  	CALL @one_digit
0401BA 01 C0 BD F0 0380*  	LD	 BC,-1000000
0401BE CD E9 01 04 0381*  	CALL @one_digit
0401C2 01 60 79 FE 0382*  	LD	 BC,-100000
0401C6 CD E9 01 04 0383*  	CALL @one_digit
0401CA 01 F0 D8 FF 0384*  	LD   BC,-10000
0401CE CD E9 01 04 0385*  	CALL @one_digit
0401D2 01 18 FC FF 0386*  	LD   BC,-1000
0401D6 CD E9 01 04 0387*  	CALL @one_digit
0401DA 01 9C FF FF 0388*  	LD   BC,-100
0401DE CD E9 01 04 0389*  	CALL @one_digit
0401E2 0E F6       0390*  	LD   C,-10
0401E4 CD E9 01 04 0391*  	CALL @one_digit
0401E8 48          0392*  	LD   C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*  	LD   A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*  	INC  A
0401EC 09          0397*  	ADD  HL,BC
0401ED 38 FC       0398*  	JR   C,@divide_me
0401EF ED 42       0399*  	SBC  HL,BC
0401F1 12          0400*  	LD   (DE),A
0401F2 13          0401*  	INC  DE
0401F3 C9          0402*  	RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
040212 CD DC 0A 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld   bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld   bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld   bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld   c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld   c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp   @frac            ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc  a
040240 09          0443*      add  hl, bc           ; Accumulate until overflow
040241 38 FC       0444*      jr   c, @divide_me
040243 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
040245 12          0446*      ld   (de), a          ; Store ASCII digit
040246 13          0447*      inc  de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld   a, '.'           ; Decimal point
04024A 12          0452*      ld   (de), a
04024B 13          0453*      inc  de
04024C E1          0454*      pop  hl               ; Restore HL with original fraction
04024D 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld   a, '0'
040255 84          0460*      add  a, h             ; Convert integer part to ASCII
040256 12          0461*      ld   (de), a
040257 13          0462*      inc  de
040258 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor  a                ; Null terminator
04025B 12          0466*      ld   (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 75 0A 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8      ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
04031B             0602*                  ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*  	ld hl,@cmd
04032B 01 08 00 00 0615*  	ld bc,@end-@cmd
04032F 5B DF       0616*  	rst.lil $18
040331 C9          0617*  	ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8      ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
040340             0627*                  ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*  	ld hl,@cmd
040350 01 08 00 00 0640*  	ld bc,@end-@cmd
040354 5B DF       0641*  	rst.lil $18
040356 C9          0642*  	ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl  ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*  	MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl  ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
04056B 5B D7       0903*  	rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*  	call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0045       include "vdu.inc"
04068E             0001*  
04068E             0002*  ; VDU 30: Home cursor
04068E             0003*  vdu_home_cursor:
04068E 3E 1E       0004*      ld a,30
040690 5B D7       0005*  	rst.lil $10
040692 C9          0006*  	ret
040693             0007*  
040693             0008*  vdu_cursor_on:
040693 21 9E 06 04 0009*  	ld hl,@cmd
040697 01 03 00 00 0010*  	ld bc,@end-@cmd
04069B 5B DF       0011*  	rst.lil $18
04069D C9          0012*  	ret
04069E             0013*  @cmd:
04069E 17 01 01    0014*  	db 23,1,1
0406A1             0015*  @end:
0406A1             0016*  
0406A1             0017*  vdu_cursor_off:
0406A1 21 AC 06 04 0018*  	ld hl,@cmd
0406A5 01 03 00 00 0019*  	ld bc,@end-@cmd
0406A9 5B DF       0020*  	rst.lil $18
0406AB C9          0021*  	ret
0406AC             0022*  @cmd:
0406AC 17 01 00    0023*  	db 23,1,0
0406AF             0024*  @end:
0406AF             0025*  
0406AF             0026*  ; VDU 5: Write text at graphics cursor
0406AF             0027*  ; inputs: a is the character to write to the screen
0406AF             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0406AF             0029*  ; outputs: see the name of the function
0406AF             0030*  ; destroys: a, hl, bc
0406AF             0031*  vdu_char_to_gfx_cursor:
0406AF 32 BF 06 04 0032*  	ld (@arg),a
0406B3 21 BE 06 04 0033*  	ld hl,@cmd
0406B7 01 02 00 00 0034*  	ld bc,@end-@cmd
0406BB 5B DF       0035*  	rst.lil $18
0406BD C9          0036*  	ret
0406BE 05          0037*  @cmd: db 5
0406BF 00          0038*  @arg: db 0
0406C0             0039*  @end:
0406C0             0040*  ; VDU 9: Move cursor forward one character
0406C0             0041*  vdu_cursor_forward:
0406C0 3E 09       0042*      ld a,9
0406C2 5B D7       0043*  	rst.lil $10
0406C4 C9          0044*  	ret
0406C5             0045*  
0406C5             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0406C5             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0406C5             0048*  vdu_move_cursor:
0406C5 ED 43 D6 06 0049*      ld (@x0),bc
       04          
0406CA 21 D5 06 04 0050*  	ld hl,@cmd
0406CE 01 03 00 00 0051*  	ld bc,@end-@cmd
0406D2 5B DF       0052*  	rst.lil $18
0406D4 C9          0053*  	ret
0406D5 1F          0054*  @cmd: 	db 31
0406D6 00          0055*  @x0:	db 0
0406D7 00          0056*  @y0: 	db 0
0406D8 00          0057*  @end: 	db 0 ; padding
0406D9             0058*  
0406D9             0059*  ; VDU 12: Clear text area (CLS)
0406D9             0060*  vdu_cls:
0406D9 3E 0C       0061*      ld a,12
0406DB 5B D7       0062*  	rst.lil $10
0406DD C9          0063*  	ret
0406DE             0064*  
0406DE             0065*  vdu_flip:
0406DE 21 E9 06 04 0066*  	ld hl,@cmd
0406E2 01 03 00 00 0067*  	ld bc,@end-@cmd
0406E6 5B DF       0068*  	rst.lil $18
0406E8 C9          0069*  	ret
0406E9 17 00 C3    0070*  @cmd: db 23,0,0xC3
0406EC             0071*  @end:
0406EC             0072*  
0406EC             0073*  ; VDU 16: Clear graphics area (CLG)
0406EC             0074*  vdu_clg:
0406EC 3E 10       0075*      ld a,16
0406EE 5B D7       0076*  	rst.lil $10
0406F0 C9          0077*  	ret
0406F1             0078*  
0406F1             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0406F1             0080*  ; VDU 23, 7: Scrolling
0406F1             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0406F1             0082*  ; inputs: a, extent; l, direction; h; speed
0406F1             0083*  vdu_scroll_down:
0406F1 32 06 07 04 0084*  	ld (@extent),a
0406F5 22 07 07 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0406F9 21 04 07 04 0086*  	ld hl,@cmd
0406FD 01 05 00 00 0087*  	ld bc,@end-@cmd
040701 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
040703 C9          0089*  	ret
040704 17 07       0090*  @cmd:       db 23,7
040706 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
040707 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
040708 00          0093*  @speed:     db 0x00 ; pixels
040709 00          0094*  @end:		db 0x00 ; padding
04070A             0095*  
04070A             0096*  ; COLOUR MODES
04070A             0097*  ; Mode	Effect
04070A             0098*  ; 0	Set on-screen pixel to target colour value
04070A             0099*  ; 1	OR value with the on-screen pixel
04070A             0100*  ; 2	AND value with the on-screen pixel
04070A             0101*  ; 3	XOR value with the on-screen pixel
04070A             0102*  ; 4	Invert the on-screen pixel
04070A             0103*  ; 5	No operation
04070A             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
04070A             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
04070A             0106*  
04070A             0107*  ; VDU 17, colour: Define text colour (COLOUR)
04070A             0108*  vdu_colour_text:
04070A 32 1A 07 04 0109*  	ld (@arg),a
04070E 21 19 07 04 0110*  	ld hl,@cmd
040712 01 02 00 00 0111*  	ld bc,@end-@cmd
040716 5B DF       0112*  	rst.lil $18
040718 C9          0113*  	ret
040719 11          0114*  @cmd: db 17
04071A 00          0115*  @arg: db 0
04071B             0116*  @end:
04071B             0117*  
04071B             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04071B             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04071B             0120*  vdu_gcol:
04071B 32 30 07 04 0121*  	ld (@mode),a
04071F 79          0122*      ld a,c
040720 32 31 07 04 0123*      ld (@col),a
040724 21 2F 07 04 0124*  	ld hl,@cmd
040728 01 03 00 00 0125*  	ld bc,@end-@cmd
04072C 5B DF       0126*  	rst.lil $18
04072E C9          0127*  	ret
04072F 12          0128*  @cmd:  db 18
040730 00          0129*  @mode: db 0
040731 00          0130*  @col:  db 0
040732             0131*  @end:
040732             0132*  
040732             0133*  
040732             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
040732             0135*  ; MIND THE LITTLE-ENDIANESS
040732             0136*  ; inputs: c=left,b=bottom,e=right,d=top
040732             0137*  ; outputs; nothing
040732             0138*  ; destroys: a might make it out alive
040732             0139*  vdu_set_txt_viewport:
040732 ED 43 48 07 0140*      ld (@lb),bc
       04          
040737 ED 53 4A 07 0141*  	ld (@rt),de
       04          
04073C 21 47 07 04 0142*  	ld hl,@cmd
040740 01 05 00 00 0143*  	ld bc,@end-@cmd
040744 5B DF       0144*  	rst.lil $18
040746 C9          0145*  	ret
040747 1C          0146*  @cmd:   db 28 ; set text viewport command
040748 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
04074A 00 00       0148*  @rt: 	dw 0x0000 ; set by de
04074C 00          0149*  @end:   db 0x00	  ; padding
04074D             0150*  
04074D             0151*  ; Wait for VBLANK interrupt
04074D             0152*  vdu_vblank:
04074D DD E5       0153*      PUSH 	IX
04074F             0154*  	MOSCALL	mos_sysvars
04074F 3E 08       0001*M 			LD	A, function
040751 5B CF       0002*M 			RST.LIL	08h
040753 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
040756             0156*  @wait:
040756 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
040759 28 FB       0158*      JR	Z, @wait
04075B DD E1       0159*      POP	IX
04075D C9          0160*      RET
04075E             0161*  
04075E             0162*  ; VDU 29, x; y;: Set graphics origin
04075E             0163*  ; This command sets the graphics origin.
04075E             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04075E             0165*  ; inputs: bc=x0,de=y0
04075E             0166*  ; outputs; nothing
04075E             0167*  ; destroys: a might make it out alive
04075E             0168*  vdu_set_gfx_origin:
04075E ED 43 74 07 0169*      ld (@x0),bc
       04          
040763 ED 53 76 07 0170*      ld (@y0),de
       04          
040768 21 73 07 04 0171*      ld hl,@cmd
04076C 01 05 00 00 0172*      ld bc,@end-@cmd
040770 5B DF       0173*      rst.lil $18
040772 C9          0174*      ret
040773 1D          0175*  @cmd:   db 29 ; set graphics origin command
040774 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
040776 00 00       0177*  @y0: 	dw 0x0000 ; set by de
040778 00          0178*  @end:   db 0x00	  ; padding
040779             0179*  
040779             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040779             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
040779             0182*  ; 	because we have turned off logical screen scaling
040779             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040779             0184*  ; outputs; nothing
040779             0185*  ; destroys: a might make it out alive
040779             0186*  vdu_set_gfx_viewport:
040779 ED 43 99 07 0187*      ld (@x0),bc
       04          
04077E FD 22 9B 07 0188*      ld (@y1),iy
       04          
040783 DD 22 9D 07 0189*  	ld (@x1),ix
       04          
040788 ED 53 9F 07 0190*  	ld (@y0),de
       04          
04078D 21 98 07 04 0191*  	ld hl,@cmd
040791 01 09 00 00 0192*  	ld bc,@end-@cmd
040795 5B DF       0193*  	rst.lil $18
040797 C9          0194*  	ret
040798 18          0195*  @cmd:   db 24 ; set graphics viewport command
040799 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
04079B 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
04079D 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
04079F 00 00       0199*  @y0: 	dw 0x0000 ; set by de
0407A1 00          0200*  @end:   db 0x00	  ; padding
0407A2             0201*  
0407A2             0202*  ; SCREEN MODES
0407A2             0203*  ; ===============================
0407A2             0204*  ; Mode  Horz  Vert  Cols  Refresh
0407A2             0205*  ; ---   ----  ----  ----  -------
0407A2             0206*  ; 11    320   240   2     60hz
0407A2             0207*  ; 139   320   240   2     60hz
0407A2             0208*  ; 23    512   384   2     60hz
0407A2             0209*  ; 151   512   384   2     60hz
0407A2             0210*  ; 6     640   240   2     60hz
0407A2             0211*  ; 134   640   240   2     60hz
0407A2             0212*  ; 2     640   480   2     60hz
0407A2             0213*  ; 130   640   480   2     60hz
0407A2             0214*  ; 17    800   600   2     60hz
0407A2             0215*  ; 145   800   600   2     60hz
0407A2             0216*  ; 18    1024  768   2     60hz
0407A2             0217*  ; 146   1024  768   2     60hz
0407A2             0218*  ; ---   ----  ----  ----  -------
0407A2             0219*  ; 10    320   240   4     60hz
0407A2             0220*  ; 138   320   240   4     60hz
0407A2             0221*  ; 22    512   384   4     60hz
0407A2             0222*  ; 150   512   384   4     60hz
0407A2             0223*  ; 5     640   240   4     60hz
0407A2             0224*  ; 133   640   240   4     60hz
0407A2             0225*  ; 1     640   480   4     60hz
0407A2             0226*  ; 129   640   480   4     60hz
0407A2             0227*  ; 16    800   600   4     60hz
0407A2             0228*  ; 19    1024  768   4     60hz
0407A2             0229*  ; ---   ----  ----  ----  -------
0407A2             0230*  ; 9     320   240   16    60hz
0407A2             0231*  ; 137   320   240   16    60hz
0407A2             0232*  ; 21    512   384   16    60hz
0407A2             0233*  ; 149   512   384   16    60hz
0407A2             0234*  ; 4     640   240   16    60hz
0407A2             0235*  ; 132   640   240   16    60hz
0407A2             0236*  ; 0     640   480   16    60hz
0407A2             0237*  ; 7     n/a   n/a   16    60hz
0407A2             0238*  ; ---   ----  ----  ----  -------
0407A2             0239*  ; 8     320   240   64    60hz
0407A2             0240*  ; 136   320   240   64    60hz
0407A2             0241*  ; 20    512   384   64    60hz
0407A2             0242*  ; 3     640   240   64    60hz
0407A2             0243*  ; ---   ----  ----  ----  -------
0407A2             0244*  vdu_set_screen_mode:
0407A2 32 B2 07 04 0245*  	ld (@arg),a
0407A6 21 B1 07 04 0246*  	ld hl,@cmd
0407AA 01 02 00 00 0247*  	ld bc,@end-@cmd
0407AE 5B DF       0248*  	rst.lil $18
0407B0 C9          0249*  	ret
0407B1 16          0250*  @cmd: db 22 ; set screen mode
0407B2 00          0251*  @arg: db 0  ; screen mode parameter
0407B3             0252*  @end:
0407B3             0253*  
0407B3             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0407B3             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0407B3             0256*  ; note: default setting on boot is scaling ON
0407B3             0257*  vdu_set_scaling:
0407B3 32 C5 07 04 0258*  	ld (@arg),a
0407B7 21 C2 07 04 0259*  	ld hl,@cmd
0407BB 01 04 00 00 0260*  	ld bc,@end-@cmd
0407BF 5B DF       0261*  	rst.lil $18
0407C1 C9          0262*  	ret
0407C2 17 00 C0    0263*  @cmd: db 23,0,0xC0
0407C5 00          0264*  @arg: db 0  ; scaling on/off
0407C6             0265*  @end:
0407C6             0266*  
0407C6             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0407C6             0268*  ; inputs: hl=bufferId
0407C6             0269*  vdu_buff_select:
0407C6 22 D8 07 04 0270*  	ld (@bufferId),hl
0407CA 21 D5 07 04 0271*  	ld hl,@cmd
0407CE 01 05 00 00 0272*  	ld bc,@end-@cmd
0407D2 5B DF       0273*  	rst.lil $18
0407D4 C9          0274*  	ret
0407D5 17 1B 20    0275*  @cmd: db 23,27,0x20
0407D8 00 00       0276*  @bufferId: dw 0x0000
0407DA 00          0277*  @end: db 0x00 ; padding
0407DB             0278*  
0407DB             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0407DB             0280*  ; inputs: a=format; bc=width; de=height
0407DB             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0407DB             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0407DB             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0407DB             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0407DB             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0407DB             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
0407DB             0287*  vdu_bmp_create:
0407DB ED 43 F7 07 0288*      ld (@width),bc
       04          
0407E0 ED 53 F9 07 0289*      ld (@height),de
       04          
0407E5 32 FB 07 04 0290*      ld (@fmt),a
0407E9 21 F4 07 04 0291*  	ld hl,@cmd
0407ED 01 08 00 00 0292*  	ld bc,@end-@cmd
0407F1 5B DF       0293*  	rst.lil $18
0407F3 C9          0294*  	ret
0407F4 17 1B 21    0295*  @cmd:       db 23,27,0x21
0407F7 00 00       0296*  @width:     dw 0x0000
0407F9 00 00       0297*  @height:    dw 0x0000
0407FB 00          0298*  @fmt:       db 0x00
0407FC             0299*  @end:
0407FC             0300*  
0407FC             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0407FC             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0407FC             0303*  vdu_load_img_rgba2_to_8:
0407FC             0304*  ; backup the target buffer id and image dimensions
0407FC E5          0305*      push hl
0407FD D5          0306*      push de
0407FE C5          0307*      push bc
0407FF             0308*  ; load the rgba2 image to working buffer 65534
0407FF 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
040803 CD 06 09 04 0310*  	call vdu_load_buffer_from_file
040807             0311*  ; restore the image dimensions and target buffer id
040807 C1          0312*      pop bc
040808 D1          0313*      pop de
040809 E1          0314*      pop hl
04080A             0315*  ; fall through to vdu_rgba2_to_8
04080A             0316*  
04080A             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04080A             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04080A             0319*  ; the "expand bitmap" command is:
04080A             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04080A             0321*  ; and then to reverse the byte order to fix endian-ness:
04080A             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04080A             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04080A             0324*  ; VDU 23,27,&20,targetBufferID%;
04080A             0325*  ; VDU 23,27,&21,width%;height%;0
04080A             0326*  ; -------------------------------------------------------------------
04080A             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
04080A             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04080A             0329*  vdu_rgba2_to_8:
04080A             0330*  ; load the image dimensions and buffer id parameters
04080A ED 43 66 08 0331*      ld (@width),bc
       04          
04080F ED 53 68 08 0332*      ld (@height),de
       04          
040814 22 4B 08 04 0333*      ld (@bufferId0),hl
040818 22 58 08 04 0334*      ld (@bufferId2),hl
04081C 22 61 08 04 0335*      ld (@bufferId1),hl
040820             0336*  ; clean up bytes that got stomped on by the ID loads
040820 3E 48       0337*      ld a,0x48
040822 32 4D 08 04 0338*      ld (@bufferId0+2),a
040826 3E 17       0339*      ld a,23
040828 32 63 08 04 0340*      ld (@bufferId1+2),a
04082C 3E 18       0341*      ld a,24
04082E 32 5A 08 04 0342*      ld (@bufferId2+2),a
040832 AF          0343*      xor a
040833 32 6A 08 04 0344*      ld (@height+2),a
040837             0345*  ; send the vdu command strings
040837 21 42 08 04 0346*      ld hl,@beg
04083B 01 29 00 00 0347*      ld bc,@end-@beg
04083F 5B DF       0348*      rst.lil $18
040841 C9          0349*      ret
040842             0350*  @beg:
040842             0351*  ; Command 14: Consolidate blocks in a buffer
040842             0352*  ; VDU 23, 0, &A0, bufferId; 14
040842 17 00 A0    0353*      db 23,0,0xA0
040845 FE FF       0354*      dw 65534 ; workingBufferId
040847 0E          0355*      db 14 ; consolidate blocks
040848             0356*  ; the "expand bitmap" command is:
040848             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040848 17 00 A0    0358*      db 23,0,0xA0
04084B 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04084D 48          0360*      db 0x48 ; given as decimal command 72 in the docs
04084E 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04084F FE FF       0362*      dw 65534 ; sourceBufferId
040851 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040855             0364*  ; reverse the byte order to fix endian-ness:
040855             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
040855             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040855             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040855 17 00 A0    0368*      db 23,0,0xA0
040858 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04085A 18          0370*      db 24 ; reverse byte order
04085B 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04085C 04 00       0372*      dw 4 ; size (4 bytes)
04085E             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04085E             0374*  ; VDU 23,27,&20,targetBufferID%;
04085E 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
040861 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
040863             0377*  ; VDU 23,27,&21,width%;height%;0
040863 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
040866 00 00       0379*  @width: dw 0x0000
040868 00 00       0380*  @height: dw 0x0000
04086A 00          0381*      db 0x00 ; rgba8888 format
04086B             0382*  @end:
04086B             0383*  
04086B             0384*  ; scratch variables
04086B 00 00 00    0385*  bufferId0: dl 0x000000
04086E 00 00 00    0386*  bufferId1: dl 0x000000
040871             0387*  
040871             0388*  ; load a vdu buffer from local memory
040871             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040871             0390*  vdu_load_buffer:
040871 ED 43 9A 08 0391*      ld (@length),bc
       04          
040876 D5          0392*      push de ; save data pointer
040877             0393*  ; send the vdu command string
040877 7D          0394*      ld a,l
040878 32 97 08 04 0395*      ld (@bufferId),a
04087C 7C          0396*      ld a,h
04087D 32 98 08 04 0397*      ld (@bufferId+1),a
040881 21 94 08 04 0398*      ld hl,@cmd
040885 01 08 00 00 0399*      ld bc,@end-@cmd
040889 5B DF       0400*      rst.lil $18
04088B             0401*  ; send the buffer data
04088B E1          0402*      pop hl ; pointer to data
04088C ED 4B 9A 08 0403*      ld bc,(@length)
       04          
040891 5B DF       0404*      rst.lil $18 ; send it
040893 C9          0405*      ret
040894             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040894 17 00 A0    0407*  @cmd:       db 23,0,0xA0
040897 00 00       0408*  @bufferId:	dw 0x0000
040899 00          0409*  		    db 0 ; load buffer
04089A 00 00       0410*  @length:	dw 0x0000
04089C 00          0411*  @end: db 0 ; padding
04089D             0412*  
04089D             0413*  ; clear a buffer
04089D             0414*  ; inputs: hl = bufferId
04089D             0415*  vdu_clear_buffer:
04089D 7D          0416*      ld a,l
04089E 32 B5 08 04 0417*      ld (@bufferId),a
0408A2 7C          0418*      ld a,h
0408A3 32 B6 08 04 0419*      ld (@bufferId+1),a
0408A7 21 B2 08 04 0420*      ld hl,@cmd
0408AB 01 06 00 00 0421*      ld bc,@end-@cmd
0408AF 5B DF       0422*      rst.lil $18
0408B1 C9          0423*      ret
0408B2 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0408B5 00 00       0425*  @bufferId:	dw 0x0000
0408B7 02          0426*  		    db 2 ; clear buffer
0408B8             0427*  @end:
0408B8             0428*  
0408B8             0429*  vdu_clear_all_buffers:
0408B8             0430*  ; clear all buffers
0408B8 21 C3 08 04 0431*      ld hl,@beg
0408BC 01 06 00 00 0432*      ld bc,@end-@beg
0408C0 5B DF       0433*      rst.lil $18
0408C2 C9          0434*      ret
0408C3 17 00 A0    0435*  @beg: db 23,0,$A0
0408C6 FF FF       0436*        dw -1 ; clear all buffers
0408C8 02          0437*        db 2  ; command 2: clear a buffer
0408C9             0438*  @end:
0408C9             0439*  
0408C9             0440*  ; Command 14: Consolidate blocks in a buffer
0408C9             0441*  vdu_consolidate_buffer:
0408C9             0442*  ; set parameters for vdu call
0408C9 7D          0443*      ld a,l
0408CA 32 E1 08 04 0444*      ld (@bufferId),a
0408CE 7C          0445*      ld a,h
0408CF 32 E2 08 04 0446*      ld (@bufferId+1),a
0408D3 21 DE 08 04 0447*      ld hl,@beg
0408D7 01 06 00 00 0448*      ld bc,@end-@beg
0408DB 5B DF       0449*      rst.lil $18
0408DD C9          0450*      ret
0408DE             0451*  ; VDU 23, 0, &A0, bufferId; 14
0408DE 17 00 A0    0452*  @beg: db 23,0,0xA0
0408E1 00 00       0453*  @bufferId: dw 0x0000
0408E3 0E          0454*             db 14
0408E4             0455*  @end:
0408E4             0456*  
0408E4             0457*  ; load an image file to a buffer and make it a bitmap
0408E4             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0408E4             0459*  vdu_load_img:
0408E4             0460*  ; back up image type and dimension parameters
0408E4 22 6B 08 04 0461*      ld (bufferId0),hl
0408E8 F5          0462*      push af
0408E9 C5          0463*  	push bc
0408EA D5          0464*  	push de
0408EB             0465*  ; load the image
0408EB CD 06 09 04 0466*  	call vdu_load_buffer_from_file
0408EF             0467*  ; now make it a bitmap
0408EF 2A 6B 08 04 0468*      ld hl,(bufferId0)
0408F3 CD C9 08 04 0469*      call vdu_consolidate_buffer
0408F7 2A 6B 08 04 0470*      ld hl,(bufferId0)
0408FB CD C6 07 04 0471*      call vdu_buff_select
0408FF D1          0472*  	pop de ; image height
040900 C1          0473*  	pop bc ; image width
040901 F1          0474*  	pop af ; image type
040902 C3 DB 07 04 0475*  	jp vdu_bmp_create ; will return to caller from there
040906             0476*  
040906             0477*  ; inputs: hl = bufferId; iy = pointer to filename
040906             0478*  vdu_load_buffer_from_file:
040906 22 6B 08 04 0479*      ld (bufferId0),hl
04090A             0480*  
04090A             0481*  ; clear target buffer
04090A CD 9D 08 04 0482*      call vdu_clear_buffer
04090E             0483*  
04090E             0484*  ; open the file in read mode
04090E             0485*  ; Open a file
04090E             0486*  ; HLU: Filename
04090E             0487*  ;   C: Mode
04090E             0488*  ; Returns:
04090E             0489*  ;   A: Filehandle, or 0 if couldn't open
04090E FD E5       0490*  	push iy ; pointer to filename
040910 E1          0491*  	pop hl
040911 0E 01       0492*  	ld c,fa_read
040913             0493*      MOSCALL mos_fopen
040913 3E 0A       0001*M 			LD	A, function
040915 5B CF       0002*M 			RST.LIL	08h
040917 32 52 09 04 0494*      ld (@filehandle),a
04091B             0495*  
04091B             0496*  @read_file:
04091B             0497*  ; Read a block of data from a file
04091B             0498*  ;   C: Filehandle
04091B             0499*  ; HLU: Pointer to where to write the data to
04091B             0500*  ; DEU: Number of bytes to read
04091B             0501*  ; Returns:
04091B             0502*  ; DEU: Number of bytes read
04091B 3A 52 09 04 0503*      ld a,(@filehandle)
04091F 4F          0504*      ld c,a
040920 21 00 E0 B7 0505*      ld hl,filedata
040924 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
040928             0507*      MOSCALL mos_fread
040928 3E 1A       0001*M 			LD	A, function
04092A 5B CF       0002*M 			RST.LIL	08h
04092C             0508*  
04092C             0509*  ; test de for zero bytes read
04092C 21 00 00 00 0510*      ld hl,0
040930 AF          0511*      xor a ; clear carry
040931 ED 52       0512*      sbc hl,de
040933 CA 49 09 04 0513*      jp z,@close_file
040937             0514*  
040937             0515*  ; load a vdu buffer from local memory
040937             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040937 2A 6B 08 04 0517*      ld hl,(bufferId0)
04093B D5          0518*      push de ; chunksize
04093C C1          0519*      pop bc
04093D 11 00 E0 B7 0520*      ld de,filedata
040941 CD 71 08 04 0521*      call vdu_load_buffer
040945             0522*  
040945             0523*  ; read the next block
040945 C3 1B 09 04 0524*      jp @read_file
040949             0525*  
040949             0526*  ; close the file
040949             0527*  @close_file:
040949 3A 52 09 04 0528*      ld a,(@filehandle)
04094D             0529*      MOSCALL mos_fclose
04094D 3E 0B       0001*M 			LD	A, function
04094F 5B CF       0002*M 			RST.LIL	08h
040951 C9          0530*      ret ; vdu_load_buffer_from_file
040952             0531*  
040952 00          0532*  @filehandle: db 0 ; file handle
040953 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
040956             0534*  
040956 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
040959             0536*  
040959             0537*  ; File information structure (FILINFO)
040959             0538*  @filinfo:
040959 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04095D 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04095F 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040961 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040962 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04096F 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040A6F             0046   	include "maths.inc"
040A6F             0001*  ; test the sign of HL
040A6F             0002*  ; inputs: HL obviously
040A6F             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040A6F             0004*  ; destroys: flags
040A6F             0005*      MACRO sign_hlu
040A6F             0006*          add hl,de
040A6F             0007*          or a
040A6F             0008*          sbc hl,de
040A6F             0009*      ENDMACRO
040A6F             0010*  
040A6F             0011*  
040A6F             0012*  ;------------------------------------------------------------------------
040A6F             0013*  ; Scratch area for calculations
040A6F             0014*  ;------------------------------------------------------------------------
040A6F 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
040A72 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
040A75             0017*  
040A75             0018*  ; absolute value of hlu
040A75             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040A75             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040A75             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040A75             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040A75             0023*  ; destroys: a
040A75             0024*  hlu_abs:
040A75 19          0025*      add hl,de
040A76 B7          0026*      or a
040A77 ED 52       0027*      sbc hl,de
040A79 FA 7E 0A 04 0028*      jp m,@is_neg
040A7D C9          0029*      ret         ; hlu is positive or zero so we're done
040A7E             0030*  @is_neg:
040A7E F5          0031*      push af     ; otherwise, save current flags for return
040A7F CD 85 0A 04 0032*      call neg_hlu ; negate hlu
040A83 F1          0033*      pop af      ; get back flags
040A84 C9          0034*      ret
040A85             0035*  
040A85             0036*  ; flip the sign of hlu
040A85             0037*  ; inputs: hlu
040A85             0038*  ; returns: 0-hlu, flags set appropriately for the result:
040A85             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
040A85             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
040A85             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
040A85             0042*  ; destroys a
040A85             0043*  neg_hlu:
040A85 D5          0044*      push de     ; save de
040A86 EB          0045*      ex de,hl    ; put hl into de
040A87 21 00 00 00 0046*      ld hl,0     ; clear hl
040A8B AF          0047*      xor a       ; clear carry
040A8C ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
040A8E D1          0049*      pop de      ; get de back
040A8F C9          0050*      ret         ; easy peasy
040A90             0051*  
040A90             0052*  ;------------------------------------------------------------------------
040A90             0053*  ; divide hlu by 2, inspired by above
040A90             0054*  ;------------------------------------------------------------------------
040A90             0055*  hlu_div2:
040A90 22 6F 0A 04 0056*  	ld		(scratch1),hl
040A94 21 71 0A 04 0057*  	ld		hl,scratch1+2
040A98 CB 1E       0058*  	rr		(hl)
040A9A 2B          0059*  	dec		hl
040A9B CB 1E       0060*  	rr		(hl)
040A9D 2B          0061*  	dec		hl
040A9E CB 1E       0062*  	rr		(hl)
040AA0 23          0063*  	inc		hl
040AA1 23          0064*  	inc		hl
040AA2 2A 6F 0A 04 0065*      ld hl,(scratch1)
040AA6 C9          0066*      ret
040AA7             0067*  
040AA7             0068*  ; this is my little hack to divide by 16
040AA7             0069*  hlu_div16:
040AA7 AF          0070*      xor a
040AA8 29          0071*      add hl,hl
040AA9 17          0072*      rla
040AAA 29          0073*      add hl,hl
040AAB 17          0074*      rla
040AAC 29          0075*      add hl,hl
040AAD 17          0076*      rla
040AAE 29          0077*      add hl,hl
040AAF 17          0078*      rla
040AB0 22 BD 0A 04 0079*      ld (@scratch),hl
040AB4 32 C0 0A 04 0080*      ld (@scratch+3),a
040AB8 2A BE 0A 04 0081*      ld hl,(@scratch+1)
040ABC C9          0082*      ret
040ABD             0083*  @scratch: ds 4
040AC1             0084*  
040AC1             0085*  ; hlu signed division by 256
040AC1             0086*  ; returns: hlu / 256
040AC1             0087*  ; destroys: af
040AC1             0088*  hlu_sdiv256:
040AC1 AF          0089*      xor a ; assume hl is positive
040AC2 22 D8 0A 04 0090*      ld (@buffer),hl
040AC6             0091*      sign_hlu
040AC6 19          0001*M         add hl,de
040AC7 B7          0002*M         or a
040AC8 ED 52       0003*M         sbc hl,de
040ACA F2 CF 0A 04 0092*      jp p,@hl_pos
040ACE 3D          0093*      dec a
040ACF             0094*  @hl_pos:
040ACF 32 DB 0A 04 0095*      ld (@buffer+3),a
040AD3 2A D9 0A 04 0096*      ld hl,(@buffer+1)
040AD7 C9          0097*      ret
040AD8             0098*  @buffer: ds 4
040ADC             0099*  
040ADC             0100*  ; hlu 1 byte right shift, unsigned
040ADC             0101*  ; returns: hlu / 256, fractional portion in a
040ADC             0102*  ; destroys: af
040ADC             0103*  hlu_udiv256:
040ADC AF          0104*  	xor a
040ADD 32 EE 0A 04 0105*  	ld (@buffer+3),a
040AE1 7D          0106*  	ld a,l ; save the fractional portion
040AE2 22 EB 0A 04 0107*  	ld (@buffer),hl
040AE6 2A EC 0A 04 0108*  	ld hl,(@buffer+1)
040AEA C9          0109*  	ret
040AEB             0110*  @buffer: ds 4
040AEF             0111*  
040AEF             0112*      MACRO hlu_mul256
040AEF             0113*          add hl,hl ; * 2
040AEF             0114*          add hl,hl ; * 4
040AEF             0115*          add hl,hl ; * 8
040AEF             0116*          add hl,hl ; * 16
040AEF             0117*          add hl,hl ; * 32
040AEF             0118*          add hl,hl ; * 64
040AEF             0119*          add hl,hl ; * 128
040AEF             0120*          add hl,hl ; * 256
040AEF             0121*      ENDMACRO
040AEF             0122*  
040AEF             0123*  ; compute the modulo of hlu by deu
040AEF             0124*  ; outputs: hlu = hlu % deu
040AEF             0125*  ; destroys: f, hl
040AEF             0126*  hlu_mod:
040AEF B7          0127*  	or a ; clear carry
040AF0             0128*  @loop:
040AF0 ED 52       0129*      sbc hl,de
040AF2 DA FA 0A 04 0130*      jp c, @end
040AF6 C3 F0 0A 04 0131*      jp @loop
040AFA             0132*  @end:
040AFA 19          0133*      add hl,de
040AFB C9          0134*  	ret
040AFC             0135*  
040AFC             0136*  
040AFC 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
040B00 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040B04             0139*  
040B04             0140*  ; set bcd values in a scratch memory address from registers bcde
040B04             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040B04             0142*  ; destroys ; hl
040B04             0143*  set_bcd:
040B04 73          0144*      ld (hl),e
040B05 23          0145*      inc hl
040B06 72          0146*      ld (hl),d
040B07 23          0147*      inc hl
040B08 71          0148*      ld (hl),c
040B09 23          0149*      inc hl
040B0A 70          0150*      ld (hl),b
040B0B C9          0151*      ret
040B0C             0152*  
040B0C             0153*  ; load bcd values from a scratch memory address to bcde
040B0C             0154*  ; input: hl; scratch address
040B0C             0155*  ; output: bcde; 8-place bcd number
040B0C             0156*  ; destroys: hl
040B0C             0157*  get_bcd:
040B0C 5E          0158*      ld e,(hl)
040B0D 23          0159*      inc hl
040B0E 56          0160*      ld d,(hl)
040B0F 23          0161*      inc hl
040B10 4E          0162*      ld c,(hl)
040B11 23          0163*      inc hl
040B12 46          0164*      ld b,(hl)
040B13 C9          0165*      ret
040B14             0166*  
040B14             0167*  ; BCD addition
040B14             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B14             0169*  ;       a is the number of bytes holding each number (number of places/2)
040B14             0170*  ; outputs: (hl) + (de) --> (hl)
040B14             0171*  ; destroys: a,b,de,hl
040B14             0172*  add_bcd:
040B14 47          0173*      ld b,a ; loop counter
040B15 AF          0174*      xor a ; reset a, clear carry flag
040B16             0175*  adcec:
040B16 1A          0176*      ld a,(de) ; addend to acc
040B17 8E          0177*      adc a,(hl) ; add (hl) to acc
040B18 27          0178*      daa ; adjust result to bcd
040B19 77          0179*      ld (hl),a ; store result
040B1A 23          0180*      inc hl ; advance memory pointers
040B1B 13          0181*      inc de
040B1C 10 F8       0182*      djnz adcec ; loop until b == 0
040B1E C9          0183*      ret
040B1F             0184*  
040B1F             0185*  ; BCD subtraction
040B1F             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B1F             0187*  ;       a is the number of bytes holding each number (number of places/2)
040B1F             0188*  ; outputs: (hl) - (de) --> (hl)
040B1F             0189*  ; destroys: a,b,de,hl
040B1F             0190*  sub_bcd:
040B1F 47          0191*      ld b,a ; loop counter
040B20 AF          0192*      xor a ; reset a,clear carry flag
040B21             0193*  subdec:
040B21 1A          0194*      ld a,(de) ; subtrahend to acc
040B22 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040B23 27          0196*      daa ; adjust result to bcd
040B24 77          0197*      ld (hl),a ; store result
040B25 23          0198*      inc hl ; advance memory pointers
040B26 13          0199*      inc de
040B27 10 F8       0200*      djnz subdec ; loop until b == 0
040B29 C9          0201*      ret
040B2A             0202*  
040B2A             0203*  ; http://www.z80.info/pseudo-random.txt
040B2A             0204*  rand_8:
040B2A C5          0205*      push bc
040B2B 3A 3E 0B 04 0206*      ld a,(r_seed)
040B2F 4F          0207*      ld c,a
040B30             0208*  
040B30 0F          0209*      rrca ; multiply by 32
040B31 0F          0210*      rrca
040B32 0F          0211*      rrca
040B33 EE 1F       0212*      xor 0x1f
040B35             0213*  
040B35 81          0214*      add a,c
040B36 DE FF       0215*      sbc a,255 ; carry
040B38             0216*  
040B38 32 3E 0B 04 0217*      ld (r_seed),a
040B3C C1          0218*      pop bc
040B3D C9          0219*      ret
040B3E 50          0220*  r_seed: defb $50
040B3F             0047   	include "trig24fast.inc"
040B3F             0001*  
040B3F             0002*  ; convert signed angles from a 360 to 256 degree circle
040B3F             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B3F             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B3F             0005*  ; destroys: TODO
040B3F             0006*  deg_360_to_256:
040B3F D5          0007*  	push de ; preserve de
040B40             0008*  ; make angle positive and store sign flag
040B40 CD 75 0A 04 0009*  	call hlu_abs
040B44 F5          0010*  	push af
040B45             0011*  ; multiply by 256 first to keep precision
040B45             0012*  	hlu_mul256 ; uh.l = uh.l * 256
040B45 29          0001*M         add hl,hl ; * 2
040B46 29          0002*M         add hl,hl ; * 4
040B47 29          0003*M         add hl,hl ; * 8
040B48 29          0004*M         add hl,hl ; * 16
040B49 29          0005*M         add hl,hl ; * 32
040B4A 29          0006*M         add hl,hl ; * 64
040B4B 29          0007*M         add hl,hl ; * 128
040B4C 29          0008*M         add hl,hl ; * 256
040B4D             0013*  ; divide uh.l by 360
040B4D 11 68 01 00 0014*  	ld de,360
040B51 CD E5 15 04 0015*  	call udiv24 ; ud.e = degrees / 360
040B55 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
040B56             0017*  ; restore sign flag and adjust output accordingly
040B56 F1          0018*  	pop af
040B57 F2 5F 0B 04 0019*  	jp p,@pos ; positive number
040B5B CD 85 0A 04 0020*  	call neg_hlu
040B5F             0021*  @pos:
040B5F             0022*  ; restore de and return uh.l as the result
040B5F D1          0023*  	pop de
040B60 C9          0024*  	ret
040B61             0025*  
040B61             0026*  ; fixed 16.8 routine
040B61             0027*  ; cos(uh.l) --> uh.l
040B61             0028*  ; destroys: f, hl
040B61             0029*  cos168:
040B61 D5          0030*      push de ; preserve de
040B62             0031*  ; for cos we simply increment the angle by 90 degrees
040B62             0032*  ; or 0x004000 in 16.8 degrees256
040B62             0033*  ; which makes it a sin problem
040B62 11 00 40 00 0034*      ld de,0x004000
040B66 19          0035*      add hl,de ; modulo 256 happens below
040B67 D1          0036*      pop de ; restore de
040B68             0037*  ; fall through to sin168
040B68             0038*  
040B68             0039*  ; ---------------------
040B68             0040*  ; fixed 16.8 routine
040B68             0041*  ; sin(uh.l) --> uh.l
040B68             0042*  ; destroys: f, hl
040B68             0043*  sin168:
040B68 D5          0044*  	push de
040B69             0045*  ; handle negative angles appropriately
040B69 CD 75 0A 04 0046*  	call hlu_abs
040B6D F2 76 0B 04 0047*  	jp p,@F
040B71 11 00 00 FF 0048*  	ld de,-256*256
040B75 19          0049*  	add hl,de
040B76             0050*  @@:
040B76 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
040B78 ED 6C       0052*      mlt hl
040B7A 11 B0 0D 04 0053*      ld de,sin_lut_168 ; grab the lut address
040B7E 19          0054*      add hl,de ; bump hl by the index
040B7F ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
040B81 D1          0056*      pop de
040B82 C9          0057*      ret
040B83             0058*  
040B83             0059*  ; 16.8 fixed inputs / outputs
040B83             0060*  ; takes: uh.l as angle in degrees 256
040B83             0061*  ;        ud.e as radius
040B83             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040B83             0063*  ;        displacements from origin (0,0)
040B83             0064*  ; destroys: everything except indexes
040B83             0065*  polar_to_cartesian:
040B83             0066*  ; back up input parameters
040B83 22 B2 0B 04 0067*      ld (@angle), hl
040B87 ED 53 B5 0B 0068*      ld (@radius), de
       04          
040B8C             0069*  ; compute dx = sin(uh.l) * ud.e
040B8C CD 68 0B 04 0070*      call sin168 ; uh.l = sin(uh.l)
040B90 ED 5B B5 0B 0071*  	ld de,(@radius)
       04          
040B95 CD 5A 15 04 0072*  	call smul168 ; uh.l = dx
040B99 E5          0073*      push hl
040B9A             0074*  ; compute dy = -cos(uh.l) * ud.e
040B9A 2A B2 0B 04 0075*      ld hl,(@angle)
040B9E CD 61 0B 04 0076*      call cos168 ; uh.l = cos(uh.l)
040BA2 ED 5B B5 0B 0077*      ld de,(@radius)
       04          
040BA7 CD 5A 15 04 0078*      call smul168    ; uh.l = dy
040BAB CD 85 0A 04 0079*      call neg_hlu ; invert dy for screen coords convention
040BAF EB          0080*      ex de,hl       ; de = dy for output
040BB0 C1          0081*      pop bc          ; bc = dx for output
040BB1             0082*  ; and out
040BB1 C9          0083*      ret
040BB2             0084*  @angle: ds 3
040BB5             0085*  @radius: ds 3
040BB8             0086*  
040BB8             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BB8             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BB8             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BB8             0090*  ;         also populates scratch locations dx168 and dy168
040BB8             0091*  ; destroys: a,hl,bc,de
040BB8             0092*  dxy168:
040BB8             0093*  ; compute dx = x1-x0
040BB8 AF          0094*      xor a ; clear carry
040BB9 DD E5       0095*      push ix ; move ix to hl via the stack
040BBB E1          0096*      pop hl ; hl = x1
040BBC ED 42       0097*      sbc hl,bc ; hl = dx
040BBE 22 D3 0B 04 0098*      ld (dx168),hl ; dx to scratch
040BC2             0099*  ; compute dy = y1-y0
040BC2 AF          0100*      xor a ; clear carry
040BC3 FD E5       0101*      push iy ; move iy to hl via the stack
040BC5 E1          0102*      pop hl ; hl = y1
040BC6 ED 52       0103*      sbc hl,de ; hl = dy
040BC8 22 D9 0B 04 0104*      ld (dy168),hl ; dy to scratch
040BCC             0105*  ; populate output registers and return
040BCC EB          0106*      ex de,hl        ; ud.e = dy
040BCD ED 4B D3 0B 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
040BD2 C9          0108*      ret
040BD3 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
040BD9 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
040BDF             0111*  
040BDF             0112*  ; compute the euclidian distance between two cartesian coordinates
040BDF             0113*  ; using the formula d = sqrt(dx^2+dy^2
040BDF             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BDF             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BDF             0116*  ; output; uh.l is the 16.8 fixed format distance
040BDF             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
040BDF             0118*  ; destroys: a,hl,bc,de
040BDF             0119*  distance168:
040BDF CD B8 0B 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
040BE3             0121*  ; compute dy^2
040BE3 EB          0122*  	ex de,hl
040BE4 CD 75 0A 04 0123*  	call hlu_abs
040BE8 E5          0124*  	push hl
040BE9 D1          0125*  	pop de
040BEA CD 52 15 04 0126*  	call umul168 ; hl = dy^2
040BEE E5          0127*  	push hl ; save dy^2
040BEF             0128*  ; compute dx^2
040BEF 2A D3 0B 04 0129*  	ld hl,(dx168)
040BF3 CD 75 0A 04 0130*  	call hlu_abs
040BF7 E5          0131*  	push hl
040BF8 D1          0132*  	pop de
040BF9 CD 52 15 04 0133*  	call umul168 ; hl = dx^2
040BFD             0134*  ; add dx^2 and dy^2
040BFD D1          0135*  	pop de ; de = dy^2
040BFE 19          0136*  	add hl,de ; hl = dx^2 + dy^2
040BFF             0137*  ; compute the square root
040BFF CD C5 0C 04 0138*  	call sqrt168
040C03 C9          0139*  	ret
040C04             0140*  
040C04             0141*  ; atan2_(ub.c,ud.e) --> uh.l
040C04             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C04             0143*  ;   whether inputs are integers or fractional doesn't matter
040C04             0144*  ;   so long as the sign bit of the upper byte is correct
040C04             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C04             0146*  ; angles are COMPASS HEADINGS based on
040C04             0147*  ; screen coordinate conventions,where the y axis is flipped
040C04             0148*  ; #E0 315      0       45 #20
040C04             0149*  ;        -x,-y | +x,-y
040C04             0150*  ; #C0 270------+------ 90 #40
040C04             0151*  ;        -x,+y | +x,+y
040C04             0152*  ; #A0 225   180 #80   135 #60
040C04             0153*  atan2_168fast:
040C04             0154*  ; get signs and make everything positive
040C04             0155*  ; get abs(x) and store its original sign
040C04 C5          0156*      push bc
040C05 E1          0157*      pop hl
040C06 CD 75 0A 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
040C0A E5          0159*      push hl ; store abs(x)
040C0B C1          0160*      pop bc ; bc = abs(x)
040C0C F5          0161*      push af ; store sign of x
040C0D             0162*  ; get abs(y) and store its original sign
040C0D EB          0163*      ex de,hl ; hl = y
040C0E CD 75 0A 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
040C12 EB          0165*      ex de,hl ; de = abs(y)
040C13 F5          0166*      push af ; store sign of y
040C14             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C14             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C14 AF          0169*      xor a ; clear the carry flag
040C15 D5          0170*      push de
040C16 E1          0171*      pop hl
040C17 ED 42       0172*      sbc hl,bc
040C19 F5          0173*      push af ; save sign of de - bc
040C1A F2 23 0C 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
040C1E             0175*  ; otherwise we swap bc and de
040C1E C5          0176*      push bc
040C1F E1          0177*      pop hl
040C20 EB          0178*      ex de,hl
040C21 E5          0179*      push hl
040C22 C1          0180*      pop bc
040C23             0181*  @1:
040C23             0182*  ; now we're ready to snag our preliminary result
040C23 C5          0183*  	push bc
040C24 E1          0184*  	pop hl
040C25 CD 93 0C 04 0185*      call atan_168fast ; uh.l comes back with prelim result
040C29             0186*  ; now we adjust uh.l based on sign of de - bc
040C29 F1          0187*      pop af
040C2A F2 36 0C 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
040C2E EB          0189*      ex de,hl
040C2F 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
040C33 AF          0191*      xor a ; clear the carry flag
040C34 ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
040C36             0193*  @2:
040C36             0194*  ; now the fun part of adjusting the result
040C36             0195*  ; based on which quadrant (x,y) is in
040C36             0196*  ; #E0 315      0       45 #20
040C36             0197*  ;        -x,-y | +x,-y
040C36             0198*  ; #C0 270------+------ 90 #40
040C36             0199*  ;        -x,+y | +x,+y
040C36             0200*  ; #A0 225   180 #80   135 #60
040C36 F1          0201*      pop af ; sign of y
040C37 CA 74 0C 04 0202*      jp z,@y_zero
040C3B F2 54 0C 04 0203*      jp p,@y_pos
040C3F             0204*  ; y neg,check x
040C3F F1          0205*      pop af ; sign of x
040C40 CA 4E 0C 04 0206*      jp z,@y_neg_x_zero
040C44 F2 53 0C 04 0207*      jp p,@y_neg_x_pos
040C48             0208*  ; y neg,x neg
040C48             0209*  ; angle is 270-360
040C48             0210*  ; negating the intermediate does the trick
040C48 CD 85 0A 04 0211*      call neg_hlu
040C4C 18 31       0212*      jr @zero_hlu
040C4E             0213*  
040C4E             0214*  @y_neg_x_zero:
040C4E             0215*  ; y neg,x zero
040C4E             0216*  ; angle is 0
040C4E 21 00 00 00 0217*      ld hl,0
040C52 C9          0218*      ret
040C53             0219*  @y_neg_x_pos:
040C53             0220*  ; y neg,x pos
040C53             0221*  ; angle is 0 to 90
040C53             0222*  ; so we're good
040C53 C9          0223*      ret
040C54             0224*  
040C54             0225*  @y_pos:
040C54 F1          0226*      pop af ; sign of x
040C55 CA 64 0C 04 0227*      jp z,@y_pos_x_zero
040C59 F2 69 0C 04 0228*      jp p,@y_pos_x_pos
040C5D             0229*  ; y pos,x neg
040C5D             0230*  ; angle is 180-270
040C5D             0231*  ; so we add 180 to intermediate
040C5D 11 00 80 00 0232*      ld de,0x008000
040C61 19          0233*      add hl,de
040C62 18 1B       0234*      jr @zero_hlu
040C64             0235*  @y_pos_x_zero:
040C64             0236*  ; y pos,x zero
040C64             0237*  ; angle is 180
040C64 21 00 80 00 0238*      ld hl,0x008000
040C68 C9          0239*      ret
040C69             0240*  @y_pos_x_pos:
040C69             0241*  ; y pos,x pos
040C69             0242*  ; angle is 90-180
040C69             0243*  ; neg the intermediate and add 180 degrees
040C69 CD 85 0A 04 0244*      call neg_hlu
040C6D 11 00 80 00 0245*      ld de,0x008000
040C71 19          0246*      add hl,de
040C72 18 0B       0247*      jr @zero_hlu
040C74             0248*  
040C74             0249*  @y_zero:
040C74 F1          0250*      pop af ; sign of x
040C75 FA 7A 0C 04 0251*      jp m,@y_zero_x_neg
040C79             0252*  ; y zero,x pos
040C79             0253*  ; angle is 90,nothing to do
040C79 C9          0254*      ret
040C7A             0255*  @y_zero_x_neg:
040C7A             0256*  ; y zero ,x neg
040C7A             0257*  ; angle is 270
040C7A 21 00 C0 00 0258*      ld hl,0x00C000
040C7E C9          0259*      ret
040C7F             0260*  @zero_hlu:
040C7F AF          0261*      xor a
040C80 22 8D 0C 04 0262*      ld (@scratch),hl
040C84 32 8F 0C 04 0263*      ld (@scratch+2),a
040C88 2A 8D 0C 04 0264*      ld hl,(@scratch)
040C8C C9          0265*      ret
040C8D             0266*  @scratch: ds 6
040C93             0267*  
040C93             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C93             0269*  ; output: uh.l is the 16.8 fixed format angle
040C93             0270*  ; destroys: a,hl,bc,de
040C93             0271*  ; the following note was written by github copilot:
040C93             0272*  ; note: this routine is a bit of a hack
040C93             0273*  ;      but it works
040C93             0274*  ;      and it's fast
040C93             0275*  ;      and it's small
040C93             0276*  ;      and it's accurate
040C93             0277*  ;      and it's easy to understand
040C93             0278*  ;      and it's easy to modify
040C93             0279*  ;      and it's easy to use
040C93             0280*  ;      and it's easy to remember
040C93             0281*  ;      and it's easy to love
040C93             0282*  ;      and it's easy to hate
040C93             0283*  ;      and it's easy to ignore
040C93             0284*  ;      and it's easy to forget
040C93             0285*  ;      and it's easy to remember
040C93             0286*  ;      and it's easy to forget
040C93             0287*  ;      and it's easy to remember
040C93             0288*  ;      (ok the bot is stuck in a loop)
040C93             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
040C93             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
040C93             0291*  atan_168fast:
040C93             0292*  ; because we use compass headings instead of geometric angles
040C93             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040C93             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
040C93 CD 7D 15 04 0295*  	call udiv168 ; ud.e = dx/dy
040C97 EB          0296*  	ex de,hl ; uh.l = dx/dy
040C98             0297*  ; test uh.l for 0
040C98 19          0298*      add hl,de
040C99 B7          0299*      or a
040C9A ED 52       0300*      sbc hl,de
040C9C 28 22       0301*      jr z,@is_zero
040C9E             0302*  ; test uh.l for 1
040C9E AF          0303*      xor a ; clear carry
040C9F EB          0304*      ex de,hl
040CA0 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
040CA4 ED 52       0306*      sbc hl,de
040CA6 28 13       0307*      jr z,@is_45
040CA8 EB          0308*  	ex de,hl
040CA9             0309*  ; no special cases so we move on
040CA9             0310*  ; l contains the fractional portion of tan(uh.l)
040CA9             0311*  ; we multiply it by three to get our lookup table index
040CA9 26 03       0312*      ld h,3
040CAB ED 6C       0313*      mlt hl ; gosh that is handy
040CAD 11 00 00 00 0314*      ld de,0 ; clear deu
040CB1 54          0315*      ld d,h ; copy hl to de
040CB2 5D          0316*      ld e,l ; de contains our index
040CB3 21 B3 10 04 0317*      ld hl,atan_lut_168 ; grab the lut address
040CB7 19          0318*      add hl,de ; bump hl by the index
040CB8 ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
040CBA C9          0320*      ret ; and out
040CBB             0321*  @is_45:
040CBB 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
040CBF C9          0323*      ret
040CC0             0324*  ; for the case tan(0)
040CC0             0325*  @is_zero:
040CC0 21 00 00 00 0326*      ld hl,0x000000
040CC4 C9          0327*      ret
040CC5             0328*  
040CC5             0329*  ; Expects  ADL mode
040CC5             0330*  ; Inputs:  UH.L
040CC5             0331*  ; Outputs: UH.L is the 16.8 square root
040CC5             0332*  ;          UD.E is the difference inputHL-DE^2
040CC5             0333*  ;          c flag reset
040CC5             0334*  sqrt168:
040CC5 CD CF 0C 04 0335*      call sqrt24
040CC9 EB          0336*      ex de,hl
040CCA 29          0337*      add hl,hl
040CCB 29          0338*      add hl,hl
040CCC 29          0339*      add hl,hl
040CCD 29          0340*      add hl,hl
040CCE C9          0341*      ret
040CCF             0342*  
040CCF             0343*  ; Expects  ADL mode
040CCF             0344*  ; Inputs:  HL
040CCF             0345*  ; Outputs: DE is the integer square root
040CCF             0346*  ;          HL is the difference inputHL-DE^2
040CCF             0347*  ;          c flag reset
040CCF             0348*  sqrt24:
040CCF AF          0349*      xor a
040CD0 45          0350*      ld b,l
040CD1 C5          0351*      push bc
040CD2 47          0352*      ld b,a
040CD3 57          0353*      ld d,a
040CD4 4F          0354*      ld c,a
040CD5 6F          0355*      ld l,a
040CD6 5F          0356*      ld e,a
040CD7             0357*  
040CD7             0358*      ;Iteration 1
040CD7 29          0359*      add hl,hl
040CD8 CB 11       0360*      rl c
040CDA 29          0361*      add hl,hl
040CDB CB 11       0362*      rl c
040CDD 91          0363*      sub c
040CDE 30 04       0364*      jr nc,$+6
040CE0 1C          0365*      inc e
040CE1 1C          0366*      inc e
040CE2 2F          0367*      cpl
040CE3 4F          0368*      ld c,a
040CE4             0369*  
040CE4             0370*      ;Iteration 2
040CE4 29          0371*      add hl,hl
040CE5 CB 11       0372*      rl c
040CE7 29          0373*      add hl,hl
040CE8 CB 11       0374*      rl c
040CEA CB 13       0375*      rl e
040CEC 7B          0376*      ld a,e
040CED 91          0377*      sub c
040CEE 30 04       0378*      jr nc,$+6
040CF0 1C          0379*      inc e
040CF1 1C          0380*      inc e
040CF2 2F          0381*      cpl
040CF3 4F          0382*      ld c,a
040CF4             0383*  
040CF4             0384*      ;Iteration 3
040CF4 29          0385*      add hl,hl
040CF5 CB 11       0386*      rl c
040CF7 29          0387*      add hl,hl
040CF8 CB 11       0388*      rl c
040CFA CB 13       0389*      rl e
040CFC 7B          0390*      ld a,e
040CFD 91          0391*      sub c
040CFE 30 04       0392*      jr nc,$+6
040D00 1C          0393*      inc e
040D01 1C          0394*      inc e
040D02 2F          0395*      cpl
040D03 4F          0396*      ld c,a
040D04             0397*  
040D04             0398*      ;Iteration 4
040D04 29          0399*      add hl,hl
040D05 CB 11       0400*      rl c
040D07 29          0401*      add hl,hl
040D08 CB 11       0402*      rl c
040D0A CB 13       0403*      rl e
040D0C 7B          0404*      ld a,e
040D0D 91          0405*      sub c
040D0E 30 04       0406*      jr nc,$+6
040D10 1C          0407*      inc e
040D11 1C          0408*      inc e
040D12 2F          0409*      cpl
040D13 4F          0410*      ld c,a
040D14             0411*  
040D14             0412*      ;Iteration 5
040D14 29          0413*      add hl,hl
040D15 CB 11       0414*      rl c
040D17 29          0415*      add hl,hl
040D18 CB 11       0416*      rl c
040D1A CB 13       0417*      rl e
040D1C 7B          0418*      ld a,e
040D1D 91          0419*      sub c
040D1E 30 04       0420*      jr nc,$+6
040D20 1C          0421*      inc e
040D21 1C          0422*      inc e
040D22 2F          0423*      cpl
040D23 4F          0424*      ld c,a
040D24             0425*  
040D24             0426*      ;Iteration 6
040D24 29          0427*      add hl,hl
040D25 CB 11       0428*      rl c
040D27 29          0429*      add hl,hl
040D28 CB 11       0430*      rl c
040D2A CB 13       0431*      rl e
040D2C 7B          0432*      ld a,e
040D2D 91          0433*      sub c
040D2E 30 04       0434*      jr nc,$+6
040D30 1C          0435*      inc e
040D31 1C          0436*      inc e
040D32 2F          0437*      cpl
040D33 4F          0438*      ld c,a
040D34             0439*  
040D34             0440*      ;Iteration 7
040D34 29          0441*      add hl,hl
040D35 CB 11       0442*      rl c
040D37 29          0443*      add hl,hl
040D38 CB 11       0444*      rl c
040D3A CB 10       0445*      rl b
040D3C EB          0446*      ex de,hl
040D3D 29          0447*      add hl,hl
040D3E E5          0448*      push hl
040D3F ED 42       0449*      sbc hl,bc
040D41 30 06       0450*      jr nc,$+8
040D43 7C          0451*      ld a,h
040D44 2F          0452*      cpl
040D45 47          0453*      ld b,a
040D46 7D          0454*      ld a,l
040D47 2F          0455*      cpl
040D48 4F          0456*      ld c,a
040D49 E1          0457*      pop hl
040D4A 30 02       0458*      jr nc,$+4
040D4C 23          0459*      inc hl
040D4D 23          0460*      inc hl
040D4E EB          0461*      ex de,hl
040D4F             0462*  
040D4F             0463*      ;Iteration 8
040D4F 29          0464*      add hl,hl
040D50 69          0465*      ld l,c
040D51 60          0466*      ld h,b
040D52 ED 6A       0467*      adc hl,hl
040D54 ED 6A       0468*      adc hl,hl
040D56 EB          0469*      ex de,hl
040D57 29          0470*      add hl,hl
040D58 ED 52       0471*      sbc hl,de
040D5A 19          0472*      add hl,de
040D5B EB          0473*      ex de,hl
040D5C 30 04       0474*      jr nc,$+6
040D5E ED 52       0475*      sbc hl,de
040D60 13          0476*      inc de
040D61 13          0477*      inc de
040D62             0478*  
040D62             0479*      ;Iteration 9
040D62 F1          0480*      pop af
040D63 17          0481*      rla
040D64 ED 6A       0482*      adc hl,hl
040D66 17          0483*      rla
040D67 ED 6A       0484*      adc hl,hl
040D69 EB          0485*      ex de,hl
040D6A 29          0486*      add hl,hl
040D6B ED 52       0487*      sbc hl,de
040D6D 19          0488*      add hl,de
040D6E EB          0489*      ex de,hl
040D6F 30 04       0490*      jr nc,$+6
040D71 ED 52       0491*      sbc hl,de
040D73 13          0492*      inc de
040D74 13          0493*      inc de
040D75             0494*  
040D75             0495*      ;Iteration 10
040D75 17          0496*      rla
040D76 ED 6A       0497*      adc hl,hl
040D78 17          0498*      rla
040D79 ED 6A       0499*      adc hl,hl
040D7B EB          0500*      ex de,hl
040D7C 29          0501*      add hl,hl
040D7D ED 52       0502*      sbc hl,de
040D7F 19          0503*      add hl,de
040D80 EB          0504*      ex de,hl
040D81 30 04       0505*      jr nc,$+6
040D83 ED 52       0506*      sbc hl,de
040D85 13          0507*      inc de
040D86 13          0508*      inc de
040D87             0509*  
040D87             0510*      ;Iteration 11
040D87 17          0511*      rla
040D88 ED 6A       0512*      adc hl,hl
040D8A 17          0513*      rla
040D8B ED 6A       0514*      adc hl,hl
040D8D EB          0515*      ex de,hl
040D8E 29          0516*      add hl,hl
040D8F ED 52       0517*      sbc hl,de
040D91 19          0518*      add hl,de
040D92 EB          0519*      ex de,hl
040D93 30 04       0520*      jr nc,$+6
040D95 ED 52       0521*      sbc hl,de
040D97 13          0522*      inc de
040D98 13          0523*      inc de
040D99             0524*  
040D99             0525*      ;Iteration 11
040D99 17          0526*      rla
040D9A ED 6A       0527*      adc hl,hl
040D9C 17          0528*      rla
040D9D ED 6A       0529*      adc hl,hl
040D9F EB          0530*      ex de,hl
040DA0 29          0531*      add hl,hl
040DA1 ED 52       0532*      sbc hl,de
040DA3 19          0533*      add hl,de
040DA4 EB          0534*      ex de,hl
040DA5 30 04       0535*      jr nc,$+6
040DA7 ED 52       0536*      sbc hl,de
040DA9 13          0537*      inc de
040DAA 13          0538*      inc de
040DAB             0539*  
040DAB CB 1A       0540*      rr d
040DAD CB 1B       0541*      rr e
040DAF C9          0542*      ret
040DB0             0543*  
040DB0             0544*  sin_lut_168:
040DB0 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
040DB3 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
040DB6 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
040DB9 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
040DBC 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
040DBF 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
040DC2 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
040DC5 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
040DC8 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
040DCB 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
040DCE 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
040DD1 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
040DD4 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
040DD7 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
040DDA 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
040DDD 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
040DE0 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
040DE3 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
040DE6 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
040DE9 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
040DEC 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
040DEF 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
040DF2 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
040DF5 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
040DF8 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
040DFB 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
040DFE 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
040E01 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
040E04 A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
040E07 A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
040E0A AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
040E0D B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
040E10 B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
040E13 B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
040E16 BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
040E19 C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
040E1C C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
040E1F C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
040E22 CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
040E25 D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
040E28 D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
040E2B D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
040E2E DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
040E31 DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
040E34 E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
040E37 E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
040E3A E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
040E3D EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
040E40 EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
040E43 EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
040E46 F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
040E49 F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
040E4C F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
040E4F F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
040E52 F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
040E55 F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
040E58 FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
040E5B FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
040E5E FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
040E61 FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
040E64 FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
040E67 FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
040E6A FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
040E6D FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
040E70 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
040E73 FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
040E76 FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
040E79 FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
040E7C FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
040E7F FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
040E82 FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
040E85 FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
040E88 FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
040E8B F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
040E8E F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
040E91 F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
040E94 F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
040E97 F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
040E9A F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
040E9D EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
040EA0 EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
040EA3 EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
040EA6 E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
040EA9 E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
040EAC E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
040EAF DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
040EB2 DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
040EB5 D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
040EB8 D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
040EBB D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
040EBE CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
040EC1 C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
040EC4 C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
040EC7 C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
040ECA BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
040ECD B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
040ED0 B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
040ED3 B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
040ED6 AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
040ED9 A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
040EDC A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
040EDF 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
040EE2 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
040EE5 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
040EE8 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
040EEB 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
040EEE 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
040EF1 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
040EF4 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
040EF7 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
040EFA 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
040EFD 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
040F00 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
040F03 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
040F06 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
040F09 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
040F0C 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
040F0F 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
040F12 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
040F15 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
040F18 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
040F1B 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
040F1E 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
040F21 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
040F24 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
040F27 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
040F2A 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
040F2D 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
040F30 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
040F33 FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
040F36 F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
040F39 EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
040F3C E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040F3F E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040F42 DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
040F45 D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
040F48 CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
040F4B C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040F4E C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040F51 BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040F54 B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040F57 B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
040F5A AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
040F5D A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040F60 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
040F63 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
040F66 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
040F69 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
040F6C 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
040F6F 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
040F72 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
040F75 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
040F78 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
040F7B 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
040F7E 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040F81 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040F84 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
040F87 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
040F8A 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
040F8D 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040F90 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040F93 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040F96 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
040F99 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
040F9C 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
040F9F 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
040FA2 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
040FA5 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
040FA8 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
040FAB 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
040FAE 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
040FB1 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
040FB4 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
040FB7 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
040FBA 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
040FBD 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
040FC0 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
040FC3 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
040FC6 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
040FC9 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
040FCC 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
040FCF 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
040FD2 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
040FD5 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
040FD8 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
040FDB 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
040FDE 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
040FE1 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
040FE4 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
040FE7 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
040FEA 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
040FED 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
040FF0 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
040FF3 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
040FF6 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
040FF9 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
040FFC 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
040FFF 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
041002 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
041005 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
041008 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04100B 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04100E 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
041011 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
041014 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
041017 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04101A 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04101D 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
041020 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
041023 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
041026 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
041029 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04102C 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
04102F 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
041032 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
041035 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
041038 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04103B 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
04103E 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
041041 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
041044 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
041047 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04104A 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04104D 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
041050 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
041053 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
041056 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
041059 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04105C 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
04105F 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041062 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
041065 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
041068 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04106B 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
04106E 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041071 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
041074 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
041077 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04107A 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04107D 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
041080 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
041083 A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
041086 AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
041089 B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04108C B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
04108F BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
041092 C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
041095 C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
041098 CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04109B D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04109E DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0410A1 E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0410A4 E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0410A7 EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0410AA F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0410AD FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0410B0 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0410B3             0802*  
0410B3             0803*  atan_lut_168:
0410B3 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
0410B6 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
0410B9 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
0410BC 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
0410BF A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
0410C2 CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
0410C5 F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
0410C8 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
0410CB 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
0410CE 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
0410D1 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
0410D4 BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
0410D7 E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
0410DA 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
0410DD 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
0410E0 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
0410E3 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
0410E6 B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
0410E9 DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
0410EC 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
0410EF 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
0410F2 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
0410F5 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
0410F8 A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
0410FB CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
0410FE F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
041101 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
041104 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
041107 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
04110A 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
04110D C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
041110 E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
041113 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
041116 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
041119 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
04111C 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
04111F B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
041122 D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
041125 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
041128 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
04112B 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
04112E 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
041131 A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
041134 C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
041137 EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
04113A 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
04113D 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
041140 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
041143 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
041146 B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
041149 DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
04114C 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
04114F 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
041152 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
041155 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
041158 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
04115B C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
04115E ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
041161 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
041164 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
041167 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
04116A 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
04116D AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
041170 D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
041173 FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
041176 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
041179 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
04117C 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
04117F 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
041182 BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
041185 E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
041188 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
04118B 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
04118E 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
041191 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
041194 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
041197 C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
04119A E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
04119D 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
0411A0 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
0411A3 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
0411A6 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
0411A9 A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
0411AC C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
0411AF EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
0411B2 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
0411B5 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
0411B8 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
0411BB 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
0411BE A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
0411C1 C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
0411C4 EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
0411C7 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
0411CA 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
0411CD 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
0411D0 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
0411D3 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
0411D6 C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
0411D9 E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
0411DC 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
0411DF 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
0411E2 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
0411E5 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
0411E8 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
0411EB B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
0411EE DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
0411F1 FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
0411F4 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
0411F7 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
0411FA 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
0411FD 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
041200 AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
041203 CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
041206 EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
041209 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
04120C 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
04120F 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
041212 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
041215 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
041218 BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
04121B DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
04121E FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
041221 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
041224 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
041227 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
04122A 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
04122D A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
041230 C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
041233 E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
041236 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
041239 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
04123C 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
04123F 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
041242 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
041245 A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
041248 C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
04124B E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
04124E 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
041251 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
041254 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
041257 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
04125A 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
04125D A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
041260 C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
041263 E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
041266 FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
041269 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
04126C 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
04126F 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
041272 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
041275 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
041278 B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
04127B D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
04127E F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
041281 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
041284 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
041287 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
04128A 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
04128D 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
041290 A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
041293 C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
041296 DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
041299 FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
04129C 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
04129F 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
0412A2 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
0412A5 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
0412A8 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
0412AB A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
0412AE C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
0412B1 E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
0412B4 FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
0412B7 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
0412BA 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
0412BD 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
0412C0 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
0412C3 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
0412C6 A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
0412C9 C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
0412CC DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
0412CF F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
0412D2 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
0412D5 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
0412D8 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
0412DB 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
0412DE 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
0412E1 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
0412E4 B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
0412E7 CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
0412EA E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
0412ED 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
0412F0 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
0412F3 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
0412F6 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
0412F9 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
0412FC 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
0412FF 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
041302 B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
041305 D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
041308 EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
04130B 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
04130E 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
041311 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
041314 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
041317 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
04131A 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
04131D 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
041320 B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
041323 CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
041326 E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
041329 FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
04132C 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
04132F 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
041332 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
041335 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
041338 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
04133B 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
04133E A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
041341 BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
041344 D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
041347 EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
04134A 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
04134D 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
041350 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
041353 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
041356 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
041359 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
04135C 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
04135F A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
041362 BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
041365 D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
041368 E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
04136B FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
04136E 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
041371 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
041374 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
041377 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
04137A 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
04137D 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
041380 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
041383 AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
041386 C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
041389 DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
04138C F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
04138F 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
041392 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
041395 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
041398 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
04139B 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
04139E 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
0413A1 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
0413A4 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
0413A7 AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
0413AA C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
0413AD D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
0413B0 EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
0413B3 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0413B6             0048   	include "fixed24.inc"
0413B6             0001*  arith24uaf: ds 6
0413BC             0002*  arith24uhl: ds 6
0413C2             0003*  arith24ubc: ds 6
0413C8             0004*  arith24ude: ds 6
0413CE             0005*  arith24uix: ds 6
0413D4             0006*  arith24uiy: ds 6
0413DA             0007*  arith24usp: ds 6
0413E0             0008*  arith24upc: ds 6
0413E6             0009*  
0413E6             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
0413E6             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
0413E6             0012*  ; inputs: hlu = 24-bit number to shift
0413E6             0013*  ;         a = signed number of bits to shift
0413E6             0014*  ;         ix = output buffer address
0413E6             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
0413E6             0016*  shift_hlu:
0413E6 C5          0017*      push bc ; preserve
0413E7 47          0018*      ld b,a            ; store shift value in b for later
0413E8             0019*  
0413E8             0020*  ; Initialize DE to zero and clear output buffer
0413E8 11 00 00 00 0021*      ld de, 0
0413EC DD 1F FD    0022*      ld (ix-3), de
0413EF DD 1F 03    0023*      ld (ix+3), de
0413F2             0024*  
0413F2             0025*  ; Get absolute value of a and save its original sign
0413F2 B7          0026*      or a
0413F3 F5          0027*      push af ; save sign flag
0413F4 F2 FA 13 04 0028*      jp p,@F ; If a is positive do nothing
0413F8 ED 44       0029*      neg ; If a is negative, negate it
0413FA             0030*  @@:
0413FA             0031*  
0413FA             0032*  ; Write abs(HLU) to the output buffer and save its original sign
0413FA CD 75 0A 04 0033*      call hlu_abs
0413FE F5          0034*      push af ; save sign of HLU
0413FF DD 2F 00    0035*      ld (ix), hl
041402             0036*  
041402             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
041402 78          0038*      ld a,b            ; Restore original shift value into 'a'
041403 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
041405 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
041407 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
041409 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
04140A             0043*  
04140A             0044*  ; Calculate remainder of a (original shift) mod 8
04140A E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
04140C 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
04140D 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
041411             0048*  
041411             0049*  ; Get back the original sign of the byte shift
041411 F1          0050*      pop af            ; Restore sign flag
041412 F2 20 14 04 0051*      jp p,@F           ; If a was positive, we're done
041416 79          0052*      ld a,c            ; 'a' now holds the number of whole bytes to shift
041417 ED 44       0053*      neg               ; Negate the number of whole bytes to shift
041419 3D          0054*      dec a             ; Subtract 1 because that's just how this works
04141A 4F          0055*      ld c,a            ; 'c' now holds the number of whole bytes to shift
04141B 1B          0056*      dec de            ; DE = -1 to make the signed addition below work
04141C 3E 08       0057*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
04141E 90          0058*      sub b
04141F 47          0059*      ld b,a            ; b is the number of bits to shift back up
041420             0060*  
041420             0061*  @@:
041420             0062*  
041420             0063*  ; Add the byte offset to the base address of output buffer
041420 59          0064*      ld e,c            ; DEU and D were properly signed above
041421 DD 19       0065*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
041423             0066*  
041423             0067*  ; Read the byte-aligned result into HL and shift in the required number of bits
041423 DD 27 00    0068*      ld hl,(ix)        ; Byte-aligned result
041426             0069*  
041426             0070*  ; Check whether we're already byte-aligned
041426 AF          0071*      xor a
041427 B0          0072*      or b
041428 28 08       0073*      jr z,@end         ; If no bits to shift, we're done
04142A             0074*  
04142A             0075*  ; Otherwise shiften zee bitzen
04142A DD 7E FF    0076*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
04142D             0077*  @loop:
04142D 07          0078*      rlca              ; One bit to carry
04142E             0079*  
04142E ED 6A       0080*      adc hl,hl         ; Shift the carry into the result
041430             0081*  
041430 10 FB       0082*      djnz @loop        ; Loop until all bits are shifted up
041432             0083*  
041432             0084*  @end:
041432             0085*  
041432             0086*  ; get back HLU's original sign and negate if necessary
041432 F1          0087*      pop af
041433 F2 3B 14 04 0088*      jp p,@F
041437 CD 85 0A 04 0089*      call neg_hlu
04143B             0090*  @@:
04143B             0091*  ; return the result
04143B DD 2F 00    0092*      ld (ix),hl        ; Store the shifted result
04143E C1          0093*      pop bc              ; Restore BC
04143F C9          0094*      ret
041440             0095*  
041440             0096*  ; operation: UHL * UDE --> UHL
041440             0097*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
041440             0098*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
041440             0099*  ; inputs: hl = 24-bit number, de = 24-bit number,
041440             0100*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
041440             0101*  ; outputs: umulfxout = 48-bit intermediate
041440             0102*  ; destroys: af, hl, bc, de
041440             0103*  umulfx:
041440 DD E5       0104*      push ix ; preserve
041442 F5          0105*      push af ; need later
041443             0106*  
041443             0107*  ; do the multiplication
041443 CD FA 14 04 0108*      call umul24x24
041447             0109*  
041447             0110*  ; shift the result to the required output precision
041447 78          0111*      ld a,b
041448 81          0112*      add a,c ; a is left shift from the multiplication
041449 C1          0113*      pop bc ; b is the output precision (was a)
04144A 90          0114*      sub b ; a is the net shift of the output
04144B             0115*  
04144B             0116*  ; Get absolute value of a and save its original sign
04144B B7          0117*      or a
04144C F5          0118*      push af ; save sign flag
04144D F2 53 14 04 0119*      jp p,@F ; If a is positive do nothing
041451 ED 44       0120*      neg ; If a is negative, negate it
041453             0121*  @@:
041453             0122*  
041453             0123*  ; Divide a by 8 to get the whole byte shift and bit remainder
041453 47          0124*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
041454 CB 3F       0125*      srl a             ; a = a / 2 (shift right 1 bit)
041456 CB 3F       0126*      srl a             ; a = a / 4 (shift right another bit)
041458 CB 3F       0127*      srl a             ; a = a / 8 (final shift for division by 8)
04145A 4F          0128*      ld c,a            ; c holds the number of whole bytes to shift
04145B             0129*  
04145B             0130*  ; Calculate remainder of a (original shift) mod 8
04145B 78          0131*      ld a,b            ; Restore original shift value into 'a'
04145C E6 07       0132*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
04145E 47          0133*      ld b,a            ; 'b' now holds the number of bits to shift back up
04145F 11 00 00 00 0134*      ld de,0           ; Clear deu for computing the offset address later
041463             0135*  
041463             0136*  ; Get back the original sign of the byte shift
041463 F1          0137*      pop af            ; Restore sign flag
041464 F2 72 14 04 0138*      jp p,@F           ; If a was positive, we're done
041468 79          0139*      ld a,c            ; 'a' now holds the number of whole bytes to shift
041469 ED 44       0140*      neg               ; Negate the number of whole bytes to shift
04146B 3D          0141*      dec a             ; Subtract 1 because that's just how this works
04146C 4F          0142*      ld c,a            ; 'c' now holds the number of whole bytes to shift
04146D 1B          0143*      dec de            ; DE = -1 to make the signed addition below work
04146E 3E 08       0144*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
041470 90          0145*      sub b
041471 47          0146*      ld b,a            ; b is the number of bits to shift back up
041472             0147*  
041472             0148*  @@:
041472             0149*  
041472             0150*  ; Add the byte offset to the base address of umulfxout
041472 59          0151*      ld e,c            ; DEU and D were properly signed above
041473 DD 21 8F 14 0152*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
041478 DD 19       0153*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
04147A             0154*  
04147A             0155*  ; Read the byte-aligned result into HL and shift in the required number of bits
04147A DD 27 00    0156*      ld hl,(ix)        ; Byte-aligned result
04147D DD 7E FF    0157*      ld a,(ix-1)       ; One byte below
041480             0158*  
041480             0159*  ; Check whether we're already byte-aligned
041480 AF          0160*      xor a
041481 B0          0161*      or b
041482 28 05       0162*      jr z,@end         ; If no bits to shift, we're done
041484             0163*  
041484             0164*  ; Otherwise shiften zee bitzen
041484             0165*  @loop:
041484             0166*  
041484 07          0167*      rlca              ; One bit to carry
041485 ED 6A       0168*      adc hl,hl         ; Shift the carry into the result
041487             0169*  
041487 10 FB       0170*      djnz @loop        ; Loop until all bits are shifted up
041489             0171*  
041489             0172*  @end:
041489             0173*  ; return the result
041489 DD E1       0174*      pop ix ; restore
04148B C9          0175*      ret
04148C             0176*  
04148C 00 00 00    0177*      dl 0 ; padding
04148F 00 00 00 00 0178*  umulfxout: blkb 6,0
       00 00       
041495 00 00 00    0179*      dl 0 ; padding
041498             0180*  
041498             0181*  ; operation: UHL * UDE --> UHL
041498             0182*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
041498             0183*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
041498             0184*  ; inputs: hl = 24-bit number, de = 24-bit number,
041498             0185*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
041498             0186*  ; outputs: umulfxout = 48-bit intermediate
041498             0187*  ; destroys: af, hl, bc, de
041498             0188*  smulfx:
041498             0189*  ; make everything positive and store sign flags
041498 CD 75 0A 04 0190*  	call hlu_abs
04149C F5          0191*  	push af
04149D EB          0192*  	ex de,hl
04149E CD 75 0A 04 0193*  	call hlu_abs
0414A2 EB          0194*  	ex de,hl
0414A3 F5          0195*  	push af
0414A4             0196*  ; do the division
0414A4 CD 40 14 04 0197*      call umulfx ; hl = product
0414A8             0198*  ; adjust sign of result
0414A8 F1          0199*  	pop af ; sign de
0414A9 FA B4 14 04 0200*  	jp m,@de_neg
0414AD F1          0201*  	pop af ; sign hl
0414AE F0          0202*  	ret p ; both positive, nothing to do
0414AF             0203*  @hl_neg:
0414AF CD 85 0A 04 0204*      call neg_hlu ; de pos, hl neg, result is negative
0414B3 C9          0205*      ret
0414B4             0206*  @de_neg:
0414B4 F1          0207*  	pop af
0414B5 F8          0208*  	ret m ; both negative, nothing to do
0414B6 CD 85 0A 04 0209*  	call neg_hlu ; result is negative
0414BA C9          0210*  	ret
0414BB             0211*  
0414BB             0212*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0414BB             0213*  ; uses EZ80 MLT instruction for speed
0414BB             0214*  ; operation: UHL * A --> UHL
0414BB             0215*  ; destroys: AF, HL
0414BB             0216*  smul24x8:
0414BB             0217*  ; make hl positive and store sign flag
0414BB CD 75 0A 04 0218*  	call hlu_abs
0414BF F5          0219*  	push af
0414C0             0220*  ; do the division
0414C0 CD CB 14 04 0221*      call umul24x8 ; hl = product
0414C4             0222*  ; adjust sign of result
0414C4 F1          0223*  	pop af ; sign de
0414C5 F0          0224*  	ret p ; hl was positive, nothing to do
0414C6 CD 85 0A 04 0225*  	call neg_hlu ; result is negative
0414CA C9          0226*  	ret
0414CB             0227*  
0414CB             0228*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0414CB             0229*  ; uses EZ80 MLT instruction for speed
0414CB             0230*  ; operation: UHL * A --> AUHL
0414CB             0231*  ; destroys: AF, HL
0414CB             0232*  umul24x8:
0414CB D5          0233*  	push de ; preserve de
0414CC             0234*  ; low byte
0414CC 5D          0235*  	ld e,l
0414CD 57          0236*  	ld d,a
0414CE ED 5C       0237*  	mlt de
0414D0 6B          0238*  	ld l,e ; product low byte
0414D1 08          0239*  	ex af,af' ; save multiplier
0414D2 7A          0240*  	ld a,d ; carry
0414D3 08          0241*  	ex af,af' ; save carry, restore multiplier
0414D4             0242*  ; high byte
0414D4 5C          0243*  	ld e,h
0414D5 57          0244*  	ld d,a
0414D6 ED 5C       0245*  	mlt de
0414D8 08          0246*  	ex af,af' ; save multiplier, restore carry
0414D9 83          0247*  	add a,e ; add carry
0414DA 67          0248*  	ld h,a ; product middle byte
0414DB 7A          0249*  	ld a,d ; carry
0414DC 08          0250*  	ex af,af' ; save carry, restore multiplier
0414DD             0251*  ; upper byte
0414DD E5          0252*  	push hl
0414DE 33          0253*  	inc sp
0414DF D1          0254*  	pop de ; d = hlu
0414E0 3B          0255*  	dec sp
0414E1 5F          0256*  	ld e,a
0414E2 ED 5C       0257*  	mlt de
0414E4 08          0258*  	ex af,af' ; restore carry
0414E5 8B          0259*  	adc a,e ; add carry
0414E6 22 F7 14 04 0260*      ld (@scratch),hl ; 7 cycles
0414EA 32 F9 14 04 0261*      ld (@scratch+2),a ; 5 cycles
0414EE 2A F7 14 04 0262*      ld hl,(@scratch) ; 7 cycles
0414F2             0263*  ; highest byte
0414F2 3E 00       0264*  	ld a,0 ; preserve carry flag
0414F4 8A          0265*  	adc a,d ; product highest byte
0414F5 D1          0266*  	pop de ; restore de
0414F6 C9          0267*  	ret
0414F7             0268*  @scratch: ds 3
0414FA             0269*  
0414FA             0270*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0414FA             0271*  ; operation: UHL * UDE --> umulfxout
0414FA             0272*  umul24x24:
0414FA FD 21 8F 14 0273*  	ld iy,umulfxout ; point to output buffer
       04          
0414FF C5          0274*  	push bc
041500 01 00 00 00 0275*  	ld bc,0
041504 FD 0F 00    0276*  	ld (iy),bc
041507 FD 0F 03    0277*  	ld (iy+3),bc
04150A C1          0278*  	pop bc
04150B             0279*  
04150B             0280*  ; STEP 1: UHL * E
04150B 7B          0281*  	ld a,e
04150C E5          0282*  	push hl
04150D CD CB 14 04 0283*  	call umul24x8
041511 FD 2F 00    0284*  	ld (iy+0),hl
041514 FD 77 03    0285*  	ld (iy+3),a
041517             0286*  
041517             0287*  ; STEP 2: UHL * D
041517 E1          0288*  	pop hl
041518 E5          0289*  	push hl
041519 7A          0290*  	ld a,d
04151A CD CB 14 04 0291*  	call umul24x8
04151E CD 2B 15 04 0292*  	call @accumulate
041522             0293*  
041522             0294*  ; STEP 3: UHL * DEU
041522 E1          0295*  	pop hl
041523 D5          0296*  	push de
041524 33          0297*  	inc sp
041525 F1          0298*  	pop af
041526 3B          0299*  	dec sp
041527 CD CB 14 04 0300*  	call umul24x8
04152B             0301*  
04152B             0302*  @accumulate:
04152B FD 23       0303*  	inc iy
04152D             0304*  ; highest byte of product to carry
04152D FD 77 03    0305*  	ld (iy+3),a
041530             0306*  ; low byte of product
041530 7D          0307*  	ld a,l
041531 FD 86 00    0308*  	add a,(iy+0)
041534 FD 77 00    0309*  	ld (iy+0),a
041537             0310*  ; high byte of product
041537 7C          0311*  	ld a,h
041538 FD 8E 01    0312*  	adc a,(iy+1)
04153B FD 77 01    0313*  	ld (iy+1),a
04153E             0314*  ; uppper byte of product
04153E E5          0315*  	push hl
04153F 33          0316*  	inc sp
041540 E1          0317*  	pop hl
041541 3B          0318*  	dec sp
041542 7C          0319*  	ld a,h
041543 FD 8E 02    0320*  	adc a,(iy+2)
041546 FD 77 02    0321*  	ld (iy+2),a
041549             0322*  ; carry
041549 3E 00       0323*  	ld a,0 ; preserve flags
04154B FD 8E 03    0324*  	adc a,(iy+3)
04154E FD 77 03    0325*  	ld (iy+3),a
041551 C9          0326*  	ret
041552             0327*  
041552             0328*  ; UH.L = UH.L*UD.E (unsigned)
041552             0329*  umul168:
041552 CD FA 14 04 0330*  	call umul24x24
041556 FD 27 FF    0331*  	ld hl,(iy-1)
041559 C9          0332*  	ret
04155A             0333*  
04155A             0334*  ; UH.L * UD.E --> UH.L (signed)
04155A             0335*  smul168:
04155A             0336*  ; make everything positive and store sign flags
04155A CD 75 0A 04 0337*  	call hlu_abs
04155E F5          0338*  	push af
04155F EB          0339*  	ex de,hl
041560 CD 75 0A 04 0340*  	call hlu_abs
041564 EB          0341*  	ex de,hl
041565 F5          0342*  	push af
041566             0343*  ; do the division
041566 CD 52 15 04 0344*      call umul168 ; hl = product
04156A             0345*  ; adjust sign of result
04156A F1          0346*  	pop af ; sign de
04156B FA 76 15 04 0347*  	jp m,@de_neg
04156F F1          0348*  	pop af ; sign hl
041570 F0          0349*  	ret p ; both positive, nothing to do
041571             0350*  @hl_neg:
041571 CD 85 0A 04 0351*      call neg_hlu ; de pos, hl neg, result is negative
041575 C9          0352*      ret
041576             0353*  @de_neg:
041576 F1          0354*  	pop af
041577 F8          0355*  	ret m ; both negative, nothing to do
041578 CD 85 0A 04 0356*  	call neg_hlu ; result is negative
04157C C9          0357*  	ret
04157D             0358*  
04157D             0359*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
04157D             0360*  ; perform unsigned division of 16.8 fixed place values
04157D             0361*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
04157D             0362*  udiv168:
04157D             0363*  ; back up divisor
04157D ED 53 B4 15 0364*  	ld (@ude),de
       04          
041582             0365*  ; get the 16-bit integer part of the quotient
041582 CD E5 15 04 0366*      call udiv24 ; de = quotient, hl = remainder
041586             0367*  ; load quotient to upper three bytes of output
041586 ED 53 BB 15 0368*      ld (div168_out+1),de
       04          
04158B             0369*  @div256:
04158B             0370*  ; multiply remainder by 256
04158B             0371*  	hlu_mul256
04158B 29          0001*M         add hl,hl ; * 2
04158C 29          0002*M         add hl,hl ; * 4
04158D 29          0003*M         add hl,hl ; * 8
04158E 29          0004*M         add hl,hl ; * 16
04158F 29          0005*M         add hl,hl ; * 32
041590 29          0006*M         add hl,hl ; * 64
041591 29          0007*M         add hl,hl ; * 128
041592 29          0008*M         add hl,hl ; * 256
041593             0372*  ; skip fractional computation if remainder is zero
041593             0373*      sign_hlu
041593 19          0001*M         add hl,de
041594 B7          0002*M         or a
041595 ED 52       0003*M         sbc hl,de
041597 20 03       0374*      jr nz,@div_frac
041599 AF          0375*      xor a
04159A 18 0A       0376*      jr @write_frac
04159C             0377*  ; now divide the shifted remainder by the divisor
04159C             0378*  @div_frac:
04159C ED 5B B4 15 0379*  	ld de,(@ude) ; get back divisor
       04          
0415A1 CD E5 15 04 0380*      call udiv24 ; de = quotient, hl = remainder
0415A5             0381*  ; load low byte of quotient to low byte of output
0415A5 7B          0382*      ld a,e
0415A6             0383*  @write_frac:
0415A6 32 BA 15 04 0384*      ld (div168_out),a
0415AA             0385*  ; load de with return value
0415AA ED 5B BA 15 0386*      ld de,(div168_out)
       04          
0415AF             0387*  ; load a with any overflow
0415AF 3A BD 15 04 0388*      ld a,(div168_out+3)
0415B3 C9          0389*      ret ; ud.e is the 16.8 result
0415B4             0390*  @ude: ds 6
0415BA             0391*  div168_out: ds 4 ; the extra byte is for overflow
0415BE             0392*  
0415BE             0393*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0415BE             0394*  ; perform signed division of 16.8 fixed place values
0415BE             0395*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0415BE             0396*  sdiv168:
0415BE             0397*  ; make everything positive and store sign flags
0415BE CD 75 0A 04 0398*  	call hlu_abs
0415C2 F5          0399*  	push af
0415C3 EB          0400*  	ex de,hl
0415C4 CD 75 0A 04 0401*  	call hlu_abs
0415C8 EB          0402*  	ex de,hl
0415C9 F5          0403*  	push af
0415CA             0404*  ; do the division
0415CA CD 7D 15 04 0405*      call udiv168 ; de = quotient, hl = remainder
0415CE             0406*  ; adjust sign of result
0415CE F1          0407*  	pop af ; sign de
0415CF FA DC 15 04 0408*  	jp m,@de_neg
0415D3 F1          0409*  	pop af ; sign hl
0415D4 F0          0410*  	ret p ; both positive, nothing to do
0415D5             0411*  @hl_neg:
0415D5 EB          0412*      ex de,hl ; hl = quotient, de = remainder
0415D6 CD 85 0A 04 0413*      call neg_hlu ; de pos, hl neg, result is negative
0415DA EB          0414*      ex de,hl ; de = negated quotient, hl = remainder
0415DB C9          0415*      ret
0415DC             0416*  @de_neg:
0415DC F1          0417*  	pop af
0415DD F8          0418*  	ret m ; both negative, nothing to do
0415DE EB          0419*      ex de,hl ; hl = quotient, de = remainder
0415DF CD 85 0A 04 0420*  	call neg_hlu ; result is negative
0415E3 EB          0421*      ex de,hl ; de = negated quotient, hl = remainder
0415E4 C9          0422*  	ret
0415E5             0423*  
0415E5             0424*  ;------------------------------------------------------------------------
0415E5             0425*  ;  arith24.asm
0415E5             0426*  ;  24-bit ez80 arithmetic routines
0415E5             0427*  ;  Copyright (c) Shawn Sijnstra 2024
0415E5             0428*  ;  MIT license
0415E5             0429*  ;
0415E5             0430*  ;  This library was created as a tool to help make ez80
0415E5             0431*  ;  24-bit native assembly routines for simple mathematical problems
0415E5             0432*  ;  more widely available.
0415E5             0433*  ;
0415E5             0434*  ;------------------------------------------------------------------------
0415E5             0435*  ;
0415E5             0436*  ;------------------------------------------------------------------------
0415E5             0437*  ; udiv24
0415E5             0438*  ; Unsigned 24-bit division
0415E5             0439*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0415E5             0440*  ;
0415E5             0441*  ; Uses AF BC DE HL
0415E5             0442*  ; Uses Restoring Division algorithm
0415E5             0443*  ;------------------------------------------------------------------------
0415E5             0444*  
0415E5             0445*  udiv24:
0415E5 E5          0446*  	push	hl
0415E6 C1          0447*  	pop		bc	;move dividend to BCU
0415E7 21 00 00 00 0448*  	ld		hl,0	;result
0415EB A7          0449*  	and		a
0415EC ED 52       0450*  	sbc		hl,de	;test for div by 0
0415EE C8          0451*  	ret		z		;it's zero, carry flag is clear
0415EF 19          0452*  	add		hl,de	;HL is 0 again
0415F0 3E 18       0453*  	ld		a,24	;number of loops through.
0415F2             0454*  udiv1:
0415F2 C5          0455*  	push	bc	;complicated way of doing this because of lack of access to top bits
0415F3 E3          0456*  	ex		(sp),hl
0415F4 37          0457*  	scf
0415F5 ED 6A       0458*  	adc	hl,hl
0415F7 E3          0459*  	ex	(sp),hl
0415F8 C1          0460*  	pop	bc		;we now have bc = (bc * 2) + 1
0415F9             0461*  
0415F9 ED 6A       0462*  	adc	hl,hl
0415FB A7          0463*  	and	a		;is this the bug
0415FC ED 52       0464*  	sbc	hl,de
0415FE 30 02       0465*  	jr	nc,udiv2
041600 19          0466*  	add	hl,de
041601             0467*  ;	dec	c
041601 0B          0468*  	dec	bc
041602             0469*  udiv2:
041602 3D          0470*  	dec	a
041603 20 ED       0471*  	jr	nz,udiv1
041605 37          0472*  	scf		;flag used for div0 error
041606 C5          0473*  	push	bc
041607 D1          0474*  	pop		de	;remainder
041608 C9          0475*  	ret
041609             0049   	include "files.inc"
041609             0001*  ; load to onboard 8k sram
041609             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
041609             0050       include "timer.inc"
041609             0001*  ; Table 32. Timer Control Registers
041609             0002*  ; this constant is the base address of the timer control registers
041609             0003*  ; each timer takes three bytes:
041609             0004*  ;   0: control register
041609             0005*  ;   1: low byte of timer reset value
041609             0006*  ;   2: high byte of timer reset value
041609             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041609             0008*  ; which correctly force the high and upper bytes of the address bus to zero
041609             0009*  TMR_CTL:     equ 80h
041609             0010*  
041609             0011*  ; Timer Control Register Bit Definitions
041609             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041609             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
041609             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041609             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
041609             0016*                              ; the TMRx_CTL register is read.
041609             0017*  
041609             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041609             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041609             0020*  
041609             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041609             0022*                              ;  0,and counting stops when the end-of-count value is reached.
041609             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041609             0024*                              ; written to the counter when the end-of-count value is reached.
041609             0025*  
041609             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041609             0027*  CLK_DIV_256:  equ %00001100 ;
041609             0028*  CLK_DIV_64:   equ %00001000 ;
041609             0029*  CLK_DIV_16:   equ %00000100 ;
041609             0030*  CLK_DIV_4:    equ %00000000 ;
041609             0031*  
041609             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041609             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041609             0034*                              ; When a 1 is written to this bit,the values in the reload registers
041609             0035*                              ;  are loaded into the downcounter when the timer restarts. The
041609             0036*                              ; programmer must ensure that this bit is set to 1 each time
041609             0037*                              ; SINGLE-PASS mode is used.
041609             0038*  
041609             0039*  ; disable/enable the programmable reload timer
041609             0040*  PRT_EN_0:     equ %00000000 ;
041609             0041*  PRT_EN_1:     equ %00000001 ;
041609             0042*  
041609             0043*  ; Table 37. Timer Input Source Select Register
041609             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
041609             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041609             0046*  ;   00: System clock / CLK_DIV
041609             0047*  ;   01: RTC / CLK_DIV
041609             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
041609             0049*  ;   10: GPIO port B pin 1.
041609             0050*  ;   11: GPIO port B pin 1.
041609             0051*  TMR_ISS:   equ 92h ; register address
041609             0052*  
041609             0053*  ; Table 51. Real-Time Clock Control Register
041609             0054*  RTC_CTRL: equ EDh ; register address
041609             0055*  
041609             0056*  ; alarm interrupt disable/enable
041609             0057*  RTC_ALARM_0:    equ %00000000
041609             0058*  RTC_ALARM_1:    equ %10000000
041609             0059*  
041609             0060*  ; interrupt on alarm disable/enable
041609             0061*  RTC_INT_ENT_0:  equ %00000000
041609             0062*  RTC_INT_ENT_1:  equ %01000000
041609             0063*  
041609             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041609             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041609             0066*  
041609             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041609             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
041609             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041609             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
041609             0071*  
041609             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041609             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041609             0074*  
041609             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041609             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041609             0077*  
041609             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041609             0079*                                  ; RTC counter is enabled.
041609             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041609             0081*                                  ; RTC counter is disabled.
041609             0082*  
041609             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041609             0084*  
041609             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041609             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041609 00 00 00    0087*  prt_reload: dl 0x000000
04160C             0088*  
04160C             0089*  ; set PRT timer
04160C             0090*  prt_set:
04160C 21 00 00 00 0091*      ld hl,0
041610 22 5A 16 04 0092*      ld (prt_irq_counter),hl
041614 2A 09 16 04 0093*      ld hl,(prt_reload)
041618 ED 29 84    0094*      out0 ($84),l
04161B ED 21 85    0095*  	out0 ($85),h
04161E             0096*  ; disable timer
04161E 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041620 ED 39 83    0098*  	out0 ($83),a
041623             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041623 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041625 ED 39 83    0101*  	out0 ($83),a
041628 C9          0102*      ret
041629             0103*  
041629             0104*  ; ===============================================
041629             0105*  ; PRT Timer Interrupt Handling
041629             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
041629             0107*  ; -----------------------------------------------
041629             0108*  prt_irq_init:
041629             0109*      ; set up interrupt vector table 2
041629 21 00 00 00 0110*  	ld hl,0
04162D 3A 0C 01 00 0111*  	ld a,($10c)
041631 6F          0112*  	ld l,a
041632 3A 0D 01 00 0113*  	ld a,($10d)
041636 67          0114*  	ld h,a
041637             0115*  
041637             0116*  	; skip over CALL ($c3)
041637 23          0117*  	inc hl
041638             0118*  	; load address of jump into vector table 2 (in ram)
041638 ED 27       0119*  	ld hl,(hl)
04163A             0120*  
04163A             0121*  	; write CALL prt_irq_handler to vector table 2
04163A 3E C3       0122*  	ld a,$c3
04163C 77          0123*  	ld (hl),a
04163D 23          0124*  	inc hl
04163E 11 45 16 04 0125*  	ld de,prt_irq_handler
041642 ED 1F       0126*  	ld (hl),de
041644             0127*  
041644 C9          0128*      ret
041645             0129*  
041645             0130*  prt_irq_handler:
041645 F3          0131*  	di
041646 F5          0132*  	push af
041647 E5          0133*      push hl
041648 ED 38 83    0134*  	in0 a,($83)
04164B 2A 5A 16 04 0135*  	ld hl,(prt_irq_counter)
04164F 23          0136*  	inc hl
041650 22 5A 16 04 0137*  	ld (prt_irq_counter),hl
041654 E1          0138*      pop hl
041655 F1          0139*  	pop af
041656 FB          0140*  	ei
041657 5B ED 4D    0141*  	reti.l
04165A             0142*  
04165A             0143*  prt_irq_counter:
04165A 00 00 00    0144*  	.dl 0
04165D             0145*  prt_irq_counter_saved:
04165D 00 00 00    0146*      .dl 0
041660             0147*  
041660             0148*  prt_loop_reset:
041660 E5          0149*      push hl
041661 21 00 00 00 0150*  	ld hl,0
041665 22 5A 16 04 0151*  	ld (prt_irq_counter),hl
041669 22 CB 16 04 0152*      ld (prt_loop_counter),hl
04166D 22 CE 16 04 0153*      ld (prt_loops),hl
041671 CD 0C 16 04 0154*      call prt_set
041675 E1          0155*      pop hl
041676 C9          0156*      ret
041677             0157*  
041677             0158*  prt_loop_start:
041677 E5          0159*      push hl
041678 21 00 00 00 0160*  	ld hl,0
04167C 22 5A 16 04 0161*  	ld (prt_irq_counter),hl
041680 E1          0162*      pop hl
041681 C9          0163*      ret
041682             0164*  
041682             0165*  prt_loop_stop:
041682 E5          0166*      push hl
041683 D5          0167*      push de
041684 2A 5A 16 04 0168*      ld hl,(prt_irq_counter)
041688 ED 5B CB 16 0169*      ld de,(prt_loop_counter)
       04          
04168D 19          0170*      add hl,de
04168E 22 CB 16 04 0171*      ld (prt_loop_counter),hl
041692 21 00 00 00 0172*      ld hl,0
041696 22 5A 16 04 0173*      ld (prt_irq_counter),hl
04169A 2A CE 16 04 0174*      ld hl,(prt_loops)
04169E 23          0175*      inc hl
04169F 22 CE 16 04 0176*      ld (prt_loops),hl
0416A3 D1          0177*      pop de
0416A4 E1          0178*      pop hl
0416A5 C9          0179*      ret
0416A6             0180*  
0416A6             0181*  ; inputs: bc = y,x text coordinates to print
0416A6             0182*  prt_loop_print:
0416A6 F5          0183*      push af
0416A7 E5          0184*      push hl
0416A8 C5          0185*      push bc
0416A9 D5          0186*      push de
0416AA DD E5       0187*      push ix
0416AC FD E5       0188*      push iy
0416AE CD C5 06 04 0189*      call vdu_move_cursor
0416B2             0190*  
0416B2 2A CB 16 04 0191*      ld hl,(prt_loop_counter)
0416B6 CD 76 01 04 0192*      call printDec
0416BA             0193*  
0416BA 2A CE 16 04 0194*      ld hl,(prt_loops)
0416BE CD 76 01 04 0195*      call printDec
0416C2             0196*  
0416C2 FD E1       0197*      pop iy
0416C4 DD E1       0198*      pop ix
0416C6 D1          0199*      pop de
0416C7 C1          0200*      pop bc
0416C8 E1          0201*      pop hl
0416C9 F1          0202*      pop af
0416CA C9          0203*      ret
0416CB             0204*  
0416CB             0205*  prt_loop_counter:
0416CB 00 00 00    0206*      .dl 0
0416CE             0207*  prt_loops:
0416CE 00 00 00    0208*      .dl 0
0416D1             0209*  
0416D1             0210*  ; ===============================================
0416D1             0211*  ; Timer functions
0416D1             0212*  ; -----------------------------------------------
0416D1             0213*  ; set a countdown timer
0416D1             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0416D1             0215*  ; returns: hl = current time
0416D1             0216*  tmr_set:
0416D1 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0416D4             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0416D4 3E 08       0001*M 			LD	A, function
0416D6 5B CF       0002*M 			RST.LIL	08h
0416D8 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0416DB FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0416DE C9          0221*      ret
0416DF             0222*  
0416DF             0223*  ; gets time remaining on a countdown timer
0416DF             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0416DF             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0416DF             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0416DF             0227*  tmr_get:
0416DF             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0416DF 3E 08       0001*M 			LD	A, function
0416E1 5B CF       0002*M 			RST.LIL	08h
0416E3 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0416E6 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0416E9 AF          0231*      xor a                   ; clear carry
0416EA ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0416EC FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0416EF AF          0234*      xor a                   ; clear carry
0416F0 ED 5A       0235*      adc hl,de               ; hl = time remaining
0416F2             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0416F2 C9          0237*      ret
0416F3             0238*  
0416F3             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0416F9             0240*  
0416F9 00 00 00    0241*  timestamp_now: dl 0
0416FC 00 00 00    0242*  timestamp_old: dl 0
0416FF 00 00 00    0243*  timestamp_chg: dl 0
041702             0244*  
041702             0245*  ; update the global timestamp from the system clock
041702             0246*  ; inputs: none
041702             0247*  ; returns: hl = time elapsed in 1/120ths of a second
041702             0248*  ;          de = current time
041702             0249*  ;          ix = pointer to syvars table
041702             0250*  ; destroys: af,hl,de,ix
041702             0251*  timestamp_tick:
041702 ED 5B F9 16 0252*      ld de,(timestamp_now)   ; get previous time
       04          
041707 ED 53 FC 16 0253*      ld (timestamp_old),de   ; save previous time
       04          
04170C             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
04170C 3E 08       0001*M 			LD	A, function
04170E 5B CF       0002*M 			RST.LIL	08h
041710 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
041713 22 F9 16 04 0256*      ld (timestamp_now),hl   ; save current time
041717 AF          0257*      xor a                   ; clear carry
041718 ED 52       0258*      sbc hl,de               ; hl = time elapsed
04171A 22 FF 16 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
04171E C9          0260*      ret
04171F             0261*  
04171F             0262*  ; set a countdown timer
04171F             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04171F             0264*  ; requires: timestamp_tick to be called at least once before this function
04171F             0265*  ; returns: hl = current time
04171F             0266*  ; destroys: hl
04171F             0267*  timestamp_tmr_set:
04171F FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
041722 2A F9 16 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
041726 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
041729 C9          0271*      ret
04172A             0272*  
04172A             0273*  ; gets time remaining on a countdown timer following the global timestamp
04172A             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04172A             0275*  ; requires: timestamp_tick to be called at least once before this function
04172A             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04172A             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
04172A             0278*  ; destroys: af,hl,de
04172A             0279*  timestamp_tmr_get:
04172A ED 5B F9 16 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
04172F FD 27 00    0281*      ld hl,(iy+0)            ; get start time
041732 AF          0282*      xor a                   ; clear carry
041733 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041735 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
041738 AF          0285*      xor a                   ; clear carry
041739 ED 5A       0286*      adc hl,de               ; hl = time remaining
04173B             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04173B C9          0288*      ret
04173C             0289*  
04173C             0290*  ; set a stopwatch
04173C             0291*  ; returns: hl = start time
04173C             0292*  ; destroys: hl,ix
04173C             0293*  stopwatch_set:
04173C             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
04173C 3E 08       0001*M 			LD	A, function
04173E 5B CF       0002*M 			RST.LIL	08h
041740 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
041743 22 58 17 04 0296*      ld (stopwatch_started),hl            ; set start time
041747 C9          0297*      ret
041748             0298*  
041748             0299*  ; gets time elapsed on a stopwatch
041748             0300*  ; returns: hl = time elapsed in 1/120ths of a second
041748             0301*  ; destroys: af,hl,de,ix
041748             0302*  stopwatch_get:
041748             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
041748 3E 08       0001*M 			LD	A, function
04174A 5B CF       0002*M 			RST.LIL	08h
04174C DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
04174F ED 5B 58 17 0305*      ld de,(stopwatch_started)            ; get start time
       04          
041754 AF          0306*      xor a                   ; clear carry
041755 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041757 C9          0308*      ret
041758             0309*  
041758             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04175B             0311*  
04175B             0312*  ; ------------------
04175B             0313*  ; delay routine
04175B             0314*  ; Author: Richard Turrnidge
04175B             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04175B             0316*  ; routine waits a fixed time,then returns
04175B             0317*  ; arrive with A =  the delay byte. One bit to be set only.
04175B             0318*  ; eg. ld A,00000100b
04175B             0319*  
04175B             0320*  multiPurposeDelay:
04175B F5          0321*      push af
04175C C5          0322*      push bc
04175D DD E5       0323*      push ix
04175F 47          0324*      ld b,a
041760 3E 08       0325*      ld a,$08
041762 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
041764             0327*  
041764             0328*  waitLoop:
041764             0329*  
041764 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041767             0331*  
041767             0332*                                  ;   we check if bit set is same as last time we checked.
041767             0333*                                  ;   bit 0 - don't use
041767             0334*                                  ;   bit 1 - changes 64 times per second
041767             0335*                                  ;   bit 2 - changes 32 times per second
041767             0336*                                  ;   bit 3 - changes 16 times per second
041767             0337*  
041767             0338*                                  ;   bit 4 - changes 8 times per second
041767             0339*                                  ;   bit 5 - changes 4 times per second
041767             0340*                                  ;   bit 6 - changes 2 times per second
041767             0341*                                  ;   bit 7 - changes 1 times per second
041767 A0          0342*      and b
041768 4F          0343*      ld c,a
041769 3A 7A 17 04 0344*      ld a,(oldTimeStamp)
04176D B9          0345*      cp c                        ; is A same as last value?
04176E 28 F4       0346*      jr z,waitLoop              ; loop here if it is
041770 79          0347*      ld a,c
041771 32 7A 17 04 0348*      ld (oldTimeStamp),a        ; set new value
041775             0349*  
041775 DD E1       0350*      pop ix
041777 C1          0351*      pop bc
041778 F1          0352*      pop af
041779 C9          0353*      ret
04177A             0354*  
04177A 00          0355*  oldTimeStamp:   .db 00h
04177B             0051   
04177B             0052   ; --- INITIALIZATION ---
04177B             0053   init:
04177B C9          0054       ret
04177C             0055   
04177C             0056   ; --- MAIN PROGRAM ---
04177C             0057   main:
04177C FD 21 F3 16 0058       ld iy,tmr_test
       04          
041781 21 78 00 00 0059       ld hl,120 ; 10 seconds
041785 CD D1 16 04 0060       call tmr_set
041789 21 00 00 00 0061       ld hl,0
04178D E5          0062       push hl
04178E CD 4D 07 04 0063       call vdu_vblank
041792             0064   @loop:
041792 21 FF FF 00 0065       ld hl,65535
041796 11 FF 03 00 0066       ld de,1023
04179A CD E5 15 04 0067       call udiv24
04179E E1          0068       pop hl
04179F 23          0069       inc hl
0417A0 E5          0070       push hl
0417A1 FD 21 F3 16 0071       ld iy,tmr_test
       04          
0417A6 CD DF 16 04 0072       call tmr_get
0417AA F2 92 17 04 0073       jp p,@loop
0417AE E1          0074       pop hl
0417AF CD 76 01 04 0075       call printDec
0417B3 CD 8C 00 04 0076       call printNewLine
0417B7             0077   
0417B7             0078   fast_div:
0417B7 FD 21 F3 16 0079       ld iy,tmr_test
       04          
0417BC 21 78 00 00 0080       ld hl,120 ; 10 seconds
0417C0 CD D1 16 04 0081       call tmr_set
0417C4 21 00 00 00 0082       ld hl,0
0417C8 E5          0083       push hl
0417C9 CD 4D 07 04 0084       call vdu_vblank
0417CD             0085   @loop:
0417CD 21 FF FF 00 0086       ld hl,65535
0417D1 0E 80       0087       ld c,128
0417D3 CD F1 17 04 0088       call HL_Div_C
0417D7 E1          0089       pop hl
0417D8 23          0090       inc hl
0417D9 E5          0091       push hl
0417DA FD 21 F3 16 0092       ld iy,tmr_test
       04          
0417DF CD DF 16 04 0093       call tmr_get
0417E3 F2 CD 17 04 0094       jp p,@loop
0417E7 E1          0095       pop hl
0417E8 CD 76 01 04 0096       call printDec
0417EC CD 8C 00 04 0097       call printNewLine
0417F0             0098   
0417F0 C9          0099       ret
0417F1             0100   
0417F1             0101   HL_Div_C:
0417F1             0102      ;Inputs:
0417F1             0103      ;     HL is the numerator
0417F1             0104      ;     C is the denominator
0417F1             0105      ;Outputs:
0417F1             0106      ;     A is the remainder
0417F1             0107      ;     B is 0
0417F1             0108      ;     C is not changed
0417F1             0109      ;     DE is not changed
0417F1             0110      ;     HL is the quotient
0417F1             0111      ;
0417F1 06 10       0112             ld b,16
0417F3 AF          0113             xor a
0417F4 29          0114               add hl,hl
0417F5 17          0115               rla
0417F6 B9          0116               cp c
0417F7 38 02       0117               jr c,$+4
0417F9 2C          0118                 inc l
0417FA 91          0119                 sub c
0417FB 10 F7       0120               djnz $-7
0417FD C9          0121             ret
