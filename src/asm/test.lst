PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000 C3 45 00 04 0003       jp start
040004 FF FF FF FF 0004       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005       db "MOS"
040043 00          0006       db 00h
040044 01          0007       db 01h
040045             0008   
040045             0009   start:
040045 F5          0010       push af
040046 C5          0011       push bc
040047 D5          0012       push de
040048 DD E5       0013       push ix
04004A FD E5       0014       push iy
04004C CD 44 1D 04 0015       call init
040050 CD 4E 1D 04 0016       call main
040054             0017   
040054             0018   exit:
040054 FD E1       0019       pop iy
040056 DD E1       0020       pop ix
040058 D1          0021       pop de
040059 C1          0022       pop bc
04005A F1          0023       pop af
04005B 21 00 00 00 0024       ld hl,0
04005F             0025   
04005F C9          0026       ret
040060             0027   
040060             0028   ; API INCLUDES
040060             0029       include "mos_api.inc"
040060             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*  ; Title:	AGON MOS - API for user projects
040060             0003*  ; Author:	Dean Belfield
040060             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*  ;			Added MOS error codes for return in HL
040060             0006*  ; Created:	03/08/2022
040060             0007*  ; Last Updated:	10/08/2023
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 05/08/2022:	Added mos_feof
040060             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*  ; 13/10/2022:	Added mos_oscli
040060             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*  ; 19/05/2023:	Added sysvar_scrMode
040060             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*  ; 03/08/2023:	Added mos_setkbvector
040060             0028*  ; 10/08/2023:	Added mos_getkbmap
040060             0029*  
040060             0030*  ; VDP control (VDU 23, 0, n)
040060             0031*  ;
040060             0032*  vdp_gp:				EQU 80h
040060             0033*  vdp_keycode:		EQU 81h
040060             0034*  vdp_cursor:			EQU	82h
040060             0035*  vdp_scrchar:		EQU	83h
040060             0036*  vdp_scrpixel:		EQU	84h
040060             0037*  vdp_audio:			EQU	85h
040060             0038*  vdp_mode:			EQU	86h
040060             0039*  vdp_rtc:			EQU	87h
040060             0040*  vdp_keystate:		EQU	88h
040060             0041*  vdp_logicalcoords:	EQU	C0h
040060             0042*  vdp_terminalmode:	EQU	FFh
040060             0043*  
040060             0044*  ; MOS high level functions
040060             0045*  ;
040060             0046*  mos_getkey:			EQU	00h
040060             0047*  mos_load:			EQU	01h
040060             0048*  mos_save:			EQU	02h
040060             0049*  mos_cd:				EQU	03h
040060             0050*  mos_dir:			EQU	04h
040060             0051*  mos_del:			EQU	05h
040060             0052*  mos_ren:			EQU	06h
040060             0053*  mos_mkdir:			EQU	07h
040060             0054*  mos_sysvars:		EQU	08h
040060             0055*  mos_editline:		EQU	09h
040060             0056*  mos_fopen:			EQU	0Ah
040060             0057*  mos_fclose:			EQU	0Bh
040060             0058*  mos_fgetc:			EQU	0Ch
040060             0059*  mos_fputc:			EQU	0Dh
040060             0060*  mos_feof:			EQU	0Eh
040060             0061*  mos_getError:		EQU	0Fh
040060             0062*  mos_oscli:			EQU	10h
040060             0063*  mos_copy:			EQU	11h
040060             0064*  mos_getrtc:			EQU	12h
040060             0065*  mos_setrtc:			EQU	13h
040060             0066*  mos_setintvector:	EQU	14h
040060             0067*  mos_uopen:			EQU	15h
040060             0068*  mos_uclose:			EQU	16h
040060             0069*  mos_ugetc:			EQU	17h
040060             0070*  mos_uputc:			EQU	18h
040060             0071*  mos_getfil:			EQU	19h
040060             0072*  mos_fread:			EQU	1Ah
040060             0073*  mos_fwrite:			EQU	1Bh
040060             0074*  mos_flseek:			EQU	1Ch
040060             0075*  mos_setkbvector:	EQU	1Dh
040060             0076*  mos_getkbmap:		EQU	1Eh
040060             0077*  
040060             0078*  ; MOS program exit codes
040060             0079*  ;
040060             0080*  EXIT_OK:				EQU  0;	"OK",
040060             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*  ; FatFS file access functions
040060             0103*  ;
040060             0104*  ffs_fopen:			EQU	80h
040060             0105*  ffs_fclose:			EQU	81h
040060             0106*  ffs_fread:			EQU	82h
040060             0107*  ffs_fwrite:			EQU	83h
040060             0108*  ffs_flseek:			EQU	84h
040060             0109*  ffs_ftruncate:		EQU	85h
040060             0110*  ffs_fsync:			EQU	86h
040060             0111*  ffs_fforward:		EQU	87h
040060             0112*  ffs_fexpand:		EQU	88h
040060             0113*  ffs_fgets:			EQU	89h
040060             0114*  ffs_fputc:			EQU	8Ah
040060             0115*  ffs_fputs:			EQU	8Bh
040060             0116*  ffs_fprintf:		EQU	8Ch
040060             0117*  ffs_ftell:			EQU	8Dh
040060             0118*  ffs_feof:			EQU	8Eh
040060             0119*  ffs_fsize:			EQU	8Fh
040060             0120*  ffs_ferror:			EQU	90h
040060             0121*  
040060             0122*  ; FatFS directory access functions
040060             0123*  ;
040060             0124*  ffs_dopen:			EQU	91h
040060             0125*  ffs_dclose:			EQU	92h
040060             0126*  ffs_dread:			EQU	93h
040060             0127*  ffs_dfindfirst:		EQU	94h
040060             0128*  ffs_dfindnext:		EQU	95h
040060             0129*  
040060             0130*  ; FatFS file and directory management functions
040060             0131*  ;
040060             0132*  ffs_stat:			EQU	96h
040060             0133*  ffs_unlink:			EQU	97h
040060             0134*  ffs_rename:			EQU	98h
040060             0135*  ffs_chmod:			EQU	99h
040060             0136*  ffs_utime:			EQU	9Ah
040060             0137*  ffs_mkdir:			EQU	9Bh
040060             0138*  ffs_chdir:			EQU	9Ch
040060             0139*  ffs_chdrive:		EQU	9Dh
040060             0140*  ffs_getcwd:			EQU	9Eh
040060             0141*  
040060             0142*  ; FatFS volume management and system configuration functions
040060             0143*  ;
040060             0144*  ffs_mount:			EQU	9Fh
040060             0145*  ffs_mkfs:			EQU	A0h
040060             0146*  ffs_fdisk:			EQU	A1h
040060             0147*  ffs_getfree:		EQU	A2h
040060             0148*  ffs_getlabel:		EQU	A3h
040060             0149*  ffs_setlabel:		EQU	A4h
040060             0150*  ffs_setcp:			EQU	A5h
040060             0151*  
040060             0152*  ; File access modes
040060             0153*  ;
040060             0154*  fa_read:			EQU	01h
040060             0155*  fa_write:			EQU	02h
040060             0156*  fa_open_existing:	EQU	00h
040060             0157*  fa_create_new:		EQU	04h
040060             0158*  fa_create_always:	EQU	08h
040060             0159*  fa_open_always:		EQU	10h
040060             0160*  fa_open_append:		EQU	30h
040060             0161*  
040060             0162*  ; System variable indexes for api_sysvars
040060             0163*  ; Index into _sysvars in globals.inc
040060             0164*  ;
040060             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*  
040060             0192*  ; Flags for the VPD protocol
040060             0193*  ;
040060             0194*  vdp_pflag_cursor:		EQU	00000001b
040060             0195*  vdp_pflag_scrchar:		EQU	00000010b
040060             0196*  vdp_pflag_point:		EQU	00000100b
040060             0197*  vdp_pflag_audio:		EQU	00001000b
040060             0198*  vdp_pflag_mode:			EQU	00010000b
040060             0199*  vdp_pflag_rtc:			EQU	00100000b
040060             0200*  
040060             0201*  ;
040060             0202*  ; FatFS structures
040060             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*  ;
040060             0205*  ; Object ID and allocation information (FFOBJID)
040060             0206*  ;
040060             0207*  ; Indexes into FFOBJID structure
040060             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*  ;
040060             0215*  ; File object structure (FIL)
040060             0216*  ;
040060             0217*  ; Indexes into FIL structure
040060             0218*  fil_obj:		EQU 0	; 15: Object identifier
040060             0219*  fil_flag:		EQU	15 	;  1: File status flags
040060             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*  ;
040060             0227*  ; Directory object structure (DIR)
040060             0228*  ; Indexes into DIR structure
040060             0229*  dir_obj:		EQU  0	; 15: Object identifier
040060             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*  dir_clust:		EQU	19	;  4: Current cluster
040060             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*  ;
040060             0237*  ; File information structure (FILINFO)
040060             0238*  ;
040060             0239*  ; Indexes into FILINFO structure
040060             0240*  filinfo_fsize:		EQU 0	;   4: File size
040060             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*  ;
040060             0247*  ; Macro for calling the API
040060             0248*  ; Parameters:
040060             0249*  ; - function: One of the function numbers listed above
040060             0250*  ;
040060             0251*  	MACRO	MOSCALL	function
040060             0252*  			LD	A, function
040060             0253*  			RST.LIL	08h
040060             0254*  	ENDMACRO
040060             0030       include "macros.inc"
040060             0001*  
040060             0002*  ; test the sign of HL
040060             0003*  ; inputs: HL obviously
040060             0004*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*  ; destroys: flags
040060             0006*      MACRO sign_hlu
040060             0007*      add hl,de
040060             0008*      or a ; clear flags
040060             0009*      sbc hl,de
040060             0010*      ENDMACRO
040060             0011*  
040060             0012*      MACRO hlu_mul256
040060             0013*      add hl,hl ; * 2
040060             0014*      add hl,hl ; * 4
040060             0015*      add hl,hl ; * 8
040060             0016*      add hl,hl ; * 16
040060             0017*      add hl,hl ; * 32
040060             0018*      add hl,hl ; * 64
040060             0019*      add hl,hl ; * 128
040060             0020*      add hl,hl ; * 256
040060             0021*      ENDMACRO
040060             0022*  
040060             0023*  ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0024*      MACRO uhl_udiv256
040060             0025*      ld a,l
040060             0026*      dec sp
040060             0027*      push hl
040060             0028*      inc sp
040060             0029*      pop hl
040060             0030*      inc hl
040060             0031*      dec.s hl ; <-- the .s sets hlu to zero (undocumented)
040060             0032*      ENDMACRO
040060             0033*  
040060             0034*      MACRO printChar char
040060             0035*      LD A, char
040060             0036*      RST.LIL 10h
040060             0037*      ENDMACRO
040060             0038*  
040060             0039*  ; Simulated call to subroutine at HL
040060             0040*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0041*  ; outputs: whatever the subroutine does, including HL and BC
040060             0042*  ; destroys: only what the subroutine does, but always BC
040060             0043*      MACRO callHL
040060             0044*      ld bc,@F ; Address of first instruction after the jump
040060             0045*      push bc ; which constitutes the return address
040060             0046*      jp (hl) ; Jump to the address in HL
040060             0047*  @@:
040060             0048*      ENDMACRO
040060             0049*  
040060             0050*  ; Simulated call to subroutine at IX
040060             0051*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0052*  ; outputs: whatever the subroutine does, including IX and BC
040060             0053*  ; destroys: only what the subroutine does, but always BC
040060             0054*      MACRO callIX
040060             0055*      ld bc,@F ; Address of first instruction after the jump
040060             0056*      push bc ; which constitutes the return address
040060             0057*      jp (ix) ; Jump to the address in IX
040060             0058*  @@:
040060             0059*      ENDMACRO
040060             0060*  
040060             0061*  ; Simulated call to soubroutinte at IY
040060             0062*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0063*  ; outputs: whatever the subroutine does, including IY and BC
040060             0064*  ; destroys: only what the subroutine does, but always BC
040060             0065*      MACRO callIY
040060             0066*      ld bc,@F ; Address of first instruction after the jump
040060             0067*      push bc ; which constitutes the return address
040060             0068*      jp (iy) ; Jump to the address in IY
040060             0069*  @@:
040060             0070*      ENDMACRO
040060             0071*  
040060             0072*  ; put the value in HLU into the accumulator
040060             0073*  ; destroys: af
040060             0074*      MACRO HLU_TO_A
040060             0075*      push hl ; 4 cycles
040060             0076*      inc sp ; 1 cycle
040060             0077*      pop af ; 4 cycles
040060             0078*      dec sp ; 1 cycle
040060             0079*      ; 10 cycles total
040060             0080*      ENDMACRO
040060             0081*  
040060             0082*      ; TODO: implement this
040060             0083*      MACRO A_TO_HLU
040060             0084*          push.s af
040060             0085*          inc sp
040060             0086*          push.s hl
040060             0087*          pop hl
040060             0088*          inc sp
040060             0089*          inc sp
040060             0090*      ENDMACRO
040060             0091*  
040060             0092*  A_TO_HLU:
040060             0093*      ; call is 7 cycles
040060 22 6D 00 04 0094*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0095*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0096*      ld hl,(@scratch) ; 7 cycles
04006C C9          0097*      ret ; 6 cycles
04006D             0098*      ; 25 cycles total
04006D 00 00 00    0099*  @scratch: dl 0
040070             0100*  
040070             0101*  
040070             0102*      MACRO PUSH_ALL
040070             0103*      ex af,af'
040070             0104*      exx
040070             0105*      push af
040070             0106*      push hl
040070             0107*      push bc
040070             0108*      push de
040070             0109*  
040070             0110*      ex af,af'
040070             0111*      exx
040070             0112*      push af
040070             0113*      push hl
040070             0114*      push bc
040070             0115*      push de
040070             0116*      push ix
040070             0117*      push iy
040070             0118*      ENDMACRO
040070             0119*  
040070             0120*      MACRO POP_ALL
040070             0121*      pop iy
040070             0122*      pop ix
040070             0123*      pop de
040070             0124*      pop bc
040070             0125*      pop hl
040070             0126*      pop af
040070             0127*      ex af,af'
040070             0128*      exx
040070             0129*  
040070             0130*      pop de
040070             0131*      pop bc
040070             0132*      pop hl
040070             0133*      pop af
040070             0134*      ex af,af'
040070             0135*      exx
040070             0136*      ENDMACRO
040070             0031       include "functions.inc"
040070 FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040100             0002*  
040100             0003*  ; Print a zero-terminated string inline with code, e.g.:
040100             0004*  ;
040100             0005*  ;    call printInline
040100             0006*  ;    ASCIZ "Hello, world!\r\n"
040100             0007*  ;
040100             0008*  ; Destroys: HL,AF
040100             0009*  printInline:
040100 E1          0010*      pop hl ; get the return address = pointer to start of string
040101 CD 07 01 04 0011*      call printString ; HL advances to end of string
040105 E5          0012*      push hl ; restore the return address = pointer to end of string
040106 C9          0013*      ret
040107             0014*  
040107             0015*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040107             0016*  ; Print a zero-terminated string
040107             0017*  ; HL: Pointer to string
040107             0018*  printString:
040107 C5          0019*      PUSH BC
040108 01 00 00 00 0020*      LD BC,0
04010C 3E 00       0021*      LD A,0
04010E 5B DF       0022*      RST.LIL 18h
040110 C1          0023*      POP BC
040111 C9          0024*      RET
040112             0025*  ; print a VDU sequence
040112             0026*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040112             0027*  sendVDUsequence:
040112 C5          0028*      PUSH BC
040113 01 00 00 00 0029*      LD BC, 0
040117 4E          0030*      LD C, (HL)
040118 5B DF       0031*      RST.LIL 18h
04011A C1          0032*      POP BC
04011B C9          0033*      RET
04011C             0034*  ; Print Newline sequence to VDP
04011C             0035*  ; destroys bc
04011C             0036*  printNewLine:
04011C F5          0037*      push af ; for some reason rst.lil 10h sets carry flag
04011D 3E 0D       0038*      LD A, '\r'
04011F 5B D7       0039*      RST.LIL 10h
040121 3E 0A       0040*      LD A, '\n'
040123 5B D7       0041*      RST.LIL 10h
040125 F1          0042*      pop af
040126 C9          0043*      RET
040127             0044*  
040127             0045*  ; Print a 24-bit HEX number
040127             0046*  ; HLU: Number to print
040127             0047*  printHex24:
040127             0048*      HLU_TO_A
040127 E5          0001*M     push hl ; 4 cycles
040128 33          0002*M     inc sp ; 1 cycle
040129 F1          0003*M     pop af ; 4 cycles
04012A 3B          0004*M     dec sp ; 1 cycle
04012B             0005*M     ; 10 cycles total
04012B CD 35 01 04 0049*      CALL printHex8
04012F             0050*  ; Print a 16-bit HEX number
04012F             0051*  ; HL: Number to print
04012F             0052*  printHex16:
04012F 7C          0053*      LD A,H
040130 CD 35 01 04 0054*      CALL printHex8
040134 7D          0055*      LD A,L
040135             0056*  ; Print an 8-bit HEX number
040135             0057*  ; A: Number to print
040135             0058*  printHex8:
040135 4F          0059*      LD C,A
040136 1F          0060*      RRA
040137 1F          0061*      RRA
040138 1F          0062*      RRA
040139 1F          0063*      RRA
04013A CD 3F 01 04 0064*      CALL @F
04013E 79          0065*      LD A,C
04013F             0066*  @@:
04013F E6 0F       0067*      AND 0Fh
040141 C6 90       0068*      ADD A,90h
040143 27          0069*      DAA
040144 CE 40       0070*      ADC A,40h
040146 27          0071*      DAA
040147 5B D7       0072*      RST.LIL 10h
040149 C9          0073*      RET
04014A             0074*  
04014A             0075*  printHexA:
04014A F5          0076*      push af
04014B C5          0077*      push bc
04014C CD 35 01 04 0078*      call printHex8
040150 3E 20       0079*      ld a,' '
040152 5B D7       0080*      rst.lil 10h
040154 C1          0081*      pop bc
040155 F1          0082*      pop af
040156 C9          0083*      ret
040157             0084*  
040157             0085*  printHexHL:
040157 F5          0086*      push af
040158 C5          0087*      push bc
040159 CD 2F 01 04 0088*      call printHex16
04015D 3E 20       0089*      ld a,' '
04015F 5B D7       0090*      rst.lil 10h
040161 C1          0091*      pop bc
040162 F1          0092*      pop af
040163 C9          0093*      ret
040164             0094*  
040164             0095*  printHexUHL:
040164 F5          0096*      push af
040165 C5          0097*      push bc
040166 CD 27 01 04 0098*      call printHex24
04016A 3E 20       0099*      ld a,' '
04016C 5B D7       0100*      rst.lil 10h
04016E C1          0101*      pop bc
04016F F1          0102*      pop af
040170 C9          0103*      ret
040171             0104*  
040171             0105*  printHexAUHL:
040171 F5          0106*      push af
040172 C5          0107*      push bc
040173 CD 35 01 04 0108*      call printHex8
040177 3E 2E       0109*      ld a,'.'
040179 5B D7       0110*      rst.lil 10h
04017B CD 27 01 04 0111*      call printHex24
04017F 3E 20       0112*      ld a,' '
040181 5B D7       0113*      rst.lil 10h
040183 C1          0114*      pop bc
040184 F1          0115*      pop af
040185 C9          0116*      ret
040186             0117*  
040186             0118*  printHexABHL:
040186             0119*  ; preserve registers
040186 C5          0120*      push bc ; b will be ok c will not
040187 F5          0121*      push af ; will get totally destroyed
040188             0122*  ; print a
040188 CD 35 01 04 0123*      call printHex8
04018C             0124*  ; print b
04018C 78          0125*      ld a,b
04018D CD 35 01 04 0126*      call printHex8
040191             0127*  ; print hl
040191 CD 2F 01 04 0128*      call printHex16
040195             0129*  ; restore registers
040195 F1          0130*      pop af
040196 C1          0131*      pop bc
040197 C9          0132*      ret
040198             0133*  
040198             0134*  printHexBHL:
040198             0135*  ; preserve registers
040198 C5          0136*      push bc ; b will be ok c will not
040199 F5          0137*      push af ; will get totally destroyed
04019A             0138*  ; print b
04019A 78          0139*      ld a,b
04019B CD 35 01 04 0140*      call printHex8
04019F             0141*  ; print hl
04019F CD 2F 01 04 0142*      call printHex16
0401A3             0143*  ; restore registers
0401A3 F1          0144*      pop af
0401A4 C1          0145*      pop bc
0401A5 C9          0146*      ret
0401A6             0147*  
0401A6             0148*  printHexCDE:
0401A6             0149*  ; preserve registers
0401A6 C5          0150*      push bc ; b will be ok c will not
0401A7 F5          0151*      push af ; will get totally destroyed
0401A8             0152*  ; print c
0401A8 79          0153*      ld a,c
0401A9 CD 35 01 04 0154*      call printHex8
0401AD             0155*  ; print de
0401AD EB          0156*      ex de,hl
0401AE CD 2F 01 04 0157*      call printHex16
0401B2 EB          0158*      ex de,hl
0401B3             0159*  ; restore registers
0401B3 F1          0160*      pop af
0401B4 C1          0161*      pop bc
0401B5 C9          0162*      ret
0401B6             0163*  
0401B6             0164*  printHexUIX:
0401B6             0165*  ; store everything in scratch
0401B6 22 43 06 04 0166*      ld (uhl),hl
0401BA ED 43 46 06 0167*      ld (ubc),bc
       04          
0401BF ED 53 49 06 0168*      ld (ude),de
       04          
0401C4 DD 22 4C 06 0169*      ld (uix),ix
       04          
0401C9 FD 22 4F 06 0170*      ld (uiy),iy
       04          
0401CE F5          0171*      push af ; fml
0401CF             0172*  
0401CF 21 DA 05 04 0173*      ld hl,str_ixu
0401D3 CD 07 01 04 0174*      call printString
0401D7 2A 4C 06 04 0175*      ld hl,(uix)
0401DB CD 27 01 04 0176*      call printHex24
0401DF CD 1C 01 04 0177*      call printNewLine
0401E3             0178*  
0401E3             0179*  ; restore everything
0401E3 2A 43 06 04 0180*      ld hl, (uhl)
0401E7 ED 4B 46 06 0181*      ld bc, (ubc)
       04          
0401EC ED 5B 49 06 0182*      ld de, (ude)
       04          
0401F1 DD 2A 4C 06 0183*      ld ix, (uix)
       04          
0401F6 FD 2A 4F 06 0184*      ld iy, (uiy)
       04          
0401FB F1          0185*      pop af
0401FC             0186*  ; all done
0401FC C9          0187*      ret
0401FD             0188*  
0401FD             0189*  ; Print a 0x HEX prefix
0401FD             0190*  DisplayHexPrefix:
0401FD 3E 30       0191*      LD A, '0'
0401FF 5B D7       0192*      RST.LIL 10h
040201 3E 78       0193*      LD A, 'x'
040203 5B D7       0194*      RST.LIL 10h
040205 C9          0195*      RET
040206             0196*  
040206             0197*      MACRO printDecBC
040206             0198*      push hl
040206             0199*      push bc
040206             0200*      pop hl
040206             0201*      call printDec
040206             0202*      pop hl
040206             0203*      ENDMACRO
040206             0204*  
040206             0205*      MACRO printDecDE
040206             0206*      push hl
040206             0207*      push de
040206             0208*      pop hl
040206             0209*      call printDec
040206             0210*      pop hl
040206             0211*      ENDMACRO
040206             0212*  
040206             0213*      MACRO printDecHL
040206             0214*      call printDec
040206             0215*      ENDMACRO
040206             0216*  
040206             0217*      MACRO printDecIX
040206             0218*      push hl
040206             0219*      push ix
040206             0220*      pop hl
040206             0221*      call printDec
040206             0222*      pop hl
040206             0223*      ENDMACRO
040206             0224*  
040206             0225*      MACRO printDecIY
040206             0226*      push hl
040206             0227*      push iy
040206             0228*      pop hl
040206             0229*      call printDec
040206             0230*      pop hl
040206             0231*      ENDMACRO
040206             0232*  
040206             0233*  
040206             0234*  ; Prints the right justified decimal value in HL without leading zeroes
040206             0235*  ; HL : Value to print
040206             0236*  ; preserves all registers and flags
040206             0237*  printDec:
040206             0238*  ; BEGIN MY CODE
040206             0239*  ; back up all the things
040206 F5          0240*      push af
040207 C5          0241*      push bc
040208 D5          0242*      push de
040209 E5          0243*      push hl
04020A             0244*  ; END MY CODE
04020A 11 32 02 04 0245*      LD DE, _printDecBuffer
04020E CD 42 02 04 0246*      CALL u24_to_ascii
040212             0247*  ; BEGIN MY CODE
040212             0248*  ; replace leading zeroes with spaces
040212 21 32 02 04 0249*      LD HL, _printDecBuffer
040216 06 07       0250*      ld B, 7 ; if HL was 0, we want to keep the final zero
040218             0251*  @loop:
040218 7E          0252*      LD A, (HL)
040219 FE 30       0253*      CP '0'
04021B C2 25 02 04 0254*      JP NZ, @done
04021F 3E 20       0255*      LD A, ' '
040221 77          0256*      LD (HL), A
040222 23          0257*      INC HL
040223             0258*      ; CALL vdu_cursor_forward
040223 10 F3       0259*      DJNZ @loop
040225             0260*  @done:
040225             0261*  ; END MY CODE
040225 21 32 02 04 0262*      LD HL, _printDecBuffer
040229 CD 07 01 04 0263*      CALL printString
04022D             0264*  ; BEGIN MY CODE
04022D             0265*  ; restore all the things
04022D E1          0266*      pop hl
04022E D1          0267*      pop de
04022F C1          0268*      pop bc
040230 F1          0269*      pop af
040231             0270*  ; END MY CODE
040231 C9          0271*      RET
040232 00 00 00 00 0272*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040242             0273*  
040242             0274*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040242             0275*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040242             0276*  ; so it will allways be 8 characters length
040242             0277*  ; HL : Value to convert to string
040242             0278*  ; DE : pointer to buffer, at least 8 byte + 0
040242             0279*  u24_to_ascii:
040242 01 80 69 67 0280*      LD BC,-10000000
040246 CD 79 02 04 0281*      CALL @one_digit
04024A 01 C0 BD F0 0282*      LD BC,-1000000
04024E CD 79 02 04 0283*      CALL @one_digit
040252 01 60 79 FE 0284*      LD BC,-100000
040256 CD 79 02 04 0285*      CALL @one_digit
04025A 01 F0 D8 FF 0286*      LD BC,-10000
04025E CD 79 02 04 0287*      CALL @one_digit
040262 01 18 FC FF 0288*      LD BC,-1000
040266 CD 79 02 04 0289*      CALL @one_digit
04026A 01 9C FF FF 0290*      LD BC,-100
04026E CD 79 02 04 0291*      CALL @one_digit
040272 0E F6       0292*      LD C,-10
040274 CD 79 02 04 0293*      CALL @one_digit
040278 48          0294*      LD C,B
040279             0295*  @one_digit:
040279 3E 2F       0296*      LD A,'0'-1
04027B             0297*  @divide_me:
04027B 3C          0298*      INC A
04027C 09          0299*      ADD HL,BC
04027D 38 FC       0300*      JR C,@divide_me
04027F ED 42       0301*      SBC HL,BC
040281 12          0302*      LD (DE),A
040282 13          0303*      INC DE
040283 C9          0304*      RET
040284             0305*  
040284             0306*  print_u24:
040284 D5          0307*      push de
040285 E5          0308*      push hl
040286 11 32 02 04 0309*      ld de,_printDecBuffer
04028A CD 42 02 04 0310*      call u24_to_ascii
04028E 21 32 02 04 0311*      ld hl,_printDecBuffer
040292 CD 07 01 04 0312*      call printString
040296 3E 20       0313*      ld a,' '
040298 5B D7       0314*      rst.lil 10h
04029A E1          0315*      pop hl
04029B D1          0316*      pop de
04029C C9          0317*      ret
04029D             0318*  
04029D             0319*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04029D             0320*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04029D             0321*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04029D             0322*  u168_to_ascii:
04029D             0323*  ; add a leading space to make room for sign flag if needed
04029D 3E 20       0324*      ld a,' '
04029F 12          0325*      ld (de),a
0402A0 13          0326*      inc de
0402A1             0327*  ; Convert integer part
0402A1 E5          0328*      push hl ; Save HL (we’ll need the fractional part later)
0402A2             0329*      ; call hlu_udiv256 ; Shift to get integer portion in HL
0402A2             0330*      uhl_udiv256 ; Shift to get integer portion in HL
0402A2 7D          0001*M     ld a,l
0402A3 3B          0002*M     dec sp
0402A4 E5          0003*M     push hl
0402A5 33          0004*M     inc sp
0402A6 E1          0005*M     pop hl
0402A7 23          0006*M     inc hl
0402A8 52 2B       0007*M     dec.s hl ; <-- the .s sets hlu to zero (undocumented)
0402AA 01 F0 D8 FF 0331*      ld bc, -10000
0402AE CD D1 02 04 0332*      call @one_int
0402B2 01 18 FC FF 0333*      ld bc, -1000
0402B6 CD D1 02 04 0334*      call @one_int
0402BA 01 9C FF FF 0335*      ld bc, -100
0402BE CD D1 02 04 0336*      call @one_int
0402C2 0E F6       0337*      ld c, -10
0402C4 CD D1 02 04 0338*      call @one_int
0402C8 48          0339*      ld c, b
0402C9 CD D1 02 04 0340*      call @one_int
0402CD C3 DC 02 04 0341*      jp @frac ; Jump to fractional part conversion
0402D1             0342*  @one_int:
0402D1 3E 2F       0343*      ld a, '0' - 1 ; Start ASCII character at '0'
0402D3             0344*  @divide_me:
0402D3 3C          0345*      inc a
0402D4 09          0346*      add hl, bc ; Accumulate until overflow
0402D5 38 FC       0347*      jr c, @divide_me
0402D7 ED 42       0348*      sbc hl, bc ; Remove excess after overflow
0402D9 12          0349*      ld (de), a ; Store ASCII digit
0402DA 13          0350*      inc de
0402DB C9          0351*      ret
0402DC             0352*  ; Convert fractional part
0402DC             0353*  @frac:
0402DC 3E 2E       0354*      ld a, '.' ; Decimal point
0402DE 12          0355*      ld (de), a
0402DF 13          0356*      inc de
0402E0 E1          0357*      pop hl ; Restore HL with original fraction
0402E1 06 03       0358*      ld b, 3 ; Loop counter for 3 fractional digits
0402E3             0359*  @frac_loop:
0402E3 26 0A       0360*      ld h, 10 ; Load multiplier for fractional part
0402E5 ED 6C       0361*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0402E7 3E 30       0362*      ld a, '0'
0402E9 84          0363*      add a, h ; Convert integer part to ASCII
0402EA 12          0364*      ld (de), a
0402EB 13          0365*      inc de
0402EC 10 F5       0366*      djnz @frac_loop ; Repeat for each fractional digit
0402EE             0367*  ; Add null terminator
0402EE AF          0368*      xor a ; Null terminator
0402EF 12          0369*      ld (de), a
0402F0 C9          0370*      ret
0402F1             0371*  
0402F1             0372*  print_u168:
0402F1 D5          0373*      push de
0402F2 E5          0374*      push hl
0402F3 11 32 02 04 0375*      ld de,_printDecBuffer
0402F7 CD 9D 02 04 0376*      call u168_to_ascii
0402FB 21 32 02 04 0377*      ld hl,_printDecBuffer
0402FF CD 07 01 04 0378*      call printString
040303 E1          0379*      pop hl
040304 D1          0380*      pop de
040305 C9          0381*      ret
040306             0382*  
040306             0383*  ; signed version of u168_to_ascii
040306             0384*  s168_to_ascii:
040306 D5          0385*      push de ; save starting address of buffer
040307 CD 06 09 04 0386*      call hlu_abs
04030B F5          0387*      push af ; save sign flag
04030C CD 9D 02 04 0388*      call u168_to_ascii
040310 F1          0389*      pop af ; restore sign flag
040311 D1          0390*      pop de ; restore starting address of buffer
040312 F0          0391*      ret p ; hlu was positive so nothing to do
040313 3E 2D       0392*      ld a,'-'
040315 12          0393*      ld (de),a
040316 C9          0394*      ret
040317             0395*  
040317             0396*  print_s168:
040317 D5          0397*      push de
040318 E5          0398*      push hl
040319 11 32 02 04 0399*      ld de,_printDecBuffer
04031D CD 06 03 04 0400*      call s168_to_ascii
040321 21 32 02 04 0401*      ld hl,_printDecBuffer
040325 CD 07 01 04 0402*      call printString
040329 E1          0403*      pop hl
04032A D1          0404*      pop de
04032B C9          0405*      ret
04032C             0406*  
04032C             0407*  print_s168_hl:
04032C F5          0408*      push af
04032D E5          0409*      push hl
04032E CD 17 03 04 0410*      call print_s168
040332 3E 20       0411*      ld a,' '
040334 5B D7       0412*      rst.lil 10h
040336 E1          0413*      pop hl
040337 F1          0414*      pop af
040338 C9          0415*      ret
040339             0416*  
040339             0417*  print_s168_bc:
040339 F5          0418*      push af
04033A C5          0419*      push bc
04033B E5          0420*      push hl
04033C C5          0421*      push bc
04033D E1          0422*      pop hl
04033E CD 17 03 04 0423*      call print_s168
040342 3E 20       0424*      ld a,' '
040344 5B D7       0425*      rst.lil 10h
040346 E1          0426*      pop hl
040347 C1          0427*      pop bc
040348 F1          0428*      pop af
040349 C9          0429*      ret
04034A             0430*  
04034A             0431*  print_s168_de:
04034A F5          0432*      push af
04034B D5          0433*      push de
04034C E5          0434*      push hl
04034D EB          0435*      ex de,hl
04034E CD 17 03 04 0436*      call print_s168
040352 3E 20       0437*      ld a,' '
040354 5B D7       0438*      rst.lil 10h
040356 E1          0439*      pop hl
040357 D1          0440*      pop de
040358 F1          0441*      pop af
040359 C9          0442*      ret
04035A             0443*  
04035A             0444*  print_s168_hl_bc_de:
04035A F5          0445*      push af
04035B C5          0446*      push bc
04035C D5          0447*      push de
04035D E5          0448*      push hl
04035E CD 17 03 04 0449*      call print_s168
040362 3E 20       0450*      ld a,' '
040364 5B D7       0451*      rst.lil 10h
040366 C5          0452*      push bc
040367 E1          0453*      pop hl
040368 CD 17 03 04 0454*      call print_s168
04036C 3E 20       0455*      ld a,' '
04036E 5B D7       0456*      rst.lil 10h
040370 EB          0457*      ex de,hl
040371 CD 17 03 04 0458*      call print_s168
040375 3E 20       0459*      ld a,' '
040377 5B D7       0460*      rst.lil 10h
040379 E1          0461*      pop hl
04037A D1          0462*      pop de
04037B C1          0463*      pop bc
04037C F1          0464*      pop af
04037D C9          0465*      ret
04037E             0466*  
04037E             0467*  print_s168_bc_de:
04037E F5          0468*      push af
04037F C5          0469*      push bc
040380 D5          0470*      push de
040381 C5          0471*      push bc
040382 E1          0472*      pop hl
040383 CD 17 03 04 0473*      call print_s168
040387 3E 20       0474*      ld a,' '
040389 5B D7       0475*      rst.lil 10h
04038B EB          0476*      ex de,hl
04038C CD 17 03 04 0477*      call print_s168
040390 3E 20       0478*      ld a,' '
040392 5B D7       0479*      rst.lil 10h
040394 E1          0480*      pop hl
040395 D1          0481*      pop de
040396 C1          0482*      pop bc
040397 F1          0483*      pop af
040398 C9          0484*      ret
040399             0485*  
040399             0486*  print_s168_a:
040399 F5          0487*      push af
04039A C5          0488*      push bc
04039B E5          0489*      push hl
04039C 21 00 00 00 0490*      ld hl,0
0403A0 6F          0491*      ld l,a
0403A1 CD 2C 03 04 0492*      call print_s168_hl
0403A5 E1          0493*      pop hl
0403A6 C1          0494*      pop bc
0403A7 F1          0495*      pop af
0403A8 C9          0496*      ret
0403A9             0497*  
0403A9             0498*  ; #### new functions added by Brandon R. Gates ####
0403A9             0499*  
0403A9             0500*  ; print the binary representation of the 8-bit value in a
0403A9             0501*  ; destroys a, hl, bc
0403A9             0502*  printBin8:
0403A9 06 08       0503*      ld b,8 ; loop counter for 8 bits
0403AB 21 C6 03 04 0504*      ld hl,@cmd ; set hl to the low byte of the output string
0403AF             0505*      ; (which will be the high bit of the value in a)
0403AF             0506*  @loop:
0403AF 07          0507*      rlca ; put the next highest bit into carry
0403B0 38 04       0508*      jr c,@one
0403B2 36 30       0509*      ld (hl),'0'
0403B4 18 02       0510*      jr @next_bit
0403B6             0511*  @one:
0403B6 36 31       0512*      ld (hl),'1'
0403B8             0513*  @next_bit:
0403B8 23          0514*      inc hl
0403B9 10 F4       0515*      djnz @loop
0403BB             0516*  ; print it
0403BB 21 C6 03 04 0517*      ld hl,@cmd
0403BF 01 08 00 00 0518*      ld bc,@end-@cmd
0403C3 5B DF       0519*      rst.lil $18
0403C5 C9          0520*      ret
0403C6             0521*  @cmd: ds 8 ; eight bytes for eight bits
0403CE             0522*  @end:
0403CE             0523*  
0403CE             0524*  ; print the binary representation of the 8-bit value in a
0403CE             0525*  ; in reverse order (lsb first)
0403CE             0526*  ; destroys a, hl, bc
0403CE             0527*  printBin8Rev:
0403CE 06 08       0528*      ld b,8 ; loop counter for 8 bits
0403D0 21 EB 03 04 0529*      ld hl,@cmd ; set hl to the low byte of the output string
0403D4             0530*      ; (which will be the high bit of the value in a)
0403D4             0531*  @loop:
0403D4 0F          0532*      rrca ; put the next lowest bit into carry
0403D5 38 04       0533*      jr c,@one
0403D7 36 30       0534*      ld (hl),'0'
0403D9 18 02       0535*      jr @next_bit
0403DB             0536*  @one:
0403DB 36 31       0537*      ld (hl),'1'
0403DD             0538*  @next_bit:
0403DD 23          0539*      inc hl
0403DE 10 F4       0540*      djnz @loop
0403E0             0541*  ; print it
0403E0 21 EB 03 04 0542*      ld hl,@cmd
0403E4 01 08 00 00 0543*      ld bc,@end-@cmd
0403E8 5B DF       0544*      rst.lil $18
0403EA C9          0545*      ret
0403EB             0546*  @cmd: ds 8 ; eight bytes for eight bits
0403F3             0547*  @end:
0403F3             0548*  
0403F3             0549*  ; print registers to screen in hexidecimal format
0403F3             0550*  ; inputs: none
0403F3             0551*  ; outputs: values of every register printed to screen
0403F3             0552*  ;    values of each register in global scratch memory
0403F3             0553*  ; destroys: nothing
0403F3             0554*  stepRegistersHex:
0403F3             0555*  ; store everything in scratch
0403F3 22 43 06 04 0556*      ld (uhl),hl
0403F7 ED 43 46 06 0557*      ld (ubc),bc
       04          
0403FC ED 53 49 06 0558*      ld (ude),de
       04          
040401 DD 22 4C 06 0559*      ld (uix),ix
       04          
040406 FD 22 4F 06 0560*      ld (uiy),iy
       04          
04040B F5          0561*      push af ; fml
04040C E1          0562*      pop hl ; thanks, zilog
04040D 22 40 06 04 0563*      ld (uaf),hl
040411 F5          0564*      push af ; dammit
040412             0565*  
040412             0566*  ; home the cursor
040412             0567*      ; call vdu_home_cursor
040412             0568*  
040412             0569*  ; print each register
040412 21 C6 05 04 0570*      ld hl,str_afu
040416 CD 07 01 04 0571*      call printString
04041A 2A 40 06 04 0572*      ld hl,(uaf)
04041E CD 27 01 04 0573*      call printHex24
040422 CD 1C 01 04 0574*      call printNewLine
040426             0575*  
040426 21 CB 05 04 0576*      ld hl,str_hlu
04042A CD 07 01 04 0577*      call printString
04042E 2A 43 06 04 0578*      ld hl,(uhl)
040432 CD 27 01 04 0579*      call printHex24
040436 CD 1C 01 04 0580*      call printNewLine
04043A             0581*  
04043A 21 D0 05 04 0582*      ld hl,str_bcu
04043E CD 07 01 04 0583*      call printString
040442 2A 46 06 04 0584*      ld hl,(ubc)
040446 CD 27 01 04 0585*      call printHex24
04044A CD 1C 01 04 0586*      call printNewLine
04044E             0587*  
04044E 21 D5 05 04 0588*      ld hl,str_deu
040452 CD 07 01 04 0589*      call printString
040456 2A 49 06 04 0590*      ld hl,(ude)
04045A CD 27 01 04 0591*      call printHex24
04045E CD 1C 01 04 0592*      call printNewLine
040462             0593*  
040462 21 DA 05 04 0594*      ld hl,str_ixu
040466 CD 07 01 04 0595*      call printString
04046A 2A 4C 06 04 0596*      ld hl,(uix)
04046E CD 27 01 04 0597*      call printHex24
040472 CD 1C 01 04 0598*      call printNewLine
040476             0599*  
040476 21 DF 05 04 0600*      ld hl,str_iyu
04047A CD 07 01 04 0601*      call printString
04047E 2A 4F 06 04 0602*      ld hl,(uiy)
040482 CD 27 01 04 0603*      call printHex24
040486 CD 1C 01 04 0604*      call printNewLine
04048A             0605*  
04048A             0606*      ; call vsync
04048A             0607*  
04048A CD 1C 01 04 0608*      call printNewLine
04048E             0609*  
04048E             0610*  ; check for right shift key and quit if pressed
04048E             0611*      MOSCALL mos_getkbmap
04048E 3E 1E       0001*M 			LD	A, function
040490 5B CF       0002*M 			RST.LIL	08h
040492             0612*  @stayhere:
040492             0613*  ; 7 RightShift
040492 DD CB 00 76 0614*      bit 6,(ix+0)
040496 20 02       0615*      jr nz,@RightShift
040498 18 F8       0616*      jr @stayhere
04049A             0617*  @RightShift:
04049A DD CB 0E 86 0618*      res 0,(ix+14) ; debounce the key (hopefully)
04049E 3E 80       0619*      ld a,%10000000
0404A0             0620*      ; call multiPurposeDelay
0404A0             0621*  
0404A0             0622*  ; restore everything
0404A0 2A 43 06 04 0623*      ld hl, (uhl)
0404A4 ED 4B 46 06 0624*      ld bc, (ubc)
       04          
0404A9 ED 5B 49 06 0625*      ld de, (ude)
       04          
0404AE DD 2A 4C 06 0626*      ld ix, (uix)
       04          
0404B3 FD 2A 4F 06 0627*      ld iy, (uiy)
       04          
0404B8 F1          0628*      pop af
0404B9             0629*  ; all done
0404B9 C9          0630*      ret
0404BA             0631*  
0404BA             0632*  ; print registers to screen in hexidecimal format
0404BA             0633*  ; inputs: none
0404BA             0634*  ; outputs: values of every register printed to screen
0404BA             0635*  ;    values of each register in global scratch memory
0404BA             0636*  ; destroys: nothing
0404BA             0637*  dumpRegistersHex:
0404BA             0638*  ; store everything in scratch
0404BA 22 43 06 04 0639*      ld (uhl),hl
0404BE ED 43 46 06 0640*      ld (ubc),bc
       04          
0404C3 ED 53 49 06 0641*      ld (ude),de
       04          
0404C8 DD 22 4C 06 0642*      ld (uix),ix
       04          
0404CD FD 22 4F 06 0643*      ld (uiy),iy
       04          
0404D2 F5          0644*      push af ; fml
0404D3 E1          0645*      pop hl ; thanks, zilog
0404D4 22 40 06 04 0646*      ld (uaf),hl
0404D8 F5          0647*      push af ; dammit
0404D9             0648*  
0404D9             0649*  ; home the cursor
0404D9             0650*      ; call vdu_home_cursor
0404D9             0651*      ; call printNewLine
0404D9             0652*  
0404D9             0653*  ; print each register
0404D9 21 C6 05 04 0654*      ld hl,str_afu
0404DD CD 07 01 04 0655*      call printString
0404E1 2A 40 06 04 0656*      ld hl,(uaf)
0404E5 CD 27 01 04 0657*      call printHex24
0404E9 CD 1C 01 04 0658*      call printNewLine
0404ED             0659*  
0404ED 21 CB 05 04 0660*      ld hl,str_hlu
0404F1 CD 07 01 04 0661*      call printString
0404F5 2A 43 06 04 0662*      ld hl,(uhl)
0404F9 CD 27 01 04 0663*      call printHex24
0404FD CD 1C 01 04 0664*      call printNewLine
040501             0665*  
040501 21 D0 05 04 0666*      ld hl,str_bcu
040505 CD 07 01 04 0667*      call printString
040509 2A 46 06 04 0668*      ld hl,(ubc)
04050D CD 27 01 04 0669*      call printHex24
040511 CD 1C 01 04 0670*      call printNewLine
040515             0671*  
040515 21 D5 05 04 0672*      ld hl,str_deu
040519 CD 07 01 04 0673*      call printString
04051D 2A 49 06 04 0674*      ld hl,(ude)
040521 CD 27 01 04 0675*      call printHex24
040525 CD 1C 01 04 0676*      call printNewLine
040529             0677*  
040529 21 DA 05 04 0678*      ld hl,str_ixu
04052D CD 07 01 04 0679*      call printString
040531 2A 4C 06 04 0680*      ld hl,(uix)
040535 CD 27 01 04 0681*      call printHex24
040539 CD 1C 01 04 0682*      call printNewLine
04053D             0683*  
04053D 21 DF 05 04 0684*      ld hl,str_iyu
040541 CD 07 01 04 0685*      call printString
040545 2A 4F 06 04 0686*      ld hl,(uiy)
040549 CD 27 01 04 0687*      call printHex24
04054D             0688*      ; call printNewLine
04054D             0689*  
04054D             0690*      ; call vdu_vblank
04054D             0691*  
04054D             0692*      ; call printNewLine
04054D             0693*  ; restore everything
04054D 2A 43 06 04 0694*      ld hl, (uhl)
040551 ED 4B 46 06 0695*      ld bc, (ubc)
       04          
040556 ED 5B 49 06 0696*      ld de, (ude)
       04          
04055B DD 2A 4C 06 0697*      ld ix, (uix)
       04          
040560 FD 2A 4F 06 0698*      ld iy, (uiy)
       04          
040565 F1          0699*      pop af
040566             0700*  ; all done
040566 C9          0701*      ret
040567             0702*  
040567             0703*  dumpRegistersHexPrime:
040567 D9          0704*      exx
040568 08          0705*      ex af,af'
040569 CD BA 04 04 0706*      call dumpRegistersHex
04056D 08          0707*      ex af,af'
04056E D9          0708*      exx
04056F C9          0709*      ret
040570             0710*  
040570             0711*  ; additionally dump prime registers
040570             0712*  ; inputs: none
040570             0713*  ; outputs: values of every register printed to screen
040570             0714*  ; destroys: nothing
040570             0715*  dumpRegistersHexAll:
040570 CD BA 04 04 0716*      call dumpRegistersHex
040574 08          0717*      ex af,af'
040575 D9          0718*      exx
040576 CD BA 04 04 0719*      call dumpRegistersHex
04057A 08          0720*      ex af,af'
04057B D9          0721*      exx
04057C C9          0722*      ret
04057D             0723*  
04057D             0724*  ; print hlu to screen in hexidecimal format
04057D             0725*  ; inputs: none
04057D             0726*  ; destroys: nothing
04057D             0727*  print_hex_hl:
04057D F5          0728*      push af
04057E E5          0729*      push hl
04057F 21 CB 05 04 0730*      ld hl,str_hlu
040583 CD 07 01 04 0731*      call printString
040587 E1          0732*      pop hl
040588 E5          0733*      push hl
040589 CD 27 01 04 0734*      call printHex24
04058D 3E 20       0735*      ld a,' '
04058F 5B D7       0736*      rst.lil 10h
040591 E1          0737*      pop hl
040592 F1          0738*      pop af
040593 C9          0739*      ret
040594             0740*  
040594             0741*  ; print bcu to screen in hexidecimal format
040594             0742*  ; inputs: none
040594             0743*  ; destroys: nothing
040594             0744*  print_hex_bc:
040594 F5          0745*      push af
040595 E5          0746*      push hl
040596 C5          0747*      push bc
040597 21 D0 05 04 0748*      ld hl,str_bcu
04059B CD 07 01 04 0749*      call printString
04059F E1          0750*      pop hl
0405A0 E5          0751*      push hl
0405A1 CD 27 01 04 0752*      call printHex24
0405A5 3E 20       0753*      ld a,' '
0405A7 5B D7       0754*      rst.lil 10h
0405A9 C1          0755*      pop bc
0405AA E1          0756*      pop hl
0405AB F1          0757*      pop af
0405AC C9          0758*      ret
0405AD             0759*  
0405AD             0760*  ; print deu to screen in hexidecimal format
0405AD             0761*  ; inputs: none
0405AD             0762*  ; destroys: nothing
0405AD             0763*  print_hex_de:
0405AD F5          0764*      push af
0405AE E5          0765*      push hl
0405AF D5          0766*      push de
0405B0 21 D5 05 04 0767*      ld hl,str_deu
0405B4 CD 07 01 04 0768*      call printString
0405B8 E1          0769*      pop hl
0405B9 E5          0770*      push hl
0405BA CD 27 01 04 0771*      call printHex24
0405BE 3E 20       0772*      ld a,' '
0405C0 5B D7       0773*      rst.lil 10h
0405C2 D1          0774*      pop de
0405C3 E1          0775*      pop hl
0405C4 F1          0776*      pop af
0405C5 C9          0777*      ret
0405C6             0778*  
0405C6 20 61 66 3D 0779*  str_afu: db " af=",0
       00          
0405CB 20 68 6C 3D 0780*  str_hlu: db " hl=",0
       00          
0405D0 20 62 63 3D 0781*  str_bcu: db " bc=",0
       00          
0405D5 20 64 65 3D 0782*  str_deu: db " de=",0
       00          
0405DA 20 69 78 3D 0783*  str_ixu: db " ix=",0
       00          
0405DF 20 69 79 3D 0784*  str_iyu: db " iy=",0
       00          
0405E4             0785*  
0405E4             0786*  ; print udeuhl to screen in hexidecimal format
0405E4             0787*  ; inputs: none
0405E4             0788*  ; outputs: concatenated hexidecimal udeuhl
0405E4             0789*  ; destroys: nothing
0405E4             0790*  dumpUDEUHLHex:
0405E4             0791*  ; store everything in scratch
0405E4 22 43 06 04 0792*      ld (uhl),hl
0405E8 ED 43 46 06 0793*      ld (ubc),bc
       04          
0405ED ED 53 49 06 0794*      ld (ude),de
       04          
0405F2 DD 22 4C 06 0795*      ld (uix),ix
       04          
0405F7 FD 22 4F 06 0796*      ld (uiy),iy
       04          
0405FC F5          0797*      push af
0405FD             0798*  
0405FD             0799*  ; print each register
0405FD             0800*  
0405FD 21 37 06 04 0801*      ld hl,str_udeuhl
040601 CD 07 01 04 0802*      call printString
040605 2A 49 06 04 0803*      ld hl,(ude)
040609 CD 27 01 04 0804*      call printHex24
04060D 3E 2E       0805*      ld a,'.' ; print a dot to separate the values
04060F 5B D7       0806*      rst.lil 10h
040611 2A 43 06 04 0807*      ld hl,(uhl)
040615 CD 27 01 04 0808*      call printHex24
040619 CD 1C 01 04 0809*      call printNewLine
04061D             0810*  
04061D             0811*  ; restore everything
04061D 2A 43 06 04 0812*      ld hl, (uhl)
040621 ED 4B 46 06 0813*      ld bc, (ubc)
       04          
040626 ED 5B 49 06 0814*      ld de, (ude)
       04          
04062B DD 2A 4C 06 0815*      ld ix, (uix)
       04          
040630 FD 2A 4F 06 0816*      ld iy, (uiy)
       04          
040635 F1          0817*      pop af
040636             0818*  ; all done
040636 C9          0819*      ret
040637             0820*  
040637 75 64 65 2E 0821*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040640             0822*  
040640             0823*  ; global scratch memory for registers
040640 00 00 00    0824*  uaf: dl 0
040643 00 00 00    0825*  uhl: dl 0
040646 00 00 00    0826*  ubc: dl 0
040649 00 00 00    0827*  ude: dl 0
04064C 00 00 00    0828*  uix: dl 0
04064F 00 00 00    0829*  uiy: dl 0
040652 00 00 00    0830*  usp: dl 0
040655 00 00 00    0831*  upc: dl 0
040658             0832*  
040658             0833*  ; inputs: whatever is in the flags register
040658             0834*  ; outputs: binary representation of flags
040658             0835*  ;          with a header so we know which is what
040658             0836*  ; destroys: nothing
040658             0837*  ; preserves: everything
040658             0838*  dumpFlags:
040658             0839*  ; first we curse zilog for not giving direct access to flags
040658 F5          0840*      push af ; this is so we can send it back unharmed
040659 F5          0841*      push af ; this is so we can pop it to hl
04065A             0842*  ; store everything in scratch
04065A 22 43 06 04 0843*      ld (uhl),hl
04065E ED 43 46 06 0844*      ld (ubc),bc
       04          
040663 ED 53 49 06 0845*      ld (ude),de
       04          
040668 DD 22 4C 06 0846*      ld (uix),ix
       04          
04066D FD 22 4F 06 0847*      ld (uiy),iy
       04          
040672             0848*  ; next we print the header
040672 21 9E 06 04 0849*      ld hl,@header
040676 CD 07 01 04 0850*      call printString
04067A E1          0851*      pop hl ; flags are now in l
04067B 7D          0852*      ld a,l ; flags are now in a
04067C CD A9 03 04 0853*      call printBin8
040680 CD 1C 01 04 0854*      call printNewLine
040684             0855*  ; restore everything
040684 2A 43 06 04 0856*      ld hl, (uhl)
040688 ED 4B 46 06 0857*      ld bc, (ubc)
       04          
04068D ED 5B 49 06 0858*      ld de, (ude)
       04          
040692 DD 2A 4C 06 0859*      ld ix, (uix)
       04          
040697 FD 2A 4F 06 0860*      ld iy, (uiy)
       04          
04069C F1          0861*      pop af ; send her home the way she came
04069D C9          0862*      ret
04069E             0863*  ; Bit 7 (S): Sign flag
04069E             0864*  ; Bit 6 (Z): Zero flag
04069E             0865*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04069E             0866*  ; Bit 4 (H): Half Carry flag
04069E             0867*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04069E             0868*  ; Bit 2 (PV): Parity/Overflow flag
04069E             0869*  ; Bit 1 (N): Subtract flag
04069E             0870*  ; Bit 0 (C): Carry flag
04069E 53 5A 78 48 0871*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0406A9             0872*  
0406A9             0873*  ; set all the bits in the flag register
0406A9             0874*  ; more of an academic exercise than anything useful
0406A9             0875*  ; inputs; none
0406A9             0876*  ; outputs; a=0,f=255
0406A9             0877*  ; destroys: flags, hl
0406A9             0878*  ; preserves: a, because why not
0406A9             0879*  setAllFlags:
0406A9 21 FF 00 00 0880*      ld hl,255
0406AD 67          0881*      ld h,a ; four cycles to preserve a is cheap
0406AE E5          0882*      push hl
0406AF F1          0883*      pop af
0406B0 C9          0884*      ret
0406B1             0885*  
0406B1             0886*  ; reset all the bits in the flag register
0406B1             0887*  ; unlike its inverse counterpart, this may actually be useful
0406B1             0888*  ; inputs; none
0406B1             0889*  ; outputs; a=0,f=0
0406B1             0890*  ; destroys: flags, hl
0406B1             0891*  ; preserves: a, because why not
0406B1             0892*  resetAllFlags:
0406B1 21 00 00 00 0893*      ld hl,0
0406B5 67          0894*      ld h,a ; four cycles to preserve a is cheap
0406B6 E5          0895*      push hl
0406B7 F1          0896*      pop af
0406B8 C9          0897*      ret
0406B9             0898*  
0406B9             0899*  ; wait until user presses a key
0406B9             0900*  ; inputs: none
0406B9             0901*  ; outputs: ascii code of key pressed in a
0406B9             0902*  ; destroys: af,ix
0406B9             0903*  waitKeypress:
0406B9             0904*      MOSCALL mos_getkey
0406B9 3E 00       0001*M 			LD	A, function
0406BB 5B CF       0002*M 			RST.LIL	08h
0406BD C9          0905*      ret
0406BE             0906*  
0406BE             0907*  ; print bytes from an address to the screen in hexidecimal format
0406BE             0908*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0406BE             0909*  ; outputs: values of each byte printed to screen separated by spaces
0406BE             0910*  ; destroys: nothing
0406BE             0911*  dumpMemoryHex:
0406BE             0912*  ; save registers to the stack
0406BE C5          0913*      push bc
0406BF E5          0914*      push hl
0406C0 F5          0915*      push af
0406C1             0916*  
0406C1             0917*  ; print the address and separator
0406C1 CD 27 01 04 0918*      call printHex24
0406C5 3E 3A       0919*      ld a,':'
0406C7 5B D7       0920*      rst.lil 10h
0406C9 3E 20       0921*      ld a,' '
0406CB 5B D7       0922*      rst.lil 10h
0406CD             0923*  
0406CD             0924*  ; set b to be our loop counter
0406CD F1          0925*      pop af
0406CE 47          0926*      ld b,a
0406CF E1          0927*      pop hl
0406D0 E5          0928*      push hl
0406D1 F5          0929*      push af
0406D2             0930*  @loop:
0406D2             0931*  ; print the byte
0406D2 7E          0932*      ld a,(hl)
0406D3 CD 35 01 04 0933*      call printHex8
0406D7             0934*  ; print a space
0406D7 3E 20       0935*      ld a,' '
0406D9 5B D7       0936*      rst.lil 10h
0406DB 23          0937*      inc hl
0406DC 10 F4       0938*      djnz @loop
0406DE CD 1C 01 04 0939*      call printNewLine
0406E2             0940*  
0406E2             0941*  ; restore everything
0406E2 F1          0942*      pop af
0406E3 E1          0943*      pop hl
0406E4 C1          0944*      pop bc
0406E5             0945*  
0406E5             0946*  ; all done
0406E5 C9          0947*      ret
0406E6             0948*  
0406E6             0949*  
0406E6             0950*  ; print bytes from an address to the screen in binary format
0406E6             0951*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0406E6             0952*  ; outputs: values of each byte printed to screen separated by spaces
0406E6             0953*  ; destroys: nothing
0406E6             0954*  dumpMemoryBin:
0406E6             0955*  ; save all registers to the stack
0406E6 F5          0956*      push af
0406E7 C5          0957*      push bc
0406E8 D5          0958*      push de
0406E9 E5          0959*      push hl
0406EA DD E5       0960*      push ix
0406EC FD E5       0961*      push iy
0406EE             0962*  
0406EE             0963*  ; set b to be our loop counter
0406EE 47          0964*      ld b,a
0406EF             0965*  @loop:
0406EF             0966*  ; print the byte
0406EF 7E          0967*      ld a,(hl)
0406F0 E5          0968*      push hl
0406F1 C5          0969*      push bc
0406F2 CD A9 03 04 0970*      call printBin8
0406F6 C1          0971*      pop bc
0406F7             0972*  ; print a space
0406F7 3E 20       0973*      ld a,' '
0406F9 5B D7       0974*      rst.lil 10h
0406FB E1          0975*      pop hl
0406FC 23          0976*      inc hl
0406FD 10 F0       0977*      djnz @loop
0406FF CD 1C 01 04 0978*      call printNewLine
040703             0979*  
040703             0980*  ; restore everything
040703 FD E1       0981*      pop iy
040705 DD E1       0982*      pop ix
040707 E1          0983*      pop hl
040708 D1          0984*      pop de
040709 C1          0985*      pop bc
04070A F1          0986*      pop af
04070B             0987*  ; all done
04070B C9          0988*      ret
04070C             0989*  
04070C             0990*  ; print bytes from an address to the screen in binary format
04070C             0991*  ; with the bits of each byte in reverse order (lsb first)
04070C             0992*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04070C             0993*  ; outputs: values of each byte printed to screen separated by spaces
04070C             0994*  ; destroys: nothing
04070C             0995*  dumpMemoryBinRev:
04070C             0996*  ; save all registers to the stack
04070C F5          0997*      push af
04070D C5          0998*      push bc
04070E D5          0999*      push de
04070F E5          1000*      push hl
040710 DD E5       1001*      push ix
040712 FD E5       1002*      push iy
040714             1003*  
040714             1004*  ; set b to be our loop counter
040714 47          1005*      ld b,a
040715             1006*  @loop:
040715             1007*  ; print the byte
040715 7E          1008*      ld a,(hl)
040716 E5          1009*      push hl
040717 C5          1010*      push bc
040718 CD CE 03 04 1011*      call printBin8Rev
04071C C1          1012*      pop bc
04071D             1013*  ; print a space
04071D 3E 20       1014*      ld a,' '
04071F 5B D7       1015*      rst.lil 10h
040721 E1          1016*      pop hl
040722 23          1017*      inc hl
040723 10 F0       1018*      djnz @loop
040725 CD 1C 01 04 1019*      call printNewLine
040729             1020*  
040729             1021*  ; restore everything
040729 FD E1       1022*      pop iy
04072B DD E1       1023*      pop ix
04072D E1          1024*      pop hl
04072E D1          1025*      pop de
04072F C1          1026*      pop bc
040730 F1          1027*      pop af
040731             1028*  ; all done
040731 C9          1029*      ret
040732             1030*  
040732             1031*  ; clear a block of memory by writing a prescribed value to each byte in the range
040732             1032*  ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
040732             1033*  ; outputs: memory block is cleared
040732             1034*  ; destroys: hl, de
040732             1035*  clear_mem:
040732 0B          1036*      dec bc ; we do this because we will increment de before writing the first byte
040733 77          1037*      ld (hl),a
040734 E5          1038*      push hl
040735 D1          1039*      pop de
040736 13          1040*      inc de ; target address
040737 ED B0       1041*      ldir
040739 C9          1042*      ret
04073A             0032       include "arith24.inc"
04073A             0001*  ;------------------------------------------------------------------------
04073A             0002*  ;  arith24.asm
04073A             0003*  ;  24-bit ez80 arithmetic routines
04073A             0004*  ;  Copyright (c) Shawn Sijnstra 2024
04073A             0005*  ;  MIT license
04073A             0006*  ;
04073A             0007*  ;  This library was created as a tool to help make ez80
04073A             0008*  ;  24-bit native assembly routines for simple mathematical problems
04073A             0009*  ;  more widely available.
04073A             0010*  ;
04073A             0011*  ;------------------------------------------------------------------------
04073A             0012*  
04073A             0013*  ;------------------------------------------------------------------------
04073A             0014*  ; umul24:	HL = HL*DE (unsigned)
04073A             0015*  ; Preserves AF, BC, DE
04073A             0016*  ; Uses a fast multiply routine.
04073A             0017*  ;------------------------------------------------------------------------
04073A             0018*  umul24:
04073A D5          0019*  	push	DE
04073B C5          0020*  	push	BC
04073C F5          0021*  	push	AF
04073D E5          0022*  	push	HL
04073E C1          0023*  	pop		BC
04073F 3E 18       0024*      ld	 	a, 24 ; No. of bits to process
040741 21 00 00 00 0025*      ld	 	hl, 0 ; Result
040745             0026*  umul24_lp:
040745 29          0027*  	add	hl,hl
040746 EB          0028*  	ex	de,hl
040747 29          0029*  	add	hl,hl
040748 EB          0030*  	ex	de,hl
040749 30 01       0031*  	jr	nc,umul24_nc
04074B 09          0032*  	add	hl,bc
04074C             0033*  umul24_nc:
04074C 3D          0034*  	dec	a
04074D 20 F6       0035*  	jr	nz,umul24_lp
04074F F1          0036*  	pop	af
040750 C1          0037*  	pop	bc
040751 D1          0038*  	pop	de
040752 C9          0039*  	ret
040753             0040*  
040753             0041*  
040753             0042*  ;------------------------------------------------------------------------
040753             0043*  ; udiv24
040753             0044*  ; Unsigned 24-bit division
040753             0045*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040753             0046*  ;
040753             0047*  ; Uses AF BC DE HL
040753             0048*  ; Uses Restoring Division algorithm
040753             0049*  ;------------------------------------------------------------------------
040753             0050*  
040753             0051*  udiv24:
040753 E5          0052*  	push	hl
040754 C1          0053*  	pop		bc	;move dividend to BCU
040755 21 00 00 00 0054*  	ld		hl,0	;result
040759 A7          0055*  	and		a
04075A ED 52       0056*  	sbc		hl,de	;test for div by 0
04075C C8          0057*  	ret		z		;it's zero, carry flag is clear
04075D 19          0058*  	add		hl,de	;HL is 0 again
04075E 3E 18       0059*  	ld		a,24	;number of loops through.
040760             0060*  udiv1:
040760 C5          0061*  	push	bc	;complicated way of doing this because of lack of access to top bits
040761 E3          0062*  	ex		(sp),hl
040762 37          0063*  	scf
040763 ED 6A       0064*  	adc	hl,hl
040765 E3          0065*  	ex	(sp),hl
040766 C1          0066*  	pop	bc		;we now have bc = (bc * 2) + 1
040767             0067*  
040767 ED 6A       0068*  	adc	hl,hl
040769 A7          0069*  	and	a		;is this the bug
04076A ED 52       0070*  	sbc	hl,de
04076C 30 02       0071*  	jr	nc,udiv2
04076E 19          0072*  	add	hl,de
04076F             0073*  ;	dec	c
04076F 0B          0074*  	dec	bc
040770             0075*  udiv2:
040770 3D          0076*  	dec	a
040771 20 ED       0077*  	jr	nz,udiv1
040773 37          0078*  	scf		;flag used for div0 error
040774 C5          0079*  	push	bc
040775 D1          0080*  	pop		de	;remainder
040776 C9          0081*  	ret
040777             0082*  
040777             0083*  
040777             0084*  
040777             0085*  ;------------------------------------------------------------------------
040777             0086*  ; neg24
040777             0087*  ; Returns: HLU = 0-HLU
040777             0088*  ; preserves all other registers
040777             0089*  ;------------------------------------------------------------------------
040777             0090*  neg24:
040777 D5          0091*  	push	de
040778 EB          0092*  	ex		de,hl
040779 21 00 00 00 0093*  	ld		hl,0
04077D B7          0094*  	or		a
04077E ED 52       0095*  	sbc		hl,de
040780 D1          0096*  	pop		de
040781 C9          0097*  	ret
040782             0098*  
040782             0099*  ;------------------------------------------------------------------------
040782             0100*  ; or_hlu_deu: 24 bit bitwise OR
040782             0101*  ; Returns: hlu = hlu OR deu
040782             0102*  ; preserves all other registers
040782             0103*  ;------------------------------------------------------------------------
040782             0104*  or_hlu_deu:
040782 22 0B 08 04 0105*  	ld	(bitbuf1),hl
040786 ED 53 0E 08 0106*  	ld	(bitbuf2),de
       04          
04078B D5          0107*  	push	de	;preserve DEU
04078C C5          0108*  	push	bc	;preserve BCU
04078D 06 03       0109*  	ld		b,3
04078F 21 0B 08 04 0110*  	ld	hl,bitbuf1
040793 11 0B 08 04 0111*  	ld	de,bitbuf1
040797             0112*  orloop_24:
040797 1A          0113*  	ld	a,(de)
040798 B6          0114*  	or	(hl)
040799 12          0115*  	ld	(de),a
04079A 13          0116*  	inc	de
04079B 23          0117*  	inc	hl
04079C 10 F9       0118*  	djnz	orloop_24
04079E 2A 0E 08 04 0119*  	ld	hl,(bitbuf2)
0407A2 C1          0120*  	pop		bc	;restore BC
0407A3 D1          0121*  	pop		de	;restore DE
0407A4             0122*  
0407A4             0123*  ;------------------------------------------------------------------------
0407A4             0124*  ; and_hlu_deu: 24 bit bitwise AND
0407A4             0125*  ; Returns: hlu = hlu AND deu
0407A4             0126*  ; preserves all other registers
0407A4             0127*  ;------------------------------------------------------------------------
0407A4             0128*  and_hlu_deu:
0407A4 22 0B 08 04 0129*  	ld	(bitbuf1),hl
0407A8 ED 53 0E 08 0130*  	ld	(bitbuf2),de
       04          
0407AD D5          0131*  	push	de	;preserve DEU
0407AE C5          0132*  	push	bc	;preserve BCU
0407AF 06 03       0133*  	ld		b,3
0407B1 21 0B 08 04 0134*  	ld	hl,bitbuf1
0407B5 11 0B 08 04 0135*  	ld	de,bitbuf1
0407B9             0136*  andloop_24:
0407B9 1A          0137*  	ld	a,(de)
0407BA A6          0138*  	and	(hl)
0407BB 12          0139*  	ld	(de),a
0407BC 13          0140*  	inc	de
0407BD 23          0141*  	inc	hl
0407BE 10 F9       0142*  	djnz	andloop_24
0407C0 2A 0E 08 04 0143*  	ld	hl,(bitbuf2)
0407C4 C1          0144*  	pop		bc	;restore BC
0407C5 D1          0145*  	pop		de	;restore DE
0407C6             0146*  
0407C6             0147*  ;------------------------------------------------------------------------
0407C6             0148*  ; xor_hlu_deu: 24 bit bitwise XOR
0407C6             0149*  ; Returns: hlu = hlu XOR deu
0407C6             0150*  ; preserves all other registers
0407C6             0151*  ;------------------------------------------------------------------------
0407C6             0152*  xor_hlu_deu:
0407C6 22 0B 08 04 0153*  	ld	(bitbuf1),hl
0407CA ED 53 0E 08 0154*  	ld	(bitbuf2),de
       04          
0407CF D5          0155*  	push	de	;preserve DEU
0407D0 C5          0156*  	push	bc	;preserve BCU
0407D1 06 03       0157*  	ld		b,3
0407D3 21 0B 08 04 0158*  	ld	hl,bitbuf1
0407D7 11 0B 08 04 0159*  	ld	de,bitbuf1
0407DB             0160*  xorloop_24:
0407DB 1A          0161*  	ld	a,(de)
0407DC AE          0162*  	xor	(hl)
0407DD 12          0163*  	ld	(de),a
0407DE 13          0164*  	inc	de
0407DF 23          0165*  	inc	hl
0407E0 10 F9       0166*  	djnz	xorloop_24
0407E2 2A 0E 08 04 0167*  	ld	hl,(bitbuf2)
0407E6 C1          0168*  	pop		bc	;restore BC
0407E7 D1          0169*  	pop		de	;restore DE
0407E8             0170*  
0407E8             0171*  ;------------------------------------------------------------------------
0407E8             0172*  ; shl_hlu: 24 bit shift left hlu by a positions
0407E8             0173*  ; Returns: hlu = hlu << a
0407E8             0174*  ;		   a = 0
0407E8             0175*  ; NOTE: only considers a up to 16 bits.
0407E8             0176*  ; preserves all other registers
0407E8             0177*  ; modified by Brandon R. Gates to use a instead of de
0407E8             0178*  ;------------------------------------------------------------------------
0407E8             0179*  shl_hlu:
0407E8 B7          0180*  	or a
0407E9 C8          0181*  	ret		z		;we're done
0407EA 29          0182*  	add		hl,hl	;shift HLU left
0407EB 3D          0183*  	dec a
0407EC 18 FA       0184*  	jr		shl_hlu
0407EE             0185*  
0407EE             0186*  ;------------------------------------------------------------------------
0407EE             0187*  ; shr_hlu: 24 bit shift right hlu by a positions
0407EE             0188*  ; Returns: hlu = hlu >> a
0407EE             0189*  ;		   a = 0
0407EE             0190*  ; NOTE: only considers a up to 16 bits.
0407EE             0191*  ; preserves all other registers
0407EE             0192*  ; modified by Brandon R. Gates to use a instead of de
0407EE             0193*  ;------------------------------------------------------------------------
0407EE             0194*  shr_hlu:
0407EE 22 0B 08 04 0195*  	ld		(bitbuf1),hl
0407F2 21 0D 08 04 0196*  	ld		hl,bitbuf1+2
0407F6             0197*  @shr_loop:
0407F6 B7          0198*  	or a
0407F7 28 0D       0199*  	jr		z,@shr_done		;we're done
0407F9             0200*  ;carry is clear from or instruction
0407F9 CB 1E       0201*  	rr		(hl)
0407FB 2B          0202*  	dec		hl
0407FC CB 1E       0203*  	rr		(hl)
0407FE 2B          0204*  	dec		hl
0407FF CB 1E       0205*  	rr		(hl)
040801 23          0206*  	inc		hl
040802 23          0207*  	inc		hl
040803 3D          0208*  	dec a
040804 18 F0       0209*  	jr		@shr_loop
040806             0210*  @shr_done:
040806 2A 0B 08 04 0211*  	ld		hl,(bitbuf1)	;collect result
04080A C9          0212*  	ret
04080B             0213*  
04080B             0214*  ;------------------------------------------------------------------------
04080B             0215*  ; Scratch area for calculations
04080B             0216*  ;------------------------------------------------------------------------
04080B 00 00 00    0217*  bitbuf1:	dw24	0	;bit manipulation buffer 1
04080E 00 00 00    0218*  bitbuf2:	dw24	0	;bit manipulation buffer 2
040811             0219*  
040811             0220*  ; -----------------------------------------------------------------------
040811             0221*  ; Functions added by Brandon R. Gates
040811             0222*  ; -----------------------------------------------------------------------
040811             0223*  
040811             0224*  ;------------------------------------------------------------------------
040811             0225*  ; shr_hlu_div: Quick division by powers of two based on log2 of A
040811             0226*  ;              Determines the LSB of A and shifts HLU accordingly.
040811             0227*  ;              HLU = HLU >> LSB(A)
040811             0228*  ; Returns: HLU = HLU >> LSB(A)
040811             0229*  ; Destroys: af
040811             0230*  ;------------------------------------------------------------------------
040811             0231*  shr_hlu_log2a:
040811 B7          0232*  	or a    ; check for zero
040812 C8          0233*  	ret z   ; nothing to shift so we're done
040813 C5          0234*  	push 	bc ; preserve
040814 06 00       0235*  	ld		b,0 ; clear b
040816             0236*  @find_bit:
040816 0F          0237*  	rrca ; bit 0 to carry
040817 DA 20 08 04 0238*  	jp c,@found_bit
04081B 04          0239*  	inc b ; next bit
04081C C3 16 08 04 0240*  	jp @find_bit
040820             0241*  @found_bit:
040820 78          0242*  	ld a,b
040821 CD EE 07 04 0243*  	call shr_hlu
040825 C1          0244*  	pop 	bc ; restore
040826 C9          0245*  	ret
040827             0246*  ; end shr_hlu_log2a
040827             0247*  
040827             0248*  ;------------------------------------------------------------------------
040827             0249*  ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040827             0250*  ;                Determines the LSB of A and shifts HLU accordingly.
040827             0251*  ;                HLU = HLU << LSB(A)
040827             0252*  ; Returns: HLU = HLU << LSB(A)
040827             0253*  ; Destroys: af
040827             0254*  ;------------------------------------------------------------------------
040827             0255*  shl_hlu_log2a:
040827 B7          0256*  	or a    ; check for zero
040828 C8          0257*  	ret z   ; nothing to shift so we're done
040829 C5          0258*  	push 	bc ; preserve
04082A 06 00       0259*  	ld		b,0 ; clear b
04082C             0260*  @find_bit:
04082C 0F          0261*  	rrca ; bit 0 to carry
04082D DA 36 08 04 0262*  	jp c,@found_bit
040831 04          0263*  	inc b ; next bit
040832 C3 2C 08 04 0264*  	jp @find_bit
040836             0265*  @found_bit:
040836 78          0266*  	ld a,b
040837 CD E8 07 04 0267*  	call shl_hlu
04083B C1          0268*  	pop 	bc ; restore
04083C C9          0269*  	ret
04083D             0270*  ; end shl_hlu_log2a
04083D             0033       include "maths.inc"
04083D FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040900             0002*  
040900             0003*  ;------------------------------------------------------------------------
040900             0004*  ; Scratch area for calculations
040900             0005*  ;------------------------------------------------------------------------
040900 00 00 00    0006*  scratch1: dw24 0 ;bit manipulation buffer 1
040903 00 00 00    0007*  scratch2: dw24 0 ;bit manipulation buffer 2
040906             0008*  
040906             0009*  ; absolute value of hlu
040906             0010*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040906             0011*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040906             0012*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040906             0013*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040906             0014*  ; destroys: a
040906             0015*  hlu_abs:
040906 19          0016*      add hl,de
040907 B7          0017*      or a
040908 ED 52       0018*      sbc hl,de
04090A FA 0F 09 04 0019*      jp m,@is_neg
04090E C9          0020*      ret ; hlu is positive or zero so we're done
04090F             0021*  @is_neg:
04090F F5          0022*      push af ; otherwise, save current flags for return
040910 CD 16 09 04 0023*      call neg_hlu ; negate hlu
040914 F1          0024*      pop af ; get back flags
040915 C9          0025*      ret
040916             0026*  
040916             0027*  ; flip the sign of hlu
040916             0028*  ; inputs: hlu
040916             0029*  ; returns: 0-hlu, flags set appropriately for the result:
040916             0030*  ;         s1,z0,pv0,n1,c1 if result is negative
040916             0031*  ;         s0,z1,pv0,n1,c0 if result is zero
040916             0032*  ;         s0,z0,pv0,n1,c1 if result is positive
040916             0033*  ; destroys a
040916             0034*  neg_hlu:
040916 D5          0035*      push de ; save de
040917 EB          0036*      ex de,hl ; put hl into de
040918 21 00 00 00 0037*      ld hl,0 ; clear hl
04091C AF          0038*      xor a ; clear carry
04091D ED 52       0039*      sbc hl,de ; 0-hlu = -hlu
04091F D1          0040*      pop de ; get de back
040920 C9          0041*      ret ; easy peasy
040921             0042*  
040921             0043*  ;------------------------------------------------------------------------
040921             0044*  ; divide hlu by 2, inspired by above
040921             0045*  ;------------------------------------------------------------------------
040921             0046*  hlu_div2:
040921 22 00 09 04 0047*      ld (scratch1),hl
040925 21 02 09 04 0048*      ld hl,scratch1+2
040929 CB 1E       0049*      rr (hl)
04092B 2B          0050*      dec hl
04092C CB 1E       0051*      rr (hl)
04092E 2B          0052*      dec hl
04092F CB 1E       0053*      rr (hl)
040931 23          0054*      inc hl
040932 23          0055*      inc hl
040933 2A 00 09 04 0056*      ld hl,(scratch1)
040937 C9          0057*      ret
040938             0058*  
040938             0059*  ; this is my little hack to divide by 16
040938             0060*  hlu_div16:
040938 AF          0061*      xor a
040939 29          0062*      add hl,hl
04093A 17          0063*      rla
04093B 29          0064*      add hl,hl
04093C 17          0065*      rla
04093D 29          0066*      add hl,hl
04093E 17          0067*      rla
04093F 29          0068*      add hl,hl
040940 17          0069*      rla
040941 22 4E 09 04 0070*      ld (@scratch),hl
040945 32 51 09 04 0071*      ld (@scratch+3),a
040949 2A 4F 09 04 0072*      ld hl,(@scratch+1)
04094D C9          0073*      ret
04094E             0074*  @scratch: ds 4
040952             0075*  
040952             0076*  ; hlu signed division by 256
040952             0077*  ; returns: hlu / 256
040952             0078*  ; destroys: af
040952             0079*  hlu_sdiv256:
040952 AF          0080*      xor a ; assume hl is positive
040953 22 69 09 04 0081*      ld (@buffer),hl
040957             0082*      sign_hlu
040957 19          0001*M     add hl,de
040958 B7          0002*M     or a ; clear flags
040959 ED 52       0003*M     sbc hl,de
04095B F2 60 09 04 0083*      jp p,@hl_pos
04095F 3D          0084*      dec a
040960             0085*  @hl_pos:
040960 32 6C 09 04 0086*      ld (@buffer+3),a
040964 2A 6A 09 04 0087*      ld hl,(@buffer+1)
040968 C9          0088*      ret
040969             0089*  @buffer: ds 4
04096D             0090*  
04096D             0091*  ; hlu 1 byte right shift, unsigned
04096D             0092*  ; returns: hlu / 256, fractional portion in a
04096D             0093*  ; destroys: af
04096D             0094*  hlu_udiv256:
04096D AF          0095*      xor a
04096E 32 7F 09 04 0096*      ld (@buffer+3),a
040972 7D          0097*      ld a,l ; save the fractional portion
040973 22 7C 09 04 0098*      ld (@buffer),hl
040977 2A 7D 09 04 0099*      ld hl,(@buffer+1)
04097B C9          0100*      ret
04097C             0101*  @buffer: ds 4
040980             0102*  
040980 00 00 00 00 0103*  add_bcd_arg1: db #00,#00,#00,#00
040984 00 00 00 00 0104*  add_bcd_arg2: db #00,#00,#00,#00
040988             0105*  
040988             0106*  ; set bcd values in a scratch memory address from registers bcde
040988             0107*  ; input: hl; scratch address,bcde; 8-place bcd number
040988             0108*  ; destroys ; hl
040988             0109*  set_bcd:
040988 73          0110*      ld (hl),e
040989 23          0111*      inc hl
04098A 72          0112*      ld (hl),d
04098B 23          0113*      inc hl
04098C 71          0114*      ld (hl),c
04098D 23          0115*      inc hl
04098E 70          0116*      ld (hl),b
04098F C9          0117*      ret
040990             0118*  
040990             0119*  ; load bcd values from a scratch memory address to bcde
040990             0120*  ; input: hl; scratch address
040990             0121*  ; output: bcde; 8-place bcd number
040990             0122*  ; destroys: hl
040990             0123*  get_bcd:
040990 5E          0124*      ld e,(hl)
040991 23          0125*      inc hl
040992 56          0126*      ld d,(hl)
040993 23          0127*      inc hl
040994 4E          0128*      ld c,(hl)
040995 23          0129*      inc hl
040996 46          0130*      ld b,(hl)
040997 C9          0131*      ret
040998             0132*  
040998             0133*  ; BCD addition
040998             0134*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040998             0135*  ;       a is the number of bytes holding each number (number of places/2)
040998             0136*  ; outputs: (hl) + (de) --> (hl)
040998             0137*  ; destroys: a,b,de,hl
040998             0138*  add_bcd:
040998 47          0139*      ld b,a ; loop counter
040999 AF          0140*      xor a ; reset a, clear carry flag
04099A             0141*  adcec:
04099A 1A          0142*      ld a,(de) ; addend to acc
04099B 8E          0143*      adc a,(hl) ; add (hl) to acc
04099C 27          0144*      daa ; adjust result to bcd
04099D 77          0145*      ld (hl),a ; store result
04099E 23          0146*      inc hl ; advance memory pointers
04099F 13          0147*      inc de
0409A0 10 F8       0148*      djnz adcec ; loop until b == 0
0409A2 C9          0149*      ret
0409A3             0150*  
0409A3             0151*  ; BCD subtraction
0409A3             0152*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0409A3             0153*  ;       a is the number of bytes holding each number (number of places/2)
0409A3             0154*  ; outputs: (hl) - (de) --> (hl)
0409A3             0155*  ; destroys: a,b,de,hl
0409A3             0156*  sub_bcd:
0409A3 47          0157*      ld b,a ; loop counter
0409A4 AF          0158*      xor a ; reset a,clear carry flag
0409A5             0159*  subdec:
0409A5 1A          0160*      ld a,(de) ; subtrahend to acc
0409A6 9E          0161*      sbc a,(hl) ; subtract (hl) from acc
0409A7 27          0162*      daa ; adjust result to bcd
0409A8 77          0163*      ld (hl),a ; store result
0409A9 23          0164*      inc hl ; advance memory pointers
0409AA 13          0165*      inc de
0409AB 10 F8       0166*      djnz subdec ; loop until b == 0
0409AD C9          0167*      ret
0409AE             0168*  
0409AE             0169*  ; http://www.z80.info/pseudo-random.txt
0409AE             0170*  rand_8:
0409AE C5          0171*      push bc
0409AF 3A C2 09 04 0172*      ld a,(r_seed)
0409B3 4F          0173*      ld c,a
0409B4             0174*  
0409B4 0F          0175*      rrca ; multiply by 32
0409B5 0F          0176*      rrca
0409B6 0F          0177*      rrca
0409B7 EE 1F       0178*      xor 0x1f
0409B9             0179*  
0409B9 81          0180*      add a,c
0409BA DE FF       0181*      sbc a,255 ; carry
0409BC             0182*  
0409BC 32 C2 09 04 0183*      ld (r_seed),a
0409C0 C1          0184*      pop bc
0409C1 C9          0185*      ret
0409C2 50          0186*  r_seed: defb $50
0409C3             0187*  
0409C3             0188*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0409C3             0189*  prng24:
0409C3             0190*  ;;Expects ADL mode.
0409C3             0191*  ;;Output: HL
0409C3             0192*  ;;50cc
0409C3             0193*  ;;33 bytes
0409C3             0194*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0409C3 ED 5B E4 09 0195*      ld de,(seed1)
       04          
0409C8 B7          0196*      or a
0409C9 ED 62       0197*      sbc hl,hl
0409CB 19          0198*      add hl,de
0409CC 29          0199*      add hl,hl
0409CD 29          0200*      add hl,hl
0409CE 2C          0201*      inc l
0409CF 19          0202*      add hl,de
0409D0 22 E4 09 04 0203*      ld (seed1),hl
0409D4 2A E7 09 04 0204*      ld hl,(seed2)
0409D8 29          0205*      add hl,hl
0409D9 9F          0206*      sbc a,a
0409DA E6 1B       0207*      and %00011011
0409DC AD          0208*      xor l
0409DD 6F          0209*      ld l,a
0409DE 22 E7 09 04 0210*      ld (seed2),hl
0409E2 19          0211*      add hl,de
0409E3 C9          0212*      ret
0409E4 00 00 00    0213*  seed1: dl 0
0409E7 00 00 00    0214*  seed2: dl 0
0409EA             0034       include "files.inc"
0409EA             0001*  ; load to onboard 8k sram
0409EA             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0409EA             0035       include "fixed168.inc"
0409EA FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
040A00             0002*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A00             0003*  ; uses EZ80 MLT instruction for speed
040A00             0004*  ; operation: UHL * A --> UHL
040A00             0005*  ; destroys: AF, HL
040A00             0006*  smul24x8:
040A00             0007*  ; make hl positive and store sign flag
040A00 CD 06 09 04 0008*      call hlu_abs
040A04 F5          0009*      push af
040A05             0010*  ; do the division
040A05 CD 10 0A 04 0011*      call mul24x8 ; hl = product
040A09             0012*  ; adjust sign of result
040A09 F1          0013*      pop af ; sign de
040A0A F0          0014*      ret p ; hl was positive, nothing to do
040A0B CD 16 09 04 0015*      call neg_hlu ; result is negative
040A0F C9          0016*      ret
040A10             0017*  
040A10             0018*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A10             0019*  ; uses EZ80 MLT instruction for speed
040A10             0020*  ; operation: UHL * A --> AUHL
040A10             0021*  ; destroys: AF, HL
040A10             0022*  mul24x8:
040A10 D5          0023*      push de ; preserve de
040A11             0024*  ; low byte
040A11 5D          0025*      ld e,l
040A12 57          0026*      ld d,a
040A13 ED 5C       0027*      mlt de
040A15 6B          0028*      ld l,e ; product low byte
040A16 08          0029*      ex af,af' ; save multiplier
040A17 7A          0030*      ld a,d ; carry
040A18 08          0031*      ex af,af' ; save carry, restore multiplier
040A19             0032*  ; high byte
040A19 5C          0033*      ld e,h
040A1A 57          0034*      ld d,a
040A1B ED 5C       0035*      mlt de
040A1D 08          0036*      ex af,af' ; save multiplier, restore carry
040A1E 83          0037*      add a,e ; add carry
040A1F 67          0038*      ld h,a ; product middle byte
040A20 7A          0039*      ld a,d ; carry
040A21 08          0040*      ex af,af' ; save carry, restore multiplier
040A22             0041*  ; upper byte
040A22 22 3D 0A 04 0042*      ld (@scratch),hl ; 7 cycles
040A26 5F          0043*      ld e,a
040A27 3A 3F 0A 04 0044*      ld a,(@scratch+2)
040A2B 57          0045*      ld d,a
040A2C ED 5C       0046*      mlt de
040A2E 08          0047*      ex af,af' ; restore carry
040A2F 8B          0048*      adc a,e ; add carry
040A30 32 3F 0A 04 0049*      ld (@scratch+2),a ; 5 cycles
040A34 2A 3D 0A 04 0050*      ld hl,(@scratch) ; 7 cycles
040A38             0051*  ; highest byte
040A38 3E 00       0052*      ld a,0 ; preserve carry flag
040A3A 8A          0053*      adc a,d ; product highest byte
040A3B D1          0054*      pop de ; restore de
040A3C C9          0055*      ret
040A3D             0056*  @scratch: ds 3
040A40             0057*  
040A40 00 00 00 00 0058*  mul24out: blkb 6,0
       00 00       
040A46             0059*  
040A46             0060*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A46             0061*  ; operation: UHL * UDE --> mul24out
040A46             0062*  mul24:
040A46 DD E5       0063*      push ix ; preserve
040A48             0064*  ; point to output buffer and clear it
040A48 DD 21 40 0A 0065*      ld ix,mul24out
       04          
040A4D C5          0066*      push bc
040A4E 01 00 00 00 0067*      ld bc,0
040A52 DD 0F 00    0068*      ld (ix),bc
040A55 DD 0F 03    0069*      ld (ix+3),bc
040A58 C1          0070*      pop bc
040A59             0071*  ; STEP 1: UHL * E
040A59 7B          0072*      ld a,e
040A5A E5          0073*      push hl
040A5B CD 10 0A 04 0074*      call mul24x8
040A5F DD 2F 00    0075*      ld (ix+0),hl
040A62 DD 77 03    0076*      ld (ix+3),a
040A65             0077*  ; STEP 2: UHL * D
040A65 E1          0078*      pop hl
040A66 E5          0079*      push hl
040A67 7A          0080*      ld a,d
040A68 CD 10 0A 04 0081*      call mul24x8
040A6C CD 85 0A 04 0082*      call @accumulate
040A70             0083*  ; STEP 3: UHL * DEU
040A70 E1          0084*      pop hl
040A71 ED 53 B5 0A 0085*      ld (@de),de
       04          
040A76 3A B7 0A 04 0086*      ld a,(@de+2)
040A7A CD 10 0A 04 0087*      call mul24x8
040A7E CD 85 0A 04 0088*      call @accumulate
040A82             0089*  ; all done
040A82 DD E1       0090*      pop ix ; restore
040A84 C9          0091*      ret
040A85             0092*  @accumulate:
040A85 DD 23       0093*      inc ix
040A87             0094*  ; highest byte of product to carry
040A87 DD 77 03    0095*      ld (ix+3),a
040A8A             0096*  ; low byte of product
040A8A 7D          0097*      ld a,l
040A8B DD 86 00    0098*      add a,(ix+0)
040A8E DD 77 00    0099*      ld (ix+0),a
040A91             0100*  ; high byte of product
040A91 7C          0101*      ld a,h
040A92 DD 8E 01    0102*      adc a,(ix+1)
040A95 DD 77 01    0103*      ld (ix+1),a
040A98             0104*  ; uppper byte of product
040A98 22 B2 0A 04 0105*      ld (@hl),hl
040A9C 3A B4 0A 04 0106*      ld a,(@hl+2)
040AA0 DD 8E 02    0107*      adc a,(ix+2)
040AA3 DD 77 02    0108*      ld (ix+2),a
040AA6             0109*  ; carry
040AA6 3E 00       0110*      ld a,0 ; preserve flags
040AA8 DD 8E 03    0111*      adc a,(ix+3)
040AAB DD 77 03    0112*      ld (ix+3),a
040AAE C9          0113*      ret
040AAF             0114*  
040AAF 00 00 00    0115*  @ix: dl 0
040AB2 00 00 00    0116*  @hl: dl 0
040AB5 00 00 00    0117*  @de: dl 0
040AB8             0118*  
040AB8             0119*  ; ; UHL * UDE --> UHL (unsigned)
040AB8             0120*  ; umul24:
040AB8             0121*  ;     call mul24
040AB8             0122*  ;     ld hl,(mul24out)
040AB8             0123*  ;     ret
040AB8             0124*  
040AB8             0125*  ; UH.L = UH.L*UD.E (unsigned)
040AB8             0126*  umul168:
040AB8 CD 46 0A 04 0127*      call mul24
040ABC 2A 41 0A 04 0128*      ld hl,(mul24out+1)
040AC0 C9          0129*      ret
040AC1             0130*  
040AC1             0131*  ; UH.L * UD.E --> UH.L (signed)
040AC1             0132*  smul168:
040AC1             0133*  ; make everything positive and store sign flags
040AC1 CD 06 09 04 0134*      call hlu_abs
040AC5 F5          0135*      push af
040AC6 EB          0136*      ex de,hl
040AC7 CD 06 09 04 0137*      call hlu_abs
040ACB EB          0138*      ex de,hl
040ACC F5          0139*      push af
040ACD             0140*  ; do the division
040ACD CD B8 0A 04 0141*      call umul168 ; hl = product
040AD1             0142*  ; adjust sign of result
040AD1 F1          0143*      pop af ; sign de
040AD2 FA DD 0A 04 0144*      jp m,@de_neg
040AD6 F1          0145*      pop af ; sign hl
040AD7 F0          0146*      ret p ; both positive, nothing to do
040AD8             0147*  @hl_neg:
040AD8 CD 16 09 04 0148*      call neg_hlu ; de pos, hl neg, result is negative
040ADC C9          0149*      ret
040ADD             0150*  @de_neg:
040ADD F1          0151*      pop af
040ADE F8          0152*      ret m ; both negative, nothing to do
040ADF CD 16 09 04 0153*      call neg_hlu ; result is negative
040AE3 C9          0154*      ret
040AE4             0155*  
040AE4             0156*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040AE4             0157*  ; perform unsigned division of 16.8 fixed place values
040AE4             0158*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040AE4             0159*  udiv168:
040AE4             0160*  ; back up divisor
040AE4 ED 53 1B 0B 0161*      ld (@ude),de
       04          
040AE9             0162*  ; get the 16-bit integer part of the quotient
040AE9 CD 53 07 04 0163*      call udiv24 ; de = quotient, hl = remainder
040AED             0164*  ; load quotient to upper three bytes of output
040AED ED 53 22 0B 0165*      ld (div168_out+1),de
       04          
040AF2             0166*  @div256:
040AF2             0167*  ; multiply remainder by 256
040AF2             0168*      hlu_mul256
040AF2 29          0001*M     add hl,hl ; * 2
040AF3 29          0002*M     add hl,hl ; * 4
040AF4 29          0003*M     add hl,hl ; * 8
040AF5 29          0004*M     add hl,hl ; * 16
040AF6 29          0005*M     add hl,hl ; * 32
040AF7 29          0006*M     add hl,hl ; * 64
040AF8 29          0007*M     add hl,hl ; * 128
040AF9 29          0008*M     add hl,hl ; * 256
040AFA             0169*  ; skip fractional computation if remainder is zero
040AFA             0170*      sign_hlu
040AFA 19          0001*M     add hl,de
040AFB B7          0002*M     or a ; clear flags
040AFC ED 52       0003*M     sbc hl,de
040AFE 20 03       0171*      jr nz,@div_frac
040B00 AF          0172*      xor a
040B01 18 0A       0173*      jr @write_frac
040B03             0174*  ; now divide the shifted remainder by the divisor
040B03             0175*  @div_frac:
040B03 ED 5B 1B 0B 0176*      ld de,(@ude) ; get back divisor
       04          
040B08 CD 53 07 04 0177*      call udiv24 ; de = quotient, hl = remainder
040B0C             0178*  ; load low byte of quotient to low byte of output
040B0C 7B          0179*      ld a,e
040B0D             0180*  @write_frac:
040B0D 32 21 0B 04 0181*      ld (div168_out),a
040B11             0182*  ; load de with return value
040B11 ED 5B 21 0B 0183*      ld de,(div168_out)
       04          
040B16             0184*  ; load a with any overflow
040B16 3A 24 0B 04 0185*      ld a,(div168_out+3)
040B1A C9          0186*      ret ; ud.e is the 16.8 result
040B1B             0187*  @ude: ds 6
040B21             0188*  div168_out: ds 4 ; the extra byte is for overflow
040B25             0189*  
040B25             0190*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B25             0191*  ; perform signed division of 16.8 fixed place values
040B25             0192*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B25             0193*  sdiv168:
040B25             0194*  ; make everything positive and store sign flags
040B25 CD 06 09 04 0195*      call hlu_abs
040B29 F5          0196*      push af
040B2A EB          0197*      ex de,hl
040B2B CD 06 09 04 0198*      call hlu_abs
040B2F EB          0199*      ex de,hl
040B30 F5          0200*      push af
040B31             0201*  ; do the division
040B31 CD E4 0A 04 0202*      call udiv168 ; de = quotient, hl = remainder
040B35             0203*  ; adjust sign of result
040B35 F1          0204*      pop af ; sign de
040B36 FA 43 0B 04 0205*      jp m,@de_neg
040B3A F1          0206*      pop af ; sign hl
040B3B F0          0207*      ret p ; both positive, nothing to do
040B3C             0208*  @hl_neg:
040B3C EB          0209*      ex de,hl ; hl = quotient, de = remainder
040B3D CD 16 09 04 0210*      call neg_hlu ; de pos, hl neg, result is negative
040B41 EB          0211*      ex de,hl ; de = negated quotient, hl = remainder
040B42 C9          0212*      ret
040B43             0213*  @de_neg:
040B43 F1          0214*      pop af
040B44 F8          0215*      ret m ; both negative, nothing to do
040B45 EB          0216*      ex de,hl ; hl = quotient, de = remainder
040B46 CD 16 09 04 0217*      call neg_hlu ; result is negative
040B4A EB          0218*      ex de,hl ; de = negated quotient, hl = remainder
040B4B C9          0219*      ret
040B4C             0220*  
040B4C             0221*  ; convert signed angles from a 360 to 256 degree circle
040B4C             0222*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B4C             0223*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B4C             0224*  ; destroys: TODO
040B4C             0225*  deg_360_to_256:
040B4C D5          0226*      push de ; preserve de
040B4D             0227*  ; make angle positive and store sign flag
040B4D CD 06 09 04 0228*      call hlu_abs
040B51 F5          0229*      push af
040B52             0230*  ; multiply by coversion factor of 256/360
040B52 11 B6 00 00 0231*      ld de,0x0000B6 ; 0.711
040B56 CD B8 0A 04 0232*      call umul168 ; uh.l = uh.l * 0.711
040B5A             0233*  ; restore sign flag and adjust output accordingly
040B5A F1          0234*      pop af
040B5B F2 63 0B 04 0235*      jp p,@pos ; positive number
040B5F CD 16 09 04 0236*      call neg_hlu
040B63             0237*  @pos:
040B63             0238*  ; restore de and return uh.l as the result
040B63 D1          0239*      pop de
040B64 C9          0240*      ret
040B65             0241*  
040B65             0242*  ; convert signed angles from a 256 to 360 degree circle
040B65             0243*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040B65             0244*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040B65             0245*  ; destroys: TODO
040B65             0246*  deg_256_to_360:
040B65 D5          0247*      push de ; preserve de
040B66             0248*  ; make angle positive and store sign flag
040B66 CD 06 09 04 0249*      call hlu_abs
040B6A F5          0250*      push af
040B6B             0251*  ; multiply by coversion factor of 360/256
040B6B 11 68 01 00 0252*      ld de,0x000168 ; 1.406
040B6F CD B8 0A 04 0253*      call umul168 ; uh.l = uh.l * 1.406
040B73             0254*  ; restore sign flag and adjust output accordingly
040B73 F1          0255*      pop af
040B74 F2 7C 0B 04 0256*      jp p,@pos ; positive number
040B78 CD 16 09 04 0257*      call neg_hlu
040B7C             0258*  @pos:
040B7C             0259*  ; restore de and return uh.l as the result
040B7C D1          0260*      pop de
040B7D C9          0261*      ret
040B7E             0262*  
040B7E             0263*  ; fixed 16.8 routine
040B7E             0264*  ; cos(uh.l) --> uh.l
040B7E             0265*  ; destroys: f, hl
040B7E             0266*  cos168:
040B7E D5          0267*      push de ; preserve de
040B7F             0268*  ; for cos we simply increment the angle by 90 degrees
040B7F             0269*  ; or 0x004000 in 16.8 degrees256
040B7F             0270*  ; which makes it a sin problem
040B7F 11 00 40 00 0271*      ld de,0x004000
040B83 19          0272*      add hl,de ; modulo 256 happens below
040B84 D1          0273*      pop de ; restore de
040B85             0274*  ; fall through to sin168
040B85             0275*  
040B85             0276*  ; ---------------------
040B85             0277*  ; fixed 16.8 routine
040B85             0278*  ; sin(uh.l) --> uh.l
040B85             0279*  ; destroys: f, hl
040B85             0280*  sin168:
040B85 D5          0281*      push de
040B86             0282*  ; handle negative angles appropriately
040B86 CD 06 09 04 0283*      call hlu_abs
040B8A F2 93 0B 04 0284*      jp p,@F
040B8E 11 00 00 FF 0285*      ld de,-256*256
040B92 19          0286*      add hl,de
040B93             0287*  @@:
040B93 2E 03       0288*      ld l,3 ; multiply by 3 to get our lookup index
040B95 ED 6C       0289*      mlt hl
040B97 11 4D 0E 04 0290*      ld de,sin_lut_168 ; grab the lut address
040B9B 19          0291*      add hl,de ; bump hl by the index
040B9C ED 27       0292*      ld hl,(hl) ; don't try this on a z80!
040B9E D1          0293*      pop de
040B9F C9          0294*      ret
040BA0             0295*  
040BA0             0296*  ; 16.8 fixed inputs / outputs
040BA0             0297*  ; takes: uh.l as angle in degrees 256
040BA0             0298*  ;        ud.e as radius
040BA0             0299*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BA0             0300*  ;        displacements from origin (0,0)
040BA0             0301*  ; destroys: everything except indexes
040BA0             0302*  polar_to_cartesian:
040BA0             0303*  ; back up input parameters
040BA0 22 CF 0B 04 0304*      ld (@angle), hl
040BA4 ED 53 D2 0B 0305*      ld (@radius), de
       04          
040BA9             0306*  ; compute dx = sin(uh.l) * ud.e
040BA9 CD 85 0B 04 0307*      call sin168 ; uh.l = sin(uh.l)
040BAD ED 5B D2 0B 0308*      ld de,(@radius)
       04          
040BB2 CD C1 0A 04 0309*      call smul168 ; uh.l = dx
040BB6 E5          0310*      push hl
040BB7             0311*  ; compute dy = -cos(uh.l) * ud.e
040BB7 2A CF 0B 04 0312*      ld hl,(@angle)
040BBB CD 7E 0B 04 0313*      call cos168 ; uh.l = cos(uh.l)
040BBF ED 5B D2 0B 0314*      ld de,(@radius)
       04          
040BC4 CD C1 0A 04 0315*      call smul168 ; uh.l = dy
040BC8 CD 16 09 04 0316*      call neg_hlu ; invert dy for screen coords convention
040BCC EB          0317*      ex de,hl ; de = dy for output
040BCD C1          0318*      pop bc ; bc = dx for output
040BCE             0319*  ; and out
040BCE C9          0320*      ret
040BCF             0321*  @angle: ds 3
040BD2             0322*  @radius: ds 3
040BD5             0323*  
040BD5             0324*  ; 16.8 fixed inputs / outputs
040BD5             0325*  ; inputs: ub.c as dx, ud.e as dy
040BD5             0326*  ;        displacements from origin (0,0)
040BD5             0327*  ; returns: uh.l as angle in degrees 256
040BD5             0328*  ;        ud.e as radius
040BD5             0329*  ; destroys: everything except indexes
040BD5             0330*  cartesian_to_polar:
040BD5 ED 43 2E 0C 0331*      ld (dx168),bc ; dx argument for distance168
       04          
040BDA ED 53 34 0C 0332*      ld (dy168),de ; dy argument for distance168
       04          
040BDF             0333*  ; compute radius
040BDF CD 3A 0C 04 0334*      call distance168 ; uh.l = radius
040BE3 E5          0335*      push hl ; save radius
040BE4             0336*  ; compute angle
040BE4 ED 4B 2E 0C 0337*      ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040BE9 ED 5B 34 0C 0338*      ld de,(dy168) ; dy argument for atan2_168fast
       04          
040BEE CD 9C 0C 04 0339*      call atan2_168fast ; uh.l = angle
040BF2             0340*  ; return result
040BF2 D1          0341*      pop de ; de = radius (was hl)
040BF3 C9          0342*      ret
040BF4             0343*  ; end cartesian_to_polar
040BF4             0344*  
040BF4             0345*  ; 16.8 fixed inputs / outputs
040BF4             0346*  ; inputs: ub.c as dx, ud.e as dy
040BF4             0347*  ;        displacements from origin (0,0)
040BF4             0348*  ; returns: uh.l as angle in degrees 256
040BF4             0349*  ;        ud.e as radius
040BF4             0350*  ; destroys: everything except indexes
040BF4             0351*  ; note: uses distance168sm which is more accurate for small deltas
040BF4             0352*  cartesian_to_polar_sm:
040BF4 ED 43 2E 0C 0353*      ld (dx168),bc ; dx argument for distance168
       04          
040BF9 ED 53 34 0C 0354*      ld (dy168),de ; dy argument for distance168
       04          
040BFE             0355*  ; compute radius
040BFE CD 77 0C 04 0356*      call distance168sm ; uh.l = radius
040C02 E5          0357*      push hl ; save radius
040C03             0358*  ; compute angle
040C03 ED 4B 2E 0C 0359*      ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C08 ED 5B 34 0C 0360*      ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C0D CD 9C 0C 04 0361*      call atan2_168fast ; uh.l = angle
040C11             0362*  ; return result
040C11 D1          0363*      pop de ; de = radius (was hl)
040C12 C9          0364*      ret
040C13             0365*  ; end cartesian_to_polar
040C13             0366*  
040C13             0367*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C13             0368*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C13             0369*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C13             0370*  ;         also populates scratch locations dx168 and dy168
040C13             0371*  ; destroys: a,hl,bc,de
040C13             0372*  dxy168:
040C13             0373*  ; compute dx = x1-x0
040C13 AF          0374*      xor a ; clear carry
040C14 DD E5       0375*      push ix ; move ix to hl via the stack
040C16 E1          0376*      pop hl ; hl = x1
040C17 ED 42       0377*      sbc hl,bc ; hl = dx
040C19 22 2E 0C 04 0378*      ld (dx168),hl ; dx to scratch
040C1D             0379*  ; compute dy = y1-y0
040C1D AF          0380*      xor a ; clear carry
040C1E FD E5       0381*      push iy ; move iy to hl via the stack
040C20 E1          0382*      pop hl ; hl = y1
040C21 ED 52       0383*      sbc hl,de ; hl = dy
040C23 22 34 0C 04 0384*      ld (dy168),hl ; dy to scratch
040C27             0385*  ; populate output registers and return
040C27 EB          0386*      ex de,hl ; ud.e = dy
040C28 ED 4B 2E 0C 0387*      ld bc,(dx168) ; ub.c = dx
       04          
040C2D C9          0388*      ret
040C2E 00 00 00 00 0389*  dx168: blkb 6,0
       00 00       
040C34 00 00 00 00 0390*  dy168: blkb 6,0
       00 00       
040C3A             0391*  
040C3A             0392*  ; compute the euclidian distance between two cartesian coordinates
040C3A             0393*  ; using the formula d = sqrt(dx^2+dy^2)
040C3A             0394*  ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C3A             0395*  ; output; uh.l is the 16.8 fixed format distance
040C3A             0396*  ;         also populates scratch locations dx168 and dy168
040C3A             0397*  ; destroys: a,hl,bc,de
040C3A             0398*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C3A             0399*  ;       thus the result will always be an integer, albeit in 16.8 format
040C3A             0400*  distance168:
040C3A             0401*  ; compute dy^2
040C3A 2A 34 0C 04 0402*      ld hl,(dy168)
040C3E CD 06 09 04 0403*      call hlu_abs
040C42             0404*      ; call hlu_udiv256 ; make integer to avoid overflow
040C42             0405*      uhl_udiv256 ; make integer to avoid overflow
040C42 7D          0001*M     ld a,l
040C43 3B          0002*M     dec sp
040C44 E5          0003*M     push hl
040C45 33          0004*M     inc sp
040C46 E1          0005*M     pop hl
040C47 23          0006*M     inc hl
040C48 52 2B       0007*M     dec.s hl ; <-- the .s sets hlu to zero (undocumented)
040C4A E5          0406*      push hl
040C4B D1          0407*      pop de
040C4C CD 3A 07 04 0408*      call umul24 ; hl = dy^2
040C50 E5          0409*      push hl ; save dy^2
040C51             0410*  ; compute dx^2
040C51 2A 2E 0C 04 0411*      ld hl,(dx168)
040C55 CD 06 09 04 0412*      call hlu_abs
040C59             0413*      ; call hlu_udiv256 ; make integer to avoid overflow
040C59             0414*      uhl_udiv256 ; make integer to avoid overflow
040C59 7D          0001*M     ld a,l
040C5A 3B          0002*M     dec sp
040C5B E5          0003*M     push hl
040C5C 33          0004*M     inc sp
040C5D E1          0005*M     pop hl
040C5E 23          0006*M     inc hl
040C5F 52 2B       0007*M     dec.s hl ; <-- the .s sets hlu to zero (undocumented)
040C61 E5          0415*      push hl
040C62 D1          0416*      pop de
040C63 CD 3A 07 04 0417*      call umul24 ; hl = dx^2
040C67             0418*  ; add dx^2 and dy^2
040C67 D1          0419*      pop de ; de = dy^2 (was hl)
040C68 19          0420*      add hl,de ; hl = dx^2 + dy^2
040C69             0421*  ; compute the square root
040C69 CD 67 0D 04 0422*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C6D EB          0423*      ex de,hl ; hl = distance
040C6E             0424*      hlu_mul256 ; convert back to 16.8 fixed
040C6E 29          0001*M     add hl,hl ; * 2
040C6F 29          0002*M     add hl,hl ; * 4
040C70 29          0003*M     add hl,hl ; * 8
040C71 29          0004*M     add hl,hl ; * 16
040C72 29          0005*M     add hl,hl ; * 32
040C73 29          0006*M     add hl,hl ; * 64
040C74 29          0007*M     add hl,hl ; * 128
040C75 29          0008*M     add hl,hl ; * 256
040C76 C9          0425*      ret
040C77             0426*  
040C77             0427*  ; compute the euclidian distance between two cartesian coordinates
040C77             0428*  ; using the formula d = sqrt(dx^2+dy^2)
040C77             0429*  ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C77             0430*  ; output; uh.l is the 16.8 fixed format distance
040C77             0431*  ;         also populates scratch locations dx168 and dy168
040C77             0432*  ; destroys: a,hl,bc,de
040C77             0433*  ; NOTE: sm means 'small' because it doesn't round down the deltas
040C77             0434*  ;       making it more accurate for small deltas,
040C77             0435*  ;       but will overflow if used for screen-sized deltas
040C77             0436*  distance168sm:
040C77             0437*  ; compute dy^2
040C77 2A 34 0C 04 0438*      ld hl,(dy168)
040C7B CD 06 09 04 0439*      call hlu_abs
040C7F E5          0440*      push hl
040C80 D1          0441*      pop de
040C81 CD 3A 07 04 0442*      call umul24 ; hl = dy^2
040C85 E5          0443*      push hl ; save dy^2
040C86             0444*  ; compute dx^2
040C86 2A 2E 0C 04 0445*      ld hl,(dx168)
040C8A CD 06 09 04 0446*      call hlu_abs
040C8E E5          0447*      push hl
040C8F D1          0448*      pop de
040C90 CD 3A 07 04 0449*      call umul24 ; hl = dx^2
040C94             0450*  ; add dx^2 and dy^2
040C94 D1          0451*      pop de ; de = dy^2 (was hl)
040C95 19          0452*      add hl,de ; hl = dx^2 + dy^2
040C96             0453*  ; compute the square root
040C96 CD 67 0D 04 0454*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C9A EB          0455*      ex de,hl ; hl = distance
040C9B C9          0456*      ret
040C9C             0457*  
040C9C             0458*  ; atan2_(ub.c,ud.e) --> uh.l
040C9C             0459*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C9C             0460*  ;   whether inputs are integers or fractional doesn't matter
040C9C             0461*  ;   so long as the sign bit of the upper byte is correct
040C9C             0462*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C9C             0463*  ; angles are COMPASS HEADINGS based on
040C9C             0464*  ; screen coordinate conventions,where the y axis is flipped
040C9C             0465*  ; #E0 224      0       32 #20
040C9C             0466*  ;        -x,-y | +x,-y
040C9C             0467*  ; #C0 192------+------ 64 #40
040C9C             0468*  ;        -x,+y | +x,+y
040C9C             0469*  ; #A0 160   128 #80   96 #60
040C9C             0470*  atan2_168fast:
040C9C             0471*  ; get signs and make everything positive
040C9C             0472*  ; get abs(x) and store its original sign
040C9C C5          0473*      push bc
040C9D E1          0474*      pop hl
040C9E CD 06 09 04 0475*      call hlu_abs ; if x was negative this also sets the sign flag
040CA2 E5          0476*      push hl ; store abs(x)
040CA3 C1          0477*      pop bc ; bc = abs(x)
040CA4 F5          0478*      push af ; store sign of x
040CA5             0479*  ; get abs(y) and store its original sign
040CA5 EB          0480*      ex de,hl ; hl = y
040CA6 CD 06 09 04 0481*      call hlu_abs ; if y was negative this also sets the sign flag
040CAA EB          0482*      ex de,hl ; de = abs(y)
040CAB F5          0483*      push af ; store sign of y
040CAC             0484*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CAC             0485*  ; this ensures that our lookup value is between 0 and 1 inclusive
040CAC AF          0486*      xor a ; clear the carry flag
040CAD D5          0487*      push de
040CAE E1          0488*      pop hl
040CAF ED 42       0489*      sbc hl,bc
040CB1 F5          0490*      push af ; save sign of de - bc
040CB2 F2 BB 0C 04 0491*      jp p,@1 ; bc <= de, so we skip ahead
040CB6             0492*  ; otherwise we swap bc and de
040CB6 C5          0493*      push bc
040CB7 E1          0494*      pop hl
040CB8 EB          0495*      ex de,hl
040CB9 E5          0496*      push hl
040CBA C1          0497*      pop bc
040CBB             0498*  @1:
040CBB             0499*  ; now we're ready to snag our preliminary result
040CBB C5          0500*      push bc
040CBC E1          0501*      pop hl
040CBD CD 2B 0D 04 0502*      call atan_168fast ; uh.l comes back with prelim result
040CC1             0503*  ; now we adjust uh.l based on sign of de - bc
040CC1 F1          0504*      pop af
040CC2 F2 CE 0C 04 0505*      jp p,@2 ; bc <= de,so we skip ahead
040CC6 EB          0506*      ex de,hl
040CC7 21 00 40 00 0507*      ld hl,64*256 ; subtract from 64 (90) degrees
040CCB AF          0508*      xor a ; clear the carry flag
040CCC ED 52       0509*      sbc hl,de
040CCE             0510*  @2:
040CCE             0511*  ; adjust the result based on quadrant
040CCE             0512*  ; #E0 224      0       32 #20
040CCE             0513*  ;        -x,-y | +x,-y
040CCE             0514*  ; #C0 192------+------ 64 #40
040CCE             0515*  ;        -x,+y | +x,+y
040CCE             0516*  ; #A0 160   128 #80   96 #60
040CCE F1          0517*      pop af ; sign of y
040CCF CA 0C 0D 04 0518*      jp z,@y_zero
040CD3 F2 EC 0C 04 0519*      jp p,@y_pos
040CD7             0520*  ; y neg,check x
040CD7 F1          0521*      pop af ; sign of x
040CD8 CA E6 0C 04 0522*      jp z,@y_neg_x_zero
040CDC F2 EB 0C 04 0523*      jp p,@y_neg_x_pos
040CE0             0524*  ; y neg,x neg
040CE0             0525*  ; angle is 128 to 256 (270 to 360)
040CE0             0526*  ; negating the intermediate does the trick
040CE0 CD 16 09 04 0527*      call neg_hlu
040CE4 18 31       0528*      jr @zero_hlu
040CE6             0529*  
040CE6             0530*  @y_neg_x_zero:
040CE6             0531*  ; y neg,x zero
040CE6             0532*  ; angle is 0
040CE6 21 00 00 00 0533*      ld hl,0
040CEA C9          0534*      ret
040CEB             0535*  @y_neg_x_pos:
040CEB             0536*  ; y neg,x pos
040CEB             0537*  ; angle is 0 to 64 (0 to 90)
040CEB             0538*  ; so we're good
040CEB C9          0539*      ret
040CEC             0540*  
040CEC             0541*  @y_pos:
040CEC F1          0542*      pop af ; sign of x
040CED CA FC 0C 04 0543*      jp z,@y_pos_x_zero
040CF1 F2 01 0D 04 0544*      jp p,@y_pos_x_pos
040CF5             0545*  ; y pos,x neg
040CF5             0546*  ; angle is 128 to 192 (180-270)
040CF5             0547*  ; so we add 128 to intermediate
040CF5 11 00 80 00 0548*      ld de,128*256
040CF9 19          0549*      add hl,de
040CFA 18 1B       0550*      jr @zero_hlu
040CFC             0551*  @y_pos_x_zero:
040CFC             0552*  ; y pos,x zero
040CFC             0553*  ; angle is 128 (180)
040CFC 21 00 80 00 0554*      ld hl,128*256
040D00 C9          0555*      ret
040D01             0556*  @y_pos_x_pos:
040D01             0557*  ; y pos,x pos
040D01             0558*  ; angle is 64 to 128 (90 to 180)
040D01             0559*  ; neg the intermediate and add 180 degrees
040D01 CD 16 09 04 0560*      call neg_hlu
040D05 11 00 80 00 0561*      ld de,128*256
040D09 19          0562*      add hl,de
040D0A 18 0B       0563*      jr @zero_hlu
040D0C             0564*  
040D0C             0565*  @y_zero:
040D0C F1          0566*      pop af ; sign of x
040D0D FA 12 0D 04 0567*      jp m,@y_zero_x_neg
040D11             0568*  ; y zero,x pos
040D11             0569*  ; angle is 64 (90),nothing to do
040D11 C9          0570*      ret
040D12             0571*  @y_zero_x_neg:
040D12             0572*  ; y zero ,x neg
040D12             0573*  ; angle is 192 (270)
040D12 21 00 C0 00 0574*      ld hl,192*256
040D16 C9          0575*      ret
040D17             0576*  @zero_hlu:
040D17 AF          0577*      xor a
040D18 22 25 0D 04 0578*      ld (@scratch),hl
040D1C 32 27 0D 04 0579*      ld (@scratch+2),a
040D20 2A 25 0D 04 0580*      ld hl,(@scratch)
040D24 C9          0581*      ret
040D25             0582*  @scratch: ds 6
040D2B             0583*  
040D2B             0584*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D2B             0585*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D2B             0586*  ; destroys: a,hl,bc,de
040D2B             0587*  ; note: only works for angles from 0 to 32 (45) degrees
040D2B             0588*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D2B             0589*  atan_168fast:
040D2B             0590*  ; because we use compass headings instead of geometric angles
040D2B             0591*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040D2B             0592*  ; we can do faster unsigned division here because we know dx and dy are positive
040D2B CD E4 0A 04 0593*      call udiv168 ; ud.e = dx/dy
040D2F EB          0594*      ex de,hl ; uh.l = dx/dy
040D30             0595*  ; test uh.l for 0
040D30 19          0596*      add hl,de
040D31 B7          0597*      or a
040D32 ED 52       0598*      sbc hl,de
040D34 28 22       0599*      jr z,@is_zero
040D36             0600*  ; test uh.l for 1
040D36 AF          0601*      xor a ; clear carry
040D37 EB          0602*      ex de,hl
040D38 21 00 01 00 0603*      ld hl,1*256 ; 1 in 16.8 fixed format
040D3C ED 52       0604*      sbc hl,de
040D3E 28 13       0605*      jr z,@is_45
040D40 EB          0606*      ex de,hl
040D41             0607*  ; no special cases so we move on
040D41             0608*  ; l contains the fractional portion of tan(uh.l)
040D41             0609*  ; we multiply it by three to get our lookup table index
040D41 26 03       0610*      ld h,3
040D43 ED 6C       0611*      mlt hl ; index into lut
040D45 11 00 00 00 0612*      ld de,0 ; clear deu
040D49 54          0613*      ld d,h ; copy hl to de
040D4A 5D          0614*      ld e,l ; de contains our index
040D4B 21 50 11 04 0615*      ld hl,atan_lut_168 ; grab the lut address
040D4F 19          0616*      add hl,de ; bump hl by the index
040D50 ED 27       0617*      ld hl,(hl) ; don't try this on a z80!
040D52 C9          0618*      ret ; and out
040D53             0619*  @is_45:
040D53 21 00 20 00 0620*      ld hl,32*256
040D57 C9          0621*      ret
040D58             0622*  ; for the case tan(0)
040D58             0623*  @is_zero:
040D58 21 00 00 00 0624*      ld hl,0*256
040D5C C9          0625*      ret
040D5D             0626*  
040D5D             0627*  ; Expects  ADL mode
040D5D             0628*  ; Inputs:  UH.L
040D5D             0629*  ; Outputs: UH.L is the 16.8 square root
040D5D             0630*  ;          UDE is the integer difference inputHL-DE^2
040D5D             0631*  sqrt168:
040D5D CD 67 0D 04 0632*      call sqrt24
040D61 EB          0633*      ex de,hl
040D62 29          0634*      add hl,hl
040D63 29          0635*      add hl,hl
040D64 29          0636*      add hl,hl
040D65 29          0637*      add hl,hl
040D66 C9          0638*      ret
040D67             0639*  
040D67             0640*  ; credit: xeda112358
040D67             0641*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D67             0642*  sqrt24:
040D67             0643*  ; Expects ADL mode
040D67             0644*  ; Inputs: HL
040D67             0645*  ; Outputs: DE is the integer square root
040D67             0646*  ;  HL is the difference inputHL-DE^2
040D67             0647*  ;  c flag reset
040D67 01 00 00 00 0648*      ld bc,0 ; clear bcu
040D6B 11 00 00 00 0649*      ld de,0 ; clear deu
040D6F AF          0650*      xor a
040D70 45          0651*      ld b,l
040D71 C5          0652*      push bc
040D72 47          0653*      ld b,a
040D73 6F          0654*      ld l,a
040D74             0655*  ; Iteration 1
040D74 29          0656*      add hl,hl
040D75 CB 11       0657*      rl c
040D77 29          0658*      add hl,hl
040D78 CB 11       0659*      rl c
040D7A 91          0660*      sub c
040D7B 30 04       0661*      jr nc,$+6
040D7D 1C          0662*      inc e
040D7E 1C          0663*      inc e
040D7F 2F          0664*      cpl
040D80 4F          0665*      ld c,a
040D81             0666*  ; Iteration 2
040D81 29          0667*      add hl,hl
040D82 CB 11       0668*      rl c
040D84 29          0669*      add hl,hl
040D85 CB 11       0670*      rl c
040D87 CB 13       0671*      rl e
040D89 7B          0672*      ld a,e
040D8A 91          0673*      sub c
040D8B 30 04       0674*      jr nc,$+6
040D8D 1C          0675*      inc e
040D8E 1C          0676*      inc e
040D8F 2F          0677*      cpl
040D90 4F          0678*      ld c,a
040D91             0679*  ; Iteration 3
040D91 29          0680*      add hl,hl
040D92 CB 11       0681*      rl c
040D94 29          0682*      add hl,hl
040D95 CB 11       0683*      rl c
040D97 CB 13       0684*      rl e
040D99 7B          0685*      ld a,e
040D9A 91          0686*      sub c
040D9B 30 04       0687*      jr nc,$+6
040D9D 1C          0688*      inc e
040D9E 1C          0689*      inc e
040D9F 2F          0690*      cpl
040DA0 4F          0691*      ld c,a
040DA1             0692*  ; Iteration 4
040DA1 29          0693*      add hl,hl
040DA2 CB 11       0694*      rl c
040DA4 29          0695*      add hl,hl
040DA5 CB 11       0696*      rl c
040DA7 CB 13       0697*      rl e
040DA9 7B          0698*      ld a,e
040DAA 91          0699*      sub c
040DAB 30 04       0700*      jr nc,$+6
040DAD 1C          0701*      inc e
040DAE 1C          0702*      inc e
040DAF 2F          0703*      cpl
040DB0 4F          0704*      ld c,a
040DB1             0705*  ; Iteration 5
040DB1 29          0706*      add hl,hl
040DB2 CB 11       0707*      rl c
040DB4 29          0708*      add hl,hl
040DB5 CB 11       0709*      rl c
040DB7 CB 13       0710*      rl e
040DB9 7B          0711*      ld a,e
040DBA 91          0712*      sub c
040DBB 30 04       0713*      jr nc,$+6
040DBD 1C          0714*      inc e
040DBE 1C          0715*      inc e
040DBF 2F          0716*      cpl
040DC0 4F          0717*      ld c,a
040DC1             0718*  ; Iteration 6
040DC1 29          0719*      add hl,hl
040DC2 CB 11       0720*      rl c
040DC4 29          0721*      add hl,hl
040DC5 CB 11       0722*      rl c
040DC7 CB 13       0723*      rl e
040DC9 7B          0724*      ld a,e
040DCA 91          0725*      sub c
040DCB 30 04       0726*      jr nc,$+6
040DCD 1C          0727*      inc e
040DCE 1C          0728*      inc e
040DCF 2F          0729*      cpl
040DD0 4F          0730*      ld c,a
040DD1             0731*  ; Iteration 7
040DD1 29          0732*      add hl,hl
040DD2 CB 11       0733*      rl c
040DD4 29          0734*      add hl,hl
040DD5 CB 11       0735*      rl c
040DD7 CB 10       0736*      rl b
040DD9 EB          0737*      ex de,hl
040DDA 29          0738*      add hl,hl
040DDB E5          0739*      push hl
040DDC ED 42       0740*      sbc hl,bc
040DDE 30 06       0741*      jr nc,$+8
040DE0 7C          0742*      ld a,h
040DE1 2F          0743*      cpl
040DE2 47          0744*      ld b,a
040DE3 7D          0745*      ld a,l
040DE4 2F          0746*      cpl
040DE5 4F          0747*      ld c,a
040DE6 E1          0748*      pop hl
040DE7 30 02       0749*      jr nc,$+4
040DE9 23          0750*      inc hl
040DEA 23          0751*      inc hl
040DEB EB          0752*      ex de,hl
040DEC             0753*  ; Iteration 8
040DEC 29          0754*      add hl,hl
040DED 69          0755*      ld l,c
040DEE 60          0756*      ld h,b
040DEF ED 6A       0757*      adc hl,hl
040DF1 ED 6A       0758*      adc hl,hl
040DF3 EB          0759*      ex de,hl
040DF4 29          0760*      add hl,hl
040DF5 ED 52       0761*      sbc hl,de
040DF7 19          0762*      add hl,de
040DF8 EB          0763*      ex de,hl
040DF9 30 04       0764*      jr nc,$+6
040DFB ED 52       0765*      sbc hl,de
040DFD 13          0766*      inc de
040DFE 13          0767*      inc de
040DFF             0768*  ; Iteration 9
040DFF F1          0769*      pop af
040E00 17          0770*      rla
040E01 ED 6A       0771*      adc hl,hl
040E03 17          0772*      rla
040E04 ED 6A       0773*      adc hl,hl
040E06 EB          0774*      ex de,hl
040E07 29          0775*      add hl,hl
040E08 ED 52       0776*      sbc hl,de
040E0A 19          0777*      add hl,de
040E0B EB          0778*      ex de,hl
040E0C 30 04       0779*      jr nc,$+6
040E0E ED 52       0780*      sbc hl,de
040E10 13          0781*      inc de
040E11 13          0782*      inc de
040E12             0783*  ; Iteration 10
040E12 17          0784*      rla
040E13 ED 6A       0785*      adc hl,hl
040E15 17          0786*      rla
040E16 ED 6A       0787*      adc hl,hl
040E18 EB          0788*      ex de,hl
040E19 29          0789*      add hl,hl
040E1A ED 52       0790*      sbc hl,de
040E1C 19          0791*      add hl,de
040E1D EB          0792*      ex de,hl
040E1E 30 04       0793*      jr nc,$+6
040E20 ED 52       0794*      sbc hl,de
040E22 13          0795*      inc de
040E23 13          0796*      inc de
040E24             0797*  ; Iteration 11
040E24 17          0798*      rla
040E25 ED 6A       0799*      adc hl,hl
040E27 17          0800*      rla
040E28 ED 6A       0801*      adc hl,hl
040E2A EB          0802*      ex de,hl
040E2B 29          0803*      add hl,hl
040E2C ED 52       0804*      sbc hl,de
040E2E 19          0805*      add hl,de
040E2F EB          0806*      ex de,hl
040E30 30 04       0807*      jr nc,$+6
040E32 ED 52       0808*      sbc hl,de
040E34 13          0809*      inc de
040E35 13          0810*      inc de
040E36             0811*  ; Iteration 12
040E36 17          0812*      rla
040E37 ED 6A       0813*      adc hl,hl
040E39 17          0814*      rla
040E3A ED 6A       0815*      adc hl,hl
040E3C EB          0816*      ex de,hl
040E3D 29          0817*      add hl,hl
040E3E ED 52       0818*      sbc hl,de
040E40 19          0819*      add hl,de
040E41 EB          0820*      ex de,hl
040E42 30 04       0821*      jr nc,$+6
040E44 ED 52       0822*      sbc hl,de
040E46 13          0823*      inc de
040E47 13          0824*      inc de
040E48 CB 1A       0825*      rr d
040E4A CB 1B       0826*      rr e
040E4C C9          0827*      ret
040E4D             0828*  
040E4D             0829*  sin_lut_168:
040E4D 00 00 00    0830*      dl 0x000000 ; 0.000 00, 0.000
040E50 06 00 00    0831*      dl 0x000006 ; 1.406 01, 0.025
040E53 0C 00 00    0832*      dl 0x00000C ; 2.813 02, 0.049
040E56 12 00 00    0833*      dl 0x000012 ; 4.219 03, 0.074
040E59 19 00 00    0834*      dl 0x000019 ; 5.625 04, 0.098
040E5C 1F 00 00    0835*      dl 0x00001F ; 7.031 05, 0.122
040E5F 25 00 00    0836*      dl 0x000025 ; 8.438 06, 0.147
040E62 2B 00 00    0837*      dl 0x00002B ; 9.844 07, 0.171
040E65 31 00 00    0838*      dl 0x000031 ; 11.250 08, 0.195
040E68 38 00 00    0839*      dl 0x000038 ; 12.656 09, 0.219
040E6B 3E 00 00    0840*      dl 0x00003E ; 14.063 0A, 0.243
040E6E 44 00 00    0841*      dl 0x000044 ; 15.469 0B, 0.267
040E71 4A 00 00    0842*      dl 0x00004A ; 16.875 0C, 0.290
040E74 50 00 00    0843*      dl 0x000050 ; 18.281 0D, 0.314
040E77 56 00 00    0844*      dl 0x000056 ; 19.688 0E, 0.337
040E7A 5C 00 00    0845*      dl 0x00005C ; 21.094 0F, 0.360
040E7D 61 00 00    0846*      dl 0x000061 ; 22.500 10, 0.383
040E80 67 00 00    0847*      dl 0x000067 ; 23.906 11, 0.405
040E83 6D 00 00    0848*      dl 0x00006D ; 25.313 12, 0.428
040E86 73 00 00    0849*      dl 0x000073 ; 26.719 13, 0.450
040E89 78 00 00    0850*      dl 0x000078 ; 28.125 14, 0.471
040E8C 7E 00 00    0851*      dl 0x00007E ; 29.531 15, 0.493
040E8F 83 00 00    0852*      dl 0x000083 ; 30.938 16, 0.514
040E92 88 00 00    0853*      dl 0x000088 ; 32.344 17, 0.535
040E95 8E 00 00    0854*      dl 0x00008E ; 33.750 18, 0.556
040E98 93 00 00    0855*      dl 0x000093 ; 35.156 19, 0.576
040E9B 98 00 00    0856*      dl 0x000098 ; 36.563 1A, 0.596
040E9E 9D 00 00    0857*      dl 0x00009D ; 37.969 1B, 0.615
040EA1 A2 00 00    0858*      dl 0x0000A2 ; 39.375 1C, 0.634
040EA4 A7 00 00    0859*      dl 0x0000A7 ; 40.781 1D, 0.653
040EA7 AB 00 00    0860*      dl 0x0000AB ; 42.188 1E, 0.672
040EAA B0 00 00    0861*      dl 0x0000B0 ; 43.594 1F, 0.690
040EAD B5 00 00    0862*      dl 0x0000B5 ; 45.000 20, 0.707
040EB0 B9 00 00    0863*      dl 0x0000B9 ; 46.406 21, 0.724
040EB3 BD 00 00    0864*      dl 0x0000BD ; 47.813 22, 0.741
040EB6 C1 00 00    0865*      dl 0x0000C1 ; 49.219 23, 0.757
040EB9 C5 00 00    0866*      dl 0x0000C5 ; 50.625 24, 0.773
040EBC C9 00 00    0867*      dl 0x0000C9 ; 52.031 25, 0.788
040EBF CD 00 00    0868*      dl 0x0000CD ; 53.438 26, 0.803
040EC2 D1 00 00    0869*      dl 0x0000D1 ; 54.844 27, 0.818
040EC5 D4 00 00    0870*      dl 0x0000D4 ; 56.250 28, 0.831
040EC8 D8 00 00    0871*      dl 0x0000D8 ; 57.656 29, 0.845
040ECB DB 00 00    0872*      dl 0x0000DB ; 59.063 2A, 0.858
040ECE DE 00 00    0873*      dl 0x0000DE ; 60.469 2B, 0.870
040ED1 E1 00 00    0874*      dl 0x0000E1 ; 61.875 2C, 0.882
040ED4 E4 00 00    0875*      dl 0x0000E4 ; 63.281 2D, 0.893
040ED7 E7 00 00    0876*      dl 0x0000E7 ; 64.688 2E, 0.904
040EDA EA 00 00    0877*      dl 0x0000EA ; 66.094 2F, 0.914
040EDD EC 00 00    0878*      dl 0x0000EC ; 67.500 30, 0.924
040EE0 EE 00 00    0879*      dl 0x0000EE ; 68.906 31, 0.933
040EE3 F1 00 00    0880*      dl 0x0000F1 ; 70.313 32, 0.942
040EE6 F3 00 00    0881*      dl 0x0000F3 ; 71.719 33, 0.950
040EE9 F4 00 00    0882*      dl 0x0000F4 ; 73.125 34, 0.957
040EEC F6 00 00    0883*      dl 0x0000F6 ; 74.531 35, 0.964
040EEF F8 00 00    0884*      dl 0x0000F8 ; 75.938 36, 0.970
040EF2 F9 00 00    0885*      dl 0x0000F9 ; 77.344 37, 0.976
040EF5 FB 00 00    0886*      dl 0x0000FB ; 78.750 38, 0.981
040EF8 FC 00 00    0887*      dl 0x0000FC ; 80.156 39, 0.985
040EFB FD 00 00    0888*      dl 0x0000FD ; 81.563 3A, 0.989
040EFE FE 00 00    0889*      dl 0x0000FE ; 82.969 3B, 0.992
040F01 FE 00 00    0890*      dl 0x0000FE ; 84.375 3C, 0.995
040F04 FF 00 00    0891*      dl 0x0000FF ; 85.781 3D, 0.997
040F07 FF 00 00    0892*      dl 0x0000FF ; 87.188 3E, 0.999
040F0A FF 00 00    0893*      dl 0x0000FF ; 88.594 3F, 1.000
040F0D 00 01 00    0894*      dl 0x000100 ; 90.000 40, 1.000
040F10 FF 00 00    0895*      dl 0x0000FF ; 91.406 41, 1.000
040F13 FF 00 00    0896*      dl 0x0000FF ; 92.813 42, 0.999
040F16 FF 00 00    0897*      dl 0x0000FF ; 94.219 43, 0.997
040F19 FE 00 00    0898*      dl 0x0000FE ; 95.625 44, 0.995
040F1C FE 00 00    0899*      dl 0x0000FE ; 97.031 45, 0.992
040F1F FD 00 00    0900*      dl 0x0000FD ; 98.438 46, 0.989
040F22 FC 00 00    0901*      dl 0x0000FC ; 99.844 47, 0.985
040F25 FB 00 00    0902*      dl 0x0000FB ; 101.250 48, 0.981
040F28 F9 00 00    0903*      dl 0x0000F9 ; 102.656 49, 0.976
040F2B F8 00 00    0904*      dl 0x0000F8 ; 104.063 4A, 0.970
040F2E F6 00 00    0905*      dl 0x0000F6 ; 105.469 4B, 0.964
040F31 F4 00 00    0906*      dl 0x0000F4 ; 106.875 4C, 0.957
040F34 F3 00 00    0907*      dl 0x0000F3 ; 108.281 4D, 0.950
040F37 F1 00 00    0908*      dl 0x0000F1 ; 109.688 4E, 0.942
040F3A EE 00 00    0909*      dl 0x0000EE ; 111.094 4F, 0.933
040F3D EC 00 00    0910*      dl 0x0000EC ; 112.500 50, 0.924
040F40 EA 00 00    0911*      dl 0x0000EA ; 113.906 51, 0.914
040F43 E7 00 00    0912*      dl 0x0000E7 ; 115.313 52, 0.904
040F46 E4 00 00    0913*      dl 0x0000E4 ; 116.719 53, 0.893
040F49 E1 00 00    0914*      dl 0x0000E1 ; 118.125 54, 0.882
040F4C DE 00 00    0915*      dl 0x0000DE ; 119.531 55, 0.870
040F4F DB 00 00    0916*      dl 0x0000DB ; 120.938 56, 0.858
040F52 D8 00 00    0917*      dl 0x0000D8 ; 122.344 57, 0.845
040F55 D4 00 00    0918*      dl 0x0000D4 ; 123.750 58, 0.831
040F58 D1 00 00    0919*      dl 0x0000D1 ; 125.156 59, 0.818
040F5B CD 00 00    0920*      dl 0x0000CD ; 126.563 5A, 0.803
040F5E C9 00 00    0921*      dl 0x0000C9 ; 127.969 5B, 0.788
040F61 C5 00 00    0922*      dl 0x0000C5 ; 129.375 5C, 0.773
040F64 C1 00 00    0923*      dl 0x0000C1 ; 130.781 5D, 0.757
040F67 BD 00 00    0924*      dl 0x0000BD ; 132.188 5E, 0.741
040F6A B9 00 00    0925*      dl 0x0000B9 ; 133.594 5F, 0.724
040F6D B5 00 00    0926*      dl 0x0000B5 ; 135.000 60, 0.707
040F70 B0 00 00    0927*      dl 0x0000B0 ; 136.406 61, 0.690
040F73 AB 00 00    0928*      dl 0x0000AB ; 137.813 62, 0.672
040F76 A7 00 00    0929*      dl 0x0000A7 ; 139.219 63, 0.653
040F79 A2 00 00    0930*      dl 0x0000A2 ; 140.625 64, 0.634
040F7C 9D 00 00    0931*      dl 0x00009D ; 142.031 65, 0.615
040F7F 98 00 00    0932*      dl 0x000098 ; 143.438 66, 0.596
040F82 93 00 00    0933*      dl 0x000093 ; 144.844 67, 0.576
040F85 8E 00 00    0934*      dl 0x00008E ; 146.250 68, 0.556
040F88 88 00 00    0935*      dl 0x000088 ; 147.656 69, 0.535
040F8B 83 00 00    0936*      dl 0x000083 ; 149.063 6A, 0.514
040F8E 7E 00 00    0937*      dl 0x00007E ; 150.469 6B, 0.493
040F91 78 00 00    0938*      dl 0x000078 ; 151.875 6C, 0.471
040F94 73 00 00    0939*      dl 0x000073 ; 153.281 6D, 0.450
040F97 6D 00 00    0940*      dl 0x00006D ; 154.688 6E, 0.428
040F9A 67 00 00    0941*      dl 0x000067 ; 156.094 6F, 0.405
040F9D 61 00 00    0942*      dl 0x000061 ; 157.500 70, 0.383
040FA0 5C 00 00    0943*      dl 0x00005C ; 158.906 71, 0.360
040FA3 56 00 00    0944*      dl 0x000056 ; 160.313 72, 0.337
040FA6 50 00 00    0945*      dl 0x000050 ; 161.719 73, 0.314
040FA9 4A 00 00    0946*      dl 0x00004A ; 163.125 74, 0.290
040FAC 44 00 00    0947*      dl 0x000044 ; 164.531 75, 0.267
040FAF 3E 00 00    0948*      dl 0x00003E ; 165.938 76, 0.243
040FB2 38 00 00    0949*      dl 0x000038 ; 167.344 77, 0.219
040FB5 31 00 00    0950*      dl 0x000031 ; 168.750 78, 0.195
040FB8 2B 00 00    0951*      dl 0x00002B ; 170.156 79, 0.171
040FBB 25 00 00    0952*      dl 0x000025 ; 171.563 7A, 0.147
040FBE 1F 00 00    0953*      dl 0x00001F ; 172.969 7B, 0.122
040FC1 19 00 00    0954*      dl 0x000019 ; 174.375 7C, 0.098
040FC4 12 00 00    0955*      dl 0x000012 ; 175.781 7D, 0.074
040FC7 0C 00 00    0956*      dl 0x00000C ; 177.188 7E, 0.049
040FCA 06 00 00    0957*      dl 0x000006 ; 178.594 7F, 0.025
040FCD 00 00 00    0958*      dl 0x000000 ; 180.000 80, 0.000
040FD0 FA FF FF    0959*      dl 0xFFFFFA ; 181.406 81, -0.025
040FD3 F4 FF FF    0960*      dl 0xFFFFF4 ; 182.813 82, -0.049
040FD6 EE FF FF    0961*      dl 0xFFFFEE ; 184.219 83, -0.074
040FD9 E7 FF FF    0962*      dl 0xFFFFE7 ; 185.625 84, -0.098
040FDC E1 FF FF    0963*      dl 0xFFFFE1 ; 187.031 85, -0.122
040FDF DB FF FF    0964*      dl 0xFFFFDB ; 188.438 86, -0.147
040FE2 D5 FF FF    0965*      dl 0xFFFFD5 ; 189.844 87, -0.171
040FE5 CF FF FF    0966*      dl 0xFFFFCF ; 191.250 88, -0.195
040FE8 C8 FF FF    0967*      dl 0xFFFFC8 ; 192.656 89, -0.219
040FEB C2 FF FF    0968*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040FEE BC FF FF    0969*      dl 0xFFFFBC ; 195.469 8B, -0.267
040FF1 B6 FF FF    0970*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040FF4 B0 FF FF    0971*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040FF7 AA FF FF    0972*      dl 0xFFFFAA ; 199.688 8E, -0.337
040FFA A4 FF FF    0973*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040FFD 9F FF FF    0974*      dl 0xFFFF9F ; 202.500 90, -0.383
041000 99 FF FF    0975*      dl 0xFFFF99 ; 203.906 91, -0.405
041003 93 FF FF    0976*      dl 0xFFFF93 ; 205.313 92, -0.428
041006 8D FF FF    0977*      dl 0xFFFF8D ; 206.719 93, -0.450
041009 88 FF FF    0978*      dl 0xFFFF88 ; 208.125 94, -0.471
04100C 82 FF FF    0979*      dl 0xFFFF82 ; 209.531 95, -0.493
04100F 7D FF FF    0980*      dl 0xFFFF7D ; 210.938 96, -0.514
041012 78 FF FF    0981*      dl 0xFFFF78 ; 212.344 97, -0.535
041015 72 FF FF    0982*      dl 0xFFFF72 ; 213.750 98, -0.556
041018 6D FF FF    0983*      dl 0xFFFF6D ; 215.156 99, -0.576
04101B 68 FF FF    0984*      dl 0xFFFF68 ; 216.563 9A, -0.596
04101E 63 FF FF    0985*      dl 0xFFFF63 ; 217.969 9B, -0.615
041021 5E FF FF    0986*      dl 0xFFFF5E ; 219.375 9C, -0.634
041024 59 FF FF    0987*      dl 0xFFFF59 ; 220.781 9D, -0.653
041027 55 FF FF    0988*      dl 0xFFFF55 ; 222.188 9E, -0.672
04102A 50 FF FF    0989*      dl 0xFFFF50 ; 223.594 9F, -0.690
04102D 4B FF FF    0990*      dl 0xFFFF4B ; 225.000 A0, -0.707
041030 47 FF FF    0991*      dl 0xFFFF47 ; 226.406 A1, -0.724
041033 43 FF FF    0992*      dl 0xFFFF43 ; 227.813 A2, -0.741
041036 3F FF FF    0993*      dl 0xFFFF3F ; 229.219 A3, -0.757
041039 3B FF FF    0994*      dl 0xFFFF3B ; 230.625 A4, -0.773
04103C 37 FF FF    0995*      dl 0xFFFF37 ; 232.031 A5, -0.788
04103F 33 FF FF    0996*      dl 0xFFFF33 ; 233.438 A6, -0.803
041042 2F FF FF    0997*      dl 0xFFFF2F ; 234.844 A7, -0.818
041045 2C FF FF    0998*      dl 0xFFFF2C ; 236.250 A8, -0.831
041048 28 FF FF    0999*      dl 0xFFFF28 ; 237.656 A9, -0.845
04104B 25 FF FF    1000*      dl 0xFFFF25 ; 239.063 AA, -0.858
04104E 22 FF FF    1001*      dl 0xFFFF22 ; 240.469 AB, -0.870
041051 1F FF FF    1002*      dl 0xFFFF1F ; 241.875 AC, -0.882
041054 1C FF FF    1003*      dl 0xFFFF1C ; 243.281 AD, -0.893
041057 19 FF FF    1004*      dl 0xFFFF19 ; 244.688 AE, -0.904
04105A 16 FF FF    1005*      dl 0xFFFF16 ; 246.094 AF, -0.914
04105D 14 FF FF    1006*      dl 0xFFFF14 ; 247.500 B0, -0.924
041060 12 FF FF    1007*      dl 0xFFFF12 ; 248.906 B1, -0.933
041063 0F FF FF    1008*      dl 0xFFFF0F ; 250.313 B2, -0.942
041066 0D FF FF    1009*      dl 0xFFFF0D ; 251.719 B3, -0.950
041069 0C FF FF    1010*      dl 0xFFFF0C ; 253.125 B4, -0.957
04106C 0A FF FF    1011*      dl 0xFFFF0A ; 254.531 B5, -0.964
04106F 08 FF FF    1012*      dl 0xFFFF08 ; 255.938 B6, -0.970
041072 07 FF FF    1013*      dl 0xFFFF07 ; 257.344 B7, -0.976
041075 05 FF FF    1014*      dl 0xFFFF05 ; 258.750 B8, -0.981
041078 04 FF FF    1015*      dl 0xFFFF04 ; 260.156 B9, -0.985
04107B 03 FF FF    1016*      dl 0xFFFF03 ; 261.563 BA, -0.989
04107E 02 FF FF    1017*      dl 0xFFFF02 ; 262.969 BB, -0.992
041081 02 FF FF    1018*      dl 0xFFFF02 ; 264.375 BC, -0.995
041084 01 FF FF    1019*      dl 0xFFFF01 ; 265.781 BD, -0.997
041087 01 FF FF    1020*      dl 0xFFFF01 ; 267.188 BE, -0.999
04108A 01 FF FF    1021*      dl 0xFFFF01 ; 268.594 BF, -1.000
04108D 00 FF FF    1022*      dl 0xFFFF00 ; 270.000 C0, -1.000
041090 01 FF FF    1023*      dl 0xFFFF01 ; 271.406 C1, -1.000
041093 01 FF FF    1024*      dl 0xFFFF01 ; 272.813 C2, -0.999
041096 01 FF FF    1025*      dl 0xFFFF01 ; 274.219 C3, -0.997
041099 02 FF FF    1026*      dl 0xFFFF02 ; 275.625 C4, -0.995
04109C 02 FF FF    1027*      dl 0xFFFF02 ; 277.031 C5, -0.992
04109F 03 FF FF    1028*      dl 0xFFFF03 ; 278.438 C6, -0.989
0410A2 04 FF FF    1029*      dl 0xFFFF04 ; 279.844 C7, -0.985
0410A5 05 FF FF    1030*      dl 0xFFFF05 ; 281.250 C8, -0.981
0410A8 07 FF FF    1031*      dl 0xFFFF07 ; 282.656 C9, -0.976
0410AB 08 FF FF    1032*      dl 0xFFFF08 ; 284.063 CA, -0.970
0410AE 0A FF FF    1033*      dl 0xFFFF0A ; 285.469 CB, -0.964
0410B1 0C FF FF    1034*      dl 0xFFFF0C ; 286.875 CC, -0.957
0410B4 0D FF FF    1035*      dl 0xFFFF0D ; 288.281 CD, -0.950
0410B7 0F FF FF    1036*      dl 0xFFFF0F ; 289.688 CE, -0.942
0410BA 12 FF FF    1037*      dl 0xFFFF12 ; 291.094 CF, -0.933
0410BD 14 FF FF    1038*      dl 0xFFFF14 ; 292.500 D0, -0.924
0410C0 16 FF FF    1039*      dl 0xFFFF16 ; 293.906 D1, -0.914
0410C3 19 FF FF    1040*      dl 0xFFFF19 ; 295.313 D2, -0.904
0410C6 1C FF FF    1041*      dl 0xFFFF1C ; 296.719 D3, -0.893
0410C9 1F FF FF    1042*      dl 0xFFFF1F ; 298.125 D4, -0.882
0410CC 22 FF FF    1043*      dl 0xFFFF22 ; 299.531 D5, -0.870
0410CF 25 FF FF    1044*      dl 0xFFFF25 ; 300.938 D6, -0.858
0410D2 28 FF FF    1045*      dl 0xFFFF28 ; 302.344 D7, -0.845
0410D5 2C FF FF    1046*      dl 0xFFFF2C ; 303.750 D8, -0.831
0410D8 2F FF FF    1047*      dl 0xFFFF2F ; 305.156 D9, -0.818
0410DB 33 FF FF    1048*      dl 0xFFFF33 ; 306.563 DA, -0.803
0410DE 37 FF FF    1049*      dl 0xFFFF37 ; 307.969 DB, -0.788
0410E1 3B FF FF    1050*      dl 0xFFFF3B ; 309.375 DC, -0.773
0410E4 3F FF FF    1051*      dl 0xFFFF3F ; 310.781 DD, -0.757
0410E7 43 FF FF    1052*      dl 0xFFFF43 ; 312.188 DE, -0.741
0410EA 47 FF FF    1053*      dl 0xFFFF47 ; 313.594 DF, -0.724
0410ED 4B FF FF    1054*      dl 0xFFFF4B ; 315.000 E0, -0.707
0410F0 50 FF FF    1055*      dl 0xFFFF50 ; 316.406 E1, -0.690
0410F3 55 FF FF    1056*      dl 0xFFFF55 ; 317.813 E2, -0.672
0410F6 59 FF FF    1057*      dl 0xFFFF59 ; 319.219 E3, -0.653
0410F9 5E FF FF    1058*      dl 0xFFFF5E ; 320.625 E4, -0.634
0410FC 63 FF FF    1059*      dl 0xFFFF63 ; 322.031 E5, -0.615
0410FF 68 FF FF    1060*      dl 0xFFFF68 ; 323.438 E6, -0.596
041102 6D FF FF    1061*      dl 0xFFFF6D ; 324.844 E7, -0.576
041105 72 FF FF    1062*      dl 0xFFFF72 ; 326.250 E8, -0.556
041108 78 FF FF    1063*      dl 0xFFFF78 ; 327.656 E9, -0.535
04110B 7D FF FF    1064*      dl 0xFFFF7D ; 329.063 EA, -0.514
04110E 82 FF FF    1065*      dl 0xFFFF82 ; 330.469 EB, -0.493
041111 88 FF FF    1066*      dl 0xFFFF88 ; 331.875 EC, -0.471
041114 8D FF FF    1067*      dl 0xFFFF8D ; 333.281 ED, -0.450
041117 93 FF FF    1068*      dl 0xFFFF93 ; 334.688 EE, -0.428
04111A 99 FF FF    1069*      dl 0xFFFF99 ; 336.094 EF, -0.405
04111D 9F FF FF    1070*      dl 0xFFFF9F ; 337.500 F0, -0.383
041120 A4 FF FF    1071*      dl 0xFFFFA4 ; 338.906 F1, -0.360
041123 AA FF FF    1072*      dl 0xFFFFAA ; 340.313 F2, -0.337
041126 B0 FF FF    1073*      dl 0xFFFFB0 ; 341.719 F3, -0.314
041129 B6 FF FF    1074*      dl 0xFFFFB6 ; 343.125 F4, -0.290
04112C BC FF FF    1075*      dl 0xFFFFBC ; 344.531 F5, -0.267
04112F C2 FF FF    1076*      dl 0xFFFFC2 ; 345.938 F6, -0.243
041132 C8 FF FF    1077*      dl 0xFFFFC8 ; 347.344 F7, -0.219
041135 CF FF FF    1078*      dl 0xFFFFCF ; 348.750 F8, -0.195
041138 D5 FF FF    1079*      dl 0xFFFFD5 ; 350.156 F9, -0.171
04113B DB FF FF    1080*      dl 0xFFFFDB ; 351.563 FA, -0.147
04113E E1 FF FF    1081*      dl 0xFFFFE1 ; 352.969 FB, -0.122
041141 E7 FF FF    1082*      dl 0xFFFFE7 ; 354.375 FC, -0.098
041144 EE FF FF    1083*      dl 0xFFFFEE ; 355.781 FD, -0.074
041147 F4 FF FF    1084*      dl 0xFFFFF4 ; 357.188 FE, -0.049
04114A FA FF FF    1085*      dl 0xFFFFFA ; 358.594 FF, -0.025
04114D 00 00 00    1086*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
041150             1087*  
041150             1088*  atan_lut_168:
041150 00 00 00    1089*      dl 0x000000 ; 000000, 0.000
041153 28 00 00    1090*      dl 0x000028 ; 000001, 0.224
041156 51 00 00    1091*      dl 0x000051 ; 000002, 0.448
041159 7A 00 00    1092*      dl 0x00007A ; 000003, 0.671
04115C A2 00 00    1093*      dl 0x0000A2 ; 000004, 0.895
04115F CB 00 00    1094*      dl 0x0000CB ; 000005, 1.119
041162 F4 00 00    1095*      dl 0x0000F4 ; 000006, 1.343
041165 1D 01 00    1096*      dl 0x00011D ; 000007, 1.566
041168 45 01 00    1097*      dl 0x000145 ; 000008, 1.790
04116B 6E 01 00    1098*      dl 0x00016E ; 000009, 2.013
04116E 97 01 00    1099*      dl 0x000197 ; 00000A, 2.237
041171 BF 01 00    1100*      dl 0x0001BF ; 00000B, 2.460
041174 E8 01 00    1101*      dl 0x0001E8 ; 00000C, 2.684
041177 11 02 00    1102*      dl 0x000211 ; 00000D, 2.907
04117A 39 02 00    1103*      dl 0x000239 ; 00000E, 3.130
04117D 62 02 00    1104*      dl 0x000262 ; 00000F, 3.353
041180 8B 02 00    1105*      dl 0x00028B ; 000010, 3.576
041183 B3 02 00    1106*      dl 0x0002B3 ; 000011, 3.799
041186 DC 02 00    1107*      dl 0x0002DC ; 000012, 4.022
041189 04 03 00    1108*      dl 0x000304 ; 000013, 4.245
04118C 2D 03 00    1109*      dl 0x00032D ; 000014, 4.467
04118F 55 03 00    1110*      dl 0x000355 ; 000015, 4.690
041192 7E 03 00    1111*      dl 0x00037E ; 000016, 4.912
041195 A6 03 00    1112*      dl 0x0003A6 ; 000017, 5.134
041198 CE 03 00    1113*      dl 0x0003CE ; 000018, 5.356
04119B F7 03 00    1114*      dl 0x0003F7 ; 000019, 5.578
04119E 1F 04 00    1115*      dl 0x00041F ; 00001A, 5.799
0411A1 48 04 00    1116*      dl 0x000448 ; 00001B, 6.021
0411A4 70 04 00    1117*      dl 0x000470 ; 00001C, 6.242
0411A7 98 04 00    1118*      dl 0x000498 ; 00001D, 6.463
0411AA C0 04 00    1119*      dl 0x0004C0 ; 00001E, 6.684
0411AD E8 04 00    1120*      dl 0x0004E8 ; 00001F, 6.905
0411B0 11 05 00    1121*      dl 0x000511 ; 000020, 7.125
0411B3 39 05 00    1122*      dl 0x000539 ; 000021, 7.345
0411B6 61 05 00    1123*      dl 0x000561 ; 000022, 7.565
0411B9 89 05 00    1124*      dl 0x000589 ; 000023, 7.785
0411BC B1 05 00    1125*      dl 0x0005B1 ; 000024, 8.005
0411BF D9 05 00    1126*      dl 0x0005D9 ; 000025, 8.224
0411C2 01 06 00    1127*      dl 0x000601 ; 000026, 8.443
0411C5 28 06 00    1128*      dl 0x000628 ; 000027, 8.662
0411C8 50 06 00    1129*      dl 0x000650 ; 000028, 8.881
0411CB 78 06 00    1130*      dl 0x000678 ; 000029, 9.099
0411CE A0 06 00    1131*      dl 0x0006A0 ; 00002A, 9.317
0411D1 C7 06 00    1132*      dl 0x0006C7 ; 00002B, 9.535
0411D4 EF 06 00    1133*      dl 0x0006EF ; 00002C, 9.752
0411D7 16 07 00    1134*      dl 0x000716 ; 00002D, 9.970
0411DA 3E 07 00    1135*      dl 0x00073E ; 00002E, 10.187
0411DD 65 07 00    1136*      dl 0x000765 ; 00002F, 10.403
0411E0 8D 07 00    1137*      dl 0x00078D ; 000030, 10.620
0411E3 B4 07 00    1138*      dl 0x0007B4 ; 000031, 10.836
0411E6 DB 07 00    1139*      dl 0x0007DB ; 000032, 11.051
0411E9 03 08 00    1140*      dl 0x000803 ; 000033, 11.267
0411EC 2A 08 00    1141*      dl 0x00082A ; 000034, 11.482
0411EF 51 08 00    1142*      dl 0x000851 ; 000035, 11.697
0411F2 78 08 00    1143*      dl 0x000878 ; 000036, 11.911
0411F5 9F 08 00    1144*      dl 0x00089F ; 000037, 12.125
0411F8 C6 08 00    1145*      dl 0x0008C6 ; 000038, 12.339
0411FB ED 08 00    1146*      dl 0x0008ED ; 000039, 12.553
0411FE 13 09 00    1147*      dl 0x000913 ; 00003A, 12.766
041201 3A 09 00    1148*      dl 0x00093A ; 00003B, 12.978
041204 61 09 00    1149*      dl 0x000961 ; 00003C, 13.191
041207 87 09 00    1150*      dl 0x000987 ; 00003D, 13.403
04120A AE 09 00    1151*      dl 0x0009AE ; 00003E, 13.614
04120D D4 09 00    1152*      dl 0x0009D4 ; 00003F, 13.825
041210 FB 09 00    1153*      dl 0x0009FB ; 000040, 14.036
041213 21 0A 00    1154*      dl 0x000A21 ; 000041, 14.247
041216 47 0A 00    1155*      dl 0x000A47 ; 000042, 14.457
041219 6D 0A 00    1156*      dl 0x000A6D ; 000043, 14.666
04121C 94 0A 00    1157*      dl 0x000A94 ; 000044, 14.876
04121F BA 0A 00    1158*      dl 0x000ABA ; 000045, 15.085
041222 E0 0A 00    1159*      dl 0x000AE0 ; 000046, 15.293
041225 05 0B 00    1160*      dl 0x000B05 ; 000047, 15.501
041228 2B 0B 00    1161*      dl 0x000B2B ; 000048, 15.709
04122B 51 0B 00    1162*      dl 0x000B51 ; 000049, 15.916
04122E 77 0B 00    1163*      dl 0x000B77 ; 00004A, 16.123
041231 9C 0B 00    1164*      dl 0x000B9C ; 00004B, 16.329
041234 C2 0B 00    1165*      dl 0x000BC2 ; 00004C, 16.535
041237 E7 0B 00    1166*      dl 0x000BE7 ; 00004D, 16.740
04123A 0C 0C 00    1167*      dl 0x000C0C ; 00004E, 16.945
04123D 32 0C 00    1168*      dl 0x000C32 ; 00004F, 17.150
041240 57 0C 00    1169*      dl 0x000C57 ; 000050, 17.354
041243 7C 0C 00    1170*      dl 0x000C7C ; 000051, 17.558
041246 A1 0C 00    1171*      dl 0x000CA1 ; 000052, 17.761
041249 C6 0C 00    1172*      dl 0x000CC6 ; 000053, 17.964
04124C EB 0C 00    1173*      dl 0x000CEB ; 000054, 18.166
04124F 0F 0D 00    1174*      dl 0x000D0F ; 000055, 18.368
041252 34 0D 00    1175*      dl 0x000D34 ; 000056, 18.569
041255 58 0D 00    1176*      dl 0x000D58 ; 000057, 18.770
041258 7D 0D 00    1177*      dl 0x000D7D ; 000058, 18.970
04125B A1 0D 00    1178*      dl 0x000DA1 ; 000059, 19.170
04125E C6 0D 00    1179*      dl 0x000DC6 ; 00005A, 19.370
041261 EA 0D 00    1180*      dl 0x000DEA ; 00005B, 19.569
041264 0E 0E 00    1181*      dl 0x000E0E ; 00005C, 19.767
041267 32 0E 00    1182*      dl 0x000E32 ; 00005D, 19.965
04126A 56 0E 00    1183*      dl 0x000E56 ; 00005E, 20.163
04126D 7A 0E 00    1184*      dl 0x000E7A ; 00005F, 20.360
041270 9E 0E 00    1185*      dl 0x000E9E ; 000060, 20.556
041273 C1 0E 00    1186*      dl 0x000EC1 ; 000061, 20.752
041276 E5 0E 00    1187*      dl 0x000EE5 ; 000062, 20.947
041279 08 0F 00    1188*      dl 0x000F08 ; 000063, 21.142
04127C 2C 0F 00    1189*      dl 0x000F2C ; 000064, 21.337
04127F 4F 0F 00    1190*      dl 0x000F4F ; 000065, 21.531
041282 72 0F 00    1191*      dl 0x000F72 ; 000066, 21.724
041285 95 0F 00    1192*      dl 0x000F95 ; 000067, 21.917
041288 B8 0F 00    1193*      dl 0x000FB8 ; 000068, 22.109
04128B DB 0F 00    1194*      dl 0x000FDB ; 000069, 22.301
04128E FE 0F 00    1195*      dl 0x000FFE ; 00006A, 22.493
041291 21 10 00    1196*      dl 0x001021 ; 00006B, 22.683
041294 44 10 00    1197*      dl 0x001044 ; 00006C, 22.874
041297 66 10 00    1198*      dl 0x001066 ; 00006D, 23.063
04129A 89 10 00    1199*      dl 0x001089 ; 00006E, 23.253
04129D AB 10 00    1200*      dl 0x0010AB ; 00006F, 23.441
0412A0 CD 10 00    1201*      dl 0x0010CD ; 000070, 23.629
0412A3 EF 10 00    1202*      dl 0x0010EF ; 000071, 23.817
0412A6 11 11 00    1203*      dl 0x001111 ; 000072, 24.004
0412A9 33 11 00    1204*      dl 0x001133 ; 000073, 24.191
0412AC 55 11 00    1205*      dl 0x001155 ; 000074, 24.376
0412AF 77 11 00    1206*      dl 0x001177 ; 000075, 24.562
0412B2 99 11 00    1207*      dl 0x001199 ; 000076, 24.747
0412B5 BA 11 00    1208*      dl 0x0011BA ; 000077, 24.931
0412B8 DC 11 00    1209*      dl 0x0011DC ; 000078, 25.115
0412BB FD 11 00    1210*      dl 0x0011FD ; 000079, 25.298
0412BE 1E 12 00    1211*      dl 0x00121E ; 00007A, 25.481
0412C1 3F 12 00    1212*      dl 0x00123F ; 00007B, 25.663
0412C4 60 12 00    1213*      dl 0x001260 ; 00007C, 25.844
0412C7 81 12 00    1214*      dl 0x001281 ; 00007D, 26.025
0412CA A2 12 00    1215*      dl 0x0012A2 ; 00007E, 26.206
0412CD C3 12 00    1216*      dl 0x0012C3 ; 00007F, 26.386
0412D0 E4 12 00    1217*      dl 0x0012E4 ; 000080, 26.565
0412D3 04 13 00    1218*      dl 0x001304 ; 000081, 26.744
0412D6 25 13 00    1219*      dl 0x001325 ; 000082, 26.922
0412D9 45 13 00    1220*      dl 0x001345 ; 000083, 27.100
0412DC 65 13 00    1221*      dl 0x001365 ; 000084, 27.277
0412DF 85 13 00    1222*      dl 0x001385 ; 000085, 27.453
0412E2 A5 13 00    1223*      dl 0x0013A5 ; 000086, 27.629
0412E5 C5 13 00    1224*      dl 0x0013C5 ; 000087, 27.805
0412E8 E5 13 00    1225*      dl 0x0013E5 ; 000088, 27.979
0412EB 05 14 00    1226*      dl 0x001405 ; 000089, 28.154
0412EE 24 14 00    1227*      dl 0x001424 ; 00008A, 28.327
0412F1 44 14 00    1228*      dl 0x001444 ; 00008B, 28.501
0412F4 63 14 00    1229*      dl 0x001463 ; 00008C, 28.673
0412F7 83 14 00    1230*      dl 0x001483 ; 00008D, 28.845
0412FA A2 14 00    1231*      dl 0x0014A2 ; 00008E, 29.017
0412FD C1 14 00    1232*      dl 0x0014C1 ; 00008F, 29.187
041300 E0 14 00    1233*      dl 0x0014E0 ; 000090, 29.358
041303 FF 14 00    1234*      dl 0x0014FF ; 000091, 29.527
041306 1E 15 00    1235*      dl 0x00151E ; 000092, 29.697
041309 3C 15 00    1236*      dl 0x00153C ; 000093, 29.865
04130C 5B 15 00    1237*      dl 0x00155B ; 000094, 30.033
04130F 79 15 00    1238*      dl 0x001579 ; 000095, 30.201
041312 98 15 00    1239*      dl 0x001598 ; 000096, 30.368
041315 B6 15 00    1240*      dl 0x0015B6 ; 000097, 30.534
041318 D4 15 00    1241*      dl 0x0015D4 ; 000098, 30.700
04131B F2 15 00    1242*      dl 0x0015F2 ; 000099, 30.865
04131E 10 16 00    1243*      dl 0x001610 ; 00009A, 31.030
041321 2E 16 00    1244*      dl 0x00162E ; 00009B, 31.194
041324 4C 16 00    1245*      dl 0x00164C ; 00009C, 31.357
041327 6A 16 00    1246*      dl 0x00166A ; 00009D, 31.520
04132A 87 16 00    1247*      dl 0x001687 ; 00009E, 31.682
04132D A5 16 00    1248*      dl 0x0016A5 ; 00009F, 31.844
041330 C2 16 00    1249*      dl 0x0016C2 ; 0000A0, 32.005
041333 DF 16 00    1250*      dl 0x0016DF ; 0000A1, 32.166
041336 FC 16 00    1251*      dl 0x0016FC ; 0000A2, 32.326
041339 19 17 00    1252*      dl 0x001719 ; 0000A3, 32.486
04133C 36 17 00    1253*      dl 0x001736 ; 0000A4, 32.645
04133F 53 17 00    1254*      dl 0x001753 ; 0000A5, 32.803
041342 70 17 00    1255*      dl 0x001770 ; 0000A6, 32.961
041345 8C 17 00    1256*      dl 0x00178C ; 0000A7, 33.118
041348 A9 17 00    1257*      dl 0x0017A9 ; 0000A8, 33.275
04134B C5 17 00    1258*      dl 0x0017C5 ; 0000A9, 33.431
04134E E2 17 00    1259*      dl 0x0017E2 ; 0000AA, 33.587
041351 FE 17 00    1260*      dl 0x0017FE ; 0000AB, 33.742
041354 1A 18 00    1261*      dl 0x00181A ; 0000AC, 33.896
041357 36 18 00    1262*      dl 0x001836 ; 0000AD, 34.050
04135A 52 18 00    1263*      dl 0x001852 ; 0000AE, 34.203
04135D 6E 18 00    1264*      dl 0x00186E ; 0000AF, 34.356
041360 8A 18 00    1265*      dl 0x00188A ; 0000B0, 34.509
041363 A5 18 00    1266*      dl 0x0018A5 ; 0000B1, 34.660
041366 C1 18 00    1267*      dl 0x0018C1 ; 0000B2, 34.811
041369 DC 18 00    1268*      dl 0x0018DC ; 0000B3, 34.962
04136C F7 18 00    1269*      dl 0x0018F7 ; 0000B4, 35.112
04136F 13 19 00    1270*      dl 0x001913 ; 0000B5, 35.262
041372 2E 19 00    1271*      dl 0x00192E ; 0000B6, 35.410
041375 49 19 00    1272*      dl 0x001949 ; 0000B7, 35.559
041378 64 19 00    1273*      dl 0x001964 ; 0000B8, 35.707
04137B 7F 19 00    1274*      dl 0x00197F ; 0000B9, 35.854
04137E 99 19 00    1275*      dl 0x001999 ; 0000BA, 36.001
041381 B4 19 00    1276*      dl 0x0019B4 ; 0000BB, 36.147
041384 CE 19 00    1277*      dl 0x0019CE ; 0000BC, 36.293
041387 E9 19 00    1278*      dl 0x0019E9 ; 0000BD, 36.438
04138A 03 1A 00    1279*      dl 0x001A03 ; 0000BE, 36.582
04138D 1D 1A 00    1280*      dl 0x001A1D ; 0000BF, 36.726
041390 37 1A 00    1281*      dl 0x001A37 ; 0000C0, 36.870
041393 51 1A 00    1282*      dl 0x001A51 ; 0000C1, 37.013
041396 6B 1A 00    1283*      dl 0x001A6B ; 0000C2, 37.155
041399 85 1A 00    1284*      dl 0x001A85 ; 0000C3, 37.297
04139C 9F 1A 00    1285*      dl 0x001A9F ; 0000C4, 37.439
04139F B9 1A 00    1286*      dl 0x001AB9 ; 0000C5, 37.579
0413A2 D2 1A 00    1287*      dl 0x001AD2 ; 0000C6, 37.720
0413A5 EC 1A 00    1288*      dl 0x001AEC ; 0000C7, 37.859
0413A8 05 1B 00    1289*      dl 0x001B05 ; 0000C8, 37.999
0413AB 1E 1B 00    1290*      dl 0x001B1E ; 0000C9, 38.137
0413AE 37 1B 00    1291*      dl 0x001B37 ; 0000CA, 38.276
0413B1 50 1B 00    1292*      dl 0x001B50 ; 0000CB, 38.413
0413B4 69 1B 00    1293*      dl 0x001B69 ; 0000CC, 38.550
0413B7 82 1B 00    1294*      dl 0x001B82 ; 0000CD, 38.687
0413BA 9B 1B 00    1295*      dl 0x001B9B ; 0000CE, 38.823
0413BD B4 1B 00    1296*      dl 0x001BB4 ; 0000CF, 38.959
0413C0 CC 1B 00    1297*      dl 0x001BCC ; 0000D0, 39.094
0413C3 E5 1B 00    1298*      dl 0x001BE5 ; 0000D1, 39.228
0413C6 FD 1B 00    1299*      dl 0x001BFD ; 0000D2, 39.362
0413C9 16 1C 00    1300*      dl 0x001C16 ; 0000D3, 39.496
0413CC 2E 1C 00    1301*      dl 0x001C2E ; 0000D4, 39.629
0413CF 46 1C 00    1302*      dl 0x001C46 ; 0000D5, 39.762
0413D2 5E 1C 00    1303*      dl 0x001C5E ; 0000D6, 39.894
0413D5 76 1C 00    1304*      dl 0x001C76 ; 0000D7, 40.025
0413D8 8E 1C 00    1305*      dl 0x001C8E ; 0000D8, 40.156
0413DB A5 1C 00    1306*      dl 0x001CA5 ; 0000D9, 40.286
0413DE BD 1C 00    1307*      dl 0x001CBD ; 0000DA, 40.416
0413E1 D5 1C 00    1308*      dl 0x001CD5 ; 0000DB, 40.546
0413E4 EC 1C 00    1309*      dl 0x001CEC ; 0000DC, 40.675
0413E7 04 1D 00    1310*      dl 0x001D04 ; 0000DD, 40.803
0413EA 1B 1D 00    1311*      dl 0x001D1B ; 0000DE, 40.931
0413ED 32 1D 00    1312*      dl 0x001D32 ; 0000DF, 41.059
0413F0 49 1D 00    1313*      dl 0x001D49 ; 0000E0, 41.186
0413F3 60 1D 00    1314*      dl 0x001D60 ; 0000E1, 41.312
0413F6 77 1D 00    1315*      dl 0x001D77 ; 0000E2, 41.438
0413F9 8E 1D 00    1316*      dl 0x001D8E ; 0000E3, 41.564
0413FC A5 1D 00    1317*      dl 0x001DA5 ; 0000E4, 41.689
0413FF BB 1D 00    1318*      dl 0x001DBB ; 0000E5, 41.814
041402 D2 1D 00    1319*      dl 0x001DD2 ; 0000E6, 41.938
041405 E9 1D 00    1320*      dl 0x001DE9 ; 0000E7, 42.061
041408 FF 1D 00    1321*      dl 0x001DFF ; 0000E8, 42.184
04140B 15 1E 00    1322*      dl 0x001E15 ; 0000E9, 42.307
04140E 2C 1E 00    1323*      dl 0x001E2C ; 0000EA, 42.429
041411 42 1E 00    1324*      dl 0x001E42 ; 0000EB, 42.551
041414 58 1E 00    1325*      dl 0x001E58 ; 0000EC, 42.672
041417 6E 1E 00    1326*      dl 0x001E6E ; 0000ED, 42.793
04141A 84 1E 00    1327*      dl 0x001E84 ; 0000EE, 42.913
04141D 99 1E 00    1328*      dl 0x001E99 ; 0000EF, 43.033
041420 AF 1E 00    1329*      dl 0x001EAF ; 0000F0, 43.152
041423 C5 1E 00    1330*      dl 0x001EC5 ; 0000F1, 43.271
041426 DA 1E 00    1331*      dl 0x001EDA ; 0000F2, 43.390
041429 F0 1E 00    1332*      dl 0x001EF0 ; 0000F3, 43.508
04142C 05 1F 00    1333*      dl 0x001F05 ; 0000F4, 43.625
04142F 1B 1F 00    1334*      dl 0x001F1B ; 0000F5, 43.742
041432 30 1F 00    1335*      dl 0x001F30 ; 0000F6, 43.859
041435 45 1F 00    1336*      dl 0x001F45 ; 0000F7, 43.975
041438 5A 1F 00    1337*      dl 0x001F5A ; 0000F8, 44.091
04143B 6F 1F 00    1338*      dl 0x001F6F ; 0000F9, 44.206
04143E 84 1F 00    1339*      dl 0x001F84 ; 0000FA, 44.321
041441 99 1F 00    1340*      dl 0x001F99 ; 0000FB, 44.435
041444 AD 1F 00    1341*      dl 0x001FAD ; 0000FC, 44.549
041447 C2 1F 00    1342*      dl 0x001FC2 ; 0000FD, 44.662
04144A D7 1F 00    1343*      dl 0x001FD7 ; 0000FE, 44.775
04144D EB 1F 00    1344*      dl 0x001FEB ; 0000FF, 44.888
041450 00 20 00    1345*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
041453             0036       ; include "fonts.inc"
041453             0037       ; include "images.inc"
041453             0038       include "timer.inc"
041453 FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
041500             0002*  
041500             0003*  ; Table 32. Timer Control Registers
041500             0004*  ; this constant is the base address of the timer control registers
041500             0005*  ; each timer takes three bytes:
041500             0006*  ;   0: control register
041500             0007*  ;   1: low byte of timer reset value
041500             0008*  ;   2: high byte of timer reset value
041500             0009*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041500             0010*  ; which correctly force the high and upper bytes of the address bus to zero
041500             0011*  TMR_CTL:     equ 80h
041500             0012*  
041500             0013*  ; Timer Control Register Bit Definitions
041500             0014*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041500             0015*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
041500             0016*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041500             0017*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
041500             0018*                              ; the TMRx_CTL register is read.
041500             0019*  
041500             0020*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041500             0021*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041500             0022*  
041500             0023*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041500             0024*                              ;  0,and counting stops when the end-of-count value is reached.
041500             0025*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041500             0026*                              ; written to the counter when the end-of-count value is reached.
041500             0027*  
041500             0028*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041500             0029*  CLK_DIV_256:  equ %00001100 ;
041500             0030*  CLK_DIV_64:   equ %00001000 ;
041500             0031*  CLK_DIV_16:   equ %00000100 ;
041500             0032*  CLK_DIV_4:    equ %00000000 ;
041500             0033*  
041500             0034*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041500             0035*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041500             0036*                              ; When a 1 is written to this bit,the values in the reload registers
041500             0037*                              ;  are loaded into the downcounter when the timer restarts. The
041500             0038*                              ; programmer must ensure that this bit is set to 1 each time
041500             0039*                              ; SINGLE-PASS mode is used.
041500             0040*  
041500             0041*  ; disable/enable the programmable reload timer
041500             0042*  PRT_EN_0:     equ %00000000 ;
041500             0043*  PRT_EN_1:     equ %00000001 ;
041500             0044*  
041500             0045*  ; Table 37. Timer Input Source Select Register
041500             0046*  ; Each of the 4 timers are allocated two bits of the 8-bit register
041500             0047*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041500             0048*  ;   00: System clock / CLK_DIV
041500             0049*  ;   01: RTC / CLK_DIV
041500             0050*  ;   NOTE: these are the values given in the manual,but it may be a typo
041500             0051*  ;   10: GPIO port B pin 1.
041500             0052*  ;   11: GPIO port B pin 1.
041500             0053*  TMR_ISS:   equ 92h ; register address
041500             0054*  
041500             0055*  ; Table 51. Real-Time Clock Control Register
041500             0056*  RTC_CTRL: equ EDh ; register address
041500             0057*  
041500             0058*  ; alarm interrupt disable/enable
041500             0059*  RTC_ALARM_0:    equ %00000000
041500             0060*  RTC_ALARM_1:    equ %10000000
041500             0061*  
041500             0062*  ; interrupt on alarm disable/enable
041500             0063*  RTC_INT_ENT_0:  equ %00000000
041500             0064*  RTC_INT_ENT_1:  equ %01000000
041500             0065*  
041500             0066*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041500             0067*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041500             0068*  
041500             0069*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041500             0070*                                  ; On-chip 32768 Hz oscillator is enabled.
041500             0071*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041500             0072*                                  ; On-chip 32768 Hz oscillator is disabled.
041500             0073*  
041500             0074*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041500             0075*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041500             0076*  
041500             0077*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041500             0078*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041500             0079*  
041500             0080*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041500             0081*                                  ; RTC counter is enabled.
041500             0082*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041500             0083*                                  ; RTC counter is disabled.
041500             0084*  
041500             0085*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041500             0086*  
041500             0087*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041500             0088*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041500 00 00 00    0089*  prt_reload: dl 0x000000
041503             0090*  
041503             0091*  ; set PRT timer
041503             0092*  prt_set:
041503 21 00 00 00 0093*      ld hl,0
041507 22 51 15 04 0094*      ld (prt_irq_counter),hl
04150B 2A 00 15 04 0095*      ld hl,(prt_reload)
04150F ED 29 84    0096*      out0 ($84),l
041512 ED 21 85    0097*  	out0 ($85),h
041515             0098*  ; disable timer
041515 3E 06       0099*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041517 ED 39 83    0100*  	out0 ($83),a
04151A             0101*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04151A 3E 57       0102*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04151C ED 39 83    0103*  	out0 ($83),a
04151F C9          0104*      ret
041520             0105*  
041520             0106*  ; ===============================================
041520             0107*  ; PRT Timer Interrupt Handling
041520             0108*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
041520             0109*  ; -----------------------------------------------
041520             0110*  prt_irq_init:
041520             0111*      ; set up interrupt vector table 2
041520 21 00 00 00 0112*  	ld hl,0
041524 3A 0C 01 00 0113*  	ld a,($10c)
041528 6F          0114*  	ld l,a
041529 3A 0D 01 00 0115*  	ld a,($10d)
04152D 67          0116*  	ld h,a
04152E             0117*  
04152E             0118*  	; skip over CALL ($c3)
04152E 23          0119*  	inc hl
04152F             0120*  	; load address of jump into vector table 2 (in ram)
04152F ED 27       0121*  	ld hl,(hl)
041531             0122*  
041531             0123*  	; write CALL prt_irq_handler to vector table 2
041531 3E C3       0124*  	ld a,$c3
041533 77          0125*  	ld (hl),a
041534 23          0126*  	inc hl
041535 11 3C 15 04 0127*  	ld de,prt_irq_handler
041539 ED 1F       0128*  	ld (hl),de
04153B             0129*  
04153B C9          0130*      ret
04153C             0131*  
04153C             0132*  prt_irq_handler:
04153C F3          0133*  	di
04153D F5          0134*  	push af
04153E E5          0135*      push hl
04153F ED 38 83    0136*  	in0 a,($83)
041542 2A 51 15 04 0137*  	ld hl,(prt_irq_counter)
041546 23          0138*  	inc hl
041547 22 51 15 04 0139*  	ld (prt_irq_counter),hl
04154B E1          0140*      pop hl
04154C F1          0141*  	pop af
04154D FB          0142*  	ei
04154E 5B ED 4D    0143*  	reti.l
041551             0144*  
041551             0145*  prt_irq_counter:
041551 00 00 00    0146*  	.dl 0
041554             0147*  prt_irq_counter_saved:
041554 00 00 00    0148*      .dl 0
041557             0149*  
041557             0150*  prt_loop_reset:
041557 E5          0151*      push hl
041558 21 00 00 00 0152*  	ld hl,0
04155C 22 51 15 04 0153*  	ld (prt_irq_counter),hl
041560 22 C2 15 04 0154*      ld (prt_loop_counter),hl
041564 22 C5 15 04 0155*      ld (prt_loops),hl
041568 CD 03 15 04 0156*      call prt_set
04156C E1          0157*      pop hl
04156D C9          0158*      ret
04156E             0159*  
04156E             0160*  prt_loop_start:
04156E E5          0161*      push hl
04156F 21 00 00 00 0162*  	ld hl,0
041573 22 51 15 04 0163*  	ld (prt_irq_counter),hl
041577 E1          0164*      pop hl
041578 C9          0165*      ret
041579             0166*  
041579             0167*  prt_loop_stop:
041579 E5          0168*      push hl
04157A D5          0169*      push de
04157B 2A 51 15 04 0170*      ld hl,(prt_irq_counter)
04157F ED 5B C2 15 0171*      ld de,(prt_loop_counter)
       04          
041584 19          0172*      add hl,de
041585 22 C2 15 04 0173*      ld (prt_loop_counter),hl
041589 21 00 00 00 0174*      ld hl,0
04158D 22 51 15 04 0175*      ld (prt_irq_counter),hl
041591 2A C5 15 04 0176*      ld hl,(prt_loops)
041595 23          0177*      inc hl
041596 22 C5 15 04 0178*      ld (prt_loops),hl
04159A D1          0179*      pop de
04159B E1          0180*      pop hl
04159C C9          0181*      ret
04159D             0182*  
04159D             0183*  ; inputs: bc = y,x text coordinates to print
04159D             0184*  prt_loop_print:
04159D F5          0185*      push af
04159E E5          0186*      push hl
04159F C5          0187*      push bc
0415A0 D5          0188*      push de
0415A1 DD E5       0189*      push ix
0415A3 FD E5       0190*      push iy
0415A5 CD 37 17 04 0191*      call vdu_move_cursor
0415A9             0192*  
0415A9 2A C2 15 04 0193*      ld hl,(prt_loop_counter)
0415AD CD 06 02 04 0194*      call printDec
0415B1             0195*  
0415B1 2A C5 15 04 0196*      ld hl,(prt_loops)
0415B5 CD 06 02 04 0197*      call printDec
0415B9             0198*  
0415B9 FD E1       0199*      pop iy
0415BB DD E1       0200*      pop ix
0415BD D1          0201*      pop de
0415BE C1          0202*      pop bc
0415BF E1          0203*      pop hl
0415C0 F1          0204*      pop af
0415C1 C9          0205*      ret
0415C2             0206*  
0415C2             0207*  prt_loop_counter:
0415C2 00 00 00    0208*      .dl 0
0415C5             0209*  prt_loops:
0415C5 00 00 00    0210*      .dl 0
0415C8             0211*  
0415C8             0212*  ; ===============================================
0415C8             0213*  ; Timer functions
0415C8             0214*  ; -----------------------------------------------
0415C8             0215*  ; set a countdown timer
0415C8             0216*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415C8             0217*  ; returns: hl = current time
0415C8             0218*  tmr_set:
0415C8 FD 2F 03    0219*      ld (iy+3),hl            ; set time remaining
0415CB             0220*      MOSCALL mos_sysvars     ; ix points to syvars table
0415CB 3E 08       0001*M 			LD	A, function
0415CD 5B CF       0002*M 			RST.LIL	08h
0415CF DD 27 00    0221*      ld hl,(ix+sysvar_time)  ; get current time
0415D2 FD 2F 00    0222*      ld (iy+0),hl            ; set start time
0415D5 C9          0223*      ret
0415D6             0224*  
0415D6             0225*  ; gets time remaining on a countdown timer
0415D6             0226*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415D6             0227*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0415D6             0228*  ;          sign flags: pos = time not expired,zero or neg = time expired
0415D6             0229*  tmr_get:
0415D6             0230*      MOSCALL mos_sysvars     ; ix points to syvars table
0415D6 3E 08       0001*M 			LD	A, function
0415D8 5B CF       0002*M 			RST.LIL	08h
0415DA DD 17 00    0231*      ld de,(ix+sysvar_time)  ; get current time
0415DD FD 27 00    0232*      ld hl,(iy+0)            ; get start time
0415E0 AF          0233*      xor a                   ; clear carry
0415E1 ED 52       0234*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0415E3 FD 17 03    0235*      ld de,(iy+3)            ; get timer set value
0415E6 AF          0236*      xor a                   ; clear carry
0415E7 ED 5A       0237*      adc hl,de               ; hl = time remaining
0415E9             0238*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0415E9 C9          0239*      ret
0415EA             0240*  
0415EA             0241*  tmr_test: ds 6 ; example of a buffer to hold timer data
0415F0             0242*  
0415F0 00 00 00    0243*  timestamp_now: dl 0
0415F3 00 00 00    0244*  timestamp_old: dl 0
0415F6 00 00 00    0245*  timestamp_chg: dl 0
0415F9             0246*  
0415F9             0247*  ; update the global timestamp from the system clock
0415F9             0248*  ; inputs: none
0415F9             0249*  ; returns: hl = time elapsed in 1/120ths of a second
0415F9             0250*  ;          ix = pointer to syvars table
0415F9             0251*  ; destroys: af,hl,de,ix
0415F9             0252*  timestamp_tick:
0415F9 ED 5B F0 15 0253*      ld de,(timestamp_now)   ; get previous time
       04          
0415FE ED 53 F3 15 0254*      ld (timestamp_old),de   ; save previous time
       04          
041603             0255*      MOSCALL mos_sysvars     ; ix points to syvars table
041603 3E 08       0001*M 			LD	A, function
041605 5B CF       0002*M 			RST.LIL	08h
041607 DD 27 00    0256*      ld hl,(ix+sysvar_time)  ; get current time
04160A 22 F0 15 04 0257*      ld (timestamp_now),hl   ; save current time
04160E AF          0258*      xor a                   ; clear carry
04160F ED 52       0259*      sbc hl,de               ; hl = time elapsed
041611 22 F6 15 04 0260*      ld (timestamp_chg),hl   ; save elapsed time
041615 C9          0261*      ret
041616             0262*  
041616             0263*  ; set a countdown timer
041616             0264*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041616             0265*  ; requires: timestamp_tick to be called at least once before this function
041616             0266*  ; returns: hl = current time
041616             0267*  ; destroys: hl
041616             0268*  timestamp_tmr_set:
041616 FD 2F 03    0269*      ld (iy+3),hl            ; set time remaining
041619 2A F0 15 04 0270*      ld hl,(timestamp_now)   ; get current timestamp
04161D FD 2F 00    0271*      ld (iy+0),hl            ; set start time
041620 C9          0272*      ret
041621             0273*  
041621             0274*  ; gets time remaining on a countdown timer following the global timestamp
041621             0275*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041621             0276*  ; requires: timestamp_tick to be called at least once before this function
041621             0277*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041621             0278*  ;          sign flags: pos = time not expired,zero or neg = time expired
041621             0279*  ; destroys: af,hl,de
041621             0280*  timestamp_tmr_get:
041621 ED 5B F0 15 0281*      ld de,(timestamp_now)   ; get current timestamp
       04          
041626 FD 27 00    0282*      ld hl,(iy+0)            ; get start time
041629 AF          0283*      xor a                   ; clear carry
04162A ED 52       0284*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04162C FD 17 03    0285*      ld de,(iy+3)            ; get timer set value
04162F AF          0286*      xor a                   ; clear carry
041630 ED 5A       0287*      adc hl,de               ; hl = time remaining
041632             0288*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041632 C9          0289*      ret
041633             0290*  
041633             0291*  ; set a stopwatch
041633             0292*  ; returns: hl = start time
041633             0293*  ; destroys: hl,ix
041633             0294*  stopwatch_set:
041633             0295*      MOSCALL mos_sysvars     ; ix points to syvars table
041633 3E 08       0001*M 			LD	A, function
041635 5B CF       0002*M 			RST.LIL	08h
041637 DD 27 00    0296*      ld hl,(ix+sysvar_time)  ; get current time
04163A 22 4F 16 04 0297*      ld (stopwatch_started),hl            ; set start time
04163E C9          0298*      ret
04163F             0299*  
04163F             0300*  ; gets time elapsed on a stopwatch
04163F             0301*  ; returns: hl = time elapsed in 1/120ths of a second
04163F             0302*  ; destroys: af,hl,de,ix
04163F             0303*  stopwatch_get:
04163F             0304*      MOSCALL mos_sysvars     ; ix points to syvars table
04163F 3E 08       0001*M 			LD	A, function
041641 5B CF       0002*M 			RST.LIL	08h
041643 DD 27 00    0305*      ld hl,(ix+sysvar_time)  ; get current time
041646 ED 5B 4F 16 0306*      ld de,(stopwatch_started)            ; get start time
       04          
04164B AF          0307*      xor a                   ; clear carry
04164C ED 52       0308*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04164E C9          0309*      ret
04164F             0310*  
04164F             0311*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041652             0312*  
041652             0313*  ; ------------------
041652             0314*  ; delay routine
041652             0315*  ; Author: Richard Turrnidge
041652             0316*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041652             0317*  ; routine waits a fixed time,then returns
041652             0318*  ; arrive with A =  the delay byte. One bit to be set only.
041652             0319*  ; eg. ld A,00000100b
041652             0320*  
041652             0321*  multiPurposeDelay:
041652 F5          0322*      push af
041653 C5          0323*      push bc
041654 DD E5       0324*      push ix
041656 47          0325*      ld b,a
041657 3E 08       0326*      ld a,$08
041659 5B CF       0327*      RST.LIL	08h                 ; get IX pointer to sysvars
04165B             0328*  
04165B             0329*  waitLoop:
04165B             0330*  
04165B DD 7E 00    0331*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04165E             0332*  
04165E             0333*                                  ;   we check if bit set is same as last time we checked.
04165E             0334*                                  ;   bit 0 - don't use
04165E             0335*                                  ;   bit 1 - changes 64 times per second
04165E             0336*                                  ;   bit 2 - changes 32 times per second
04165E             0337*                                  ;   bit 3 - changes 16 times per second
04165E             0338*  
04165E             0339*                                  ;   bit 4 - changes 8 times per second
04165E             0340*                                  ;   bit 5 - changes 4 times per second
04165E             0341*                                  ;   bit 6 - changes 2 times per second
04165E             0342*                                  ;   bit 7 - changes 1 times per second
04165E A0          0343*      and b
04165F 4F          0344*      ld c,a
041660 3A 71 16 04 0345*      ld a,(oldTimeStamp)
041664 B9          0346*      cp c                        ; is A same as last value?
041665 28 F4       0347*      jr z,waitLoop              ; loop here if it is
041667 79          0348*      ld a,c
041668 32 71 16 04 0349*      ld (oldTimeStamp),a        ; set new value
04166C             0350*  
04166C DD E1       0351*      pop ix
04166E C1          0352*      pop bc
04166F F1          0353*      pop af
041670 C9          0354*      ret
041671             0355*  
041671 00          0356*  oldTimeStamp:   .db 00h
041672             0039       include "vdu.inc"
041672 FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
041700             0002*  
041700             0003*  ; VDU 30: Home cursor
041700             0004*  vdu_home_cursor:
041700 3E 1E       0005*      ld a,30
041702 5B D7       0006*  	rst.lil $10
041704 C9          0007*  	ret
041705             0008*  
041705             0009*  vdu_cursor_on:
041705 21 10 17 04 0010*  	ld hl,@cmd
041709 01 03 00 00 0011*  	ld bc,@end-@cmd
04170D 5B DF       0012*  	rst.lil $18
04170F C9          0013*  	ret
041710             0014*  @cmd:
041710 17 01 01    0015*  	db 23,1,1
041713             0016*  @end:
041713             0017*  
041713             0018*  vdu_cursor_off:
041713 21 1E 17 04 0019*  	ld hl,@cmd
041717 01 03 00 00 0020*  	ld bc,@end-@cmd
04171B 5B DF       0021*  	rst.lil $18
04171D C9          0022*  	ret
04171E             0023*  @cmd:
04171E 17 01 00    0024*  	db 23,1,0
041721             0025*  @end:
041721             0026*  
041721             0027*  ; VDU 5: Write text at graphics cursor
041721             0028*  ; inputs: a is the character to write to the screen
041721             0029*  ; prerequisites: the graphics cursor at the intended position on screen
041721             0030*  ; outputs: see the name of the function
041721             0031*  ; destroys: a, hl, bc
041721             0032*  vdu_char_to_gfx_cursor:
041721 32 31 17 04 0033*  	ld (@arg),a
041725 21 30 17 04 0034*  	ld hl,@cmd
041729 01 02 00 00 0035*  	ld bc,@end-@cmd
04172D 5B DF       0036*  	rst.lil $18
04172F C9          0037*  	ret
041730 05          0038*  @cmd: db 5
041731 00          0039*  @arg: db 0
041732             0040*  @end:
041732             0041*  ; VDU 9: Move cursor forward one character
041732             0042*  vdu_cursor_forward:
041732 3E 09       0043*      ld a,9
041734 5B D7       0044*  	rst.lil $10
041736 C9          0045*  	ret
041737             0046*  
041737             0047*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041737             0048*  ; inputs: c=x, b=y 8-bit unsigned integers
041737             0049*  vdu_move_cursor:
041737 ED 43 48 17 0050*      ld (@x0),bc
       04          
04173C 21 47 17 04 0051*  	ld hl,@cmd
041740 01 03 00 00 0052*  	ld bc,@end-@cmd
041744 5B DF       0053*  	rst.lil $18
041746 C9          0054*  	ret
041747 1F          0055*  @cmd: 	db 31
041748 00          0056*  @x0:	db 0
041749 00          0057*  @y0: 	db 0
04174A 00          0058*  @end: 	db 0 ; padding
04174B             0059*  
04174B             0060*  ; VDU 12: Clear text area (CLS)
04174B             0061*  vdu_cls:
04174B 3E 0C       0062*      ld a,12
04174D 5B D7       0063*  	rst.lil $10
04174F C9          0064*  	ret
041750             0065*  
041750             0066*  vdu_flip:
041750 21 5B 17 04 0067*  	ld hl,@cmd
041754 01 03 00 00 0068*  	ld bc,@end-@cmd
041758 5B DF       0069*  	rst.lil $18
04175A C9          0070*  	ret
04175B 17 00 C3    0071*  @cmd: db 23,0,0xC3
04175E             0072*  @end:
04175E             0073*  
04175E             0074*  ; VDU 16: Clear graphics area (CLG)
04175E             0075*  vdu_clg:
04175E 3E 10       0076*      ld a,16
041760 5B D7       0077*  	rst.lil $10
041762 C9          0078*  	ret
041763             0079*  
041763             0080*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041763             0081*  ; VDU 23, 7: Scrolling
041763             0082*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041763             0083*  ; inputs: a, extent; l, direction; h; speed
041763             0084*  vdu_scroll_down:
041763 32 78 17 04 0085*  	ld (@extent),a
041767 22 79 17 04 0086*  	ld (@dir),hl ; implicitly populates @speed
04176B 21 76 17 04 0087*  	ld hl,@cmd
04176F 01 05 00 00 0088*  	ld bc,@end-@cmd
041773 5B DF       0089*  	rst.lil $18     ;; Sending command to VDP
041775 C9          0090*  	ret
041776 17 07       0091*  @cmd:       db 23,7
041778 00          0092*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041779 00          0093*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04177A 00          0094*  @speed:     db 0x00 ; pixels
04177B 00          0095*  @end:		db 0x00 ; padding
04177C             0096*  
04177C             0097*  ; COLOUR MODES
04177C             0098*  ; Mode	Effect
04177C             0099*  ; 0	Set on-screen pixel to target colour value
04177C             0100*  ; 1	OR value with the on-screen pixel
04177C             0101*  ; 2	AND value with the on-screen pixel
04177C             0102*  ; 3	XOR value with the on-screen pixel
04177C             0103*  ; 4	Invert the on-screen pixel
04177C             0104*  ; 5	No operation
04177C             0105*  ; 6	AND the inverse of the specified colour with the on-screen pixel
04177C             0106*  ; 7	OR the inverse of the specified colour with the on-screen pixel
04177C             0107*  
04177C             0108*  ; VDU 17, colour: Define text colour (COLOUR)
04177C             0109*  vdu_colour_text:
04177C 32 8C 17 04 0110*  	ld (@arg),a
041780 21 8B 17 04 0111*  	ld hl,@cmd
041784 01 02 00 00 0112*  	ld bc,@end-@cmd
041788 5B DF       0113*  	rst.lil $18
04178A C9          0114*  	ret
04178B 11          0115*  @cmd: db 17
04178C 00          0116*  @arg: db 0
04178D             0117*  @end:
04178D             0118*  
04178D             0119*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04178D             0120*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04178D             0121*  vdu_gcol:
04178D 32 A2 17 04 0122*  	ld (@mode),a
041791 79          0123*      ld a,c
041792 32 A3 17 04 0124*      ld (@col),a
041796 21 A1 17 04 0125*  	ld hl,@cmd
04179A 01 03 00 00 0126*  	ld bc,@end-@cmd
04179E 5B DF       0127*  	rst.lil $18
0417A0 C9          0128*  	ret
0417A1 12          0129*  @cmd:  db 18
0417A2 00          0130*  @mode: db 0
0417A3 00          0131*  @col:  db 0
0417A4             0132*  @end:
0417A4             0133*  
0417A4             0134*  
0417A4             0135*  ; VDU 28, left, bottom, right, top: Set text viewport **
0417A4             0136*  ; MIND THE LITTLE-ENDIANESS
0417A4             0137*  ; inputs: c=left,b=bottom,e=right,d=top
0417A4             0138*  ; outputs; nothing
0417A4             0139*  ; destroys: a might make it out alive
0417A4             0140*  vdu_set_txt_viewport:
0417A4 ED 43 BA 17 0141*      ld (@lb),bc
       04          
0417A9 ED 53 BC 17 0142*  	ld (@rt),de
       04          
0417AE 21 B9 17 04 0143*  	ld hl,@cmd
0417B2 01 05 00 00 0144*  	ld bc,@end-@cmd
0417B6 5B DF       0145*  	rst.lil $18
0417B8 C9          0146*  	ret
0417B9 1C          0147*  @cmd:   db 28 ; set text viewport command
0417BA 00 00       0148*  @lb: 	dw 0x0000 ; set by bc
0417BC 00 00       0149*  @rt: 	dw 0x0000 ; set by de
0417BE 00          0150*  @end:   db 0x00	  ; padding
0417BF             0151*  
0417BF             0152*  ; Wait for VBLANK interrupt
0417BF             0153*  vdu_vblank:
0417BF DD E5       0154*      PUSH 	IX
0417C1             0155*  	MOSCALL	mos_sysvars
0417C1 3E 08       0001*M 			LD	A, function
0417C3 5B CF       0002*M 			RST.LIL	08h
0417C5 DD 7E 00    0156*  	LD	A, (IX + sysvar_time + 0)
0417C8             0157*  @wait:
0417C8 DD BE 00    0158*      CP 	A, (IX + sysvar_time + 0)
0417CB 28 FB       0159*      JR	Z, @wait
0417CD DD E1       0160*      POP	IX
0417CF C9          0161*      RET
0417D0             0162*  
0417D0             0163*  ; VDU 29, x; y;: Set graphics origin
0417D0             0164*  ; This command sets the graphics origin.
0417D0             0165*  ; The origin is the point on the screen where the coordinates (0,0) are located.
0417D0             0166*  ; inputs: bc=x0,de=y0
0417D0             0167*  ; outputs; nothing
0417D0             0168*  ; destroys: a might make it out alive
0417D0             0169*  vdu_set_gfx_origin:
0417D0 ED 43 E6 17 0170*      ld (@x0),bc
       04          
0417D5 ED 53 E8 17 0171*      ld (@y0),de
       04          
0417DA 21 E5 17 04 0172*      ld hl,@cmd
0417DE 01 05 00 00 0173*      ld bc,@end-@cmd
0417E2 5B DF       0174*      rst.lil $18
0417E4 C9          0175*      ret
0417E5 1D          0176*  @cmd:   db 29 ; set graphics origin command
0417E6 00 00       0177*  @x0: 	dw 0x0000 ; set by bc
0417E8 00 00       0178*  @y0: 	dw 0x0000 ; set by de
0417EA 00          0179*  @end:   db 0x00	  ; padding
0417EB             0180*  
0417EB             0181*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0417EB             0182*  ; NOTE: the order of the y-coordinate parameters are inverted
0417EB             0183*  ; 	because we have turned off logical screen scaling
0417EB             0184*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0417EB             0185*  ; outputs; nothing
0417EB             0186*  ; destroys: a might make it out alive
0417EB             0187*  vdu_set_gfx_viewport:
0417EB ED 43 0B 18 0188*      ld (@x0),bc
       04          
0417F0 FD 22 0D 18 0189*      ld (@y1),iy
       04          
0417F5 DD 22 0F 18 0190*  	ld (@x1),ix
       04          
0417FA ED 53 11 18 0191*  	ld (@y0),de
       04          
0417FF 21 0A 18 04 0192*  	ld hl,@cmd
041803 01 09 00 00 0193*  	ld bc,@end-@cmd
041807 5B DF       0194*  	rst.lil $18
041809 C9          0195*  	ret
04180A 18          0196*  @cmd:   db 24 ; set graphics viewport command
04180B 00 00       0197*  @x0: 	dw 0x0000 ; set by bc
04180D 00 00       0198*  @y1: 	dw 0x0000 ; set by iy
04180F 00 00       0199*  @x1: 	dw 0x0000 ; set by ix
041811 00 00       0200*  @y0: 	dw 0x0000 ; set by de
041813 00          0201*  @end:   db 0x00	  ; padding
041814             0202*  
041814             0203*  ; SCREEN MODES
041814             0204*  ; ===============================
041814             0205*  ; Mode  Horz  Vert  Cols  Refresh
041814             0206*  ; ---   ----  ----  ----  -------
041814             0207*  ; 11    320   240   2     60hz
041814             0208*  ; 139   320   240   2     60hz
041814             0209*  ; 23    512   384   2     60hz
041814             0210*  ; 151   512   384   2     60hz
041814             0211*  ; 6     640   240   2     60hz
041814             0212*  ; 134   640   240   2     60hz
041814             0213*  ; 2     640   480   2     60hz
041814             0214*  ; 130   640   480   2     60hz
041814             0215*  ; 17    800   600   2     60hz
041814             0216*  ; 145   800   600   2     60hz
041814             0217*  ; 18    1024  768   2     60hz
041814             0218*  ; 146   1024  768   2     60hz
041814             0219*  ; ---   ----  ----  ----  -------
041814             0220*  ; 10    320   240   4     60hz
041814             0221*  ; 138   320   240   4     60hz
041814             0222*  ; 22    512   384   4     60hz
041814             0223*  ; 150   512   384   4     60hz
041814             0224*  ; 5     640   240   4     60hz
041814             0225*  ; 133   640   240   4     60hz
041814             0226*  ; 1     640   480   4     60hz
041814             0227*  ; 129   640   480   4     60hz
041814             0228*  ; 16    800   600   4     60hz
041814             0229*  ; 19    1024  768   4     60hz
041814             0230*  ; ---   ----  ----  ----  -------
041814             0231*  ; 9     320   240   16    60hz
041814             0232*  ; 137   320   240   16    60hz
041814             0233*  ; 21    512   384   16    60hz
041814             0234*  ; 149   512   384   16    60hz
041814             0235*  ; 4     640   240   16    60hz
041814             0236*  ; 132   640   240   16    60hz
041814             0237*  ; 0     640   480   16    60hz
041814             0238*  ; 7     n/a   n/a   16    60hz
041814             0239*  ; ---   ----  ----  ----  -------
041814             0240*  ; 8     320   240   64    60hz
041814             0241*  ; 136   320   240   64    60hz
041814             0242*  ; 20    512   384   64    60hz
041814             0243*  ; 3     640   240   64    60hz
041814             0244*  ; ---   ----  ----  ----  -------
041814             0245*  vdu_set_screen_mode:
041814 32 24 18 04 0246*  	ld (@arg),a
041818 21 23 18 04 0247*  	ld hl,@cmd
04181C 01 02 00 00 0248*  	ld bc,@end-@cmd
041820 5B DF       0249*  	rst.lil $18
041822 C9          0250*  	ret
041823 16          0251*  @cmd: db 22 ; set screen mode
041824 00          0252*  @arg: db 0  ; screen mode parameter
041825             0253*  @end:
041825             0254*  
041825             0255*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041825             0256*  ; inputs: a is scaling mode, 1=on, 0=off
041825             0257*  ; note: default setting on boot is scaling ON
041825             0258*  vdu_set_scaling:
041825 32 37 18 04 0259*  	ld (@arg),a
041829 21 34 18 04 0260*  	ld hl,@cmd
04182D 01 04 00 00 0261*  	ld bc,@end-@cmd
041831 5B DF       0262*  	rst.lil $18
041833 C9          0263*  	ret
041834 17 00 C0    0264*  @cmd: db 23,0,0xC0
041837 00          0265*  @arg: db 0  ; scaling on/off
041838             0266*  @end:
041838             0267*  
041838             0268*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041838             0269*  ; inputs: hl=bufferId
041838             0270*  vdu_buff_select:
041838 22 4A 18 04 0271*  	ld (@bufferId),hl
04183C 21 47 18 04 0272*  	ld hl,@cmd
041840 01 05 00 00 0273*  	ld bc,@end-@cmd
041844 5B DF       0274*  	rst.lil $18
041846 C9          0275*  	ret
041847 17 1B 20    0276*  @cmd: db 23,27,0x20
04184A 00 00       0277*  @bufferId: dw 0x0000
04184C 00          0278*  @end: db 0x00 ; padding
04184D             0279*  
04184D             0280*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04184D             0281*  ; inputs: a=format; bc=width; de=height
04184D             0282*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04184D             0283*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04184D             0284*  ; 0 	RGBA8888 (4-bytes per pixel)
04184D             0285*  ; 1 	RGBA2222 (1-bytes per pixel)
04184D             0286*  ; 2 	Mono/Mask (1-bit per pixel)
04184D             0287*  ; 3 	Reserved for internal use by VDP (“native” format)
04184D             0288*  vdu_bmp_create:
04184D ED 43 69 18 0289*      ld (@width),bc
       04          
041852 ED 53 6B 18 0290*      ld (@height),de
       04          
041857 32 6D 18 04 0291*      ld (@fmt),a
04185B 21 66 18 04 0292*  	ld hl,@cmd
04185F 01 08 00 00 0293*  	ld bc,@end-@cmd
041863 5B DF       0294*  	rst.lil $18
041865 C9          0295*  	ret
041866 17 1B 21    0296*  @cmd:       db 23,27,0x21
041869 00 00       0297*  @width:     dw 0x0000
04186B 00 00       0298*  @height:    dw 0x0000
04186D 00          0299*  @fmt:       db 0x00
04186E             0300*  @end:
04186E             0301*  
04186E             0302*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04186E             0303*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04186E             0304*  vdu_load_img_rgba2_to_8:
04186E             0305*  ; backup the target buffer id and image dimensions
04186E E5          0306*      push hl
04186F D5          0307*      push de
041870 C5          0308*      push bc
041871             0309*  ; load the rgba2 image to working buffer 65534
041871 21 FE FF 00 0310*      ld hl,65534 ; temporary working buffer id
041875 CD 78 19 04 0311*  	call vdu_load_buffer_from_file
041879             0312*  ; restore the image dimensions and target buffer id
041879 C1          0313*      pop bc
04187A D1          0314*      pop de
04187B E1          0315*      pop hl
04187C             0316*  ; fall through to vdu_rgba2_to_8
04187C             0317*  
04187C             0318*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04187C             0319*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04187C             0320*  ; the "expand bitmap" command is:
04187C             0321*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04187C             0322*  ; and then to reverse the byte order to fix endian-ness:
04187C             0323*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04187C             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04187C             0325*  ; VDU 23,27,&20,targetBufferID%;
04187C             0326*  ; VDU 23,27,&21,width%;height%;0
04187C             0327*  ; -------------------------------------------------------------------
04187C             0328*  ; inputs: bc,de image width,height ; hl = targetBufferId
04187C             0329*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04187C             0330*  vdu_rgba2_to_8:
04187C             0331*  ; load the image dimensions and buffer id parameters
04187C ED 43 D8 18 0332*      ld (@width),bc
       04          
041881 ED 53 DA 18 0333*      ld (@height),de
       04          
041886 22 BD 18 04 0334*      ld (@bufferId0),hl
04188A 22 CA 18 04 0335*      ld (@bufferId2),hl
04188E 22 D3 18 04 0336*      ld (@bufferId1),hl
041892             0337*  ; clean up bytes that got stomped on by the ID loads
041892 3E 48       0338*      ld a,0x48
041894 32 BF 18 04 0339*      ld (@bufferId0+2),a
041898 3E 17       0340*      ld a,23
04189A 32 D5 18 04 0341*      ld (@bufferId1+2),a
04189E 3E 18       0342*      ld a,24
0418A0 32 CC 18 04 0343*      ld (@bufferId2+2),a
0418A4 AF          0344*      xor a
0418A5 32 DC 18 04 0345*      ld (@height+2),a
0418A9             0346*  ; send the vdu command strings
0418A9 21 B4 18 04 0347*      ld hl,@beg
0418AD 01 29 00 00 0348*      ld bc,@end-@beg
0418B1 5B DF       0349*      rst.lil $18
0418B3 C9          0350*      ret
0418B4             0351*  @beg:
0418B4             0352*  ; Command 14: Consolidate blocks in a buffer
0418B4             0353*  ; VDU 23, 0, &A0, bufferId; 14
0418B4 17 00 A0    0354*      db 23,0,0xA0
0418B7 FE FF       0355*      dw 65534 ; workingBufferId
0418B9 0E          0356*      db 14 ; consolidate blocks
0418BA             0357*  ; the "expand bitmap" command is:
0418BA             0358*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0418BA 17 00 A0    0359*      db 23,0,0xA0
0418BD 00 00       0360*  @bufferId0: dw 0x0000 ; targetBufferId
0418BF 48          0361*      db 0x48 ; given as decimal command 72 in the docs
0418C0 02          0362*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0418C1 FE FF       0363*      dw 65534 ; sourceBufferId
0418C3 00 7F BF FF 0364*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0418C7             0365*  ; reverse the byte order to fix endian-ness:
0418C7             0366*  ; Command 24: Reverse the order of data of blocks within a buffer
0418C7             0367*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0418C7             0368*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0418C7 17 00 A0    0369*      db 23,0,0xA0
0418CA 00 00       0370*  @bufferId2:    dw 0x0000 ; targetBufferId
0418CC 18          0371*      db 24 ; reverse byte order
0418CD 04          0372*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0418CE 04 00       0373*      dw 4 ; size (4 bytes)
0418D0             0374*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0418D0             0375*  ; VDU 23,27,&20,targetBufferID%;
0418D0 17 1B 20    0376*      db 23,27,0x20 ; select bitmap
0418D3 00 00       0377*  @bufferId1: dw 0x0000 ; targetBufferId
0418D5             0378*  ; VDU 23,27,&21,width%;height%;0
0418D5 17 1B 21    0379*      db 23,27,0x21 ; create bitmap from buffer
0418D8 00 00       0380*  @width: dw 0x0000
0418DA 00 00       0381*  @height: dw 0x0000
0418DC 00          0382*      db 0x00 ; rgba8888 format
0418DD             0383*  @end:
0418DD             0384*  
0418DD             0385*  ; scratch variables
0418DD 00 00 00    0386*  bufferId0: dl 0x000000
0418E0 00 00 00    0387*  bufferId1: dl 0x000000
0418E3             0388*  
0418E3             0389*  ; load a vdu buffer from local memory
0418E3             0390*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0418E3             0391*  vdu_load_buffer:
0418E3 ED 43 0C 19 0392*      ld (@length),bc
       04          
0418E8 D5          0393*      push de ; save data pointer
0418E9             0394*  ; send the vdu command string
0418E9 7D          0395*      ld a,l
0418EA 32 09 19 04 0396*      ld (@bufferId),a
0418EE 7C          0397*      ld a,h
0418EF 32 0A 19 04 0398*      ld (@bufferId+1),a
0418F3 21 06 19 04 0399*      ld hl,@cmd
0418F7 01 08 00 00 0400*      ld bc,@end-@cmd
0418FB 5B DF       0401*      rst.lil $18
0418FD             0402*  ; send the buffer data
0418FD E1          0403*      pop hl ; pointer to data
0418FE ED 4B 0C 19 0404*      ld bc,(@length)
       04          
041903 5B DF       0405*      rst.lil $18 ; send it
041905 C9          0406*      ret
041906             0407*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041906 17 00 A0    0408*  @cmd:       db 23,0,0xA0
041909 00 00       0409*  @bufferId:	dw 0x0000
04190B 00          0410*  		    db 0 ; load buffer
04190C 00 00       0411*  @length:	dw 0x0000
04190E 00          0412*  @end: db 0 ; padding
04190F             0413*  
04190F             0414*  ; clear a buffer
04190F             0415*  ; inputs: hl = bufferId
04190F             0416*  vdu_clear_buffer:
04190F 7D          0417*      ld a,l
041910 32 27 19 04 0418*      ld (@bufferId),a
041914 7C          0419*      ld a,h
041915 32 28 19 04 0420*      ld (@bufferId+1),a
041919 21 24 19 04 0421*      ld hl,@cmd
04191D 01 06 00 00 0422*      ld bc,@end-@cmd
041921 5B DF       0423*      rst.lil $18
041923 C9          0424*      ret
041924 17 00 A0    0425*  @cmd:       db 23,0,0xA0
041927 00 00       0426*  @bufferId:	dw 0x0000
041929 02          0427*  		    db 2 ; clear buffer
04192A             0428*  @end:
04192A             0429*  
04192A             0430*  vdu_clear_all_buffers:
04192A             0431*  ; clear all buffers
04192A 21 35 19 04 0432*      ld hl,@beg
04192E 01 06 00 00 0433*      ld bc,@end-@beg
041932 5B DF       0434*      rst.lil $18
041934 C9          0435*      ret
041935 17 00 A0    0436*  @beg: db 23,0,$A0
041938 FF FF       0437*        dw -1 ; clear all buffers
04193A 02          0438*        db 2  ; command 2: clear a buffer
04193B             0439*  @end:
04193B             0440*  
04193B             0441*  ; Command 14: Consolidate blocks in a buffer
04193B             0442*  vdu_consolidate_buffer:
04193B             0443*  ; set parameters for vdu call
04193B 7D          0444*      ld a,l
04193C 32 53 19 04 0445*      ld (@bufferId),a
041940 7C          0446*      ld a,h
041941 32 54 19 04 0447*      ld (@bufferId+1),a
041945 21 50 19 04 0448*      ld hl,@beg
041949 01 06 00 00 0449*      ld bc,@end-@beg
04194D 5B DF       0450*      rst.lil $18
04194F C9          0451*      ret
041950             0452*  ; VDU 23, 0, &A0, bufferId; 14
041950 17 00 A0    0453*  @beg: db 23,0,0xA0
041953 00 00       0454*  @bufferId: dw 0x0000
041955 0E          0455*             db 14
041956             0456*  @end:
041956             0457*  
041956             0458*  ; load an image file to a buffer and make it a bitmap
041956             0459*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041956             0460*  vdu_load_img:
041956             0461*  ; back up image type and dimension parameters
041956 22 DD 18 04 0462*      ld (bufferId0),hl
04195A F5          0463*      push af
04195B C5          0464*  	push bc
04195C D5          0465*  	push de
04195D             0466*  ; load the image
04195D CD 78 19 04 0467*  	call vdu_load_buffer_from_file
041961             0468*  ; now make it a bitmap
041961 2A DD 18 04 0469*      ld hl,(bufferId0)
041965 CD 3B 19 04 0470*      call vdu_consolidate_buffer
041969 2A DD 18 04 0471*      ld hl,(bufferId0)
04196D CD 38 18 04 0472*      call vdu_buff_select
041971 D1          0473*  	pop de ; image height
041972 C1          0474*  	pop bc ; image width
041973 F1          0475*  	pop af ; image type
041974 C3 4D 18 04 0476*  	jp vdu_bmp_create ; will return to caller from there
041978             0477*  
041978             0478*  ; inputs: hl = bufferId; iy = pointer to filename
041978             0479*  vdu_load_buffer_from_file:
041978 22 DD 18 04 0480*      ld (bufferId0),hl
04197C             0481*  
04197C             0482*  ; clear target buffer
04197C CD 0F 19 04 0483*      call vdu_clear_buffer
041980             0484*  
041980             0485*  ; open the file in read mode
041980             0486*  ; Open a file
041980             0487*  ; HLU: Filename
041980             0488*  ;   C: Mode
041980             0489*  ; Returns:
041980             0490*  ;   A: Filehandle, or 0 if couldn't open
041980 FD E5       0491*  	push iy ; pointer to filename
041982 E1          0492*  	pop hl
041983 0E 01       0493*  	ld c,fa_read
041985             0494*      MOSCALL mos_fopen
041985 3E 0A       0001*M 			LD	A, function
041987 5B CF       0002*M 			RST.LIL	08h
041989 32 C4 19 04 0495*      ld (@filehandle),a
04198D             0496*  
04198D             0497*  @read_file:
04198D             0498*  ; Read a block of data from a file
04198D             0499*  ;   C: Filehandle
04198D             0500*  ; HLU: Pointer to where to write the data to
04198D             0501*  ; DEU: Number of bytes to read
04198D             0502*  ; Returns:
04198D             0503*  ; DEU: Number of bytes read
04198D 3A C4 19 04 0504*      ld a,(@filehandle)
041991 4F          0505*      ld c,a
041992 21 00 E0 B7 0506*      ld hl,filedata
041996 11 00 20 00 0507*      ld de,8192 ; max we can read into onboard sram at one time
04199A             0508*      MOSCALL mos_fread
04199A 3E 1A       0001*M 			LD	A, function
04199C 5B CF       0002*M 			RST.LIL	08h
04199E             0509*  
04199E             0510*  ; test de for zero bytes read
04199E 21 00 00 00 0511*      ld hl,0
0419A2 AF          0512*      xor a ; clear carry
0419A3 ED 52       0513*      sbc hl,de
0419A5 CA BB 19 04 0514*      jp z,@close_file
0419A9             0515*  
0419A9             0516*  ; load a vdu buffer from local memory
0419A9             0517*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0419A9 2A DD 18 04 0518*      ld hl,(bufferId0)
0419AD D5          0519*      push de ; chunksize
0419AE C1          0520*      pop bc
0419AF 11 00 E0 B7 0521*      ld de,filedata
0419B3 CD E3 18 04 0522*      call vdu_load_buffer
0419B7             0523*  
0419B7             0524*  ; read the next block
0419B7 C3 8D 19 04 0525*      jp @read_file
0419BB             0526*  
0419BB             0527*  ; close the file
0419BB             0528*  @close_file:
0419BB 3A C4 19 04 0529*      ld a,(@filehandle)
0419BF             0530*      MOSCALL mos_fclose
0419BF 3E 0B       0001*M 			LD	A, function
0419C1 5B CF       0002*M 			RST.LIL	08h
0419C3 C9          0531*      ret ; vdu_load_buffer_from_file
0419C4             0532*  
0419C4 00          0533*  @filehandle: db 0 ; file handle
0419C5 00 00 00    0534*  @fil: dl 0 ; pointer to FIL struct
0419C8             0535*  
0419C8 00 00 00    0536*  @chunkpointer: dl 0 ; pointer to current chunk
0419CB             0537*  
0419CB             0538*  ; File information structure (FILINFO)
0419CB             0539*  @filinfo:
0419CB 00 00 00 00 0540*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0419CF 00 00       0541*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0419D1 00 00       0542*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0419D3 00          0543*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0419D4 00 00 00 00 0544*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0419E1 00 00 00 00 0545*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041AE1             0040       include "vdu_fonts.inc"
041AE1 FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
041B00             0002*  ; select font
041B00             0003*  ; inputs: hl = bufferId, a = font flags
041B00             0004*  ; Flags:
041B00             0005*  ; Bit	Description
041B00             0006*  ; 0	Adjust cursor position to ensure text baseline is aligned
041B00             0007*  ;   0: Do not adjust cursor position (best for changing font on a new line)
041B00             0008*  ;   1: Adjust cursor position (best for changing font in the middle of a line)
041B00             0009*  ; 1-7	Reserved for future use
041B00             0010*  ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041B00             0011*  vdu_font_select:
041B00 22 17 1B 04 0012*      ld (@bufferId),hl
041B04 32 19 1B 04 0013*      ld (@flags),a
041B08 21 13 1B 04 0014*      ld hl,@cmd
041B0C 01 07 00 00 0015*      ld bc,@end-@cmd
041B10 5B DF       0016*      rst.lil $18
041B12 C9          0017*      ret
041B13 17 00 95 00 0018*  @cmd: db 23, 0, 0x95, 0
041B17 00 00       0019*  @bufferId: dw 0x0000
041B19 00          0020*  @flags: db 0x00
041B1A             0021*  @end:
041B1A             0022*  
041B1A             0023*  ; create font from buffer
041B1A             0024*  ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041B1A             0025*  ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041B1A             0026*  vdu_font_create:
041B1A 22 3F 1B 04 0027*      ld (@bufferId),hl
041B1E ED 53 41 1B 0028*      ld (@width),de ; also loads height
       04          
041B23 32 44 1B 04 0029*      ld (@flags),a
041B27 7A          0030*      ld a,d ; height
041B28 32 43 1B 04 0031*      ld (@ascent),a ; ascent = height
041B2C             0032*  ; consolidate buffer
041B2C CD 3B 19 04 0033*      call vdu_consolidate_buffer
041B30             0034*  ; create font
041B30 21 3B 1B 04 0035*      ld hl,@cmd
041B34 01 0A 00 00 0036*      ld bc,@end-@cmd
041B38 5B DF       0037*      rst.lil $18
041B3A C9          0038*      ret
041B3B 17 00 95 01 0039*  @cmd: db 23, 0, 0x95, 1
041B3F 00 00       0040*  @bufferId: dw 0x0000
041B41 00          0041*  @width: db 0x00
041B42 00          0042*  @height: db 0x00
041B43 00          0043*  @ascent: db 0x00
041B44 00          0044*  @flags: db 0x00
041B45             0045*  @end:
041B45             0046*  
041B45             0047*  ; set or adjust font property
041B45             0048*  ; inputs: hl = bufferId, a = field, de = value
041B45             0049*  ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041B45             0050*  vdu_font_property:
041B45 22 61 1B 04 0051*      ld (@bufferId),hl
041B49 32 63 1B 04 0052*      ld (@field),a
041B4D ED 53 64 1B 0053*      ld (@value),de
       04          
041B52 21 5D 1B 04 0054*      ld hl,@cmd
041B56 01 09 00 00 0055*      ld bc,@end-@cmd
041B5A 5B DF       0056*      rst.lil $18
041B5C C9          0057*      ret
041B5D 17 00 95 02 0058*  @cmd: db 23, 0, 0x95, 2
041B61 00 00       0059*  @bufferId: dw 0x0000
041B63 00          0060*  @field: db 0x00
041B64 00 00       0061*  @value: dw 0x0000
041B66 00          0062*  @end: db 0x00 ; padding
041B67             0063*  
041B67             0064*  ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041B67             0065*  
041B67             0066*  ; Clear/Delete font
041B67             0067*  ; inputs: hl = bufferId
041B67             0068*  ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041B67             0069*  vdu_font_clear:
041B67 22 7A 1B 04 0070*      ld (@bufferId),hl
041B6B 21 76 1B 04 0071*      ld hl,@cmd
041B6F 01 06 00 00 0072*      ld bc,@end-@cmd
041B73 5B DF       0073*      rst.lil $18
041B75 C9          0074*      ret
041B76 17 00 95 04 0075*  @cmd: db 23, 0, 0x95, 4
041B7A 00 00       0076*  @bufferId: dw 0x0000
041B7C 00          0077*  @end: db 0x00 ; padding
041B7D             0078*  
041B7D             0079*  ; Copy system font to buffer
041B7D             0080*  ; inputs: hl = bufferId
041B7D             0081*  ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041B7D             0082*  vdu_font_copy_system:
041B7D 22 90 1B 04 0083*      ld (@bufferId),hl
041B81 21 8C 1B 04 0084*      ld hl,@cmd
041B85 01 06 00 00 0085*      ld bc,@end-@cmd
041B89 5B DF       0086*      rst.lil $18
041B8B C9          0087*      ret
041B8C 17 00 95 05 0088*  @cmd: db 23, 0, 0x95, 5
041B90 00 00       0089*  @bufferId: dw 0x0000
041B92 00          0090*  @end: db 0x00 ; padding
041B93             0041       include "vdu_plot.inc"
041B93 FF FF FF FF 0001*      align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
041C00             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C00             0003*  ; PLOT code 	(Decimal) 	Effect
041C00             0004*  ; &00-&07 	0-7 	Solid line, includes both ends
041C00             0005*  plot_sl_both: equ 0x00
041C00             0006*  
041C00             0007*  ; &08-&0F 	8-15 	Solid line, final point omitted
041C00             0008*  plot_sl_first: equ 0x08
041C00             0009*  
041C00             0010*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041C00             0011*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041C00             0012*  
041C00             0013*  ; &20-&27 	32-39 	Solid line, first point omitted
041C00             0014*  plot_sl_last: equ 0x20
041C00             0015*  
041C00             0016*  ; &28-&2F 	40-47 	Solid line, both points omitted
041C00             0017*  plot_sl_none: equ 0x28
041C00             0018*  
041C00             0019*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041C00             0020*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041C00             0021*  
041C00             0022*  ; &40-&47 	64-71 	Point plot
041C00             0023*  plot_pt: equ 0x40
041C00             0024*  
041C00             0025*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041C00             0026*  plot_lf_lr_non_bg: equ 0x48
041C00             0027*  
041C00             0028*  ; &50-&57 	80-87 	Triangle fill
041C00             0029*  plot_tf: equ 0x50
041C00             0030*  
041C00             0031*  ; &58-&5F 	88-95 	Line fill right to background §§
041C00             0032*  plot_lf_r_bg: equ 0x58
041C00             0033*  
041C00             0034*  ; &60-&67 	96-103 	Rectangle fill
041C00             0035*  plot_rf: equ 0x60
041C00             0036*  
041C00             0037*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041C00             0038*  plot_lf_lr_fg: equ 0x60
041C00             0039*  
041C00             0040*  ; &70-&77 	112-119 	Parallelogram fill
041C00             0041*  plot_pf: equ 0x70
041C00             0042*  
041C00             0043*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041C00             0044*  plot_lf_r_non_fg: equ 0x78
041C00             0045*  
041C00             0046*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
041C00             0047*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041C00             0048*  
041C00             0049*  ; &90-&97 	144-151 	Circle outline
041C00             0050*  plot_co: equ 0x90
041C00             0051*  
041C00             0052*  ; &98-&9F 	152-159 	Circle fill
041C00             0053*  plot_cf: equ 0x98
041C00             0054*  
041C00             0055*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
041C00             0056*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
041C00             0057*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
041C00             0058*  
041C00             0059*  ; &B8-&BF 	184-191 	Rectangle copy/move
041C00             0060*  plot_rcm: equ 0xB8
041C00             0061*  
041C00             0062*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041C00             0063*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041C00             0064*  ; &D0-&D7 	208-215 	Not defined
041C00             0065*  ; &D8-&DF 	216-223 	Not defined
041C00             0066*  ; &E0-&E7 	224-231 	Not defined
041C00             0067*  
041C00             0068*  ; &E8-&EF 	232-239 	Bitmap plot §
041C00             0069*  plot_bmp: equ 0xE8
041C00             0070*  
041C00             0071*  ; &F0-&F7 	240-247 	Not defined
041C00             0072*  ; &F8-&FF 	248-255 	Not defined
041C00             0073*  
041C00             0074*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041C00             0075*  ; Agon Console8 VDP 2.2.0
041C00             0076*  
041C00             0077*  ; Within each group of eight plot codes, the effects are as follows:
041C00             0078*  ; Plot code 	Effect
041C00             0079*  ; 0 	Move relative
041C00             0080*  mv_rel: equ 0
041C00             0081*  
041C00             0082*  ; 1 	Plot relative in current foreground colour
041C00             0083*  dr_rel_fg: equ 1
041C00             0084*  
041C00             0085*  ; 2 	Not supported (Plot relative in logical inverse colour)
041C00             0086*  ; 3 	Plot relative in current background colour
041C00             0087*  dr_rel_bg: equ 3
041C00             0088*  
041C00             0089*  ; 4 	Move absolute
041C00             0090*  mv_abs: equ 4
041C00             0091*  
041C00             0092*  ; 5 	Plot absolute in current foreground colour
041C00             0093*  dr_abs_fg: equ 5
041C00             0094*  
041C00             0095*  ; 6 	Not supported (Plot absolute in logical inverse colour)
041C00             0096*  ; 7 	Plot absolute in current background colour
041C00             0097*  dr_abs_bg: equ 7
041C00             0098*  
041C00             0099*  ; Codes 0-3 use the position data provided as part of the command
041C00             0100*  ; as a relative position, adding the position given to the current
041C00             0101*  ; graphical cursor position. Codes 4-7 use the position data provided
041C00             0102*  ; as part of the command as an absolute position, setting the current
041C00             0103*  ; graphical cursor position to the position given.
041C00             0104*  
041C00             0105*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041C00             0106*  ; current pixel colour. These operations cannot currently be supported
041C00             0107*  ; by the graphics system the Agon VDP uses, so these codes are not
041C00             0108*  ; supported. Support for these codes may be added in a future version
041C00             0109*  ; of the VDP firmware.
041C00             0110*  
041C00             0111*  ; 16 colour palette constants
041C00             0112*  c_black: equ 0
041C00             0113*  c_red_dk: equ 1
041C00             0114*  c_green_dk: equ 2
041C00             0115*  c_yellow_dk: equ 3
041C00             0116*  c_blue_dk: equ 4
041C00             0117*  c_magenta_dk: equ 5
041C00             0118*  c_cyan_dk: equ 6
041C00             0119*  c_grey: equ 7
041C00             0120*  c_grey_dk: equ 8
041C00             0121*  c_red: equ 9
041C00             0122*  c_green: equ 10
041C00             0123*  c_yellow: equ 11
041C00             0124*  c_blue: equ 12
041C00             0125*  c_magenta: equ 13
041C00             0126*  c_cyan: equ 14
041C00             0127*  c_white: equ 15
041C00             0128*  
041C00             0129*  ; VDU 25, mode, x; y;: PLOT command
041C00             0130*  ; inputs: a=mode, bc=x0, de=y0
041C00             0131*  vdu_plot:
041C00 32 1A 1C 04 0132*      ld (@mode),a
041C04 ED 43 1B 1C 0133*      ld (@x0),bc
       04          
041C09 ED 53 1D 1C 0134*      ld (@y0),de
       04          
041C0E 21 19 1C 04 0135*  	ld hl,@cmd
041C12 01 06 00 00 0136*  	ld bc,@end-@cmd
041C16 5B DF       0137*  	rst.lil $18
041C18 C9          0138*  	ret
041C19 19          0139*  @cmd:   db 25
041C1A 00          0140*  @mode:  db 0
041C1B 00 00       0141*  @x0: 	dw 0
041C1D 00 00       0142*  @y0: 	dw 0
041C1F 00          0143*  @end:   db 0 ; extra byte to soak up deu
041C20             0144*  
041C20             0145*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C20             0146*  ; &E8-&EF 	232-239 	Bitmap plot §
041C20             0147*  ; VDU 25, mode, x; y;: PLOT command
041C20             0148*  ; inputs: bc=x0, de=y0
041C20             0149*  ; prerequisites: vdu_buff_select
041C20             0150*  vdu_plot_bmp:
041C20 ED 43 37 1C 0151*      ld (@x0),bc
       04          
041C25 ED 53 39 1C 0152*      ld (@y0),de
       04          
041C2A 21 35 1C 04 0153*  	ld hl,@cmd
041C2E 01 06 00 00 0154*  	ld bc,@end-@cmd
041C32 5B DF       0155*  	rst.lil $18
041C34 C9          0156*  	ret
041C35 19          0157*  @cmd:   db 25
041C36 ED          0158*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C37 00 00       0159*  @x0: 	dw 0x0000
041C39 00 00       0160*  @y0: 	dw 0x0000
041C3B 00          0161*  @end:   db 0x00 ; padding
041C3C             0162*  
041C3C             0163*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041C3C             0164*  ; &E8-&EF 	232-239 	Bitmap plot §
041C3C             0165*  ; VDU 25, mode, x; y;: PLOT command
041C3C             0166*  ; inputs: bc=x0, de=y0
041C3C             0167*  ; USING 16.8 FIXED POINT COORDINATES
041C3C             0168*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041C3C             0169*  ;   the fractional portiion of the inputs are truncated
041C3C             0170*  ;   leaving only the 16-bit integer portion
041C3C             0171*  ; prerequisites: vdu_buff_select
041C3C             0172*  vdu_plot_bmp168:
041C3C             0173*  ; populate in the reverse of normal to keep the
041C3C             0174*  ; inputs from stomping on each other
041C3C ED 53 5A 1C 0175*      ld (@y0-1),de
       04          
041C41 ED 43 58 1C 0176*      ld (@x0-1),bc
       04          
041C46 3E ED       0177*      ld a,plot_bmp+dr_abs_fg ; 0xED
041C48 32 58 1C 04 0178*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041C4C 21 57 1C 04 0179*  	ld hl,@cmd
041C50 01 06 00 00 0180*  	ld bc,@end-@cmd
041C54 5B DF       0181*  	rst.lil $18
041C56 C9          0182*  	ret
041C57 19          0183*  @cmd:   db 25
041C58 ED          0184*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041C59 00 00       0185*  @x0: 	dw 0x0000
041C5B 00 00       0186*  @y0: 	dw 0x0000
041C5D             0187*  @end:  ; no padding required b/c we shifted de right
041C5D             0188*  
041C5D             0189*  ; draw a filled rectangle
041C5D             0190*  vdu_plot_rf:
041C5D ED 43 84 1C 0191*      ld (@x0),bc
       04          
041C62 ED 53 86 1C 0192*      ld (@y0),de
       04          
041C67 DD 22 8A 1C 0193*      ld (@x1),ix
       04          
041C6C FD 22 8C 1C 0194*      ld (@y1),iy
       04          
041C71 3E 19       0195*      ld a,25 ; we have to reload the 2nd plot command
041C73 32 88 1C 04 0196*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041C77 21 82 1C 04 0197*  	ld hl,@cmd0
041C7B 01 0C 00 00 0198*  	ld bc,@end-@cmd0
041C7F 5B DF       0199*  	rst.lil $18
041C81 C9          0200*      ret
041C82 19          0201*  @cmd0:  db 25 ; plot
041C83 04          0202*  @arg0:  db plot_sl_both+mv_abs
041C84 00 00       0203*  @x0:    dw 0x0000
041C86 00 00       0204*  @y0:    dw 0x0000
041C88 19          0205*  @cmd1:  db 25 ; plot
041C89 65          0206*  @arg1:  db plot_rf+dr_abs_fg
041C8A 00 00       0207*  @x1:    dw 0x0000
041C8C 00 00       0208*  @y1:    dw 0x0000
041C8E 00          0209*  @end:   db 0x00 ; padding
041C8F             0210*  
041C8F             0211*  ; draw a filled circle
041C8F             0212*  vdu_plot_cf:
041C8F ED 43 B6 1C 0213*      ld (@x0),bc
       04          
041C94 ED 53 B8 1C 0214*      ld (@y0),de
       04          
041C99 DD 22 BC 1C 0215*      ld (@x1),ix
       04          
041C9E FD 22 BE 1C 0216*      ld (@y1),iy
       04          
041CA3 3E 19       0217*      ld a,25 ; we have to reload the 2nd plot command
041CA5 32 BA 1C 04 0218*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041CA9 21 B4 1C 04 0219*  	ld hl,@cmd0
041CAD 01 0C 00 00 0220*  	ld bc,@end-@cmd0
041CB1 5B DF       0221*  	rst.lil $18
041CB3 C9          0222*      ret
041CB4 19          0223*  @cmd0:  db 25 ; plot
041CB5 04          0224*  @arg0:  db plot_sl_both+mv_abs
041CB6 00 00       0225*  @x0:    dw 0x0000
041CB8 00 00       0226*  @y0:    dw 0x0000
041CBA 19          0227*  @cmd1:  db 25 ; plot
041CBB 9D          0228*  @arg1:  db plot_cf+dr_abs_fg
041CBC 00 00       0229*  @x1:    dw 0x0000
041CBE 00 00       0230*  @y1:    dw 0x0000
041CC0 00          0231*  @end:   db 0x00 ; padding
041CC1             0042       ; include "vdu_sprites.inc"
041CC1             0043   
041CC1             0044   ; ; APPLICATION INCLUDES
041CC1             0045   ;     include "ascii.inc"
041CC1             0046   ;     include "collisions.inc"
041CC1             0047   ;     include "enemies.inc"
041CC1             0048   ;     include "enemy_fireball.inc"
041CC1             0049   ;     include "enemy_seeker.inc"
041CC1             0050   ;     include "explosion.inc"
041CC1             0051   ;     include "fonts_list.inc"
041CC1             0052   ;     include "images_tiles_dg.inc"
041CC1             0053   ;     ; include "images_tiles_xevious.inc"
041CC1             0054   ;     include "images_sprites.inc"
041CC1             0055   ;     include "images_ui.inc"
041CC1             0056   ;     ; include "laser.inc"
041CC1             0057   ;     include "levels.inc"
041CC1             0058   ;     include "levels_tileset_0.inc"
041CC1             0059   ;     ; include "levels_xevious.inc"
041CC1             0060   ;     include "player.inc"
041CC1             0061   ;     include "player_laser.inc"
041CC1             0062   ;     include "player_weapons.inc"
041CC1             0063   ;     include "state.inc"
041CC1             0064   ;     include "targeting.inc"
041CC1             0065   ;     include "tile_table.inc"
041CC1             0066   ;     include "tiles.inc"
041CC1             0067   ;     include "tiles_active.inc"
041CC1             0068   ;     include "tile_pad_small.inc"
041CC1             0069   ;     include "tile_turret_fireball.inc"
041CC1             0070   ;     include "sprites.inc"
041CC1             0071   ;     include "sprites_new.inc"
041CC1             0072   
041CC1 FF FF FF FF 0073       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
041D00             0074   
041D00             0075   ; --- MAIN PROGRAM FILE ---
041D00 57 65 6C 63 0076   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
041D1B 4C 6F 61 64 0077   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
041D29 50 72 65 73 0078   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
041D44             0079   
041D44             0080   init:
041D44 C9          0081       ret
041D45             0082   
041D45             0083   buffer:
041D45             0084       ; db 0x0D,0x0E,0x0F
041D45             0085       ; db 0x0A,0x0B,0x0C
041D45 07 08 09    0086       db 0x07,0x08,0x09
041D48 04 05 06    0087       db 0x04,0x05,0x06
041D4B 01 02 03    0088       db 0x01,0x02,0x03
041D4E             0089   
041D4E             0090   main:
041D4E DD 21 45 1D 0091       ld ix,buffer
       04          
041D53 DD 27 00    0092       ld hl,(ix+0)
041D56 E5          0093       push hl
041D57 DD 27 03    0094       ld hl,(ix+3)
041D5A E5          0095       push hl
041D5B DD 27 06    0096       ld hl,(ix+6)
041D5E E5          0097       push hl
041D5F             0098   
041D5F             0099   ; ; the testing is here
041D5F             0100   ;     pop hl
041D5F             0101   ;     pop hl
041D5F             0102   ;     call printHex24 ; 0x060504
041D5F             0103   ;     call printNewLine
041D5F             0104   ; ; end of testing
041D5F             0105   
041D5F             0106   ; ; the testing is here
041D5F             0107   ;     pop hl
041D5F             0108   ;     inc sp
041D5F             0109   ;     pop hl
041D5F             0110   ;     dec sp
041D5F             0111   ;     call printHex24 ; 0x070605
041D5F             0112   ;     call printNewLine
041D5F             0113   ; ; end of testing
041D5F             0114   
041D5F             0115   ; the testing is here
041D5F E1          0116       pop hl
041D60 3B          0117       dec sp
041D61 E1          0118       pop hl
041D62 33          0119       inc sp
041D63 CD 27 01 04 0120       call printHex24 ; 0x080706
041D67 CD 1C 01 04 0121       call printNewLine
041D6B             0122   ; end of testing
041D6B             0123   
041D6B E1          0124       pop hl
041D6C             0125   
041D6C             0126       ; ld a,0xAB
041D6C             0127       ; A_TO_HLU
041D6C             0128       ; call printHex24
041D6C             0129       ; call printNewLine
041D6C             0130   
041D6C C3 DC 1D 04 0131       jp main_end
041D70             0132   
041D70             0133   ; test umul24ss
041D70 CD BF 17 04 0134       call vdu_vblank ; synchronize timer
041D74 FD 21 EA 15 0135       ld iy,tmr_test
       04          
041D79 21 78 00 00 0136       ld hl,120 ; 1 second
041D7D CD C8 15 04 0137       call tmr_set
041D81 21 00 00 00 0138       ld hl,0 ; counter
041D85 E5          0139       push hl ; save counter
041D86             0140   @@:
041D86 21 00 01 00 0141       ld hl,256
041D8A 11 00 01 00 0142       ld de,256
041D8E CD B8 0A 04 0143       call umul168
041D92 E1          0144       pop hl ; restore counter
041D93 23          0145       inc hl
041D94 E5          0146       push hl ; save counter
041D95 CD D6 15 04 0147       call tmr_get
041D99 F2 86 1D 04 0148       jp p,@B
041D9D E1          0149       pop hl ; restore counter
041D9E CD 06 02 04 0150       call printDec
041DA2 CD 1C 01 04 0151       call printNewLine
041DA6             0152   
041DA6             0153   ; test umul24
041DA6 CD BF 17 04 0154       call vdu_vblank ; synchronize timer
041DAA FD 21 EA 15 0155       ld iy,tmr_test
       04          
041DAF 21 78 00 00 0156       ld hl,120 ; 1 second
041DB3 CD C8 15 04 0157       call tmr_set
041DB7 21 00 00 00 0158       ld hl,0 ; counter
041DBB E5          0159       push hl ; save counter
041DBC             0160   @@:
041DBC 21 00 01 00 0161       ld hl,256
041DC0 11 00 01 00 0162       ld de,256
041DC4 CD E4 0A 04 0163       call udiv168
041DC8 E1          0164       pop hl ; restore counter
041DC9 23          0165       inc hl
041DCA E5          0166       push hl ; save counter
041DCB CD D6 15 04 0167       call tmr_get
041DCF F2 BC 1D 04 0168       jp p,@B
041DD3 E1          0169       pop hl ; restore counter
041DD4 CD 06 02 04 0170       call printDec
041DD8 CD 1C 01 04 0171       call printNewLine
041DDC             0172   
041DDC             0173   
041DDC             0174   main_end:
041DDC C9          0175       ret
041DDD             0176   
041DDD             0177       ; include "tables.inc"
