PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       ; include "mos_api.inc"
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       db "MOS"
040043 00          0010       db 00h
040044 01          0011       db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 66 0E 04 0020       call init
040050 CD 67 0E 04 0021       call main
040054             0022   
040054             0023   exit:
040054             0024   
040054 FD E1       0025       pop iy
040056 DD E1       0026       pop ix
040058 D1          0027       pop de
040059 C1          0028       pop bc
04005A F1          0029       pop af
04005B 21 00 00 00 0030       ld hl,0
04005F             0031   
04005F C9          0032       ret
040060             0033   
040060             0034   ; --- MAIN PROGRAM ---
040060             0035   ; APPLICATION INCLUDES
040060             0036       include "../../fixed168/fixed168.inc"
040060             0001*  ; multiply HL by 256
040060             0002*  ; inputs: HL
040060             0003*  ; outputs: HL*256
040060             0004*  ; destroys: flags
040060             0005*      MACRO hlu_mul256
040060             0006*          add hl,hl ; * 2
040060             0007*          add hl,hl ; * 4
040060             0008*          add hl,hl ; * 8
040060             0009*          add hl,hl ; * 16
040060             0010*          add hl,hl ; * 32
040060             0011*          add hl,hl ; * 64
040060             0012*          add hl,hl ; * 128
040060             0013*          add hl,hl ; * 256
040060             0014*      ENDMACRO
040060             0015*  
040060             0016*  ; test the sign of HL
040060             0017*  ; inputs: HL obviously
040060             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0019*  ; destroys: flags
040060             0020*      MACRO sign_hlu
040060             0021*          add hl,de
040060             0022*          or a
040060             0023*          sbc hl,de
040060             0024*      ENDMACRO
040060             0025*  
040060             0026*  ; hlu signed division by 256
040060             0027*  ; returns: hlu / 256
040060             0028*  ; destroys: af
040060             0029*  hlu_sdiv256:
040060 AF          0030*      xor a ; assume hl is positive
040061 22 77 00 04 0031*      ld (@buffer),hl
040065             0032*      sign_hlu
040065 19          0001*M         add hl,de
040066 B7          0002*M         or a
040067 ED 52       0003*M         sbc hl,de
040069 F2 6E 00 04 0033*      jp p,@hl_pos
04006D 3D          0034*      dec a
04006E             0035*  @hl_pos:
04006E 32 7A 00 04 0036*      ld (@buffer+3),a
040072 2A 78 00 04 0037*      ld hl,(@buffer+1)
040076 C9          0038*      ret
040077 00 00 00 00 0039*  @buffer: blkb 4,0
04007B             0040*  
04007B             0041*  ; hlu 1 byte right shift, unsigned
04007B             0042*  ; returns: hlu / 256
04007B             0043*  hlu_udiv256:
04007B 22 84 00 04 0044*  	ld (@buffer),hl
04007F 2A 85 00 04 0045*  	ld hl,(@buffer+1)
040083 C9          0046*  	ret
040084 00 00 00 00 0047*  @buffer: blkb 4,0
040088             0048*  
040088             0049*  ; absolute value of hlu
040088             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040088             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040088             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040088             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040088             0054*  ; destroys: a
040088             0055*  hlu_abs:
040088 19          0056*      add hl,de
040089 B7          0057*      or a
04008A ED 52       0058*      sbc hl,de
04008C FA 91 00 04 0059*      jp m,@is_neg
040090 C9          0060*      ret         ; hlu is positive or zero so we're done
040091             0061*  @is_neg:
040091 F5          0062*      push af     ; otherwise, save current flags for return
040092 CD 98 00 04 0063*      call neg_hlu ; negate hlu
040096 F1          0064*      pop af      ; get back flags
040097 C9          0065*      ret
040098             0066*  
040098             0067*  ; flip the sign of hlu
040098             0068*  ; inputs: hlu
040098             0069*  ; returns: 0-hlu, flags set appropriately for the result:
040098             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
040098             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
040098             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
040098             0073*  ; destroys a
040098             0074*  neg_hlu:
040098 D5          0075*      push de     ; save de
040099 EB          0076*      ex de,hl    ; put hl into de
04009A 21 00 00 00 0077*      ld hl,0     ; clear hl
04009E AF          0078*      xor a       ; clear carry
04009F ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0400A1 D1          0080*      pop de      ; get de back
0400A2 C9          0081*      ret         ; easy peasy
0400A3             0082*  
0400A3             0083*      ; include "fixed24.inc"
0400A3             0084*  
0400A3             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0400A3             0086*  ; uses EZ80 MLT instruction for speed
0400A3             0087*  ; operation: UHL * A --> UHL
0400A3             0088*  ; destroys: AF, HL
0400A3             0089*  smul24x8:
0400A3             0090*  ; make hl positive and store sign flag
0400A3 CD 88 00 04 0091*  	call hlu_abs
0400A7 F5          0092*  	push af
0400A8             0093*  ; do the division
0400A8 CD B3 00 04 0094*      call mul24x8 ; hl = product
0400AC             0095*  ; adjust sign of result
0400AC F1          0096*  	pop af ; sign de
0400AD F0          0097*  	ret p ; hl was positive, nothing to do
0400AE CD 98 00 04 0098*  	call neg_hlu ; result is negative
0400B2 C9          0099*  	ret
0400B3             0100*  
0400B3             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0400B3             0102*  ; uses EZ80 MLT instruction for speed
0400B3             0103*  ; operation: UHL * A --> AUHL
0400B3             0104*  ; destroys: AF, HL
0400B3             0105*  mul24x8:
0400B3 D5          0106*  	push de ; preserve de
0400B4             0107*  ; low byte
0400B4 5D          0108*  	ld e,l
0400B5 57          0109*  	ld d,a
0400B6 ED 5C       0110*  	mlt de
0400B8 6B          0111*  	ld l,e ; product low byte
0400B9 08          0112*  	ex af,af' ; save multiplier
0400BA 7A          0113*  	ld a,d ; carry
0400BB 08          0114*  	ex af,af' ; save carry, restore multiplier
0400BC             0115*  ; high byte
0400BC 5C          0116*  	ld e,h
0400BD 57          0117*  	ld d,a
0400BE ED 5C       0118*  	mlt de
0400C0 08          0119*  	ex af,af' ; save multiplier, restore carry
0400C1 83          0120*  	add a,e ; add carry
0400C2 67          0121*  	ld h,a ; product middle byte
0400C3 7A          0122*  	ld a,d ; carry
0400C4 08          0123*  	ex af,af' ; save carry, restore multiplier
0400C5             0124*  ; upper byte
0400C5 22 E0 00 04 0125*      ld (@scratch),hl ; 7 cycles
0400C9 5F          0126*  	ld e,a
0400CA 3A E2 00 04 0127*  	ld a,(@scratch+2)
0400CE 57          0128*  	ld d,a
0400CF ED 5C       0129*  	mlt de
0400D1 08          0130*  	ex af,af' ; restore carry
0400D2 8B          0131*  	adc a,e ; add carry
0400D3 32 E2 00 04 0132*      ld (@scratch+2),a ; 5 cycles
0400D7 2A E0 00 04 0133*      ld hl,(@scratch) ; 7 cycles
0400DB             0134*  ; highest byte
0400DB 3E 00       0135*  	ld a,0 ; preserve carry flag
0400DD 8A          0136*  	adc a,d ; product highest byte
0400DE D1          0137*  	pop de ; restore de
0400DF C9          0138*  	ret
0400E0             0139*  @scratch: ds 3
0400E3             0140*  
0400E3 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0400E9             0142*  
0400E9             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0400E9             0144*  ; operation: UHL * UDE --> mul24out
0400E9             0145*  mul24:
0400E9 DD E5       0146*  	push ix ; preserve
0400EB             0147*  ; point to output buffer and clear it
0400EB DD 21 E3 00 0148*  	ld ix,mul24out
       04          
0400F0 C5          0149*  	push bc
0400F1 01 00 00 00 0150*  	ld bc,0
0400F5 DD 0F 00    0151*  	ld (ix),bc
0400F8 DD 0F 03    0152*  	ld (ix+3),bc
0400FB C1          0153*  	pop bc
0400FC             0154*  ; STEP 1: UHL * E
0400FC 7B          0155*  	ld a,e
0400FD E5          0156*  	push hl
0400FE CD B3 00 04 0157*  	call mul24x8
040102 DD 2F 00    0158*  	ld (ix+0),hl
040105 DD 77 03    0159*  	ld (ix+3),a
040108             0160*  ; STEP 2: UHL * D
040108 E1          0161*  	pop hl
040109 E5          0162*  	push hl
04010A 7A          0163*  	ld a,d
04010B CD B3 00 04 0164*  	call mul24x8
04010F CD 28 01 04 0165*  	call @accumulate
040113             0166*  ; STEP 3: UHL * DEU
040113 E1          0167*  	pop hl
040114 ED 53 58 01 0168*  	ld (@de),de
       04          
040119 3A 5A 01 04 0169*  	ld a,(@de+2)
04011D CD B3 00 04 0170*  	call mul24x8
040121 CD 28 01 04 0171*  	call @accumulate
040125             0172*  ; all done
040125 DD E1       0173*  	pop ix ; restore
040127 C9          0174*  	ret
040128             0175*  @accumulate:
040128 DD 23       0176*  	inc ix
04012A             0177*  ; highest byte of product to carry
04012A DD 77 03    0178*  	ld (ix+3),a
04012D             0179*  ; low byte of product
04012D 7D          0180*  	ld a,l
04012E DD 86 00    0181*  	add a,(ix+0)
040131 DD 77 00    0182*  	ld (ix+0),a
040134             0183*  ; high byte of product
040134 7C          0184*  	ld a,h
040135 DD 8E 01    0185*  	adc a,(ix+1)
040138 DD 77 01    0186*  	ld (ix+1),a
04013B             0187*  ; uppper byte of product
04013B 22 55 01 04 0188*  	ld (@hl),hl
04013F 3A 57 01 04 0189*  	ld a,(@hl+2)
040143 DD 8E 02    0190*  	adc a,(ix+2)
040146 DD 77 02    0191*  	ld (ix+2),a
040149             0192*  ; carry
040149 3E 00       0193*  	ld a,0 ; preserve flags
04014B DD 8E 03    0194*  	adc a,(ix+3)
04014E DD 77 03    0195*  	ld (ix+3),a
040151 C9          0196*  	ret
040152             0197*  
040152 00 00 00    0198*  @ix: dl 0
040155 00 00 00    0199*  @hl: dl 0
040158 00 00 00    0200*  @de: dl 0
04015B             0201*  
04015B             0202*  ; UHL * UDE --> UHL (unsigned)
04015B             0203*  umul24:
04015B CD E9 00 04 0204*  	call mul24
04015F 2A E3 00 04 0205*  	ld hl,(mul24out)
040163 C9          0206*  	ret
040164             0207*  
040164             0208*  ; UH.L = UH.L*UD.E (unsigned)
040164             0209*  umul168:
040164 CD E9 00 04 0210*  	call mul24
040168 2A E4 00 04 0211*  	ld hl,(mul24out+1)
04016C C9          0212*  	ret
04016D             0213*  
04016D             0214*  ; UH.L * UD.E --> UH.L (signed)
04016D             0215*  smul168:
04016D             0216*  ; make everything positive and store sign flags
04016D CD 88 00 04 0217*  	call hlu_abs
040171 F5          0218*  	push af
040172 EB          0219*  	ex de,hl
040173 CD 88 00 04 0220*  	call hlu_abs
040177 EB          0221*  	ex de,hl
040178 F5          0222*  	push af
040179             0223*  ; do the division
040179 CD 64 01 04 0224*      call umul168 ; hl = product
04017D             0225*  ; adjust sign of result
04017D F1          0226*  	pop af ; sign de
04017E FA 89 01 04 0227*  	jp m,@de_neg
040182 F1          0228*  	pop af ; sign hl
040183 F0          0229*  	ret p ; both positive, nothing to do
040184             0230*  @hl_neg:
040184 CD 98 00 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
040188 C9          0232*      ret
040189             0233*  @de_neg:
040189 F1          0234*  	pop af
04018A F8          0235*  	ret m ; both negative, nothing to do
04018B CD 98 00 04 0236*  	call neg_hlu ; result is negative
04018F C9          0237*  	ret
040190             0238*  
040190             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040190             0240*  ; perform unsigned division of 16.8 fixed place values
040190             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040190             0242*  udiv168:
040190             0243*  ; back up divisor
040190 ED 53 C7 01 0244*  	ld (@ude),de
       04          
040195             0245*  ; get the 16-bit integer part of the quotient
040195 CD F8 01 04 0246*      call udiv24 ; de = quotient, hl = remainder
040199             0247*  ; load quotient to upper three bytes of output
040199 ED 53 CE 01 0248*      ld (div168_out+1),de
       04          
04019E             0249*  @div256:
04019E             0250*  ; multiply remainder by 256
04019E             0251*  	hlu_mul256
04019E 29          0001*M         add hl,hl ; * 2
04019F 29          0002*M         add hl,hl ; * 4
0401A0 29          0003*M         add hl,hl ; * 8
0401A1 29          0004*M         add hl,hl ; * 16
0401A2 29          0005*M         add hl,hl ; * 32
0401A3 29          0006*M         add hl,hl ; * 64
0401A4 29          0007*M         add hl,hl ; * 128
0401A5 29          0008*M         add hl,hl ; * 256
0401A6             0252*  ; skip fractional computation if remainder is zero
0401A6             0253*      sign_hlu
0401A6 19          0001*M         add hl,de
0401A7 B7          0002*M         or a
0401A8 ED 52       0003*M         sbc hl,de
0401AA 20 03       0254*      jr nz,@div_frac
0401AC AF          0255*      xor a
0401AD 18 0A       0256*      jr @write_frac
0401AF             0257*  ; now divide the shifted remainder by the divisor
0401AF             0258*  @div_frac:
0401AF ED 5B C7 01 0259*  	ld de,(@ude) ; get back divisor
       04          
0401B4 CD F8 01 04 0260*      call udiv24 ; de = quotient, hl = remainder
0401B8             0261*  ; load low byte of quotient to low byte of output
0401B8 7B          0262*      ld a,e
0401B9             0263*  @write_frac:
0401B9 32 CD 01 04 0264*      ld (div168_out),a
0401BD             0265*  ; load de with return value
0401BD ED 5B CD 01 0266*      ld de,(div168_out)
       04          
0401C2             0267*  ; load a with any overflow
0401C2 3A D0 01 04 0268*      ld a,(div168_out+3)
0401C6 C9          0269*      ret ; ud.e is the 16.8 result
0401C7             0270*  @ude: ds 6
0401CD             0271*  div168_out: ds 4 ; the extra byte is for overflow
0401D1             0272*  
0401D1             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0401D1             0274*  ; perform signed division of 16.8 fixed place values
0401D1             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0401D1             0276*  sdiv168:
0401D1             0277*  ; make everything positive and store sign flags
0401D1 CD 88 00 04 0278*  	call hlu_abs
0401D5 F5          0279*  	push af
0401D6 EB          0280*  	ex de,hl
0401D7 CD 88 00 04 0281*  	call hlu_abs
0401DB EB          0282*  	ex de,hl
0401DC F5          0283*  	push af
0401DD             0284*  ; do the division
0401DD CD 90 01 04 0285*      call udiv168 ; de = quotient, hl = remainder
0401E1             0286*  ; adjust sign of result
0401E1 F1          0287*  	pop af ; sign de
0401E2 FA EF 01 04 0288*  	jp m,@de_neg
0401E6 F1          0289*  	pop af ; sign hl
0401E7 F0          0290*  	ret p ; both positive, nothing to do
0401E8             0291*  @hl_neg:
0401E8 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0401E9 CD 98 00 04 0293*      call neg_hlu ; de pos, hl neg, result is negative
0401ED EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0401EE C9          0295*      ret
0401EF             0296*  @de_neg:
0401EF F1          0297*  	pop af
0401F0 F8          0298*  	ret m ; both negative, nothing to do
0401F1 EB          0299*      ex de,hl ; hl = quotient, de = remainder
0401F2 CD 98 00 04 0300*  	call neg_hlu ; result is negative
0401F6 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0401F7 C9          0302*  	ret
0401F8             0303*  
0401F8             0304*  ;------------------------------------------------------------------------
0401F8             0305*  ;  arith24.asm
0401F8             0306*  ;  24-bit ez80 arithmetic routines
0401F8             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0401F8             0308*  ;  MIT license
0401F8             0309*  ;
0401F8             0310*  ;  This library was created as a tool to help make ez80
0401F8             0311*  ;  24-bit native assembly routines for simple mathematical problems
0401F8             0312*  ;  more widely available.
0401F8             0313*  ;
0401F8             0314*  ;------------------------------------------------------------------------
0401F8             0315*  ;
0401F8             0316*  ;------------------------------------------------------------------------
0401F8             0317*  ; udiv24
0401F8             0318*  ; Unsigned 24-bit division
0401F8             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0401F8             0320*  ;
0401F8             0321*  ; Uses AF BC DE HL
0401F8             0322*  ; Uses Restoring Division algorithm
0401F8             0323*  ;------------------------------------------------------------------------
0401F8             0324*  
0401F8             0325*  udiv24:
0401F8 E5          0326*  	push	hl
0401F9 C1          0327*  	pop		bc	;move dividend to BCU
0401FA 21 00 00 00 0328*  	ld		hl,0	;result
0401FE A7          0329*  	and		a
0401FF ED 52       0330*  	sbc		hl,de	;test for div by 0
040201 C8          0331*  	ret		z		;it's zero, carry flag is clear
040202 19          0332*  	add		hl,de	;HL is 0 again
040203 3E 18       0333*  	ld		a,24	;number of loops through.
040205             0334*  udiv1:
040205 C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
040206 E3          0336*  	ex		(sp),hl
040207 37          0337*  	scf
040208 ED 6A       0338*  	adc	hl,hl
04020A E3          0339*  	ex	(sp),hl
04020B C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
04020C             0341*  
04020C ED 6A       0342*  	adc	hl,hl
04020E A7          0343*  	and	a		;is this the bug
04020F ED 52       0344*  	sbc	hl,de
040211 30 02       0345*  	jr	nc,udiv2
040213 19          0346*  	add	hl,de
040214             0347*  ;	dec	c
040214 0B          0348*  	dec	bc
040215             0349*  udiv2:
040215 3D          0350*  	dec	a
040216 20 ED       0351*  	jr	nz,udiv1
040218 37          0352*  	scf		;flag used for div0 error
040219 C5          0353*  	push	bc
04021A D1          0354*  	pop		de	;remainder
04021B C9          0355*  	ret
04021C             0356*  
04021C             0357*  ;------------------------------------------------------------------------
04021C             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
04021C             0359*  ;------------------------------------------------------------------------
04021C             0360*  
04021C             0361*  
04021C             0362*      ; include "trig24fast.inc"
04021C             0363*  
04021C             0364*  
04021C             0365*  ; convert signed angles from a 360 to 256 degree circle
04021C             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
04021C             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
04021C             0368*  ; destroys: TODO
04021C             0369*  deg_360_to_256:
04021C D5          0370*  	push de ; preserve de
04021D             0371*  ; make angle positive and store sign flag
04021D CD 88 00 04 0372*  	call hlu_abs
040221 F5          0373*  	push af
040222             0374*  ; multiply by coversion factor of 256/360
040222 11 B6 00 00 0375*  	ld de,0x0000B6 ; 0.711
040226 CD 64 01 04 0376*  	call umul168 ; uh.l = uh.l * 0.711
04022A             0377*  ; restore sign flag and adjust output accordingly
04022A F1          0378*  	pop af
04022B F2 33 02 04 0379*  	jp p,@pos ; positive number
04022F CD 98 00 04 0380*  	call neg_hlu
040233             0381*  @pos:
040233             0382*  ; restore de and return uh.l as the result
040233 D1          0383*  	pop de
040234 C9          0384*  	ret
040235             0385*  
040235             0386*  ; convert signed angles from a 256 to 360 degree circle
040235             0387*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040235             0388*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040235             0389*  ; destroys: TODO
040235             0390*  deg_256_to_360:
040235 D5          0391*  	push de ; preserve de
040236             0392*  ; make angle positive and store sign flag
040236 CD 88 00 04 0393*  	call hlu_abs
04023A F5          0394*  	push af
04023B             0395*  ; multiply by coversion factor of 360/256
04023B 11 68 01 00 0396*      ld de,0x000168 ; 1.406
04023F CD 64 01 04 0397*  	call umul168 ; uh.l = uh.l * 1.406
040243             0398*  ; restore sign flag and adjust output accordingly
040243 F1          0399*  	pop af
040244 F2 4C 02 04 0400*  	jp p,@pos ; positive number
040248 CD 98 00 04 0401*  	call neg_hlu
04024C             0402*  @pos:
04024C             0403*  ; restore de and return uh.l as the result
04024C D1          0404*  	pop de
04024D C9          0405*  	ret
04024E             0406*  
04024E             0407*  ; fixed 16.8 routine
04024E             0408*  ; cos(uh.l) --> uh.l
04024E             0409*  ; destroys: f, hl
04024E             0410*  cos168:
04024E D5          0411*      push de ; preserve de
04024F             0412*  ; for cos we simply increment the angle by 90 degrees
04024F             0413*  ; or 0x004000 in 16.8 degrees256
04024F             0414*  ; which makes it a sin problem
04024F 11 00 40 00 0415*      ld de,0x004000
040253 19          0416*      add hl,de ; modulo 256 happens below
040254 D1          0417*      pop de ; restore de
040255             0418*  ; fall through to sin168
040255             0419*  
040255             0420*  ; ---------------------
040255             0421*  ; fixed 16.8 routine
040255             0422*  ; sin(uh.l) --> uh.l
040255             0423*  ; destroys: f, hl
040255             0424*  sin168:
040255 D5          0425*  	push de
040256             0426*  ; handle negative angles appropriately
040256 CD 88 00 04 0427*  	call hlu_abs
04025A F2 63 02 04 0428*  	jp p,@F
04025E 11 00 00 FF 0429*  	ld de,-256*256
040262 19          0430*  	add hl,de
040263             0431*  @@:
040263 2E 03       0432*  	ld l,3 ; multiply by 3 to get our lookup index
040265 ED 6C       0433*      mlt hl
040267 11 B3 04 04 0434*      ld de,sin_lut_168 ; grab the lut address
04026B 19          0435*      add hl,de ; bump hl by the index
04026C ED 27       0436*      ld hl,(hl) ; don't try this on a z80!
04026E D1          0437*      pop de
04026F C9          0438*      ret
040270             0439*  
040270             0440*  ; 16.8 fixed inputs / outputs
040270             0441*  ; takes: uh.l as angle in degrees 256
040270             0442*  ;        ud.e as radius
040270             0443*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040270             0444*  ;        displacements from origin (0,0)
040270             0445*  ; destroys: everything except indexes
040270             0446*  polar_to_cartesian:
040270             0447*  ; back up input parameters
040270 22 9F 02 04 0448*      ld (@angle), hl
040274 ED 53 A2 02 0449*      ld (@radius), de
       04          
040279             0450*  ; compute dx = sin(uh.l) * ud.e
040279 CD 55 02 04 0451*      call sin168 ; uh.l = sin(uh.l)
04027D ED 5B A2 02 0452*  	ld de,(@radius)
       04          
040282 CD 6D 01 04 0453*  	call smul168 ; uh.l = dx
040286 E5          0454*      push hl
040287             0455*  ; compute dy = -cos(uh.l) * ud.e
040287 2A 9F 02 04 0456*      ld hl,(@angle)
04028B CD 4E 02 04 0457*      call cos168 ; uh.l = cos(uh.l)
04028F ED 5B A2 02 0458*      ld de,(@radius)
       04          
040294 CD 6D 01 04 0459*      call smul168    ; uh.l = dy
040298 CD 98 00 04 0460*      call neg_hlu ; invert dy for screen coords convention
04029C EB          0461*      ex de,hl       ; de = dy for output
04029D C1          0462*      pop bc          ; bc = dx for output
04029E             0463*  ; and out
04029E C9          0464*      ret
04029F             0465*  @angle: ds 3
0402A2             0466*  @radius: ds 3
0402A5             0467*  
0402A5             0468*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0402A5             0469*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0402A5             0470*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0402A5             0471*  ;         also populates scratch locations dx168 and dy168
0402A5             0472*  ; destroys: a,hl,bc,de
0402A5             0473*  dxy168:
0402A5             0474*  ; compute dx = x1-x0
0402A5 AF          0475*      xor a ; clear carry
0402A6 DD E5       0476*      push ix ; move ix to hl via the stack
0402A8 E1          0477*      pop hl ; hl = x1
0402A9 ED 42       0478*      sbc hl,bc ; hl = dx
0402AB 22 C0 02 04 0479*      ld (dx168),hl ; dx to scratch
0402AF             0480*  ; compute dy = y1-y0
0402AF AF          0481*      xor a ; clear carry
0402B0 FD E5       0482*      push iy ; move iy to hl via the stack
0402B2 E1          0483*      pop hl ; hl = y1
0402B3 ED 52       0484*      sbc hl,de ; hl = dy
0402B5 22 C6 02 04 0485*      ld (dy168),hl ; dy to scratch
0402B9             0486*  ; populate output registers and return
0402B9 EB          0487*      ex de,hl        ; ud.e = dy
0402BA ED 4B C0 02 0488*      ld bc,(dx168)   ; ub.c = dx
       04          
0402BF C9          0489*      ret
0402C0 00 00 00 00 0490*  dx168: blkb 6,0
       00 00       
0402C6 00 00 00 00 0491*  dy168: blkb 6,0
       00 00       
0402CC             0492*  
0402CC             0493*  ; compute the euclidian distance between two cartesian coordinates
0402CC             0494*  ; using the formula d = sqrt(dx^2+dy^2)
0402CC             0495*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0402CC             0496*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0402CC             0497*  ; output; uh.l is the 16.8 fixed format distance
0402CC             0498*  ;         also populates scratch locations dx168 and dy168
0402CC             0499*  ; destroys: a,hl,bc,de
0402CC             0500*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0402CC             0501*  ;       thus the result will always be an integer, albeit in 16.8 format
0402CC             0502*  distance168:
0402CC CD A5 02 04 0503*  	call dxy168 ; ub.c = dx, ud.e = dy
0402D0             0504*  ; compute dy^2
0402D0 EB          0505*  	ex de,hl
0402D1 CD 88 00 04 0506*  	call hlu_abs
0402D5 CD 7B 00 04 0507*  	call hlu_udiv256 ; make integer to avoid overflow
0402D9 E5          0508*  	push hl
0402DA D1          0509*  	pop de
0402DB CD 5B 01 04 0510*  	call umul24 ; hl = dy^2
0402DF E5          0511*  	push hl ; save dy^2
0402E0             0512*  ; compute dx^2
0402E0 2A C0 02 04 0513*  	ld hl,(dx168)
0402E4 CD 88 00 04 0514*  	call hlu_abs
0402E8 CD 7B 00 04 0515*  	call hlu_udiv256 ; make integer to avoid overflow
0402EC E5          0516*  	push hl
0402ED D1          0517*  	pop de
0402EE CD 5B 01 04 0518*  	call umul24 ; hl = dx^2
0402F2             0519*  ; add dx^2 and dy^2
0402F2 D1          0520*  	pop de ; de = dy^2 (was hl)
0402F3 19          0521*  	add hl,de ; hl = dx^2 + dy^2
0402F4             0522*  ; compute the square root
0402F4 CD CD 03 04 0523*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0402F8 EB          0524*      ex de,hl ; hl = distance
0402F9             0525*      hlu_mul256 ; convert back to 16.8 fixed
0402F9 29          0001*M         add hl,hl ; * 2
0402FA 29          0002*M         add hl,hl ; * 4
0402FB 29          0003*M         add hl,hl ; * 8
0402FC 29          0004*M         add hl,hl ; * 16
0402FD 29          0005*M         add hl,hl ; * 32
0402FE 29          0006*M         add hl,hl ; * 64
0402FF 29          0007*M         add hl,hl ; * 128
040300 29          0008*M         add hl,hl ; * 256
040301 C9          0526*  	ret
040302             0527*  
040302             0528*  ; atan2_(ub.c,ud.e) --> uh.l
040302             0529*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040302             0530*  ;   whether inputs are integers or fractional doesn't matter
040302             0531*  ;   so long as the sign bit of the upper byte is correct
040302             0532*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040302             0533*  ; angles are COMPASS HEADINGS based on
040302             0534*  ; screen coordinate conventions,where the y axis is flipped
040302             0535*  ; #E0 224      0       32 #20
040302             0536*  ;        -x,-y | +x,-y
040302             0537*  ; #C0 192------+------ 64 #40
040302             0538*  ;        -x,+y | +x,+y
040302             0539*  ; #A0 160   128 #80   96 #60
040302             0540*  atan2_168fast:
040302             0541*  ; get signs and make everything positive
040302             0542*  ; get abs(x) and store its original sign
040302 C5          0543*      push bc
040303 E1          0544*      pop hl
040304 CD 88 00 04 0545*      call hlu_abs ; if x was negative this also sets the sign flag
040308 E5          0546*      push hl ; store abs(x)
040309 C1          0547*      pop bc ; bc = abs(x)
04030A F5          0548*      push af ; store sign of x
04030B             0549*  ; get abs(y) and store its original sign
04030B EB          0550*      ex de,hl ; hl = y
04030C CD 88 00 04 0551*      call hlu_abs ; if y was negative this also sets the sign flag
040310 EB          0552*      ex de,hl ; de = abs(y)
040311 F5          0553*      push af ; store sign of y
040312             0554*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040312             0555*  ; this ensures that our lookup value is between 0 and 1 inclusive
040312 AF          0556*      xor a ; clear the carry flag
040313 D5          0557*      push de
040314 E1          0558*      pop hl
040315 ED 42       0559*      sbc hl,bc
040317 F5          0560*      push af ; save sign of de - bc
040318 F2 21 03 04 0561*      jp p,@1 ; bc <= de, so we skip ahead
04031C             0562*  ; otherwise we swap bc and de
04031C C5          0563*      push bc
04031D E1          0564*      pop hl
04031E EB          0565*      ex de,hl
04031F E5          0566*      push hl
040320 C1          0567*      pop bc
040321             0568*  @1:
040321             0569*  ; now we're ready to snag our preliminary result
040321 C5          0570*      push bc
040322 E1          0571*      pop hl
040323 CD 91 03 04 0572*      call atan_168fast ; uh.l comes back with prelim result
040327             0573*  ; now we adjust uh.l based on sign of de - bc
040327 F1          0574*      pop af
040328 F2 34 03 04 0575*      jp p,@2 ; bc <= de,so we skip ahead
04032C EB          0576*      ex de,hl
04032D 21 00 40 00 0577*      ld hl,64*256 ; subtract from 64 (90) degrees
040331 AF          0578*      xor a ; clear the carry flag
040332 ED 52       0579*      sbc hl,de
040334             0580*  @2:
040334             0581*  ; adjust the result based on quadrant
040334             0582*  ; #E0 224      0       32 #20
040334             0583*  ;        -x,-y | +x,-y
040334             0584*  ; #C0 192------+------ 64 #40
040334             0585*  ;        -x,+y | +x,+y
040334             0586*  ; #A0 160   128 #80   96 #60
040334 F1          0587*      pop af ; sign of y
040335 CA 72 03 04 0588*      jp z,@y_zero
040339 F2 52 03 04 0589*      jp p,@y_pos
04033D             0590*  ; y neg,check x
04033D F1          0591*      pop af ; sign of x
04033E CA 4C 03 04 0592*      jp z,@y_neg_x_zero
040342 F2 51 03 04 0593*      jp p,@y_neg_x_pos
040346             0594*  ; y neg,x neg
040346             0595*  ; angle is 128 to 256 (270 to 360)
040346             0596*  ; negating the intermediate does the trick
040346 CD 98 00 04 0597*      call neg_hlu
04034A 18 31       0598*      jr @zero_hlu
04034C             0599*  
04034C             0600*  @y_neg_x_zero:
04034C             0601*  ; y neg,x zero
04034C             0602*  ; angle is 0
04034C 21 00 00 00 0603*      ld hl,0
040350 C9          0604*      ret
040351             0605*  @y_neg_x_pos:
040351             0606*  ; y neg,x pos
040351             0607*  ; angle is 0 to 64 (0 to 90)
040351             0608*  ; so we're good
040351 C9          0609*      ret
040352             0610*  
040352             0611*  @y_pos:
040352 F1          0612*      pop af ; sign of x
040353 CA 62 03 04 0613*      jp z,@y_pos_x_zero
040357 F2 67 03 04 0614*      jp p,@y_pos_x_pos
04035B             0615*  ; y pos,x neg
04035B             0616*  ; angle is 128 to 192 (180-270)
04035B             0617*  ; so we add 128 to intermediate
04035B 11 00 80 00 0618*      ld de,128*256
04035F 19          0619*      add hl,de
040360 18 1B       0620*      jr @zero_hlu
040362             0621*  @y_pos_x_zero:
040362             0622*  ; y pos,x zero
040362             0623*  ; angle is 128 (180)
040362 21 00 80 00 0624*      ld hl,128*256
040366 C9          0625*      ret
040367             0626*  @y_pos_x_pos:
040367             0627*  ; y pos,x pos
040367             0628*  ; angle is 64 to 128 (90 to 180)
040367             0629*  ; neg the intermediate and add 180 degrees
040367 CD 98 00 04 0630*      call neg_hlu
04036B 11 00 80 00 0631*      ld de,128*256
04036F 19          0632*      add hl,de
040370 18 0B       0633*      jr @zero_hlu
040372             0634*  
040372             0635*  @y_zero:
040372 F1          0636*      pop af ; sign of x
040373 FA 78 03 04 0637*      jp m,@y_zero_x_neg
040377             0638*  ; y zero,x pos
040377             0639*  ; angle is 64 (90),nothing to do
040377 C9          0640*      ret
040378             0641*  @y_zero_x_neg:
040378             0642*  ; y zero ,x neg
040378             0643*  ; angle is 192 (270)
040378 21 00 C0 00 0644*      ld hl,192*256
04037C C9          0645*      ret
04037D             0646*  @zero_hlu:
04037D AF          0647*      xor a
04037E 22 8B 03 04 0648*      ld (@scratch),hl
040382 32 8D 03 04 0649*      ld (@scratch+2),a
040386 2A 8B 03 04 0650*      ld hl,(@scratch)
04038A C9          0651*      ret
04038B             0652*  @scratch: ds 6
040391             0653*  
040391             0654*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040391             0655*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040391             0656*  ; destroys: a,hl,bc,de
040391             0657*  ; note: only works for angles from 0 to 32 (45) degrees
040391             0658*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040391             0659*  atan_168fast:
040391             0660*  ; because we use compass headings instead of geometric angles
040391             0661*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040391             0662*  ; we can do faster unsigned division here because we know dx and dy are positive
040391 CD 90 01 04 0663*      call udiv168 ; ud.e = dx/dy
040395 EB          0664*      ex de,hl ; uh.l = dx/dy
040396             0665*  ; test uh.l for 0
040396 19          0666*      add hl,de
040397 B7          0667*      or a
040398 ED 52       0668*      sbc hl,de
04039A 28 22       0669*      jr z,@is_zero
04039C             0670*  ; test uh.l for 1
04039C AF          0671*      xor a ; clear carry
04039D EB          0672*      ex de,hl
04039E 21 00 01 00 0673*      ld hl,1*256 ; 1 in 16.8 fixed format
0403A2 ED 52       0674*      sbc hl,de
0403A4 28 13       0675*      jr z,@is_45
0403A6 EB          0676*      ex de,hl
0403A7             0677*  ; no special cases so we move on
0403A7             0678*  ; l contains the fractional portion of tan(uh.l)
0403A7             0679*  ; we multiply it by three to get our lookup table index
0403A7 26 03       0680*      ld h,3
0403A9 ED 6C       0681*      mlt hl ; index into lut
0403AB 11 00 00 00 0682*      ld de,0 ; clear deu
0403AF 54          0683*      ld d,h ; copy hl to de
0403B0 5D          0684*      ld e,l ; de contains our index
0403B1 21 B6 07 04 0685*      ld hl,atan_lut_168 ; grab the lut address
0403B5 19          0686*      add hl,de ; bump hl by the index
0403B6 ED 27       0687*      ld hl,(hl) ; don't try this on a z80!
0403B8 C9          0688*      ret ; and out
0403B9             0689*  @is_45:
0403B9 21 00 40 00 0690*      ld hl,64*256
0403BD C9          0691*      ret
0403BE             0692*  ; for the case tan(0)
0403BE             0693*  @is_zero:
0403BE 21 00 00 00 0694*      ld hl,0*256
0403C2 C9          0695*      ret
0403C3             0696*  
0403C3             0697*  ; Expects  ADL mode
0403C3             0698*  ; Inputs:  UH.L
0403C3             0699*  ; Outputs: UH.L is the 16.8 square root
0403C3             0700*  ;          UDE is the integer difference inputHL-DE^2
0403C3             0701*  sqrt168:
0403C3 CD CD 03 04 0702*      call sqrt24
0403C7 EB          0703*      ex de,hl
0403C8 29          0704*      add hl,hl
0403C9 29          0705*      add hl,hl
0403CA 29          0706*      add hl,hl
0403CB 29          0707*      add hl,hl
0403CC C9          0708*      ret
0403CD             0709*  
0403CD             0710*  ; credit: xeda112358
0403CD             0711*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0403CD             0712*  sqrt24:
0403CD             0713*  ; Expects ADL mode
0403CD             0714*  ; Inputs: HL
0403CD             0715*  ; Outputs: DE is the integer square root
0403CD             0716*  ;  HL is the difference inputHL-DE^2
0403CD             0717*  ;  c flag reset
0403CD 01 00 00 00 0718*  	ld bc,0 ; clear bcu
0403D1 11 00 00 00 0719*  	ld de,0 ; clear deu
0403D5 AF          0720*      xor a
0403D6 45          0721*      ld b,l
0403D7 C5          0722*      push bc
0403D8 47          0723*      ld b,a
0403D9 6F          0724*      ld l,a
0403DA             0725*  ; Iteration 1
0403DA 29          0726*      add hl,hl
0403DB CB 11       0727*      rl c
0403DD 29          0728*      add hl,hl
0403DE CB 11       0729*      rl c
0403E0 91          0730*      sub c
0403E1 30 04       0731*      jr nc,$+6
0403E3 1C          0732*      inc e
0403E4 1C          0733*      inc e
0403E5 2F          0734*      cpl
0403E6 4F          0735*      ld c,a
0403E7             0736*  ; Iteration 2
0403E7 29          0737*      add hl,hl
0403E8 CB 11       0738*      rl c
0403EA 29          0739*      add hl,hl
0403EB CB 11       0740*      rl c
0403ED CB 13       0741*      rl e
0403EF 7B          0742*      ld a,e
0403F0 91          0743*      sub c
0403F1 30 04       0744*      jr nc,$+6
0403F3 1C          0745*      inc e
0403F4 1C          0746*      inc e
0403F5 2F          0747*      cpl
0403F6 4F          0748*      ld c,a
0403F7             0749*  ; Iteration 3
0403F7 29          0750*      add hl,hl
0403F8 CB 11       0751*      rl c
0403FA 29          0752*      add hl,hl
0403FB CB 11       0753*      rl c
0403FD CB 13       0754*      rl e
0403FF 7B          0755*      ld a,e
040400 91          0756*      sub c
040401 30 04       0757*      jr nc,$+6
040403 1C          0758*      inc e
040404 1C          0759*      inc e
040405 2F          0760*      cpl
040406 4F          0761*      ld c,a
040407             0762*  ; Iteration 4
040407 29          0763*      add hl,hl
040408 CB 11       0764*      rl c
04040A 29          0765*      add hl,hl
04040B CB 11       0766*      rl c
04040D CB 13       0767*      rl e
04040F 7B          0768*      ld a,e
040410 91          0769*      sub c
040411 30 04       0770*      jr nc,$+6
040413 1C          0771*      inc e
040414 1C          0772*      inc e
040415 2F          0773*      cpl
040416 4F          0774*      ld c,a
040417             0775*  ; Iteration 5
040417 29          0776*      add hl,hl
040418 CB 11       0777*      rl c
04041A 29          0778*      add hl,hl
04041B CB 11       0779*      rl c
04041D CB 13       0780*      rl e
04041F 7B          0781*      ld a,e
040420 91          0782*      sub c
040421 30 04       0783*      jr nc,$+6
040423 1C          0784*      inc e
040424 1C          0785*      inc e
040425 2F          0786*      cpl
040426 4F          0787*      ld c,a
040427             0788*  ; Iteration 6
040427 29          0789*      add hl,hl
040428 CB 11       0790*      rl c
04042A 29          0791*      add hl,hl
04042B CB 11       0792*      rl c
04042D CB 13       0793*      rl e
04042F 7B          0794*      ld a,e
040430 91          0795*      sub c
040431 30 04       0796*      jr nc,$+6
040433 1C          0797*      inc e
040434 1C          0798*      inc e
040435 2F          0799*      cpl
040436 4F          0800*      ld c,a
040437             0801*  ; Iteration 7
040437 29          0802*      add hl,hl
040438 CB 11       0803*      rl c
04043A 29          0804*      add hl,hl
04043B CB 11       0805*      rl c
04043D CB 10       0806*      rl b
04043F EB          0807*      ex de,hl
040440 29          0808*      add hl,hl
040441 E5          0809*      push hl
040442 ED 42       0810*      sbc hl,bc
040444 30 06       0811*      jr nc,$+8
040446 7C          0812*      ld a,h
040447 2F          0813*      cpl
040448 47          0814*      ld b,a
040449 7D          0815*      ld a,l
04044A 2F          0816*      cpl
04044B 4F          0817*      ld c,a
04044C E1          0818*      pop hl
04044D 30 02       0819*      jr nc,$+4
04044F 23          0820*      inc hl
040450 23          0821*      inc hl
040451 EB          0822*      ex de,hl
040452             0823*  ; Iteration 8
040452 29          0824*      add hl,hl
040453 69          0825*      ld l,c
040454 60          0826*      ld h,b
040455 ED 6A       0827*      adc hl,hl
040457 ED 6A       0828*      adc hl,hl
040459 EB          0829*      ex de,hl
04045A 29          0830*      add hl,hl
04045B ED 52       0831*      sbc hl,de
04045D 19          0832*      add hl,de
04045E EB          0833*      ex de,hl
04045F 30 04       0834*      jr nc,$+6
040461 ED 52       0835*      sbc hl,de
040463 13          0836*      inc de
040464 13          0837*      inc de
040465             0838*  ; Iteration 9
040465 F1          0839*      pop af
040466 17          0840*      rla
040467 ED 6A       0841*      adc hl,hl
040469 17          0842*      rla
04046A ED 6A       0843*      adc hl,hl
04046C EB          0844*      ex de,hl
04046D 29          0845*      add hl,hl
04046E ED 52       0846*      sbc hl,de
040470 19          0847*      add hl,de
040471 EB          0848*      ex de,hl
040472 30 04       0849*      jr nc,$+6
040474 ED 52       0850*      sbc hl,de
040476 13          0851*      inc de
040477 13          0852*      inc de
040478             0853*  ; Iteration 10
040478 17          0854*      rla
040479 ED 6A       0855*      adc hl,hl
04047B 17          0856*      rla
04047C ED 6A       0857*      adc hl,hl
04047E EB          0858*      ex de,hl
04047F 29          0859*      add hl,hl
040480 ED 52       0860*      sbc hl,de
040482 19          0861*      add hl,de
040483 EB          0862*      ex de,hl
040484 30 04       0863*      jr nc,$+6
040486 ED 52       0864*      sbc hl,de
040488 13          0865*      inc de
040489 13          0866*      inc de
04048A             0867*  ; Iteration 11
04048A 17          0868*      rla
04048B ED 6A       0869*      adc hl,hl
04048D 17          0870*      rla
04048E ED 6A       0871*      adc hl,hl
040490 EB          0872*      ex de,hl
040491 29          0873*      add hl,hl
040492 ED 52       0874*      sbc hl,de
040494 19          0875*      add hl,de
040495 EB          0876*      ex de,hl
040496 30 04       0877*      jr nc,$+6
040498 ED 52       0878*      sbc hl,de
04049A 13          0879*      inc de
04049B 13          0880*      inc de
04049C             0881*  ; Iteration 12
04049C 17          0882*      rla
04049D ED 6A       0883*      adc hl,hl
04049F 17          0884*      rla
0404A0 ED 6A       0885*      adc hl,hl
0404A2 EB          0886*      ex de,hl
0404A3 29          0887*      add hl,hl
0404A4 ED 52       0888*      sbc hl,de
0404A6 19          0889*      add hl,de
0404A7 EB          0890*      ex de,hl
0404A8 30 04       0891*      jr nc,$+6
0404AA ED 52       0892*      sbc hl,de
0404AC 13          0893*      inc de
0404AD 13          0894*      inc de
0404AE CB 1A       0895*      rr d
0404B0 CB 1B       0896*      rr e
0404B2 C9          0897*      ret
0404B3             0898*  
0404B3             0899*  sin_lut_168:
0404B3 00 00 00    0900*  	dl 0x000000 ; 0.000 00, 0.000
0404B6 06 00 00    0901*  	dl 0x000006 ; 1.406 01, 0.025
0404B9 0C 00 00    0902*  	dl 0x00000C ; 2.813 02, 0.049
0404BC 12 00 00    0903*  	dl 0x000012 ; 4.219 03, 0.074
0404BF 19 00 00    0904*  	dl 0x000019 ; 5.625 04, 0.098
0404C2 1F 00 00    0905*  	dl 0x00001F ; 7.031 05, 0.122
0404C5 25 00 00    0906*  	dl 0x000025 ; 8.438 06, 0.147
0404C8 2B 00 00    0907*  	dl 0x00002B ; 9.844 07, 0.171
0404CB 31 00 00    0908*  	dl 0x000031 ; 11.250 08, 0.195
0404CE 38 00 00    0909*  	dl 0x000038 ; 12.656 09, 0.219
0404D1 3E 00 00    0910*  	dl 0x00003E ; 14.063 0A, 0.243
0404D4 44 00 00    0911*  	dl 0x000044 ; 15.469 0B, 0.267
0404D7 4A 00 00    0912*  	dl 0x00004A ; 16.875 0C, 0.290
0404DA 50 00 00    0913*  	dl 0x000050 ; 18.281 0D, 0.314
0404DD 56 00 00    0914*  	dl 0x000056 ; 19.688 0E, 0.337
0404E0 5C 00 00    0915*  	dl 0x00005C ; 21.094 0F, 0.360
0404E3 61 00 00    0916*  	dl 0x000061 ; 22.500 10, 0.383
0404E6 67 00 00    0917*  	dl 0x000067 ; 23.906 11, 0.405
0404E9 6D 00 00    0918*  	dl 0x00006D ; 25.313 12, 0.428
0404EC 73 00 00    0919*  	dl 0x000073 ; 26.719 13, 0.450
0404EF 78 00 00    0920*  	dl 0x000078 ; 28.125 14, 0.471
0404F2 7E 00 00    0921*  	dl 0x00007E ; 29.531 15, 0.493
0404F5 83 00 00    0922*  	dl 0x000083 ; 30.938 16, 0.514
0404F8 88 00 00    0923*  	dl 0x000088 ; 32.344 17, 0.535
0404FB 8E 00 00    0924*  	dl 0x00008E ; 33.750 18, 0.556
0404FE 93 00 00    0925*  	dl 0x000093 ; 35.156 19, 0.576
040501 98 00 00    0926*  	dl 0x000098 ; 36.563 1A, 0.596
040504 9D 00 00    0927*  	dl 0x00009D ; 37.969 1B, 0.615
040507 A2 00 00    0928*  	dl 0x0000A2 ; 39.375 1C, 0.634
04050A A7 00 00    0929*  	dl 0x0000A7 ; 40.781 1D, 0.653
04050D AB 00 00    0930*  	dl 0x0000AB ; 42.188 1E, 0.672
040510 B0 00 00    0931*  	dl 0x0000B0 ; 43.594 1F, 0.690
040513 B5 00 00    0932*  	dl 0x0000B5 ; 45.000 20, 0.707
040516 B9 00 00    0933*  	dl 0x0000B9 ; 46.406 21, 0.724
040519 BD 00 00    0934*  	dl 0x0000BD ; 47.813 22, 0.741
04051C C1 00 00    0935*  	dl 0x0000C1 ; 49.219 23, 0.757
04051F C5 00 00    0936*  	dl 0x0000C5 ; 50.625 24, 0.773
040522 C9 00 00    0937*  	dl 0x0000C9 ; 52.031 25, 0.788
040525 CD 00 00    0938*  	dl 0x0000CD ; 53.438 26, 0.803
040528 D1 00 00    0939*  	dl 0x0000D1 ; 54.844 27, 0.818
04052B D4 00 00    0940*  	dl 0x0000D4 ; 56.250 28, 0.831
04052E D8 00 00    0941*  	dl 0x0000D8 ; 57.656 29, 0.845
040531 DB 00 00    0942*  	dl 0x0000DB ; 59.063 2A, 0.858
040534 DE 00 00    0943*  	dl 0x0000DE ; 60.469 2B, 0.870
040537 E1 00 00    0944*  	dl 0x0000E1 ; 61.875 2C, 0.882
04053A E4 00 00    0945*  	dl 0x0000E4 ; 63.281 2D, 0.893
04053D E7 00 00    0946*  	dl 0x0000E7 ; 64.688 2E, 0.904
040540 EA 00 00    0947*  	dl 0x0000EA ; 66.094 2F, 0.914
040543 EC 00 00    0948*  	dl 0x0000EC ; 67.500 30, 0.924
040546 EE 00 00    0949*  	dl 0x0000EE ; 68.906 31, 0.933
040549 F1 00 00    0950*  	dl 0x0000F1 ; 70.313 32, 0.942
04054C F3 00 00    0951*  	dl 0x0000F3 ; 71.719 33, 0.950
04054F F4 00 00    0952*  	dl 0x0000F4 ; 73.125 34, 0.957
040552 F6 00 00    0953*  	dl 0x0000F6 ; 74.531 35, 0.964
040555 F8 00 00    0954*  	dl 0x0000F8 ; 75.938 36, 0.970
040558 F9 00 00    0955*  	dl 0x0000F9 ; 77.344 37, 0.976
04055B FB 00 00    0956*  	dl 0x0000FB ; 78.750 38, 0.981
04055E FC 00 00    0957*  	dl 0x0000FC ; 80.156 39, 0.985
040561 FD 00 00    0958*  	dl 0x0000FD ; 81.563 3A, 0.989
040564 FE 00 00    0959*  	dl 0x0000FE ; 82.969 3B, 0.992
040567 FE 00 00    0960*  	dl 0x0000FE ; 84.375 3C, 0.995
04056A FF 00 00    0961*  	dl 0x0000FF ; 85.781 3D, 0.997
04056D FF 00 00    0962*  	dl 0x0000FF ; 87.188 3E, 0.999
040570 FF 00 00    0963*  	dl 0x0000FF ; 88.594 3F, 1.000
040573 00 01 00    0964*  	dl 0x000100 ; 90.000 40, 1.000
040576 FF 00 00    0965*  	dl 0x0000FF ; 91.406 41, 1.000
040579 FF 00 00    0966*  	dl 0x0000FF ; 92.813 42, 0.999
04057C FF 00 00    0967*  	dl 0x0000FF ; 94.219 43, 0.997
04057F FE 00 00    0968*  	dl 0x0000FE ; 95.625 44, 0.995
040582 FE 00 00    0969*  	dl 0x0000FE ; 97.031 45, 0.992
040585 FD 00 00    0970*  	dl 0x0000FD ; 98.438 46, 0.989
040588 FC 00 00    0971*  	dl 0x0000FC ; 99.844 47, 0.985
04058B FB 00 00    0972*  	dl 0x0000FB ; 101.250 48, 0.981
04058E F9 00 00    0973*  	dl 0x0000F9 ; 102.656 49, 0.976
040591 F8 00 00    0974*  	dl 0x0000F8 ; 104.063 4A, 0.970
040594 F6 00 00    0975*  	dl 0x0000F6 ; 105.469 4B, 0.964
040597 F4 00 00    0976*  	dl 0x0000F4 ; 106.875 4C, 0.957
04059A F3 00 00    0977*  	dl 0x0000F3 ; 108.281 4D, 0.950
04059D F1 00 00    0978*  	dl 0x0000F1 ; 109.688 4E, 0.942
0405A0 EE 00 00    0979*  	dl 0x0000EE ; 111.094 4F, 0.933
0405A3 EC 00 00    0980*  	dl 0x0000EC ; 112.500 50, 0.924
0405A6 EA 00 00    0981*  	dl 0x0000EA ; 113.906 51, 0.914
0405A9 E7 00 00    0982*  	dl 0x0000E7 ; 115.313 52, 0.904
0405AC E4 00 00    0983*  	dl 0x0000E4 ; 116.719 53, 0.893
0405AF E1 00 00    0984*  	dl 0x0000E1 ; 118.125 54, 0.882
0405B2 DE 00 00    0985*  	dl 0x0000DE ; 119.531 55, 0.870
0405B5 DB 00 00    0986*  	dl 0x0000DB ; 120.938 56, 0.858
0405B8 D8 00 00    0987*  	dl 0x0000D8 ; 122.344 57, 0.845
0405BB D4 00 00    0988*  	dl 0x0000D4 ; 123.750 58, 0.831
0405BE D1 00 00    0989*  	dl 0x0000D1 ; 125.156 59, 0.818
0405C1 CD 00 00    0990*  	dl 0x0000CD ; 126.563 5A, 0.803
0405C4 C9 00 00    0991*  	dl 0x0000C9 ; 127.969 5B, 0.788
0405C7 C5 00 00    0992*  	dl 0x0000C5 ; 129.375 5C, 0.773
0405CA C1 00 00    0993*  	dl 0x0000C1 ; 130.781 5D, 0.757
0405CD BD 00 00    0994*  	dl 0x0000BD ; 132.188 5E, 0.741
0405D0 B9 00 00    0995*  	dl 0x0000B9 ; 133.594 5F, 0.724
0405D3 B5 00 00    0996*  	dl 0x0000B5 ; 135.000 60, 0.707
0405D6 B0 00 00    0997*  	dl 0x0000B0 ; 136.406 61, 0.690
0405D9 AB 00 00    0998*  	dl 0x0000AB ; 137.813 62, 0.672
0405DC A7 00 00    0999*  	dl 0x0000A7 ; 139.219 63, 0.653
0405DF A2 00 00    1000*  	dl 0x0000A2 ; 140.625 64, 0.634
0405E2 9D 00 00    1001*  	dl 0x00009D ; 142.031 65, 0.615
0405E5 98 00 00    1002*  	dl 0x000098 ; 143.438 66, 0.596
0405E8 93 00 00    1003*  	dl 0x000093 ; 144.844 67, 0.576
0405EB 8E 00 00    1004*  	dl 0x00008E ; 146.250 68, 0.556
0405EE 88 00 00    1005*  	dl 0x000088 ; 147.656 69, 0.535
0405F1 83 00 00    1006*  	dl 0x000083 ; 149.063 6A, 0.514
0405F4 7E 00 00    1007*  	dl 0x00007E ; 150.469 6B, 0.493
0405F7 78 00 00    1008*  	dl 0x000078 ; 151.875 6C, 0.471
0405FA 73 00 00    1009*  	dl 0x000073 ; 153.281 6D, 0.450
0405FD 6D 00 00    1010*  	dl 0x00006D ; 154.688 6E, 0.428
040600 67 00 00    1011*  	dl 0x000067 ; 156.094 6F, 0.405
040603 61 00 00    1012*  	dl 0x000061 ; 157.500 70, 0.383
040606 5C 00 00    1013*  	dl 0x00005C ; 158.906 71, 0.360
040609 56 00 00    1014*  	dl 0x000056 ; 160.313 72, 0.337
04060C 50 00 00    1015*  	dl 0x000050 ; 161.719 73, 0.314
04060F 4A 00 00    1016*  	dl 0x00004A ; 163.125 74, 0.290
040612 44 00 00    1017*  	dl 0x000044 ; 164.531 75, 0.267
040615 3E 00 00    1018*  	dl 0x00003E ; 165.938 76, 0.243
040618 38 00 00    1019*  	dl 0x000038 ; 167.344 77, 0.219
04061B 31 00 00    1020*  	dl 0x000031 ; 168.750 78, 0.195
04061E 2B 00 00    1021*  	dl 0x00002B ; 170.156 79, 0.171
040621 25 00 00    1022*  	dl 0x000025 ; 171.563 7A, 0.147
040624 1F 00 00    1023*  	dl 0x00001F ; 172.969 7B, 0.122
040627 19 00 00    1024*  	dl 0x000019 ; 174.375 7C, 0.098
04062A 12 00 00    1025*  	dl 0x000012 ; 175.781 7D, 0.074
04062D 0C 00 00    1026*  	dl 0x00000C ; 177.188 7E, 0.049
040630 06 00 00    1027*  	dl 0x000006 ; 178.594 7F, 0.025
040633 00 00 00    1028*  	dl 0x000000 ; 180.000 80, 0.000
040636 FA FF FF    1029*  	dl 0xFFFFFA ; 181.406 81, -0.025
040639 F4 FF FF    1030*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04063C EE FF FF    1031*  	dl 0xFFFFEE ; 184.219 83, -0.074
04063F E7 FF FF    1032*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040642 E1 FF FF    1033*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040645 DB FF FF    1034*  	dl 0xFFFFDB ; 188.438 86, -0.147
040648 D5 FF FF    1035*  	dl 0xFFFFD5 ; 189.844 87, -0.171
04064B CF FF FF    1036*  	dl 0xFFFFCF ; 191.250 88, -0.195
04064E C8 FF FF    1037*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040651 C2 FF FF    1038*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040654 BC FF FF    1039*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040657 B6 FF FF    1040*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
04065A B0 FF FF    1041*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04065D AA FF FF    1042*  	dl 0xFFFFAA ; 199.688 8E, -0.337
040660 A4 FF FF    1043*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040663 9F FF FF    1044*  	dl 0xFFFF9F ; 202.500 90, -0.383
040666 99 FF FF    1045*  	dl 0xFFFF99 ; 203.906 91, -0.405
040669 93 FF FF    1046*  	dl 0xFFFF93 ; 205.313 92, -0.428
04066C 8D FF FF    1047*  	dl 0xFFFF8D ; 206.719 93, -0.450
04066F 88 FF FF    1048*  	dl 0xFFFF88 ; 208.125 94, -0.471
040672 82 FF FF    1049*  	dl 0xFFFF82 ; 209.531 95, -0.493
040675 7D FF FF    1050*  	dl 0xFFFF7D ; 210.938 96, -0.514
040678 78 FF FF    1051*  	dl 0xFFFF78 ; 212.344 97, -0.535
04067B 72 FF FF    1052*  	dl 0xFFFF72 ; 213.750 98, -0.556
04067E 6D FF FF    1053*  	dl 0xFFFF6D ; 215.156 99, -0.576
040681 68 FF FF    1054*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040684 63 FF FF    1055*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040687 5E FF FF    1056*  	dl 0xFFFF5E ; 219.375 9C, -0.634
04068A 59 FF FF    1057*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04068D 55 FF FF    1058*  	dl 0xFFFF55 ; 222.188 9E, -0.672
040690 50 FF FF    1059*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040693 4B FF FF    1060*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040696 47 FF FF    1061*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040699 43 FF FF    1062*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04069C 3F FF FF    1063*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04069F 3B FF FF    1064*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0406A2 37 FF FF    1065*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0406A5 33 FF FF    1066*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0406A8 2F FF FF    1067*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0406AB 2C FF FF    1068*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0406AE 28 FF FF    1069*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0406B1 25 FF FF    1070*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0406B4 22 FF FF    1071*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0406B7 1F FF FF    1072*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0406BA 1C FF FF    1073*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0406BD 19 FF FF    1074*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0406C0 16 FF FF    1075*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0406C3 14 FF FF    1076*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0406C6 12 FF FF    1077*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0406C9 0F FF FF    1078*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0406CC 0D FF FF    1079*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0406CF 0C FF FF    1080*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0406D2 0A FF FF    1081*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0406D5 08 FF FF    1082*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0406D8 07 FF FF    1083*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0406DB 05 FF FF    1084*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0406DE 04 FF FF    1085*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0406E1 03 FF FF    1086*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0406E4 02 FF FF    1087*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0406E7 02 FF FF    1088*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0406EA 01 FF FF    1089*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0406ED 01 FF FF    1090*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0406F0 01 FF FF    1091*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0406F3 00 FF FF    1092*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0406F6 01 FF FF    1093*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0406F9 01 FF FF    1094*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0406FC 01 FF FF    1095*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0406FF 02 FF FF    1096*  	dl 0xFFFF02 ; 275.625 C4, -0.995
040702 02 FF FF    1097*  	dl 0xFFFF02 ; 277.031 C5, -0.992
040705 03 FF FF    1098*  	dl 0xFFFF03 ; 278.438 C6, -0.989
040708 04 FF FF    1099*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04070B 05 FF FF    1100*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04070E 07 FF FF    1101*  	dl 0xFFFF07 ; 282.656 C9, -0.976
040711 08 FF FF    1102*  	dl 0xFFFF08 ; 284.063 CA, -0.970
040714 0A FF FF    1103*  	dl 0xFFFF0A ; 285.469 CB, -0.964
040717 0C FF FF    1104*  	dl 0xFFFF0C ; 286.875 CC, -0.957
04071A 0D FF FF    1105*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04071D 0F FF FF    1106*  	dl 0xFFFF0F ; 289.688 CE, -0.942
040720 12 FF FF    1107*  	dl 0xFFFF12 ; 291.094 CF, -0.933
040723 14 FF FF    1108*  	dl 0xFFFF14 ; 292.500 D0, -0.924
040726 16 FF FF    1109*  	dl 0xFFFF16 ; 293.906 D1, -0.914
040729 19 FF FF    1110*  	dl 0xFFFF19 ; 295.313 D2, -0.904
04072C 1C FF FF    1111*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04072F 1F FF FF    1112*  	dl 0xFFFF1F ; 298.125 D4, -0.882
040732 22 FF FF    1113*  	dl 0xFFFF22 ; 299.531 D5, -0.870
040735 25 FF FF    1114*  	dl 0xFFFF25 ; 300.938 D6, -0.858
040738 28 FF FF    1115*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04073B 2C FF FF    1116*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04073E 2F FF FF    1117*  	dl 0xFFFF2F ; 305.156 D9, -0.818
040741 33 FF FF    1118*  	dl 0xFFFF33 ; 306.563 DA, -0.803
040744 37 FF FF    1119*  	dl 0xFFFF37 ; 307.969 DB, -0.788
040747 3B FF FF    1120*  	dl 0xFFFF3B ; 309.375 DC, -0.773
04074A 3F FF FF    1121*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04074D 43 FF FF    1122*  	dl 0xFFFF43 ; 312.188 DE, -0.741
040750 47 FF FF    1123*  	dl 0xFFFF47 ; 313.594 DF, -0.724
040753 4B FF FF    1124*  	dl 0xFFFF4B ; 315.000 E0, -0.707
040756 50 FF FF    1125*  	dl 0xFFFF50 ; 316.406 E1, -0.690
040759 55 FF FF    1126*  	dl 0xFFFF55 ; 317.813 E2, -0.672
04075C 59 FF FF    1127*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04075F 5E FF FF    1128*  	dl 0xFFFF5E ; 320.625 E4, -0.634
040762 63 FF FF    1129*  	dl 0xFFFF63 ; 322.031 E5, -0.615
040765 68 FF FF    1130*  	dl 0xFFFF68 ; 323.438 E6, -0.596
040768 6D FF FF    1131*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04076B 72 FF FF    1132*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04076E 78 FF FF    1133*  	dl 0xFFFF78 ; 327.656 E9, -0.535
040771 7D FF FF    1134*  	dl 0xFFFF7D ; 329.063 EA, -0.514
040774 82 FF FF    1135*  	dl 0xFFFF82 ; 330.469 EB, -0.493
040777 88 FF FF    1136*  	dl 0xFFFF88 ; 331.875 EC, -0.471
04077A 8D FF FF    1137*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04077D 93 FF FF    1138*  	dl 0xFFFF93 ; 334.688 EE, -0.428
040780 99 FF FF    1139*  	dl 0xFFFF99 ; 336.094 EF, -0.405
040783 9F FF FF    1140*  	dl 0xFFFF9F ; 337.500 F0, -0.383
040786 A4 FF FF    1141*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
040789 AA FF FF    1142*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04078C B0 FF FF    1143*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04078F B6 FF FF    1144*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
040792 BC FF FF    1145*  	dl 0xFFFFBC ; 344.531 F5, -0.267
040795 C2 FF FF    1146*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
040798 C8 FF FF    1147*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04079B CF FF FF    1148*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04079E D5 FF FF    1149*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0407A1 DB FF FF    1150*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0407A4 E1 FF FF    1151*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0407A7 E7 FF FF    1152*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0407AA EE FF FF    1153*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0407AD F4 FF FF    1154*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0407B0 FA FF FF    1155*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0407B3 00 00 00    1156*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0407B6             1157*  
0407B6             1158*  atan_lut_168:
0407B6 00 00 00    1159*  	dl 0x000000 ; 000000, 0.000
0407B9 28 00 00    1160*  	dl 0x000028 ; 000001, 0.224
0407BC 51 00 00    1161*  	dl 0x000051 ; 000002, 0.448
0407BF 7A 00 00    1162*  	dl 0x00007A ; 000003, 0.671
0407C2 A2 00 00    1163*  	dl 0x0000A2 ; 000004, 0.895
0407C5 CB 00 00    1164*  	dl 0x0000CB ; 000005, 1.119
0407C8 F4 00 00    1165*  	dl 0x0000F4 ; 000006, 1.343
0407CB 1D 01 00    1166*  	dl 0x00011D ; 000007, 1.566
0407CE 45 01 00    1167*  	dl 0x000145 ; 000008, 1.790
0407D1 6E 01 00    1168*  	dl 0x00016E ; 000009, 2.013
0407D4 97 01 00    1169*  	dl 0x000197 ; 00000A, 2.237
0407D7 BF 01 00    1170*  	dl 0x0001BF ; 00000B, 2.460
0407DA E8 01 00    1171*  	dl 0x0001E8 ; 00000C, 2.684
0407DD 11 02 00    1172*  	dl 0x000211 ; 00000D, 2.907
0407E0 39 02 00    1173*  	dl 0x000239 ; 00000E, 3.130
0407E3 62 02 00    1174*  	dl 0x000262 ; 00000F, 3.353
0407E6 8B 02 00    1175*  	dl 0x00028B ; 000010, 3.576
0407E9 B3 02 00    1176*  	dl 0x0002B3 ; 000011, 3.799
0407EC DC 02 00    1177*  	dl 0x0002DC ; 000012, 4.022
0407EF 04 03 00    1178*  	dl 0x000304 ; 000013, 4.245
0407F2 2D 03 00    1179*  	dl 0x00032D ; 000014, 4.467
0407F5 55 03 00    1180*  	dl 0x000355 ; 000015, 4.690
0407F8 7E 03 00    1181*  	dl 0x00037E ; 000016, 4.912
0407FB A6 03 00    1182*  	dl 0x0003A6 ; 000017, 5.134
0407FE CE 03 00    1183*  	dl 0x0003CE ; 000018, 5.356
040801 F7 03 00    1184*  	dl 0x0003F7 ; 000019, 5.578
040804 1F 04 00    1185*  	dl 0x00041F ; 00001A, 5.799
040807 48 04 00    1186*  	dl 0x000448 ; 00001B, 6.021
04080A 70 04 00    1187*  	dl 0x000470 ; 00001C, 6.242
04080D 98 04 00    1188*  	dl 0x000498 ; 00001D, 6.463
040810 C0 04 00    1189*  	dl 0x0004C0 ; 00001E, 6.684
040813 E8 04 00    1190*  	dl 0x0004E8 ; 00001F, 6.905
040816 11 05 00    1191*  	dl 0x000511 ; 000020, 7.125
040819 39 05 00    1192*  	dl 0x000539 ; 000021, 7.345
04081C 61 05 00    1193*  	dl 0x000561 ; 000022, 7.565
04081F 89 05 00    1194*  	dl 0x000589 ; 000023, 7.785
040822 B1 05 00    1195*  	dl 0x0005B1 ; 000024, 8.005
040825 D9 05 00    1196*  	dl 0x0005D9 ; 000025, 8.224
040828 01 06 00    1197*  	dl 0x000601 ; 000026, 8.443
04082B 28 06 00    1198*  	dl 0x000628 ; 000027, 8.662
04082E 50 06 00    1199*  	dl 0x000650 ; 000028, 8.881
040831 78 06 00    1200*  	dl 0x000678 ; 000029, 9.099
040834 A0 06 00    1201*  	dl 0x0006A0 ; 00002A, 9.317
040837 C7 06 00    1202*  	dl 0x0006C7 ; 00002B, 9.535
04083A EF 06 00    1203*  	dl 0x0006EF ; 00002C, 9.752
04083D 16 07 00    1204*  	dl 0x000716 ; 00002D, 9.970
040840 3E 07 00    1205*  	dl 0x00073E ; 00002E, 10.187
040843 65 07 00    1206*  	dl 0x000765 ; 00002F, 10.403
040846 8D 07 00    1207*  	dl 0x00078D ; 000030, 10.620
040849 B4 07 00    1208*  	dl 0x0007B4 ; 000031, 10.836
04084C DB 07 00    1209*  	dl 0x0007DB ; 000032, 11.051
04084F 03 08 00    1210*  	dl 0x000803 ; 000033, 11.267
040852 2A 08 00    1211*  	dl 0x00082A ; 000034, 11.482
040855 51 08 00    1212*  	dl 0x000851 ; 000035, 11.697
040858 78 08 00    1213*  	dl 0x000878 ; 000036, 11.911
04085B 9F 08 00    1214*  	dl 0x00089F ; 000037, 12.125
04085E C6 08 00    1215*  	dl 0x0008C6 ; 000038, 12.339
040861 ED 08 00    1216*  	dl 0x0008ED ; 000039, 12.553
040864 13 09 00    1217*  	dl 0x000913 ; 00003A, 12.766
040867 3A 09 00    1218*  	dl 0x00093A ; 00003B, 12.978
04086A 61 09 00    1219*  	dl 0x000961 ; 00003C, 13.191
04086D 87 09 00    1220*  	dl 0x000987 ; 00003D, 13.403
040870 AE 09 00    1221*  	dl 0x0009AE ; 00003E, 13.614
040873 D4 09 00    1222*  	dl 0x0009D4 ; 00003F, 13.825
040876 FB 09 00    1223*  	dl 0x0009FB ; 000040, 14.036
040879 21 0A 00    1224*  	dl 0x000A21 ; 000041, 14.247
04087C 47 0A 00    1225*  	dl 0x000A47 ; 000042, 14.457
04087F 6D 0A 00    1226*  	dl 0x000A6D ; 000043, 14.666
040882 94 0A 00    1227*  	dl 0x000A94 ; 000044, 14.876
040885 BA 0A 00    1228*  	dl 0x000ABA ; 000045, 15.085
040888 E0 0A 00    1229*  	dl 0x000AE0 ; 000046, 15.293
04088B 05 0B 00    1230*  	dl 0x000B05 ; 000047, 15.501
04088E 2B 0B 00    1231*  	dl 0x000B2B ; 000048, 15.709
040891 51 0B 00    1232*  	dl 0x000B51 ; 000049, 15.916
040894 77 0B 00    1233*  	dl 0x000B77 ; 00004A, 16.123
040897 9C 0B 00    1234*  	dl 0x000B9C ; 00004B, 16.329
04089A C2 0B 00    1235*  	dl 0x000BC2 ; 00004C, 16.535
04089D E7 0B 00    1236*  	dl 0x000BE7 ; 00004D, 16.740
0408A0 0C 0C 00    1237*  	dl 0x000C0C ; 00004E, 16.945
0408A3 32 0C 00    1238*  	dl 0x000C32 ; 00004F, 17.150
0408A6 57 0C 00    1239*  	dl 0x000C57 ; 000050, 17.354
0408A9 7C 0C 00    1240*  	dl 0x000C7C ; 000051, 17.558
0408AC A1 0C 00    1241*  	dl 0x000CA1 ; 000052, 17.761
0408AF C6 0C 00    1242*  	dl 0x000CC6 ; 000053, 17.964
0408B2 EB 0C 00    1243*  	dl 0x000CEB ; 000054, 18.166
0408B5 0F 0D 00    1244*  	dl 0x000D0F ; 000055, 18.368
0408B8 34 0D 00    1245*  	dl 0x000D34 ; 000056, 18.569
0408BB 58 0D 00    1246*  	dl 0x000D58 ; 000057, 18.770
0408BE 7D 0D 00    1247*  	dl 0x000D7D ; 000058, 18.970
0408C1 A1 0D 00    1248*  	dl 0x000DA1 ; 000059, 19.170
0408C4 C6 0D 00    1249*  	dl 0x000DC6 ; 00005A, 19.370
0408C7 EA 0D 00    1250*  	dl 0x000DEA ; 00005B, 19.569
0408CA 0E 0E 00    1251*  	dl 0x000E0E ; 00005C, 19.767
0408CD 32 0E 00    1252*  	dl 0x000E32 ; 00005D, 19.965
0408D0 56 0E 00    1253*  	dl 0x000E56 ; 00005E, 20.163
0408D3 7A 0E 00    1254*  	dl 0x000E7A ; 00005F, 20.360
0408D6 9E 0E 00    1255*  	dl 0x000E9E ; 000060, 20.556
0408D9 C1 0E 00    1256*  	dl 0x000EC1 ; 000061, 20.752
0408DC E5 0E 00    1257*  	dl 0x000EE5 ; 000062, 20.947
0408DF 08 0F 00    1258*  	dl 0x000F08 ; 000063, 21.142
0408E2 2C 0F 00    1259*  	dl 0x000F2C ; 000064, 21.337
0408E5 4F 0F 00    1260*  	dl 0x000F4F ; 000065, 21.531
0408E8 72 0F 00    1261*  	dl 0x000F72 ; 000066, 21.724
0408EB 95 0F 00    1262*  	dl 0x000F95 ; 000067, 21.917
0408EE B8 0F 00    1263*  	dl 0x000FB8 ; 000068, 22.109
0408F1 DB 0F 00    1264*  	dl 0x000FDB ; 000069, 22.301
0408F4 FE 0F 00    1265*  	dl 0x000FFE ; 00006A, 22.493
0408F7 21 10 00    1266*  	dl 0x001021 ; 00006B, 22.683
0408FA 44 10 00    1267*  	dl 0x001044 ; 00006C, 22.874
0408FD 66 10 00    1268*  	dl 0x001066 ; 00006D, 23.063
040900 89 10 00    1269*  	dl 0x001089 ; 00006E, 23.253
040903 AB 10 00    1270*  	dl 0x0010AB ; 00006F, 23.441
040906 CD 10 00    1271*  	dl 0x0010CD ; 000070, 23.629
040909 EF 10 00    1272*  	dl 0x0010EF ; 000071, 23.817
04090C 11 11 00    1273*  	dl 0x001111 ; 000072, 24.004
04090F 33 11 00    1274*  	dl 0x001133 ; 000073, 24.191
040912 55 11 00    1275*  	dl 0x001155 ; 000074, 24.376
040915 77 11 00    1276*  	dl 0x001177 ; 000075, 24.562
040918 99 11 00    1277*  	dl 0x001199 ; 000076, 24.747
04091B BA 11 00    1278*  	dl 0x0011BA ; 000077, 24.931
04091E DC 11 00    1279*  	dl 0x0011DC ; 000078, 25.115
040921 FD 11 00    1280*  	dl 0x0011FD ; 000079, 25.298
040924 1E 12 00    1281*  	dl 0x00121E ; 00007A, 25.481
040927 3F 12 00    1282*  	dl 0x00123F ; 00007B, 25.663
04092A 60 12 00    1283*  	dl 0x001260 ; 00007C, 25.844
04092D 81 12 00    1284*  	dl 0x001281 ; 00007D, 26.025
040930 A2 12 00    1285*  	dl 0x0012A2 ; 00007E, 26.206
040933 C3 12 00    1286*  	dl 0x0012C3 ; 00007F, 26.386
040936 E4 12 00    1287*  	dl 0x0012E4 ; 000080, 26.565
040939 04 13 00    1288*  	dl 0x001304 ; 000081, 26.744
04093C 25 13 00    1289*  	dl 0x001325 ; 000082, 26.922
04093F 45 13 00    1290*  	dl 0x001345 ; 000083, 27.100
040942 65 13 00    1291*  	dl 0x001365 ; 000084, 27.277
040945 85 13 00    1292*  	dl 0x001385 ; 000085, 27.453
040948 A5 13 00    1293*  	dl 0x0013A5 ; 000086, 27.629
04094B C5 13 00    1294*  	dl 0x0013C5 ; 000087, 27.805
04094E E5 13 00    1295*  	dl 0x0013E5 ; 000088, 27.979
040951 05 14 00    1296*  	dl 0x001405 ; 000089, 28.154
040954 24 14 00    1297*  	dl 0x001424 ; 00008A, 28.327
040957 44 14 00    1298*  	dl 0x001444 ; 00008B, 28.501
04095A 63 14 00    1299*  	dl 0x001463 ; 00008C, 28.673
04095D 83 14 00    1300*  	dl 0x001483 ; 00008D, 28.845
040960 A2 14 00    1301*  	dl 0x0014A2 ; 00008E, 29.017
040963 C1 14 00    1302*  	dl 0x0014C1 ; 00008F, 29.187
040966 E0 14 00    1303*  	dl 0x0014E0 ; 000090, 29.358
040969 FF 14 00    1304*  	dl 0x0014FF ; 000091, 29.527
04096C 1E 15 00    1305*  	dl 0x00151E ; 000092, 29.697
04096F 3C 15 00    1306*  	dl 0x00153C ; 000093, 29.865
040972 5B 15 00    1307*  	dl 0x00155B ; 000094, 30.033
040975 79 15 00    1308*  	dl 0x001579 ; 000095, 30.201
040978 98 15 00    1309*  	dl 0x001598 ; 000096, 30.368
04097B B6 15 00    1310*  	dl 0x0015B6 ; 000097, 30.534
04097E D4 15 00    1311*  	dl 0x0015D4 ; 000098, 30.700
040981 F2 15 00    1312*  	dl 0x0015F2 ; 000099, 30.865
040984 10 16 00    1313*  	dl 0x001610 ; 00009A, 31.030
040987 2E 16 00    1314*  	dl 0x00162E ; 00009B, 31.194
04098A 4C 16 00    1315*  	dl 0x00164C ; 00009C, 31.357
04098D 6A 16 00    1316*  	dl 0x00166A ; 00009D, 31.520
040990 87 16 00    1317*  	dl 0x001687 ; 00009E, 31.682
040993 A5 16 00    1318*  	dl 0x0016A5 ; 00009F, 31.844
040996 C2 16 00    1319*  	dl 0x0016C2 ; 0000A0, 32.005
040999 DF 16 00    1320*  	dl 0x0016DF ; 0000A1, 32.166
04099C FC 16 00    1321*  	dl 0x0016FC ; 0000A2, 32.326
04099F 19 17 00    1322*  	dl 0x001719 ; 0000A3, 32.486
0409A2 36 17 00    1323*  	dl 0x001736 ; 0000A4, 32.645
0409A5 53 17 00    1324*  	dl 0x001753 ; 0000A5, 32.803
0409A8 70 17 00    1325*  	dl 0x001770 ; 0000A6, 32.961
0409AB 8C 17 00    1326*  	dl 0x00178C ; 0000A7, 33.118
0409AE A9 17 00    1327*  	dl 0x0017A9 ; 0000A8, 33.275
0409B1 C5 17 00    1328*  	dl 0x0017C5 ; 0000A9, 33.431
0409B4 E2 17 00    1329*  	dl 0x0017E2 ; 0000AA, 33.587
0409B7 FE 17 00    1330*  	dl 0x0017FE ; 0000AB, 33.742
0409BA 1A 18 00    1331*  	dl 0x00181A ; 0000AC, 33.896
0409BD 36 18 00    1332*  	dl 0x001836 ; 0000AD, 34.050
0409C0 52 18 00    1333*  	dl 0x001852 ; 0000AE, 34.203
0409C3 6E 18 00    1334*  	dl 0x00186E ; 0000AF, 34.356
0409C6 8A 18 00    1335*  	dl 0x00188A ; 0000B0, 34.509
0409C9 A5 18 00    1336*  	dl 0x0018A5 ; 0000B1, 34.660
0409CC C1 18 00    1337*  	dl 0x0018C1 ; 0000B2, 34.811
0409CF DC 18 00    1338*  	dl 0x0018DC ; 0000B3, 34.962
0409D2 F7 18 00    1339*  	dl 0x0018F7 ; 0000B4, 35.112
0409D5 13 19 00    1340*  	dl 0x001913 ; 0000B5, 35.262
0409D8 2E 19 00    1341*  	dl 0x00192E ; 0000B6, 35.410
0409DB 49 19 00    1342*  	dl 0x001949 ; 0000B7, 35.559
0409DE 64 19 00    1343*  	dl 0x001964 ; 0000B8, 35.707
0409E1 7F 19 00    1344*  	dl 0x00197F ; 0000B9, 35.854
0409E4 99 19 00    1345*  	dl 0x001999 ; 0000BA, 36.001
0409E7 B4 19 00    1346*  	dl 0x0019B4 ; 0000BB, 36.147
0409EA CE 19 00    1347*  	dl 0x0019CE ; 0000BC, 36.293
0409ED E9 19 00    1348*  	dl 0x0019E9 ; 0000BD, 36.438
0409F0 03 1A 00    1349*  	dl 0x001A03 ; 0000BE, 36.582
0409F3 1D 1A 00    1350*  	dl 0x001A1D ; 0000BF, 36.726
0409F6 37 1A 00    1351*  	dl 0x001A37 ; 0000C0, 36.870
0409F9 51 1A 00    1352*  	dl 0x001A51 ; 0000C1, 37.013
0409FC 6B 1A 00    1353*  	dl 0x001A6B ; 0000C2, 37.155
0409FF 85 1A 00    1354*  	dl 0x001A85 ; 0000C3, 37.297
040A02 9F 1A 00    1355*  	dl 0x001A9F ; 0000C4, 37.439
040A05 B9 1A 00    1356*  	dl 0x001AB9 ; 0000C5, 37.579
040A08 D2 1A 00    1357*  	dl 0x001AD2 ; 0000C6, 37.720
040A0B EC 1A 00    1358*  	dl 0x001AEC ; 0000C7, 37.859
040A0E 05 1B 00    1359*  	dl 0x001B05 ; 0000C8, 37.999
040A11 1E 1B 00    1360*  	dl 0x001B1E ; 0000C9, 38.137
040A14 37 1B 00    1361*  	dl 0x001B37 ; 0000CA, 38.276
040A17 50 1B 00    1362*  	dl 0x001B50 ; 0000CB, 38.413
040A1A 69 1B 00    1363*  	dl 0x001B69 ; 0000CC, 38.550
040A1D 82 1B 00    1364*  	dl 0x001B82 ; 0000CD, 38.687
040A20 9B 1B 00    1365*  	dl 0x001B9B ; 0000CE, 38.823
040A23 B4 1B 00    1366*  	dl 0x001BB4 ; 0000CF, 38.959
040A26 CC 1B 00    1367*  	dl 0x001BCC ; 0000D0, 39.094
040A29 E5 1B 00    1368*  	dl 0x001BE5 ; 0000D1, 39.228
040A2C FD 1B 00    1369*  	dl 0x001BFD ; 0000D2, 39.362
040A2F 16 1C 00    1370*  	dl 0x001C16 ; 0000D3, 39.496
040A32 2E 1C 00    1371*  	dl 0x001C2E ; 0000D4, 39.629
040A35 46 1C 00    1372*  	dl 0x001C46 ; 0000D5, 39.762
040A38 5E 1C 00    1373*  	dl 0x001C5E ; 0000D6, 39.894
040A3B 76 1C 00    1374*  	dl 0x001C76 ; 0000D7, 40.025
040A3E 8E 1C 00    1375*  	dl 0x001C8E ; 0000D8, 40.156
040A41 A5 1C 00    1376*  	dl 0x001CA5 ; 0000D9, 40.286
040A44 BD 1C 00    1377*  	dl 0x001CBD ; 0000DA, 40.416
040A47 D5 1C 00    1378*  	dl 0x001CD5 ; 0000DB, 40.546
040A4A EC 1C 00    1379*  	dl 0x001CEC ; 0000DC, 40.675
040A4D 04 1D 00    1380*  	dl 0x001D04 ; 0000DD, 40.803
040A50 1B 1D 00    1381*  	dl 0x001D1B ; 0000DE, 40.931
040A53 32 1D 00    1382*  	dl 0x001D32 ; 0000DF, 41.059
040A56 49 1D 00    1383*  	dl 0x001D49 ; 0000E0, 41.186
040A59 60 1D 00    1384*  	dl 0x001D60 ; 0000E1, 41.312
040A5C 77 1D 00    1385*  	dl 0x001D77 ; 0000E2, 41.438
040A5F 8E 1D 00    1386*  	dl 0x001D8E ; 0000E3, 41.564
040A62 A5 1D 00    1387*  	dl 0x001DA5 ; 0000E4, 41.689
040A65 BB 1D 00    1388*  	dl 0x001DBB ; 0000E5, 41.814
040A68 D2 1D 00    1389*  	dl 0x001DD2 ; 0000E6, 41.938
040A6B E9 1D 00    1390*  	dl 0x001DE9 ; 0000E7, 42.061
040A6E FF 1D 00    1391*  	dl 0x001DFF ; 0000E8, 42.184
040A71 15 1E 00    1392*  	dl 0x001E15 ; 0000E9, 42.307
040A74 2C 1E 00    1393*  	dl 0x001E2C ; 0000EA, 42.429
040A77 42 1E 00    1394*  	dl 0x001E42 ; 0000EB, 42.551
040A7A 58 1E 00    1395*  	dl 0x001E58 ; 0000EC, 42.672
040A7D 6E 1E 00    1396*  	dl 0x001E6E ; 0000ED, 42.793
040A80 84 1E 00    1397*  	dl 0x001E84 ; 0000EE, 42.913
040A83 99 1E 00    1398*  	dl 0x001E99 ; 0000EF, 43.033
040A86 AF 1E 00    1399*  	dl 0x001EAF ; 0000F0, 43.152
040A89 C5 1E 00    1400*  	dl 0x001EC5 ; 0000F1, 43.271
040A8C DA 1E 00    1401*  	dl 0x001EDA ; 0000F2, 43.390
040A8F F0 1E 00    1402*  	dl 0x001EF0 ; 0000F3, 43.508
040A92 05 1F 00    1403*  	dl 0x001F05 ; 0000F4, 43.625
040A95 1B 1F 00    1404*  	dl 0x001F1B ; 0000F5, 43.742
040A98 30 1F 00    1405*  	dl 0x001F30 ; 0000F6, 43.859
040A9B 45 1F 00    1406*  	dl 0x001F45 ; 0000F7, 43.975
040A9E 5A 1F 00    1407*  	dl 0x001F5A ; 0000F8, 44.091
040AA1 6F 1F 00    1408*  	dl 0x001F6F ; 0000F9, 44.206
040AA4 84 1F 00    1409*  	dl 0x001F84 ; 0000FA, 44.321
040AA7 99 1F 00    1410*  	dl 0x001F99 ; 0000FB, 44.435
040AAA AD 1F 00    1411*  	dl 0x001FAD ; 0000FC, 44.549
040AAD C2 1F 00    1412*  	dl 0x001FC2 ; 0000FD, 44.662
040AB0 D7 1F 00    1413*  	dl 0x001FD7 ; 0000FE, 44.775
040AB3 EB 1F 00    1414*  	dl 0x001FEB ; 0000FF, 44.888
040AB6 00 20 00    1415*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
040AB9             1416*  
040AB9             1417*  	; include "functions.inc"
040AB9             1418*  
040AB9             1419*      MACRO printChar char
040AB9             1420*          LD A, char
040AB9             1421*          RST.LIL 10h
040AB9             1422*      ENDMACRO
040AB9             1423*  
040AB9             1424*  ; put the value in HLU into the accumulator
040AB9             1425*  ; destroys: af
040AB9             1426*      MACRO HLU_TO_A
040AB9             1427*          push hl ; 4 cycles
040AB9             1428*          inc sp ; 1 cycle
040AB9             1429*          pop af  ; 4 cycles
040AB9             1430*          dec sp ; 1 cycle
040AB9             1431*                 ; 10 cycles total
040AB9             1432*      ENDMACRO
040AB9             1433*  
040AB9             1434*  ; put the value in the accumulator into HLU
040AB9             1435*  ; destroys a
040AB9             1436*  A_TO_HLU:
040AB9             1437*      ; call is 7 cycles
040AB9 22 C6 0A 04 1438*      ld (@scratch),hl ; 7 cycles
040ABD 32 C8 0A 04 1439*      ld (@scratch+2),a ; 5 cycles
040AC1 2A C6 0A 04 1440*      ld hl,(@scratch) ; 7 cycles
040AC5 C9          1441*      ret ; 6 cycles
040AC6             1442*          ; 25 cycles total
040AC6 00 00 00    1443*  @scratch: dl 0
040AC9             1444*  
040AC9             1445*  
040AC9             1446*  ; Print a zero-terminated string inline with code, e.g.:
040AC9             1447*  ;
040AC9             1448*  ;    call printInline
040AC9             1449*  ;    ASCIZ "Hello, world!\r\n"
040AC9             1450*  ;
040AC9             1451*  ; Destroys: HL,AF
040AC9             1452*  printInline:
040AC9 E1          1453*      pop hl ; get the return address = pointer to start of string
040ACA CD D0 0A 04 1454*      call printString ; HL advances to end of string
040ACE E5          1455*      push hl ; restore the return address = pointer to end of string
040ACF C9          1456*      ret
040AD0             1457*  
040AD0             1458*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040AD0             1459*  ; Print a zero-terminated string
040AD0             1460*  ; HL: Pointer to string
040AD0             1461*  printString:
040AD0 C5          1462*  	PUSH	BC
040AD1 01 00 00 00 1463*  	LD		BC,0
040AD5 3E 00       1464*  	LD 	 	A,0
040AD7 5B DF       1465*  	RST.LIL 18h
040AD9 C1          1466*  	POP		BC
040ADA C9          1467*  	RET
040ADB             1468*  ; print a VDU sequence
040ADB             1469*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040ADB             1470*  sendVDUsequence:
040ADB C5          1471*  	PUSH	BC
040ADC 01 00 00 00 1472*  	LD		BC, 0
040AE0 4E          1473*  	LD		C, (HL)
040AE1 5B DF       1474*  	RST.LIL	18h
040AE3 C1          1475*  	POP		BC
040AE4 C9          1476*  	RET
040AE5             1477*  ; Print Newline sequence to VDP
040AE5             1478*  printNewLine:
040AE5 F5          1479*      push af ; for some reason rst.lil 10h sets carry flag
040AE6 3E 0D       1480*  	LD	A, '\r'
040AE8 5B D7       1481*  	RST.LIL 10h
040AEA 3E 0A       1482*  	LD	A, '\n'
040AEC 5B D7       1483*  	RST.LIL 10h
040AEE F1          1484*      pop af
040AEF C9          1485*  	RET
040AF0             1486*  
040AF0             1487*  ; Print a 24-bit HEX number
040AF0             1488*  ; HLU: Number to print
040AF0             1489*  printHex24:
040AF0             1490*      HLU_TO_A
040AF0 E5          0001*M         push hl ; 4 cycles
040AF1 33          0002*M         inc sp ; 1 cycle
040AF2 F1          0003*M         pop af  ; 4 cycles
040AF3 3B          0004*M         dec sp ; 1 cycle
040AF4             0005*M                ; 10 cycles total
040AF4 CD FE 0A 04 1491*  	CALL	printHex8
040AF8             1492*  ; Print a 16-bit HEX number
040AF8             1493*  ; HL: Number to print
040AF8             1494*  printHex16:
040AF8 7C          1495*  	LD		A,H
040AF9 CD FE 0A 04 1496*  	CALL	printHex8
040AFD 7D          1497*  	LD		A,L
040AFE             1498*  ; Print an 8-bit HEX number
040AFE             1499*  ; A: Number to print
040AFE             1500*  printHex8:
040AFE 4F          1501*  	LD		C,A
040AFF 1F          1502*  	RRA
040B00 1F          1503*  	RRA
040B01 1F          1504*  	RRA
040B02 1F          1505*  	RRA
040B03 CD 08 0B 04 1506*  	CALL	@F
040B07 79          1507*  	LD		A,C
040B08             1508*  @@:
040B08 E6 0F       1509*  	AND		0Fh
040B0A C6 90       1510*  	ADD		A,90h
040B0C 27          1511*  	DAA
040B0D CE 40       1512*  	ADC		A,40h
040B0F 27          1513*  	DAA
040B10 5B D7       1514*  	RST.LIL	10h
040B12 C9          1515*  	RET
040B13             1516*  
040B13             1517*  printHexUHL:
040B13 E5          1518*  	push hl
040B14 CD F0 0A 04 1519*  	call printHex24
040B18 E1          1520*  	pop hl
040B19 C9          1521*  	ret
040B1A             1522*  
040B1A             1523*  
040B1A             1524*  ; print registers to screen in hexidecimal format
040B1A             1525*  ; inputs: none
040B1A             1526*  ; outputs: values of every register printed to screen
040B1A             1527*  ;    values of each register in global scratch memory
040B1A             1528*  ; destroys: nothing
040B1A             1529*  dumpRegistersHex:
040B1A             1530*  ; store everything in scratch
040B1A 22 BF 0B 04 1531*      ld (@uhl),hl
040B1E ED 43 C2 0B 1532*      ld (@ubc),bc
       04          
040B23 ED 53 C5 0B 1533*      ld (@ude),de
       04          
040B28 DD 22 C8 0B 1534*      ld (@uix),ix
       04          
040B2D FD 22 CB 0B 1535*      ld (@uiy),iy
       04          
040B32 F5          1536*      push af
040B33 E1          1537*      pop hl
040B34 22 BC 0B 04 1538*      ld (@uaf),hl
040B38 F5          1539*      push af
040B39             1540*  
040B39             1541*  ; print each register
040B39 CD C9 0A 04 1542*      call printInline
040B3D 61 66 3D 00 1543*      asciz "af="
040B41 2A BC 0B 04 1544*      ld hl,(@uaf)
040B45 CD F0 0A 04 1545*      call printHex24
040B49             1546*  
040B49 CD C9 0A 04 1547*      call printInline
040B4D 20 68 6C 3D 1548*      asciz " hl="
       00          
040B52 2A BF 0B 04 1549*      ld hl,(@uhl)
040B56 CD F0 0A 04 1550*      call printHex24
040B5A             1551*  
040B5A CD C9 0A 04 1552*      call printInline
040B5E 20 62 63 3D 1553*      asciz " bc="
       00          
040B63 2A C2 0B 04 1554*      ld hl,(@ubc)
040B67 CD F0 0A 04 1555*      call printHex24
040B6B             1556*  
040B6B CD C9 0A 04 1557*      call printInline
040B6F 20 64 65 3D 1558*      asciz " de="
       00          
040B74 2A C5 0B 04 1559*      ld hl,(@ude)
040B78 CD F0 0A 04 1560*      call printHex24
040B7C             1561*  
040B7C CD C9 0A 04 1562*      call printInline
040B80 20 69 78 3D 1563*      asciz " ix="
       00          
040B85 2A C8 0B 04 1564*      ld hl,(@uix)
040B89 CD F0 0A 04 1565*      call printHex24
040B8D             1566*  
040B8D CD C9 0A 04 1567*      call printInline
040B91 20 69 79 3D 1568*      asciz " iy="
       00          
040B96 2A CB 0B 04 1569*      ld hl,(@uiy)
040B9A CD F0 0A 04 1570*      call printHex24
040B9E             1571*  
040B9E CD E5 0A 04 1572*      call printNewLine
040BA2             1573*  ; restore everything
040BA2 2A BF 0B 04 1574*      ld hl, (@uhl)
040BA6 ED 4B C2 0B 1575*      ld bc, (@ubc)
       04          
040BAB ED 5B C5 0B 1576*      ld de, (@ude)
       04          
040BB0 DD 2A C8 0B 1577*      ld ix, (@uix)
       04          
040BB5 FD 2A CB 0B 1578*      ld iy, (@uiy)
       04          
040BBA F1          1579*      pop af
040BBB             1580*  ; all done
040BBB C9          1581*      ret
040BBC             1582*  
040BBC 00 00 00    1583*  @uaf: dl 0
040BBF 00 00 00    1584*  @uhl: dl 0
040BC2 00 00 00    1585*  @ubc: dl 0
040BC5 00 00 00    1586*  @ude: dl 0
040BC8 00 00 00    1587*  @uix: dl 0
040BCB 00 00 00    1588*  @uiy: dl 0
040BCE             1589*  
040BCE             1590*  ; Prints the right justified decimal value in HL without leading zeroes
040BCE             1591*  ; HL : Value to print
040BCE             1592*  ; preserves all registers and flags
040BCE             1593*  printDec:
040BCE             1594*  ; BEGIN MY CODE
040BCE             1595*  ; back up all the things
040BCE F5          1596*      push af
040BCF C5          1597*      push bc
040BD0 D5          1598*      push de
040BD1 E5          1599*      push hl
040BD2             1600*  ; END MY CODE
040BD2 11 FA 0B 04 1601*  	LD	 DE, _printDecBuffer
040BD6 CD 0A 0C 04 1602*  	CALL u24_to_ascii
040BDA             1603*  ; BEGIN MY CODE
040BDA             1604*  ; replace leading zeroes with spaces
040BDA 21 FA 0B 04 1605*      LD	 HL, _printDecBuffer
040BDE 06 07       1606*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040BE0             1607*  @loop:
040BE0 7E          1608*      LD	 A, (HL)
040BE1 FE 30       1609*      CP	 '0'
040BE3 C2 ED 0B 04 1610*      JP	 NZ, @done
040BE7 3E 20       1611*      LD   A, ' '
040BE9 77          1612*      LD	 (HL), A
040BEA 23          1613*      INC	 HL
040BEB             1614*      ; CALL vdu_cursor_forward
040BEB 10 F3       1615*      DJNZ @loop
040BED             1616*  @done:
040BED             1617*  ; END MY CODE
040BED 21 FA 0B 04 1618*  	LD	 HL, _printDecBuffer
040BF1 CD D0 0A 04 1619*  	CALL printString
040BF5             1620*  ; BEGIN MY CODE
040BF5             1621*  ; restore all the things
040BF5 E1          1622*      pop hl
040BF6 D1          1623*      pop de
040BF7 C1          1624*      pop bc
040BF8 F1          1625*      pop af
040BF9             1626*  ; END MY CODE
040BF9 C9          1627*  	RET
040BFA 00 00 00 00 1628*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C0A             1629*  
040C0A             1630*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040C0A             1631*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040C0A             1632*  ; so it will allways be 8 characters length
040C0A             1633*  ; HL : Value to convert to string
040C0A             1634*  ; DE : pointer to buffer, at least 8 byte + 0
040C0A             1635*  u24_to_ascii:
040C0A 01 80 69 67 1636*  	LD	 BC,-10000000
040C0E CD 41 0C 04 1637*  	CALL @one_digit
040C12 01 C0 BD F0 1638*  	LD	 BC,-1000000
040C16 CD 41 0C 04 1639*  	CALL @one_digit
040C1A 01 60 79 FE 1640*  	LD	 BC,-100000
040C1E CD 41 0C 04 1641*  	CALL @one_digit
040C22 01 F0 D8 FF 1642*  	LD   BC,-10000
040C26 CD 41 0C 04 1643*  	CALL @one_digit
040C2A 01 18 FC FF 1644*  	LD   BC,-1000
040C2E CD 41 0C 04 1645*  	CALL @one_digit
040C32 01 9C FF FF 1646*  	LD   BC,-100
040C36 CD 41 0C 04 1647*  	CALL @one_digit
040C3A 0E F6       1648*  	LD   C,-10
040C3C CD 41 0C 04 1649*  	CALL @one_digit
040C40 48          1650*  	LD   C,B
040C41             1651*  @one_digit:
040C41 3E 2F       1652*  	LD   A,'0'-1
040C43             1653*  @divide_me:
040C43 3C          1654*  	INC  A
040C44 09          1655*  	ADD  HL,BC
040C45 38 FC       1656*  	JR   C,@divide_me
040C47 ED 42       1657*  	SBC  HL,BC
040C49 12          1658*  	LD   (DE),A
040C4A 13          1659*  	INC  DE
040C4B C9          1660*  	RET
040C4C             1661*  
040C4C             1662*  print_u24:
040C4C D5          1663*      push de
040C4D E5          1664*      push hl
040C4E 11 FA 0B 04 1665*      ld de,_printDecBuffer
040C52 CD 0A 0C 04 1666*      call u24_to_ascii
040C56 21 FA 0B 04 1667*      ld hl,_printDecBuffer
040C5A CD D0 0A 04 1668*      call printString
040C5E 3E 20       1669*      ld a,' '
040C60 5B D7       1670*      rst.lil 10h
040C62 E1          1671*      pop hl
040C63 D1          1672*      pop de
040C64 C9          1673*      ret
040C65             1674*  
040C65             1675*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040C65             1676*  ; HL : Value to convert to string (integer part in H, fractional part in L)
040C65             1677*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040C65             1678*  u168_to_ascii:
040C65             1679*  ; add a leading space to make room for sign flag if needed
040C65 3E 20       1680*      ld a,' '
040C67 12          1681*      ld (de),a
040C68 13          1682*      inc de
040C69             1683*  ; Convert integer part
040C69 E5          1684*      push hl               ; Save HL (well need the fractional part later)
040C6A CD 7B 00 04 1685*      call hlu_udiv256    ; Shift to get integer portion in HL
040C6E 01 F0 D8 FF 1686*      ld   bc, -10000
040C72 CD 95 0C 04 1687*      call @one_int
040C76 01 18 FC FF 1688*      ld   bc, -1000
040C7A CD 95 0C 04 1689*      call @one_int
040C7E 01 9C FF FF 1690*      ld   bc, -100
040C82 CD 95 0C 04 1691*      call @one_int
040C86 0E F6       1692*      ld   c, -10
040C88 CD 95 0C 04 1693*      call @one_int
040C8C 48          1694*      ld   c, b
040C8D CD 95 0C 04 1695*      call @one_int
040C91 C3 A0 0C 04 1696*      jp   @frac            ; Jump to fractional part conversion
040C95             1697*  @one_int:
040C95 3E 2F       1698*      ld   a, '0' - 1       ; Start ASCII character at '0'
040C97             1699*  @divide_me:
040C97 3C          1700*      inc  a
040C98 09          1701*      add  hl, bc           ; Accumulate until overflow
040C99 38 FC       1702*      jr   c, @divide_me
040C9B ED 42       1703*      sbc  hl, bc           ; Remove excess after overflow
040C9D 12          1704*      ld   (de), a          ; Store ASCII digit
040C9E 13          1705*      inc  de
040C9F C9          1706*      ret
040CA0             1707*  ; Convert fractional part
040CA0             1708*  @frac:
040CA0 3E 2E       1709*      ld   a, '.'           ; Decimal point
040CA2 12          1710*      ld   (de), a
040CA3 13          1711*      inc  de
040CA4 E1          1712*      pop  hl               ; Restore HL with original fraction
040CA5 06 03       1713*      ld   b, 3             ; Loop counter for 3 fractional digits
040CA7             1714*  @frac_loop:
040CA7 26 0A       1715*      ld   h, 10            ; Load multiplier for fractional part
040CA9 ED 6C       1716*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040CAB 3E 30       1717*      ld   a, '0'
040CAD 84          1718*      add  a, h             ; Convert integer part to ASCII
040CAE 12          1719*      ld   (de), a
040CAF 13          1720*      inc  de
040CB0 10 F5       1721*      djnz @frac_loop       ; Repeat for each fractional digit
040CB2             1722*  ; Add null terminator
040CB2 AF          1723*      xor  a                ; Null terminator
040CB3 12          1724*      ld   (de), a
040CB4 C9          1725*      ret
040CB5             1726*  
040CB5             1727*  print_u168:
040CB5 D5          1728*      push de
040CB6 E5          1729*      push hl
040CB7 11 FA 0B 04 1730*      ld de,_printDecBuffer
040CBB CD 65 0C 04 1731*      call u168_to_ascii
040CBF 21 FA 0B 04 1732*      ld hl,_printDecBuffer
040CC3 CD D0 0A 04 1733*      call printString
040CC7 E1          1734*      pop hl
040CC8 D1          1735*      pop de
040CC9 C9          1736*      ret
040CCA             1737*  
040CCA             1738*  ; signed version of u168_to_ascii
040CCA             1739*  s168_to_ascii:
040CCA D5          1740*      push de ; save starting address of buffer
040CCB CD 88 00 04 1741*      call hlu_abs
040CCF F5          1742*      push af ; save sign flag
040CD0 CD 65 0C 04 1743*      call u168_to_ascii
040CD4 F1          1744*      pop af ; restore sign flag
040CD5 D1          1745*      pop de ; restore starting address of buffer
040CD6 F0          1746*      ret p ; hlu was positive so nothing to do
040CD7 3E 2D       1747*      ld a,'-'
040CD9 12          1748*      ld (de),a
040CDA C9          1749*      ret
040CDB             1750*  
040CDB             1751*  print_s168:
040CDB D5          1752*      push de
040CDC E5          1753*      push hl
040CDD 11 FA 0B 04 1754*      ld de,_printDecBuffer
040CE1 CD CA 0C 04 1755*      call s168_to_ascii
040CE5 21 FA 0B 04 1756*      ld hl,_printDecBuffer
040CE9 CD D0 0A 04 1757*      call printString
040CED E1          1758*      pop hl
040CEE D1          1759*      pop de
040CEF C9          1760*      ret
040CF0             1761*  
040CF0             1762*  	; include "parse.inc"
040CF0             1763*  
040CF0             1764*  ;
040CF0             1765*  ; Title:	Number Parsing Functions
040CF0             1766*  ; Author:	Dean Belfield
040CF0             1767*  ; Created:	15/11/2022
040CF0             1768*  ; Last Updated:	15/11/2022
040CF0             1769*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
040CF0             1770*  ; Modinfo:
040CF0             1771*  ; 2024/04/08    Adapt for ez80asm
040CF0             1772*  
040CF0             1773*  ; Read a number and convert to binary
040CF0             1774*  ; If prefixed with &, will read as hex, otherwise decimal
040CF0             1775*  ;   Inputs: HL: Pointer in string buffer
040CF0             1776*  ;  Outputs: HL: Updated text pointer
040CF0             1777*  ;           DE: Value
040CF0             1778*  ;            A: Terminator (spaces skipped)
040CF0             1779*  ;            F: Carry set if valid number, otherwise reset
040CF0             1780*  ; Destroys: A,D,E,H,L,F
040CF0             1781*  ;
040CF0 11 00 00 00 1782*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
040CF4             1783*  			; CALL		_skip_spaces		; Skip whitespace
040CF4 7E          1784*  			LD		A, (HL)			; Read first character
040CF5 B7          1785*  			OR		A			; Check for end of string
040CF6 C8          1786*  			RET		Z			; Return with no carry if not
040CF7 C5          1787*  			PUSH		BC			; Preserve BC
040CF8 FE 26       1788*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
040CFA 20 23       1789*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
040CFC 23          1790*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
040CFD             1791*  ;
040CFD 7E          1792*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
040CFE CD 40 0D 04 1793*  			CALL   	 	UPPRC			; Convert to uppercase
040D02 D6 30       1794*  			SUB		'0'			; Normalise to 0
040D04 38 37       1795*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040D06 FE 0A       1796*  			CP 		10			; Check if >= 10
040D08 38 06       1797*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
040D0A D6 07       1798*  			SUB 		7			; Adjust ASCII A-F to nibble
040D0C FE 10       1799*  			CP 		16			; Check for > F
040D0E 30 2D       1800*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
040D10             1801*  ;
040D10 E5          1802*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
040D11 D5          1803*  			PUSH		DE			; LD HL, DE
040D12 E1          1804*  			POP		HL
040D13 29          1805*  			ADD		HL, HL
040D14 29          1806*  			ADD		HL, HL
040D15 29          1807*  			ADD		HL, HL
040D16 29          1808*  			ADD		HL, HL
040D17 E5          1809*  			PUSH		HL			; LD DE, HL
040D18 D1          1810*  			POP		DE
040D19 E1          1811*  			POP		HL			; Restore HL
040D1A B3          1812*  			OR      	E			; OR the new digit in to the least significant nibble
040D1B 5F          1813*  			LD      	E, A
040D1C             1814*  ;
040D1C 23          1815*  			INC		HL			; Onto the next character
040D1D 18 DE       1816*  			JR      	ASC_TO_NUMBER1		; And loop
040D1F             1817*  ;
040D1F 7E          1818*  ASC_TO_NUMBER3:		LD		A, (HL)
040D20 D6 30       1819*  			SUB		'0'			; Normalise to 0
040D22 38 19       1820*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040D24 FE 0A       1821*  			CP		10			; Check if >= 10
040D26 30 15       1822*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
040D28             1823*  ;
040D28 E5          1824*  			PUSH		HL			; Stack HL
040D29 D5          1825*  			PUSH		DE			; LD HL, DE
040D2A E1          1826*  			POP		HL
040D2B E5          1827*  			PUSH		HL			; LD BC, HL
040D2C C1          1828*  			POP		BC
040D2D 29          1829*  			ADD		HL, HL 			; x 2
040D2E 29          1830*  			ADD		HL, HL 			; x 4
040D2F 09          1831*  			ADD		HL, BC 			; x 5
040D30 29          1832*  			ADD		HL, HL 			; x 10
040D31 01 00 00 00 1833*  			LD		BC, 0
040D35 4F          1834*  			LD 		C, A			; LD BCU, A
040D36 09          1835*  			ADD		HL, BC			; Add BCU to HL
040D37 E5          1836*  			PUSH		HL			; LD DE, HL
040D38 D1          1837*  			POP		DE
040D39 E1          1838*  			POP		HL			; Restore HL
040D3A             1839*  ;
040D3A 23          1840*  			INC		HL
040D3B 18 E2       1841*  			JR		ASC_TO_NUMBER3
040D3D C1          1842*  ASC_TO_NUMBER4:		POP		BC
040D3E 37          1843*  			SCF					; We have a valid number so set carry
040D3F C9          1844*  			RET
040D40             1845*  
040D40             1846*  
040D40             1847*  ; Convert a character to upper case
040D40             1848*  ;  A: Character to convert
040D40             1849*  ;
040D40 E6 7F       1850*  UPPRC:  		AND     	7FH
040D42 FE 60       1851*  			CP      	'`'
040D44 D8          1852*  			RET     	C
040D45 E6 5F       1853*  			AND     	5FH			; Convert to upper case
040D47 C9          1854*  			RET
040D48             1855*  
040D48             1856*  ; -----------------------------------------------------------------------
040D48             1857*  ;
040D48             1858*  ; additional functions by Brandon R. Gates based on Dean's code
040D48             1859*  ;
040D48             1860*  ;------------------------------------------------------------------------
040D48             1861*  ; Read a number and convert to binary (decimal only)
040D48             1862*  ; Inputs: hl: Pointer in string buffer
040D48             1863*  ; Outputs: hl: Updated text pointer
040D48             1864*  ;         de: Value
040D48             1865*  ;         a: Terminator (spaces skipped)
040D48             1866*  ;         f: Carry set if valid number, otherwise reset
040D48             1867*  ; Destroys: a, d, e, h, l, f
040D48             1868*  ;------------------------------------------------------------------------
040D48             1869*  asc_to_s24:
040D48 3E 01       1870*      ld a,1 ; set sign flag
040D4A 32 96 0D 04 1871*      ld (@sign),a ; store sign flag
040D4E             1872*  
040D4E 11 00 00 00 1873*      ld de, 0 ; initialise de
040D52             1874*      ; call _skip_spaces ; skip whitespace
040D52             1875*  
040D52 7E          1876*      ld a, (hl) ; read first character
040D53 B7          1877*      or a ; check for end of string
040D54 C8          1878*      ret z ; return with no carry if not
040D55             1879*  
040D55 C5          1880*      push bc ; preserve bc
040D56             1881*  
040D56 FE 2D       1882*      cp '-' ; check for negative number
040D58 C2 62 0D 04 1883*      jp nz,@loop ; number is positive, nothing more to do
040D5C AF          1884*      xor a ; sign flag to zero
040D5D 32 96 0D 04 1885*      ld (@sign),a ; store sign flag
040D61 23          1886*      inc hl ; skip '-'
040D62             1887*  
040D62             1888*  @loop:
040D62 7E          1889*      ld a, (hl)
040D63 D6 30       1890*      sub '0' ; normalise to 0
040D65 38 19       1891*      jr c, @integer_end ; return if < ascii '0'
040D67 FE 0A       1892*      cp 10 ; check if >= 10
040D69 30 15       1893*      jr nc, @integer_end ; return if >= 10
040D6B E5          1894*      push hl ; stack hl
040D6C D5          1895*      push de ; ld hl, de
040D6D E1          1896*      pop hl
040D6E E5          1897*      push hl ; ld bc, hl
040D6F C1          1898*      pop bc
040D70 29          1899*      add hl, hl ; x 2
040D71 29          1900*      add hl, hl ; x 4
040D72 09          1901*      add hl, bc ; x 5
040D73 29          1902*      add hl, hl ; x 10
040D74 01 00 00 00 1903*      ld bc, 0
040D78 4F          1904*      ld c, a ; ld bcu, a
040D79 09          1905*      add hl, bc ; add bcu to hl
040D7A E5          1906*      push hl ; ld de, hl
040D7B D1          1907*      pop de
040D7C E1          1908*      pop hl ; restore hl
040D7D 23          1909*      inc hl
040D7E 18 E2       1910*      jr @loop
040D80             1911*  
040D80             1912*  @integer_end:
040D80 C1          1913*      pop bc ; send bc back how she came in
040D81 3A 96 0D 04 1914*      ld a, (@sign) ; get sign flag
040D85 3D          1915*      dec a ; check if negative
040D86 F2 94 0D 04 1916*      jp p,@pos ; positive number
040D8A             1917*  
040D8A             1918*  ; Negate de
040D8A E5          1919*      push hl ; save text pointer
040D8B 21 00 00 00 1920*      ld hl, 0
040D8F AF          1921*      xor a ; clear carry
040D90 ED 52       1922*      sbc hl, de ; subtract DE from HL
040D92 EB          1923*      ex de, hl ; DE = 0-HL
040D93 E1          1924*      pop hl ; restore text pointer
040D94             1925*  
040D94             1926*  @pos:
040D94 37          1927*      scf ; we have a valid number so set carry
040D95 C9          1928*      ret
040D96             1929*  
040D96 00          1930*  @sign: db 0 ; sign flag buffer
040D97             1931*  
040D97             1932*  
040D97             1933*  ;------------------------------------------------------------------------
040D97             1934*  ; Read a number and convert to binary (decimal only)
040D97             1935*  ; Inputs: hl: Pointer in string buffer
040D97             1936*  ; Outputs: hl: Updated text pointer
040D97             1937*  ;         de: Value
040D97             1938*  ;         a: Terminator (spaces skipped)
040D97             1939*  ;         f: Carry set if valid number, otherwise reset
040D97             1940*  ; Destroys: a, d, e, h, l, f
040D97             1941*  ;------------------------------------------------------------------------
040D97             1942*  asc_to_s168:
040D97 3E 01       1943*      ld a,1 ; set sign flag
040D99 32 56 0E 04 1944*      ld (@sign),a ; store sign flag
040D9D             1945*  
040D9D 11 00 00 00 1946*      ld de, 0 ; initialise de
040DA1 ED 53 4E 0E 1947*      ld (@result), de ; clear low bytes of result buffer
       04          
040DA6 ED 53 52 0E 1948*      ld (@scratch), de ; clear low bytes of scratch buffer
       04          
040DAB             1949*  
040DAB             1950*      ; call _skip_spaces ; skip whitespace
040DAB             1951*  
040DAB 7E          1952*      ld a, (hl) ; read first character
040DAC B7          1953*      or a ; check for end of string
040DAD C8          1954*      ret z ; return with no carry if not
040DAE             1955*  
040DAE C5          1956*      push bc ; preserve bc
040DAF             1957*  
040DAF FE 2D       1958*      cp '-' ; check for negative number
040DB1 C2 BB 0D 04 1959*      jp nz,@loop ; number is positive, nothing more to do
040DB5 AF          1960*      xor a ; sign flag to zero
040DB6 32 56 0E 04 1961*      ld (@sign),a ; store sign flag
040DBA 23          1962*      inc hl ; skip '-'
040DBB             1963*  
040DBB             1964*  @loop:
040DBB 7E          1965*      ld a, (hl)
040DBC             1966*  
040DBC             1967*  ; chcek for decimal point
040DBC FE 2E       1968*      cp '.' ; check for decimal point
040DBE CA FF 0D 04 1969*      jp z,@fractional_start ; jump to fractional part
040DC2             1970*  
040DC2             1971*  ; process integer part
040DC2 D6 30       1972*      sub '0' ; normalise to 0
040DC4 38 19       1973*      jr c, @integer_end ; return if < ascii '0'
040DC6 FE 0A       1974*      cp 10 ; check if >= 10
040DC8 30 15       1975*      jr nc, @integer_end ; return if >= 10
040DCA E5          1976*      push hl ; stack hl
040DCB D5          1977*      push de ; ld hl, de
040DCC E1          1978*      pop hl
040DCD E5          1979*      push hl ; ld bc, hl
040DCE C1          1980*      pop bc
040DCF 29          1981*      add hl, hl ; x 2
040DD0 29          1982*      add hl, hl ; x 4
040DD1 09          1983*      add hl, bc ; x 5
040DD2 29          1984*      add hl, hl ; x 10
040DD3 01 00 00 00 1985*      ld bc, 0
040DD7 4F          1986*      ld c, a ; ld bcu, a
040DD8 09          1987*      add hl, bc ; add bcu to hl
040DD9 E5          1988*      push hl ; ld de, hl
040DDA D1          1989*      pop de
040DDB E1          1990*      pop hl ; restore hl
040DDC 23          1991*      inc hl
040DDD 18 DC       1992*      jr @loop
040DDF             1993*  
040DDF             1994*  @integer_end:
040DDF ED 53 4F 0E 1995*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       04          
040DE4             1996*  
040DE4             1997*  @end:
040DE4 C1          1998*      pop bc ; send bc back how she came in
040DE5 ED 5B 4E 0E 1999*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       04          
040DEA 3A 56 0E 04 2000*      ld a, (@sign) ; get sign flag
040DEE 3D          2001*      dec a ; check if negative
040DEF F2 FD 0D 04 2002*      jp p,@pos ; positive number
040DF3             2003*  
040DF3             2004*  ; Negate de
040DF3 E5          2005*      push hl ; save text pointer
040DF4 21 00 00 00 2006*      ld hl, 0
040DF8 AF          2007*      xor a ; clear carry
040DF9 ED 52       2008*      sbc hl, de ; subtract DE from HL
040DFB EB          2009*      ex de, hl ; DE = 0-HL
040DFC E1          2010*      pop hl ; restore text pointer
040DFD             2011*  
040DFD             2012*  @pos:
040DFD 37          2013*      scf ; we have a valid number so set carry
040DFE C9          2014*      ret
040DFF             2015*  
040DFF             2016*  @fractional_start:
040DFF DD E5       2017*      push ix                    ; preserve ix
040E01 ED 53 4F 0E 2018*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       04          
040E06 06 03       2019*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
040E08 11 00 00 00 2020*      ld de, 0                   ; Initialize DE as the fractional accumulator
040E0C DD 21 57 0E 2021*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       04          
040E11 23          2022*      inc hl                     ; Skip decimal point
040E12             2023*  
040E12             2024*  @fractional_loop:
040E12 7E          2025*      ld a, (hl)                 ; Load next character
040E13 D6 30       2026*      sub '0'                    ; Normalize ASCII to decimal
040E15 38 1C       2027*      jr c, @end_fraction        ; Exit if < '0'
040E17 FE 0A       2028*      cp 10
040E19 30 18       2029*      jr nc, @end_fraction       ; Exit if >= 10
040E1B             2030*  
040E1B             2031*      ; Multiply the current fractional accumulator by 10
040E1B E5          2032*      push hl                    ; Save char pointer
040E1C F5          2033*      push af                    ; Save the digit
040E1D EB          2034*      ex de, hl
040E1E E5          2035*      push hl
040E1F 29          2036*      add hl,hl ; * 2
040E20 29          2037*      add hl,hl ; * 4
040E21 D1          2038*      pop de
040E22 19          2039*      add hl,de ; * 5
040E23 29          2040*      add hl,hl ; * 10
040E24 11 00 00 00 2041*      ld de, 0                   ; Clear DEU
040E28 F1          2042*      pop af                     ; Restore the current digit
040E29 5F          2043*      ld e, a                    ; Load the digit into E
040E2A 19          2044*      add hl, de                 ; Add the digit to the accumulator
040E2B EB          2045*      ex de, hl                  ; Result back to DE
040E2C ED 32 03    2046*      lea ix,ix+3                ; Advance IX to the next scaling factor
040E2F E1          2047*      pop hl                     ; Restore char pointer
040E30 23          2048*      inc hl                     ; Move to the next character
040E31 10 DF       2049*      djnz @fractional_loop      ; Loop if more digits to process
040E33             2050*  
040E33             2051*  @end_fraction:
040E33             2052*  ; Final scaling based on number of fractional digits processed
040E33 ED 53 53 0E 2053*      ld (@scratch+1), de          ; Shift fractional part up a byte
       04          
040E38 2A 52 0E 04 2054*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
040E3C             2055*  
040E3C DD 17 00    2056*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
040E3F CD F8 01 04 2057*      call udiv24                ; Perform 24-bit division to scale down
040E43 7B          2058*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
040E44 32 4E 0E 04 2059*      ld (@result), a            ; Store fractional part in result buffer
040E48 DD E1       2060*      pop ix                     ; Restore ix
040E4A C3 E4 0D 04 2061*      jp @end                    ; Final sign check and flag setup
040E4E             2062*  
040E4E             2063*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
040E52             2064*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
040E56 00          2065*  @sign: db 0                    ; Sign flag buffer
040E57             2066*  
040E57             2067*  powers_of_10:
040E57 01 00 00    2068*      dl 1                       ; 10^0
040E5A 0A 00 00    2069*      dl 10                      ; 10^1
040E5D 64 00 00    2070*      dl 100                     ; 10^2
040E60 E8 03 00    2071*      dl 1000                    ; 10^3
040E63 10 27 00    2072*      dl 10000                   ; 10^4
040E66             0037   
040E66             0038   ; --- INITIALIZATION ---
040E66             0039   init:
040E66 C9          0040       ret
040E67             0041   
040E67             0042   ; --- MAIN PROGRAM ---
040E67             0043   main:
040E67 AF          0044       xor a
040E68 CD 1A 0B 04 0045       call dumpRegistersHex
040E6C C9          0046       ret
