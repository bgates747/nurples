PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       db "MOS"
040043 00          0010       db 00h
040044 01          0011       db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD DE 49 04 0020       call init
040050 CD DF 49 04 0021       call main
040054             0022   
040054             0023   exit:
040054             0024   
040054 FD E1       0025       pop iy
040056 DD E1       0026       pop ix
040058 D1          0027       pop de
040059 C1          0028       pop bc
04005A F1          0029       pop af
04005B 21 00 00 00 0030       ld hl,0
04005F             0031   
04005F C9          0032       ret
040060             0033   
040060             0034   ; --- MAIN PROGRAM ---
040060             0035   ; APPLICATION INCLUDES
040060             0036       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,@F ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*  @@:
040060             0016*      ENDMACRO
040060             0017*  
040060             0018*  ; Simulated call to subroutine at IX
040060             0019*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0020*  ; outputs: whatever the subroutine does, including IX and BC
040060             0021*  ; destroys: only what the subroutine does, but always BC
040060             0022*      MACRO callIX
040060             0023*      ld bc,@F ; Address of first instruction after the jump
040060             0024*      push bc ; which constitutes the return address
040060             0025*      jp (ix) ; Jump to the address in IX
040060             0026*  @@:
040060             0027*      ENDMACRO
040060             0028*  
040060             0029*  ; Simulated call to soubroutinte at IY
040060             0030*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0031*  ; outputs: whatever the subroutine does, including IY and BC
040060             0032*  ; destroys: only what the subroutine does, but always BC
040060             0033*      MACRO callIY
040060             0034*      ld bc,@F ; Address of first instruction after the jump
040060             0035*      push bc ; which constitutes the return address
040060             0036*      jp (iy) ; Jump to the address in IY
040060             0037*  @@:
040060             0038*      ENDMACRO
040060             0039*  
040060             0040*  ; put the value in HLU into the accumulator
040060             0041*  ; destroys: af
040060             0042*      MACRO HLU_TO_A
040060             0043*      push hl ; 4 cycles
040060             0044*      inc sp ; 1 cycle
040060             0045*      pop af ; 4 cycles
040060             0046*      dec sp ; 1 cycle
040060             0047*      ; 10 cycles total
040060             0048*      ENDMACRO
040060             0049*  
040060             0050*  A_TO_HLU:
040060             0051*      ; call is 7 cycles
040060 22 6D 00 04 0052*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0053*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0054*      ld hl,(@scratch) ; 7 cycles
04006C C9          0055*      ret ; 6 cycles
04006D             0056*      ; 25 cycles total
04006D 00 00 00    0057*  @scratch: dl 0
040070             0058*  
040070             0059*      ; TODO: implement this
040070             0060*      ; MACRO A_TO_HLU
040070             0061*      ;     push.s af
040070             0062*      ;     inc sp
040070             0063*      ;     push.s hl
040070             0064*      ;     pop hl
040070             0065*      ;     inc sp
040070             0066*      ;     inc sp
040070             0067*      ; ENDMACRO
040070             0068*  
040070             0069*      MACRO PUSH_ALL
040070             0070*      ex af,af'
040070             0071*      exx
040070             0072*      push af
040070             0073*      push hl
040070             0074*      push bc
040070             0075*      push de
040070             0076*  
040070             0077*      ex af,af'
040070             0078*      exx
040070             0079*      push af
040070             0080*      push hl
040070             0081*      push bc
040070             0082*      push de
040070             0083*      push ix
040070             0084*      push iy
040070             0085*      ENDMACRO
040070             0086*  
040070             0087*      MACRO POP_ALL
040070             0088*      pop iy
040070             0089*      pop ix
040070             0090*      pop de
040070             0091*      pop bc
040070             0092*      pop hl
040070             0093*      pop af
040070             0094*      ex af,af'
040070             0095*      exx
040070             0096*  
040070             0097*      pop de
040070             0098*      pop bc
040070             0099*      pop hl
040070             0100*      pop af
040070             0101*      ex af,af'
040070             0102*      exx
040070             0103*      ENDMACRO
040070             0104*  
040070             0105*  ; Print a zero-terminated string inline with code, e.g.:
040070             0106*  ;
040070             0107*  ;    call printInline
040070             0108*  ;    ASCIZ "Hello, world!\r\n"
040070             0109*  ;
040070             0110*  ; Destroys: HL,AF
040070             0111*  printInline:
040070 E1          0112*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0113*      call printString ; HL advances to end of string
040075 E5          0114*      push hl ; restore the return address = pointer to end of string
040076 C9          0115*      ret
040077             0116*  
040077             0117*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0118*  ; Print a zero-terminated string
040077             0119*  ; HL: Pointer to string
040077             0120*  printString:
040077 C5          0121*      PUSH BC
040078 01 00 00 00 0122*      LD BC,0
04007C 3E 00       0123*      LD A,0
04007E 5B DF       0124*      RST.LIL 18h
040080 C1          0125*      POP BC
040081 C9          0126*      RET
040082             0127*  ; print a VDU sequence
040082             0128*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0129*  sendVDUsequence:
040082 C5          0130*      PUSH BC
040083 01 00 00 00 0131*      LD BC, 0
040087 4E          0132*      LD C, (HL)
040088 5B DF       0133*      RST.LIL 18h
04008A C1          0134*      POP BC
04008B C9          0135*      RET
04008C             0136*  ; Print Newline sequence to VDP
04008C             0137*  printNewLine:
04008C F5          0138*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0139*      LD A, '\r'
04008F 5B D7       0140*      RST.LIL 10h
040091 3E 0A       0141*      LD A, '\n'
040093 5B D7       0142*      RST.LIL 10h
040095 F1          0143*      pop af
040096 C9          0144*      RET
040097             0145*  
040097             0146*  ; Print a 24-bit HEX number
040097             0147*  ; HLU: Number to print
040097             0148*  printHex24:
040097             0149*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0150*      CALL printHex8
04009F             0151*  ; Print a 16-bit HEX number
04009F             0152*  ; HL: Number to print
04009F             0153*  printHex16:
04009F 7C          0154*      LD A,H
0400A0 CD A5 00 04 0155*      CALL printHex8
0400A4 7D          0156*      LD A,L
0400A5             0157*  ; Print an 8-bit HEX number
0400A5             0158*  ; A: Number to print
0400A5             0159*  printHex8:
0400A5 4F          0160*      LD C,A
0400A6 1F          0161*      RRA
0400A7 1F          0162*      RRA
0400A8 1F          0163*      RRA
0400A9 1F          0164*      RRA
0400AA CD AF 00 04 0165*      CALL @F
0400AE 79          0166*      LD A,C
0400AF             0167*  @@:
0400AF E6 0F       0168*      AND 0Fh
0400B1 C6 90       0169*      ADD A,90h
0400B3 27          0170*      DAA
0400B4 CE 40       0171*      ADC A,40h
0400B6 27          0172*      DAA
0400B7 5B D7       0173*      RST.LIL 10h
0400B9 C9          0174*      RET
0400BA             0175*  
0400BA             0176*  printHexA:
0400BA F5          0177*      push af
0400BB C5          0178*      push bc
0400BC CD A5 00 04 0179*      call printHex8
0400C0 3E 20       0180*      ld a,' '
0400C2 5B D7       0181*      rst.lil 10h
0400C4 C1          0182*      pop bc
0400C5 F1          0183*      pop af
0400C6 C9          0184*      ret
0400C7             0185*  
0400C7             0186*  printHexHL:
0400C7 F5          0187*      push af
0400C8 C5          0188*      push bc
0400C9 CD 9F 00 04 0189*      call printHex16
0400CD 3E 20       0190*      ld a,' '
0400CF 5B D7       0191*      rst.lil 10h
0400D1 C1          0192*      pop bc
0400D2 F1          0193*      pop af
0400D3 C9          0194*      ret
0400D4             0195*  
0400D4             0196*  printHexUHL:
0400D4 F5          0197*      push af
0400D5 C5          0198*      push bc
0400D6 CD 97 00 04 0199*      call printHex24
0400DA 3E 20       0200*      ld a,' '
0400DC 5B D7       0201*      rst.lil 10h
0400DE C1          0202*      pop bc
0400DF F1          0203*      pop af
0400E0 C9          0204*      ret
0400E1             0205*  
0400E1             0206*  printHexAUHL:
0400E1 F5          0207*      push af
0400E2 C5          0208*      push bc
0400E3 CD A5 00 04 0209*      call printHex8
0400E7 3E 2E       0210*      ld a,'.'
0400E9 5B D7       0211*      rst.lil 10h
0400EB CD 97 00 04 0212*      call printHex24
0400EF 3E 20       0213*      ld a,' '
0400F1 5B D7       0214*      rst.lil 10h
0400F3 C1          0215*      pop bc
0400F4 F1          0216*      pop af
0400F5 C9          0217*      ret
0400F6             0218*  
0400F6             0219*  printHexABHL:
0400F6             0220*  ; preserve registers
0400F6 C5          0221*      push bc ; b will be ok c will not
0400F7 F5          0222*      push af ; will get totally destroyed
0400F8             0223*  ; print a
0400F8 CD A5 00 04 0224*      call printHex8
0400FC             0225*  ; print b
0400FC 78          0226*      ld a,b
0400FD CD A5 00 04 0227*      call printHex8
040101             0228*  ; print hl
040101 CD 9F 00 04 0229*      call printHex16
040105             0230*  ; restore registers
040105 F1          0231*      pop af
040106 C1          0232*      pop bc
040107 C9          0233*      ret
040108             0234*  
040108             0235*  printHexBHL:
040108             0236*  ; preserve registers
040108 C5          0237*      push bc ; b will be ok c will not
040109 F5          0238*      push af ; will get totally destroyed
04010A             0239*  ; print b
04010A 78          0240*      ld a,b
04010B CD A5 00 04 0241*      call printHex8
04010F             0242*  ; print hl
04010F CD 9F 00 04 0243*      call printHex16
040113             0244*  ; restore registers
040113 F1          0245*      pop af
040114 C1          0246*      pop bc
040115 C9          0247*      ret
040116             0248*  
040116             0249*  printHexCDE:
040116             0250*  ; preserve registers
040116 C5          0251*      push bc ; b will be ok c will not
040117 F5          0252*      push af ; will get totally destroyed
040118             0253*  ; print c
040118 79          0254*      ld a,c
040119 CD A5 00 04 0255*      call printHex8
04011D             0256*  ; print de
04011D EB          0257*      ex de,hl
04011E CD 9F 00 04 0258*      call printHex16
040122 EB          0259*      ex de,hl
040123             0260*  ; restore registers
040123 F1          0261*      pop af
040124 C1          0262*      pop bc
040125 C9          0263*      ret
040126             0264*  
040126             0265*  printHexUIX:
040126             0266*  ; store everything in scratch
040126 22 9F 05 04 0267*      ld (uhl),hl
04012A ED 43 A2 05 0268*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0269*      ld (ude),de
       04          
040134 DD 22 A8 05 0270*      ld (uix),ix
       04          
040139 FD 22 AB 05 0271*      ld (uiy),iy
       04          
04013E F5          0272*      push af ; fml
04013F             0273*  
04013F 21 36 05 04 0274*      ld hl,str_ixu
040143 CD 77 00 04 0275*      call printString
040147 2A A8 05 04 0276*      ld hl,(uix)
04014B CD 97 00 04 0277*      call printHex24
04014F CD 8C 00 04 0278*      call printNewLine
040153             0279*  
040153             0280*  ; restore everything
040153 2A 9F 05 04 0281*      ld hl, (uhl)
040157 ED 4B A2 05 0282*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0283*      ld de, (ude)
       04          
040161 DD 2A A8 05 0284*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0285*      ld iy, (uiy)
       04          
04016B F1          0286*      pop af
04016C             0287*  ; all done
04016C C9          0288*      ret
04016D             0289*  
04016D             0290*  ; Print a 0x HEX prefix
04016D             0291*  DisplayHexPrefix:
04016D 3E 30       0292*      LD A, '0'
04016F 5B D7       0293*      RST.LIL 10h
040171 3E 78       0294*      LD A, 'x'
040173 5B D7       0295*      RST.LIL 10h
040175 C9          0296*      RET
040176             0297*  
040176             0298*      MACRO printDecBC
040176             0299*      push hl
040176             0300*      push bc
040176             0301*      pop hl
040176             0302*      call printDec
040176             0303*      pop hl
040176             0304*      ENDMACRO
040176             0305*  
040176             0306*      MACRO printDecDE
040176             0307*      push hl
040176             0308*      push de
040176             0309*      pop hl
040176             0310*      call printDec
040176             0311*      pop hl
040176             0312*      ENDMACRO
040176             0313*  
040176             0314*      MACRO printDecHL
040176             0315*      call printDec
040176             0316*      ENDMACRO
040176             0317*  
040176             0318*      MACRO printDecIX
040176             0319*      push hl
040176             0320*      push ix
040176             0321*      pop hl
040176             0322*      call printDec
040176             0323*      pop hl
040176             0324*      ENDMACRO
040176             0325*  
040176             0326*      MACRO printDecIY
040176             0327*      push hl
040176             0328*      push iy
040176             0329*      pop hl
040176             0330*      call printDec
040176             0331*      pop hl
040176             0332*      ENDMACRO
040176             0333*  
040176             0334*  
040176             0335*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0336*  ; HL : Value to print
040176             0337*  ; preserves all registers and flags
040176             0338*  printDec:
040176             0339*  ; BEGIN MY CODE
040176             0340*  ; back up all the things
040176 F5          0341*      push af
040177 C5          0342*      push bc
040178 D5          0343*      push de
040179 E5          0344*      push hl
04017A             0345*  ; END MY CODE
04017A 11 A2 01 04 0346*      LD DE, _printDecBuffer
04017E CD B2 01 04 0347*      CALL u24_to_ascii
040182             0348*  ; BEGIN MY CODE
040182             0349*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0350*      LD HL, _printDecBuffer
040186 06 07       0351*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0352*  @loop:
040188 7E          0353*      LD A, (HL)
040189 FE 30       0354*      CP '0'
04018B C2 95 01 04 0355*      JP NZ, @done
04018F 3E 20       0356*      LD A, ' '
040191 77          0357*      LD (HL), A
040192 23          0358*      INC HL
040193             0359*      ; CALL vdu_cursor_forward
040193 10 F3       0360*      DJNZ @loop
040195             0361*  @done:
040195             0362*  ; END MY CODE
040195 21 A2 01 04 0363*      LD HL, _printDecBuffer
040199 CD 77 00 04 0364*      CALL printString
04019D             0365*  ; BEGIN MY CODE
04019D             0366*  ; restore all the things
04019D E1          0367*      pop hl
04019E D1          0368*      pop de
04019F C1          0369*      pop bc
0401A0 F1          0370*      pop af
0401A1             0371*  ; END MY CODE
0401A1 C9          0372*      RET
0401A2 00 00 00 00 0373*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0374*  
0401B2             0375*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0376*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0377*  ; so it will allways be 8 characters length
0401B2             0378*  ; HL : Value to convert to string
0401B2             0379*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0380*  u24_to_ascii:
0401B2 01 80 69 67 0381*      LD BC,-10000000
0401B6 CD E9 01 04 0382*      CALL @one_digit
0401BA 01 C0 BD F0 0383*      LD BC,-1000000
0401BE CD E9 01 04 0384*      CALL @one_digit
0401C2 01 60 79 FE 0385*      LD BC,-100000
0401C6 CD E9 01 04 0386*      CALL @one_digit
0401CA 01 F0 D8 FF 0387*      LD BC,-10000
0401CE CD E9 01 04 0388*      CALL @one_digit
0401D2 01 18 FC FF 0389*      LD BC,-1000
0401D6 CD E9 01 04 0390*      CALL @one_digit
0401DA 01 9C FF FF 0391*      LD BC,-100
0401DE CD E9 01 04 0392*      CALL @one_digit
0401E2 0E F6       0393*      LD C,-10
0401E4 CD E9 01 04 0394*      CALL @one_digit
0401E8 48          0395*      LD C,B
0401E9             0396*  @one_digit:
0401E9 3E 2F       0397*      LD A,'0'-1
0401EB             0398*  @divide_me:
0401EB 3C          0399*      INC A
0401EC 09          0400*      ADD HL,BC
0401ED 38 FC       0401*      JR C,@divide_me
0401EF ED 42       0402*      SBC HL,BC
0401F1 12          0403*      LD (DE),A
0401F2 13          0404*      INC DE
0401F3 C9          0405*      RET
0401F4             0406*  
0401F4             0407*  print_u24:
0401F4 D5          0408*      push de
0401F5 E5          0409*      push hl
0401F6 11 A2 01 04 0410*      ld de,_printDecBuffer
0401FA CD B2 01 04 0411*      call u24_to_ascii
0401FE 21 A2 01 04 0412*      ld hl,_printDecBuffer
040202 CD 77 00 04 0413*      call printString
040206 3E 20       0414*      ld a,' '
040208 5B D7       0415*      rst.lil 10h
04020A E1          0416*      pop hl
04020B D1          0417*      pop de
04020C C9          0418*      ret
04020D             0419*  
04020D             0420*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0421*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0422*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0423*  u168_to_ascii:
04020D             0424*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0425*      ld a,' '
04020F 12          0426*      ld (de),a
040210 13          0427*      inc de
040211             0428*  ; Convert integer part
040211 E5          0429*      push hl ; Save HL (we’ll need the fractional part later)
040212 CD FB 06 04 0430*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0431*      ld bc, -10000
04021A CD 3D 02 04 0432*      call @one_int
04021E 01 18 FC FF 0433*      ld bc, -1000
040222 CD 3D 02 04 0434*      call @one_int
040226 01 9C FF FF 0435*      ld bc, -100
04022A CD 3D 02 04 0436*      call @one_int
04022E 0E F6       0437*      ld c, -10
040230 CD 3D 02 04 0438*      call @one_int
040234 48          0439*      ld c, b
040235 CD 3D 02 04 0440*      call @one_int
040239 C3 48 02 04 0441*      jp @frac ; Jump to fractional part conversion
04023D             0442*  @one_int:
04023D 3E 2F       0443*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0444*  @divide_me:
04023F 3C          0445*      inc a
040240 09          0446*      add hl, bc ; Accumulate until overflow
040241 38 FC       0447*      jr c, @divide_me
040243 ED 42       0448*      sbc hl, bc ; Remove excess after overflow
040245 12          0449*      ld (de), a ; Store ASCII digit
040246 13          0450*      inc de
040247 C9          0451*      ret
040248             0452*  ; Convert fractional part
040248             0453*  @frac:
040248 3E 2E       0454*      ld a, '.' ; Decimal point
04024A 12          0455*      ld (de), a
04024B 13          0456*      inc de
04024C E1          0457*      pop hl ; Restore HL with original fraction
04024D 06 03       0458*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0459*  @frac_loop:
04024F 26 0A       0460*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0461*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0462*      ld a, '0'
040255 84          0463*      add a, h ; Convert integer part to ASCII
040256 12          0464*      ld (de), a
040257 13          0465*      inc de
040258 10 F5       0466*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0467*  ; Add null terminator
04025A AF          0468*      xor a ; Null terminator
04025B 12          0469*      ld (de), a
04025C C9          0470*      ret
04025D             0471*  
04025D             0472*  print_u168:
04025D D5          0473*      push de
04025E E5          0474*      push hl
04025F 11 A2 01 04 0475*      ld de,_printDecBuffer
040263 CD 0D 02 04 0476*      call u168_to_ascii
040267 21 A2 01 04 0477*      ld hl,_printDecBuffer
04026B CD 77 00 04 0478*      call printString
04026F E1          0479*      pop hl
040270 D1          0480*      pop de
040271 C9          0481*      ret
040272             0482*  
040272             0483*  ; signed version of u168_to_ascii
040272             0484*  s168_to_ascii:
040272 D5          0485*      push de ; save starting address of buffer
040273 CD 94 06 04 0486*      call hlu_abs
040277 F5          0487*      push af ; save sign flag
040278 CD 0D 02 04 0488*      call u168_to_ascii
04027C F1          0489*      pop af ; restore sign flag
04027D D1          0490*      pop de ; restore starting address of buffer
04027E F0          0491*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0492*      ld a,'-'
040281 12          0493*      ld (de),a
040282 C9          0494*      ret
040283             0495*  
040283             0496*  print_s168:
040283 D5          0497*      push de
040284 E5          0498*      push hl
040285 11 A2 01 04 0499*      ld de,_printDecBuffer
040289 CD 72 02 04 0500*      call s168_to_ascii
04028D 21 A2 01 04 0501*      ld hl,_printDecBuffer
040291 CD 77 00 04 0502*      call printString
040295 E1          0503*      pop hl
040296 D1          0504*      pop de
040297 C9          0505*      ret
040298             0506*  
040298             0507*  print_s168_hl:
040298 F5          0508*      push af
040299 E5          0509*      push hl
04029A CD 83 02 04 0510*      call print_s168
04029E 3E 20       0511*      ld a,' '
0402A0 5B D7       0512*      rst.lil 10h
0402A2 E1          0513*      pop hl
0402A3 F1          0514*      pop af
0402A4 C9          0515*      ret
0402A5             0516*  
0402A5             0517*  print_s168_bc:
0402A5 F5          0518*      push af
0402A6 C5          0519*      push bc
0402A7 E5          0520*      push hl
0402A8 C5          0521*      push bc
0402A9 E1          0522*      pop hl
0402AA CD 83 02 04 0523*      call print_s168
0402AE 3E 20       0524*      ld a,' '
0402B0 5B D7       0525*      rst.lil 10h
0402B2 E1          0526*      pop hl
0402B3 C1          0527*      pop bc
0402B4 F1          0528*      pop af
0402B5 C9          0529*      ret
0402B6             0530*  
0402B6             0531*  print_s168_de:
0402B6 F5          0532*      push af
0402B7 D5          0533*      push de
0402B8 E5          0534*      push hl
0402B9 EB          0535*      ex de,hl
0402BA CD 83 02 04 0536*      call print_s168
0402BE 3E 20       0537*      ld a,' '
0402C0 5B D7       0538*      rst.lil 10h
0402C2 E1          0539*      pop hl
0402C3 D1          0540*      pop de
0402C4 F1          0541*      pop af
0402C5 C9          0542*      ret
0402C6             0543*  
0402C6             0544*  print_s168_hl_bc_de:
0402C6 F5          0545*      push af
0402C7 C5          0546*      push bc
0402C8 D5          0547*      push de
0402C9 E5          0548*      push hl
0402CA CD 83 02 04 0549*      call print_s168
0402CE 3E 20       0550*      ld a,' '
0402D0 5B D7       0551*      rst.lil 10h
0402D2 C5          0552*      push bc
0402D3 E1          0553*      pop hl
0402D4 CD 83 02 04 0554*      call print_s168
0402D8 3E 20       0555*      ld a,' '
0402DA 5B D7       0556*      rst.lil 10h
0402DC EB          0557*      ex de,hl
0402DD CD 83 02 04 0558*      call print_s168
0402E1 3E 20       0559*      ld a,' '
0402E3 5B D7       0560*      rst.lil 10h
0402E5 E1          0561*      pop hl
0402E6 D1          0562*      pop de
0402E7 C1          0563*      pop bc
0402E8 F1          0564*      pop af
0402E9 C9          0565*      ret
0402EA             0566*  
0402EA             0567*  print_s168_bc_de:
0402EA F5          0568*      push af
0402EB C5          0569*      push bc
0402EC D5          0570*      push de
0402ED C5          0571*      push bc
0402EE E1          0572*      pop hl
0402EF CD 83 02 04 0573*      call print_s168
0402F3 3E 20       0574*      ld a,' '
0402F5 5B D7       0575*      rst.lil 10h
0402F7 EB          0576*      ex de,hl
0402F8 CD 83 02 04 0577*      call print_s168
0402FC 3E 20       0578*      ld a,' '
0402FE 5B D7       0579*      rst.lil 10h
040300 E1          0580*      pop hl
040301 D1          0581*      pop de
040302 C1          0582*      pop bc
040303 F1          0583*      pop af
040304 C9          0584*      ret
040305             0585*  
040305             0586*  print_s168_a:
040305 F5          0587*      push af
040306 C5          0588*      push bc
040307 E5          0589*      push hl
040308 21 00 00 00 0590*      ld hl,0
04030C 6F          0591*      ld l,a
04030D CD 98 02 04 0592*      call print_s168_hl
040311 E1          0593*      pop hl
040312 C1          0594*      pop bc
040313 F1          0595*      pop af
040314 C9          0596*      ret
040315             0597*  
040315             0598*  ; #### new functions added by Brandon R. Gates ####
040315             0599*  
040315             0600*  ; print the binary representation of the 8-bit value in a
040315             0601*  ; destroys a, hl, bc
040315             0602*  printBin8:
040315 06 08       0603*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0604*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0605*      ; (which will be the high bit of the value in a)
04031B             0606*  @loop:
04031B 07          0607*      rlca ; put the next highest bit into carry
04031C 38 04       0608*      jr c,@one
04031E 36 30       0609*      ld (hl),'0'
040320 18 02       0610*      jr @next_bit
040322             0611*  @one:
040322 36 31       0612*      ld (hl),'1'
040324             0613*  @next_bit:
040324 23          0614*      inc hl
040325 10 F4       0615*      djnz @loop
040327             0616*  ; print it
040327 21 32 03 04 0617*      ld hl,@cmd
04032B 01 08 00 00 0618*      ld bc,@end-@cmd
04032F 5B DF       0619*      rst.lil $18
040331 C9          0620*      ret
040332             0621*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0622*  @end:
04033A             0623*  
04033A             0624*  ; print the binary representation of the 8-bit value in a
04033A             0625*  ; in reverse order (lsb first)
04033A             0626*  ; destroys a, hl, bc
04033A             0627*  printBin8Rev:
04033A 06 08       0628*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0629*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0630*      ; (which will be the high bit of the value in a)
040340             0631*  @loop:
040340 0F          0632*      rrca ; put the next lowest bit into carry
040341 38 04       0633*      jr c,@one
040343 36 30       0634*      ld (hl),'0'
040345 18 02       0635*      jr @next_bit
040347             0636*  @one:
040347 36 31       0637*      ld (hl),'1'
040349             0638*  @next_bit:
040349 23          0639*      inc hl
04034A 10 F4       0640*      djnz @loop
04034C             0641*  ; print it
04034C 21 57 03 04 0642*      ld hl,@cmd
040350 01 08 00 00 0643*      ld bc,@end-@cmd
040354 5B DF       0644*      rst.lil $18
040356 C9          0645*      ret
040357             0646*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0647*  @end:
04035F             0648*  
04035F             0649*  ; print registers to screen in hexidecimal format
04035F             0650*  ; inputs: none
04035F             0651*  ; outputs: values of every register printed to screen
04035F             0652*  ;    values of each register in global scratch memory
04035F             0653*  ; destroys: nothing
04035F             0654*  stepRegistersHex:
04035F             0655*  ; store everything in scratch
04035F 22 9F 05 04 0656*      ld (uhl),hl
040363 ED 43 A2 05 0657*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0658*      ld (ude),de
       04          
04036D DD 22 A8 05 0659*      ld (uix),ix
       04          
040372 FD 22 AB 05 0660*      ld (uiy),iy
       04          
040377 F5          0661*      push af ; fml
040378 E1          0662*      pop hl ; thanks, zilog
040379 22 9C 05 04 0663*      ld (uaf),hl
04037D F5          0664*      push af ; dammit
04037E             0665*  
04037E             0666*  ; home the cursor
04037E             0667*      ; call vdu_home_cursor
04037E             0668*  
04037E             0669*  ; print each register
04037E 21 22 05 04 0670*      ld hl,str_afu
040382 CD 77 00 04 0671*      call printString
040386 2A 9C 05 04 0672*      ld hl,(uaf)
04038A CD 97 00 04 0673*      call printHex24
04038E CD 8C 00 04 0674*      call printNewLine
040392             0675*  
040392 21 27 05 04 0676*      ld hl,str_hlu
040396 CD 77 00 04 0677*      call printString
04039A 2A 9F 05 04 0678*      ld hl,(uhl)
04039E CD 97 00 04 0679*      call printHex24
0403A2 CD 8C 00 04 0680*      call printNewLine
0403A6             0681*  
0403A6 21 2C 05 04 0682*      ld hl,str_bcu
0403AA CD 77 00 04 0683*      call printString
0403AE 2A A2 05 04 0684*      ld hl,(ubc)
0403B2 CD 97 00 04 0685*      call printHex24
0403B6 CD 8C 00 04 0686*      call printNewLine
0403BA             0687*  
0403BA 21 31 05 04 0688*      ld hl,str_deu
0403BE CD 77 00 04 0689*      call printString
0403C2 2A A5 05 04 0690*      ld hl,(ude)
0403C6 CD 97 00 04 0691*      call printHex24
0403CA CD 8C 00 04 0692*      call printNewLine
0403CE             0693*  
0403CE 21 36 05 04 0694*      ld hl,str_ixu
0403D2 CD 77 00 04 0695*      call printString
0403D6 2A A8 05 04 0696*      ld hl,(uix)
0403DA CD 97 00 04 0697*      call printHex24
0403DE CD 8C 00 04 0698*      call printNewLine
0403E2             0699*  
0403E2 21 3B 05 04 0700*      ld hl,str_iyu
0403E6 CD 77 00 04 0701*      call printString
0403EA 2A AB 05 04 0702*      ld hl,(uiy)
0403EE CD 97 00 04 0703*      call printHex24
0403F2 CD 8C 00 04 0704*      call printNewLine
0403F6             0705*  
0403F6             0706*      ; call vsync
0403F6             0707*  
0403F6 CD 8C 00 04 0708*      call printNewLine
0403FA             0709*  
0403FA             0710*  ; check for right shift key and quit if pressed
0403FA             0711*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0712*  @stayhere:
0403FE             0713*  ; 7 RightShift
0403FE DD CB 00 76 0714*      bit 6,(ix+0)
040402 20 02       0715*      jr nz,@RightShift
040404 18 F8       0716*      jr @stayhere
040406             0717*  @RightShift:
040406 DD CB 0E 86 0718*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0719*      ld a,%10000000
04040C             0720*      ; call multiPurposeDelay
04040C             0721*  
04040C             0722*  ; restore everything
04040C 2A 9F 05 04 0723*      ld hl, (uhl)
040410 ED 4B A2 05 0724*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0725*      ld de, (ude)
       04          
04041A DD 2A A8 05 0726*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0727*      ld iy, (uiy)
       04          
040424 F1          0728*      pop af
040425             0729*  ; all done
040425 C9          0730*      ret
040426             0731*  
040426             0732*  ; print registers to screen in hexidecimal format
040426             0733*  ; inputs: none
040426             0734*  ; outputs: values of every register printed to screen
040426             0735*  ;    values of each register in global scratch memory
040426             0736*  ; destroys: nothing
040426             0737*  dumpRegistersHex:
040426             0738*  ; store everything in scratch
040426 22 9F 05 04 0739*      ld (uhl),hl
04042A ED 43 A2 05 0740*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0741*      ld (ude),de
       04          
040434 DD 22 A8 05 0742*      ld (uix),ix
       04          
040439 FD 22 AB 05 0743*      ld (uiy),iy
       04          
04043E F5          0744*      push af ; fml
04043F E1          0745*      pop hl ; thanks, zilog
040440 22 9C 05 04 0746*      ld (uaf),hl
040444 F5          0747*      push af ; dammit
040445             0748*  
040445             0749*  ; home the cursor
040445             0750*      ; call vdu_home_cursor
040445             0751*      ; call printNewLine
040445             0752*  
040445             0753*  ; print each register
040445 21 22 05 04 0754*      ld hl,str_afu
040449 CD 77 00 04 0755*      call printString
04044D 2A 9C 05 04 0756*      ld hl,(uaf)
040451 CD 97 00 04 0757*      call printHex24
040455             0758*      ; call printNewLine
040455             0759*  
040455 21 27 05 04 0760*      ld hl,str_hlu
040459 CD 77 00 04 0761*      call printString
04045D 2A 9F 05 04 0762*      ld hl,(uhl)
040461 CD 97 00 04 0763*      call printHex24
040465             0764*      ; call printNewLine
040465             0765*  
040465 21 2C 05 04 0766*      ld hl,str_bcu
040469 CD 77 00 04 0767*      call printString
04046D 2A A2 05 04 0768*      ld hl,(ubc)
040471 CD 97 00 04 0769*      call printHex24
040475             0770*      ; call printNewLine
040475             0771*  
040475 21 31 05 04 0772*      ld hl,str_deu
040479 CD 77 00 04 0773*      call printString
04047D 2A A5 05 04 0774*      ld hl,(ude)
040481 CD 97 00 04 0775*      call printHex24
040485             0776*      ; call printNewLine
040485             0777*  
040485 21 36 05 04 0778*      ld hl,str_ixu
040489 CD 77 00 04 0779*      call printString
04048D 2A A8 05 04 0780*      ld hl,(uix)
040491 CD 97 00 04 0781*      call printHex24
040495             0782*      ; call printNewLine
040495             0783*  
040495 21 3B 05 04 0784*      ld hl,str_iyu
040499 CD 77 00 04 0785*      call printString
04049D 2A AB 05 04 0786*      ld hl,(uiy)
0404A1 CD 97 00 04 0787*      call printHex24
0404A5             0788*      ; call printNewLine
0404A5             0789*  
0404A5             0790*      ; call vdu_vblank
0404A5             0791*  
0404A5 CD 8C 00 04 0792*      call printNewLine
0404A9             0793*  ; restore everything
0404A9 2A 9F 05 04 0794*      ld hl, (uhl)
0404AD ED 4B A2 05 0795*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0796*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0797*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0798*      ld iy, (uiy)
       04          
0404C1 F1          0799*      pop af
0404C2             0800*  ; all done
0404C2 C9          0801*      ret
0404C3             0802*  
0404C3             0803*  dumpRegistersHexPrime:
0404C3 D9          0804*      exx
0404C4 08          0805*      ex af,af'
0404C5 CD 26 04 04 0806*      call dumpRegistersHex
0404C9 08          0807*      ex af,af'
0404CA D9          0808*      exx
0404CB C9          0809*      ret
0404CC             0810*  
0404CC             0811*  ; additionally dump prime registers
0404CC             0812*  ; inputs: none
0404CC             0813*  ; outputs: values of every register printed to screen
0404CC             0814*  ; destroys: nothing
0404CC             0815*  dumpRegistersHexAll:
0404CC CD 26 04 04 0816*      call dumpRegistersHex
0404D0 08          0817*      ex af,af'
0404D1 D9          0818*      exx
0404D2 CD 26 04 04 0819*      call dumpRegistersHex
0404D6 08          0820*      ex af,af'
0404D7 D9          0821*      exx
0404D8 C9          0822*      ret
0404D9             0823*  
0404D9             0824*  ; print hlu to screen in hexidecimal format
0404D9             0825*  ; inputs: none
0404D9             0826*  ; destroys: nothing
0404D9             0827*  print_hex_hl:
0404D9 F5          0828*      push af
0404DA E5          0829*      push hl
0404DB 21 27 05 04 0830*      ld hl,str_hlu
0404DF CD 77 00 04 0831*      call printString
0404E3 E1          0832*      pop hl
0404E4 E5          0833*      push hl
0404E5 CD 97 00 04 0834*      call printHex24
0404E9 3E 20       0835*      ld a,' '
0404EB 5B D7       0836*      rst.lil 10h
0404ED E1          0837*      pop hl
0404EE F1          0838*      pop af
0404EF C9          0839*      ret
0404F0             0840*  
0404F0             0841*  ; print bcu to screen in hexidecimal format
0404F0             0842*  ; inputs: none
0404F0             0843*  ; destroys: nothing
0404F0             0844*  print_hex_bc:
0404F0 F5          0845*      push af
0404F1 E5          0846*      push hl
0404F2 C5          0847*      push bc
0404F3 21 2C 05 04 0848*      ld hl,str_bcu
0404F7 CD 77 00 04 0849*      call printString
0404FB E1          0850*      pop hl
0404FC E5          0851*      push hl
0404FD CD 97 00 04 0852*      call printHex24
040501 3E 20       0853*      ld a,' '
040503 5B D7       0854*      rst.lil 10h
040505 C1          0855*      pop bc
040506 E1          0856*      pop hl
040507 F1          0857*      pop af
040508 C9          0858*      ret
040509             0859*  
040509             0860*  ; print deu to screen in hexidecimal format
040509             0861*  ; inputs: none
040509             0862*  ; destroys: nothing
040509             0863*  print_hex_de:
040509 F5          0864*      push af
04050A E5          0865*      push hl
04050B D5          0866*      push de
04050C 21 31 05 04 0867*      ld hl,str_deu
040510 CD 77 00 04 0868*      call printString
040514 E1          0869*      pop hl
040515 E5          0870*      push hl
040516 CD 97 00 04 0871*      call printHex24
04051A 3E 20       0872*      ld a,' '
04051C 5B D7       0873*      rst.lil 10h
04051E D1          0874*      pop de
04051F E1          0875*      pop hl
040520 F1          0876*      pop af
040521 C9          0877*      ret
040522             0878*  
040522 20 61 66 3D 0879*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0880*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0881*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0882*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0883*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0884*  str_iyu: db " iy=",0
       00          
040540             0885*  
040540             0886*  ; print udeuhl to screen in hexidecimal format
040540             0887*  ; inputs: none
040540             0888*  ; outputs: concatenated hexidecimal udeuhl
040540             0889*  ; destroys: nothing
040540             0890*  dumpUDEUHLHex:
040540             0891*  ; store everything in scratch
040540 22 9F 05 04 0892*      ld (uhl),hl
040544 ED 43 A2 05 0893*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0894*      ld (ude),de
       04          
04054E DD 22 A8 05 0895*      ld (uix),ix
       04          
040553 FD 22 AB 05 0896*      ld (uiy),iy
       04          
040558 F5          0897*      push af
040559             0898*  
040559             0899*  ; print each register
040559             0900*  
040559 21 93 05 04 0901*      ld hl,str_udeuhl
04055D CD 77 00 04 0902*      call printString
040561 2A A5 05 04 0903*      ld hl,(ude)
040565 CD 97 00 04 0904*      call printHex24
040569 3E 2E       0905*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0906*      rst.lil 10h
04056D 2A 9F 05 04 0907*      ld hl,(uhl)
040571 CD 97 00 04 0908*      call printHex24
040575 CD 8C 00 04 0909*      call printNewLine
040579             0910*  
040579             0911*  ; restore everything
040579 2A 9F 05 04 0912*      ld hl, (uhl)
04057D ED 4B A2 05 0913*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0914*      ld de, (ude)
       04          
040587 DD 2A A8 05 0915*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0916*      ld iy, (uiy)
       04          
040591 F1          0917*      pop af
040592             0918*  ; all done
040592 C9          0919*      ret
040593             0920*  
040593 75 64 65 2E 0921*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0922*  
04059C             0923*  ; global scratch memory for registers
04059C 00 00 00    0924*  uaf: dl 0
04059F 00 00 00    0925*  uhl: dl 0
0405A2 00 00 00    0926*  ubc: dl 0
0405A5 00 00 00    0927*  ude: dl 0
0405A8 00 00 00    0928*  uix: dl 0
0405AB 00 00 00    0929*  uiy: dl 0
0405AE 00 00 00    0930*  usp: dl 0
0405B1 00 00 00    0931*  upc: dl 0
0405B4             0932*  
0405B4             0933*  ; inputs: whatever is in the flags register
0405B4             0934*  ; outputs: binary representation of flags
0405B4             0935*  ;          with a header so we know which is what
0405B4             0936*  ; destroys: nothing
0405B4             0937*  ; preserves: everything
0405B4             0938*  dumpFlags:
0405B4             0939*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0940*      push af ; this is so we can send it back unharmed
0405B5 F5          0941*      push af ; this is so we can pop it to hl
0405B6             0942*  ; store everything in scratch
0405B6 22 9F 05 04 0943*      ld (uhl),hl
0405BA ED 43 A2 05 0944*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0945*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0946*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0947*      ld (uiy),iy
       04          
0405CE             0948*  ; next we print the header
0405CE 21 FA 05 04 0949*      ld hl,@header
0405D2 CD 77 00 04 0950*      call printString
0405D6 E1          0951*      pop hl ; flags are now in l
0405D7 7D          0952*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0953*      call printBin8
0405DC CD 8C 00 04 0954*      call printNewLine
0405E0             0955*  ; restore everything
0405E0 2A 9F 05 04 0956*      ld hl, (uhl)
0405E4 ED 4B A2 05 0957*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0958*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0959*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0960*      ld iy, (uiy)
       04          
0405F8 F1          0961*      pop af ; send her home the way she came
0405F9 C9          0962*      ret
0405FA             0963*  ; Bit 7 (S): Sign flag
0405FA             0964*  ; Bit 6 (Z): Zero flag
0405FA             0965*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0966*  ; Bit 4 (H): Half Carry flag
0405FA             0967*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0968*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0969*  ; Bit 1 (N): Subtract flag
0405FA             0970*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0971*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0972*  
040605             0973*  ; set all the bits in the flag register
040605             0974*  ; more of an academic exercise than anything useful
040605             0975*  ; inputs; none
040605             0976*  ; outputs; a=0,f=255
040605             0977*  ; destroys: flags, hl
040605             0978*  ; preserves: a, because why not
040605             0979*  setAllFlags:
040605 21 FF 00 00 0980*      ld hl,255
040609 67          0981*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0982*      push hl
04060B F1          0983*      pop af
04060C C9          0984*      ret
04060D             0985*  
04060D             0986*  ; reset all the bits in the flag register
04060D             0987*  ; unlike its inverse counterpart, this may actually be useful
04060D             0988*  ; inputs; none
04060D             0989*  ; outputs; a=0,f=0
04060D             0990*  ; destroys: flags, hl
04060D             0991*  ; preserves: a, because why not
04060D             0992*  resetAllFlags:
04060D 21 00 00 00 0993*      ld hl,0
040611 67          0994*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0995*      push hl
040613 F1          0996*      pop af
040614 C9          0997*      ret
040615             0998*  
040615             0999*  ; wait until user presses a key
040615             1000*  ; inputs: none
040615             1001*  ; outputs: ascii code of key pressed in a
040615             1002*  ; destroys: af,ix
040615             1003*  waitKeypress:
040615             1004*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1005*      ret
04061A             1006*  
04061A             1007*  ; print bytes from an address to the screen in hexidecimal format
04061A             1008*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1009*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1010*  ; destroys: nothing
04061A             1011*  dumpMemoryHex:
04061A             1012*  ; save registers to the stack
04061A C5          1013*      push bc
04061B E5          1014*      push hl
04061C F5          1015*      push af
04061D             1016*  
04061D             1017*  ; print the address and separator
04061D CD 97 00 04 1018*      call printHex24
040621 3E 3A       1019*      ld a,':'
040623 5B D7       1020*      rst.lil 10h
040625 3E 20       1021*      ld a,' '
040627 5B D7       1022*      rst.lil 10h
040629             1023*  
040629             1024*  ; set b to be our loop counter
040629 F1          1025*      pop af
04062A 47          1026*      ld b,a
04062B E1          1027*      pop hl
04062C E5          1028*      push hl
04062D F5          1029*      push af
04062E             1030*  @loop:
04062E             1031*  ; print the byte
04062E 7E          1032*      ld a,(hl)
04062F CD A5 00 04 1033*      call printHex8
040633             1034*  ; print a space
040633 3E 20       1035*      ld a,' '
040635 5B D7       1036*      rst.lil 10h
040637 23          1037*      inc hl
040638 10 F4       1038*      djnz @loop
04063A CD 8C 00 04 1039*      call printNewLine
04063E             1040*  
04063E             1041*  ; restore everything
04063E F1          1042*      pop af
04063F E1          1043*      pop hl
040640 C1          1044*      pop bc
040641             1045*  
040641             1046*  ; all done
040641 C9          1047*      ret
040642             1048*  
040642             1049*  
040642             1050*  ; print bytes from an address to the screen in binary format
040642             1051*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1052*  ; outputs: values of each byte printed to screen separated by spaces
040642             1053*  ; destroys: nothing
040642             1054*  dumpMemoryBin:
040642             1055*  ; save all registers to the stack
040642 F5          1056*      push af
040643 C5          1057*      push bc
040644 D5          1058*      push de
040645 E5          1059*      push hl
040646 DD E5       1060*      push ix
040648 FD E5       1061*      push iy
04064A             1062*  
04064A             1063*  ; set b to be our loop counter
04064A 47          1064*      ld b,a
04064B             1065*  @loop:
04064B             1066*  ; print the byte
04064B 7E          1067*      ld a,(hl)
04064C E5          1068*      push hl
04064D C5          1069*      push bc
04064E CD 15 03 04 1070*      call printBin8
040652 C1          1071*      pop bc
040653             1072*  ; print a space
040653 3E 20       1073*      ld a,' '
040655 5B D7       1074*      rst.lil 10h
040657 E1          1075*      pop hl
040658 23          1076*      inc hl
040659 10 F0       1077*      djnz @loop
04065B CD 8C 00 04 1078*      call printNewLine
04065F             1079*  
04065F             1080*  ; restore everything
04065F FD E1       1081*      pop iy
040661 DD E1       1082*      pop ix
040663 E1          1083*      pop hl
040664 D1          1084*      pop de
040665 C1          1085*      pop bc
040666 F1          1086*      pop af
040667             1087*  ; all done
040667 C9          1088*      ret
040668             1089*  
040668             1090*  ; print bytes from an address to the screen in binary format
040668             1091*  ; with the bits of each byte in reverse order (lsb first)
040668             1092*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1093*  ; outputs: values of each byte printed to screen separated by spaces
040668             1094*  ; destroys: nothing
040668             1095*  dumpMemoryBinRev:
040668             1096*  ; save all registers to the stack
040668 F5          1097*      push af
040669 C5          1098*      push bc
04066A D5          1099*      push de
04066B E5          1100*      push hl
04066C DD E5       1101*      push ix
04066E FD E5       1102*      push iy
040670             1103*  
040670             1104*  ; set b to be our loop counter
040670 47          1105*      ld b,a
040671             1106*  @loop:
040671             1107*  ; print the byte
040671 7E          1108*      ld a,(hl)
040672 E5          1109*      push hl
040673 C5          1110*      push bc
040674 CD 3A 03 04 1111*      call printBin8Rev
040678 C1          1112*      pop bc
040679             1113*  ; print a space
040679 3E 20       1114*      ld a,' '
04067B 5B D7       1115*      rst.lil 10h
04067D E1          1116*      pop hl
04067E 23          1117*      inc hl
04067F 10 F0       1118*      djnz @loop
040681 CD 8C 00 04 1119*      call printNewLine
040685             1120*  
040685             1121*  ; restore everything
040685 FD E1       1122*      pop iy
040687 DD E1       1123*      pop ix
040689 E1          1124*      pop hl
04068A D1          1125*      pop de
04068B C1          1126*      pop bc
04068C F1          1127*      pop af
04068D             1128*  ; all done
04068D C9          1129*      ret
04068E             0037       include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*      add hl,de
04068E             0007*      or a
04068E             0008*      sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de ; save de
0406A5 EB          0045*      ex de,hl ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0 ; clear hl
0406AA AF          0047*      xor a ; clear carry
0406AB ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
0406AD D1          0049*      pop de ; get de back
0406AE C9          0050*      ret ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*      ld (scratch1),hl
0406B3 21 90 06 04 0057*      ld hl,scratch1+2
0406B7 CB 1E       0058*      rr (hl)
0406B9 2B          0059*      dec hl
0406BA CB 1E       0060*      rr (hl)
0406BC 2B          0061*      dec hl
0406BD CB 1E       0062*      rr (hl)
0406BF 23          0063*      inc hl
0406C0 23          0064*      inc hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M     add hl,de
0406E6 B7          0002*M     or a
0406E7 ED 52       0003*M     sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*      xor a
0406FC 32 0D 07 04 0105*      ld (@buffer+3),a
040700 7D          0106*      ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*      ld (@buffer),hl
040705 2A 0B 07 04 0108*      ld hl,(@buffer+1)
040709 C9          0109*      ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*      add hl,hl ; * 2
04070E             0114*      add hl,hl ; * 4
04070E             0115*      add hl,hl ; * 8
04070E             0116*      add hl,hl ; * 16
04070E             0117*      add hl,hl ; * 32
04070E             0118*      add hl,hl ; * 64
04070E             0119*      add hl,hl ; * 128
04070E             0120*      add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*      or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*      ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0038       include "enemies.inc"
040785 01          0001*  max_enemy_sprites: db 1
040786             0002*  
040786             0003*  ; sprite_type
040786             0004*  enemy_dead: equ 0
040786             0005*  enemy_small: equ 1
040786             0006*  enemy_medium: equ 2
040786             0007*  enemy_large: equ 3
040786             0008*  landing_pad: equ 4
040786             0009*  laser_turret: equ 5
040786             0010*  fireballs: equ 6
040786             0011*  explosion: equ 7
040786             0012*  
040786             0013*  move_enemies:
040786             0014*  ; are there any active enemies or explosions?
040786 3A D5 3D 04 0015*      ld a,(table_active_sprites)
04078A A7          0016*      and a ; will be zero if no alive enemies or explosions
04078B C2 98 07 04 0017*      jp nz,@they_live
04078F 21 14 40 04 0018*      ld hl,enemies_dead
040793 22 11 40 04 0019*      ld (enemies_state),hl
040797 C9          0020*      ret
040798             0021*  @they_live:
040798             0022*  ; initialize pointers and loop counter
040798 FD 21 72 3B 0023*      ld iy,table_base ; set iy to first record in table
       04          
04079D 06 10       0024*      ld b,table_max_records ; loop counter
04079F             0025*  move_enemies_loop:
04079F FD 22 D2 3D 0026*      ld (table_pointer),iy ; update table pointer
       04          
0407A4 C5          0027*      push bc ; backup loop counter
0407A5             0028*  ; check sprite_type to see if sprite is active
0407A5 FD 7E 01    0029*      ld a,(iy+sprite_type)
0407A8 A7          0030*      and a ; if zero, sprite is dead
0407A9 28 33       0031*      jr z,move_enemies_next_record ; ... and we skip to next record
0407AB             0032*  ; otherwise we prepare to move the sprite
0407AB FD 7E 00    0033*      ld a,(iy+sprite_id) ; get spriteId
0407AE CD 74 48 04 0034*      call vdu_sprite_select ; select sprite
0407B2 FD 27 05    0035*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0407B5             0036*      callHL
0407B5 01 BB 07 04 0001*M     ld bc,@F ; Address of first instruction after the jump
0407B9 C5          0002*M     push bc ; which constitutes the return address
0407BA E9          0003*M     jp (hl) ; Jump to the address in HL
0407BB             0004*M @@:
0407BB             0037*  ; move_enemies_loop_return: return from behavior subroutines
0407BB FD 2A D2 3D 0038*      ld iy,(table_pointer) ; get back table pointer
       04          
0407C0             0039*  ; now we check results of all the moves
0407C0 FD 7E 08    0040*      ld a,(iy+sprite_collisions)
0407C3 E6 F0       0041*      and %11110000 ; any bits set in high nibble means we died
0407C5 FD 7E 00    0042*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0407C8 28 0A       0043*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0407CA CD 1E 3E 04 0044*      call table_deactivate_sprite ; otherwise we ded
0407CE AF          0045*      xor a ; zero a so that we can ...
0407CF FD 77 08    0046*      ld (iy+sprite_collisions),a ; ... clear collision flags
0407D2 18 0A       0047*      jr move_enemies_next_record ; and to the next record
0407D4             0048*  move_enemies_draw_sprite:
0407D4             0049*  ; if we got here sprite will have already been activated
0407D4             0050*  ; so all we need to do is set its coordinates and draw it
0407D4 FD 07 0B    0051*      ld bc,(iy+sprite_x)
0407D7 FD 17 0E    0052*      ld de,(iy+sprite_y)
0407DA CD 40 49 04 0053*      call vdu_sprite_move_abs168
0407DE             0054*  ; fall through to next record
0407DE             0055*  move_enemies_next_record:
0407DE 11 26 00 00 0056*      ld de,table_bytes_per_record
0407E2 FD 19       0057*      add iy,de ; point to next record
0407E4 AF          0058*      xor a ; clears carry flag
0407E5 32 D6 3D 04 0059*      ld (sprite_screen_edge),a ; clear screen edge collision flag
0407E9 C1          0060*      pop bc ; get back our loop counter
0407EA 10 B3       0061*      djnz move_enemies_loop ; loop until we've checked all the records
0407EC C9          0062*      ret ; and we're out
0407ED             0063*  
0407ED             0064*  en_nav_zigzag_start:
0407ED FD 2A D2 3D 0065*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0407F2 CD 49 07 04 0066*      call rand_8
0407F6 E6 3F       0067*      and %00111111 ; limit it to 64
0407F8 CB DF       0068*      set 3,a ; make sure it's at least 8
0407FA FD 77 22    0069*      ld (iy+sprite_move_timer),a ; store it
0407FD             0070*      ; fall through to en_nav_zigzag
0407FD             0071*  en_nav_zigzag:
0407FD FD 7E 22    0072*      ld a,(iy+sprite_move_timer)
040800 3D          0073*      dec a
040801 FD 77 22    0074*      ld (iy+sprite_move_timer),a
040804 20 1C       0075*      jr nz,en_nav_zigzag_no_switch
040806             0076*      ; otherwise flip direction and restart timer
040806 FD 7E 23    0077*      ld a,(iy+sprite_move_step)
040809 EE 01       0078*      xor %1 ; flips bit one
04080B FD 77 23    0079*      ld (iy+sprite_move_step),a ; store it
04080E 20 09       0080*      jr nz,en_nav_zigzag_right
040810             0081*  ;otherwise zag left
040810 21 00 A0 00 0082*      ld hl,0x00A000; southwest heading
040814 FD 2F 1A    0083*      ld (iy+sprite_heading),hl ; save sprite heading
040817 18 D4       0084*      jr en_nav_zigzag_start
040819             0085*  en_nav_zigzag_right:
040819 21 00 60 00 0086*      ld hl,0x006000; southeast heading
04081D FD 2F 1A    0087*      ld (iy+sprite_heading),hl ; save sprite heading
040820 18 CB       0088*      jr en_nav_zigzag_start
040822             0089*  en_nav_zigzag_no_switch:
040822             0090*      ; ld a,(sprite_orientation)
040822 FD 27 1A    0091*      ld hl,(iy+sprite_heading)
040825 18 13       0092*      jr en_nav_computevelocities
040827             0093*  
040827             0094*  ; contains the logic for how to move the enemy
040827             0095*  ; and then does the moving
040827             0096*  ; inputs: a fully-populated active sprite table
040827             0097*  ;         player position variables
040827             0098*  ; destroys: everything except index registers
040827             0099*  ; outputs: moving enemies
040827             0100*  en_nav:
040827             0101*  ; set velocity and orientation by player's relative location
040827             0102*  ; move enemies y-axis
040827             0103*  ; where is player relative to us?
040827 CD EE 08 04 0104*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
04082B             0105*  ; is player above or below us?
04082B ED 53 A5 05 0106*      ld (ude),de ; dy
       04          
040830 3A A7 05 04 0107*      ld a,(ude+2) ; deu
040834 17          0108*      rla ; shift sign bit into carry
040835 30 C6       0109*      jr nc,en_nav_zigzag ; player is below,evade
040837             0110*  ; player is even or above,so home in on current heading
040837 FD 2F 1A    0111*      ld (iy+sprite_heading),hl ; save sprite heading
04083A             0112*  
04083A             0113*  ; we land here from zig-zag program so as not to
04083A             0114*  ; redundantly save orientation and heading
04083A             0115*  en_nav_computevelocities:
04083A             0116*  ; set x/y component velocities based on bearing to player
04083A FD 2A D2 3D 0117*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04083F E5          0118*      push hl ; we need it back to set rotation frame
040840 FD 17 17    0119*      ld de,(iy+sprite_vel)
040843 CD B6 0B 04 0120*      call polar_to_cartesian
040847 FD 2A D2 3D 0121*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04084C FD 0F 11    0122*      ld (iy+sprite_xvel),bc ; save x-velocity component
04084F FD 1F 14    0123*      ld (iy+sprite_yvel),de ; save y-velocity component
040852             0124*  ; change the animation frame to match heading
040852             0125*  ; by dividng the heading by 8
040852 E1          0126*      pop hl ; get back Heading
040853 7C          0127*      ld a,h
040854 CB 3F       0128*      srl a
040856 CB 3F       0129*      srl a
040858 CB 3F       0130*      srl a
04085A CD D7 48 04 0131*      call vdu_sprite_select_frame
04085E C3 86 3E 04 0132*      jp move_sprite ; will return to caller from there
040862             0133*  
040862             0134*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
040862             0135*  ; ; each sprite in the table must have one of these defined
040862             0136*  ; ; but they need not be unique to a particular sprite
040862             0137*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
040862             0138*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
040862             0139*  ; ; but they can call anything they want between those two endpoints
040862             0140*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
040862             0141*  
040862             0142*  ; move_nop: ; does nothing but burn a few cycles changing the PC
040862             0143*  ;     ret
040862             0144*  
040862             0145*  ; move_explosion:
040862             0146*  ;     call animate_explosion
040862             0147*  ;     ret
040862             0148*  
040862             0149*  move_enemy_small:
040862 CD 27 08 04 0150*      call en_nav
040866 CD 97 09 04 0151*      call check_collisions
04086A C9          0152*      ret
04086B             0153*  
04086B             0154*  ; move_enemy_medium:
04086B             0155*  ;     call en_nav
04086B             0156*  ;     call check_collisions
04086B             0157*  ;     ret
04086B             0158*  
04086B             0159*  ; move_enemy_large:
04086B             0160*  ;     call en_nav
04086B             0161*  ;     call check_collisions
04086B             0162*  ;     ret
04086B             0163*  
04086B             0164*  ; move_landing_pad:
04086B             0165*  ;     call move_active_tiles
04086B             0166*  ;     call check_collisions
04086B             0167*  ; ; is it time to launch an enemy?
04086B             0168*  ;     ld hl,sprite_move_timer
04086B             0169*  ;     dec (hl)
04086B             0170*  ;     jp nz,move_enemies_loop_return
04086B             0171*  ;     call enemy_init_from_landing_pad
04086B             0172*  ;     ; reset move timer so can spawn again if player doesn't take us out
04086B             0173*  ;     call rand_8     ; snag a random number
04086B             0174*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04086B             0175*  ;     add a,64 ; range is now 64-127
04086B             0176*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04086B             0177*  ;     ret
04086B             0178*  
04086B             0179*  speed_seeker: equ 0x000280 ; 2.5 pixels per frame
04086B             0180*  
04086B             0181*  enemy_init_from_landing_pad:
04086B             0182*  ; get next available spriteId
04086B CD F9 3D 04 0183*      call table_get_next_id
04086F D0          0184*      ret nc ; no carry means no free sprite slots, so we go home
040870             0185*  ; ix comes back with the pointer to the new sprite variables
040870 DD E5       0186*      push ix ; de picks it up when we're ready for the copy to the table
040872             0187*  ; a comes back with the spriteId of the new sprite
040872 32 C8 08 04 0188*      ld (@id),a
040876             0189*  ; initialize the new sprite
040876 CD 74 48 04 0190*      call vdu_sprite_select
04087A CD 87 48 04 0191*      call vdu_sprite_clear_frames
04087E 21 14 01 00 0192*      ld hl,BUF_SEEKER_000
040882 06 20       0193*      ld b,32
040884             0194*  @load_frames:
040884 C5          0195*      push bc
040885 E5          0196*      push hl
040886 CD C9 49 04 0197*      call vdu_sprite_add_buff
04088A E1          0198*      pop hl
04088B 23          0199*      inc hl
04088C C1          0200*      pop bc
04088D 10 F5       0201*      djnz @load_frames
04088F             0202*  ; copy coordinates of active sprite to new sprite
04088F FD 2A D2 3D 0203*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040894             0204*      ; ld hl,(iy+sprite_x)
040894             0205*      ; ld hl,0x008000 ; debug
040894             0206*  
040894 CD 49 07 04 0207*      call rand_8
040898 21 00 00 00 0208*      ld hl,0
04089C 67          0209*      ld h,a
04089D             0210*  
04089D 22 D3 08 04 0211*      ld (@x),hl
0408A1             0212*      ; ld hl,(iy+sprite_y)
0408A1             0213*      ; ld hl,0x002000 ; debug
0408A1             0214*  
0408A1 CD 49 07 04 0215*      call rand_8
0408A5 21 00 00 00 0216*      ld hl,0
0408A9 67          0217*      ld h,a
0408AA             0218*  
0408AA 22 D6 08 04 0219*      ld (@y),hl
0408AE CD 49 07 04 0220*      call rand_8
0408B2 E6 01       0221*      and %00000001 ; 50/50 chance of moving left or right on spanw
0408B4 32 EB 08 04 0222*      ld (@move_step),a
0408B8             0223*  ; now copy to the table
0408B8 21 C8 08 04 0224*      ld hl,@id ; address to copy from
0408BC D1          0225*      pop de ; address to copy to (was ix)
0408BD 01 26 00 00 0226*      ld bc,table_bytes_per_record ; number of bytes to copy
0408C1 ED B0       0227*      ldir ; copy the records from local scratch to sprite table
0408C3             0228*  ; finally, make the new sprite visible
0408C3 CD EA 48 04 0229*      call vdu_sprite_show
0408C7 C9          0230*      ret
0408C8 00          0231*  @id:                    db 0x00 ; 1 bytes unique spriteId, zero-based
0408C9 01          0232*  @type:                  db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
0408CA 14 01 00    0233*  @base_bufferId:         dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0408CD 62 08 04    0234*  @move_program:          dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0408D0 03          0235*  @collisions:            db %00000011 ; 3 bytes collides with enemy and laser
0408D1 10          0236*  @dim_x:                 db 0x10 ; 1 bytes sprite width in pixels
0408D2 10          0237*  @dim_y:                 db 0x10 ; 1 bytes sprite height in pixels
0408D3 00 00 00    0238*  @x:                     dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0408D6 00 00 00    0239*  @y:                     dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0408D9 00 00 00    0240*  @xvel:                  dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0408DC 00 00 00    0241*  @yvel:                  dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0408DF 80 02 00    0242*  @vel:                   dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
0408E2 00 80 00    0243*  @heading:               dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0408E5 00 80 00    0244*  @orientation:           dl 0x008000 ; 3 bytes orientation bits
0408E8 00          0245*  @animation:             db 0x00 ; 1 bytes current animation index, zero-based
0408E9 00          0246*  @animation_timer:       db 0x00 ; 1 bytes when hits zero, draw next animation
0408EA 01          0247*  @move_timer:            db 0x01 ; 1 bytes when zero, go to next move program, or step
0408EB 00          0248*  @move_step:             db 0x00 ; 1 bytes stage in a move program sequence, varies
0408EC 0A          0249*  @points:                db 10 ; 1 bytes points awarded for killing this sprite type
0408ED 02          0250*  @shield_damage:         db 0x02 ; 1 bytes shield points deducted for collision
0408EE             0251*  
0408EE             0252*  ; move_laser_turret:
0408EE             0253*  ; ; compute orientation to player
0408EE             0254*  ;     call orientation_to_player
0408EE             0255*  ; ; h.l 8.8 fixed angle256 to player
0408EE             0256*  ; ; bc and de as signed 16-bit integers
0408EE             0257*  ; ; representing delta-x/y *to* target respectively
0408EE             0258*  ;     ld (Bearing_t),hl
0408EE             0259*  ;     ld hl,0x0400
0408EE             0260*  ;     ld (Vp),hl
0408EE             0261*  ;     call targeting_computer
0408EE             0262*  ;     ld (sprite_heading),hl ; store bearing to player
0408EE             0263*  ; ; is it time to launch a fireball?
0408EE             0264*  ;     ld hl,sprite_move_timer
0408EE             0265*  ;     dec (hl)
0408EE             0266*  ;     jp nz,move_laser_turret_boilerplate
0408EE             0267*  ;     call fireballs_init
0408EE             0268*  ;     ; reset move timer so can fire again if player doesn't take us out
0408EE             0269*  ;     call rand_8     ; snag a random number
0408EE             0270*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0408EE             0271*  ;     add a,64 ; range is now 64-127
0408EE             0272*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0408EE             0273*  ; move_laser_turret_boilerplate:
0408EE             0274*  ;     call move_active_tiles
0408EE             0275*  ;     call check_collisions
0408EE             0276*  ;     ret
0408EE             0277*  
0408EE             0278*  ; fireballs_init:
0408EE             0279*  ;     call sprite_variables_to_stack
0408EE             0280*  
0408EE             0281*  ;     ld hl,fireballs
0408EE             0282*  ;     ld (sprite_base_bufferId),hl
0408EE             0283*  
0408EE             0284*  ;     ld hl,move_fireballs
0408EE             0285*  ;     ld (sprite_move_program),hl
0408EE             0286*  
0408EE             0287*  ;     ld a,%11 ; collides with laser and player
0408EE             0288*  ;     ; ld a,%10 ; collides with laser DEBUG
0408EE             0289*  ;     ld (iy+sprite_collisions),a
0408EE             0290*  
0408EE             0291*  ;     ld hl,(Vp)
0408EE             0292*  ;     ld (sprite_vel),hl
0408EE             0293*  ;     ld hl,(Vp_x)
0408EE             0294*  ;     ld (sprite_xvel),hl
0408EE             0295*  ;     ld hl,(Vp_y)
0408EE             0296*  ;     inc h ; account for ground movement
0408EE             0297*  ;     ld (sprite_yvel),hl
0408EE             0298*  
0408EE             0299*  ;     xor a ; zero a
0408EE             0300*  ;     ld (sprite_animation),a
0408EE             0301*  ;     ld (sprite_move_step),a
0408EE             0302*  ;     ld (sprite_move_timer),a
0408EE             0303*  
0408EE             0304*  ;     ld a,6 ; 1/10th of a second timer
0408EE             0305*  ;     ld (sprite_animation_timer),a
0408EE             0306*  
0408EE             0307*  ;     ld a,0x00 ; BCD
0408EE             0308*  ;     ld (sprite_points),a
0408EE             0309*  ;     ld a,1 ; binary
0408EE             0310*  ;     ld (sprite_shield_damage),a
0408EE             0311*  
0408EE             0312*  ;     call table_add_record ; plops that on the sprite stack for later
0408EE             0313*  ;     call sprite_variables_from_stack ; come back to where we started
0408EE             0314*  ;     ret
0408EE             0315*  
0408EE             0316*  ; move_fireballs:
0408EE             0317*  ;     call move_sprite ; move sprite
0408EE             0318*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
0408EE             0319*  ;     and a ; if zero we're still within screen bounds
0408EE             0320*  ;     jr z,move_fireballs_alive
0408EE             0321*  ; ; otherwise kill sprite
0408EE             0322*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
0408EE             0323*  ;     ld (iy+sprite_collisions),a
0408EE             0324*  ;     ret
0408EE             0325*  ; move_fireballs_alive:
0408EE             0326*  ;     ld a,(sprite_animation_timer)
0408EE             0327*  ;     dec a
0408EE             0328*  ;     ld (sprite_animation_timer),a
0408EE             0329*  ;     jr nz,move_fireballs_draw
0408EE             0330*  ;     ld a,(sprite_animation)
0408EE             0331*  ;     xor %1
0408EE             0332*  ;     ld (sprite_animation),a
0408EE             0333*  ;     ld a,6 ; 1/10th of a second timer
0408EE             0334*  ;     ld (sprite_animation_timer),a
0408EE             0335*  ;     ; fall through
0408EE             0336*  
0408EE             0337*  ; move_fireballs_draw:
0408EE             0338*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0408EE             0339*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0408EE             0340*  ;     call check_collisions
0408EE             0341*  ;     ret
0408EE             0342*  
0408EE             0343*  ; compute orientation to player
0408EE             0344*  ; based on relative positions
0408EE             0345*  ; returns: h.l 16.8 fixed angle256 to player
0408EE             0346*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0408EE             0347*  ;    representing delta-x/y *to* target respectively
0408EE             0348*  orientation_to_player:
0408EE FD 2A D2 3D 0349*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0408F3 FD 07 0B    0350*      ld bc,(iy+sprite_x)
0408F6 FD 17 0E    0351*      ld de,(iy+sprite_y)
0408F9 DD 2A 62 3A 0352*      ld ix,(player_x)
       04          
0408FE FD 2A 65 3A 0353*      ld iy,(player_y)
       04          
040903 CD EB 0B 04 0354*      call dxy168
040907 C5          0355*      push bc
040908 D5          0356*      push de
040909 CD 48 0C 04 0357*      call atan2_168fast
04090D D1          0358*      pop de
04090E C1          0359*      pop bc
04090F FD 2A D2 3D 0360*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
040914 C9          0361*      ret
040915             0362*  
040915             0363*  
040915             0364*  ; targeting_computer scratch variables
040915 00 00       0365*  Bearing_t: dw #0000 ; 8.8 fixed
040917 00 00       0366*  Heading_t: dw #0000 ; 8.8 fixed
040919 00 00       0367*  Vp: dw #0000 ; 8.8 fixed
04091B 00 00       0368*  Vp_x: dw #0000 ; 8.8 fixed
04091D 00 00       0369*  Vp_y: dw #0000 ; 8.8 fixed
04091F 00 00       0370*  Vt: dw #0000 ; 8.8 fixed
040921 00 00       0371*  Vt_x: dw #0000 ; 8.8 fixed
040923 00 00       0372*  Vt_y: dw #0000 ; 8.8 fixed
040925             0373*  
040925             0374*  
040925             0375*  ; ; Inputs:   see scratch variables
040925             0376*  ; ; Note:     a call to orientation_to_player provides these inputs
040925             0377*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
040925             0378*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
040925             0379*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
040925             0380*  ; targeting_computer:
040925             0381*  ; ; compute target velocity from x,y component velocities
040925             0382*  ;     ld bc,(player_xvel)
040925             0383*  ;     ld de,(player_yvel)
040925             0384*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
040925             0385*  
040925             0386*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
040925             0387*  ;     ld (Heading_t),bc
040925             0388*  ;     ld (Vt),de
040925             0389*  
040925             0390*  ; ; compute Heading_t-Bearing_t
040925             0391*  ;     ld h,b
040925             0392*  ;     ld l,c
040925             0393*  ;     ld bc,(Bearing_t)
040925             0394*  ;     and a ; clear carry
040925             0395*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
040925             0396*  
040925             0397*  ; ; compute sin(Heading_t-Bearing_t)
040925             0398*  ;     ld b,h
040925             0399*  ;     ld c,l
040925             0400*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
040925             0401*  
040925             0402*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
040925             0403*  ;     ex de,hl
040925             0404*  ;     ld bc,(Vt)
040925             0405*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
040925             0406*  
040925             0407*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
040925             0408*  ;     ld b,h
040925             0409*  ;     ld c,l
040925             0410*  ;     ld de,(Vp)
040925             0411*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
040925             0412*  ; ; answer is in radians, convert to degrees256
040925             0413*  ;     ex de,hl
040925             0414*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
040925             0415*  ;     call BC_Mul_DE_88
040925             0416*  
040925             0417*  ; ; add lead angle to target bearing
040925             0418*  ;     ld de,(Bearing_t)
040925             0419*  ;     add hl,de ; h.l=lead angle+target bearing
040925             0420*  ;     push hl
040925             0421*  
040925             0422*  ; ; compute component projectile velocities
040925             0423*  ;     ld b,h
040925             0424*  ;     ld c,l
040925             0425*  ;     ld de,(Vp)
040925             0426*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
040925             0427*  
040925             0428*  ;     ld (Vp_x),bc
040925             0429*  ;     ld (Vp_y),de
040925             0430*  ;     pop hl ; h.l=lead angle+target bearing
040925             0431*  ;     ret
040925             0432*  
040925             0433*  ; this routine vanquishes the enemy sprite
040925             0434*  ; and replaces it with an animated explosion
040925             0435*  ; we jump here instead of call because
040925             0436*  ; we want to return to differing locations in the loop
040925             0437*  ; depending on whether we're still sploding
040925             0438*  ; destroys: everything except index registers
040925             0439*  ; returns: an incandescent ball of debris and gas
040925             0440*  kill_nurple:
040925 FD 2A D2 3D 0441*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
04092A             0442*  ; tally up points
04092A 2A 4D 3A 04 0443*      ld hl,(player_score)
04092E 01 00 00 00 0444*      ld bc,0 ; clear bcu
040932 FD 4E 24    0445*      ld c,(iy+sprite_points)
040935 09          0446*      add hl,bc
040936 22 4D 3A 04 0447*      ld (player_score),hl
04093A             0448*  ; ; initialize explosion
04093A             0449*  ; init_explosion:
04093A             0450*  ;     ld hl,explosion
04093A             0451*  ;     ld (sprite_base_bufferId),hl
04093A             0452*  ;     ld hl,move_explosion
04093A             0453*  ;     ld (sprite_move_program),hl
04093A             0454*  ;     ld a,%00000000 ; collides with nothing
04093A             0455*  ;     ld (iy+sprite_collisions),a
04093A             0456*  ;     ld hl,0 ; north
04093A             0457*  ;     ld (sprite_heading),hl
04093A             0458*  ;     ld a,0x04 ; will decrement to 03
04093A             0459*  ;     ld (sprite_animation),a
04093A             0460*  ;     ld a,0x07 ; 7/60th of a second timer
04093A             0461*  ;     ld (sprite_animation_timer),a
04093A             0462*  ;     xor a
04093A             0463*  ;     ld (sprite_move_timer),a
04093A             0464*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04093A             0465*  ; ; fall through to next_explosion
04093A             0466*  ; next_explosion:
04093A             0467*  ;     ld a,(sprite_animation)
04093A             0468*  ;     dec a ; if rolled negative from zero,we're done sploding
04093A             0469*  ;     jp m,done_explosion
04093A             0470*  ;     ld (sprite_animation),a
04093A             0471*  ;     ld a,0x7 ; 7/60th of a second timer
04093A             0472*  ;     ld (sprite_animation_timer),a
04093A             0473*  ; ; fall through to animate_explosion
04093A             0474*  ; animate_explosion:
04093A             0475*  ;     ld hl,sprite_y+1
04093A             0476*  ;     inc (hl) ; move explosion down 1 pixel
04093A             0477*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
04093A             0478*  ;     ld hl,sprite_animation_timer
04093A             0479*  ;     dec (hl) ; if timer is zero,we do next animation
04093A             0480*  ;     jr z,next_explosion
04093A             0481*  ;     ;otherwise we fall through to draw the current one
04093A             0482*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04093A             0483*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04093A             0484*  ;     ret ; now we go back to caller
04093A             0485*  ; done_explosion:
04093A 3E 80       0486*      ld a,%10000000 ; high bit set is non-specific kill-me flag
04093C FD 77 08    0487*      ld (iy+sprite_collisions),a
04093F C9          0488*      ret ; now we go back to caller
040940             0489*  
040940             0490*  ; game_over:
040940             0491*  ;     jp game_initialize
040940             0492*  
040940             0493*  ; it's presumed we've already checked that laser is alive
040940             0494*  collision_enemy_with_laser:
040940 DD 2A 30 29 0495*      ld ix,(laser_x)
       04          
040945 FD 2A 33 29 0496*      ld iy,(laser_y)
       04          
04094A 3A 2E 29 04 0497*      ld a,(laser_dim_x)
04094E CB 2F       0498*      sra a ; divide by 2
040950 F5          0499*      push af ; we need this later
040951 C3 66 09 04 0500*      jp collision_enemy
040955             0501*  
040955             0502*  ; it's presumed we've already checked that player is alive
040955             0503*  collision_enemy_with_player:
040955 DD 2A 62 3A 0504*      ld ix,(player_x)
       04          
04095A FD 2A 65 3A 0505*      ld iy,(player_y)
       04          
04095F 3A 60 3A 04 0506*      ld a,(player_dim_x)
040963 CB 2F       0507*      sra a ; divide by 2
040965 F5          0508*      push af ; we need this later
040966             0509*      ; fall through to collision_enemy
040966             0510*  
040966             0511*  ; compute the distance between the two sprites' centers
040966             0512*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
040966             0513*  collision_enemy:
040966             0514*  ; back up iy because we need it as the sprite table pointer
040966 FD E5       0515*      push iy
040968 FD 2A D2 3D 0516*      ld iy,(table_pointer)
       04          
04096D FD 27 0B    0517*      ld hl,(iy+sprite_x)
040970 FD 7E 09    0518*      ld a,(iy+sprite_dim_x)
040973 CB 2F       0519*      sra a
040975 F5          0520*      push af ; we need this later
040976 E5          0521*      push hl
040977 C1          0522*      pop bc ; bc = x0
040978 FD 27 0E    0523*      ld hl,(iy+sprite_y)
04097B FD 7E 0A    0524*      ld a,(iy+sprite_dim_y)
04097E EB          0525*      ex de,hl ; de = y0
04097F F1          0526*      pop af ; TODO: srsly, this is the best way to do this?
040980 FD E1       0527*      pop iy
040982 F5          0528*      push af
040983 CD 12 0C 04 0529*      call distance168
040987             0530*  
040987             0531*  ; ; subtract sum of radii from distance between centers
040987             0532*  ;     ld de,0
040987             0533*  ;     pop af ; radius of enemy sprite
040987             0534*  ;     ld e,a
040987             0535*  ;     pop af ; radius of player or laser sprite
040987             0536*  ;     add a,e
040987             0537*  ;     ld e,a
040987             0538*  ;     and a ; clear carry
040987             0539*  ;     sbc hl,de
040987             0540*  ;     jr c,collision_enemy_is
040987             0541*  ;     xor a
040987             0542*  ;     ret
040987             0543*  ; temp fix TODO: remove this
040987 F1          0544*      pop af
040988 F1          0545*      pop af
040989 11 00 10 00 0546*      ld de,16*256
04098D A7          0547*      and a
04098E ED 52       0548*      sbc hl,de
040990 38 02       0549*      jr c,collision_enemy_is
040992 AF          0550*      xor a
040993 C9          0551*      ret
040994             0552*  collision_enemy_is:
040994 AF          0553*      xor a
040995 3C          0554*      inc a
040996 C9          0555*      ret
040997             0556*  
040997             0557*  ; looks up what enemy sprite collides with
040997             0558*  ; detects collisions
040997             0559*  ; and sets things to sploding accordingly
040997             0560*  check_collisions:
040997 FD 7E 08    0561*      ld a,(iy+sprite_collisions) ; snag what we collide with
04099A A7          0562*      and a ; if this is zero,
04099B C8          0563*      ret z ; there's nothing to do
04099C E6 01       0564*      and %01 ; do we collide with player?
04099E 28 27       0565*      jr z,move_enemies_laser ; if not,check laser collision
0409A0 CD 55 09 04 0566*      call collision_enemy_with_player ; otherwise see if we hit player
0409A4 A7          0567*      and a ; was there a collision?
0409A5 28 20       0568*      jr z,move_enemies_laser ; if not,see if laser smacked us
0409A7             0569*  ; yes collision with player
0409A7             0570*      ; deduct shield damage
0409A7 21 25 00 00 0571*      ld hl,sprite_shield_damage
0409AB 3A 50 3A 04 0572*      ld a,(player_shields)
0409AF 96          0573*      sub (hl)
0409B0 32 50 3A 04 0574*      ld (player_shields),a
0409B4             0575*  ; if shields >= 0,player survives
0409B4 F2 C2 09 04 0576*      jp p,check_collisions_kill_nurple
0409B8             0577*  ; otherwise update player status so it will die
0409B8 3A 5F 3A 04 0578*      ld a,(player_collisions)
0409BC F6 02       0579*      or %10 ; sets bit 1,meaning player just died
0409BE 32 5F 3A 04 0580*      ld (player_collisions),a
0409C2             0581*      ; fall through
0409C2             0582*  check_collisions_kill_nurple:
0409C2             0583*  ; kill enemy and replace with explosion
0409C2 CD 25 09 04 0584*      call kill_nurple
0409C6 C9          0585*      ret ; and out
0409C7             0586*  
0409C7             0587*  ; did we hit the laser?
0409C7             0588*  move_enemies_laser:
0409C7 FD 7E 08    0589*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0409CA E6 02       0590*      and %10 ; do we even collide with laser?
0409CC C8          0591*      ret z ; if not,we're out
0409CD 3A 2D 29 04 0592*      ld a,(laser_collisions) ; is laser alive?
0409D1 E6 01       0593*      and %1 ; if bit 0 is not set laser is dead
0409D3 C8          0594*      ret z ; so we're out
0409D4 CD 40 09 04 0595*      call collision_enemy_with_laser ; otherwise check for collision
0409D8 A7          0596*      and a ; was there a collision?
0409D9 C8          0597*      ret z ; if not,we're done
0409DA             0598*  ; otherwise we mark laser for termination and kill enemy
0409DA             0599*  ; update laser status so it will die
0409DA 3A 2D 29 04 0600*      ld a,(laser_collisions)
0409DE F6 02       0601*      or %10 ; bit 1 set means laser just died
0409E0 32 2D 29 04 0602*      ld (laser_collisions),a
0409E4 CD 25 09 04 0603*      call kill_nurple ; yes there was a collision,so kill enemy
0409E8 C9          0604*      ret ; we're outta' here
0409E9             0039       include "files.inc"
0409E9             0001*  ; load to onboard 8k sram
0409E9             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0409E9             0040       include "fixed168.inc"
0409E9             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0409E9             0002*  ; uses EZ80 MLT instruction for speed
0409E9             0003*  ; operation: UHL * A --> UHL
0409E9             0004*  ; destroys: AF, HL
0409E9             0005*  smul24x8:
0409E9             0006*  ; make hl positive and store sign flag
0409E9 CD 94 06 04 0007*      call hlu_abs
0409ED F5          0008*      push af
0409EE             0009*  ; do the division
0409EE CD F9 09 04 0010*      call mul24x8 ; hl = product
0409F2             0011*  ; adjust sign of result
0409F2 F1          0012*      pop af ; sign de
0409F3 F0          0013*      ret p ; hl was positive, nothing to do
0409F4 CD A4 06 04 0014*      call neg_hlu ; result is negative
0409F8 C9          0015*      ret
0409F9             0016*  
0409F9             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0409F9             0018*  ; uses EZ80 MLT instruction for speed
0409F9             0019*  ; operation: UHL * A --> AUHL
0409F9             0020*  ; destroys: AF, HL
0409F9             0021*  mul24x8:
0409F9 D5          0022*      push de ; preserve de
0409FA             0023*  ; low byte
0409FA 5D          0024*      ld e,l
0409FB 57          0025*      ld d,a
0409FC ED 5C       0026*      mlt de
0409FE 6B          0027*      ld l,e ; product low byte
0409FF 08          0028*      ex af,af' ; save multiplier
040A00 7A          0029*      ld a,d ; carry
040A01 08          0030*      ex af,af' ; save carry, restore multiplier
040A02             0031*  ; high byte
040A02 5C          0032*      ld e,h
040A03 57          0033*      ld d,a
040A04 ED 5C       0034*      mlt de
040A06 08          0035*      ex af,af' ; save multiplier, restore carry
040A07 83          0036*      add a,e ; add carry
040A08 67          0037*      ld h,a ; product middle byte
040A09 7A          0038*      ld a,d ; carry
040A0A 08          0039*      ex af,af' ; save carry, restore multiplier
040A0B             0040*  ; upper byte
040A0B 22 26 0A 04 0041*      ld (@scratch),hl ; 7 cycles
040A0F 5F          0042*      ld e,a
040A10 3A 28 0A 04 0043*      ld a,(@scratch+2)
040A14 57          0044*      ld d,a
040A15 ED 5C       0045*      mlt de
040A17 08          0046*      ex af,af' ; restore carry
040A18 8B          0047*      adc a,e ; add carry
040A19 32 28 0A 04 0048*      ld (@scratch+2),a ; 5 cycles
040A1D 2A 26 0A 04 0049*      ld hl,(@scratch) ; 7 cycles
040A21             0050*  ; highest byte
040A21 3E 00       0051*      ld a,0 ; preserve carry flag
040A23 8A          0052*      adc a,d ; product highest byte
040A24 D1          0053*      pop de ; restore de
040A25 C9          0054*      ret
040A26             0055*  @scratch: ds 3
040A29             0056*  
040A29 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
040A2F             0058*  
040A2F             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A2F             0060*  ; operation: UHL * UDE --> mul24out
040A2F             0061*  mul24:
040A2F DD E5       0062*      push ix ; preserve
040A31             0063*  ; point to output buffer and clear it
040A31 DD 21 29 0A 0064*      ld ix,mul24out
       04          
040A36 C5          0065*      push bc
040A37 01 00 00 00 0066*      ld bc,0
040A3B DD 0F 00    0067*      ld (ix),bc
040A3E DD 0F 03    0068*      ld (ix+3),bc
040A41 C1          0069*      pop bc
040A42             0070*  ; STEP 1: UHL * E
040A42 7B          0071*      ld a,e
040A43 E5          0072*      push hl
040A44 CD F9 09 04 0073*      call mul24x8
040A48 DD 2F 00    0074*      ld (ix+0),hl
040A4B DD 77 03    0075*      ld (ix+3),a
040A4E             0076*  ; STEP 2: UHL * D
040A4E E1          0077*      pop hl
040A4F E5          0078*      push hl
040A50 7A          0079*      ld a,d
040A51 CD F9 09 04 0080*      call mul24x8
040A55 CD 6E 0A 04 0081*      call @accumulate
040A59             0082*  ; STEP 3: UHL * DEU
040A59 E1          0083*      pop hl
040A5A ED 53 9E 0A 0084*      ld (@de),de
       04          
040A5F 3A A0 0A 04 0085*      ld a,(@de+2)
040A63 CD F9 09 04 0086*      call mul24x8
040A67 CD 6E 0A 04 0087*      call @accumulate
040A6B             0088*  ; all done
040A6B DD E1       0089*      pop ix ; restore
040A6D C9          0090*      ret
040A6E             0091*  @accumulate:
040A6E DD 23       0092*      inc ix
040A70             0093*  ; highest byte of product to carry
040A70 DD 77 03    0094*      ld (ix+3),a
040A73             0095*  ; low byte of product
040A73 7D          0096*      ld a,l
040A74 DD 86 00    0097*      add a,(ix+0)
040A77 DD 77 00    0098*      ld (ix+0),a
040A7A             0099*  ; high byte of product
040A7A 7C          0100*      ld a,h
040A7B DD 8E 01    0101*      adc a,(ix+1)
040A7E DD 77 01    0102*      ld (ix+1),a
040A81             0103*  ; uppper byte of product
040A81 22 9B 0A 04 0104*      ld (@hl),hl
040A85 3A 9D 0A 04 0105*      ld a,(@hl+2)
040A89 DD 8E 02    0106*      adc a,(ix+2)
040A8C DD 77 02    0107*      ld (ix+2),a
040A8F             0108*  ; carry
040A8F 3E 00       0109*      ld a,0 ; preserve flags
040A91 DD 8E 03    0110*      adc a,(ix+3)
040A94 DD 77 03    0111*      ld (ix+3),a
040A97 C9          0112*      ret
040A98             0113*  
040A98 00 00 00    0114*  @ix: dl 0
040A9B 00 00 00    0115*  @hl: dl 0
040A9E 00 00 00    0116*  @de: dl 0
040AA1             0117*  
040AA1             0118*  ; UHL * UDE --> UHL (unsigned)
040AA1             0119*  umul24:
040AA1 CD 2F 0A 04 0120*      call mul24
040AA5 2A 29 0A 04 0121*      ld hl,(mul24out)
040AA9 C9          0122*      ret
040AAA             0123*  
040AAA             0124*  ; UH.L = UH.L*UD.E (unsigned)
040AAA             0125*  umul168:
040AAA CD 2F 0A 04 0126*      call mul24
040AAE 2A 2A 0A 04 0127*      ld hl,(mul24out+1)
040AB2 C9          0128*      ret
040AB3             0129*  
040AB3             0130*  ; UH.L * UD.E --> UH.L (signed)
040AB3             0131*  smul168:
040AB3             0132*  ; make everything positive and store sign flags
040AB3 CD 94 06 04 0133*      call hlu_abs
040AB7 F5          0134*      push af
040AB8 EB          0135*      ex de,hl
040AB9 CD 94 06 04 0136*      call hlu_abs
040ABD EB          0137*      ex de,hl
040ABE F5          0138*      push af
040ABF             0139*  ; do the division
040ABF CD AA 0A 04 0140*      call umul168 ; hl = product
040AC3             0141*  ; adjust sign of result
040AC3 F1          0142*      pop af ; sign de
040AC4 FA CF 0A 04 0143*      jp m,@de_neg
040AC8 F1          0144*      pop af ; sign hl
040AC9 F0          0145*      ret p ; both positive, nothing to do
040ACA             0146*  @hl_neg:
040ACA CD A4 06 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
040ACE C9          0148*      ret
040ACF             0149*  @de_neg:
040ACF F1          0150*      pop af
040AD0 F8          0151*      ret m ; both negative, nothing to do
040AD1 CD A4 06 04 0152*      call neg_hlu ; result is negative
040AD5 C9          0153*      ret
040AD6             0154*  
040AD6             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040AD6             0156*  ; perform unsigned division of 16.8 fixed place values
040AD6             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040AD6             0158*  udiv168:
040AD6             0159*  ; back up divisor
040AD6 ED 53 0D 0B 0160*      ld (@ude),de
       04          
040ADB             0161*  ; get the 16-bit integer part of the quotient
040ADB CD 3E 0B 04 0162*      call udiv24 ; de = quotient, hl = remainder
040ADF             0163*  ; load quotient to upper three bytes of output
040ADF ED 53 14 0B 0164*      ld (div168_out+1),de
       04          
040AE4             0165*  @div256:
040AE4             0166*  ; multiply remainder by 256
040AE4             0167*      hlu_mul256
040AE4 29          0001*M     add hl,hl ; * 2
040AE5 29          0002*M     add hl,hl ; * 4
040AE6 29          0003*M     add hl,hl ; * 8
040AE7 29          0004*M     add hl,hl ; * 16
040AE8 29          0005*M     add hl,hl ; * 32
040AE9 29          0006*M     add hl,hl ; * 64
040AEA 29          0007*M     add hl,hl ; * 128
040AEB 29          0008*M     add hl,hl ; * 256
040AEC             0168*  ; skip fractional computation if remainder is zero
040AEC             0169*      sign_hlu
040AEC 19          0001*M     add hl,de
040AED B7          0002*M     or a
040AEE ED 52       0003*M     sbc hl,de
040AF0 20 03       0170*      jr nz,@div_frac
040AF2 AF          0171*      xor a
040AF3 18 0A       0172*      jr @write_frac
040AF5             0173*  ; now divide the shifted remainder by the divisor
040AF5             0174*  @div_frac:
040AF5 ED 5B 0D 0B 0175*      ld de,(@ude) ; get back divisor
       04          
040AFA CD 3E 0B 04 0176*      call udiv24 ; de = quotient, hl = remainder
040AFE             0177*  ; load low byte of quotient to low byte of output
040AFE 7B          0178*      ld a,e
040AFF             0179*  @write_frac:
040AFF 32 13 0B 04 0180*      ld (div168_out),a
040B03             0181*  ; load de with return value
040B03 ED 5B 13 0B 0182*      ld de,(div168_out)
       04          
040B08             0183*  ; load a with any overflow
040B08 3A 16 0B 04 0184*      ld a,(div168_out+3)
040B0C C9          0185*      ret ; ud.e is the 16.8 result
040B0D             0186*  @ude: ds 6
040B13             0187*  div168_out: ds 4 ; the extra byte is for overflow
040B17             0188*  
040B17             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B17             0190*  ; perform signed division of 16.8 fixed place values
040B17             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B17             0192*  sdiv168:
040B17             0193*  ; make everything positive and store sign flags
040B17 CD 94 06 04 0194*      call hlu_abs
040B1B F5          0195*      push af
040B1C EB          0196*      ex de,hl
040B1D CD 94 06 04 0197*      call hlu_abs
040B21 EB          0198*      ex de,hl
040B22 F5          0199*      push af
040B23             0200*  ; do the division
040B23 CD D6 0A 04 0201*      call udiv168 ; de = quotient, hl = remainder
040B27             0202*  ; adjust sign of result
040B27 F1          0203*      pop af ; sign de
040B28 FA 35 0B 04 0204*      jp m,@de_neg
040B2C F1          0205*      pop af ; sign hl
040B2D F0          0206*      ret p ; both positive, nothing to do
040B2E             0207*  @hl_neg:
040B2E EB          0208*      ex de,hl ; hl = quotient, de = remainder
040B2F CD A4 06 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
040B33 EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
040B34 C9          0211*      ret
040B35             0212*  @de_neg:
040B35 F1          0213*      pop af
040B36 F8          0214*      ret m ; both negative, nothing to do
040B37 EB          0215*      ex de,hl ; hl = quotient, de = remainder
040B38 CD A4 06 04 0216*      call neg_hlu ; result is negative
040B3C EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
040B3D C9          0218*      ret
040B3E             0219*  
040B3E             0220*  ;------------------------------------------------------------------------
040B3E             0221*  ;  arith24.asm
040B3E             0222*  ;  24-bit ez80 arithmetic routines
040B3E             0223*  ;  Copyright (c) Shawn Sijnstra 2024
040B3E             0224*  ;  MIT license
040B3E             0225*  ;
040B3E             0226*  ;  This library was created as a tool to help make ez80
040B3E             0227*  ;  24-bit native assembly routines for simple mathematical problems
040B3E             0228*  ;  more widely available.
040B3E             0229*  ;
040B3E             0230*  ;------------------------------------------------------------------------
040B3E             0231*  ;
040B3E             0232*  ;------------------------------------------------------------------------
040B3E             0233*  ; udiv24
040B3E             0234*  ; Unsigned 24-bit division
040B3E             0235*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040B3E             0236*  ;
040B3E             0237*  ; Uses AF BC DE HL
040B3E             0238*  ; Uses Restoring Division algorithm
040B3E             0239*  ;------------------------------------------------------------------------
040B3E             0240*  
040B3E             0241*  udiv24:
040B3E E5          0242*      push hl
040B3F C1          0243*      pop bc ;move dividend to BCU
040B40 21 00 00 00 0244*      ld hl,0 ;result
040B44 A7          0245*      and a
040B45 ED 52       0246*      sbc hl,de ;test for div by 0
040B47 C8          0247*      ret z ;it's zero, carry flag is clear
040B48 19          0248*      add hl,de ;HL is 0 again
040B49 3E 18       0249*      ld a,24 ;number of loops through.
040B4B             0250*  udiv1:
040B4B C5          0251*      push bc ;complicated way of doing this because of lack of access to top bits
040B4C E3          0252*      ex (sp),hl
040B4D 37          0253*      scf
040B4E ED 6A       0254*      adc hl,hl
040B50 E3          0255*      ex (sp),hl
040B51 C1          0256*      pop bc ;we now have bc = (bc * 2) + 1
040B52             0257*  
040B52 ED 6A       0258*      adc hl,hl
040B54 A7          0259*      and a ;is this the bug
040B55 ED 52       0260*      sbc hl,de
040B57 30 02       0261*      jr nc,udiv2
040B59 19          0262*      add hl,de
040B5A             0263*  ;	dec	c
040B5A 0B          0264*      dec bc
040B5B             0265*  udiv2:
040B5B 3D          0266*      dec a
040B5C 20 ED       0267*      jr nz,udiv1
040B5E 37          0268*      scf ;flag used for div0 error
040B5F C5          0269*      push bc
040B60 D1          0270*      pop de ;remainder
040B61 C9          0271*      ret
040B62             0272*  
040B62             0273*  ;------------------------------------------------------------------------
040B62             0274*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
040B62             0275*  ;------------------------------------------------------------------------
040B62             0276*  
040B62             0277*  
040B62             0278*      ; include "trig24fast.inc"
040B62             0279*  
040B62             0280*  
040B62             0281*  ; convert signed angles from a 360 to 256 degree circle
040B62             0282*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B62             0283*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B62             0284*  ; destroys: TODO
040B62             0285*  deg_360_to_256:
040B62 D5          0286*      push de ; preserve de
040B63             0287*  ; make angle positive and store sign flag
040B63 CD 94 06 04 0288*      call hlu_abs
040B67 F5          0289*      push af
040B68             0290*  ; multiply by coversion factor of 256/360
040B68 11 B6 00 00 0291*      ld de,0x0000B6 ; 0.711
040B6C CD AA 0A 04 0292*      call umul168 ; uh.l = uh.l * 0.711
040B70             0293*  ; restore sign flag and adjust output accordingly
040B70 F1          0294*      pop af
040B71 F2 79 0B 04 0295*      jp p,@pos ; positive number
040B75 CD A4 06 04 0296*      call neg_hlu
040B79             0297*  @pos:
040B79             0298*  ; restore de and return uh.l as the result
040B79 D1          0299*      pop de
040B7A C9          0300*      ret
040B7B             0301*  
040B7B             0302*  ; convert signed angles from a 256 to 360 degree circle
040B7B             0303*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040B7B             0304*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040B7B             0305*  ; destroys: TODO
040B7B             0306*  deg_256_to_360:
040B7B D5          0307*      push de ; preserve de
040B7C             0308*  ; make angle positive and store sign flag
040B7C CD 94 06 04 0309*      call hlu_abs
040B80 F5          0310*      push af
040B81             0311*  ; multiply by coversion factor of 360/256
040B81 11 68 01 00 0312*      ld de,0x000168 ; 1.406
040B85 CD AA 0A 04 0313*      call umul168 ; uh.l = uh.l * 1.406
040B89             0314*  ; restore sign flag and adjust output accordingly
040B89 F1          0315*      pop af
040B8A F2 92 0B 04 0316*      jp p,@pos ; positive number
040B8E CD A4 06 04 0317*      call neg_hlu
040B92             0318*  @pos:
040B92             0319*  ; restore de and return uh.l as the result
040B92 D1          0320*      pop de
040B93 C9          0321*      ret
040B94             0322*  
040B94             0323*  ; fixed 16.8 routine
040B94             0324*  ; cos(uh.l) --> uh.l
040B94             0325*  ; destroys: f, hl
040B94             0326*  cos168:
040B94 D5          0327*      push de ; preserve de
040B95             0328*  ; for cos we simply increment the angle by 90 degrees
040B95             0329*  ; or 0x004000 in 16.8 degrees256
040B95             0330*  ; which makes it a sin problem
040B95 11 00 40 00 0331*      ld de,0x004000
040B99 19          0332*      add hl,de ; modulo 256 happens below
040B9A D1          0333*      pop de ; restore de
040B9B             0334*  ; fall through to sin168
040B9B             0335*  
040B9B             0336*  ; ---------------------
040B9B             0337*  ; fixed 16.8 routine
040B9B             0338*  ; sin(uh.l) --> uh.l
040B9B             0339*  ; destroys: f, hl
040B9B             0340*  sin168:
040B9B D5          0341*      push de
040B9C             0342*  ; handle negative angles appropriately
040B9C CD 94 06 04 0343*      call hlu_abs
040BA0 F2 A9 0B 04 0344*      jp p,@F
040BA4 11 00 00 FF 0345*      ld de,-256*256
040BA8 19          0346*      add hl,de
040BA9             0347*  @@:
040BA9 2E 03       0348*      ld l,3 ; multiply by 3 to get our lookup index
040BAB ED 6C       0349*      mlt hl
040BAD 11 F9 0D 04 0350*      ld de,sin_lut_168 ; grab the lut address
040BB1 19          0351*      add hl,de ; bump hl by the index
040BB2 ED 27       0352*      ld hl,(hl) ; don't try this on a z80!
040BB4 D1          0353*      pop de
040BB5 C9          0354*      ret
040BB6             0355*  
040BB6             0356*  ; 16.8 fixed inputs / outputs
040BB6             0357*  ; takes: uh.l as angle in degrees 256
040BB6             0358*  ;        ud.e as radius
040BB6             0359*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BB6             0360*  ;        displacements from origin (0,0)
040BB6             0361*  ; destroys: everything except indexes
040BB6             0362*  polar_to_cartesian:
040BB6             0363*  ; back up input parameters
040BB6 22 E5 0B 04 0364*      ld (@angle), hl
040BBA ED 53 E8 0B 0365*      ld (@radius), de
       04          
040BBF             0366*  ; compute dx = sin(uh.l) * ud.e
040BBF CD 9B 0B 04 0367*      call sin168 ; uh.l = sin(uh.l)
040BC3 ED 5B E8 0B 0368*      ld de,(@radius)
       04          
040BC8 CD B3 0A 04 0369*      call smul168 ; uh.l = dx
040BCC E5          0370*      push hl
040BCD             0371*  ; compute dy = -cos(uh.l) * ud.e
040BCD 2A E5 0B 04 0372*      ld hl,(@angle)
040BD1 CD 94 0B 04 0373*      call cos168 ; uh.l = cos(uh.l)
040BD5 ED 5B E8 0B 0374*      ld de,(@radius)
       04          
040BDA CD B3 0A 04 0375*      call smul168 ; uh.l = dy
040BDE CD A4 06 04 0376*      call neg_hlu ; invert dy for screen coords convention
040BE2 EB          0377*      ex de,hl ; de = dy for output
040BE3 C1          0378*      pop bc ; bc = dx for output
040BE4             0379*  ; and out
040BE4 C9          0380*      ret
040BE5             0381*  @angle: ds 3
040BE8             0382*  @radius: ds 3
040BEB             0383*  
040BEB             0384*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BEB             0385*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BEB             0386*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BEB             0387*  ;         also populates scratch locations dx168 and dy168
040BEB             0388*  ; destroys: a,hl,bc,de
040BEB             0389*  dxy168:
040BEB             0390*  ; compute dx = x1-x0
040BEB AF          0391*      xor a ; clear carry
040BEC DD E5       0392*      push ix ; move ix to hl via the stack
040BEE E1          0393*      pop hl ; hl = x1
040BEF ED 42       0394*      sbc hl,bc ; hl = dx
040BF1 22 06 0C 04 0395*      ld (dx168),hl ; dx to scratch
040BF5             0396*  ; compute dy = y1-y0
040BF5 AF          0397*      xor a ; clear carry
040BF6 FD E5       0398*      push iy ; move iy to hl via the stack
040BF8 E1          0399*      pop hl ; hl = y1
040BF9 ED 52       0400*      sbc hl,de ; hl = dy
040BFB 22 0C 0C 04 0401*      ld (dy168),hl ; dy to scratch
040BFF             0402*  ; populate output registers and return
040BFF EB          0403*      ex de,hl ; ud.e = dy
040C00 ED 4B 06 0C 0404*      ld bc,(dx168) ; ub.c = dx
       04          
040C05 C9          0405*      ret
040C06 00 00 00 00 0406*  dx168: blkb 6,0
       00 00       
040C0C 00 00 00 00 0407*  dy168: blkb 6,0
       00 00       
040C12             0408*  
040C12             0409*  ; compute the euclidian distance between two cartesian coordinates
040C12             0410*  ; using the formula d = sqrt(dx^2+dy^2)
040C12             0411*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C12             0412*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C12             0413*  ; output; uh.l is the 16.8 fixed format distance
040C12             0414*  ;         also populates scratch locations dx168 and dy168
040C12             0415*  ; destroys: a,hl,bc,de
040C12             0416*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C12             0417*  ;       thus the result will always be an integer, albeit in 16.8 format
040C12             0418*  distance168:
040C12 CD EB 0B 04 0419*      call dxy168 ; ub.c = dx, ud.e = dy
040C16             0420*  ; compute dy^2
040C16 EB          0421*      ex de,hl
040C17 CD 94 06 04 0422*      call hlu_abs
040C1B CD FB 06 04 0423*      call hlu_udiv256 ; make integer to avoid overflow
040C1F E5          0424*      push hl
040C20 D1          0425*      pop de
040C21 CD A1 0A 04 0426*      call umul24 ; hl = dy^2
040C25 E5          0427*      push hl ; save dy^2
040C26             0428*  ; compute dx^2
040C26 2A 06 0C 04 0429*      ld hl,(dx168)
040C2A CD 94 06 04 0430*      call hlu_abs
040C2E CD FB 06 04 0431*      call hlu_udiv256 ; make integer to avoid overflow
040C32 E5          0432*      push hl
040C33 D1          0433*      pop de
040C34 CD A1 0A 04 0434*      call umul24 ; hl = dx^2
040C38             0435*  ; add dx^2 and dy^2
040C38 D1          0436*      pop de ; de = dy^2 (was hl)
040C39 19          0437*      add hl,de ; hl = dx^2 + dy^2
040C3A             0438*  ; compute the square root
040C3A CD 13 0D 04 0439*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C3E EB          0440*      ex de,hl ; hl = distance
040C3F             0441*      hlu_mul256 ; convert back to 16.8 fixed
040C3F 29          0001*M     add hl,hl ; * 2
040C40 29          0002*M     add hl,hl ; * 4
040C41 29          0003*M     add hl,hl ; * 8
040C42 29          0004*M     add hl,hl ; * 16
040C43 29          0005*M     add hl,hl ; * 32
040C44 29          0006*M     add hl,hl ; * 64
040C45 29          0007*M     add hl,hl ; * 128
040C46 29          0008*M     add hl,hl ; * 256
040C47 C9          0442*      ret
040C48             0443*  
040C48             0444*  ; atan2_(ub.c,ud.e) --> uh.l
040C48             0445*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C48             0446*  ;   whether inputs are integers or fractional doesn't matter
040C48             0447*  ;   so long as the sign bit of the upper byte is correct
040C48             0448*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C48             0449*  ; angles are COMPASS HEADINGS based on
040C48             0450*  ; screen coordinate conventions,where the y axis is flipped
040C48             0451*  ; #E0 224      0       32 #20
040C48             0452*  ;        -x,-y | +x,-y
040C48             0453*  ; #C0 192------+------ 64 #40
040C48             0454*  ;        -x,+y | +x,+y
040C48             0455*  ; #A0 160   128 #80   96 #60
040C48             0456*  atan2_168fast:
040C48             0457*  ; get signs and make everything positive
040C48             0458*  ; get abs(x) and store its original sign
040C48 C5          0459*      push bc
040C49 E1          0460*      pop hl
040C4A CD 94 06 04 0461*      call hlu_abs ; if x was negative this also sets the sign flag
040C4E E5          0462*      push hl ; store abs(x)
040C4F C1          0463*      pop bc ; bc = abs(x)
040C50 F5          0464*      push af ; store sign of x
040C51             0465*  ; get abs(y) and store its original sign
040C51 EB          0466*      ex de,hl ; hl = y
040C52 CD 94 06 04 0467*      call hlu_abs ; if y was negative this also sets the sign flag
040C56 EB          0468*      ex de,hl ; de = abs(y)
040C57 F5          0469*      push af ; store sign of y
040C58             0470*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C58             0471*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C58 AF          0472*      xor a ; clear the carry flag
040C59 D5          0473*      push de
040C5A E1          0474*      pop hl
040C5B ED 42       0475*      sbc hl,bc
040C5D F5          0476*      push af ; save sign of de - bc
040C5E F2 67 0C 04 0477*      jp p,@1 ; bc <= de, so we skip ahead
040C62             0478*  ; otherwise we swap bc and de
040C62 C5          0479*      push bc
040C63 E1          0480*      pop hl
040C64 EB          0481*      ex de,hl
040C65 E5          0482*      push hl
040C66 C1          0483*      pop bc
040C67             0484*  @1:
040C67             0485*  ; now we're ready to snag our preliminary result
040C67 C5          0486*      push bc
040C68 E1          0487*      pop hl
040C69 CD D7 0C 04 0488*      call atan_168fast ; uh.l comes back with prelim result
040C6D             0489*  ; now we adjust uh.l based on sign of de - bc
040C6D F1          0490*      pop af
040C6E F2 7A 0C 04 0491*      jp p,@2 ; bc <= de,so we skip ahead
040C72 EB          0492*      ex de,hl
040C73 21 00 40 00 0493*      ld hl,64*256 ; subtract from 64 (90) degrees
040C77 AF          0494*      xor a ; clear the carry flag
040C78 ED 52       0495*      sbc hl,de
040C7A             0496*  @2:
040C7A             0497*  ; adjust the result based on quadrant
040C7A             0498*  ; #E0 224      0       32 #20
040C7A             0499*  ;        -x,-y | +x,-y
040C7A             0500*  ; #C0 192------+------ 64 #40
040C7A             0501*  ;        -x,+y | +x,+y
040C7A             0502*  ; #A0 160   128 #80   96 #60
040C7A F1          0503*      pop af ; sign of y
040C7B CA B8 0C 04 0504*      jp z,@y_zero
040C7F F2 98 0C 04 0505*      jp p,@y_pos
040C83             0506*  ; y neg,check x
040C83 F1          0507*      pop af ; sign of x
040C84 CA 92 0C 04 0508*      jp z,@y_neg_x_zero
040C88 F2 97 0C 04 0509*      jp p,@y_neg_x_pos
040C8C             0510*  ; y neg,x neg
040C8C             0511*  ; angle is 128 to 256 (270 to 360)
040C8C             0512*  ; negating the intermediate does the trick
040C8C CD A4 06 04 0513*      call neg_hlu
040C90 18 31       0514*      jr @zero_hlu
040C92             0515*  
040C92             0516*  @y_neg_x_zero:
040C92             0517*  ; y neg,x zero
040C92             0518*  ; angle is 0
040C92 21 00 00 00 0519*      ld hl,0
040C96 C9          0520*      ret
040C97             0521*  @y_neg_x_pos:
040C97             0522*  ; y neg,x pos
040C97             0523*  ; angle is 0 to 64 (0 to 90)
040C97             0524*  ; so we're good
040C97 C9          0525*      ret
040C98             0526*  
040C98             0527*  @y_pos:
040C98 F1          0528*      pop af ; sign of x
040C99 CA A8 0C 04 0529*      jp z,@y_pos_x_zero
040C9D F2 AD 0C 04 0530*      jp p,@y_pos_x_pos
040CA1             0531*  ; y pos,x neg
040CA1             0532*  ; angle is 128 to 192 (180-270)
040CA1             0533*  ; so we add 128 to intermediate
040CA1 11 00 80 00 0534*      ld de,128*256
040CA5 19          0535*      add hl,de
040CA6 18 1B       0536*      jr @zero_hlu
040CA8             0537*  @y_pos_x_zero:
040CA8             0538*  ; y pos,x zero
040CA8             0539*  ; angle is 128 (180)
040CA8 21 00 80 00 0540*      ld hl,128*256
040CAC C9          0541*      ret
040CAD             0542*  @y_pos_x_pos:
040CAD             0543*  ; y pos,x pos
040CAD             0544*  ; angle is 64 to 128 (90 to 180)
040CAD             0545*  ; neg the intermediate and add 180 degrees
040CAD CD A4 06 04 0546*      call neg_hlu
040CB1 11 00 80 00 0547*      ld de,128*256
040CB5 19          0548*      add hl,de
040CB6 18 0B       0549*      jr @zero_hlu
040CB8             0550*  
040CB8             0551*  @y_zero:
040CB8 F1          0552*      pop af ; sign of x
040CB9 FA BE 0C 04 0553*      jp m,@y_zero_x_neg
040CBD             0554*  ; y zero,x pos
040CBD             0555*  ; angle is 64 (90),nothing to do
040CBD C9          0556*      ret
040CBE             0557*  @y_zero_x_neg:
040CBE             0558*  ; y zero ,x neg
040CBE             0559*  ; angle is 192 (270)
040CBE 21 00 C0 00 0560*      ld hl,192*256
040CC2 C9          0561*      ret
040CC3             0562*  @zero_hlu:
040CC3 AF          0563*      xor a
040CC4 22 D1 0C 04 0564*      ld (@scratch),hl
040CC8 32 D3 0C 04 0565*      ld (@scratch+2),a
040CCC 2A D1 0C 04 0566*      ld hl,(@scratch)
040CD0 C9          0567*      ret
040CD1             0568*  @scratch: ds 6
040CD7             0569*  
040CD7             0570*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CD7             0571*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040CD7             0572*  ; destroys: a,hl,bc,de
040CD7             0573*  ; note: only works for angles from 0 to 32 (45) degrees
040CD7             0574*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040CD7             0575*  atan_168fast:
040CD7             0576*  ; because we use compass headings instead of geometric angles
040CD7             0577*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040CD7             0578*  ; we can do faster unsigned division here because we know dx and dy are positive
040CD7 CD D6 0A 04 0579*      call udiv168 ; ud.e = dx/dy
040CDB EB          0580*      ex de,hl ; uh.l = dx/dy
040CDC             0581*  ; test uh.l for 0
040CDC 19          0582*      add hl,de
040CDD B7          0583*      or a
040CDE ED 52       0584*      sbc hl,de
040CE0 28 22       0585*      jr z,@is_zero
040CE2             0586*  ; test uh.l for 1
040CE2 AF          0587*      xor a ; clear carry
040CE3 EB          0588*      ex de,hl
040CE4 21 00 01 00 0589*      ld hl,1*256 ; 1 in 16.8 fixed format
040CE8 ED 52       0590*      sbc hl,de
040CEA 28 13       0591*      jr z,@is_45
040CEC EB          0592*      ex de,hl
040CED             0593*  ; no special cases so we move on
040CED             0594*  ; l contains the fractional portion of tan(uh.l)
040CED             0595*  ; we multiply it by three to get our lookup table index
040CED 26 03       0596*      ld h,3
040CEF ED 6C       0597*      mlt hl ; index into lut
040CF1 11 00 00 00 0598*      ld de,0 ; clear deu
040CF5 54          0599*      ld d,h ; copy hl to de
040CF6 5D          0600*      ld e,l ; de contains our index
040CF7 21 FC 10 04 0601*      ld hl,atan_lut_168 ; grab the lut address
040CFB 19          0602*      add hl,de ; bump hl by the index
040CFC ED 27       0603*      ld hl,(hl) ; don't try this on a z80!
040CFE C9          0604*      ret ; and out
040CFF             0605*  @is_45:
040CFF 21 00 40 00 0606*      ld hl,64*256
040D03 C9          0607*      ret
040D04             0608*  ; for the case tan(0)
040D04             0609*  @is_zero:
040D04 21 00 00 00 0610*      ld hl,0*256
040D08 C9          0611*      ret
040D09             0612*  
040D09             0613*  ; Expects  ADL mode
040D09             0614*  ; Inputs:  UH.L
040D09             0615*  ; Outputs: UH.L is the 16.8 square root
040D09             0616*  ;          UDE is the integer difference inputHL-DE^2
040D09             0617*  sqrt168:
040D09 CD 13 0D 04 0618*      call sqrt24
040D0D EB          0619*      ex de,hl
040D0E 29          0620*      add hl,hl
040D0F 29          0621*      add hl,hl
040D10 29          0622*      add hl,hl
040D11 29          0623*      add hl,hl
040D12 C9          0624*      ret
040D13             0625*  
040D13             0626*  ; credit: xeda112358
040D13             0627*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D13             0628*  sqrt24:
040D13             0629*  ; Expects ADL mode
040D13             0630*  ; Inputs: HL
040D13             0631*  ; Outputs: DE is the integer square root
040D13             0632*  ;  HL is the difference inputHL-DE^2
040D13             0633*  ;  c flag reset
040D13 01 00 00 00 0634*      ld bc,0 ; clear bcu
040D17 11 00 00 00 0635*      ld de,0 ; clear deu
040D1B AF          0636*      xor a
040D1C 45          0637*      ld b,l
040D1D C5          0638*      push bc
040D1E 47          0639*      ld b,a
040D1F 6F          0640*      ld l,a
040D20             0641*  ; Iteration 1
040D20 29          0642*      add hl,hl
040D21 CB 11       0643*      rl c
040D23 29          0644*      add hl,hl
040D24 CB 11       0645*      rl c
040D26 91          0646*      sub c
040D27 30 04       0647*      jr nc,$+6
040D29 1C          0648*      inc e
040D2A 1C          0649*      inc e
040D2B 2F          0650*      cpl
040D2C 4F          0651*      ld c,a
040D2D             0652*  ; Iteration 2
040D2D 29          0653*      add hl,hl
040D2E CB 11       0654*      rl c
040D30 29          0655*      add hl,hl
040D31 CB 11       0656*      rl c
040D33 CB 13       0657*      rl e
040D35 7B          0658*      ld a,e
040D36 91          0659*      sub c
040D37 30 04       0660*      jr nc,$+6
040D39 1C          0661*      inc e
040D3A 1C          0662*      inc e
040D3B 2F          0663*      cpl
040D3C 4F          0664*      ld c,a
040D3D             0665*  ; Iteration 3
040D3D 29          0666*      add hl,hl
040D3E CB 11       0667*      rl c
040D40 29          0668*      add hl,hl
040D41 CB 11       0669*      rl c
040D43 CB 13       0670*      rl e
040D45 7B          0671*      ld a,e
040D46 91          0672*      sub c
040D47 30 04       0673*      jr nc,$+6
040D49 1C          0674*      inc e
040D4A 1C          0675*      inc e
040D4B 2F          0676*      cpl
040D4C 4F          0677*      ld c,a
040D4D             0678*  ; Iteration 4
040D4D 29          0679*      add hl,hl
040D4E CB 11       0680*      rl c
040D50 29          0681*      add hl,hl
040D51 CB 11       0682*      rl c
040D53 CB 13       0683*      rl e
040D55 7B          0684*      ld a,e
040D56 91          0685*      sub c
040D57 30 04       0686*      jr nc,$+6
040D59 1C          0687*      inc e
040D5A 1C          0688*      inc e
040D5B 2F          0689*      cpl
040D5C 4F          0690*      ld c,a
040D5D             0691*  ; Iteration 5
040D5D 29          0692*      add hl,hl
040D5E CB 11       0693*      rl c
040D60 29          0694*      add hl,hl
040D61 CB 11       0695*      rl c
040D63 CB 13       0696*      rl e
040D65 7B          0697*      ld a,e
040D66 91          0698*      sub c
040D67 30 04       0699*      jr nc,$+6
040D69 1C          0700*      inc e
040D6A 1C          0701*      inc e
040D6B 2F          0702*      cpl
040D6C 4F          0703*      ld c,a
040D6D             0704*  ; Iteration 6
040D6D 29          0705*      add hl,hl
040D6E CB 11       0706*      rl c
040D70 29          0707*      add hl,hl
040D71 CB 11       0708*      rl c
040D73 CB 13       0709*      rl e
040D75 7B          0710*      ld a,e
040D76 91          0711*      sub c
040D77 30 04       0712*      jr nc,$+6
040D79 1C          0713*      inc e
040D7A 1C          0714*      inc e
040D7B 2F          0715*      cpl
040D7C 4F          0716*      ld c,a
040D7D             0717*  ; Iteration 7
040D7D 29          0718*      add hl,hl
040D7E CB 11       0719*      rl c
040D80 29          0720*      add hl,hl
040D81 CB 11       0721*      rl c
040D83 CB 10       0722*      rl b
040D85 EB          0723*      ex de,hl
040D86 29          0724*      add hl,hl
040D87 E5          0725*      push hl
040D88 ED 42       0726*      sbc hl,bc
040D8A 30 06       0727*      jr nc,$+8
040D8C 7C          0728*      ld a,h
040D8D 2F          0729*      cpl
040D8E 47          0730*      ld b,a
040D8F 7D          0731*      ld a,l
040D90 2F          0732*      cpl
040D91 4F          0733*      ld c,a
040D92 E1          0734*      pop hl
040D93 30 02       0735*      jr nc,$+4
040D95 23          0736*      inc hl
040D96 23          0737*      inc hl
040D97 EB          0738*      ex de,hl
040D98             0739*  ; Iteration 8
040D98 29          0740*      add hl,hl
040D99 69          0741*      ld l,c
040D9A 60          0742*      ld h,b
040D9B ED 6A       0743*      adc hl,hl
040D9D ED 6A       0744*      adc hl,hl
040D9F EB          0745*      ex de,hl
040DA0 29          0746*      add hl,hl
040DA1 ED 52       0747*      sbc hl,de
040DA3 19          0748*      add hl,de
040DA4 EB          0749*      ex de,hl
040DA5 30 04       0750*      jr nc,$+6
040DA7 ED 52       0751*      sbc hl,de
040DA9 13          0752*      inc de
040DAA 13          0753*      inc de
040DAB             0754*  ; Iteration 9
040DAB F1          0755*      pop af
040DAC 17          0756*      rla
040DAD ED 6A       0757*      adc hl,hl
040DAF 17          0758*      rla
040DB0 ED 6A       0759*      adc hl,hl
040DB2 EB          0760*      ex de,hl
040DB3 29          0761*      add hl,hl
040DB4 ED 52       0762*      sbc hl,de
040DB6 19          0763*      add hl,de
040DB7 EB          0764*      ex de,hl
040DB8 30 04       0765*      jr nc,$+6
040DBA ED 52       0766*      sbc hl,de
040DBC 13          0767*      inc de
040DBD 13          0768*      inc de
040DBE             0769*  ; Iteration 10
040DBE 17          0770*      rla
040DBF ED 6A       0771*      adc hl,hl
040DC1 17          0772*      rla
040DC2 ED 6A       0773*      adc hl,hl
040DC4 EB          0774*      ex de,hl
040DC5 29          0775*      add hl,hl
040DC6 ED 52       0776*      sbc hl,de
040DC8 19          0777*      add hl,de
040DC9 EB          0778*      ex de,hl
040DCA 30 04       0779*      jr nc,$+6
040DCC ED 52       0780*      sbc hl,de
040DCE 13          0781*      inc de
040DCF 13          0782*      inc de
040DD0             0783*  ; Iteration 11
040DD0 17          0784*      rla
040DD1 ED 6A       0785*      adc hl,hl
040DD3 17          0786*      rla
040DD4 ED 6A       0787*      adc hl,hl
040DD6 EB          0788*      ex de,hl
040DD7 29          0789*      add hl,hl
040DD8 ED 52       0790*      sbc hl,de
040DDA 19          0791*      add hl,de
040DDB EB          0792*      ex de,hl
040DDC 30 04       0793*      jr nc,$+6
040DDE ED 52       0794*      sbc hl,de
040DE0 13          0795*      inc de
040DE1 13          0796*      inc de
040DE2             0797*  ; Iteration 12
040DE2 17          0798*      rla
040DE3 ED 6A       0799*      adc hl,hl
040DE5 17          0800*      rla
040DE6 ED 6A       0801*      adc hl,hl
040DE8 EB          0802*      ex de,hl
040DE9 29          0803*      add hl,hl
040DEA ED 52       0804*      sbc hl,de
040DEC 19          0805*      add hl,de
040DED EB          0806*      ex de,hl
040DEE 30 04       0807*      jr nc,$+6
040DF0 ED 52       0808*      sbc hl,de
040DF2 13          0809*      inc de
040DF3 13          0810*      inc de
040DF4 CB 1A       0811*      rr d
040DF6 CB 1B       0812*      rr e
040DF8 C9          0813*      ret
040DF9             0814*  
040DF9             0815*  sin_lut_168:
040DF9 00 00 00    0816*      dl 0x000000 ; 0.000 00, 0.000
040DFC 06 00 00    0817*      dl 0x000006 ; 1.406 01, 0.025
040DFF 0C 00 00    0818*      dl 0x00000C ; 2.813 02, 0.049
040E02 12 00 00    0819*      dl 0x000012 ; 4.219 03, 0.074
040E05 19 00 00    0820*      dl 0x000019 ; 5.625 04, 0.098
040E08 1F 00 00    0821*      dl 0x00001F ; 7.031 05, 0.122
040E0B 25 00 00    0822*      dl 0x000025 ; 8.438 06, 0.147
040E0E 2B 00 00    0823*      dl 0x00002B ; 9.844 07, 0.171
040E11 31 00 00    0824*      dl 0x000031 ; 11.250 08, 0.195
040E14 38 00 00    0825*      dl 0x000038 ; 12.656 09, 0.219
040E17 3E 00 00    0826*      dl 0x00003E ; 14.063 0A, 0.243
040E1A 44 00 00    0827*      dl 0x000044 ; 15.469 0B, 0.267
040E1D 4A 00 00    0828*      dl 0x00004A ; 16.875 0C, 0.290
040E20 50 00 00    0829*      dl 0x000050 ; 18.281 0D, 0.314
040E23 56 00 00    0830*      dl 0x000056 ; 19.688 0E, 0.337
040E26 5C 00 00    0831*      dl 0x00005C ; 21.094 0F, 0.360
040E29 61 00 00    0832*      dl 0x000061 ; 22.500 10, 0.383
040E2C 67 00 00    0833*      dl 0x000067 ; 23.906 11, 0.405
040E2F 6D 00 00    0834*      dl 0x00006D ; 25.313 12, 0.428
040E32 73 00 00    0835*      dl 0x000073 ; 26.719 13, 0.450
040E35 78 00 00    0836*      dl 0x000078 ; 28.125 14, 0.471
040E38 7E 00 00    0837*      dl 0x00007E ; 29.531 15, 0.493
040E3B 83 00 00    0838*      dl 0x000083 ; 30.938 16, 0.514
040E3E 88 00 00    0839*      dl 0x000088 ; 32.344 17, 0.535
040E41 8E 00 00    0840*      dl 0x00008E ; 33.750 18, 0.556
040E44 93 00 00    0841*      dl 0x000093 ; 35.156 19, 0.576
040E47 98 00 00    0842*      dl 0x000098 ; 36.563 1A, 0.596
040E4A 9D 00 00    0843*      dl 0x00009D ; 37.969 1B, 0.615
040E4D A2 00 00    0844*      dl 0x0000A2 ; 39.375 1C, 0.634
040E50 A7 00 00    0845*      dl 0x0000A7 ; 40.781 1D, 0.653
040E53 AB 00 00    0846*      dl 0x0000AB ; 42.188 1E, 0.672
040E56 B0 00 00    0847*      dl 0x0000B0 ; 43.594 1F, 0.690
040E59 B5 00 00    0848*      dl 0x0000B5 ; 45.000 20, 0.707
040E5C B9 00 00    0849*      dl 0x0000B9 ; 46.406 21, 0.724
040E5F BD 00 00    0850*      dl 0x0000BD ; 47.813 22, 0.741
040E62 C1 00 00    0851*      dl 0x0000C1 ; 49.219 23, 0.757
040E65 C5 00 00    0852*      dl 0x0000C5 ; 50.625 24, 0.773
040E68 C9 00 00    0853*      dl 0x0000C9 ; 52.031 25, 0.788
040E6B CD 00 00    0854*      dl 0x0000CD ; 53.438 26, 0.803
040E6E D1 00 00    0855*      dl 0x0000D1 ; 54.844 27, 0.818
040E71 D4 00 00    0856*      dl 0x0000D4 ; 56.250 28, 0.831
040E74 D8 00 00    0857*      dl 0x0000D8 ; 57.656 29, 0.845
040E77 DB 00 00    0858*      dl 0x0000DB ; 59.063 2A, 0.858
040E7A DE 00 00    0859*      dl 0x0000DE ; 60.469 2B, 0.870
040E7D E1 00 00    0860*      dl 0x0000E1 ; 61.875 2C, 0.882
040E80 E4 00 00    0861*      dl 0x0000E4 ; 63.281 2D, 0.893
040E83 E7 00 00    0862*      dl 0x0000E7 ; 64.688 2E, 0.904
040E86 EA 00 00    0863*      dl 0x0000EA ; 66.094 2F, 0.914
040E89 EC 00 00    0864*      dl 0x0000EC ; 67.500 30, 0.924
040E8C EE 00 00    0865*      dl 0x0000EE ; 68.906 31, 0.933
040E8F F1 00 00    0866*      dl 0x0000F1 ; 70.313 32, 0.942
040E92 F3 00 00    0867*      dl 0x0000F3 ; 71.719 33, 0.950
040E95 F4 00 00    0868*      dl 0x0000F4 ; 73.125 34, 0.957
040E98 F6 00 00    0869*      dl 0x0000F6 ; 74.531 35, 0.964
040E9B F8 00 00    0870*      dl 0x0000F8 ; 75.938 36, 0.970
040E9E F9 00 00    0871*      dl 0x0000F9 ; 77.344 37, 0.976
040EA1 FB 00 00    0872*      dl 0x0000FB ; 78.750 38, 0.981
040EA4 FC 00 00    0873*      dl 0x0000FC ; 80.156 39, 0.985
040EA7 FD 00 00    0874*      dl 0x0000FD ; 81.563 3A, 0.989
040EAA FE 00 00    0875*      dl 0x0000FE ; 82.969 3B, 0.992
040EAD FE 00 00    0876*      dl 0x0000FE ; 84.375 3C, 0.995
040EB0 FF 00 00    0877*      dl 0x0000FF ; 85.781 3D, 0.997
040EB3 FF 00 00    0878*      dl 0x0000FF ; 87.188 3E, 0.999
040EB6 FF 00 00    0879*      dl 0x0000FF ; 88.594 3F, 1.000
040EB9 00 01 00    0880*      dl 0x000100 ; 90.000 40, 1.000
040EBC FF 00 00    0881*      dl 0x0000FF ; 91.406 41, 1.000
040EBF FF 00 00    0882*      dl 0x0000FF ; 92.813 42, 0.999
040EC2 FF 00 00    0883*      dl 0x0000FF ; 94.219 43, 0.997
040EC5 FE 00 00    0884*      dl 0x0000FE ; 95.625 44, 0.995
040EC8 FE 00 00    0885*      dl 0x0000FE ; 97.031 45, 0.992
040ECB FD 00 00    0886*      dl 0x0000FD ; 98.438 46, 0.989
040ECE FC 00 00    0887*      dl 0x0000FC ; 99.844 47, 0.985
040ED1 FB 00 00    0888*      dl 0x0000FB ; 101.250 48, 0.981
040ED4 F9 00 00    0889*      dl 0x0000F9 ; 102.656 49, 0.976
040ED7 F8 00 00    0890*      dl 0x0000F8 ; 104.063 4A, 0.970
040EDA F6 00 00    0891*      dl 0x0000F6 ; 105.469 4B, 0.964
040EDD F4 00 00    0892*      dl 0x0000F4 ; 106.875 4C, 0.957
040EE0 F3 00 00    0893*      dl 0x0000F3 ; 108.281 4D, 0.950
040EE3 F1 00 00    0894*      dl 0x0000F1 ; 109.688 4E, 0.942
040EE6 EE 00 00    0895*      dl 0x0000EE ; 111.094 4F, 0.933
040EE9 EC 00 00    0896*      dl 0x0000EC ; 112.500 50, 0.924
040EEC EA 00 00    0897*      dl 0x0000EA ; 113.906 51, 0.914
040EEF E7 00 00    0898*      dl 0x0000E7 ; 115.313 52, 0.904
040EF2 E4 00 00    0899*      dl 0x0000E4 ; 116.719 53, 0.893
040EF5 E1 00 00    0900*      dl 0x0000E1 ; 118.125 54, 0.882
040EF8 DE 00 00    0901*      dl 0x0000DE ; 119.531 55, 0.870
040EFB DB 00 00    0902*      dl 0x0000DB ; 120.938 56, 0.858
040EFE D8 00 00    0903*      dl 0x0000D8 ; 122.344 57, 0.845
040F01 D4 00 00    0904*      dl 0x0000D4 ; 123.750 58, 0.831
040F04 D1 00 00    0905*      dl 0x0000D1 ; 125.156 59, 0.818
040F07 CD 00 00    0906*      dl 0x0000CD ; 126.563 5A, 0.803
040F0A C9 00 00    0907*      dl 0x0000C9 ; 127.969 5B, 0.788
040F0D C5 00 00    0908*      dl 0x0000C5 ; 129.375 5C, 0.773
040F10 C1 00 00    0909*      dl 0x0000C1 ; 130.781 5D, 0.757
040F13 BD 00 00    0910*      dl 0x0000BD ; 132.188 5E, 0.741
040F16 B9 00 00    0911*      dl 0x0000B9 ; 133.594 5F, 0.724
040F19 B5 00 00    0912*      dl 0x0000B5 ; 135.000 60, 0.707
040F1C B0 00 00    0913*      dl 0x0000B0 ; 136.406 61, 0.690
040F1F AB 00 00    0914*      dl 0x0000AB ; 137.813 62, 0.672
040F22 A7 00 00    0915*      dl 0x0000A7 ; 139.219 63, 0.653
040F25 A2 00 00    0916*      dl 0x0000A2 ; 140.625 64, 0.634
040F28 9D 00 00    0917*      dl 0x00009D ; 142.031 65, 0.615
040F2B 98 00 00    0918*      dl 0x000098 ; 143.438 66, 0.596
040F2E 93 00 00    0919*      dl 0x000093 ; 144.844 67, 0.576
040F31 8E 00 00    0920*      dl 0x00008E ; 146.250 68, 0.556
040F34 88 00 00    0921*      dl 0x000088 ; 147.656 69, 0.535
040F37 83 00 00    0922*      dl 0x000083 ; 149.063 6A, 0.514
040F3A 7E 00 00    0923*      dl 0x00007E ; 150.469 6B, 0.493
040F3D 78 00 00    0924*      dl 0x000078 ; 151.875 6C, 0.471
040F40 73 00 00    0925*      dl 0x000073 ; 153.281 6D, 0.450
040F43 6D 00 00    0926*      dl 0x00006D ; 154.688 6E, 0.428
040F46 67 00 00    0927*      dl 0x000067 ; 156.094 6F, 0.405
040F49 61 00 00    0928*      dl 0x000061 ; 157.500 70, 0.383
040F4C 5C 00 00    0929*      dl 0x00005C ; 158.906 71, 0.360
040F4F 56 00 00    0930*      dl 0x000056 ; 160.313 72, 0.337
040F52 50 00 00    0931*      dl 0x000050 ; 161.719 73, 0.314
040F55 4A 00 00    0932*      dl 0x00004A ; 163.125 74, 0.290
040F58 44 00 00    0933*      dl 0x000044 ; 164.531 75, 0.267
040F5B 3E 00 00    0934*      dl 0x00003E ; 165.938 76, 0.243
040F5E 38 00 00    0935*      dl 0x000038 ; 167.344 77, 0.219
040F61 31 00 00    0936*      dl 0x000031 ; 168.750 78, 0.195
040F64 2B 00 00    0937*      dl 0x00002B ; 170.156 79, 0.171
040F67 25 00 00    0938*      dl 0x000025 ; 171.563 7A, 0.147
040F6A 1F 00 00    0939*      dl 0x00001F ; 172.969 7B, 0.122
040F6D 19 00 00    0940*      dl 0x000019 ; 174.375 7C, 0.098
040F70 12 00 00    0941*      dl 0x000012 ; 175.781 7D, 0.074
040F73 0C 00 00    0942*      dl 0x00000C ; 177.188 7E, 0.049
040F76 06 00 00    0943*      dl 0x000006 ; 178.594 7F, 0.025
040F79 00 00 00    0944*      dl 0x000000 ; 180.000 80, 0.000
040F7C FA FF FF    0945*      dl 0xFFFFFA ; 181.406 81, -0.025
040F7F F4 FF FF    0946*      dl 0xFFFFF4 ; 182.813 82, -0.049
040F82 EE FF FF    0947*      dl 0xFFFFEE ; 184.219 83, -0.074
040F85 E7 FF FF    0948*      dl 0xFFFFE7 ; 185.625 84, -0.098
040F88 E1 FF FF    0949*      dl 0xFFFFE1 ; 187.031 85, -0.122
040F8B DB FF FF    0950*      dl 0xFFFFDB ; 188.438 86, -0.147
040F8E D5 FF FF    0951*      dl 0xFFFFD5 ; 189.844 87, -0.171
040F91 CF FF FF    0952*      dl 0xFFFFCF ; 191.250 88, -0.195
040F94 C8 FF FF    0953*      dl 0xFFFFC8 ; 192.656 89, -0.219
040F97 C2 FF FF    0954*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040F9A BC FF FF    0955*      dl 0xFFFFBC ; 195.469 8B, -0.267
040F9D B6 FF FF    0956*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040FA0 B0 FF FF    0957*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040FA3 AA FF FF    0958*      dl 0xFFFFAA ; 199.688 8E, -0.337
040FA6 A4 FF FF    0959*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040FA9 9F FF FF    0960*      dl 0xFFFF9F ; 202.500 90, -0.383
040FAC 99 FF FF    0961*      dl 0xFFFF99 ; 203.906 91, -0.405
040FAF 93 FF FF    0962*      dl 0xFFFF93 ; 205.313 92, -0.428
040FB2 8D FF FF    0963*      dl 0xFFFF8D ; 206.719 93, -0.450
040FB5 88 FF FF    0964*      dl 0xFFFF88 ; 208.125 94, -0.471
040FB8 82 FF FF    0965*      dl 0xFFFF82 ; 209.531 95, -0.493
040FBB 7D FF FF    0966*      dl 0xFFFF7D ; 210.938 96, -0.514
040FBE 78 FF FF    0967*      dl 0xFFFF78 ; 212.344 97, -0.535
040FC1 72 FF FF    0968*      dl 0xFFFF72 ; 213.750 98, -0.556
040FC4 6D FF FF    0969*      dl 0xFFFF6D ; 215.156 99, -0.576
040FC7 68 FF FF    0970*      dl 0xFFFF68 ; 216.563 9A, -0.596
040FCA 63 FF FF    0971*      dl 0xFFFF63 ; 217.969 9B, -0.615
040FCD 5E FF FF    0972*      dl 0xFFFF5E ; 219.375 9C, -0.634
040FD0 59 FF FF    0973*      dl 0xFFFF59 ; 220.781 9D, -0.653
040FD3 55 FF FF    0974*      dl 0xFFFF55 ; 222.188 9E, -0.672
040FD6 50 FF FF    0975*      dl 0xFFFF50 ; 223.594 9F, -0.690
040FD9 4B FF FF    0976*      dl 0xFFFF4B ; 225.000 A0, -0.707
040FDC 47 FF FF    0977*      dl 0xFFFF47 ; 226.406 A1, -0.724
040FDF 43 FF FF    0978*      dl 0xFFFF43 ; 227.813 A2, -0.741
040FE2 3F FF FF    0979*      dl 0xFFFF3F ; 229.219 A3, -0.757
040FE5 3B FF FF    0980*      dl 0xFFFF3B ; 230.625 A4, -0.773
040FE8 37 FF FF    0981*      dl 0xFFFF37 ; 232.031 A5, -0.788
040FEB 33 FF FF    0982*      dl 0xFFFF33 ; 233.438 A6, -0.803
040FEE 2F FF FF    0983*      dl 0xFFFF2F ; 234.844 A7, -0.818
040FF1 2C FF FF    0984*      dl 0xFFFF2C ; 236.250 A8, -0.831
040FF4 28 FF FF    0985*      dl 0xFFFF28 ; 237.656 A9, -0.845
040FF7 25 FF FF    0986*      dl 0xFFFF25 ; 239.063 AA, -0.858
040FFA 22 FF FF    0987*      dl 0xFFFF22 ; 240.469 AB, -0.870
040FFD 1F FF FF    0988*      dl 0xFFFF1F ; 241.875 AC, -0.882
041000 1C FF FF    0989*      dl 0xFFFF1C ; 243.281 AD, -0.893
041003 19 FF FF    0990*      dl 0xFFFF19 ; 244.688 AE, -0.904
041006 16 FF FF    0991*      dl 0xFFFF16 ; 246.094 AF, -0.914
041009 14 FF FF    0992*      dl 0xFFFF14 ; 247.500 B0, -0.924
04100C 12 FF FF    0993*      dl 0xFFFF12 ; 248.906 B1, -0.933
04100F 0F FF FF    0994*      dl 0xFFFF0F ; 250.313 B2, -0.942
041012 0D FF FF    0995*      dl 0xFFFF0D ; 251.719 B3, -0.950
041015 0C FF FF    0996*      dl 0xFFFF0C ; 253.125 B4, -0.957
041018 0A FF FF    0997*      dl 0xFFFF0A ; 254.531 B5, -0.964
04101B 08 FF FF    0998*      dl 0xFFFF08 ; 255.938 B6, -0.970
04101E 07 FF FF    0999*      dl 0xFFFF07 ; 257.344 B7, -0.976
041021 05 FF FF    1000*      dl 0xFFFF05 ; 258.750 B8, -0.981
041024 04 FF FF    1001*      dl 0xFFFF04 ; 260.156 B9, -0.985
041027 03 FF FF    1002*      dl 0xFFFF03 ; 261.563 BA, -0.989
04102A 02 FF FF    1003*      dl 0xFFFF02 ; 262.969 BB, -0.992
04102D 02 FF FF    1004*      dl 0xFFFF02 ; 264.375 BC, -0.995
041030 01 FF FF    1005*      dl 0xFFFF01 ; 265.781 BD, -0.997
041033 01 FF FF    1006*      dl 0xFFFF01 ; 267.188 BE, -0.999
041036 01 FF FF    1007*      dl 0xFFFF01 ; 268.594 BF, -1.000
041039 00 FF FF    1008*      dl 0xFFFF00 ; 270.000 C0, -1.000
04103C 01 FF FF    1009*      dl 0xFFFF01 ; 271.406 C1, -1.000
04103F 01 FF FF    1010*      dl 0xFFFF01 ; 272.813 C2, -0.999
041042 01 FF FF    1011*      dl 0xFFFF01 ; 274.219 C3, -0.997
041045 02 FF FF    1012*      dl 0xFFFF02 ; 275.625 C4, -0.995
041048 02 FF FF    1013*      dl 0xFFFF02 ; 277.031 C5, -0.992
04104B 03 FF FF    1014*      dl 0xFFFF03 ; 278.438 C6, -0.989
04104E 04 FF FF    1015*      dl 0xFFFF04 ; 279.844 C7, -0.985
041051 05 FF FF    1016*      dl 0xFFFF05 ; 281.250 C8, -0.981
041054 07 FF FF    1017*      dl 0xFFFF07 ; 282.656 C9, -0.976
041057 08 FF FF    1018*      dl 0xFFFF08 ; 284.063 CA, -0.970
04105A 0A FF FF    1019*      dl 0xFFFF0A ; 285.469 CB, -0.964
04105D 0C FF FF    1020*      dl 0xFFFF0C ; 286.875 CC, -0.957
041060 0D FF FF    1021*      dl 0xFFFF0D ; 288.281 CD, -0.950
041063 0F FF FF    1022*      dl 0xFFFF0F ; 289.688 CE, -0.942
041066 12 FF FF    1023*      dl 0xFFFF12 ; 291.094 CF, -0.933
041069 14 FF FF    1024*      dl 0xFFFF14 ; 292.500 D0, -0.924
04106C 16 FF FF    1025*      dl 0xFFFF16 ; 293.906 D1, -0.914
04106F 19 FF FF    1026*      dl 0xFFFF19 ; 295.313 D2, -0.904
041072 1C FF FF    1027*      dl 0xFFFF1C ; 296.719 D3, -0.893
041075 1F FF FF    1028*      dl 0xFFFF1F ; 298.125 D4, -0.882
041078 22 FF FF    1029*      dl 0xFFFF22 ; 299.531 D5, -0.870
04107B 25 FF FF    1030*      dl 0xFFFF25 ; 300.938 D6, -0.858
04107E 28 FF FF    1031*      dl 0xFFFF28 ; 302.344 D7, -0.845
041081 2C FF FF    1032*      dl 0xFFFF2C ; 303.750 D8, -0.831
041084 2F FF FF    1033*      dl 0xFFFF2F ; 305.156 D9, -0.818
041087 33 FF FF    1034*      dl 0xFFFF33 ; 306.563 DA, -0.803
04108A 37 FF FF    1035*      dl 0xFFFF37 ; 307.969 DB, -0.788
04108D 3B FF FF    1036*      dl 0xFFFF3B ; 309.375 DC, -0.773
041090 3F FF FF    1037*      dl 0xFFFF3F ; 310.781 DD, -0.757
041093 43 FF FF    1038*      dl 0xFFFF43 ; 312.188 DE, -0.741
041096 47 FF FF    1039*      dl 0xFFFF47 ; 313.594 DF, -0.724
041099 4B FF FF    1040*      dl 0xFFFF4B ; 315.000 E0, -0.707
04109C 50 FF FF    1041*      dl 0xFFFF50 ; 316.406 E1, -0.690
04109F 55 FF FF    1042*      dl 0xFFFF55 ; 317.813 E2, -0.672
0410A2 59 FF FF    1043*      dl 0xFFFF59 ; 319.219 E3, -0.653
0410A5 5E FF FF    1044*      dl 0xFFFF5E ; 320.625 E4, -0.634
0410A8 63 FF FF    1045*      dl 0xFFFF63 ; 322.031 E5, -0.615
0410AB 68 FF FF    1046*      dl 0xFFFF68 ; 323.438 E6, -0.596
0410AE 6D FF FF    1047*      dl 0xFFFF6D ; 324.844 E7, -0.576
0410B1 72 FF FF    1048*      dl 0xFFFF72 ; 326.250 E8, -0.556
0410B4 78 FF FF    1049*      dl 0xFFFF78 ; 327.656 E9, -0.535
0410B7 7D FF FF    1050*      dl 0xFFFF7D ; 329.063 EA, -0.514
0410BA 82 FF FF    1051*      dl 0xFFFF82 ; 330.469 EB, -0.493
0410BD 88 FF FF    1052*      dl 0xFFFF88 ; 331.875 EC, -0.471
0410C0 8D FF FF    1053*      dl 0xFFFF8D ; 333.281 ED, -0.450
0410C3 93 FF FF    1054*      dl 0xFFFF93 ; 334.688 EE, -0.428
0410C6 99 FF FF    1055*      dl 0xFFFF99 ; 336.094 EF, -0.405
0410C9 9F FF FF    1056*      dl 0xFFFF9F ; 337.500 F0, -0.383
0410CC A4 FF FF    1057*      dl 0xFFFFA4 ; 338.906 F1, -0.360
0410CF AA FF FF    1058*      dl 0xFFFFAA ; 340.313 F2, -0.337
0410D2 B0 FF FF    1059*      dl 0xFFFFB0 ; 341.719 F3, -0.314
0410D5 B6 FF FF    1060*      dl 0xFFFFB6 ; 343.125 F4, -0.290
0410D8 BC FF FF    1061*      dl 0xFFFFBC ; 344.531 F5, -0.267
0410DB C2 FF FF    1062*      dl 0xFFFFC2 ; 345.938 F6, -0.243
0410DE C8 FF FF    1063*      dl 0xFFFFC8 ; 347.344 F7, -0.219
0410E1 CF FF FF    1064*      dl 0xFFFFCF ; 348.750 F8, -0.195
0410E4 D5 FF FF    1065*      dl 0xFFFFD5 ; 350.156 F9, -0.171
0410E7 DB FF FF    1066*      dl 0xFFFFDB ; 351.563 FA, -0.147
0410EA E1 FF FF    1067*      dl 0xFFFFE1 ; 352.969 FB, -0.122
0410ED E7 FF FF    1068*      dl 0xFFFFE7 ; 354.375 FC, -0.098
0410F0 EE FF FF    1069*      dl 0xFFFFEE ; 355.781 FD, -0.074
0410F3 F4 FF FF    1070*      dl 0xFFFFF4 ; 357.188 FE, -0.049
0410F6 FA FF FF    1071*      dl 0xFFFFFA ; 358.594 FF, -0.025
0410F9 00 00 00    1072*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
0410FC             1073*  
0410FC             1074*  atan_lut_168:
0410FC 00 00 00    1075*      dl 0x000000 ; 000000, 0.000
0410FF 28 00 00    1076*      dl 0x000028 ; 000001, 0.224
041102 51 00 00    1077*      dl 0x000051 ; 000002, 0.448
041105 7A 00 00    1078*      dl 0x00007A ; 000003, 0.671
041108 A2 00 00    1079*      dl 0x0000A2 ; 000004, 0.895
04110B CB 00 00    1080*      dl 0x0000CB ; 000005, 1.119
04110E F4 00 00    1081*      dl 0x0000F4 ; 000006, 1.343
041111 1D 01 00    1082*      dl 0x00011D ; 000007, 1.566
041114 45 01 00    1083*      dl 0x000145 ; 000008, 1.790
041117 6E 01 00    1084*      dl 0x00016E ; 000009, 2.013
04111A 97 01 00    1085*      dl 0x000197 ; 00000A, 2.237
04111D BF 01 00    1086*      dl 0x0001BF ; 00000B, 2.460
041120 E8 01 00    1087*      dl 0x0001E8 ; 00000C, 2.684
041123 11 02 00    1088*      dl 0x000211 ; 00000D, 2.907
041126 39 02 00    1089*      dl 0x000239 ; 00000E, 3.130
041129 62 02 00    1090*      dl 0x000262 ; 00000F, 3.353
04112C 8B 02 00    1091*      dl 0x00028B ; 000010, 3.576
04112F B3 02 00    1092*      dl 0x0002B3 ; 000011, 3.799
041132 DC 02 00    1093*      dl 0x0002DC ; 000012, 4.022
041135 04 03 00    1094*      dl 0x000304 ; 000013, 4.245
041138 2D 03 00    1095*      dl 0x00032D ; 000014, 4.467
04113B 55 03 00    1096*      dl 0x000355 ; 000015, 4.690
04113E 7E 03 00    1097*      dl 0x00037E ; 000016, 4.912
041141 A6 03 00    1098*      dl 0x0003A6 ; 000017, 5.134
041144 CE 03 00    1099*      dl 0x0003CE ; 000018, 5.356
041147 F7 03 00    1100*      dl 0x0003F7 ; 000019, 5.578
04114A 1F 04 00    1101*      dl 0x00041F ; 00001A, 5.799
04114D 48 04 00    1102*      dl 0x000448 ; 00001B, 6.021
041150 70 04 00    1103*      dl 0x000470 ; 00001C, 6.242
041153 98 04 00    1104*      dl 0x000498 ; 00001D, 6.463
041156 C0 04 00    1105*      dl 0x0004C0 ; 00001E, 6.684
041159 E8 04 00    1106*      dl 0x0004E8 ; 00001F, 6.905
04115C 11 05 00    1107*      dl 0x000511 ; 000020, 7.125
04115F 39 05 00    1108*      dl 0x000539 ; 000021, 7.345
041162 61 05 00    1109*      dl 0x000561 ; 000022, 7.565
041165 89 05 00    1110*      dl 0x000589 ; 000023, 7.785
041168 B1 05 00    1111*      dl 0x0005B1 ; 000024, 8.005
04116B D9 05 00    1112*      dl 0x0005D9 ; 000025, 8.224
04116E 01 06 00    1113*      dl 0x000601 ; 000026, 8.443
041171 28 06 00    1114*      dl 0x000628 ; 000027, 8.662
041174 50 06 00    1115*      dl 0x000650 ; 000028, 8.881
041177 78 06 00    1116*      dl 0x000678 ; 000029, 9.099
04117A A0 06 00    1117*      dl 0x0006A0 ; 00002A, 9.317
04117D C7 06 00    1118*      dl 0x0006C7 ; 00002B, 9.535
041180 EF 06 00    1119*      dl 0x0006EF ; 00002C, 9.752
041183 16 07 00    1120*      dl 0x000716 ; 00002D, 9.970
041186 3E 07 00    1121*      dl 0x00073E ; 00002E, 10.187
041189 65 07 00    1122*      dl 0x000765 ; 00002F, 10.403
04118C 8D 07 00    1123*      dl 0x00078D ; 000030, 10.620
04118F B4 07 00    1124*      dl 0x0007B4 ; 000031, 10.836
041192 DB 07 00    1125*      dl 0x0007DB ; 000032, 11.051
041195 03 08 00    1126*      dl 0x000803 ; 000033, 11.267
041198 2A 08 00    1127*      dl 0x00082A ; 000034, 11.482
04119B 51 08 00    1128*      dl 0x000851 ; 000035, 11.697
04119E 78 08 00    1129*      dl 0x000878 ; 000036, 11.911
0411A1 9F 08 00    1130*      dl 0x00089F ; 000037, 12.125
0411A4 C6 08 00    1131*      dl 0x0008C6 ; 000038, 12.339
0411A7 ED 08 00    1132*      dl 0x0008ED ; 000039, 12.553
0411AA 13 09 00    1133*      dl 0x000913 ; 00003A, 12.766
0411AD 3A 09 00    1134*      dl 0x00093A ; 00003B, 12.978
0411B0 61 09 00    1135*      dl 0x000961 ; 00003C, 13.191
0411B3 87 09 00    1136*      dl 0x000987 ; 00003D, 13.403
0411B6 AE 09 00    1137*      dl 0x0009AE ; 00003E, 13.614
0411B9 D4 09 00    1138*      dl 0x0009D4 ; 00003F, 13.825
0411BC FB 09 00    1139*      dl 0x0009FB ; 000040, 14.036
0411BF 21 0A 00    1140*      dl 0x000A21 ; 000041, 14.247
0411C2 47 0A 00    1141*      dl 0x000A47 ; 000042, 14.457
0411C5 6D 0A 00    1142*      dl 0x000A6D ; 000043, 14.666
0411C8 94 0A 00    1143*      dl 0x000A94 ; 000044, 14.876
0411CB BA 0A 00    1144*      dl 0x000ABA ; 000045, 15.085
0411CE E0 0A 00    1145*      dl 0x000AE0 ; 000046, 15.293
0411D1 05 0B 00    1146*      dl 0x000B05 ; 000047, 15.501
0411D4 2B 0B 00    1147*      dl 0x000B2B ; 000048, 15.709
0411D7 51 0B 00    1148*      dl 0x000B51 ; 000049, 15.916
0411DA 77 0B 00    1149*      dl 0x000B77 ; 00004A, 16.123
0411DD 9C 0B 00    1150*      dl 0x000B9C ; 00004B, 16.329
0411E0 C2 0B 00    1151*      dl 0x000BC2 ; 00004C, 16.535
0411E3 E7 0B 00    1152*      dl 0x000BE7 ; 00004D, 16.740
0411E6 0C 0C 00    1153*      dl 0x000C0C ; 00004E, 16.945
0411E9 32 0C 00    1154*      dl 0x000C32 ; 00004F, 17.150
0411EC 57 0C 00    1155*      dl 0x000C57 ; 000050, 17.354
0411EF 7C 0C 00    1156*      dl 0x000C7C ; 000051, 17.558
0411F2 A1 0C 00    1157*      dl 0x000CA1 ; 000052, 17.761
0411F5 C6 0C 00    1158*      dl 0x000CC6 ; 000053, 17.964
0411F8 EB 0C 00    1159*      dl 0x000CEB ; 000054, 18.166
0411FB 0F 0D 00    1160*      dl 0x000D0F ; 000055, 18.368
0411FE 34 0D 00    1161*      dl 0x000D34 ; 000056, 18.569
041201 58 0D 00    1162*      dl 0x000D58 ; 000057, 18.770
041204 7D 0D 00    1163*      dl 0x000D7D ; 000058, 18.970
041207 A1 0D 00    1164*      dl 0x000DA1 ; 000059, 19.170
04120A C6 0D 00    1165*      dl 0x000DC6 ; 00005A, 19.370
04120D EA 0D 00    1166*      dl 0x000DEA ; 00005B, 19.569
041210 0E 0E 00    1167*      dl 0x000E0E ; 00005C, 19.767
041213 32 0E 00    1168*      dl 0x000E32 ; 00005D, 19.965
041216 56 0E 00    1169*      dl 0x000E56 ; 00005E, 20.163
041219 7A 0E 00    1170*      dl 0x000E7A ; 00005F, 20.360
04121C 9E 0E 00    1171*      dl 0x000E9E ; 000060, 20.556
04121F C1 0E 00    1172*      dl 0x000EC1 ; 000061, 20.752
041222 E5 0E 00    1173*      dl 0x000EE5 ; 000062, 20.947
041225 08 0F 00    1174*      dl 0x000F08 ; 000063, 21.142
041228 2C 0F 00    1175*      dl 0x000F2C ; 000064, 21.337
04122B 4F 0F 00    1176*      dl 0x000F4F ; 000065, 21.531
04122E 72 0F 00    1177*      dl 0x000F72 ; 000066, 21.724
041231 95 0F 00    1178*      dl 0x000F95 ; 000067, 21.917
041234 B8 0F 00    1179*      dl 0x000FB8 ; 000068, 22.109
041237 DB 0F 00    1180*      dl 0x000FDB ; 000069, 22.301
04123A FE 0F 00    1181*      dl 0x000FFE ; 00006A, 22.493
04123D 21 10 00    1182*      dl 0x001021 ; 00006B, 22.683
041240 44 10 00    1183*      dl 0x001044 ; 00006C, 22.874
041243 66 10 00    1184*      dl 0x001066 ; 00006D, 23.063
041246 89 10 00    1185*      dl 0x001089 ; 00006E, 23.253
041249 AB 10 00    1186*      dl 0x0010AB ; 00006F, 23.441
04124C CD 10 00    1187*      dl 0x0010CD ; 000070, 23.629
04124F EF 10 00    1188*      dl 0x0010EF ; 000071, 23.817
041252 11 11 00    1189*      dl 0x001111 ; 000072, 24.004
041255 33 11 00    1190*      dl 0x001133 ; 000073, 24.191
041258 55 11 00    1191*      dl 0x001155 ; 000074, 24.376
04125B 77 11 00    1192*      dl 0x001177 ; 000075, 24.562
04125E 99 11 00    1193*      dl 0x001199 ; 000076, 24.747
041261 BA 11 00    1194*      dl 0x0011BA ; 000077, 24.931
041264 DC 11 00    1195*      dl 0x0011DC ; 000078, 25.115
041267 FD 11 00    1196*      dl 0x0011FD ; 000079, 25.298
04126A 1E 12 00    1197*      dl 0x00121E ; 00007A, 25.481
04126D 3F 12 00    1198*      dl 0x00123F ; 00007B, 25.663
041270 60 12 00    1199*      dl 0x001260 ; 00007C, 25.844
041273 81 12 00    1200*      dl 0x001281 ; 00007D, 26.025
041276 A2 12 00    1201*      dl 0x0012A2 ; 00007E, 26.206
041279 C3 12 00    1202*      dl 0x0012C3 ; 00007F, 26.386
04127C E4 12 00    1203*      dl 0x0012E4 ; 000080, 26.565
04127F 04 13 00    1204*      dl 0x001304 ; 000081, 26.744
041282 25 13 00    1205*      dl 0x001325 ; 000082, 26.922
041285 45 13 00    1206*      dl 0x001345 ; 000083, 27.100
041288 65 13 00    1207*      dl 0x001365 ; 000084, 27.277
04128B 85 13 00    1208*      dl 0x001385 ; 000085, 27.453
04128E A5 13 00    1209*      dl 0x0013A5 ; 000086, 27.629
041291 C5 13 00    1210*      dl 0x0013C5 ; 000087, 27.805
041294 E5 13 00    1211*      dl 0x0013E5 ; 000088, 27.979
041297 05 14 00    1212*      dl 0x001405 ; 000089, 28.154
04129A 24 14 00    1213*      dl 0x001424 ; 00008A, 28.327
04129D 44 14 00    1214*      dl 0x001444 ; 00008B, 28.501
0412A0 63 14 00    1215*      dl 0x001463 ; 00008C, 28.673
0412A3 83 14 00    1216*      dl 0x001483 ; 00008D, 28.845
0412A6 A2 14 00    1217*      dl 0x0014A2 ; 00008E, 29.017
0412A9 C1 14 00    1218*      dl 0x0014C1 ; 00008F, 29.187
0412AC E0 14 00    1219*      dl 0x0014E0 ; 000090, 29.358
0412AF FF 14 00    1220*      dl 0x0014FF ; 000091, 29.527
0412B2 1E 15 00    1221*      dl 0x00151E ; 000092, 29.697
0412B5 3C 15 00    1222*      dl 0x00153C ; 000093, 29.865
0412B8 5B 15 00    1223*      dl 0x00155B ; 000094, 30.033
0412BB 79 15 00    1224*      dl 0x001579 ; 000095, 30.201
0412BE 98 15 00    1225*      dl 0x001598 ; 000096, 30.368
0412C1 B6 15 00    1226*      dl 0x0015B6 ; 000097, 30.534
0412C4 D4 15 00    1227*      dl 0x0015D4 ; 000098, 30.700
0412C7 F2 15 00    1228*      dl 0x0015F2 ; 000099, 30.865
0412CA 10 16 00    1229*      dl 0x001610 ; 00009A, 31.030
0412CD 2E 16 00    1230*      dl 0x00162E ; 00009B, 31.194
0412D0 4C 16 00    1231*      dl 0x00164C ; 00009C, 31.357
0412D3 6A 16 00    1232*      dl 0x00166A ; 00009D, 31.520
0412D6 87 16 00    1233*      dl 0x001687 ; 00009E, 31.682
0412D9 A5 16 00    1234*      dl 0x0016A5 ; 00009F, 31.844
0412DC C2 16 00    1235*      dl 0x0016C2 ; 0000A0, 32.005
0412DF DF 16 00    1236*      dl 0x0016DF ; 0000A1, 32.166
0412E2 FC 16 00    1237*      dl 0x0016FC ; 0000A2, 32.326
0412E5 19 17 00    1238*      dl 0x001719 ; 0000A3, 32.486
0412E8 36 17 00    1239*      dl 0x001736 ; 0000A4, 32.645
0412EB 53 17 00    1240*      dl 0x001753 ; 0000A5, 32.803
0412EE 70 17 00    1241*      dl 0x001770 ; 0000A6, 32.961
0412F1 8C 17 00    1242*      dl 0x00178C ; 0000A7, 33.118
0412F4 A9 17 00    1243*      dl 0x0017A9 ; 0000A8, 33.275
0412F7 C5 17 00    1244*      dl 0x0017C5 ; 0000A9, 33.431
0412FA E2 17 00    1245*      dl 0x0017E2 ; 0000AA, 33.587
0412FD FE 17 00    1246*      dl 0x0017FE ; 0000AB, 33.742
041300 1A 18 00    1247*      dl 0x00181A ; 0000AC, 33.896
041303 36 18 00    1248*      dl 0x001836 ; 0000AD, 34.050
041306 52 18 00    1249*      dl 0x001852 ; 0000AE, 34.203
041309 6E 18 00    1250*      dl 0x00186E ; 0000AF, 34.356
04130C 8A 18 00    1251*      dl 0x00188A ; 0000B0, 34.509
04130F A5 18 00    1252*      dl 0x0018A5 ; 0000B1, 34.660
041312 C1 18 00    1253*      dl 0x0018C1 ; 0000B2, 34.811
041315 DC 18 00    1254*      dl 0x0018DC ; 0000B3, 34.962
041318 F7 18 00    1255*      dl 0x0018F7 ; 0000B4, 35.112
04131B 13 19 00    1256*      dl 0x001913 ; 0000B5, 35.262
04131E 2E 19 00    1257*      dl 0x00192E ; 0000B6, 35.410
041321 49 19 00    1258*      dl 0x001949 ; 0000B7, 35.559
041324 64 19 00    1259*      dl 0x001964 ; 0000B8, 35.707
041327 7F 19 00    1260*      dl 0x00197F ; 0000B9, 35.854
04132A 99 19 00    1261*      dl 0x001999 ; 0000BA, 36.001
04132D B4 19 00    1262*      dl 0x0019B4 ; 0000BB, 36.147
041330 CE 19 00    1263*      dl 0x0019CE ; 0000BC, 36.293
041333 E9 19 00    1264*      dl 0x0019E9 ; 0000BD, 36.438
041336 03 1A 00    1265*      dl 0x001A03 ; 0000BE, 36.582
041339 1D 1A 00    1266*      dl 0x001A1D ; 0000BF, 36.726
04133C 37 1A 00    1267*      dl 0x001A37 ; 0000C0, 36.870
04133F 51 1A 00    1268*      dl 0x001A51 ; 0000C1, 37.013
041342 6B 1A 00    1269*      dl 0x001A6B ; 0000C2, 37.155
041345 85 1A 00    1270*      dl 0x001A85 ; 0000C3, 37.297
041348 9F 1A 00    1271*      dl 0x001A9F ; 0000C4, 37.439
04134B B9 1A 00    1272*      dl 0x001AB9 ; 0000C5, 37.579
04134E D2 1A 00    1273*      dl 0x001AD2 ; 0000C6, 37.720
041351 EC 1A 00    1274*      dl 0x001AEC ; 0000C7, 37.859
041354 05 1B 00    1275*      dl 0x001B05 ; 0000C8, 37.999
041357 1E 1B 00    1276*      dl 0x001B1E ; 0000C9, 38.137
04135A 37 1B 00    1277*      dl 0x001B37 ; 0000CA, 38.276
04135D 50 1B 00    1278*      dl 0x001B50 ; 0000CB, 38.413
041360 69 1B 00    1279*      dl 0x001B69 ; 0000CC, 38.550
041363 82 1B 00    1280*      dl 0x001B82 ; 0000CD, 38.687
041366 9B 1B 00    1281*      dl 0x001B9B ; 0000CE, 38.823
041369 B4 1B 00    1282*      dl 0x001BB4 ; 0000CF, 38.959
04136C CC 1B 00    1283*      dl 0x001BCC ; 0000D0, 39.094
04136F E5 1B 00    1284*      dl 0x001BE5 ; 0000D1, 39.228
041372 FD 1B 00    1285*      dl 0x001BFD ; 0000D2, 39.362
041375 16 1C 00    1286*      dl 0x001C16 ; 0000D3, 39.496
041378 2E 1C 00    1287*      dl 0x001C2E ; 0000D4, 39.629
04137B 46 1C 00    1288*      dl 0x001C46 ; 0000D5, 39.762
04137E 5E 1C 00    1289*      dl 0x001C5E ; 0000D6, 39.894
041381 76 1C 00    1290*      dl 0x001C76 ; 0000D7, 40.025
041384 8E 1C 00    1291*      dl 0x001C8E ; 0000D8, 40.156
041387 A5 1C 00    1292*      dl 0x001CA5 ; 0000D9, 40.286
04138A BD 1C 00    1293*      dl 0x001CBD ; 0000DA, 40.416
04138D D5 1C 00    1294*      dl 0x001CD5 ; 0000DB, 40.546
041390 EC 1C 00    1295*      dl 0x001CEC ; 0000DC, 40.675
041393 04 1D 00    1296*      dl 0x001D04 ; 0000DD, 40.803
041396 1B 1D 00    1297*      dl 0x001D1B ; 0000DE, 40.931
041399 32 1D 00    1298*      dl 0x001D32 ; 0000DF, 41.059
04139C 49 1D 00    1299*      dl 0x001D49 ; 0000E0, 41.186
04139F 60 1D 00    1300*      dl 0x001D60 ; 0000E1, 41.312
0413A2 77 1D 00    1301*      dl 0x001D77 ; 0000E2, 41.438
0413A5 8E 1D 00    1302*      dl 0x001D8E ; 0000E3, 41.564
0413A8 A5 1D 00    1303*      dl 0x001DA5 ; 0000E4, 41.689
0413AB BB 1D 00    1304*      dl 0x001DBB ; 0000E5, 41.814
0413AE D2 1D 00    1305*      dl 0x001DD2 ; 0000E6, 41.938
0413B1 E9 1D 00    1306*      dl 0x001DE9 ; 0000E7, 42.061
0413B4 FF 1D 00    1307*      dl 0x001DFF ; 0000E8, 42.184
0413B7 15 1E 00    1308*      dl 0x001E15 ; 0000E9, 42.307
0413BA 2C 1E 00    1309*      dl 0x001E2C ; 0000EA, 42.429
0413BD 42 1E 00    1310*      dl 0x001E42 ; 0000EB, 42.551
0413C0 58 1E 00    1311*      dl 0x001E58 ; 0000EC, 42.672
0413C3 6E 1E 00    1312*      dl 0x001E6E ; 0000ED, 42.793
0413C6 84 1E 00    1313*      dl 0x001E84 ; 0000EE, 42.913
0413C9 99 1E 00    1314*      dl 0x001E99 ; 0000EF, 43.033
0413CC AF 1E 00    1315*      dl 0x001EAF ; 0000F0, 43.152
0413CF C5 1E 00    1316*      dl 0x001EC5 ; 0000F1, 43.271
0413D2 DA 1E 00    1317*      dl 0x001EDA ; 0000F2, 43.390
0413D5 F0 1E 00    1318*      dl 0x001EF0 ; 0000F3, 43.508
0413D8 05 1F 00    1319*      dl 0x001F05 ; 0000F4, 43.625
0413DB 1B 1F 00    1320*      dl 0x001F1B ; 0000F5, 43.742
0413DE 30 1F 00    1321*      dl 0x001F30 ; 0000F6, 43.859
0413E1 45 1F 00    1322*      dl 0x001F45 ; 0000F7, 43.975
0413E4 5A 1F 00    1323*      dl 0x001F5A ; 0000F8, 44.091
0413E7 6F 1F 00    1324*      dl 0x001F6F ; 0000F9, 44.206
0413EA 84 1F 00    1325*      dl 0x001F84 ; 0000FA, 44.321
0413ED 99 1F 00    1326*      dl 0x001F99 ; 0000FB, 44.435
0413F0 AD 1F 00    1327*      dl 0x001FAD ; 0000FC, 44.549
0413F3 C2 1F 00    1328*      dl 0x001FC2 ; 0000FD, 44.662
0413F6 D7 1F 00    1329*      dl 0x001FD7 ; 0000FE, 44.775
0413F9 EB 1F 00    1330*      dl 0x001FEB ; 0000FF, 44.888
0413FC 00 20 00    1331*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
0413FF             0041       include "fonts.inc"
0413FF             0001*  fonts_load:
0413FF DD 21 3B 14 0002*      ld ix,font_list ; pointer to font list lookup
       04          
041404 06 12       0003*      ld b,num_fonts ; loop counter
041406             0004*  
041406             0005*  @load_loop:
041406 C5          0006*      push bc ; save loop counter
041407             0007*  
041407             0008*  ; load font into a buffer
041407 DD 27 06    0009*      ld hl,(ix+font_list_bufferId)
04140A DD 31 09    0010*      ld iy,(ix+font_list_filename)
04140D CD B7 45 04 0011*      call vdu_load_buffer_from_file
041411             0012*  
041411             0013*  ; create font from buffer
041411 DD 27 06    0014*      ld hl,(ix+font_list_bufferId)
041414 DD 5E 00    0015*      ld e,(ix+font_list_width)
041417 DD 56 03    0016*      ld d,(ix+font_list_height)
04141A 3E 00       0017*      ld a,0 ; flags
04141C CD 3A 47 04 0018*      call vdu_font_create
041420             0019*  
041420             0020*  ; select font
041420 DD 27 06    0021*      ld hl,(ix+font_list_bufferId)
041423 3E 01       0022*      ld a,1 ; flags
041425 CD 20 47 04 0023*      call vdu_font_select
041429             0024*  
041429             0025*  ; debug print filename
041429 CD 8C 00 04 0026*      call printNewLine
04142D DD 27 09    0027*      ld hl,(ix+font_list_filename)
041430 CD 77 00 04 0028*      call printString
041434             0029*  
041434             0030*  ; advance font_list pointer to next record
041434 ED 32 0C    0031*      lea ix,ix+font_list_record_size
041437             0032*  
041437             0033*  ; restore loop counter
041437 C1          0034*      pop bc
041438 10 CC       0035*      djnz @load_loop
04143A             0036*  
04143A             0037*  ; all done
04143A C9          0038*      ret
04143B             0042       include "fonts_list.inc"
04143B             0001*  ; Generated by asm_config_editor.py
04143B             0002*  font_list_record_size: equ 12
04143B             0003*  font_list_width: equ 0
04143B             0004*  font_list_height: equ 3
04143B             0005*  font_list_bufferId: equ 6
04143B             0006*  font_list_filename: equ 9
04143B             0007*  
04143B             0008*  num_fonts: equ 18
04143B             0009*  
04143B             0010*  ; Index list:
04143B             0011*  amiga_forever_16x24: equ 0
04143B             0012*  amiga_forever_8x16: equ 1
04143B             0013*  amiga_forever_8x8: equ 2
04143B             0014*  computer_pixel_7_10x15: equ 3
04143B             0015*  computer_pixel_7_10x24: equ 4
04143B             0016*  computer_pixel_7_8x14: equ 5
04143B             0017*  Lat2_Terminus12x6_6x12: equ 6
04143B             0018*  Lat2_TerminusBold14_8x14: equ 7
04143B             0019*  Lat2_VGA14_8x14: equ 8
04143B             0020*  Lat2_VGA16_8x16: equ 9
04143B             0021*  Lat2_VGA8_8x8: equ 10
04143B             0022*  Lat7_Fixed13_8x13: equ 11
04143B             0023*  Lat7_Terminus12x6_6x12: equ 12
04143B             0024*  Lat7_TerminusBold16_8x16: equ 13
04143B             0025*  Lat7_VGA14_8x14: equ 14
04143B             0026*  Lat7_VGA8_8x8: equ 15
04143B             0027*  scriptorium_12x14: equ 16
04143B             0028*  Squarewave_Bold_8x12: equ 17
04143B             0029*  
04143B             0030*  font_list: ; width; height; bufferId; filename;:
04143B 10 00 00 18 0031*  	dl 16, 24, 64000, fn_amiga_forever_16x24
       00 00 00 FA 
       00 13 15 04 
041447 08 00 00 10 0032*  	dl 8, 16, 64001, fn_amiga_forever_8x16
       00 00 01 FA 
       00 37 15 04 
041453 08 00 00 08 0033*  	dl 8, 8, 64002, fn_amiga_forever_8x8
       00 00 02 FA 
       00 5A 15 04 
04145F 0A 00 00 0F 0034*  	dl 10, 15, 64003, fn_computer_pixel_7_10x15
       00 00 03 FA 
       00 7C 15 04 
04146B 0A 00 00 18 0035*  	dl 10, 24, 64004, fn_computer_pixel_7_10x24
       00 00 04 FA 
       00 A3 15 04 
041477 08 00 00 0E 0036*  	dl 8, 14, 64005, fn_computer_pixel_7_8x14
       00 00 05 FA 
       00 CA 15 04 
041483 06 00 00 0C 0037*  	dl 6, 12, 64006, fn_Lat2_Terminus12x6_6x12
       00 00 06 FA 
       00 F0 15 04 
04148F 08 00 00 0E 0038*  	dl 8, 14, 64007, fn_Lat2_TerminusBold14_8x14
       00 00 07 FA 
       00 17 16 04 
04149B 08 00 00 0E 0039*  	dl 8, 14, 64008, fn_Lat2_VGA14_8x14
       00 00 08 FA 
       00 40 16 04 
0414A7 08 00 00 10 0040*  	dl 8, 16, 64009, fn_Lat2_VGA16_8x16
       00 00 09 FA 
       00 60 16 04 
0414B3 08 00 00 08 0041*  	dl 8, 8, 64010, fn_Lat2_VGA8_8x8
       00 00 0A FA 
       00 80 16 04 
0414BF 08 00 00 0D 0042*  	dl 8, 13, 64011, fn_Lat7_Fixed13_8x13
       00 00 0B FA 
       00 9E 16 04 
0414CB 06 00 00 0C 0043*  	dl 6, 12, 64012, fn_Lat7_Terminus12x6_6x12
       00 00 0C FA 
       00 C0 16 04 
0414D7 08 00 00 10 0044*  	dl 8, 16, 64013, fn_Lat7_TerminusBold16_8x16
       00 00 0D FA 
       00 E7 16 04 
0414E3 08 00 00 0E 0045*  	dl 8, 14, 64014, fn_Lat7_VGA14_8x14
       00 00 0E FA 
       00 10 17 04 
0414EF 08 00 00 08 0046*  	dl 8, 8, 64015, fn_Lat7_VGA8_8x8
       00 00 0F FA 
       00 30 17 04 
0414FB 0C 00 00 0E 0047*  	dl 12, 14, 64016, fn_scriptorium_12x14
       00 00 10 FA 
       00 4E 17 04 
041507 08 00 00 0C 0048*  	dl 8, 12, 64017, fn_Squarewave_Bold_8x12
       00 00 11 FA 
       00 70 17 04 
041513             0049*  
041513             0050*  ; files_list: ; filename:
041513 2F 6D 6F 73 0051*  fn_amiga_forever_16x24: db "/mos/fonts/amiga_forever_16x24.font",0
       2F 66 6F 6E 
       74 73 2F 61 
       6D 69 67 61 
       5F 66 6F 72 
       65 76 65 72 
       5F 31 36 78 
       32 34 2E 66 
       6F 6E 74 00 
041537 2F 6D 6F 73 0052*  fn_amiga_forever_8x16: db "/mos/fonts/amiga_forever_8x16.font",0
       2F 66 6F 6E 
       74 73 2F 61 
       6D 69 67 61 
       5F 66 6F 72 
       65 76 65 72 
       5F 38 78 31 
       36 2E 66 6F 
       6E 74 00    
04155A 2F 6D 6F 73 0053*  fn_amiga_forever_8x8: db "/mos/fonts/amiga_forever_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 61 
       6D 69 67 61 
       5F 66 6F 72 
       65 76 65 72 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04157C 2F 6D 6F 73 0054*  fn_computer_pixel_7_10x15: db "/mos/fonts/computer_pixel_7_10x15.font",0
       2F 66 6F 6E 
       74 73 2F 63 
       6F 6D 70 75 
       74 65 72 5F 
       70 69 78 65 
       6C 5F 37 5F 
       31 30 78 31 
       35 2E 66 6F 
       6E 74 00    
0415A3 2F 6D 6F 73 0055*  fn_computer_pixel_7_10x24: db "/mos/fonts/computer_pixel_7_10x24.font",0
       2F 66 6F 6E 
       74 73 2F 63 
       6F 6D 70 75 
       74 65 72 5F 
       70 69 78 65 
       6C 5F 37 5F 
       31 30 78 32 
       34 2E 66 6F 
       6E 74 00    
0415CA 2F 6D 6F 73 0056*  fn_computer_pixel_7_8x14: db "/mos/fonts/computer_pixel_7_8x14.font",0
       2F 66 6F 6E 
       74 73 2F 63 
       6F 6D 70 75 
       74 65 72 5F 
       70 69 78 65 
       6C 5F 37 5F 
       38 78 31 34 
       2E 66 6F 6E 
       74 00       
0415F0 2F 6D 6F 73 0057*  fn_Lat2_Terminus12x6_6x12: db "/mos/fonts/Lat2-Terminus12x6_6x12.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       54 65 72 6D 
       69 6E 75 73 
       31 32 78 36 
       5F 36 78 31 
       32 2E 66 6F 
       6E 74 00    
041617 2F 6D 6F 73 0058*  fn_Lat2_TerminusBold14_8x14: db "/mos/fonts/Lat2-TerminusBold14_8x14.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       54 65 72 6D 
       69 6E 75 73 
       42 6F 6C 64 
       31 34 5F 38 
       78 31 34 2E 
       66 6F 6E 74 
       00          
041640 2F 6D 6F 73 0059*  fn_Lat2_VGA14_8x14: db "/mos/fonts/Lat2-VGA14_8x14.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       56 47 41 31 
       34 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
041660 2F 6D 6F 73 0060*  fn_Lat2_VGA16_8x16: db "/mos/fonts/Lat2-VGA16_8x16.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       56 47 41 31 
       36 5F 38 78 
       31 36 2E 66 
       6F 6E 74 00 
041680 2F 6D 6F 73 0061*  fn_Lat2_VGA8_8x8: db "/mos/fonts/Lat2-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04169E 2F 6D 6F 73 0062*  fn_Lat7_Fixed13_8x13: db "/mos/fonts/Lat7-Fixed13_8x13.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       46 69 78 65 
       64 31 33 5F 
       38 78 31 33 
       2E 66 6F 6E 
       74 00       
0416C0 2F 6D 6F 73 0063*  fn_Lat7_Terminus12x6_6x12: db "/mos/fonts/Lat7-Terminus12x6_6x12.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       54 65 72 6D 
       69 6E 75 73 
       31 32 78 36 
       5F 36 78 31 
       32 2E 66 6F 
       6E 74 00    
0416E7 2F 6D 6F 73 0064*  fn_Lat7_TerminusBold16_8x16: db "/mos/fonts/Lat7-TerminusBold16_8x16.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       54 65 72 6D 
       69 6E 75 73 
       42 6F 6C 64 
       31 36 5F 38 
       78 31 36 2E 
       66 6F 6E 74 
       00          
041710 2F 6D 6F 73 0065*  fn_Lat7_VGA14_8x14: db "/mos/fonts/Lat7-VGA14_8x14.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       56 47 41 31 
       34 5F 38 78 
       31 34 2E 66 
       6F 6E 74 00 
041730 2F 6D 6F 73 0066*  fn_Lat7_VGA8_8x8: db "/mos/fonts/Lat7-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04174E 2F 6D 6F 73 0067*  fn_scriptorium_12x14: db "/mos/fonts/scriptorium_12x14.font",0
       2F 66 6F 6E 
       74 73 2F 73 
       63 72 69 70 
       74 6F 72 69 
       75 6D 5F 31 
       32 78 31 34 
       2E 66 6F 6E 
       74 00       
041770 2F 6D 6F 73 0068*  fn_Squarewave_Bold_8x12: db "/mos/fonts/Squarewave_Bold_8x12.font",0
       2F 66 6F 6E 
       74 73 2F 53 
       71 75 61 72 
       65 77 61 76 
       65 5F 42 6F 
       6C 64 5F 38 
       78 31 32 2E 
       66 6F 6E 74 
       00          
041795             0043       include "images.inc"
041795             0001*  image_type: equ 0
041795             0002*  image_width: equ image_type+3
041795             0003*  image_height: equ image_width+3
041795             0004*  image_filesize: equ image_height+3
041795             0005*  image_filename: equ image_filesize+3
041795             0006*  image_bufferId: equ image_filename+3
041795             0007*  image_record_size: equ image_bufferId+3
041795             0008*  
041795 00 00 00    0009*  cur_image_list: dl 0
041798 00 00 00    0010*  cur_file_idx: dl 0
04179B 00 00 00    0011*  cur_filename: dl 0
04179E 00 00 00    0012*  cur_buffer_id: dl 0
0417A1             0013*  
0417A1             0014*  load_ui_images:
0417A1             0015*  ; initialize image loading variables
0417A1 21 00 00 00 0016*      ld hl,0
0417A5 22 98 17 04 0017*      ld (cur_file_idx),hl
0417A9 21 93 28 04 0018*      ld hl,ui_image_list
0417AD 22 95 17 04 0019*      ld (cur_image_list),hl
0417B1             0020*  ; load images
0417B1 06 04       0021*      ld b,ui_num_images
0417B3             0022*  @loop:
0417B3 C5          0023*      push bc
0417B4 CD 12 18 04 0024*      call load_next_image
0417B8 C1          0025*      pop bc
0417B9 10 F8       0026*      djnz @loop
0417BB C9          0027*      ret
0417BC             0028*  
0417BC             0029*  load_sprite_images:
0417BC             0030*  ; initialize image loading variables
0417BC 21 00 00 00 0031*      ld hl,0
0417C0 22 98 17 04 0032*      ld (cur_file_idx),hl
0417C4 21 A3 18 04 0033*      ld hl,sprites_image_list
0417C8 22 95 17 04 0034*      ld (cur_image_list),hl
0417CC 01 5F 00 00 0035*      ld bc,sprites_num_images
0417D0             0036*  ; load images
0417D0 CD D5 17 04 0037*      call img_load_main
0417D4 C9          0038*      ret
0417D5             0039*  
0417D5             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0417D5             0041*  img_load_main:
0417D5 AF          0042*      xor a
0417D6 32 98 17 04 0043*      ld (cur_file_idx),a
0417DA             0044*  
0417DA             0045*  img_load_main_loop:
0417DA             0046*  ; back up loop counter
0417DA C5          0047*      push bc
0417DB             0048*  
0417DB             0049*  ; load the next image
0417DB CD 12 18 04 0050*      call load_next_image
0417DF             0051*  
0417DF             0052*  ; plot the background
0417DF CD 8A 43 04 0053*      call vdu_cls
0417E3 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
0417E7 CD 77 44 04 0055*      call vdu_buff_select
0417EB 01 00 00 00 0056*      ld bc,0
0417EF 11 00 00 00 0057*      ld de,0
0417F3 CD D3 47 04 0058*      call vdu_plot_bmp
0417F7             0059*  
0417F7             0060*  ; ; draw the most recently loaded image
0417F7             0061*  ; 	ld hl,(cur_buffer_id)
0417F7             0062*  ; 	call vdu_buff_select
0417F7             0063*  ; 	ld bc,0
0417F7             0064*  ; 	ld de,0
0417F7             0065*  ; 	call vdu_plot_bmp
0417F7             0066*  
0417F7             0067*  ; move logo
0417F7 CD 72 18 04 0068*      call move_logo
0417FB             0069*  
0417FB             0070*  ; print current filename
0417FB 2A 9B 17 04 0071*      ld hl,(cur_filename)
0417FF CD 77 00 04 0072*      call printString
041803             0073*  
041803             0074*  ; flip the framebuffer
041803             0075*      ; call vdu_flip
041803             0076*  
041803             0077*  ; decrement loop counter
041803 C1          0078*      pop bc
041804 0B          0079*      dec bc
041805 79          0080*      ld a,c
041806 B7          0081*      or a
041807 C2 DA 17 04 0082*      jp nz,img_load_main_loop
04180B 78          0083*      ld a,b
04180C B7          0084*      or a
04180D C2 DA 17 04 0085*      jp nz,img_load_main_loop
041811 C9          0086*      ret
041812             0087*  
041812             0088*  load_next_image:
041812 16 12       0089*      ld d,image_record_size
041814 3A 98 17 04 0090*      ld a,(cur_file_idx)
041818 5F          0091*      ld e,a
041819 ED 5C       0092*      mlt de
04181B FD 2A 95 17 0093*      ld iy,(cur_image_list)
       04          
041820 FD 19       0094*      add iy,de
041822             0095*  
041822 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
041825 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
041828 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
04182B FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
04182E FD 27 0F    0100*      ld hl,(iy+image_bufferId) ; get image bufferId
041831 22 9E 17 04 0101*      ld (cur_buffer_id),hl
041835 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
041838 FD 22 9B 17 0103*      ld (cur_filename),iy
       04          
04183D CD 95 45 04 0104*      call vdu_load_img
041841 FD 21 98 17 0105*      ld iy,cur_file_idx
       04          
041846 FD 34 00    0106*      inc (iy)
041849 C9          0107*      ret
04184A             0108*  
04184A             0109*  img_load_init:
04184A             0110*  ; initialize logo's position parameters
04184A 21 00 00 00 0111*      ld hl,0
04184E 22 97 18 04 0112*      ld (logo_xvel),hl
041852 22 9A 18 04 0113*      ld (logo_xpos),hl
041856             0114*  ; begin 16.8 maths to determine logo's y position and velocity
041856 21 00 E0 00 0115*      ld hl,240-16*256 ; allow space for text at bottom of screen
04185A 22 A0 18 04 0116*      ld (logo_ypos),hl
04185E EB          0117*      ex de,hl
04185F 21 00 F8 FF 0118*      ld hl,-8*256 ; 8 pixels from top of screen
041863 19          0119*      add hl,de ; distance for logo to travel
041864 11 00 A1 FF 0120*      ld de,-sprites_num_images*256
041868 CD 17 0B 04 0121*      call sdiv168 ; ud.e = distance / num images = y velocity
04186C ED 53 9D 18 0122*      ld (logo_yvel),de
       04          
041871             0123*  ; all done
041871 C9          0124*      ret
041872             0125*  
041872             0126*  move_logo:
041872             0127*  ; activate logo bitmap
041872 21 03 00 00 0128*      ld hl, BUF_SPLASH_LOGO
041876 CD 77 44 04 0129*      call vdu_buff_select
04187A             0130*  ; update position based on velocity parameters
04187A 2A A0 18 04 0131*      ld hl,(logo_ypos)
04187E ED 5B 9D 18 0132*      ld de,(logo_yvel)
       04          
041883 19          0133*      add hl,de
041884 22 A0 18 04 0134*      ld (logo_ypos),hl
041888             0135*  ; draw logo
041888 ED 4B 9A 18 0136*      ld bc,(logo_xpos)
       04          
04188D ED 5B A0 18 0137*      ld de,(logo_ypos)
       04          
041892 CD EF 47 04 0138*      call vdu_plot_bmp168
041896 C9          0139*      ret
041897             0140*  
041897 00 00 00    0141*  logo_xvel: dl 0
04189A 00 00 00    0142*  logo_xpos: dl 0
04189D             0143*  
04189D 00 00 00    0144*  logo_yvel: dl 0
0418A0 00 00 00    0145*  logo_ypos: dl 0
0418A3             0044       include "images_sprites.inc"
0418A3             0001*  ; Generated by make_images.py
0418A3             0002*  
0418A3             0003*  sprites_num_images: equ 95
0418A3             0004*  
0418A3             0005*  ; buffer_ids:
0418A3             0006*  BUF_0TILE_EMPTY: equ 256
0418A3             0007*  BUF_1TILE_CROSS: equ 257
0418A3             0008*  BUF_2TILE_HORIZ: equ 258
0418A3             0009*  BUF_3TILE_VERT: equ 259
0418A3             0010*  BUF_4TILE_SQUARE: equ 260
0418A3             0011*  BUF_5TILE_CIRCLE: equ 261
0418A3             0012*  BUF_6TILE_PAD: equ 262
0418A3             0013*  BUF_7TILE_TURRET: equ 263
0418A3             0014*  BUF_CIRCLE: equ 264
0418A3             0015*  BUF_CRATER: equ 265
0418A3             0016*  BUF_EXPLOSION_A: equ 266
0418A3             0017*  BUF_EXPLOSION_B: equ 267
0418A3             0018*  BUF_EXPLOSION_C: equ 268
0418A3             0019*  BUF_EXPLOSION_D: equ 269
0418A3             0020*  BUF_EXPLOSION_E: equ 270
0418A3             0021*  BUF_FIREBALL_A: equ 271
0418A3             0022*  BUF_FIREBALL_B: equ 272
0418A3             0023*  BUF_LASER_A: equ 273
0418A3             0024*  BUF_LASER_B: equ 274
0418A3             0025*  BUF_PAD: equ 275
0418A3             0026*  BUF_SEEKER_000: equ 276
0418A3             0027*  BUF_SEEKER_008: equ 277
0418A3             0028*  BUF_SEEKER_016: equ 278
0418A3             0029*  BUF_SEEKER_024: equ 279
0418A3             0030*  BUF_SEEKER_032: equ 280
0418A3             0031*  BUF_SEEKER_040: equ 281
0418A3             0032*  BUF_SEEKER_048: equ 282
0418A3             0033*  BUF_SEEKER_056: equ 283
0418A3             0034*  BUF_SEEKER_064: equ 284
0418A3             0035*  BUF_SEEKER_072: equ 285
0418A3             0036*  BUF_SEEKER_080: equ 286
0418A3             0037*  BUF_SEEKER_088: equ 287
0418A3             0038*  BUF_SEEKER_096: equ 288
0418A3             0039*  BUF_SEEKER_104: equ 289
0418A3             0040*  BUF_SEEKER_112: equ 290
0418A3             0041*  BUF_SEEKER_120: equ 291
0418A3             0042*  BUF_SEEKER_128: equ 292
0418A3             0043*  BUF_SEEKER_136: equ 293
0418A3             0044*  BUF_SEEKER_144: equ 294
0418A3             0045*  BUF_SEEKER_152: equ 295
0418A3             0046*  BUF_SEEKER_160: equ 296
0418A3             0047*  BUF_SEEKER_168: equ 297
0418A3             0048*  BUF_SEEKER_176: equ 298
0418A3             0049*  BUF_SEEKER_184: equ 299
0418A3             0050*  BUF_SEEKER_192: equ 300
0418A3             0051*  BUF_SEEKER_200: equ 301
0418A3             0052*  BUF_SEEKER_208: equ 302
0418A3             0053*  BUF_SEEKER_216: equ 303
0418A3             0054*  BUF_SEEKER_224: equ 304
0418A3             0055*  BUF_SEEKER_232: equ 305
0418A3             0056*  BUF_SEEKER_240: equ 306
0418A3             0057*  BUF_SEEKER_248: equ 307
0418A3             0058*  BUF_SHIP_0L: equ 308
0418A3             0059*  BUF_SHIP_1C: equ 309
0418A3             0060*  BUF_SHIP_2R: equ 310
0418A3             0061*  BUF_SHIP_SMALL: equ 311
0418A3             0062*  BUF_STAR: equ 312
0418A3             0063*  BUF_STATION_BG_00: equ 313
0418A3             0064*  BUF_STATION_BG_01: equ 314
0418A3             0065*  BUF_STATION_BG_02: equ 315
0418A3             0066*  BUF_STATION_BG_03: equ 316
0418A3             0067*  BUF_STATION_BG_04: equ 317
0418A3             0068*  BUF_STATION_BG_05: equ 318
0418A3             0069*  BUF_TURRET_000: equ 319
0418A3             0070*  BUF_TURRET_008: equ 320
0418A3             0071*  BUF_TURRET_016: equ 321
0418A3             0072*  BUF_TURRET_024: equ 322
0418A3             0073*  BUF_TURRET_032: equ 323
0418A3             0074*  BUF_TURRET_040: equ 324
0418A3             0075*  BUF_TURRET_048: equ 325
0418A3             0076*  BUF_TURRET_056: equ 326
0418A3             0077*  BUF_TURRET_064: equ 327
0418A3             0078*  BUF_TURRET_072: equ 328
0418A3             0079*  BUF_TURRET_080: equ 329
0418A3             0080*  BUF_TURRET_088: equ 330
0418A3             0081*  BUF_TURRET_096: equ 331
0418A3             0082*  BUF_TURRET_104: equ 332
0418A3             0083*  BUF_TURRET_112: equ 333
0418A3             0084*  BUF_TURRET_120: equ 334
0418A3             0085*  BUF_TURRET_128: equ 335
0418A3             0086*  BUF_TURRET_136: equ 336
0418A3             0087*  BUF_TURRET_144: equ 337
0418A3             0088*  BUF_TURRET_152: equ 338
0418A3             0089*  BUF_TURRET_160: equ 339
0418A3             0090*  BUF_TURRET_168: equ 340
0418A3             0091*  BUF_TURRET_176: equ 341
0418A3             0092*  BUF_TURRET_184: equ 342
0418A3             0093*  BUF_TURRET_192: equ 343
0418A3             0094*  BUF_TURRET_200: equ 344
0418A3             0095*  BUF_TURRET_208: equ 345
0418A3             0096*  BUF_TURRET_216: equ 346
0418A3             0097*  BUF_TURRET_224: equ 347
0418A3             0098*  BUF_TURRET_232: equ 348
0418A3             0099*  BUF_TURRET_240: equ 349
0418A3             0100*  BUF_TURRET_248: equ 350
0418A3             0101*  
0418A3             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
0418A3 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       51 1F 04 00 
       01 00       
0418B5 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       6B 1F 04 01 
       01 00       
0418C7 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       85 1F 04 02 
       01 00       
0418D9 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       9F 1F 04 03 
       01 00       
0418EB 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       B8 1F 04 04 
       01 00       
0418FD 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       D3 1F 04 05 
       01 00       
04190F 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       EE 1F 04 06 
       01 00       
041921 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       06 20 04 07 
       01 00       
041933 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       21 20 04 08 
       01 00       
041945 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       36 20 04 09 
       01 00       
041957 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       4B 20 04 0A 
       01 00       
041969 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       65 20 04 0B 
       01 00       
04197B 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       7F 20 04 0C 
       01 00       
04198D 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       99 20 04 0D 
       01 00       
04199F 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       B3 20 04 0E 
       01 00       
0419B1 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       CD 20 04 0F 
       01 00       
0419C3 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       E6 20 04 10 
       01 00       
0419D5 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       FF 20 04 11 
       01 00       
0419E7 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       15 21 04 12 
       01 00       
0419F9 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       2B 21 04 13 
       01 00       
041A0B 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       3D 21 04 14 
       01 00       
041A1D 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       56 21 04 15 
       01 00       
041A2F 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       6F 21 04 16 
       01 00       
041A41 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       88 21 04 17 
       01 00       
041A53 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       A1 21 04 18 
       01 00       
041A65 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       BA 21 04 19 
       01 00       
041A77 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       D3 21 04 1A 
       01 00       
041A89 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       EC 21 04 1B 
       01 00       
041A9B 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       05 22 04 1C 
       01 00       
041AAD 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       1E 22 04 1D 
       01 00       
041ABF 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       37 22 04 1E 
       01 00       
041AD1 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       50 22 04 1F 
       01 00       
041AE3 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       69 22 04 20 
       01 00       
041AF5 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       82 22 04 21 
       01 00       
041B07 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       9B 22 04 22 
       01 00       
041B19 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       B4 22 04 23 
       01 00       
041B2B 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       CD 22 04 24 
       01 00       
041B3D 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       E6 22 04 25 
       01 00       
041B4F 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       FF 22 04 26 
       01 00       
041B61 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       18 23 04 27 
       01 00       
041B73 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       31 23 04 28 
       01 00       
041B85 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       4A 23 04 29 
       01 00       
041B97 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       63 23 04 2A 
       01 00       
041BA9 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       7C 23 04 2B 
       01 00       
041BBB 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       95 23 04 2C 
       01 00       
041BCD 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       AE 23 04 2D 
       01 00       
041BDF 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       C7 23 04 2E 
       01 00       
041BF1 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       E0 23 04 2F 
       01 00       
041C03 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       F9 23 04 30 
       01 00       
041C15 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       12 24 04 31 
       01 00       
041C27 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       2B 24 04 32 
       01 00       
041C39 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       44 24 04 33 
       01 00       
041C4B 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       5D 24 04 34 
       01 00       
041C5D 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       73 24 04 35 
       01 00       
041C6F 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       89 24 04 36 
       01 00       
041C81 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       9F 24 04 37 
       01 00       
041C93 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       B8 24 04 38 
       01 00       
041CA5 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       CB 24 04 39 
       01 00       
041CB7 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       E7 24 04 3A 
       01 00       
041CC9 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       03 25 04 3B 
       01 00       
041CDB 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       1F 25 04 3C 
       01 00       
041CED 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       3B 25 04 3D 
       01 00       
041CFF 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       57 25 04 3E 
       01 00       
041D11 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       73 25 04 3F 
       01 00       
041D23 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       8C 25 04 40 
       01 00       
041D35 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       A5 25 04 41 
       01 00       
041D47 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       BE 25 04 42 
       01 00       
041D59 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       D7 25 04 43 
       01 00       
041D6B 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       F0 25 04 44 
       01 00       
041D7D 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       09 26 04 45 
       01 00       
041D8F 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       22 26 04 46 
       01 00       
041DA1 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       3B 26 04 47 
       01 00       
041DB3 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       54 26 04 48 
       01 00       
041DC5 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       6D 26 04 49 
       01 00       
041DD7 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       86 26 04 4A 
       01 00       
041DE9 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       9F 26 04 4B 
       01 00       
041DFB 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       B8 26 04 4C 
       01 00       
041E0D 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       D1 26 04 4D 
       01 00       
041E1F 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       EA 26 04 4E 
       01 00       
041E31 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       03 27 04 4F 
       01 00       
041E43 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       1C 27 04 50 
       01 00       
041E55 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       35 27 04 51 
       01 00       
041E67 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       4E 27 04 52 
       01 00       
041E79 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       67 27 04 53 
       01 00       
041E8B 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       80 27 04 54 
       01 00       
041E9D 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       99 27 04 55 
       01 00       
041EAF 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       B2 27 04 56 
       01 00       
041EC1 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       CB 27 04 57 
       01 00       
041ED3 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       E4 27 04 58 
       01 00       
041EE5 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       FD 27 04 59 
       01 00       
041EF7 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       16 28 04 5A 
       01 00       
041F09 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       2F 28 04 5B 
       01 00       
041F1B 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       48 28 04 5C 
       01 00       
041F2D 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       61 28 04 5D 
       01 00       
041F3F 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       7A 28 04 5E 
       01 00       
041F51             0198*  
041F51             0199*  ; files_list: ; filename:
041F51 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
041F6B 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
041F85 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
041F9F 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
041FB8 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
041FD3 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
041FEE 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
042006 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
042021 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
042036 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
04204B 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
042065 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
04207F 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
042099 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
0420B3 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
0420CD 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
0420E6 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
0420FF 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
042115 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
04212B 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
04213D 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
042156 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
04216F 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
042188 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
0421A1 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
0421BA 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
0421D3 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
0421EC 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
042205 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
04221E 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
042237 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
042250 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
042269 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
042282 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
04229B 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0422B4 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
0422CD 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
0422E6 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0422FF 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
042318 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
042331 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
04234A 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
042363 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
04237C 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042395 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0423AE 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0423C7 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
0423E0 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0423F9 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042412 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
04242B 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
042444 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
04245D 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
042473 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
042489 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
04249F 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
0424B8 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
0424CB 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
0424E7 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
042503 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
04251F 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
04253B 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
042557 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
042573 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
04258C 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0425A5 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0425BE 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
0425D7 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
0425F0 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
042609 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
042622 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
04263B 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
042654 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
04266D 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
042686 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04269F 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0426B8 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
0426D1 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0426EA 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042703 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04271C 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
042735 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
04274E 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
042767 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
042780 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
042799 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0427B2 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
0427CB 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0427E4 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0427FD 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042816 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04282F 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042848 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
042861 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04287A 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
042893             0045       include "images_ui.inc"
042893             0001*  ; Generated by make_images.py
042893             0002*  
042893             0003*  ui_num_images: equ 4
042893             0004*  
042893             0005*  ; buffer_ids:
042893             0006*  BUF_BEZEL_L: equ 0
042893             0007*  BUF_BEZEL_R: equ 1
042893             0008*  BUF_SPLASH_BG: equ 2
042893             0009*  BUF_SPLASH_LOGO: equ 3
042893             0010*  
042893             0011*  ui_image_list: ; type; width; height; filename; bufferId:
042893 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       DB 28 04 00 
       00 00       
0428A5 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       EC 28 04 01 
       00 00       
0428B7 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       FD 28 04 02 
       00 00       
0428C9 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       10 29 04 03 
       00 00       
0428DB             0016*  
0428DB             0017*  ; files_list: ; filename:
0428DB 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
0428EC 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
0428FD 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
042910 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
042925             0046       include "laser.inc"
042925             0001*  ; ##### LASER SPRITE PARAMETERS #####
042925             0002*  ; uses the same offsets from its table base as the main sprite table:
042925             0003*  laser_start_variables: ; label marking beginning of table
042925 11          0004*  laser_id:               db table_max_records+1
042926 00          0005*  laser_type:             db 0x00 ; 1 bytes currently not used
042927 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
04292A 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
04292D 00          0008*  laser_collisions:       db 0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
04292E 00          0009*  laser_dim_x:            db 0x00 ; 1 bytes sprite width in pixels
04292F 00          0010*  laser_dim_y:            db 0x00 ; 1 bytes sprite height in pixels
042930 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042933 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042936 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042939 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04293C 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
04293F 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042942 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
042945 00          0018*  laser_animation:        db 0x00 ; 1 bytes current sprite animation frame
042946 00          0019*  laser_animation_timer:  db 0x00 ; 1 bytes decremented every frame, when zero, advance animation
042947 00          0020*  laser_move_timer:       db 0x00 ; 1 bytes not currently used
042948 00          0021*  laser_move_step:        db 0x00 ; 1 bytes not currently used
042949 00          0022*  laser_points:           db 0x00 ; 1 bytes not currently used
04294A 00          0023*  laser_shield_damage:    db 0x00 ; 1 bytes not currently used
04294B             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
04294B             0025*  
04294B             0026*  ; laser_control:
04294B             0027*  ; ; is laser already active?
04294B             0028*  ;     ld a,(laser_collisions)
04294B             0029*  ;     and %00000001 ; bit zero is lit if laser is active
04294B             0030*  ;     jr nz,laser_move ; move laser if not zero
04294B             0031*  ; ; otherwise check if laser fired
04294B             0032*  ;     in a,(#82) ; keyboard
04294B             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
04294B             0034*  ;     ret z ; go back if laser not fired
04294B             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
04294B             0036*  ; ; set laser status to active (set bit 0)
04294B             0037*  ;     ld a,%1
04294B             0038*  ;     ld (laser_collisions),a
04294B             0039*  ; ; initialize laser position
04294B             0040*  ;     ld a,(player_x+1) ; we only need the integer part
04294B             0041*  ;     ; add a,6 ; horizontal center with player sprite
04294B             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
04294B             0043*  ;     ld a,(player_y+1) ; we only need the integer part
04294B             0044*  ;     add a,-6 ; set laser y a few pixels above player
04294B             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
04294B             0046*  ;     ; fall through to laser_move
04294B             0047*  
04294B             0048*  ; laser_move:
04294B             0049*  ; ; begin setting laser to active sprite
04294B             0050*  ;     ld hl,lasers
04294B             0051*  ;     ld (sprite_base_bufferId),hl
04294B             0052*  ;     ld hl,0 ; north
04294B             0053*  ;     ld (sprite_heading),hl
04294B             0054*  ;     xor a ; laser has no animations yet :-(
04294B             0055*  ;     ld (sprite_animation),a
04294B             0056*  ;     ; we set position here for the time being as a default
04294B             0057*  ;     ; in case the laser is flagged for deletion
04294B             0058*  ;     ; load sprite_x with laser x position (we do y further down)
04294B             0059*  ;     ld hl,(laser_x)
04294B             0060*  ;     ld (sprite_x),hl
04294B             0061*  ; ; did laser just die?
04294B             0062*  ;     ld a,(laser_collisions)
04294B             0063*  ;     bit 1,a ; z if laser didn't just die
04294B             0064*  ;     jr z,laser_not_dead_yet
04294B             0065*  ; ; yes laser died
04294B             0066*  ;     call kill_laser
04294B             0067*  ;     ret ; done
04294B             0068*  ; laser_not_dead_yet:
04294B             0069*  ; ; draw it
04294B             0070*  ; ; update laser y position
04294B             0071*  ;     ld hl,(laser_y) ; grab laser y position
04294B             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
04294B             0073*  ;     add hl,de ; add y velocity to y pos
04294B             0074*  ;     ld (sprite_y),hl ; update laser y position
04294B             0075*  ;     ld (laser_y),hl ; update laser y position
04294B             0076*  ; ; are we at top of screen?
04294B             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
04294B             0078*  ;     sub h ; no carry if above threshold
04294B             0079*  ;     jr c,finally_draw_the_frikken_laser
04294B             0080*  ;     ; if at top of screen,laser dies
04294B             0081*  ;     call kill_laser
04294B             0082*  ;     ret
04294B             0083*  ; ; otherwise,finally draw the frikken laser
04294B             0084*  ; finally_draw_the_frikken_laser:
04294B             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04294B             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04294B             0087*  ; ; all done
04294B             0088*  ;     ret
04294B             0089*  
04294B             0090*  ; kill_laser:
04294B             0091*  ; ; update status to inactive
04294B             0092*  ;     xor a ; zero out a
04294B             0093*  ;     ld (laser_collisions),a
04294B             0094*  ;     ret
04294B             0047       include "levels.inc"
04294B 00          0001*  tiles_level_00: db 0 ; number of rows, 0 is max of 256
04294C 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
04295C 00 00 00 00 0003*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
04296C 00 00 00 00 0004*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
04297C 00 00 00 07 0005*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04298C 00 00 00 03 0006*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
04299C 00 00 00 03 0007*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0429AC 00 00 00 01 0008*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0429BC 00 00 00 03 0009*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
0429CC 00 00 00 03 0010*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
0429DC 01 02 02 01 0011*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0429EC 03 04 05 03 0012*      db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
0429FC 03 05 04 03 0013*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
042A0C 01 02 02 01 0014*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
042A1C 00 00 00 00 0015*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
042A2C 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042A3C 00 00 00 00 0017*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
042A4C 00 00 00 00 0018*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
042A5C 00 00 00 00 0019*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
042A6C 00 00 00 00 0020*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042A7C 00 00 00 00 0021*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
042A8C 00 00 00 00 0022*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
042A9C 00 00 00 00 0023*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
042AAC 00 00 00 00 0024*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
042ABC 00 00 00 00 0025*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042ACC 00 00 00 00 0026*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
042ADC 00 00 00 00 0027*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
042AEC 00 00 00 01 0028*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
042AFC 00 00 00 03 0029*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042B0C 00 00 00 03 0030*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042B1C 00 00 00 01 0031*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042B2C 00 00 00 03 0032*      db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
042B3C 00 00 00 03 0033*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
042B4C 00 00 00 01 0034*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
042B5C 00 00 00 00 0035*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042B6C 00 00 00 00 0036*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042B7C 00 00 00 00 0037*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
042B8C 00 00 00 00 0038*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042B9C 00 00 00 00 0039*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042BAC 00 00 00 00 0040*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042BBC 00 00 00 00 0041*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042BCC 00 00 00 00 0042*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042BDC 00 00 00 01 0043*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042BEC 00 00 00 03 0044*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042BFC 00 00 00 03 0045*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C0C 07 02 02 01 0046*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042C1C 03 00 00 03 0047*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C2C 03 00 00 03 0048*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C3C 01 02 02 01 0049*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042C4C 00 00 00 03 0050*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C5C 00 00 00 03 0051*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042C6C 00 00 00 06 0052*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
042C7C 00 00 00 00 0053*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042C8C 00 00 00 00 0054*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
042C9C 00 00 00 00 0055*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
042CAC 00 00 00 00 0056*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042CBC 00 00 00 00 0057*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042CCC 00 00 00 01 0058*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042CDC 00 00 00 03 0059*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
042CEC 00 00 00 03 0060*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
042CFC 00 00 00 01 0061*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
042D0C 00 00 00 03 0062*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D1C 00 00 00 03 0063*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D2C 00 00 00 07 0064*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042D3C 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D4C 00 00 00 00 0066*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D5C 00 00 00 00 0067*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
042D6C 00 00 00 00 0068*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D7C 00 00 00 00 0069*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042D8C 00 00 00 00 0070*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042D9C 00 00 00 00 0071*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
042DAC 00 00 00 00 0072*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
042DBC 00 00 00 00 0073*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
042DCC 00 00 00 00 0074*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042DDC 00 00 00 00 0075*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
042DEC 00 00 00 00 0076*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042DFC 00 00 00 00 0077*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042E0C 00 00 00 00 0078*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042E1C 00 00 00 07 0079*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
042E2C 00 00 00 03 0080*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042E3C 00 00 00 03 0081*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
042E4C 00 00 00 01 0082*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
042E5C 00 00 00 03 0083*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
042E6C 00 00 00 03 0084*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
042E7C 00 00 00 01 0085*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
042E8C 00 00 00 00 0086*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042E9C 00 00 00 00 0087*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
042EAC 00 00 00 00 0088*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
042EBC 00 00 00 00 0089*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
042ECC 00 00 00 00 0090*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
042EDC 00 00 00 00 0091*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
042EEC 00 00 00 00 0092*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042EFC 00 00 00 00 0093*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
042F0C 00 00 00 00 0094*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
042F1C 00 00 00 00 0095*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
042F2C 00 00 00 00 0096*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
042F3C 00 00 00 01 0097*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
042F4C 00 00 00 03 0098*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042F5C 00 00 00 03 0099*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
042F6C 00 00 00 01 0100*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
042F7C 01 02 02 01 0101*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042F8C 03 00 00 03 0102*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042F9C 03 00 00 03 0103*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042FAC 01 02 02 07 0104*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042FBC 03 00 00 03 0105*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042FCC 03 00 00 03 0106*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042FDC 01 02 02 01 0107*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
042FEC 03 00 04 03 0108*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
042FFC 03 04 00 03 0109*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04300C 01 02 02 01 0110*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
04301C 03 00 00 03 0111*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04302C 03 00 04 03 0112*      db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
04303C 01 02 02 01 0113*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
04304C 00 00 00 03 0114*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04305C 00 00 00 03 0115*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
04306C 00 00 00 01 0116*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04307C 00 00 00 00 0117*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
04308C 00 00 00 00 0118*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
04309C 00 00 00 00 0119*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0430AC 00 00 00 00 0120*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0430BC 00 00 00 00 0121*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0430CC 00 00 00 00 0122*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0430DC 00 00 00 00 0123*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
0430EC 00 00 00 00 0124*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
0430FC 00 00 00 00 0125*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
04310C 00 00 00 00 0126*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04311C 00 00 00 00 0127*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
04312C 00 00 00 00 0128*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
04313C 00 00 00 00 0129*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
04314C 00 00 00 00 0130*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
04315C 00 00 00 01 0131*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
04316C 00 00 00 03 0132*      db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
04317C 00 00 00 03 0133*      db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
04318C 01 02 02 07 0134*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04319C 03 04 00 03 0135*      db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0431AC 03 05 04 03 0136*      db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0431BC 01 02 02 01 0137*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0431CC 03 00 00 03 0138*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0431DC 03 00 00 03 0139*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0431EC 01 02 02 01 0140*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0431FC 03 00 00 03 0141*      db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
04320C 03 00 00 03 0142*      db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
04321C 01 02 02 01 0143*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04322C 00 00 00 03 0144*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04323C 00 00 00 03 0145*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04324C 00 00 00 06 0146*      db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
04325C 00 00 00 00 0147*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
04326C 00 00 00 00 0148*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
04327C 00 00 00 00 0149*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
04328C 00 00 00 00 0150*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
04329C 00 00 00 00 0151*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0432AC 00 00 00 00 0152*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0432BC 00 00 00 00 0153*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
0432CC 00 00 00 00 0154*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
0432DC 00 00 00 00 0155*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0432EC 00 00 00 00 0156*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
0432FC 00 00 00 00 0157*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
04330C 00 00 00 00 0158*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
04331C 00 00 00 00 0159*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04332C 00 00 00 00 0160*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04333C 00 00 00 00 0161*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
04334C 00 00 00 00 0162*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
04335C 00 00 00 00 0163*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
04336C 00 00 00 00 0164*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
04337C 00 00 00 00 0165*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04338C 00 00 00 00 0166*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
04339C 00 00 00 01 0167*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
0433AC 00 00 00 03 0168*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
0433BC 00 00 00 03 0169*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
0433CC 00 00 00 01 0170*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
0433DC 01 02 02 07 0171*      db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0433EC 03 00 00 03 0172*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0433FC 03 00 00 03 0173*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04340C 01 02 02 01 0174*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04341C 03 04 04 03 0175*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04342C 03 04 04 03 0176*      db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04343C 01 02 02 01 0177*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04344C 03 00 00 03 0178*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04345C 03 00 00 03 0179*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04346C 01 02 02 01 0180*      db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04347C 03 00 00 03 0181*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04348C 03 00 00 03 0182*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04349C 01 02 02 07 0183*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0434AC 03 00 00 03 0184*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0434BC 03 00 00 03 0185*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0434CC 01 02 02 01 0186*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0434DC 00 00 00 03 0187*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0434EC 00 00 00 03 0188*      db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0434FC 00 00 00 01 0189*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
04350C 00 00 00 03 0190*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04351C 00 00 00 03 0191*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
04352C 00 00 00 01 0192*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
04353C 00 00 00 03 0193*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04354C 00 00 00 03 0194*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04355C 00 00 00 01 0195*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04356C 00 00 00 03 0196*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
04357C 00 00 00 03 0197*      db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
04358C 00 00 00 01 0198*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04359C 00 00 00 03 0199*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0435AC 00 00 00 03 0200*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0435BC 00 00 00 07 0201*      db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0435CC 00 00 00 03 0202*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0435DC 00 00 00 03 0203*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0435EC 00 00 00 01 0204*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0435FC 00 00 00 00 0205*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04360C 00 00 00 00 0206*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
04361C 00 00 00 00 0207*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
04362C 00 00 00 00 0208*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04363C 00 00 00 00 0209*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04364C 00 00 00 00 0210*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
04365C 00 00 00 00 0211*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
04366C 00 00 00 00 0212*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
04367C 00 00 00 00 0213*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
04368C 00 00 00 00 0214*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
04369C 00 00 00 00 0215*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
0436AC 00 00 00 00 0216*      db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
0436BC 00 00 00 00 0217*      db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
0436CC 00 00 00 01 0218*      db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
0436DC 00 00 01 05 0219*      db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
0436EC 01 02 02 07 0220*      db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
0436FC 03 00 00 03 0221*      db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
04370C 03 00 00 03 0222*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04371C 01 02 02 01 0223*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04372C 03 00 00 03 0224*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04373C 03 00 00 03 0225*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04374C 01 02 02 01 0226*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
04375C 00 00 00 03 0227*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04376C 00 00 00 03 0228*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04377C 00 00 00 01 0229*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
04378C 00 00 00 03 0230*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04379C 00 00 00 03 0231*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0437AC 00 00 00 01 0232*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0437BC 00 00 00 03 0233*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0437CC 00 00 00 03 0234*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0437DC 01 02 02 01 0235*      db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
0437EC 03 00 00 03 0236*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0437FC 03 00 00 03 0237*      db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04380C 07 02 02 01 0238*      db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
04381C 00 00 00 03 0239*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04382C 00 00 00 03 0240*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
04383C 00 00 00 01 0241*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
04384C 00 00 00 03 0242*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04385C 00 00 00 03 0243*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04386C 00 00 00 01 0244*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
04387C 00 00 00 00 0245*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04388C 00 00 00 00 0246*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
04389C 00 00 00 00 0247*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0438AC 00 00 00 00 0248*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0438BC 00 00 00 00 0249*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0438CC 00 00 00 01 0250*      db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0438DC 00 00 00 03 0251*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0438EC 00 00 00 03 0252*      db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0438FC 01 02 02 07 0253*      db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
04390C 03 05 05 03 0254*      db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
04391C 03 04 04 03 0255*      db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
04392C 01 02 02 06 0256*      db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
04393C 00 00 00 00 0257*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04394C             0258*  
04394C             0259*  
04394C 10          0260*  tiles_level_01: db 16 ; number of rows, 0 is max of 256
04394D 00 00 00 00 0261*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04395D 00 00 00 00 0262*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04396D 00 00 00 00 0263*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04397D 00 00 00 00 0264*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04398D 00 00 00 00 0265*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04399D 00 00 00 00 0266*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439AD 00 00 00 00 0267*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439BD 00 00 00 00 0268*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439CD 00 00 00 00 0269*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439DD 00 00 00 00 0270*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439ED 00 00 00 00 0271*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439FD 00 00 00 00 0272*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A0D 00 00 00 00 0273*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A1D 00 00 00 00 0274*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A2D 00 00 00 00 0275*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A3D 00 00 00 00 0276*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A4D             0277*  
043A4D             0048       include "player.inc"
043A4D             0001*  ; ######## GAME STATE VARIABLES #######
043A4D             0002*  ; THESE MUST BE IN THIS ORDER FOR game_initialize TO WORK PROPERLY
043A4D 00 00 00    0003*  player_score: dl 0 ; integer
043A50             0004*  ; player current shields,binary
043A50             0005*  ; when < 0 player splodes
043A50             0006*  ; restores to player_max_shields when new ship spawns
043A50 10 00 00    0007*  player_shields: dl 16 ; integer
043A53             0008*  ; max player shields,binary
043A53             0009*  ; can increase with power-ups (todo)
043A53 10 00 00    0010*  player_max_shields: dl 16 ; integer
043A56             0011*  ; when reaches zero,game ends
043A56             0012*  ; can increase based on TODO
043A56 03          0013*  player_ships: db 3 ; integer
043A57             0014*  
043A57             0015*  speed_player: equ 3*256 ; 3 pixels per frame 16.8 fixed
043A57             0016*  
043A57             0017*  ; ######### PLAYER SPRITE PARAMETERS ##########
043A57             0018*  ; uses the same offsets from its table base as the main sprite table:
043A57             0019*  player_start_variables: ; label marking beginning of table
043A57 10          0020*  player_id:               db table_max_records
043A58 00          0021*  player_type:             db     0x00 ; 1 bytes currently not used
043A59 34 01 00    0022*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
043A5C 00 00 00    0023*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
043A5F 00          0024*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
043A60 00          0025*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043A61 00          0026*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043A62 00 00 00    0027*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043A65 00 00 00    0028*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043A68 00 00 00    0029*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043A6B 00 00 00    0030*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043A6E 00 00 00    0031*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
043A71 00 00 00    0032*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043A74 00 00 00    0033*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
043A77 00          0034*  player_animation:        db     0x00 ; 1 bytes not currently used
043A78 00          0035*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
043A79 00          0036*  player_move_timer:       db     0x00 ; 1 bytes not currently used
043A7A 00          0037*  player_move_step:        db     0x00 ; 1 bytes not currently used
043A7B 00          0038*  player_points:           db     0x00 ; 1 bytes not currently used
043A7C 00          0039*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
043A7D             0040*  player_end_variables: ; for when we want to traverse this table in reverse
043A7D             0041*  
043A7D             0042*  ; set initial player position
043A7D             0043*  ; inputs: none,everything is hardcoded
043A7D             0044*  ; outputs: player_x/y set to bottom-left corner of screen
043A7D             0045*  ; destroys: a
043A7D             0046*  player_init:
043A7D 3A 57 3A 04 0047*  	ld a,(player_id)
043A81 CD 74 48 04 0048*  	call vdu_sprite_select
043A85 CD 87 48 04 0049*      call vdu_sprite_clear_frames
043A89 21 34 01 00 0050*      ld hl,BUF_SHIP_0L
043A8D CD C9 49 04 0051*      call vdu_sprite_add_buff
043A91 21 35 01 00 0052*      ld hl,BUF_SHIP_1C
043A95 CD C9 49 04 0053*      call vdu_sprite_add_buff
043A99 21 36 01 00 0054*      ld hl,BUF_SHIP_2R
043A9D CD C9 49 04 0055*      call vdu_sprite_add_buff
043AA1 01 00 00 00 0056*      ld bc,0
043AA5 ED 43 62 3A 0057*      ld (player_x),bc
       04          
043AAA 11 00 6F 01 0058*      ld de,sprite_bottom*256 ; max sprite y-coordinate
043AAE ED 53 65 3A 0059*      ld (player_y),de
       04          
043AB3 CD 40 49 04 0060*      call vdu_sprite_move_abs168
043AB7 CD EA 48 04 0061*      call vdu_sprite_show
043ABB 21 00 40 04 0062*      ld hl,player_alive
043ABF 22 F2 3F 04 0063*      ld (player_state),hl
043AC3 C9          0064*      ret
043AC4             0065*  
043AC4             0066*  ; process player keyboard input, set player bitmap
043AC4             0067*  ; velocities and draw player bitmap at updated coordinates
043AC4             0068*  ; Inputs: player_x/y set at desired position
043AC4             0069*  ; Returns: player bitmap drawn at updated position
043AC4             0070*  ; Destroys: probably everything except maybe iy
043AC4             0071*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
043AC4             0072*  ; TODO: requires sprite implementation
043AC4             0073*  player_input:
043AC4             0074*  ; ; did we die last frame?
043AC4             0075*  ;     ld a,(player_collisions)
043AC4             0076*  ;     and %00000010 ; zero flag will be set if not dead
043AC4             0077*  ;     jr z,player_not_dead
043AC4             0078*  ; ; yes we died
043AC4             0079*  ;     call kill_player
043AC4             0080*  ;     ret ; done
043AC4             0081*  player_not_dead: ; yay we didn't die
043AC4             0082*  ; reset player component velocities to zero as the default
043AC4 21 00 00 00 0083*  	ld hl,0
043AC8 22 68 3A 04 0084*  	ld (player_xvel),hl
043ACC 22 6B 3A 04 0085*  	ld (player_yvel),hl
043AD0             0086*  ; make ship the active sprite
043AD0 3A 57 3A 04 0087*      ld a,(player_id)
043AD4 CD 74 48 04 0088*      call vdu_sprite_select
043AD8             0089*  ; check for keypresses and branch accordingly
043AD8             0090*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043AD8             0091*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043AD8 3E 1E       0001*M 			LD	A, function
043ADA 5B CF       0002*M 			RST.LIL	08h
043ADC             0092*  ; we test all four arrow keys and add/subract velocities accordingly
043ADC             0093*  ; this handles the case where two opposing movement keys
043ADC             0094*  ; are down simultaneously (velocities will net to zero)
043ADC             0095*  ; and allows diagonal movement when a vertical and horizontal key are down
043ADC             0096*  ; it also allows movement and action keys to be detected simultaneously
043ADC             0097*  ; so we can walk and chew gum at the same time
043ADC 3E 01       0098*      ld a,1 ; set ship's default animation to center
043ADE             0099*          ; if left and right are both down a will net to
043ADE             0100*  
043ADE             0101*  @left:
043ADE DD CB 03 4E 0102*      bit 1,(ix+3) ; keycode 26
043AE2 28 0E       0103*      jr z,@right
043AE4 2A 68 3A 04 0104*      ld hl,(player_xvel)
043AE8 01 00 FD FF 0105*      ld bc,-speed_player
043AEC 09          0106*      add hl,bc
043AED 22 68 3A 04 0107*      ld (player_xvel),hl
043AF1 3D          0108*      dec a ; set ship's animation to left
043AF2             0109*  @right:
043AF2 DD CB 0F 4E 0110*      bit 1,(ix+15) ; keycode 122
043AF6 28 0E       0111*  	jr z,@up
043AF8 2A 68 3A 04 0112*      ld hl,(player_xvel)
043AFC 01 00 03 00 0113*      ld bc,speed_player
043B00 09          0114*      add hl,bc
043B01 22 68 3A 04 0115*      ld (player_xvel),hl
043B05 3C          0116*      inc a ; set ship's animation to right
043B06             0117*  @up:
043B06 DD CB 07 4E 0118*      bit 1,(ix+7) ; keycode 58
043B0A 28 0D       0119*  	jr z,@down
043B0C 2A 6B 3A 04 0120*      ld hl,(player_yvel)
043B10 01 00 FD FF 0121*      ld bc,-speed_player
043B14 09          0122*      add hl,bc
043B15 22 6B 3A 04 0123*      ld (player_yvel),hl
043B19             0124*  @down:
043B19 DD CB 05 4E 0125*      bit 1,(ix+5) ; keycode 42
043B1D 28 0D       0126*  	jr z,@done_keyboard
043B1F 2A 6B 3A 04 0127*      ld hl,(player_yvel)
043B23 01 00 03 00 0128*      ld bc,speed_player
043B27 09          0129*      add hl,bc
043B28 22 6B 3A 04 0130*      ld (player_yvel),hl
043B2C             0131*  @done_keyboard:
043B2C             0132*  ; a should land here loaded with the correct frame
043B2C CD D7 48 04 0133*      call vdu_sprite_select_frame
043B30             0134*  ; draw player at updated position
043B30 FD 21 57 3A 0135*      ld iy,player_start_variables
       04          
043B35 FD 22 D2 3D 0136*      ld (table_pointer),iy
       04          
043B3A CD 86 3E 04 0137*      call move_sprite
043B3E ED 4B 62 3A 0138*      ld bc,(player_x)
       04          
043B43 ED 5B 65 3A 0139*      ld de,(player_y)
       04          
043B48 CD 40 49 04 0140*  	call vdu_sprite_move_abs168
043B4C             0141*  
043B4C             0142*      ; call waitKeypress ; DEBUG
043B4C             0143*  ; end player_input
043B4C C9          0144*  	ret
043B4D             0145*  
043B4D             0146*  ; ###################################################################
043B4D             0147*  ; TODO: the below is all stuff from the original code we need to port
043B4D             0148*  ; ###################################################################
043B4D             0149*  
043B4D             0150*  kill_player:
043B4D             0151*  ; ; set player status to dead
043B4D             0152*  ;     xor a; sets all player flags to zero
043B4D             0153*  ;     ld (player_collisions),a
043B4D             0154*  ; ; deduct a ship from the inventory
043B4D             0155*  ;     ld a,(player_ships)
043B4D             0156*  ;     dec a
043B4D             0157*  ;     ld (player_ships),a
043B4D             0158*  ; ; are we out of ships?
043B4D             0159*  ;     jp z,game_over
043B4D             0160*  ; ; wait a few ticks
043B4D             0161*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
043B4D             0162*  ;     ld (player_move_timer),a
043B4D             0163*  ; kill_player_loop:
043B4D             0164*  ;     call vdu_vblank
043B4D             0165*  ;     ld a,(player_move_timer)
043B4D             0166*  ;     dec a
043B4D             0167*  ;     ld (player_move_timer),a
043B4D             0168*  ;     jr nz,kill_player_loop
043B4D             0169*  ;     call player_init ; player respawn if timer zero
043B4D C9          0170*      ret ; and out
043B4E             0171*  
043B4E             0172*  ; draws the player's shields level
043B4E             0173*  ; draw_shields:
043B4E             0174*  ; TODO: Agonize this routine
043B4E             0175*  ; ; prep the loop to draw the bars
043B4E             0176*  ;     ld a,(player_shields) ; snag shields
043B4E             0177*  ;     and a
043B4E             0178*  ;     ret z ; don't draw if zero shields
043B4E             0179*  ; ; set loop counter and drawing position
043B4E             0180*  ;     ld b,a ; loop counter
043B4E             0181*  ;     ld hl,#5300+48+12
043B4E             0182*  ; ; set color based on bars remaining
043B4E             0183*  ;     ld c,103 ; bright green 28fe0a
043B4E             0184*  ;     cp 9
043B4E             0185*  ;     jp p,draw_shields_loop
043B4E             0186*  ;     ld c,74 ; bright yellow eafe5b
043B4E             0187*  ;     cp 3
043B4E             0188*  ;     jp p,draw_shields_loop
043B4E             0189*  ;     ld c,28 ; bright red fe0a0a
043B4E             0190*  ; draw_shields_loop:
043B4E             0191*  ;     push bc ; yup,outta
043B4E             0192*  ;     push hl ; registers again
043B4E             0193*  ;     ; ld a,#A8 ; ▀,168
043B4E             0194*  ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
043B4E             0195*  ;     ; call draw_char
043B4E             0196*  ;     call draw_num ; we nuked draw_char for the time being
043B4E             0197*  ;     pop hl
043B4E             0198*  ;     ld a,8
043B4E             0199*  ;     add a,l
043B4E             0200*  ;     ld l,a
043B4E             0201*  ;     pop bc
043B4E             0202*  ;     djnz draw_shields_loop
043B4E             0203*      ; ret
043B4E             0204*  
043B4E             0205*  score_x: equ 0
043B4E             0206*  score_y: equ 1
043B4E             0207*  ; prints the player's score
043B4E             0208*  print_score:
043B4E             0209*  ; DEBUG
043B4E 0E 00       0210*      ld c,score_x
043B50 06 00       0211*      ld b,score_y-1
043B52 CD 76 43 04 0212*      call vdu_move_cursor
043B56 CD 70 00 04 0213*      call printInline
043B5A 53 63 6F 72 0214*      asciz "Score:"
       65 3A 00    
043B61             0215*  ; END DEBUG
043B61 0E 00       0216*      ld c,score_x
043B63 06 01       0217*      ld b,score_y
043B65 CD 76 43 04 0218*      call vdu_move_cursor
043B69 2A 4D 3A 04 0219*      ld hl,(player_score)
043B6D CD 76 01 04 0220*      call printDec
043B71 C9          0221*      ret
043B72             0222*  
043B72             0223*  ; draw_lives:
043B72             0224*  ;     ld hl,player_small ; make small yellow ship the active sprite
043B72             0225*  ;     ld (sprite_base_bufferId),hl
043B72             0226*  ;     ; ld a,#80 ; northern orientation
043B72             0227*  ;     ; ld (sprite_orientation),a
043B72             0228*  ;     ld hl,0 ; north
043B72             0229*  ;     ld (sprite_heading),hl
043B72             0230*  ;     xor a
043B72             0231*  ;     ld (sprite_animation),a
043B72             0232*  ;     ld a,#56 ; top of visible screen
043B72             0233*  ;     ld (sprite_y+1),a
043B72             0234*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043B72             0235*  ;     ld a,(player_ships)
043B72             0236*  ;     dec a ; we draw one fewer ships than lives
043B72             0237*  ;     ret z ; nothing to draw here, move along
043B72             0238*  ;     ld b,a ; loop counter
043B72             0239*  ;     ld a,256-16 ; initial x position
043B72             0240*  ; draw_lives_loop:
043B72             0241*  ;     ld (sprite_x+1),a
043B72             0242*  ;     push af
043B72             0243*  ;     push bc
043B72             0244*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043B72             0245*  ;     pop bc
043B72             0246*  ;     pop af
043B72             0247*  ;     sub 10
043B72             0248*  ;     djnz draw_lives_loop
043B72             0249*  ;     ret
043B72             0049       include "sprites.inc"
043B72             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
043B72             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
043B72             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
043B72             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
043B72             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
043B72             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
043B72             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
043B72             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
043B72             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
043B72             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
043B72             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
043B72             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043B72             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043B72             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
043B72             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
043B72             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
043B72             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
043B72             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
043B72             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
043B72             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
043B72             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type
043B72             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision
043B72             0023*  
043B72             0024*  ; ###### SPRITE TABLE VARIABLES ######
043B72             0025*  ; maximum number of sprites
043B72             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
043B72             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
043B72             0028*  
043B72             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
043B72             0030*  table_base:
043B72 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043DD2             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
043DD2             0033*  
043DD2             0034*  ; pointer to top address of current record, initialized to table_base
043DD2 72 3B 04    0035*  table_pointer: dl table_base
043DD5             0036*  ; how many active sprites
043DD5 00          0037*  table_active_sprites: db 0x00
043DD6             0038*  ; flag indicating collision with screen edge
043DD6             0039*  ; uses orientation codes to specify which edge(s)
043DD6 00          0040*  sprite_screen_edge: db #00
043DD7             0041*  ; next sprite id to use
043DD7 00          0042*  sprite_next_id: db 0
043DD8             0043*  
043DD8             0044*  ; origin_top: equ 48
043DD8             0045*  origin_top: equ 0 ; DEBUG
043DD8             0046*  origin_left: equ 128
043DD8             0047*  field_top: equ 0
043DD8             0048*  field_bottom: equ 383-origin_top
043DD8             0049*  field_left: equ 0
043DD8             0050*  field_right: equ 255
043DD8             0051*  sprite_top: equ 0
043DD8             0052*  sprite_bottom: equ field_bottom-16
043DD8             0053*  sprite_left: equ field_left
043DD8             0054*  sprite_right: equ field_right-16
043DD8             0055*  collide_top: equ %00001000
043DD8             0056*  collide_bottom: equ %00000100
043DD8             0057*  collide_left: equ %00000010
043DD8             0058*  collide_right: equ %00000001
043DD8             0059*  
043DD8             0060*  ; ######### COLLISION SPRITE PARAMETERS ##########
043DD8             0061*  ; integer coordinates are all that are needed for collision calculations
043DD8 00          0062*  collision_x: db 0x00
043DD9 00          0063*  collision_y: db 0x00
043DDA 00          0064*  collision_dim_x: db 0x00
043DDB 00          0065*  collision_dim_y: db 0x00
043DDC             0066*  
043DDC             0067*  ; scratch variables
043DDC 00          0068*  x: db 0x00 ; 8-bit signed integer
043DDD 00          0069*  y: db 0x00 ; 8-bit signed integer
043DDE 00 00 00    0070*  x0: dl 0x000000 ; 16.8 signed fixed place
043DE1 00 00 00    0071*  y0: dl 0x000000 ; 16.8 signed fixed place
043DE4 00 00 00    0072*  incx1: dl 0x000000 ; 16.8 signed fixed place
043DE7 00 00 00    0073*  incy1: dl 0x000000 ; 16.8 signed fixed place
043DEA 00 00 00    0074*  incx2: dl 0x000000 ; 16.8 signed fixed place
043DED 00 00 00    0075*  incy2: dl 0x000000 ; 16.8 signed fixed place
043DF0             0076*  
043DF0             0077*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
043DF0 00 00 00    0078*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
043DF3 00 00 00    0079*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
043DF6 00 00 00    0080*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
043DF9             0081*  
043DF9             0082*  ; gets the next available sprite id
043DF9             0083*  ; inputs; none
043DF9             0084*  ; returns: if new sprite available, a = sprite id,
043DF9             0085*  ;           ix pointing to new sprite vars, carry set
043DF9             0086*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
043DF9             0087*  ; destroys: a,b,hl,ix
043DF9             0088*  ; affects: bumps table_active_sprites by one
043DF9             0089*  table_get_next_id:
043DF9 DD 21 72 3B 0090*      ld ix,table_base
       04          
043DFE 11 26 00 00 0091*      ld de,table_bytes_per_record
043E02 06 10       0092*      ld b,table_max_records
043E04             0093*  @loop:
043E04 DD 7E 01    0094*      ld a,(ix+sprite_type)
043E07 A7          0095*      and a
043E08 28 06       0096*      jr z,@found
043E0A DD 19       0097*      add ix,de
043E0C 10 F6       0098*      djnz @loop
043E0E             0099*  @notfound:
043E0E AF          0100*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
043E0F C9          0101*      ret
043E10             0102*  @found:
043E10             0103*  ; bump number of active sprites
043E10 21 D5 3D 04 0104*      ld hl,table_active_sprites
043E14 34          0105*      inc (hl)
043E15             0106*  ; return sprite id
043E15 3E 10       0107*      ld a,table_max_records
043E17 90          0108*      sub b
043E18 32 D7 3D 04 0109*      ld (sprite_next_id),a
043E1C 37          0110*      scf ; sets carry flag indicating we found a free sprite
043E1D C9          0111*      ret ; done
043E1E             0112*  
043E1E             0113*  ; deactivate the sprite with the given id
043E1E             0114*  ; inputs: a = sprite id
043E1E             0115*  ; outputs: nothing
043E1E             0116*  ; destroys: a,ix,de
043E1E             0117*  ; affects: decrements table_active_sprites by one
043E1E             0118*  table_deactivate_sprite:
043E1E F5          0119*      push af ; save sprite id bc we need it later
043E1F CD 74 48 04 0120*      call vdu_sprite_select
043E23 CD F8 48 04 0121*      call vdu_sprite_hide
043E27 F1          0122*      pop af ; restore sprite id
043E28 11 00 00 00 0123*      ld de,0 ; clear deu
043E2C 57          0124*      ld d,a
043E2D 1E 26       0125*      ld e,table_bytes_per_record
043E2F ED 5C       0126*      mlt de
043E31 DD 21 72 3B 0127*      ld ix,table_base
       04          
043E36 DD 19       0128*      add ix,de
043E38 AF          0129*      xor a
043E39 DD 77 01    0130*      ld (ix+sprite_type),a
043E3C DD 21 D5 3D 0131*      ld ix,table_active_sprites
       04          
043E41 DD 35 00    0132*      dec (ix)
043E44 C9          0133*      ret
043E45             0134*  
043E45             0135*  sprites_init:
043E45             0136*  ; initialize sprites
043E45 CD A8 49 04 0137*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
043E49 AF          0138*  	xor a
043E4A             0139*  @sprite_loop:
043E4A F5          0140*  	push af
043E4B CD 74 48 04 0141*  	call vdu_sprite_select
043E4F 21 00 01 00 0142*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
043E53 CD C9 49 04 0143*  	call vdu_sprite_add_buff
043E57 F1          0144*  	pop af
043E58 3C          0145*  	inc a
043E59 FE 12       0146*  	cp table_max_records+2 ; tack on sprites for player and laser
043E5B 20 ED       0147*  	jr nz,@sprite_loop
043E5D 3C          0148*  	inc a
043E5E CD A8 48 04 0149*  	call vdu_sprite_activate
043E62             0150*  
043E62             0151*  ; define player sprite
043E62 3A 57 3A 04 0152*  	ld a,(player_id)
043E66 CD 74 48 04 0153*  	call vdu_sprite_select
043E6A CD 87 48 04 0154*  	call vdu_sprite_clear_frames
043E6E 21 34 01 00 0155*  	ld hl,BUF_SHIP_0L
043E72 01 03 00 00 0156*  	ld bc,3 ; three bitmaps for player ship
043E76             0157*  @sprite_player_loop:
043E76 C5          0158*  	push bc
043E77 E5          0159*  	push hl
043E78 CD C9 49 04 0160*  	call vdu_sprite_add_buff
043E7C E1          0161*  	pop hl
043E7D 23          0162*  	inc hl
043E7E C1          0163*  	pop bc
043E7F 10 F5       0164*  	djnz @sprite_player_loop
043E81 CD EA 48 04 0165*  	call vdu_sprite_show
043E85             0166*  
043E85             0167*  ; all done
043E85 C9          0168*      ret
043E86             0169*  
043E86             0170*  ; compute a sprite's new position based on its component x,y velocities
043E86             0171*  ; with screen boundary checking and update its sprite table record accordingly
043E86             0172*  ; inputs: iy pointing to sprite table record
043E86             0173*  ; returns: updated x, y positions and edge collision flags in sprite table record
043E86             0174*  ; destroys: everything
043E86             0175*  ; note: actual rendering of sprite must be handled by caller
043E86             0176*  move_sprite:
043E86 FD 2A D2 3D 0177*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043E8B             0178*  ; x-axis movement
043E8B FD 27 0B    0179*      ld hl,(iy+sprite_x)
043E8E FD 17 11    0180*      ld de,(iy+sprite_xvel)
043E91 19          0181*      add hl,de
043E92 FD 2F 0B    0182*      ld (iy+sprite_x),hl
043E95             0183*  ; y-axis movement
043E95 FD 27 0E    0184*      ld hl,(iy+sprite_y)
043E98 FD 17 14    0185*      ld de,(iy+sprite_yvel)
043E9B 19          0186*      add hl,de
043E9C FD 2F 0E    0187*      ld (iy+sprite_y),hl
043E9F             0188*  ; detect screen edge collisions
043E9F AF          0189*      xor a ; reset screen edge collision flag and clear carry
043EA0 32 D6 3D 04 0190*      ld (sprite_screen_edge),a
043EA4             0191*  ; y-axis first since we already have it in hl
043EA4 11 00 00 00 0192*      ld de,-sprite_top*256
043EA8 ED 5A       0193*      adc hl,de
043EAA FA D4 3E 04 0194*      jp m,@top
043EAE ED 52       0195*      sbc hl,de ; hl back to original value
043EB0 11 00 91 FE 0196*      ld de,-sprite_bottom*256
043EB4 ED 5A       0197*      adc hl,de
043EB6 F2 DE 3E 04 0198*      jp p,@bottom
043EBA             0199*  @xaxis:
043EBA FD 27 0B    0200*      ld hl,(iy+sprite_x)
043EBD 11 00 00 00 0201*      ld de,-sprite_left*256
043EC1 ED 5A       0202*      adc hl,de
043EC3 FA F9 3E 04 0203*      jp m,@left
043EC7 ED 52       0204*      sbc hl,de ; hl back to original value
043EC9 11 00 11 FF 0205*      ld de,-sprite_right*256
043ECD ED 5A       0206*      adc hl,de
043ECF F2 07 3F 04 0207*      jp p,@right
043ED3             0208*  ; no edge collisions so go home
043ED3 C9          0209*      ret
043ED4             0210*  @top:
043ED4 3E 08       0211*      ld a,collide_top
043ED6 21 00 00 00 0212*      ld hl,sprite_top*256
043EDA C3 E4 3E 04 0213*      jp @collide_y
043EDE             0214*  @bottom:
043EDE 3E 04       0215*      ld a,collide_bottom
043EE0 21 00 6F 01 0216*      ld hl,sprite_bottom*256
043EE4             0217*  @collide_y:
043EE4 32 D6 3D 04 0218*      ld (sprite_screen_edge),a
043EE8 FD 2F 0E    0219*      ld (iy+sprite_y),hl
043EEB             0220*  ; reverse y-axis velocity
043EEB FD 27 14    0221*      ld hl,(iy+sprite_yvel)
043EEE CD A4 06 04 0222*      call neg_hlu
043EF2 FD 2F 14    0223*      ld (iy+sprite_yvel),hl
043EF5             0224*  ; go check for x-axis collisions
043EF5 C3 BA 3E 04 0225*      jp @xaxis
043EF9             0226*  @left:
043EF9 3A D6 3D 04 0227*      ld a,(sprite_screen_edge)
043EFD F6 02       0228*      or a,collide_left
043EFF 21 00 00 00 0229*      ld hl,sprite_left*256
043F03 C3 11 3F 04 0230*      jp @collide_x
043F07             0231*  @right:
043F07 3A D6 3D 04 0232*      ld a,(sprite_screen_edge)
043F0B F6 01       0233*      or a,collide_right
043F0D 21 00 EF 00 0234*      ld hl,sprite_right*256
043F11             0235*  @collide_x:
043F11 32 D6 3D 04 0236*      ld (sprite_screen_edge),a
043F15 FD 2F 0B    0237*      ld (iy+sprite_x),hl
043F18             0238*  ; reverse x-axis velocity
043F18 FD 27 11    0239*      ld hl,(iy+sprite_xvel)
043F1B CD A4 06 04 0240*      call neg_hlu
043F1F FD 2F 11    0241*      ld (iy+sprite_xvel),hl
043F22             0242*  ; final collision flag to a and return
043F22 3A D6 3D 04 0243*      ld a,(sprite_screen_edge)
043F26 C9          0244*      ret
043F27             0050       include "state.inc"
043F27             0001*  ; Game state variables
043F27 35 3F 04    0002*  game_state:  dl game_main_menu
043F2A             0003*  
043F2A             0004*  do_game:
043F2A 2A 27 3F 04 0005*      ld hl,(game_state)   ; Load the current game state
043F2E             0006*      callHL                ; Call the corresponding state handler
043F2E 01 34 3F 04 0001*M     ld bc,@F ; Address of first instruction after the jump
043F32 C5          0002*M     push bc ; which constitutes the return address
043F33 E9          0003*M     jp (hl) ; Jump to the address in HL
043F34             0004*M @@:
043F34 C9          0007*      ret
043F35             0008*  
043F35             0009*  ; ========================
043F35             0010*  ; Main Game States
043F35             0011*  ; ========================
043F35             0012*  
043F35             0013*  game_main_menu:
043F35             0014*      ; Handle main menu options
043F35             0015*      ; Example: Check input for "Start Game"
043F35 CD 5A 40 04 0016*      call check_input_menu
043F39 C2 3E 3F 04 0017*      jp nz, game_initialize ; Start game on selection
043F3D C9          0018*      ret
043F3E             0019*  
043F3E             0020*  game_initialize:
043F3E             0021*  ; reset the sprite table
043F3E AF          0022*      xor a
043F3F 32 D5 3D 04 0023*      ld (table_active_sprites),a
043F43 21 72 3B 04 0024*      ld hl,table_base
043F47 22 D2 3D 04 0025*      ld (table_pointer),hl
043F4B             0026*  ; initialize sprites
043F4B CD 45 3E 04 0027*      call sprites_init
043F4F             0028*  ; initialize the first level
043F4F AF          0029*      xor a
043F50 32 6B 40 04 0030*      ld (cur_level),a
043F54 CD 6B 41 04 0031*      call init_level
043F58             0032*  ; initialize player
043F58 21 00 00 00 0033*      ld hl,0
043F5C 22 4D 3A 04 0034*      ld (player_score),hl
043F60 2A 53 3A 04 0035*      ld hl,(player_max_shields)
043F64 22 50 3A 04 0036*      ld (player_shields),hl
043F68 3E 03       0037*      ld a,3
043F6A 32 56 3A 04 0038*      ld (player_ships),a
043F6E CD 7D 3A 04 0039*      call player_init
043F72             0040*  ; TODO: TEMPORARY UNTIL MAP LOGIC IMPLEMENTED
043F72 21 14 40 04 0041*      ld hl,enemies_dead
043F76 22 11 40 04 0042*      ld (enemies_state),hl
043F7A             0043*  ; END TODO
043F7A             0044*  ; set the game state to playing
043F7A 21 84 3F 04 0045*      ld hl,game_playing
043F7E 22 27 3F 04 0046*      ld (game_state), hl
043F82 C9          0047*      ret
043F83             0048*  ; done initializing
043F83 C9          0049*      ret
043F84             0050*  
043F84             0051*  game_playing:
043F84             0052*  ; Main gameplay loop
043F84 CD B6 40 04 0053*      call tiles_plot
043F88 CD F5 3F 04 0054*      call do_player
043F8C CD 06 40 04 0055*      call do_enemies
043F90             0056*  ; update UI: TODO make this a standalone function
043F90 CD 4E 3B 04 0057*      call print_score
043F94 C9          0058*      ret
043F95             0059*  
043F95             0060*  game_paused:
043F95             0061*      ; Pause menu logic
043F95 CD 5D 40 04 0062*      call check_input_pause
043F99 C2 84 3F 04 0063*      jp nz, game_playing ; Resume game
043F9D CA 35 3F 04 0064*      jp z, game_main_menu ; Exit to main menu
043FA1 C9          0065*      ret
043FA2             0066*  
043FA2             0067*  game_level_transition:
043FA2             0068*      ; Handle level transitions
043FA2 CD 5E 40 04 0069*      call load_next_level
043FA6 21 84 3F 04 0070*      ld hl, game_playing
043FAA 22 27 3F 04 0071*      ld (game_state), hl
043FAE C9          0072*      ret
043FAF             0073*  
043FAF             0074*  game_over:
043FAF             0075*      ; Display game over screen
043FAF CD 5F 40 04 0076*      call display_game_over
043FB3 C2 35 3F 04 0077*      jp nz, game_main_menu ; Return to main menu on input
043FB7 C9          0078*      ret
043FB8             0079*  
043FB8             0080*  game_victory:
043FB8             0081*      ; Display victory screen
043FB8 CD 60 40 04 0082*      call display_victory
043FBC C2 35 3F 04 0083*      jp nz, game_main_menu ; Return to main menu on input
043FC0 C9          0084*      ret
043FC1             0085*  
043FC1             0086*  ; ========================
043FC1             0087*  ; Supporting States
043FC1             0088*  ; ========================
043FC1             0089*  
043FC1             0090*  game_loading:
043FC1             0091*      ; Show loading screen while preparing assets
043FC1 CD 61 40 04 0092*      call load_resources
043FC5 21 3E 3F 04 0093*      ld hl, game_initialize
043FC9 22 27 3F 04 0094*      ld (game_state), hl
043FCD C9          0095*      ret
043FCE             0096*  
043FCE             0097*  game_cutscene:
043FCE             0098*      ; Play a non-interactive cutscene
043FCE CD 62 40 04 0099*      call play_cutscene
043FD2 C2 84 3F 04 0100*      jp nz, game_playing ; Return to gameplay after cutscene
043FD6 C9          0101*      ret
043FD7             0102*  
043FD7             0103*  game_inventory:
043FD7             0104*      ; Open inventory or shop
043FD7 CD 63 40 04 0105*      call display_inventory
043FDB C2 84 3F 04 0106*      jp nz, game_playing ; Return to gameplay after inventory close
043FDF C9          0107*      ret
043FE0             0108*  
043FE0             0109*  game_map:
043FE0             0110*      ; Display map or quest
043FE0 CD 64 40 04 0111*      call display_map
043FE4 C2 84 3F 04 0112*      jp nz, game_playing ; Return to gameplay after map close
043FE8 C9          0113*      ret
043FE9             0114*  
043FE9             0115*  game_exit:
043FE9             0116*      ; Handle exit logic
043FE9 CD 65 40 04 0117*      call save_game
043FED C3 66 40 04 0118*      jp exit_game         ; Safely shut down
043FF1 C9          0119*      ret
043FF2             0120*  
043FF2             0121*  ; ========================
043FF2             0122*  ; Sub-state branching (Example for player state)
043FF2             0123*  ; ========================
043FF2             0124*  
043FF2 00 40 04    0125*  player_state:  dl player_alive ; Player state variable
043FF5             0126*  
043FF5             0127*  do_player:
043FF5 2A F2 3F 04 0128*      ld hl,(player_state)
043FF9             0129*      callHL                ; Call the corresponding player state
043FF9 01 FF 3F 04 0001*M     ld bc,@F ; Address of first instruction after the jump
043FFD C5          0002*M     push bc ; which constitutes the return address
043FFE E9          0003*M     jp (hl) ; Jump to the address in HL
043FFF             0004*M @@:
043FFF C9          0130*      ret
044000             0131*  
044000             0132*  player_alive:
044000 CD C4 3A 04 0133*      call player_input     ; Handle player input
044004 C9          0134*      ret
044005             0135*  
044005             0136*  player_dead:
044005             0137*      ; Player is dead, no input handled
044005 C9          0138*      ret
044006             0139*  
044006             0140*  do_enemies:
044006 2A 11 40 04 0141*      ld hl, (enemies_state)
04400A             0142*      callHL
04400A 01 10 40 04 0001*M     ld bc,@F ; Address of first instruction after the jump
04400E C5          0002*M     push bc ; which constitutes the return address
04400F E9          0003*M     jp (hl) ; Jump to the address in HL
044010             0004*M @@:
044010 C9          0143*      ret
044011 14 40 04    0144*  enemies_state: dl enemies_dead
044014             0145*  enemies_dead:
044014 FD 21 39 40 0146*      ld iy,enemies_respawn_tmr
       04          
044019 21 F0 00 00 0147*      ld hl,120*2 ; 120ths of a second
04401D CD E3 42 04 0148*      call timestamp_tmr_set
044021 21 2A 40 04 0149*      ld hl,enemies_respawning
044025 22 11 40 04 0150*      ld (enemies_state),hl
044029 C9          0151*      ret
04402A             0152*  
04402A             0153*  ; DEBUG: FOR TESTING UNTIL WE PROPERLY IMPLEMENT MAP LOGIC
04402A             0154*  enemies_respawning:
04402A FD 21 39 40 0155*      ld iy,enemies_respawn_tmr
       04          
04402F CD EE 42 04 0156*      call timestamp_tmr_get
044033 F0          0157*      ret p ; not time to respawn yet
044034 CD 3F 40 04 0158*      call enemies_respawn
044038 C9          0159*      ret
044039             0160*  enemies_respawn_tmr: ds 6
04403F             0161*  
04403F             0162*  enemies_respawn:
04403F             0163*  ; initialize enemy sprites
04403F 3A 85 07 04 0164*      ld a,(max_enemy_sprites)
044043 47          0165*      ld b,a ; loop counter
044044             0166*  @respawn_loop:
044044 C5          0167*      push bc
044045 CD 6B 08 04 0168*      call enemy_init_from_landing_pad
044049 C1          0169*      pop bc
04404A 10 F8       0170*      djnz @respawn_loop
04404C 21 55 40 04 0171*      ld hl,enemies_alive
044050 22 11 40 04 0172*      ld (enemies_state),hl
044054 C9          0173*      ret
044055             0174*  ; END DEBUG
044055             0175*  
044055             0176*  enemies_alive:
044055 CD 86 07 04 0177*      call move_enemies
044059 C9          0178*      ret
04405A             0179*  
04405A             0180*  check_input_menu:
04405A C9          0181*      ret
04405B             0182*  
04405B             0183*  update_game_world:
04405B C9          0184*      ret
04405C             0185*  
04405C             0186*  check_game_events:
04405C C9          0187*      ret
04405D             0188*  
04405D             0189*  check_input_pause:
04405D C9          0190*      ret
04405E             0191*  
04405E             0192*  load_next_level:
04405E C9          0193*      ret
04405F             0194*  
04405F             0195*  display_game_over:
04405F C9          0196*      ret
044060             0197*  
044060             0198*  display_victory:
044060 C9          0199*      ret
044061             0200*  
044061             0201*  load_resources:
044061 C9          0202*      ret
044062             0203*  
044062             0204*  play_cutscene:
044062 C9          0205*      ret
044063             0206*  
044063             0207*  display_inventory:
044063 C9          0208*      ret
044064             0209*  
044064             0210*  display_map:
044064 C9          0211*      ret
044065             0212*  
044065             0213*  save_game:
044065 C9          0214*      ret
044066             0215*  
044066             0216*  exit_game:
044066 C9          0217*      ret
044067             0218*  
044067             0051       include "tiles.inc"
044067             0001*  ; ######### TILES #########
044067             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
044067             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
044067 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
04406A 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
04406B             0006*      ; initialize to zero for a maximum of 256 rows in a level
04406B 00          0007*  cur_level: db 0
04406C             0008*  num_levels: equ 2 ; number of levels,duh
04406C             0009*  
04406C             0010*  ; lookup table for level definitions
04406C 4B 29 04 4C 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       39 04       
044072             0012*  
044072             0013*  ; tiles_bufferId: dl 0
044072 00 00 00    0014*  tiles_x_plot: dl 0
044075 F1 FF FF    0015*  tiles_y_plot: dl -15
044078             0016*  
044078 FF FF FF    0017*  bg_y_plot: dl -1
04407B 39 01 00    0018*  bg_bufferId: dl BUF_STATION_BG_00 ; default bufferId for background tiles
04407E             0019*  
04407E             0020*  bg_plot:
04407E             0021*  ; load current bg tile bufferId as default
04407E 2A 7B 40 04 0022*      ld hl,(bg_bufferId)
044082             0023*  ; check whether it is time for a new background tile
044082 3A 78 40 04 0024*      ld a,(bg_y_plot)
044086 3C          0025*      inc a
044087 32 78 40 04 0026*      ld (bg_y_plot),a
04408B C2 A3 40 04 0027*      jp nz,@F ; not time for a new tile so draw current one
04408F             0028*  ; load the next background tile
04408F 21 39 01 00 0029*      ld hl,BUF_STATION_BG_00
044093 CD 49 07 04 0030*      call rand_8
044097 E6 03       0031*      and %0000011
044099 85          0032*      add a,l
04409A 6F          0033*      ld l,a
04409B 3E 00       0034*      ld a,0
04409D 8C          0035*      adc a,h
04409E 67          0036*      ld h,a
04409F 22 7B 40 04 0037*      ld (bg_bufferId),hl
0440A3             0038*  @@:
0440A3 CD 77 44 04 0039*      call vdu_buff_select
0440A7 01 00 00 00 0040*      ld bc,0
0440AB ED 5B 78 40 0041*      ld de,(bg_y_plot)
       04          
0440B0 13          0042*      inc de
0440B1 CD D3 47 04 0043*      call vdu_plot_bmp
0440B5             0044*  ; all done
0440B5 C9          0045*      ret
0440B6             0046*  
0440B6             0047*  ; xevious_plot:
0440B6             0048*  ; ; load current bg tile bufferId as default
0440B6             0049*  ;     ld hl,(bg_bufferId)
0440B6             0050*  ; ; check whether it is time for a new background tile
0440B6             0051*  ;     ld a,(bg_y_plot)
0440B6             0052*  ;     inc a
0440B6             0053*  ;     ld (bg_y_plot),a
0440B6             0054*  ;     jp nz,@F ; not time for a new tile so draw current one
0440B6             0055*  ; ; load the next background tile
0440B6             0056*  ;     ld hl,Xevious_tile
0440B6             0057*  ;     inc (hl)
0440B6             0058*  ;     ld a,%00011111 ; 31
0440B6             0059*  ;     and (hl)
0440B6             0060*  ;     ld hl,BUF_XEVIOUS_00
0440B6             0061*  ;     add a,l
0440B6             0062*  ;     ld l,a
0440B6             0063*  ;     ld a,0
0440B6             0064*  ;     adc a,h
0440B6             0065*  ;     ld h,a
0440B6             0066*  ;     ld (bg_bufferId),hl
0440B6             0067*  ; @@:
0440B6             0068*  ;     call vdu_buff_select
0440B6             0069*  ;     ld bc,0
0440B6             0070*  ;     ld de,(bg_y_plot)
0440B6             0071*  ;     inc de
0440B6             0072*  ;     call vdu_plot_bmp
0440B6             0073*  ; ; all done
0440B6             0074*  ;     ret
0440B6             0075*  ; Xevious_tile: db 0
0440B6             0076*  
0440B6             0077*  tiles_plot:
0440B6             0078*  ; set gfx viewport to playing field window
0440B6 01 00 00 00 0079*      ld bc,field_left
0440BA 11 00 00 00 0080*      ld de,field_top
0440BE DD 21 FF 00 0081*      ld ix,field_right
       00          
0440C3 FD 21 7F 01 0082*      ld iy,field_bottom
       00          
0440C8 CD 2A 44 04 0083*      call vdu_set_gfx_viewport
0440CC             0084*  ; move the background down one pixel
0440CC 3E 02       0085*      ld a,2 ; current gfx viewport
0440CE 2E 02       0086*      ld l,2 ; direction=down
0440D0 26 01       0087*      ld h,1 ; speed=1 px
0440D2 CD A2 43 04 0088*      call vdu_scroll_down
0440D6             0089*  ; set gfx viewport to one scanline to optimise plotting tiles
0440D6 01 00 00 00 0090*      ld bc,0 ; leftmost x-coord
0440DA 11 00 00 00 0091*      ld de,0 ; topmost y-coord
0440DE DD 21 FF 00 0092*      ld ix,255 ; rightmost x-coord
       00          
0440E3 FD 21 00 00 0093*      ld iy,0 ; bottommost y-coord
       00          
0440E8 CD 2A 44 04 0094*      call vdu_set_gfx_viewport
0440EC             0095*  ; plot the background
0440EC CD 7E 40 04 0096*      call bg_plot
0440F0             0097*      ; call xevious_plot
0440F0             0098*      ; ret ; DEBUG
0440F0             0099*  ; initialize tiles loop
0440F0 21 00 00 00 0100*      ld hl,0 ; init plotting x-coordinate
0440F4 22 72 40 04 0101*      ld (tiles_x_plot),hl
0440F8 2A 67 40 04 0102*      ld hl,(tiles_row_defs)
0440FC 06 10       0103*      ld b,16 ; loop counter
0440FE             0104*  @loop:
0440FE C5          0105*      push bc ; save the loop counter
0440FF             0106*  ; read the tile defintion for the current column
0440FF 7E          0107*      ld a,(hl) ; a has tile definition
044100 E5          0108*      push hl ; save pointer to tile definition
044101 21 00 00 00 0109*      ld hl,0 ; hlu is non-zero
044105 6F          0110*      ld l,a ; l is tile defintion
044106 26 01       0111*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
044108 CD 77 44 04 0112*      call vdu_buff_select ; tile bitmap buffer is now active
04410C             0113*  ; plot the active bitmap
04410C ED 4B 72 40 0114*      ld bc,(tiles_x_plot)
       04          
044111 ED 5B 75 40 0115*      ld de,(tiles_y_plot)
       04          
044116 CD D3 47 04 0116*      call vdu_plot_bmp
04411A             0117*  ; bump x-coords the width of one tile and save it
04411A 2A 72 40 04 0118*      ld hl,(tiles_x_plot)
04411E 01 10 00 00 0119*      ld bc,16
044122 09          0120*      add hl,bc
044123 22 72 40 04 0121*      ld (tiles_x_plot),hl
044127             0122*  ; prepare to loop to next column
044127 E1          0123*      pop hl ; get back pointer to tile def
044128 23          0124*      inc hl ; bump it to the next column
044129 C1          0125*      pop bc ; snag our loop counter
04412A 10 D2       0126*      djnz @loop
04412C             0127*  ; increment tiles plotting y-coordinate
04412C             0128*  ; when it hits zero, we go to next row of tiles in the map
04412C             0129*  ; (we use ix b/c we want to preserve hl for the next step)
04412C DD 21 75 40 0130*      ld ix,tiles_y_plot
       04          
044131 DD 34 00    0131*      inc (ix)
044134 C0          0132*      ret nz
044135             0133*  ; time to bump tiles_row_defs to next row
044135             0134*  ; (hl was already there at the end of the loop)
044135 22 67 40 04 0135*      ld (tiles_row_defs),hl
044139             0136*  ; reset coords to plot next row of tiles
044139 21 00 00 00 0137*      ld hl,0
04413D 22 72 40 04 0138*      ld (tiles_x_plot),hl
044141 21 F1 FF FF 0139*      ld hl,-15
044145 22 75 40 04 0140*      ld (tiles_y_plot),hl
044149             0141*  ; decrement tiles row counter
044149 21 6A 40 04 0142*      ld hl,tiles_row
04414D 35          0143*      dec (hl)
04414E C0          0144*      ret nz
04414F             0145*  ; queue up next level
04414F 3A 6B 40 04 0146*      ld a,(cur_level)
044153 FE 01       0147*      cp num_levels-1
044155 20 02       0148*      jr nz,@inc_level
044157 3E FF       0149*      ld a,-1 ; will wrap around to zero when we fall through
044159             0150*  @inc_level:
044159 3C          0151*      inc a
04415A 32 6B 40 04 0152*      ld (cur_level),a
04415E             0153*  ; increase the number of enemy sprites
04415E 3A 85 07 04 0154*      ld a,(max_enemy_sprites)
044162 3C          0155*      inc a
044163 FE 10       0156*      cp table_max_records ; if we're at the global limit,skip ahead at max level
044165 28 04       0157*      jr z,init_level
044167 32 85 07 04 0158*      ld (max_enemy_sprites),a ; otherwise save the updated number
04416B             0159*  ; fall through to init_level
04416B             0160*  
04416B             0161*  init_level:
04416B             0162*  ; look up address of level's tile defintion
04416B 21 6C 40 04 0163*      ld hl,tiles_levels
04416F 3A 6B 40 04 0164*      ld a,(cur_level)
044173 11 00 00 00 0165*      ld de,0 ; just in case deu is non-zero
044177 57          0166*      ld d,a
044178 1E 03       0167*      ld e,3
04417A ED 5C       0168*      mlt de
04417C 19          0169*      add hl,de
04417D ED 37       0170*      ld ix,(hl)
04417F DD 22 67 40 0171*      ld (tiles_row_defs),ix
       04          
044184             0172*  ; set tiles_row counter
044184 DD 7E 00    0173*      ld a,(ix)
044187 32 6A 40 04 0174*      ld (tiles_row),a
04418B DD 23       0175*      inc ix ; now ix points first element of first row tile def
04418D DD 22 67 40 0176*      ld (tiles_row_defs),ix ; ... so we save it
       04          
044192             0177*  ; draw initial background tiles
044192             0178*  ; TODO: make this a stars background
044192 21 39 01 00 0179*      ld hl,BUF_STATION_BG_00
044196 CD 77 44 04 0180*      call vdu_buff_select
04419A 01 00 00 00 0181*      ld bc,0
04419E 11 00 00 00 0182*      ld de,field_top
0441A2 CD D3 47 04 0183*      call vdu_plot_bmp
0441A6             0184*  
0441A6 21 3A 01 00 0185*      ld hl,BUF_STATION_BG_01
0441AA CD 77 44 04 0186*      call vdu_buff_select
0441AE 01 00 00 00 0187*      ld bc,0
0441B2 11 00 01 00 0188*      ld de,field_top+256
0441B6 CD D3 47 04 0189*      call vdu_plot_bmp
0441BA             0190*  
0441BA C9          0191*      ret
0441BB             0192*  
0441BB             0193*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
0441BB             0194*  ; dt_is_active:
0441BB             0195*  ; ; a lands here containing a tile index in the low nibble
0441BB             0196*  ; ; we test the values for the tiles which are active
0441BB             0197*  ;     cp #07
0441BB             0198*  ;     call z,ld_act_landing_pad
0441BB             0199*  ;     cp #08
0441BB             0200*  ;     call z,ld_act_laser_turret
0441BB             0201*  ;     ; fall through
0441BB             0202*  ;     ret
0441BB             0203*  
0441BB             0204*  ; ; some tiles become active sprites,so we load those here
0441BB             0205*  ; ; sprite_x/y have already been loaded
0441BB             0206*  ; ; sprite_dim_x/y are loaded by table_add_record
0441BB             0207*  ; ; we don't want sprite drawn to background like other tiles
0441BB             0208*  ; ; so this routine only adds them to the sprite table
0441BB             0209*  ; dt_ld_act:
0441BB             0210*  ;     ld a,#48 ; top of screen + 1/2 tile height
0441BB             0211*  ;     ld (sprite_y+1),a ; just the integer part
0441BB             0212*  ;     ld (sprite_base_bufferId),hl
0441BB             0213*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0441BB             0214*  ;     call table_add_record
0441BB             0215*  ;     call sprite_variables_from_stack
0441BB             0216*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
0441BB             0217*  ;     ret ; and back
0441BB             0218*  
0441BB             0219*  ; ld_act_landing_pad:
0441BB             0220*  ;     call sprite_variables_to_stack
0441BB             0221*  
0441BB             0222*  ;     ld hl,move_landing_pad
0441BB             0223*  ;     ld (sprite_move_program),hl
0441BB             0224*  
0441BB             0225*  ;     xor a
0441BB             0226*  ;     ld (sprite_animation),a ; animation 0
0441BB             0227*  
0441BB             0228*  ;     call rand_8     ; snag a random number
0441BB             0229*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0441BB             0230*  ;     add a,64 ; range is now 64-127
0441BB             0231*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0441BB             0232*  
0441BB             0233*  ;     ld a,%10 ; collides with laser but not player
0441BB             0234*  ;     ld (iy+sprite_collisions),a
0441BB             0235*  
0441BB             0236*  ;     ld a,#05 ; BCD
0441BB             0237*  ;     ld (sprite_points),a
0441BB             0238*  ;     ld a,0 ; binary
0441BB             0239*  ;     ld (sprite_shield_damage),a
0441BB             0240*  
0441BB             0241*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
0441BB             0242*  ;     jr dt_ld_act
0441BB             0243*  
0441BB             0244*  ; ld_act_laser_turret:
0441BB             0245*  ;     call sprite_variables_to_stack
0441BB             0246*  
0441BB             0247*  ;     ld hl,move_laser_turret
0441BB             0248*  ;     ld (sprite_move_program),hl
0441BB             0249*  
0441BB             0250*  ;     xor a
0441BB             0251*  ;     ld (sprite_animation),a
0441BB             0252*  ;     ld (sprite_move_step),a
0441BB             0253*  
0441BB             0254*  ;     call rand_8     ; snag a random number
0441BB             0255*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0441BB             0256*  ;     add a,64 ; range is now 64-127
0441BB             0257*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0441BB             0258*  
0441BB             0259*  ;     ld a,%10 ; collides with laser but not player
0441BB             0260*  ;     ld (iy+sprite_collisions),a
0441BB             0261*  
0441BB             0262*  ;     ld a,#10 ; BCD
0441BB             0263*  ;     ld (sprite_points),a
0441BB             0264*  ;     ld a,0 ; binary
0441BB             0265*  ;     ld (sprite_shield_damage),a
0441BB             0266*  
0441BB             0267*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
0441BB             0268*  ;     jp dt_ld_act
0441BB             0269*  
0441BB             0270*  
0441BB             0271*  ; moves active tile sprites down one pixel in sync with tiles movement
0441BB             0272*  ; deletes sprites from table when they wrap around to top of screen
0441BB             0273*  move_active_tiles:
0441BB             0274*  ; get current position
0441BB 3A 0F 00 00 0275*      ld a,(sprite_y+1) ; we only need the integer part
0441BF 3C          0276*      inc a
0441C0             0277*  ; are we at the bottom of the screen?
0441C0 20 06       0278*      jr nz,move_active_tiles_draw_sprite ; nope
0441C2             0279*  ; otherwise kill sprite
0441C2 3E 80       0280*      ld a,%10000000 ; any bit set in high nibble means sprite will die
0441C4 FD 77 08    0281*      ld (iy+sprite_collisions),a
0441C7 C9          0282*      ret ; debug
0441C8             0283*  move_active_tiles_draw_sprite:
0441C8 32 0F 00 00 0284*      ld (sprite_y+1),a ; update tile y position integer part
0441CC             0285*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0441CC             0286*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
0441CC C9          0287*      ret ; and done
0441CD             0052       include "timer.inc"
0441CD             0001*  ; Table 32. Timer Control Registers
0441CD             0002*  ; this constant is the base address of the timer control registers
0441CD             0003*  ; each timer takes three bytes:
0441CD             0004*  ;   0: control register
0441CD             0005*  ;   1: low byte of timer reset value
0441CD             0006*  ;   2: high byte of timer reset value
0441CD             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0441CD             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0441CD             0009*  TMR_CTL:     equ 80h
0441CD             0010*  
0441CD             0011*  ; Timer Control Register Bit Definitions
0441CD             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0441CD             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0441CD             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0441CD             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0441CD             0016*                              ; the TMRx_CTL register is read.
0441CD             0017*  
0441CD             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0441CD             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0441CD             0020*  
0441CD             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0441CD             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0441CD             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0441CD             0024*                              ; written to the counter when the end-of-count value is reached.
0441CD             0025*  
0441CD             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0441CD             0027*  CLK_DIV_256:  equ %00001100 ;
0441CD             0028*  CLK_DIV_64:   equ %00001000 ;
0441CD             0029*  CLK_DIV_16:   equ %00000100 ;
0441CD             0030*  CLK_DIV_4:    equ %00000000 ;
0441CD             0031*  
0441CD             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0441CD             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0441CD             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0441CD             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0441CD             0036*                              ; programmer must ensure that this bit is set to 1 each time
0441CD             0037*                              ; SINGLE-PASS mode is used.
0441CD             0038*  
0441CD             0039*  ; disable/enable the programmable reload timer
0441CD             0040*  PRT_EN_0:     equ %00000000 ;
0441CD             0041*  PRT_EN_1:     equ %00000001 ;
0441CD             0042*  
0441CD             0043*  ; Table 37. Timer Input Source Select Register
0441CD             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0441CD             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0441CD             0046*  ;   00: System clock / CLK_DIV
0441CD             0047*  ;   01: RTC / CLK_DIV
0441CD             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0441CD             0049*  ;   10: GPIO port B pin 1.
0441CD             0050*  ;   11: GPIO port B pin 1.
0441CD             0051*  TMR_ISS:   equ 92h ; register address
0441CD             0052*  
0441CD             0053*  ; Table 51. Real-Time Clock Control Register
0441CD             0054*  RTC_CTRL: equ EDh ; register address
0441CD             0055*  
0441CD             0056*  ; alarm interrupt disable/enable
0441CD             0057*  RTC_ALARM_0:    equ %00000000
0441CD             0058*  RTC_ALARM_1:    equ %10000000
0441CD             0059*  
0441CD             0060*  ; interrupt on alarm disable/enable
0441CD             0061*  RTC_INT_ENT_0:  equ %00000000
0441CD             0062*  RTC_INT_ENT_1:  equ %01000000
0441CD             0063*  
0441CD             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0441CD             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0441CD             0066*  
0441CD             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0441CD             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0441CD             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0441CD             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0441CD             0071*  
0441CD             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0441CD             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0441CD             0074*  
0441CD             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0441CD             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0441CD             0077*  
0441CD             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0441CD             0079*                                  ; RTC counter is enabled.
0441CD             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0441CD             0081*                                  ; RTC counter is disabled.
0441CD             0082*  
0441CD             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0441CD             0084*  
0441CD             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0441CD             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0441CD 00 00 00    0087*  prt_reload: dl 0x000000
0441D0             0088*  
0441D0             0089*  ; set PRT timer
0441D0             0090*  prt_set:
0441D0 21 00 00 00 0091*      ld hl,0
0441D4 22 1E 42 04 0092*      ld (prt_irq_counter),hl
0441D8 2A CD 41 04 0093*      ld hl,(prt_reload)
0441DC ED 29 84    0094*      out0 ($84),l
0441DF ED 21 85    0095*  	out0 ($85),h
0441E2             0096*  ; disable timer
0441E2 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0441E4 ED 39 83    0098*  	out0 ($83),a
0441E7             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0441E7 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0441E9 ED 39 83    0101*  	out0 ($83),a
0441EC C9          0102*      ret
0441ED             0103*  
0441ED             0104*  ; ===============================================
0441ED             0105*  ; PRT Timer Interrupt Handling
0441ED             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0441ED             0107*  ; -----------------------------------------------
0441ED             0108*  prt_irq_init:
0441ED             0109*      ; set up interrupt vector table 2
0441ED 21 00 00 00 0110*  	ld hl,0
0441F1 3A 0C 01 00 0111*  	ld a,($10c)
0441F5 6F          0112*  	ld l,a
0441F6 3A 0D 01 00 0113*  	ld a,($10d)
0441FA 67          0114*  	ld h,a
0441FB             0115*  
0441FB             0116*  	; skip over CALL ($c3)
0441FB 23          0117*  	inc hl
0441FC             0118*  	; load address of jump into vector table 2 (in ram)
0441FC ED 27       0119*  	ld hl,(hl)
0441FE             0120*  
0441FE             0121*  	; write CALL prt_irq_handler to vector table 2
0441FE 3E C3       0122*  	ld a,$c3
044200 77          0123*  	ld (hl),a
044201 23          0124*  	inc hl
044202 11 09 42 04 0125*  	ld de,prt_irq_handler
044206 ED 1F       0126*  	ld (hl),de
044208             0127*  
044208 C9          0128*      ret
044209             0129*  
044209             0130*  prt_irq_handler:
044209 F3          0131*  	di
04420A F5          0132*  	push af
04420B E5          0133*      push hl
04420C ED 38 83    0134*  	in0 a,($83)
04420F 2A 1E 42 04 0135*  	ld hl,(prt_irq_counter)
044213 23          0136*  	inc hl
044214 22 1E 42 04 0137*  	ld (prt_irq_counter),hl
044218 E1          0138*      pop hl
044219 F1          0139*  	pop af
04421A FB          0140*  	ei
04421B 5B ED 4D    0141*  	reti.l
04421E             0142*  
04421E             0143*  prt_irq_counter:
04421E 00 00 00    0144*  	.dl 0
044221             0145*  prt_irq_counter_saved:
044221 00 00 00    0146*      .dl 0
044224             0147*  
044224             0148*  prt_loop_reset:
044224 E5          0149*      push hl
044225 21 00 00 00 0150*  	ld hl,0
044229 22 1E 42 04 0151*  	ld (prt_irq_counter),hl
04422D 22 8F 42 04 0152*      ld (prt_loop_counter),hl
044231 22 92 42 04 0153*      ld (prt_loops),hl
044235 CD D0 41 04 0154*      call prt_set
044239 E1          0155*      pop hl
04423A C9          0156*      ret
04423B             0157*  
04423B             0158*  prt_loop_start:
04423B E5          0159*      push hl
04423C 21 00 00 00 0160*  	ld hl,0
044240 22 1E 42 04 0161*  	ld (prt_irq_counter),hl
044244 E1          0162*      pop hl
044245 C9          0163*      ret
044246             0164*  
044246             0165*  prt_loop_stop:
044246 E5          0166*      push hl
044247 D5          0167*      push de
044248 2A 1E 42 04 0168*      ld hl,(prt_irq_counter)
04424C ED 5B 8F 42 0169*      ld de,(prt_loop_counter)
       04          
044251 19          0170*      add hl,de
044252 22 8F 42 04 0171*      ld (prt_loop_counter),hl
044256 21 00 00 00 0172*      ld hl,0
04425A 22 1E 42 04 0173*      ld (prt_irq_counter),hl
04425E 2A 92 42 04 0174*      ld hl,(prt_loops)
044262 23          0175*      inc hl
044263 22 92 42 04 0176*      ld (prt_loops),hl
044267 D1          0177*      pop de
044268 E1          0178*      pop hl
044269 C9          0179*      ret
04426A             0180*  
04426A             0181*  ; inputs: bc = y,x text coordinates to print
04426A             0182*  prt_loop_print:
04426A F5          0183*      push af
04426B E5          0184*      push hl
04426C C5          0185*      push bc
04426D D5          0186*      push de
04426E DD E5       0187*      push ix
044270 FD E5       0188*      push iy
044272 CD 76 43 04 0189*      call vdu_move_cursor
044276             0190*  
044276 2A 8F 42 04 0191*      ld hl,(prt_loop_counter)
04427A CD 76 01 04 0192*      call printDec
04427E             0193*  
04427E 2A 92 42 04 0194*      ld hl,(prt_loops)
044282 CD 76 01 04 0195*      call printDec
044286             0196*  
044286 FD E1       0197*      pop iy
044288 DD E1       0198*      pop ix
04428A D1          0199*      pop de
04428B C1          0200*      pop bc
04428C E1          0201*      pop hl
04428D F1          0202*      pop af
04428E C9          0203*      ret
04428F             0204*  
04428F             0205*  prt_loop_counter:
04428F 00 00 00    0206*      .dl 0
044292             0207*  prt_loops:
044292 00 00 00    0208*      .dl 0
044295             0209*  
044295             0210*  ; ===============================================
044295             0211*  ; Timer functions
044295             0212*  ; -----------------------------------------------
044295             0213*  ; set a countdown timer
044295             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
044295             0215*  ; returns: hl = current time
044295             0216*  tmr_set:
044295 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
044298             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
044298 3E 08       0001*M 			LD	A, function
04429A 5B CF       0002*M 			RST.LIL	08h
04429C DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
04429F FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0442A2 C9          0221*      ret
0442A3             0222*  
0442A3             0223*  ; gets time remaining on a countdown timer
0442A3             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0442A3             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0442A3             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0442A3             0227*  tmr_get:
0442A3             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0442A3 3E 08       0001*M 			LD	A, function
0442A5 5B CF       0002*M 			RST.LIL	08h
0442A7 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0442AA FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0442AD AF          0231*      xor a                   ; clear carry
0442AE ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0442B0 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0442B3 AF          0234*      xor a                   ; clear carry
0442B4 ED 5A       0235*      adc hl,de               ; hl = time remaining
0442B6             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0442B6 C9          0237*      ret
0442B7             0238*  
0442B7             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0442BD             0240*  
0442BD 00 00 00    0241*  timestamp_now: dl 0
0442C0 00 00 00    0242*  timestamp_old: dl 0
0442C3 00 00 00    0243*  timestamp_chg: dl 0
0442C6             0244*  
0442C6             0245*  ; update the global timestamp from the system clock
0442C6             0246*  ; inputs: none
0442C6             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0442C6             0248*  ;          ix = pointer to syvars table
0442C6             0249*  ; destroys: af,hl,de,ix
0442C6             0250*  timestamp_tick:
0442C6 ED 5B BD 42 0251*      ld de,(timestamp_now)   ; get previous time
       04          
0442CB ED 53 C0 42 0252*      ld (timestamp_old),de   ; save previous time
       04          
0442D0             0253*      MOSCALL mos_sysvars     ; ix points to syvars table
0442D0 3E 08       0001*M 			LD	A, function
0442D2 5B CF       0002*M 			RST.LIL	08h
0442D4 DD 27 00    0254*      ld hl,(ix+sysvar_time)  ; get current time
0442D7 22 BD 42 04 0255*      ld (timestamp_now),hl   ; save current time
0442DB AF          0256*      xor a                   ; clear carry
0442DC ED 52       0257*      sbc hl,de               ; hl = time elapsed
0442DE 22 C3 42 04 0258*      ld (timestamp_chg),hl   ; save elapsed time
0442E2 C9          0259*      ret
0442E3             0260*  
0442E3             0261*  ; set a countdown timer
0442E3             0262*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0442E3             0263*  ; requires: timestamp_tick to be called at least once before this function
0442E3             0264*  ; returns: hl = current time
0442E3             0265*  ; destroys: hl
0442E3             0266*  timestamp_tmr_set:
0442E3 FD 2F 03    0267*      ld (iy+3),hl            ; set time remaining
0442E6 2A BD 42 04 0268*      ld hl,(timestamp_now)   ; get current timestamp
0442EA FD 2F 00    0269*      ld (iy+0),hl            ; set start time
0442ED C9          0270*      ret
0442EE             0271*  
0442EE             0272*  ; gets time remaining on a countdown timer following the global timestamp
0442EE             0273*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0442EE             0274*  ; requires: timestamp_tick to be called at least once before this function
0442EE             0275*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0442EE             0276*  ;          sign flags: pos = time not expired,zero or neg = time expired
0442EE             0277*  ; destroys: af,hl,de
0442EE             0278*  timestamp_tmr_get:
0442EE ED 5B BD 42 0279*      ld de,(timestamp_now)   ; get current timestamp
       04          
0442F3 FD 27 00    0280*      ld hl,(iy+0)            ; get start time
0442F6 AF          0281*      xor a                   ; clear carry
0442F7 ED 52       0282*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0442F9 FD 17 03    0283*      ld de,(iy+3)            ; get timer set value
0442FC AF          0284*      xor a                   ; clear carry
0442FD ED 5A       0285*      adc hl,de               ; hl = time remaining
0442FF             0286*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0442FF C9          0287*      ret
044300             0288*  
044300             0289*  ; set a stopwatch
044300             0290*  ; returns: hl = start time
044300             0291*  ; destroys: hl,ix
044300             0292*  stopwatch_set:
044300             0293*      MOSCALL mos_sysvars     ; ix points to syvars table
044300 3E 08       0001*M 			LD	A, function
044302 5B CF       0002*M 			RST.LIL	08h
044304 DD 27 00    0294*      ld hl,(ix+sysvar_time)  ; get current time
044307 22 1C 43 04 0295*      ld (stopwatch_started),hl            ; set start time
04430B C9          0296*      ret
04430C             0297*  
04430C             0298*  ; gets time elapsed on a stopwatch
04430C             0299*  ; returns: hl = time elapsed in 1/120ths of a second
04430C             0300*  ; destroys: af,hl,de,ix
04430C             0301*  stopwatch_get:
04430C             0302*      MOSCALL mos_sysvars     ; ix points to syvars table
04430C 3E 08       0001*M 			LD	A, function
04430E 5B CF       0002*M 			RST.LIL	08h
044310 DD 27 00    0303*      ld hl,(ix+sysvar_time)  ; get current time
044313 ED 5B 1C 43 0304*      ld de,(stopwatch_started)            ; get start time
       04          
044318 AF          0305*      xor a                   ; clear carry
044319 ED 52       0306*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04431B C9          0307*      ret
04431C             0308*  
04431C             0309*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04431F             0310*  
04431F             0311*  ; ------------------
04431F             0312*  ; delay routine
04431F             0313*  ; Author: Richard Turrnidge
04431F             0314*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04431F             0315*  ; routine waits a fixed time,then returns
04431F             0316*  ; arrive with A =  the delay byte. One bit to be set only.
04431F             0317*  ; eg. ld A,00000100b
04431F             0318*  
04431F             0319*  multiPurposeDelay:
04431F F5          0320*      push af
044320 C5          0321*      push bc
044321 DD E5       0322*      push ix
044323 47          0323*      ld b,a
044324 3E 08       0324*      ld a,$08
044326 5B CF       0325*      RST.LIL	08h                 ; get IX pointer to sysvars
044328             0326*  
044328             0327*  waitLoop:
044328             0328*  
044328 DD 7E 00    0329*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04432B             0330*  
04432B             0331*                                  ;   we check if bit set is same as last time we checked.
04432B             0332*                                  ;   bit 0 - don't use
04432B             0333*                                  ;   bit 1 - changes 64 times per second
04432B             0334*                                  ;   bit 2 - changes 32 times per second
04432B             0335*                                  ;   bit 3 - changes 16 times per second
04432B             0336*  
04432B             0337*                                  ;   bit 4 - changes 8 times per second
04432B             0338*                                  ;   bit 5 - changes 4 times per second
04432B             0339*                                  ;   bit 6 - changes 2 times per second
04432B             0340*                                  ;   bit 7 - changes 1 times per second
04432B A0          0341*      and b
04432C 4F          0342*      ld c,a
04432D 3A 3E 43 04 0343*      ld a,(oldTimeStamp)
044331 B9          0344*      cp c                        ; is A same as last value?
044332 28 F4       0345*      jr z,waitLoop              ; loop here if it is
044334 79          0346*      ld a,c
044335 32 3E 43 04 0347*      ld (oldTimeStamp),a        ; set new value
044339             0348*  
044339 DD E1       0349*      pop ix
04433B C1          0350*      pop bc
04433C F1          0351*      pop af
04433D C9          0352*      ret
04433E             0353*  
04433E 00          0354*  oldTimeStamp:   .db 00h
04433F             0053       include "vdu.inc"
04433F             0001*  
04433F             0002*  ; VDU 30: Home cursor
04433F             0003*  vdu_home_cursor:
04433F 3E 1E       0004*      ld a,30
044341 5B D7       0005*  	rst.lil $10
044343 C9          0006*  	ret
044344             0007*  
044344             0008*  vdu_cursor_on:
044344 21 4F 43 04 0009*  	ld hl,@cmd
044348 01 03 00 00 0010*  	ld bc,@end-@cmd
04434C 5B DF       0011*  	rst.lil $18
04434E C9          0012*  	ret
04434F             0013*  @cmd:
04434F 17 01 01    0014*  	db 23,1,1
044352             0015*  @end:
044352             0016*  
044352             0017*  vdu_cursor_off:
044352 21 5D 43 04 0018*  	ld hl,@cmd
044356 01 03 00 00 0019*  	ld bc,@end-@cmd
04435A 5B DF       0020*  	rst.lil $18
04435C C9          0021*  	ret
04435D             0022*  @cmd:
04435D 17 01 00    0023*  	db 23,1,0
044360             0024*  @end:
044360             0025*  
044360             0026*  ; VDU 5: Write text at graphics cursor
044360             0027*  ; inputs: a is the character to write to the screen
044360             0028*  ; prerequisites: the graphics cursor at the intended position on screen
044360             0029*  ; outputs: see the name of the function
044360             0030*  ; destroys: a, hl, bc
044360             0031*  vdu_char_to_gfx_cursor:
044360 32 70 43 04 0032*  	ld (@arg),a
044364 21 6F 43 04 0033*  	ld hl,@cmd
044368 01 02 00 00 0034*  	ld bc,@end-@cmd
04436C 5B DF       0035*  	rst.lil $18
04436E C9          0036*  	ret
04436F 05          0037*  @cmd: db 5
044370 00          0038*  @arg: db 0
044371             0039*  @end:
044371             0040*  ; VDU 9: Move cursor forward one character
044371             0041*  vdu_cursor_forward:
044371 3E 09       0042*      ld a,9
044373 5B D7       0043*  	rst.lil $10
044375 C9          0044*  	ret
044376             0045*  
044376             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
044376             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
044376             0048*  vdu_move_cursor:
044376 ED 43 87 43 0049*      ld (@x0),bc
       04          
04437B 21 86 43 04 0050*  	ld hl,@cmd
04437F 01 03 00 00 0051*  	ld bc,@end-@cmd
044383 5B DF       0052*  	rst.lil $18
044385 C9          0053*  	ret
044386 1F          0054*  @cmd: 	db 31
044387 00          0055*  @x0:	db 0
044388 00          0056*  @y0: 	db 0
044389 00          0057*  @end: 	db 0 ; padding
04438A             0058*  
04438A             0059*  ; VDU 12: Clear text area (CLS)
04438A             0060*  vdu_cls:
04438A 3E 0C       0061*      ld a,12
04438C 5B D7       0062*  	rst.lil $10
04438E C9          0063*  	ret
04438F             0064*  
04438F             0065*  vdu_flip:
04438F 21 9A 43 04 0066*  	ld hl,@cmd
044393 01 03 00 00 0067*  	ld bc,@end-@cmd
044397 5B DF       0068*  	rst.lil $18
044399 C9          0069*  	ret
04439A 17 00 C3    0070*  @cmd: db 23,0,0xC3
04439D             0071*  @end:
04439D             0072*  
04439D             0073*  ; VDU 16: Clear graphics area (CLG)
04439D             0074*  vdu_clg:
04439D 3E 10       0075*      ld a,16
04439F 5B D7       0076*  	rst.lil $10
0443A1 C9          0077*  	ret
0443A2             0078*  
0443A2             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0443A2             0080*  ; VDU 23, 7: Scrolling
0443A2             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0443A2             0082*  ; inputs: a, extent; l, direction; h; speed
0443A2             0083*  vdu_scroll_down:
0443A2 32 B7 43 04 0084*  	ld (@extent),a
0443A6 22 B8 43 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0443AA 21 B5 43 04 0086*  	ld hl,@cmd
0443AE 01 05 00 00 0087*  	ld bc,@end-@cmd
0443B2 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
0443B4 C9          0089*  	ret
0443B5 17 07       0090*  @cmd:       db 23,7
0443B7 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0443B8 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0443B9 00          0093*  @speed:     db 0x00 ; pixels
0443BA 00          0094*  @end:		db 0x00 ; padding
0443BB             0095*  
0443BB             0096*  ; COLOUR MODES
0443BB             0097*  ; Mode	Effect
0443BB             0098*  ; 0	Set on-screen pixel to target colour value
0443BB             0099*  ; 1	OR value with the on-screen pixel
0443BB             0100*  ; 2	AND value with the on-screen pixel
0443BB             0101*  ; 3	XOR value with the on-screen pixel
0443BB             0102*  ; 4	Invert the on-screen pixel
0443BB             0103*  ; 5	No operation
0443BB             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0443BB             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0443BB             0106*  
0443BB             0107*  ; VDU 17, colour: Define text colour (COLOUR)
0443BB             0108*  vdu_colour_text:
0443BB 32 CB 43 04 0109*  	ld (@arg),a
0443BF 21 CA 43 04 0110*  	ld hl,@cmd
0443C3 01 02 00 00 0111*  	ld bc,@end-@cmd
0443C7 5B DF       0112*  	rst.lil $18
0443C9 C9          0113*  	ret
0443CA 11          0114*  @cmd: db 17
0443CB 00          0115*  @arg: db 0
0443CC             0116*  @end:
0443CC             0117*  
0443CC             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0443CC             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0443CC             0120*  vdu_gcol:
0443CC 32 E1 43 04 0121*  	ld (@mode),a
0443D0 79          0122*      ld a,c
0443D1 32 E2 43 04 0123*      ld (@col),a
0443D5 21 E0 43 04 0124*  	ld hl,@cmd
0443D9 01 03 00 00 0125*  	ld bc,@end-@cmd
0443DD 5B DF       0126*  	rst.lil $18
0443DF C9          0127*  	ret
0443E0 12          0128*  @cmd:  db 18
0443E1 00          0129*  @mode: db 0
0443E2 00          0130*  @col:  db 0
0443E3             0131*  @end:
0443E3             0132*  
0443E3             0133*  
0443E3             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
0443E3             0135*  ; MIND THE LITTLE-ENDIANESS
0443E3             0136*  ; inputs: c=left,b=bottom,e=right,d=top
0443E3             0137*  ; outputs; nothing
0443E3             0138*  ; destroys: a might make it out alive
0443E3             0139*  vdu_set_txt_viewport:
0443E3 ED 43 F9 43 0140*      ld (@lb),bc
       04          
0443E8 ED 53 FB 43 0141*  	ld (@rt),de
       04          
0443ED 21 F8 43 04 0142*  	ld hl,@cmd
0443F1 01 05 00 00 0143*  	ld bc,@end-@cmd
0443F5 5B DF       0144*  	rst.lil $18
0443F7 C9          0145*  	ret
0443F8 1C          0146*  @cmd:   db 28 ; set text viewport command
0443F9 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
0443FB 00 00       0148*  @rt: 	dw 0x0000 ; set by de
0443FD 00          0149*  @end:   db 0x00	  ; padding
0443FE             0150*  
0443FE             0151*  ; Wait for VBLANK interrupt
0443FE             0152*  vdu_vblank:
0443FE DD E5       0153*      PUSH 	IX
044400             0154*  	MOSCALL	mos_sysvars
044400 3E 08       0001*M 			LD	A, function
044402 5B CF       0002*M 			RST.LIL	08h
044404 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
044407             0156*  @wait:
044407 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
04440A 28 FB       0158*      JR	Z, @wait
04440C DD E1       0159*      POP	IX
04440E C9          0160*      RET
04440F             0161*  
04440F             0162*  ; VDU 29, x; y;: Set graphics origin
04440F             0163*  ; This command sets the graphics origin.
04440F             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04440F             0165*  ; inputs: bc=x0,de=y0
04440F             0166*  ; outputs; nothing
04440F             0167*  ; destroys: a might make it out alive
04440F             0168*  vdu_set_gfx_origin:
04440F ED 43 25 44 0169*      ld (@x0),bc
       04          
044414 ED 53 27 44 0170*      ld (@y0),de
       04          
044419 21 24 44 04 0171*      ld hl,@cmd
04441D 01 05 00 00 0172*      ld bc,@end-@cmd
044421 5B DF       0173*      rst.lil $18
044423 C9          0174*      ret
044424 1D          0175*  @cmd:   db 29 ; set graphics origin command
044425 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
044427 00 00       0177*  @y0: 	dw 0x0000 ; set by de
044429 00          0178*  @end:   db 0x00	  ; padding
04442A             0179*  
04442A             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04442A             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04442A             0182*  ; 	because we have turned off logical screen scaling
04442A             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04442A             0184*  ; outputs; nothing
04442A             0185*  ; destroys: a might make it out alive
04442A             0186*  vdu_set_gfx_viewport:
04442A ED 43 4A 44 0187*      ld (@x0),bc
       04          
04442F FD 22 4C 44 0188*      ld (@y1),iy
       04          
044434 DD 22 4E 44 0189*  	ld (@x1),ix
       04          
044439 ED 53 50 44 0190*  	ld (@y0),de
       04          
04443E 21 49 44 04 0191*  	ld hl,@cmd
044442 01 09 00 00 0192*  	ld bc,@end-@cmd
044446 5B DF       0193*  	rst.lil $18
044448 C9          0194*  	ret
044449 18          0195*  @cmd:   db 24 ; set graphics viewport command
04444A 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
04444C 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
04444E 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
044450 00 00       0199*  @y0: 	dw 0x0000 ; set by de
044452 00          0200*  @end:   db 0x00	  ; padding
044453             0201*  
044453             0202*  ; SCREEN MODES
044453             0203*  ; ===============================
044453             0204*  ; Mode  Horz  Vert  Cols  Refresh
044453             0205*  ; ---   ----  ----  ----  -------
044453             0206*  ; 11    320   240   2     60hz
044453             0207*  ; 139   320   240   2     60hz
044453             0208*  ; 23    512   384   2     60hz
044453             0209*  ; 151   512   384   2     60hz
044453             0210*  ; 6     640   240   2     60hz
044453             0211*  ; 134   640   240   2     60hz
044453             0212*  ; 2     640   480   2     60hz
044453             0213*  ; 130   640   480   2     60hz
044453             0214*  ; 17    800   600   2     60hz
044453             0215*  ; 145   800   600   2     60hz
044453             0216*  ; 18    1024  768   2     60hz
044453             0217*  ; 146   1024  768   2     60hz
044453             0218*  ; ---   ----  ----  ----  -------
044453             0219*  ; 10    320   240   4     60hz
044453             0220*  ; 138   320   240   4     60hz
044453             0221*  ; 22    512   384   4     60hz
044453             0222*  ; 150   512   384   4     60hz
044453             0223*  ; 5     640   240   4     60hz
044453             0224*  ; 133   640   240   4     60hz
044453             0225*  ; 1     640   480   4     60hz
044453             0226*  ; 129   640   480   4     60hz
044453             0227*  ; 16    800   600   4     60hz
044453             0228*  ; 19    1024  768   4     60hz
044453             0229*  ; ---   ----  ----  ----  -------
044453             0230*  ; 9     320   240   16    60hz
044453             0231*  ; 137   320   240   16    60hz
044453             0232*  ; 21    512   384   16    60hz
044453             0233*  ; 149   512   384   16    60hz
044453             0234*  ; 4     640   240   16    60hz
044453             0235*  ; 132   640   240   16    60hz
044453             0236*  ; 0     640   480   16    60hz
044453             0237*  ; 7     n/a   n/a   16    60hz
044453             0238*  ; ---   ----  ----  ----  -------
044453             0239*  ; 8     320   240   64    60hz
044453             0240*  ; 136   320   240   64    60hz
044453             0241*  ; 20    512   384   64    60hz
044453             0242*  ; 3     640   240   64    60hz
044453             0243*  ; ---   ----  ----  ----  -------
044453             0244*  vdu_set_screen_mode:
044453 32 63 44 04 0245*  	ld (@arg),a
044457 21 62 44 04 0246*  	ld hl,@cmd
04445B 01 02 00 00 0247*  	ld bc,@end-@cmd
04445F 5B DF       0248*  	rst.lil $18
044461 C9          0249*  	ret
044462 16          0250*  @cmd: db 22 ; set screen mode
044463 00          0251*  @arg: db 0  ; screen mode parameter
044464             0252*  @end:
044464             0253*  
044464             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
044464             0255*  ; inputs: a is scaling mode, 1=on, 0=off
044464             0256*  ; note: default setting on boot is scaling ON
044464             0257*  vdu_set_scaling:
044464 32 76 44 04 0258*  	ld (@arg),a
044468 21 73 44 04 0259*  	ld hl,@cmd
04446C 01 04 00 00 0260*  	ld bc,@end-@cmd
044470 5B DF       0261*  	rst.lil $18
044472 C9          0262*  	ret
044473 17 00 C0    0263*  @cmd: db 23,0,0xC0
044476 00          0264*  @arg: db 0  ; scaling on/off
044477             0265*  @end:
044477             0266*  
044477             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
044477             0268*  ; inputs: hl=bufferId
044477             0269*  vdu_buff_select:
044477 22 89 44 04 0270*  	ld (@bufferId),hl
04447B 21 86 44 04 0271*  	ld hl,@cmd
04447F 01 05 00 00 0272*  	ld bc,@end-@cmd
044483 5B DF       0273*  	rst.lil $18
044485 C9          0274*  	ret
044486 17 1B 20    0275*  @cmd: db 23,27,0x20
044489 00 00       0276*  @bufferId: dw 0x0000
04448B 00          0277*  @end: db 0x00 ; padding
04448C             0278*  
04448C             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04448C             0280*  ; inputs: a=format; bc=width; de=height
04448C             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04448C             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04448C             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
04448C             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
04448C             0285*  ; 2 	Mono/Mask (1-bit per pixel)
04448C             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
04448C             0287*  vdu_bmp_create:
04448C ED 43 A8 44 0288*      ld (@width),bc
       04          
044491 ED 53 AA 44 0289*      ld (@height),de
       04          
044496 32 AC 44 04 0290*      ld (@fmt),a
04449A 21 A5 44 04 0291*  	ld hl,@cmd
04449E 01 08 00 00 0292*  	ld bc,@end-@cmd
0444A2 5B DF       0293*  	rst.lil $18
0444A4 C9          0294*  	ret
0444A5 17 1B 21    0295*  @cmd:       db 23,27,0x21
0444A8 00 00       0296*  @width:     dw 0x0000
0444AA 00 00       0297*  @height:    dw 0x0000
0444AC 00          0298*  @fmt:       db 0x00
0444AD             0299*  @end:
0444AD             0300*  
0444AD             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0444AD             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0444AD             0303*  vdu_load_img_rgba2_to_8:
0444AD             0304*  ; backup the target buffer id and image dimensions
0444AD E5          0305*      push hl
0444AE D5          0306*      push de
0444AF C5          0307*      push bc
0444B0             0308*  ; load the rgba2 image to working buffer 65534
0444B0 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
0444B4 CD B7 45 04 0310*  	call vdu_load_buffer_from_file
0444B8             0311*  ; restore the image dimensions and target buffer id
0444B8 C1          0312*      pop bc
0444B9 D1          0313*      pop de
0444BA E1          0314*      pop hl
0444BB             0315*  ; fall through to vdu_rgba2_to_8
0444BB             0316*  
0444BB             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0444BB             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0444BB             0319*  ; the "expand bitmap" command is:
0444BB             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0444BB             0321*  ; and then to reverse the byte order to fix endian-ness:
0444BB             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0444BB             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0444BB             0324*  ; VDU 23,27,&20,targetBufferID%;
0444BB             0325*  ; VDU 23,27,&21,width%;height%;0
0444BB             0326*  ; -------------------------------------------------------------------
0444BB             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0444BB             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0444BB             0329*  vdu_rgba2_to_8:
0444BB             0330*  ; load the image dimensions and buffer id parameters
0444BB ED 43 17 45 0331*      ld (@width),bc
       04          
0444C0 ED 53 19 45 0332*      ld (@height),de
       04          
0444C5 22 FC 44 04 0333*      ld (@bufferId0),hl
0444C9 22 09 45 04 0334*      ld (@bufferId2),hl
0444CD 22 12 45 04 0335*      ld (@bufferId1),hl
0444D1             0336*  ; clean up bytes that got stomped on by the ID loads
0444D1 3E 48       0337*      ld a,0x48
0444D3 32 FE 44 04 0338*      ld (@bufferId0+2),a
0444D7 3E 17       0339*      ld a,23
0444D9 32 14 45 04 0340*      ld (@bufferId1+2),a
0444DD 3E 18       0341*      ld a,24
0444DF 32 0B 45 04 0342*      ld (@bufferId2+2),a
0444E3 AF          0343*      xor a
0444E4 32 1B 45 04 0344*      ld (@height+2),a
0444E8             0345*  ; send the vdu command strings
0444E8 21 F3 44 04 0346*      ld hl,@beg
0444EC 01 29 00 00 0347*      ld bc,@end-@beg
0444F0 5B DF       0348*      rst.lil $18
0444F2 C9          0349*      ret
0444F3             0350*  @beg:
0444F3             0351*  ; Command 14: Consolidate blocks in a buffer
0444F3             0352*  ; VDU 23, 0, &A0, bufferId; 14
0444F3 17 00 A0    0353*      db 23,0,0xA0
0444F6 FE FF       0354*      dw 65534 ; workingBufferId
0444F8 0E          0355*      db 14 ; consolidate blocks
0444F9             0356*  ; the "expand bitmap" command is:
0444F9             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0444F9 17 00 A0    0358*      db 23,0,0xA0
0444FC 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
0444FE 48          0360*      db 0x48 ; given as decimal command 72 in the docs
0444FF 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
044500 FE FF       0362*      dw 65534 ; sourceBufferId
044502 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
044506             0364*  ; reverse the byte order to fix endian-ness:
044506             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
044506             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
044506             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
044506 17 00 A0    0368*      db 23,0,0xA0
044509 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04450B 18          0370*      db 24 ; reverse byte order
04450C 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04450D 04 00       0372*      dw 4 ; size (4 bytes)
04450F             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04450F             0374*  ; VDU 23,27,&20,targetBufferID%;
04450F 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
044512 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
044514             0377*  ; VDU 23,27,&21,width%;height%;0
044514 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
044517 00 00       0379*  @width: dw 0x0000
044519 00 00       0380*  @height: dw 0x0000
04451B 00          0381*      db 0x00 ; rgba8888 format
04451C             0382*  @end:
04451C             0383*  
04451C             0384*  ; scratch variables
04451C 00 00 00    0385*  bufferId0: dl 0x000000
04451F 00 00 00    0386*  bufferId1: dl 0x000000
044522             0387*  
044522             0388*  ; load a vdu buffer from local memory
044522             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
044522             0390*  vdu_load_buffer:
044522 ED 43 4B 45 0391*      ld (@length),bc
       04          
044527 D5          0392*      push de ; save data pointer
044528             0393*  ; send the vdu command string
044528 7D          0394*      ld a,l
044529 32 48 45 04 0395*      ld (@bufferId),a
04452D 7C          0396*      ld a,h
04452E 32 49 45 04 0397*      ld (@bufferId+1),a
044532 21 45 45 04 0398*      ld hl,@cmd
044536 01 08 00 00 0399*      ld bc,@end-@cmd
04453A 5B DF       0400*      rst.lil $18
04453C             0401*  ; send the buffer data
04453C E1          0402*      pop hl ; pointer to data
04453D ED 4B 4B 45 0403*      ld bc,(@length)
       04          
044542 5B DF       0404*      rst.lil $18 ; send it
044544 C9          0405*      ret
044545             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
044545 17 00 A0    0407*  @cmd:       db 23,0,0xA0
044548 00 00       0408*  @bufferId:	dw 0x0000
04454A 00          0409*  		    db 0 ; load buffer
04454B 00 00       0410*  @length:	dw 0x0000
04454D 00          0411*  @end: db 0 ; padding
04454E             0412*  
04454E             0413*  ; clear a buffer
04454E             0414*  ; inputs: hl = bufferId
04454E             0415*  vdu_clear_buffer:
04454E 7D          0416*      ld a,l
04454F 32 66 45 04 0417*      ld (@bufferId),a
044553 7C          0418*      ld a,h
044554 32 67 45 04 0419*      ld (@bufferId+1),a
044558 21 63 45 04 0420*      ld hl,@cmd
04455C 01 06 00 00 0421*      ld bc,@end-@cmd
044560 5B DF       0422*      rst.lil $18
044562 C9          0423*      ret
044563 17 00 A0    0424*  @cmd:       db 23,0,0xA0
044566 00 00       0425*  @bufferId:	dw 0x0000
044568 02          0426*  		    db 2 ; clear buffer
044569             0427*  @end:
044569             0428*  
044569             0429*  vdu_clear_all_buffers:
044569             0430*  ; clear all buffers
044569 21 74 45 04 0431*      ld hl,@beg
04456D 01 06 00 00 0432*      ld bc,@end-@beg
044571 5B DF       0433*      rst.lil $18
044573 C9          0434*      ret
044574 17 00 A0    0435*  @beg: db 23,0,$A0
044577 FF FF       0436*        dw -1 ; clear all buffers
044579 02          0437*        db 2  ; command 2: clear a buffer
04457A             0438*  @end:
04457A             0439*  
04457A             0440*  ; Command 14: Consolidate blocks in a buffer
04457A             0441*  vdu_consolidate_buffer:
04457A             0442*  ; set parameters for vdu call
04457A 7D          0443*      ld a,l
04457B 32 92 45 04 0444*      ld (@bufferId),a
04457F 7C          0445*      ld a,h
044580 32 93 45 04 0446*      ld (@bufferId+1),a
044584 21 8F 45 04 0447*      ld hl,@beg
044588 01 06 00 00 0448*      ld bc,@end-@beg
04458C 5B DF       0449*      rst.lil $18
04458E C9          0450*      ret
04458F             0451*  ; VDU 23, 0, &A0, bufferId; 14
04458F 17 00 A0    0452*  @beg: db 23,0,0xA0
044592 00 00       0453*  @bufferId: dw 0x0000
044594 0E          0454*             db 14
044595             0455*  @end:
044595             0456*  
044595             0457*  ; load an image file to a buffer and make it a bitmap
044595             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
044595             0459*  vdu_load_img:
044595             0460*  ; back up image type and dimension parameters
044595 22 1C 45 04 0461*      ld (bufferId0),hl
044599 F5          0462*      push af
04459A C5          0463*  	push bc
04459B D5          0464*  	push de
04459C             0465*  ; load the image
04459C CD B7 45 04 0466*  	call vdu_load_buffer_from_file
0445A0             0467*  ; now make it a bitmap
0445A0 2A 1C 45 04 0468*      ld hl,(bufferId0)
0445A4 CD 7A 45 04 0469*      call vdu_consolidate_buffer
0445A8 2A 1C 45 04 0470*      ld hl,(bufferId0)
0445AC CD 77 44 04 0471*      call vdu_buff_select
0445B0 D1          0472*  	pop de ; image height
0445B1 C1          0473*  	pop bc ; image width
0445B2 F1          0474*  	pop af ; image type
0445B3 C3 8C 44 04 0475*  	jp vdu_bmp_create ; will return to caller from there
0445B7             0476*  
0445B7             0477*  ; inputs: hl = bufferId; iy = pointer to filename
0445B7             0478*  vdu_load_buffer_from_file:
0445B7 22 1C 45 04 0479*      ld (bufferId0),hl
0445BB             0480*  
0445BB             0481*  ; clear target buffer
0445BB CD 4E 45 04 0482*      call vdu_clear_buffer
0445BF             0483*  
0445BF             0484*  ; open the file in read mode
0445BF             0485*  ; Open a file
0445BF             0486*  ; HLU: Filename
0445BF             0487*  ;   C: Mode
0445BF             0488*  ; Returns:
0445BF             0489*  ;   A: Filehandle, or 0 if couldn't open
0445BF FD E5       0490*  	push iy ; pointer to filename
0445C1 E1          0491*  	pop hl
0445C2 0E 01       0492*  	ld c,fa_read
0445C4             0493*      MOSCALL mos_fopen
0445C4 3E 0A       0001*M 			LD	A, function
0445C6 5B CF       0002*M 			RST.LIL	08h
0445C8 32 03 46 04 0494*      ld (@filehandle),a
0445CC             0495*  
0445CC             0496*  @read_file:
0445CC             0497*  ; Read a block of data from a file
0445CC             0498*  ;   C: Filehandle
0445CC             0499*  ; HLU: Pointer to where to write the data to
0445CC             0500*  ; DEU: Number of bytes to read
0445CC             0501*  ; Returns:
0445CC             0502*  ; DEU: Number of bytes read
0445CC 3A 03 46 04 0503*      ld a,(@filehandle)
0445D0 4F          0504*      ld c,a
0445D1 21 00 E0 B7 0505*      ld hl,filedata
0445D5 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0445D9             0507*      MOSCALL mos_fread
0445D9 3E 1A       0001*M 			LD	A, function
0445DB 5B CF       0002*M 			RST.LIL	08h
0445DD             0508*  
0445DD             0509*  ; test de for zero bytes read
0445DD 21 00 00 00 0510*      ld hl,0
0445E1 AF          0511*      xor a ; clear carry
0445E2 ED 52       0512*      sbc hl,de
0445E4 CA FA 45 04 0513*      jp z,@close_file
0445E8             0514*  
0445E8             0515*  ; load a vdu buffer from local memory
0445E8             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0445E8 2A 1C 45 04 0517*      ld hl,(bufferId0)
0445EC D5          0518*      push de ; chunksize
0445ED C1          0519*      pop bc
0445EE 11 00 E0 B7 0520*      ld de,filedata
0445F2 CD 22 45 04 0521*      call vdu_load_buffer
0445F6             0522*  
0445F6             0523*  ; read the next block
0445F6 C3 CC 45 04 0524*      jp @read_file
0445FA             0525*  
0445FA             0526*  ; close the file
0445FA             0527*  @close_file:
0445FA 3A 03 46 04 0528*      ld a,(@filehandle)
0445FE             0529*      MOSCALL mos_fclose
0445FE 3E 0B       0001*M 			LD	A, function
044600 5B CF       0002*M 			RST.LIL	08h
044602 C9          0530*      ret ; vdu_load_buffer_from_file
044603             0531*  
044603 00          0532*  @filehandle: db 0 ; file handle
044604 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
044607             0534*  
044607 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
04460A             0536*  
04460A             0537*  ; File information structure (FILINFO)
04460A             0538*  @filinfo:
04460A 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04460E 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
044610 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
044612 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
044613 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
044620 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044720             0054       include "vdu_fonts.inc"
044720             0001*  ; select font
044720             0002*  ; inputs: hl = bufferId, a = font flags
044720             0003*  ; Flags:
044720             0004*  ; Bit	Description
044720             0005*  ; 0	Adjust cursor position to ensure text baseline is aligned
044720             0006*  ;   0: Do not adjust cursor position (best for changing font on a new line)
044720             0007*  ;   1: Adjust cursor position (best for changing font in the middle of a line)
044720             0008*  ; 1-7	Reserved for future use
044720             0009*  ; VDU 23, 0, &95, 0, bufferId; flags: Select font
044720             0010*  vdu_font_select:
044720 22 37 47 04 0011*      ld (@bufferId),hl
044724 32 39 47 04 0012*      ld (@flags),a
044728 21 33 47 04 0013*      ld hl,@cmd
04472C 01 07 00 00 0014*      ld bc,@end-@cmd
044730 5B DF       0015*      rst.lil $18
044732 C9          0016*      ret
044733 17 00 95 00 0017*  @cmd: db 23, 0, 0x95, 0
044737 00 00       0018*  @bufferId: dw 0x0000
044739 00          0019*  @flags: db 0x00
04473A             0020*  @end:
04473A             0021*  
04473A             0022*  ; create font from buffer
04473A             0023*  ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
04473A             0024*  ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
04473A             0025*  vdu_font_create:
04473A 22 5F 47 04 0026*      ld (@bufferId),hl
04473E ED 53 61 47 0027*      ld (@width),de ; also loads height
       04          
044743 32 64 47 04 0028*      ld (@flags),a
044747 7A          0029*      ld a,d ; height
044748 32 63 47 04 0030*      ld (@ascent),a ; ascent = height
04474C             0031*  ; consolidate buffer
04474C CD 7A 45 04 0032*      call vdu_consolidate_buffer
044750             0033*  ; create font
044750 21 5B 47 04 0034*      ld hl,@cmd
044754 01 0A 00 00 0035*      ld bc,@end-@cmd
044758 5B DF       0036*      rst.lil $18
04475A C9          0037*      ret
04475B 17 00 95 01 0038*  @cmd: db 23, 0, 0x95, 1
04475F 00 00       0039*  @bufferId: dw 0x0000
044761 00          0040*  @width: db 0x00
044762 00          0041*  @height: db 0x00
044763 00          0042*  @ascent: db 0x00
044764 00          0043*  @flags: db 0x00
044765             0044*  @end:
044765             0045*  
044765             0046*  ; set or adjust font property
044765             0047*  ; inputs: hl = bufferId, a = field, de = value
044765             0048*  ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
044765             0049*  vdu_font_property:
044765 22 81 47 04 0050*      ld (@bufferId),hl
044769 32 83 47 04 0051*      ld (@field),a
04476D ED 53 84 47 0052*      ld (@value),de
       04          
044772 21 7D 47 04 0053*      ld hl,@cmd
044776 01 09 00 00 0054*      ld bc,@end-@cmd
04477A 5B DF       0055*      rst.lil $18
04477C C9          0056*      ret
04477D 17 00 95 02 0057*  @cmd: db 23, 0, 0x95, 2
044781 00 00       0058*  @bufferId: dw 0x0000
044783 00          0059*  @field: db 0x00
044784 00 00       0060*  @value: dw 0x0000
044786 00          0061*  @end: db 0x00 ; padding
044787             0062*  
044787             0063*  ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
044787             0064*  
044787             0065*  ; Clear/Delete font
044787             0066*  ; inputs: hl = bufferId
044787             0067*  ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
044787             0068*  vdu_font_clear:
044787 22 9A 47 04 0069*      ld (@bufferId),hl
04478B 21 96 47 04 0070*      ld hl,@cmd
04478F 01 06 00 00 0071*      ld bc,@end-@cmd
044793 5B DF       0072*      rst.lil $18
044795 C9          0073*      ret
044796 17 00 95 04 0074*  @cmd: db 23, 0, 0x95, 4
04479A 00 00       0075*  @bufferId: dw 0x0000
04479C 00          0076*  @end: db 0x00 ; padding
04479D             0077*  
04479D             0078*  ; Copy system font to buffer
04479D             0079*  ; inputs: hl = bufferId
04479D             0080*  ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04479D             0081*  vdu_font_copy_system:
04479D 22 B0 47 04 0082*      ld (@bufferId),hl
0447A1 21 AC 47 04 0083*      ld hl,@cmd
0447A5 01 06 00 00 0084*      ld bc,@end-@cmd
0447A9 5B DF       0085*      rst.lil $18
0447AB C9          0086*      ret
0447AC 17 00 95 05 0087*  @cmd: db 23, 0, 0x95, 5
0447B0 00 00       0088*  @bufferId: dw 0x0000
0447B2 00          0089*  @end: db 0x00 ; padding
0447B3             0055       include "vdu_plot.inc"
0447B3             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0447B3             0002*  ; PLOT code 	(Decimal) 	Effect
0447B3             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0447B3             0004*  plot_sl_both: equ 0x00
0447B3             0005*  
0447B3             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0447B3             0007*  plot_sl_first: equ 0x08
0447B3             0008*  
0447B3             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0447B3             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0447B3             0011*  
0447B3             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0447B3             0013*  plot_sl_last: equ 0x20
0447B3             0014*  
0447B3             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0447B3             0016*  plot_sl_none: equ 0x28
0447B3             0017*  
0447B3             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0447B3             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0447B3             0020*  
0447B3             0021*  ; &40-&47 	64-71 	Point plot
0447B3             0022*  plot_pt: equ 0x40
0447B3             0023*  
0447B3             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0447B3             0025*  plot_lf_lr_non_bg: equ 0x48
0447B3             0026*  
0447B3             0027*  ; &50-&57 	80-87 	Triangle fill
0447B3             0028*  plot_tf: equ 0x50
0447B3             0029*  
0447B3             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0447B3             0031*  plot_lf_r_bg: equ 0x58
0447B3             0032*  
0447B3             0033*  ; &60-&67 	96-103 	Rectangle fill
0447B3             0034*  plot_rf: equ 0x60
0447B3             0035*  
0447B3             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0447B3             0037*  plot_lf_lr_fg: equ 0x60
0447B3             0038*  
0447B3             0039*  ; &70-&77 	112-119 	Parallelogram fill
0447B3             0040*  plot_pf: equ 0x70
0447B3             0041*  
0447B3             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0447B3             0043*  plot_lf_r_non_fg: equ 0x78
0447B3             0044*  
0447B3             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0447B3             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0447B3             0047*  
0447B3             0048*  ; &90-&97 	144-151 	Circle outline
0447B3             0049*  plot_co: equ 0x90
0447B3             0050*  
0447B3             0051*  ; &98-&9F 	152-159 	Circle fill
0447B3             0052*  plot_cf: equ 0x98
0447B3             0053*  
0447B3             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0447B3             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0447B3             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0447B3             0057*  
0447B3             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0447B3             0059*  plot_rcm: equ 0xB8
0447B3             0060*  
0447B3             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0447B3             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0447B3             0063*  ; &D0-&D7 	208-215 	Not defined
0447B3             0064*  ; &D8-&DF 	216-223 	Not defined
0447B3             0065*  ; &E0-&E7 	224-231 	Not defined
0447B3             0066*  
0447B3             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0447B3             0068*  plot_bmp: equ 0xE8
0447B3             0069*  
0447B3             0070*  ; &F0-&F7 	240-247 	Not defined
0447B3             0071*  ; &F8-&FF 	248-255 	Not defined
0447B3             0072*  
0447B3             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0447B3             0074*  ; Agon Console8 VDP 2.2.0
0447B3             0075*  
0447B3             0076*  ; Within each group of eight plot codes, the effects are as follows:
0447B3             0077*  ; Plot code 	Effect
0447B3             0078*  ; 0 	Move relative
0447B3             0079*  mv_rel: equ 0
0447B3             0080*  
0447B3             0081*  ; 1 	Plot relative in current foreground colour
0447B3             0082*  dr_rel_fg: equ 1
0447B3             0083*  
0447B3             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0447B3             0085*  ; 3 	Plot relative in current background colour
0447B3             0086*  dr_rel_bg: equ 3
0447B3             0087*  
0447B3             0088*  ; 4 	Move absolute
0447B3             0089*  mv_abs: equ 4
0447B3             0090*  
0447B3             0091*  ; 5 	Plot absolute in current foreground colour
0447B3             0092*  dr_abs_fg: equ 5
0447B3             0093*  
0447B3             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0447B3             0095*  ; 7 	Plot absolute in current background colour
0447B3             0096*  dr_abs_bg: equ 7
0447B3             0097*  
0447B3             0098*  ; Codes 0-3 use the position data provided as part of the command
0447B3             0099*  ; as a relative position, adding the position given to the current
0447B3             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0447B3             0101*  ; as part of the command as an absolute position, setting the current
0447B3             0102*  ; graphical cursor position to the position given.
0447B3             0103*  
0447B3             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0447B3             0105*  ; current pixel colour. These operations cannot currently be supported
0447B3             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0447B3             0107*  ; supported. Support for these codes may be added in a future version
0447B3             0108*  ; of the VDP firmware.
0447B3             0109*  
0447B3             0110*  ; 16 colour palette constants
0447B3             0111*  c_black: equ 0
0447B3             0112*  c_red_dk: equ 1
0447B3             0113*  c_green_dk: equ 2
0447B3             0114*  c_yellow_dk: equ 3
0447B3             0115*  c_blue_dk: equ 4
0447B3             0116*  c_magenta_dk: equ 5
0447B3             0117*  c_cyan_dk: equ 6
0447B3             0118*  c_grey: equ 7
0447B3             0119*  c_grey_dk: equ 8
0447B3             0120*  c_red: equ 9
0447B3             0121*  c_green: equ 10
0447B3             0122*  c_yellow: equ 11
0447B3             0123*  c_blue: equ 12
0447B3             0124*  c_magenta: equ 13
0447B3             0125*  c_cyan: equ 14
0447B3             0126*  c_white: equ 15
0447B3             0127*  
0447B3             0128*  ; VDU 25, mode, x; y;: PLOT command
0447B3             0129*  ; inputs: a=mode, bc=x0, de=y0
0447B3             0130*  vdu_plot:
0447B3 32 CD 47 04 0131*      ld (@mode),a
0447B7 ED 43 CE 47 0132*      ld (@x0),bc
       04          
0447BC ED 53 D0 47 0133*      ld (@y0),de
       04          
0447C1 21 CC 47 04 0134*  	ld hl,@cmd
0447C5 01 06 00 00 0135*  	ld bc,@end-@cmd
0447C9 5B DF       0136*  	rst.lil $18
0447CB C9          0137*  	ret
0447CC 19          0138*  @cmd:   db 25
0447CD 00          0139*  @mode:  db 0
0447CE 00 00       0140*  @x0: 	dw 0
0447D0 00 00       0141*  @y0: 	dw 0
0447D2 00          0142*  @end:   db 0 ; extra byte to soak up deu
0447D3             0143*  
0447D3             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0447D3             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
0447D3             0146*  ; VDU 25, mode, x; y;: PLOT command
0447D3             0147*  ; inputs: bc=x0, de=y0
0447D3             0148*  ; prerequisites: vdu_buff_select
0447D3             0149*  vdu_plot_bmp:
0447D3 ED 43 EA 47 0150*      ld (@x0),bc
       04          
0447D8 ED 53 EC 47 0151*      ld (@y0),de
       04          
0447DD 21 E8 47 04 0152*  	ld hl,@cmd
0447E1 01 06 00 00 0153*  	ld bc,@end-@cmd
0447E5 5B DF       0154*  	rst.lil $18
0447E7 C9          0155*  	ret
0447E8 19          0156*  @cmd:   db 25
0447E9 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0447EA 00 00       0158*  @x0: 	dw 0x0000
0447EC 00 00       0159*  @y0: 	dw 0x0000
0447EE 00          0160*  @end:   db 0x00 ; padding
0447EF             0161*  
0447EF             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0447EF             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
0447EF             0164*  ; VDU 25, mode, x; y;: PLOT command
0447EF             0165*  ; inputs: bc=x0, de=y0
0447EF             0166*  ; USING 16.8 FIXED POINT COORDINATES
0447EF             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0447EF             0168*  ;   the fractional portiion of the inputs are truncated
0447EF             0169*  ;   leaving only the 16-bit integer portion
0447EF             0170*  ; prerequisites: vdu_buff_select
0447EF             0171*  vdu_plot_bmp168:
0447EF             0172*  ; populate in the reverse of normal to keep the
0447EF             0173*  ; inputs from stomping on each other
0447EF ED 53 0D 48 0174*      ld (@y0-1),de
       04          
0447F4 ED 43 0B 48 0175*      ld (@x0-1),bc
       04          
0447F9 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0447FB 32 0B 48 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0447FF 21 0A 48 04 0178*  	ld hl,@cmd
044803 01 06 00 00 0179*  	ld bc,@end-@cmd
044807 5B DF       0180*  	rst.lil $18
044809 C9          0181*  	ret
04480A 19          0182*  @cmd:   db 25
04480B ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04480C 00 00       0184*  @x0: 	dw 0x0000
04480E 00 00       0185*  @y0: 	dw 0x0000
044810             0186*  @end:  ; no padding required b/c we shifted de right
044810             0187*  
044810             0188*  ; draw a filled rectangle
044810             0189*  vdu_plot_rf:
044810 ED 43 37 48 0190*      ld (@x0),bc
       04          
044815 ED 53 39 48 0191*      ld (@y0),de
       04          
04481A DD 22 3D 48 0192*      ld (@x1),ix
       04          
04481F FD 22 3F 48 0193*      ld (@y1),iy
       04          
044824 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
044826 32 3B 48 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04482A 21 35 48 04 0196*  	ld hl,@cmd0
04482E 01 0C 00 00 0197*  	ld bc,@end-@cmd0
044832 5B DF       0198*  	rst.lil $18
044834 C9          0199*      ret
044835 19          0200*  @cmd0:  db 25 ; plot
044836 04          0201*  @arg0:  db plot_sl_both+mv_abs
044837 00 00       0202*  @x0:    dw 0x0000
044839 00 00       0203*  @y0:    dw 0x0000
04483B 19          0204*  @cmd1:  db 25 ; plot
04483C 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04483D 00 00       0206*  @x1:    dw 0x0000
04483F 00 00       0207*  @y1:    dw 0x0000
044841 00          0208*  @end:   db 0x00 ; padding
044842             0209*  
044842             0210*  ; draw a filled circle
044842             0211*  vdu_plot_cf:
044842 ED 43 69 48 0212*      ld (@x0),bc
       04          
044847 ED 53 6B 48 0213*      ld (@y0),de
       04          
04484C DD 22 6F 48 0214*      ld (@x1),ix
       04          
044851 FD 22 71 48 0215*      ld (@y1),iy
       04          
044856 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
044858 32 6D 48 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04485C 21 67 48 04 0218*  	ld hl,@cmd0
044860 01 0C 00 00 0219*  	ld bc,@end-@cmd0
044864 5B DF       0220*  	rst.lil $18
044866 C9          0221*      ret
044867 19          0222*  @cmd0:  db 25 ; plot
044868 04          0223*  @arg0:  db plot_sl_both+mv_abs
044869 00 00       0224*  @x0:    dw 0x0000
04486B 00 00       0225*  @y0:    dw 0x0000
04486D 19          0226*  @cmd1:  db 25 ; plot
04486E 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
04486F 00 00       0228*  @x1:    dw 0x0000
044871 00 00       0229*  @y1:    dw 0x0000
044873 00          0230*  @end:   db 0x00 ; padding
044874             0056       include "vdu_sprites.inc"
044874             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
044874             0002*  ; the VDP can support up to 256 sprites. They must be defined
044874             0003*  ; contiguously, and so the first sprite is sprite 0.
044874             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
044874             0005*  ; Once a selection of sprites have been defined, you can activate
044874             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
044874             0007*  ; of sprites to activate. This will activate the first n sprites,
044874             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
044874             0009*  
044874             0010*  ; A single sprite can have multiple "frames", referring to
044874             0011*  ; different bitmaps.
044874             0012*  ; (These bitmaps do not need to be the same size.)
044874             0013*  ; This allows a sprite to include an animation sequence,
044874             0014*  ; which can be stepped through one frame at a time, or picked
044874             0015*  ; in any order.
044874             0016*  
044874             0017*  ; Any format of bitmap can be used as a sprite frame. It should
044874             0018*  ; be noted however that "native" format bitmaps are not
044874             0019*  ; recommended for use as sprite frames, as they cannot get
044874             0020*  ; erased from the screen. (As noted above, the "native" bitmap
044874             0021*  ; format is not really intended for general use.) This is part
044874             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
044874             0023*  ; screen are now stored in RGBA2222 format.
044874             0024*  
044874             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
044874             0026*  ; and then later shown again.
044874             0027*  
044874             0028*  ; Moving sprites around the screen is done by changing the
044874             0029*  ; position of the sprite. This can be done either by setting
044874             0030*  ; the absolute position of the sprite, or by moving the sprite
044874             0031*  ; by a given number of pixels. (Sprites are positioned using
044874             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
044874             0033*  ; In the current sprite system, sprites will not update their
044874             0034*  ; position on-screen until either another drawing operation is
044874             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
044874             0036*  
044874             0037*  ; VDU 23, 27, 4, n: Select sprite n
044874             0038*  ; inputs: a is the 8-bit sprite id
044874             0039*  vdu_sprite_select:
044874 32 86 48 04 0040*      ld (@sprite),a
044878 21 83 48 04 0041*      ld hl,@cmd
04487C 01 04 00 00 0042*      ld bc,@end-@cmd
044880 5B DF       0043*      rst.lil $18
044882 C9          0044*      ret
044883 17 1B 04    0045*  @cmd:    db 23,27,4
044886 00          0046*  @sprite: db 0x00
044887             0047*  @end:
044887             0048*  
044887             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
044887             0050*  ; inputs: none
044887             0051*  ; prerequisites: vdu_sprite_select
044887             0052*  vdu_sprite_clear_frames:
044887 21 92 48 04 0053*      ld hl,@cmd
04488B 01 03 00 00 0054*      ld bc,@end-@cmd
04488F 5B DF       0055*      rst.lil $18
044891 C9          0056*      ret
044892 17 1B 05    0057*  @cmd: db 23,27,5
044895             0058*  @end:
044895             0059*  
044895             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
044895             0061*  ; inputs: a is the 8-bit bitmap number
044895             0062*  ; prerequisites: vdu_sprite_select
044895             0063*  vdu_sprite_add_bmp:
044895 32 A7 48 04 0064*      ld (@bmp),a
044899 21 A4 48 04 0065*      ld hl,@cmd
04489D 01 04 00 00 0066*      ld bc,@end-@cmd
0448A1 5B DF       0067*      rst.lil $18
0448A3 C9          0068*      ret
0448A4 17 1B 06    0069*  @cmd: db 23,27,6
0448A7 00          0070*  @bmp: db 0x00
0448A8             0071*  @end:
0448A8             0072*  
0448A8             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0448A8             0074*  ; inputs: a is the number of sprites to activate
0448A8             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0448A8             0076*  vdu_sprite_activate:
0448A8 32 BA 48 04 0077*      ld (@num),a
0448AC 21 B7 48 04 0078*      ld hl,@cmd
0448B0 01 04 00 00 0079*      ld bc,@end-@cmd
0448B4 5B DF       0080*      rst.lil $18
0448B6 C9          0081*      ret
0448B7 17 1B 07    0082*  @cmd: db 23,27,7
0448BA 00          0083*  @num: db 0x00
0448BB             0084*  @end:
0448BB             0085*  
0448BB             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
0448BB             0087*  ; inputs: none
0448BB             0088*  ; prerequisites: vdu_sprite_select
0448BB             0089*  vdu_sprite_next_frame:
0448BB 21 C6 48 04 0090*      ld hl,@cmd
0448BF 01 03 00 00 0091*      ld bc,@end-@cmd
0448C3 5B DF       0092*      rst.lil $18
0448C5 C9          0093*      ret
0448C6 17 1B 08    0094*  @cmd: db 23,27,8
0448C9             0095*  @end:
0448C9             0096*  
0448C9             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
0448C9             0098*  ; inputs: none
0448C9             0099*  ; prerequisites: vdu_sprite_select
0448C9             0100*  vdu_sprite_prev_frame:
0448C9 21 D4 48 04 0101*      ld hl,@cmd
0448CD 01 03 00 00 0102*      ld bc,@end-@cmd
0448D1 5B DF       0103*      rst.lil $18
0448D3 C9          0104*      ret
0448D4 17 1B 09    0105*  @cmd: db 23,27,9
0448D7             0106*  @end:
0448D7             0107*  
0448D7             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0448D7             0109*  ; inputs: a is frame number to select
0448D7             0110*  ; prerequisites: vdu_sprite_select
0448D7             0111*  vdu_sprite_select_frame:
0448D7 32 E9 48 04 0112*      ld (@frame),a
0448DB 21 E6 48 04 0113*      ld hl,@cmd
0448DF 01 04 00 00 0114*      ld bc,@end-@cmd
0448E3 5B DF       0115*      rst.lil $18
0448E5 C9          0116*      ret
0448E6 17 1B 0A    0117*  @cmd:    db 23,27,10
0448E9 00          0118*  @frame:  db 0x00
0448EA             0119*  @end:
0448EA             0120*  
0448EA             0121*  ; VDU 23, 27, 11: Show current sprite
0448EA             0122*  ; inputs: none
0448EA             0123*  ; prerequisites: vdu_sprite_select
0448EA             0124*  vdu_sprite_show:
0448EA 21 F5 48 04 0125*      ld hl,@cmd
0448EE 01 03 00 00 0126*      ld bc,@end-@cmd
0448F2 5B DF       0127*      rst.lil $18
0448F4 C9          0128*      ret
0448F5 17 1B 0B    0129*  @cmd: db 23,27,11
0448F8             0130*  @end:
0448F8             0131*  
0448F8             0132*  ; VDU 23, 27, 12: Hide current sprite
0448F8             0133*  ; inputs: none
0448F8             0134*  ; prerequisites: vdu_sprite_select
0448F8             0135*  vdu_sprite_hide:
0448F8 21 03 49 04 0136*      ld hl,@cmd
0448FC 01 03 00 00 0137*      ld bc,@end-@cmd
044900 5B DF       0138*      rst.lil $18
044902 C9          0139*      ret
044903 17 1B 0C    0140*  @cmd: db 23,27,12
044906             0141*  @end:
044906             0142*  
044906             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044906             0144*  ; inputs: bc is x coordinate, de is y coordinate
044906             0145*  ; prerequisites: vdu_sprite_select
044906             0146*  vdu_sprite_move_abs:
044906 ED 43 1E 49 0147*      ld (@xpos),bc
       04          
04490B ED 53 20 49 0148*      ld (@ypos),de
       04          
044910 21 1B 49 04 0149*      ld hl,@cmd
044914 01 07 00 00 0150*      ld bc,@end-@cmd
044918 5B DF       0151*      rst.lil $18
04491A C9          0152*      ret
04491B 17 1B 0D    0153*  @cmd:  db 23,27,13
04491E 00 00       0154*  @xpos: dw 0x0000
044920 00 00       0155*  @ypos: dw 0x0000
044922 00          0156*  @end:  db 0x00 ; padding
044923             0157*  
044923             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
044923             0159*  ; inputs: bc is x coordinate, de is y coordinate
044923             0160*  ; prerequisites: vdu_sprite_select
044923             0161*  vdu_sprite_move_rel:
044923 ED 43 3B 49 0162*      ld (@dx),bc
       04          
044928 ED 53 3D 49 0163*      ld (@dy),de
       04          
04492D 21 38 49 04 0164*      ld hl,@cmd
044931 01 07 00 00 0165*      ld bc,@end-@cmd
044935 5B DF       0166*      rst.lil $18
044937 C9          0167*      ret
044938 17 1B 0E    0168*  @cmd: db 23,27,14
04493B 00 00       0169*  @dx:  dw 0x0000
04493D 00 00       0170*  @dy:  dw 0x0000
04493F 00          0171*  @end: db 0x00 ; padding
044940             0172*  
044940             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
044940             0174*  ; USING 16.8 FIXED POINT COORDINATES
044940             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
044940             0176*  ;   the fractional portiion of the inputs are truncated
044940             0177*  ;   leaving only the 16-bit integer portion
044940             0178*  ; prerequisites: vdu_sprite_select
044940             0179*  vdu_sprite_move_abs168:
044940             0180*  ; offset inputs by the gfx origin
044940             0181*  ; y coordinate
044940 21 00 00 00 0182*      ld hl,origin_top*256
044944 19          0183*      add hl,de
044945 22 67 49 04 0184*      ld (@ypos-1),hl
044949             0185*  ; x coordinate
044949 21 00 80 00 0186*      ld hl,origin_left*256
04494D 09          0187*      add hl,bc
04494E 22 65 49 04 0188*      ld (@xpos-1),hl
044952             0189*  ; prepare vdu command
044952 3E 0D       0190*      ld a,13       ; restore the final byte of the command
044954 32 65 49 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
044958 21 63 49 04 0192*      ld hl,@cmd
04495C 01 07 00 00 0193*      ld bc,@end-@cmd
044960 5B DF       0194*      rst.lil $18
044962 C9          0195*      ret
044963 17 1B 0D    0196*  @cmd:  db 23,27,13
044966 00 00       0197*  @xpos: dw 0x0000
044968 00 00       0198*  @ypos: dw 0x0000
04496A             0199*  @end:  ; no padding required b/c we shifted de right
04496A             0200*  
04496A             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04496A             0202*  ; USING 16.8 FIXED POINT COORDINATES
04496A             0203*  ; inputs: ub.c is dx, ud.e is dy
04496A             0204*  ;   the fractional portiion of the inputs are truncated
04496A             0205*  ;   leaving only the 16-bit integer portion
04496A             0206*  ; prerequisites: vdu_sprite_select
04496A             0207*  vdu_sprite_move_rel168:
04496A             0208*  ; populate in the reverse of normal to keep the
04496A             0209*  ; inputs from stomping on each other
04496A ED 53 89 49 0210*      ld (@dy-1),de
       04          
04496F ED 43 87 49 0211*      ld (@dx-1),bc
       04          
044974 3E 0E       0212*      ld a,14       ; restore the final byte of the command
044976 32 87 49 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
04497A 21 85 49 04 0214*      ld hl,@cmd
04497E 01 07 00 00 0215*      ld bc,@end-@cmd
044982 5B DF       0216*      rst.lil $18
044984 C9          0217*      ret
044985 17 1B 0E    0218*  @cmd:  db 23,27,14
044988 00 00       0219*  @dx: dw 0x0000
04498A 00 00       0220*  @dy: dw 0x0000
04498C             0221*  @end:  ; no padding required b/c we shifted de right
04498C             0222*  
04498C             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
04498C             0224*  ; inputs: none
04498C             0225*  vdu_sprite_update:
04498C 21 97 49 04 0226*      ld hl,@cmd
044990 01 03 00 00 0227*      ld bc,@end-@cmd
044994 5B DF       0228*      rst.lil $18
044996 C9          0229*      ret
044997 17 1B 0F    0230*  @cmd: db 23,27,15
04499A             0231*  @end:
04499A             0232*  
04499A             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
04499A             0234*  ; inputs: none
04499A             0235*  vdu_sprite_bmp_reset:
04499A 21 A5 49 04 0236*      ld hl,@cmd
04499E 01 03 00 00 0237*      ld bc,@end-@cmd
0449A2 5B DF       0238*      rst.lil $18
0449A4 C9          0239*      ret
0449A5 17 1B 10    0240*  @cmd: db 23,27,16
0449A8             0241*  @end:
0449A8             0242*  
0449A8             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0449A8             0244*  ; inputs: none
0449A8             0245*  vdu_sprite_reset:
0449A8 21 B3 49 04 0246*      ld hl,@cmd
0449AC 01 03 00 00 0247*      ld bc,@end-@cmd
0449B0 5B DF       0248*      rst.lil $18
0449B2 C9          0249*      ret
0449B3 17 1B 11    0250*  @cmd: db 23,27,17
0449B6             0251*  @end:
0449B6             0252*  
0449B6             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0449B6             0254*  ; inputs: a is the GCOL paint mode
0449B6             0255*  ; prerequisites: vdu_sprite_select
0449B6             0256*  vdu_sprite_set_gcol:
0449B6 32 C8 49 04 0257*      ld (@mode),a
0449BA 21 C5 49 04 0258*      ld hl,@cmd
0449BE 01 04 00 00 0259*      ld bc,@end-@cmd
0449C2 5B DF       0260*      rst.lil $18
0449C4 C9          0261*      ret
0449C5 17 1B 12    0262*  @cmd:  db 23,27,18
0449C8 00          0263*  @mode: db 0x00
0449C9             0264*  @end:
0449C9             0265*  
0449C9             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0449C9             0267*  ; inputs: hl=bufferId
0449C9             0268*  ; prerequisites: vdu_sprite_select
0449C9             0269*  vdu_sprite_add_buff:
0449C9 22 DB 49 04 0270*      ld (@bufferId),hl
0449CD 21 D8 49 04 0271*      ld hl,@cmd
0449D1 01 05 00 00 0272*      ld bc,@end-@cmd
0449D5 5B DF       0273*      rst.lil $18
0449D7 C9          0274*      ret
0449D8 17 1B 26    0275*  @cmd:      db 23,27,0x26
0449DB 00 00       0276*  @bufferId: dw 0x0000
0449DD 00          0277*  @end:      db 0x00 ; padding
0449DE             0057   
0449DE             0058   ; --- INITIALIZATION ---
0449DE             0059   init:
0449DE C9          0060       ret
0449DF             0061   
0449DF             0062   ; --- MAIN PROGRAM ---
0449DF             0063   main:
0449DF             0064   ; load fonts
0449DF             0065   	; call fonts_load
0449DF             0066       ; call printNewLine
0449DF 21 00 00 0B 0067       ld hl,0x0B0000 ; moslet
0449E3             0068       callHL
0449E3 01 E9 49 04 0001M      ld bc,@F ; Address of first instruction after the jump
0449E7 C5          0002M      push bc ; which constitutes the return address
0449E8 E9          0003M      jp (hl) ; Jump to the address in HL
0449E9             0004M  @@:
0449E9             0069   ; select font
0449E9 21 05 FA 00 0070       ld hl,computer_pixel_7_8x14+64000
0449ED 3E 01       0071       ld a,1 ; flags
0449EF CD 20 47 04 0072       call vdu_font_select
0449F3 C9          0073       ret
