PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C CD 00 1C 04 0015        call init
040050 CD 01 1C 04 0016        call main
040054             0017    
040054             0018    exit:
040054 FD E1       0019        pop iy
040056 DD E1       0020        pop ix
040058 D1          0021        pop de
040059 C1          0022        pop bc
04005A F1          0023        pop af
04005B 21 00 00 00 0024        ld hl,0
04005F             0025    
04005F C9          0026        ret
040060             0027    
040060             0028    ; API INCLUDES
040060             0029        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0030        include "functions.inc"
040060 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040100             0002*   
040100             0003*       MACRO printChar char
040100             0004*       LD A, char
040100             0005*       RST.LIL 10h
040100             0006*       ENDMACRO
040100             0007*   
040100             0008*   ; Simulated call to subroutine at HL
040100             0009*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040100             0010*   ; outputs: whatever the subroutine does, including HL and BC
040100             0011*   ; destroys: only what the subroutine does, but always BC
040100             0012*       MACRO callHL
040100             0013*       ld bc,@F ; Address of first instruction after the jump
040100             0014*       push bc ; which constitutes the return address
040100             0015*       jp (hl) ; Jump to the address in HL
040100             0016*   @@:
040100             0017*       ENDMACRO
040100             0018*   
040100             0019*   ; Simulated call to subroutine at IX
040100             0020*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040100             0021*   ; outputs: whatever the subroutine does, including IX and BC
040100             0022*   ; destroys: only what the subroutine does, but always BC
040100             0023*       MACRO callIX
040100             0024*       ld bc,@F ; Address of first instruction after the jump
040100             0025*       push bc ; which constitutes the return address
040100             0026*       jp (ix) ; Jump to the address in IX
040100             0027*   @@:
040100             0028*       ENDMACRO
040100             0029*   
040100             0030*   ; Simulated call to soubroutinte at IY
040100             0031*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040100             0032*   ; outputs: whatever the subroutine does, including IY and BC
040100             0033*   ; destroys: only what the subroutine does, but always BC
040100             0034*       MACRO callIY
040100             0035*       ld bc,@F ; Address of first instruction after the jump
040100             0036*       push bc ; which constitutes the return address
040100             0037*       jp (iy) ; Jump to the address in IY
040100             0038*   @@:
040100             0039*       ENDMACRO
040100             0040*   
040100             0041*   ; put the value in HLU into the accumulator
040100             0042*   ; destroys: af
040100             0043*       MACRO HLU_TO_A
040100             0044*       push hl ; 4 cycles
040100             0045*       inc sp ; 1 cycle
040100             0046*       pop af ; 4 cycles
040100             0047*       dec sp ; 1 cycle
040100             0048*       ; 10 cycles total
040100             0049*       ENDMACRO
040100             0050*   
040100             0051*   A_TO_HLU:
040100             0052*       ; call is 7 cycles
040100 22 0D 01 04 0053*       ld (@scratch),hl ; 7 cycles
040104 32 0F 01 04 0054*       ld (@scratch+2),a ; 5 cycles
040108 2A 0D 01 04 0055*       ld hl,(@scratch) ; 7 cycles
04010C C9          0056*       ret ; 6 cycles
04010D             0057*       ; 25 cycles total
04010D 00 00 00    0058*   @scratch: dl 0
040110             0059*   
040110             0060*       ; TODO: implement this
040110             0061*       ; MACRO A_TO_HLU
040110             0062*       ;     push.s af
040110             0063*       ;     inc sp
040110             0064*       ;     push.s hl
040110             0065*       ;     pop hl
040110             0066*       ;     inc sp
040110             0067*       ;     inc sp
040110             0068*       ; ENDMACRO
040110             0069*   
040110             0070*       MACRO PUSH_ALL
040110             0071*       ex af,af'
040110             0072*       exx
040110             0073*       push af
040110             0074*       push hl
040110             0075*       push bc
040110             0076*       push de
040110             0077*   
040110             0078*       ex af,af'
040110             0079*       exx
040110             0080*       push af
040110             0081*       push hl
040110             0082*       push bc
040110             0083*       push de
040110             0084*       push ix
040110             0085*       push iy
040110             0086*       ENDMACRO
040110             0087*   
040110             0088*       MACRO POP_ALL
040110             0089*       pop iy
040110             0090*       pop ix
040110             0091*       pop de
040110             0092*       pop bc
040110             0093*       pop hl
040110             0094*       pop af
040110             0095*       ex af,af'
040110             0096*       exx
040110             0097*   
040110             0098*       pop de
040110             0099*       pop bc
040110             0100*       pop hl
040110             0101*       pop af
040110             0102*       ex af,af'
040110             0103*       exx
040110             0104*       ENDMACRO
040110             0105*   
040110             0106*   ; Print a zero-terminated string inline with code, e.g.:
040110             0107*   ;
040110             0108*   ;    call printInline
040110             0109*   ;    ASCIZ "Hello, world!\r\n"
040110             0110*   ;
040110             0111*   ; Destroys: HL,AF
040110             0112*   printInline:
040110 E1          0113*       pop hl ; get the return address = pointer to start of string
040111 CD 17 01 04 0114*       call printString ; HL advances to end of string
040115 E5          0115*       push hl ; restore the return address = pointer to end of string
040116 C9          0116*       ret
040117             0117*   
040117             0118*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040117             0119*   ; Print a zero-terminated string
040117             0120*   ; HL: Pointer to string
040117             0121*   printString:
040117 C5          0122*       PUSH BC
040118 01 00 00 00 0123*       LD BC,0
04011C 3E 00       0124*       LD A,0
04011E 5B DF       0125*       RST.LIL 18h
040120 C1          0126*       POP BC
040121 C9          0127*       RET
040122             0128*   ; print a VDU sequence
040122             0129*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040122             0130*   sendVDUsequence:
040122 C5          0131*       PUSH BC
040123 01 00 00 00 0132*       LD BC, 0
040127 4E          0133*       LD C, (HL)
040128 5B DF       0134*       RST.LIL 18h
04012A C1          0135*       POP BC
04012B C9          0136*       RET
04012C             0137*   ; Print Newline sequence to VDP
04012C             0138*   ; destroys bc
04012C             0139*   printNewLine:
04012C F5          0140*       push af ; for some reason rst.lil 10h sets carry flag
04012D 3E 0D       0141*       LD A, '\r'
04012F 5B D7       0142*       RST.LIL 10h
040131 3E 0A       0143*       LD A, '\n'
040133 5B D7       0144*       RST.LIL 10h
040135 F1          0145*       pop af
040136 C9          0146*       RET
040137             0147*   
040137             0148*   ; Print a 24-bit HEX number
040137             0149*   ; HLU: Number to print
040137             0150*   printHex24:
040137             0151*       HLU_TO_A
040137 E5          0001*M1     push hl ; 4 cycles
040138 33          0002*M1     inc sp ; 1 cycle
040139 F1          0003*M1     pop af ; 4 cycles
04013A 3B          0004*M1     dec sp ; 1 cycle
04013B             0005*M1     ; 10 cycles total
04013B CD 45 01 04 0152*       CALL printHex8
04013F             0153*   ; Print a 16-bit HEX number
04013F             0154*   ; HL: Number to print
04013F             0155*   printHex16:
04013F 7C          0156*       LD A,H
040140 CD 45 01 04 0157*       CALL printHex8
040144 7D          0158*       LD A,L
040145             0159*   ; Print an 8-bit HEX number
040145             0160*   ; A: Number to print
040145             0161*   printHex8:
040145 4F          0162*       LD C,A
040146 1F          0163*       RRA
040147 1F          0164*       RRA
040148 1F          0165*       RRA
040149 1F          0166*       RRA
04014A CD 4F 01 04 0167*       CALL @F
04014E 79          0168*       LD A,C
04014F             0169*   @@:
04014F E6 0F       0170*       AND 0Fh
040151 C6 90       0171*       ADD A,90h
040153 27          0172*       DAA
040154 CE 40       0173*       ADC A,40h
040156 27          0174*       DAA
040157 5B D7       0175*       RST.LIL 10h
040159 C9          0176*       RET
04015A             0177*   
04015A             0178*   printHexA:
04015A F5          0179*       push af
04015B C5          0180*       push bc
04015C CD 45 01 04 0181*       call printHex8
040160 3E 20       0182*       ld a,' '
040162 5B D7       0183*       rst.lil 10h
040164 C1          0184*       pop bc
040165 F1          0185*       pop af
040166 C9          0186*       ret
040167             0187*   
040167             0188*   printHexHL:
040167 F5          0189*       push af
040168 C5          0190*       push bc
040169 CD 3F 01 04 0191*       call printHex16
04016D 3E 20       0192*       ld a,' '
04016F 5B D7       0193*       rst.lil 10h
040171 C1          0194*       pop bc
040172 F1          0195*       pop af
040173 C9          0196*       ret
040174             0197*   
040174             0198*   printHexUHL:
040174 F5          0199*       push af
040175 C5          0200*       push bc
040176 CD 37 01 04 0201*       call printHex24
04017A 3E 20       0202*       ld a,' '
04017C 5B D7       0203*       rst.lil 10h
04017E C1          0204*       pop bc
04017F F1          0205*       pop af
040180 C9          0206*       ret
040181             0207*   
040181             0208*   printHexAUHL:
040181 F5          0209*       push af
040182 C5          0210*       push bc
040183 CD 45 01 04 0211*       call printHex8
040187 3E 2E       0212*       ld a,'.'
040189 5B D7       0213*       rst.lil 10h
04018B CD 37 01 04 0214*       call printHex24
04018F 3E 20       0215*       ld a,' '
040191 5B D7       0216*       rst.lil 10h
040193 C1          0217*       pop bc
040194 F1          0218*       pop af
040195 C9          0219*       ret
040196             0220*   
040196             0221*   printHexABHL:
040196             0222*   ; preserve registers
040196 C5          0223*       push bc ; b will be ok c will not
040197 F5          0224*       push af ; will get totally destroyed
040198             0225*   ; print a
040198 CD 45 01 04 0226*       call printHex8
04019C             0227*   ; print b
04019C 78          0228*       ld a,b
04019D CD 45 01 04 0229*       call printHex8
0401A1             0230*   ; print hl
0401A1 CD 3F 01 04 0231*       call printHex16
0401A5             0232*   ; restore registers
0401A5 F1          0233*       pop af
0401A6 C1          0234*       pop bc
0401A7 C9          0235*       ret
0401A8             0236*   
0401A8             0237*   printHexBHL:
0401A8             0238*   ; preserve registers
0401A8 C5          0239*       push bc ; b will be ok c will not
0401A9 F5          0240*       push af ; will get totally destroyed
0401AA             0241*   ; print b
0401AA 78          0242*       ld a,b
0401AB CD 45 01 04 0243*       call printHex8
0401AF             0244*   ; print hl
0401AF CD 3F 01 04 0245*       call printHex16
0401B3             0246*   ; restore registers
0401B3 F1          0247*       pop af
0401B4 C1          0248*       pop bc
0401B5 C9          0249*       ret
0401B6             0250*   
0401B6             0251*   printHexCDE:
0401B6             0252*   ; preserve registers
0401B6 C5          0253*       push bc ; b will be ok c will not
0401B7 F5          0254*       push af ; will get totally destroyed
0401B8             0255*   ; print c
0401B8 79          0256*       ld a,c
0401B9 CD 45 01 04 0257*       call printHex8
0401BD             0258*   ; print de
0401BD EB          0259*       ex de,hl
0401BE CD 3F 01 04 0260*       call printHex16
0401C2 EB          0261*       ex de,hl
0401C3             0262*   ; restore registers
0401C3 F1          0263*       pop af
0401C4 C1          0264*       pop bc
0401C5 C9          0265*       ret
0401C6             0266*   
0401C6             0267*   printHexUIX:
0401C6             0268*   ; store everything in scratch
0401C6 22 4F 06 04 0269*       ld (uhl),hl
0401CA ED 43 52 06 0270*       ld (ubc),bc
       04          
0401CF ED 53 55 06 0271*       ld (ude),de
       04          
0401D4 DD 22 58 06 0272*       ld (uix),ix
       04          
0401D9 FD 22 5B 06 0273*       ld (uiy),iy
       04          
0401DE F5          0274*       push af ; fml
0401DF             0275*   
0401DF 21 E6 05 04 0276*       ld hl,str_ixu
0401E3 CD 17 01 04 0277*       call printString
0401E7 2A 58 06 04 0278*       ld hl,(uix)
0401EB CD 37 01 04 0279*       call printHex24
0401EF CD 2C 01 04 0280*       call printNewLine
0401F3             0281*   
0401F3             0282*   ; restore everything
0401F3 2A 4F 06 04 0283*       ld hl, (uhl)
0401F7 ED 4B 52 06 0284*       ld bc, (ubc)
       04          
0401FC ED 5B 55 06 0285*       ld de, (ude)
       04          
040201 DD 2A 58 06 0286*       ld ix, (uix)
       04          
040206 FD 2A 5B 06 0287*       ld iy, (uiy)
       04          
04020B F1          0288*       pop af
04020C             0289*   ; all done
04020C C9          0290*       ret
04020D             0291*   
04020D             0292*   ; Print a 0x HEX prefix
04020D             0293*   DisplayHexPrefix:
04020D 3E 30       0294*       LD A, '0'
04020F 5B D7       0295*       RST.LIL 10h
040211 3E 78       0296*       LD A, 'x'
040213 5B D7       0297*       RST.LIL 10h
040215 C9          0298*       RET
040216             0299*   
040216             0300*       MACRO printDecBC
040216             0301*       push hl
040216             0302*       push bc
040216             0303*       pop hl
040216             0304*       call printDec
040216             0305*       pop hl
040216             0306*       ENDMACRO
040216             0307*   
040216             0308*       MACRO printDecDE
040216             0309*       push hl
040216             0310*       push de
040216             0311*       pop hl
040216             0312*       call printDec
040216             0313*       pop hl
040216             0314*       ENDMACRO
040216             0315*   
040216             0316*       MACRO printDecHL
040216             0317*       call printDec
040216             0318*       ENDMACRO
040216             0319*   
040216             0320*       MACRO printDecIX
040216             0321*       push hl
040216             0322*       push ix
040216             0323*       pop hl
040216             0324*       call printDec
040216             0325*       pop hl
040216             0326*       ENDMACRO
040216             0327*   
040216             0328*       MACRO printDecIY
040216             0329*       push hl
040216             0330*       push iy
040216             0331*       pop hl
040216             0332*       call printDec
040216             0333*       pop hl
040216             0334*       ENDMACRO
040216             0335*   
040216             0336*   
040216             0337*   ; Prints the right justified decimal value in HL without leading zeroes
040216             0338*   ; HL : Value to print
040216             0339*   ; preserves all registers and flags
040216             0340*   printDec:
040216             0341*   ; BEGIN MY CODE
040216             0342*   ; back up all the things
040216 F5          0343*       push af
040217 C5          0344*       push bc
040218 D5          0345*       push de
040219 E5          0346*       push hl
04021A             0347*   ; END MY CODE
04021A 11 42 02 04 0348*       LD DE, _printDecBuffer
04021E CD 52 02 04 0349*       CALL u24_to_ascii
040222             0350*   ; BEGIN MY CODE
040222             0351*   ; replace leading zeroes with spaces
040222 21 42 02 04 0352*       LD HL, _printDecBuffer
040226 06 07       0353*       ld B, 7 ; if HL was 0, we want to keep the final zero
040228             0354*   @loop:
040228 7E          0355*       LD A, (HL)
040229 FE 30       0356*       CP '0'
04022B C2 35 02 04 0357*       JP NZ, @done
04022F 3E 20       0358*       LD A, ' '
040231 77          0359*       LD (HL), A
040232 23          0360*       INC HL
040233             0361*       ; CALL vdu_cursor_forward
040233 10 F3       0362*       DJNZ @loop
040235             0363*   @done:
040235             0364*   ; END MY CODE
040235 21 42 02 04 0365*       LD HL, _printDecBuffer
040239 CD 17 01 04 0366*       CALL printString
04023D             0367*   ; BEGIN MY CODE
04023D             0368*   ; restore all the things
04023D E1          0369*       pop hl
04023E D1          0370*       pop de
04023F C1          0371*       pop bc
040240 F1          0372*       pop af
040241             0373*   ; END MY CODE
040241 C9          0374*       RET
040242 00 00 00 00 0375*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040252             0376*   
040252             0377*   ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040252             0378*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040252             0379*   ; so it will allways be 8 characters length
040252             0380*   ; HL : Value to convert to string
040252             0381*   ; DE : pointer to buffer, at least 8 byte + 0
040252             0382*   u24_to_ascii:
040252 01 80 69 67 0383*       LD BC,-10000000
040256 CD 89 02 04 0384*       CALL @one_digit
04025A 01 C0 BD F0 0385*       LD BC,-1000000
04025E CD 89 02 04 0386*       CALL @one_digit
040262 01 60 79 FE 0387*       LD BC,-100000
040266 CD 89 02 04 0388*       CALL @one_digit
04026A 01 F0 D8 FF 0389*       LD BC,-10000
04026E CD 89 02 04 0390*       CALL @one_digit
040272 01 18 FC FF 0391*       LD BC,-1000
040276 CD 89 02 04 0392*       CALL @one_digit
04027A 01 9C FF FF 0393*       LD BC,-100
04027E CD 89 02 04 0394*       CALL @one_digit
040282 0E F6       0395*       LD C,-10
040284 CD 89 02 04 0396*       CALL @one_digit
040288 48          0397*       LD C,B
040289             0398*   @one_digit:
040289 3E 2F       0399*       LD A,'0'-1
04028B             0400*   @divide_me:
04028B 3C          0401*       INC A
04028C 09          0402*       ADD HL,BC
04028D 38 FC       0403*       JR C,@divide_me
04028F ED 42       0404*       SBC HL,BC
040291 12          0405*       LD (DE),A
040292 13          0406*       INC DE
040293 C9          0407*       RET
040294             0408*   
040294             0409*   print_u24:
040294 D5          0410*       push de
040295 E5          0411*       push hl
040296 11 42 02 04 0412*       ld de,_printDecBuffer
04029A CD 52 02 04 0413*       call u24_to_ascii
04029E 21 42 02 04 0414*       ld hl,_printDecBuffer
0402A2 CD 17 01 04 0415*       call printString
0402A6 3E 20       0416*       ld a,' '
0402A8 5B D7       0417*       rst.lil 10h
0402AA E1          0418*       pop hl
0402AB D1          0419*       pop de
0402AC C9          0420*       ret
0402AD             0421*   
0402AD             0422*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0402AD             0423*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0402AD             0424*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0402AD             0425*   u168_to_ascii:
0402AD             0426*   ; add a leading space to make room for sign flag if needed
0402AD 3E 20       0427*       ld a,' '
0402AF 12          0428*       ld (de),a
0402B0 13          0429*       inc de
0402B1             0430*   ; Convert integer part
0402B1 E5          0431*       push hl ; Save HL (we’ll need the fractional part later)
0402B2 CD 6D 09 04 0432*       call hlu_udiv256 ; Shift to get integer portion in HL
0402B6 01 F0 D8 FF 0433*       ld bc, -10000
0402BA CD DD 02 04 0434*       call @one_int
0402BE 01 18 FC FF 0435*       ld bc, -1000
0402C2 CD DD 02 04 0436*       call @one_int
0402C6 01 9C FF FF 0437*       ld bc, -100
0402CA CD DD 02 04 0438*       call @one_int
0402CE 0E F6       0439*       ld c, -10
0402D0 CD DD 02 04 0440*       call @one_int
0402D4 48          0441*       ld c, b
0402D5 CD DD 02 04 0442*       call @one_int
0402D9 C3 E8 02 04 0443*       jp @frac ; Jump to fractional part conversion
0402DD             0444*   @one_int:
0402DD 3E 2F       0445*       ld a, '0' - 1 ; Start ASCII character at '0'
0402DF             0446*   @divide_me:
0402DF 3C          0447*       inc a
0402E0 09          0448*       add hl, bc ; Accumulate until overflow
0402E1 38 FC       0449*       jr c, @divide_me
0402E3 ED 42       0450*       sbc hl, bc ; Remove excess after overflow
0402E5 12          0451*       ld (de), a ; Store ASCII digit
0402E6 13          0452*       inc de
0402E7 C9          0453*       ret
0402E8             0454*   ; Convert fractional part
0402E8             0455*   @frac:
0402E8 3E 2E       0456*       ld a, '.' ; Decimal point
0402EA 12          0457*       ld (de), a
0402EB 13          0458*       inc de
0402EC E1          0459*       pop hl ; Restore HL with original fraction
0402ED 06 03       0460*       ld b, 3 ; Loop counter for 3 fractional digits
0402EF             0461*   @frac_loop:
0402EF 26 0A       0462*       ld h, 10 ; Load multiplier for fractional part
0402F1 ED 6C       0463*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0402F3 3E 30       0464*       ld a, '0'
0402F5 84          0465*       add a, h ; Convert integer part to ASCII
0402F6 12          0466*       ld (de), a
0402F7 13          0467*       inc de
0402F8 10 F5       0468*       djnz @frac_loop ; Repeat for each fractional digit
0402FA             0469*   ; Add null terminator
0402FA AF          0470*       xor a ; Null terminator
0402FB 12          0471*       ld (de), a
0402FC C9          0472*       ret
0402FD             0473*   
0402FD             0474*   print_u168:
0402FD D5          0475*       push de
0402FE E5          0476*       push hl
0402FF 11 42 02 04 0477*       ld de,_printDecBuffer
040303 CD AD 02 04 0478*       call u168_to_ascii
040307 21 42 02 04 0479*       ld hl,_printDecBuffer
04030B CD 17 01 04 0480*       call printString
04030F E1          0481*       pop hl
040310 D1          0482*       pop de
040311 C9          0483*       ret
040312             0484*   
040312             0485*   ; signed version of u168_to_ascii
040312             0486*   s168_to_ascii:
040312 D5          0487*       push de ; save starting address of buffer
040313 CD 06 09 04 0488*       call hlu_abs
040317 F5          0489*       push af ; save sign flag
040318 CD AD 02 04 0490*       call u168_to_ascii
04031C F1          0491*       pop af ; restore sign flag
04031D D1          0492*       pop de ; restore starting address of buffer
04031E F0          0493*       ret p ; hlu was positive so nothing to do
04031F 3E 2D       0494*       ld a,'-'
040321 12          0495*       ld (de),a
040322 C9          0496*       ret
040323             0497*   
040323             0498*   print_s168:
040323 D5          0499*       push de
040324 E5          0500*       push hl
040325 11 42 02 04 0501*       ld de,_printDecBuffer
040329 CD 12 03 04 0502*       call s168_to_ascii
04032D 21 42 02 04 0503*       ld hl,_printDecBuffer
040331 CD 17 01 04 0504*       call printString
040335 E1          0505*       pop hl
040336 D1          0506*       pop de
040337 C9          0507*       ret
040338             0508*   
040338             0509*   print_s168_hl:
040338 F5          0510*       push af
040339 E5          0511*       push hl
04033A CD 23 03 04 0512*       call print_s168
04033E 3E 20       0513*       ld a,' '
040340 5B D7       0514*       rst.lil 10h
040342 E1          0515*       pop hl
040343 F1          0516*       pop af
040344 C9          0517*       ret
040345             0518*   
040345             0519*   print_s168_bc:
040345 F5          0520*       push af
040346 C5          0521*       push bc
040347 E5          0522*       push hl
040348 C5          0523*       push bc
040349 E1          0524*       pop hl
04034A CD 23 03 04 0525*       call print_s168
04034E 3E 20       0526*       ld a,' '
040350 5B D7       0527*       rst.lil 10h
040352 E1          0528*       pop hl
040353 C1          0529*       pop bc
040354 F1          0530*       pop af
040355 C9          0531*       ret
040356             0532*   
040356             0533*   print_s168_de:
040356 F5          0534*       push af
040357 D5          0535*       push de
040358 E5          0536*       push hl
040359 EB          0537*       ex de,hl
04035A CD 23 03 04 0538*       call print_s168
04035E 3E 20       0539*       ld a,' '
040360 5B D7       0540*       rst.lil 10h
040362 E1          0541*       pop hl
040363 D1          0542*       pop de
040364 F1          0543*       pop af
040365 C9          0544*       ret
040366             0545*   
040366             0546*   print_s168_hl_bc_de:
040366 F5          0547*       push af
040367 C5          0548*       push bc
040368 D5          0549*       push de
040369 E5          0550*       push hl
04036A CD 23 03 04 0551*       call print_s168
04036E 3E 20       0552*       ld a,' '
040370 5B D7       0553*       rst.lil 10h
040372 C5          0554*       push bc
040373 E1          0555*       pop hl
040374 CD 23 03 04 0556*       call print_s168
040378 3E 20       0557*       ld a,' '
04037A 5B D7       0558*       rst.lil 10h
04037C EB          0559*       ex de,hl
04037D CD 23 03 04 0560*       call print_s168
040381 3E 20       0561*       ld a,' '
040383 5B D7       0562*       rst.lil 10h
040385 E1          0563*       pop hl
040386 D1          0564*       pop de
040387 C1          0565*       pop bc
040388 F1          0566*       pop af
040389 C9          0567*       ret
04038A             0568*   
04038A             0569*   print_s168_bc_de:
04038A F5          0570*       push af
04038B C5          0571*       push bc
04038C D5          0572*       push de
04038D C5          0573*       push bc
04038E E1          0574*       pop hl
04038F CD 23 03 04 0575*       call print_s168
040393 3E 20       0576*       ld a,' '
040395 5B D7       0577*       rst.lil 10h
040397 EB          0578*       ex de,hl
040398 CD 23 03 04 0579*       call print_s168
04039C 3E 20       0580*       ld a,' '
04039E 5B D7       0581*       rst.lil 10h
0403A0 E1          0582*       pop hl
0403A1 D1          0583*       pop de
0403A2 C1          0584*       pop bc
0403A3 F1          0585*       pop af
0403A4 C9          0586*       ret
0403A5             0587*   
0403A5             0588*   print_s168_a:
0403A5 F5          0589*       push af
0403A6 C5          0590*       push bc
0403A7 E5          0591*       push hl
0403A8 21 00 00 00 0592*       ld hl,0
0403AC 6F          0593*       ld l,a
0403AD CD 38 03 04 0594*       call print_s168_hl
0403B1 E1          0595*       pop hl
0403B2 C1          0596*       pop bc
0403B3 F1          0597*       pop af
0403B4 C9          0598*       ret
0403B5             0599*   
0403B5             0600*   ; #### new functions added by Brandon R. Gates ####
0403B5             0601*   
0403B5             0602*   ; print the binary representation of the 8-bit value in a
0403B5             0603*   ; destroys a, hl, bc
0403B5             0604*   printBin8:
0403B5 06 08       0605*       ld b,8 ; loop counter for 8 bits
0403B7 21 D2 03 04 0606*       ld hl,@cmd ; set hl to the low byte of the output string
0403BB             0607*       ; (which will be the high bit of the value in a)
0403BB             0608*   @loop:
0403BB 07          0609*       rlca ; put the next highest bit into carry
0403BC 38 04       0610*       jr c,@one
0403BE 36 30       0611*       ld (hl),'0'
0403C0 18 02       0612*       jr @next_bit
0403C2             0613*   @one:
0403C2 36 31       0614*       ld (hl),'1'
0403C4             0615*   @next_bit:
0403C4 23          0616*       inc hl
0403C5 10 F4       0617*       djnz @loop
0403C7             0618*   ; print it
0403C7 21 D2 03 04 0619*       ld hl,@cmd
0403CB 01 08 00 00 0620*       ld bc,@end-@cmd
0403CF 5B DF       0621*       rst.lil $18
0403D1 C9          0622*       ret
0403D2             0623*   @cmd: ds 8 ; eight bytes for eight bits
0403DA             0624*   @end:
0403DA             0625*   
0403DA             0626*   ; print the binary representation of the 8-bit value in a
0403DA             0627*   ; in reverse order (lsb first)
0403DA             0628*   ; destroys a, hl, bc
0403DA             0629*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
0403DA 06 08       0630*       ld b,8 ; loop counter for 8 bits
0403DC 21 F7 03 04 0631*       ld hl,@cmd ; set hl to the low byte of the output string
0403E0             0632*       ; (which will be the high bit of the value in a)
0403E0             0633*   @loop:
0403E0 0F          0634*       rrca ; put the next lowest bit into carry
0403E1 38 04       0635*       jr c,@one
0403E3 36 30       0636*       ld (hl),'0'
0403E5 18 02       0637*       jr @next_bit
0403E7             0638*   @one:
0403E7 36 31       0639*       ld (hl),'1'
0403E9             0640*   @next_bit:
0403E9 23          0641*       inc hl
0403EA 10 F4       0642*       djnz @loop
0403EC             0643*   ; print it
0403EC 21 F7 03 04 0644*       ld hl,@cmd
0403F0 01 08 00 00 0645*       ld bc,@end-@cmd
0403F4 5B DF       0646*       rst.lil $18
0403F6 C9          0647*       ret
0403F7             0648*   @cmd: ds 8 ; eight bytes for eight bits
0403FF             0649*   @end:
0403FF             0650*   
0403FF             0651*   ; print registers to screen in hexidecimal format
0403FF             0652*   ; inputs: none
0403FF             0653*   ; outputs: values of every register printed to screen
0403FF             0654*   ;    values of each register in global scratch memory
0403FF             0655*   ; destroys: nothing
0403FF             0656*   stepRegistersHex:
0403FF             0657*   ; store everything in scratch
       FF FF FF FF 
       FF FF FF FF 
0403FF 22 4F 06 04 0658*       ld (uhl),hl
040403 ED 43 52 06 0659*       ld (ubc),bc
       04          
040408 ED 53 55 06 0660*       ld (ude),de
       04          
04040D DD 22 58 06 0661*       ld (uix),ix
       04          
040412 FD 22 5B 06 0662*       ld (uiy),iy
       04          
040417 F5          0663*       push af ; fml
040418 E1          0664*       pop hl ; thanks, zilog
040419 22 4C 06 04 0665*       ld (uaf),hl
04041D F5          0666*       push af ; dammit
04041E             0667*   
04041E             0668*   ; home the cursor
04041E             0669*       ; call vdu_home_cursor
04041E             0670*   
04041E             0671*   ; print each register
04041E 21 D2 05 04 0672*       ld hl,str_afu
040422 CD 17 01 04 0673*       call printString
040426 2A 4C 06 04 0674*       ld hl,(uaf)
04042A CD 37 01 04 0675*       call printHex24
04042E CD 2C 01 04 0676*       call printNewLine
040432             0677*   
040432 21 D7 05 04 0678*       ld hl,str_hlu
040436 CD 17 01 04 0679*       call printString
04043A 2A 4F 06 04 0680*       ld hl,(uhl)
04043E CD 37 01 04 0681*       call printHex24
040442 CD 2C 01 04 0682*       call printNewLine
040446             0683*   
040446 21 DC 05 04 0684*       ld hl,str_bcu
04044A CD 17 01 04 0685*       call printString
04044E 2A 52 06 04 0686*       ld hl,(ubc)
040452 CD 37 01 04 0687*       call printHex24
040456 CD 2C 01 04 0688*       call printNewLine
04045A             0689*   
04045A 21 E1 05 04 0690*       ld hl,str_deu
04045E CD 17 01 04 0691*       call printString
040462 2A 55 06 04 0692*       ld hl,(ude)
040466 CD 37 01 04 0693*       call printHex24
04046A CD 2C 01 04 0694*       call printNewLine
04046E             0695*   
04046E 21 E6 05 04 0696*       ld hl,str_ixu
040472 CD 17 01 04 0697*       call printString
040476 2A 58 06 04 0698*       ld hl,(uix)
04047A CD 37 01 04 0699*       call printHex24
04047E CD 2C 01 04 0700*       call printNewLine
040482             0701*   
040482 21 EB 05 04 0702*       ld hl,str_iyu
040486 CD 17 01 04 0703*       call printString
04048A 2A 5B 06 04 0704*       ld hl,(uiy)
04048E CD 37 01 04 0705*       call printHex24
040492 CD 2C 01 04 0706*       call printNewLine
040496             0707*   
040496             0708*       ; call vsync
040496             0709*   
040496 CD 2C 01 04 0710*       call printNewLine
04049A             0711*   
04049A             0712*   ; check for right shift key and quit if pressed
04049A             0713*       MOSCALL mos_getkbmap
04049A 3E 1E       0001*M1 			LD	A, function
04049C 5B CF       0002*M1 			RST.LIL	08h
04049E             0714*   @stayhere:
04049E             0715*   ; 7 RightShift
04049E DD CB 00 76 0716*       bit 6,(ix+0)
0404A2 20 02       0717*       jr nz,@RightShift
0404A4 18 F8       0718*       jr @stayhere
0404A6             0719*   @RightShift:
0404A6 DD CB 0E 86 0720*       res 0,(ix+14) ; debounce the key (hopefully)
0404AA 3E 80       0721*       ld a,%10000000
0404AC             0722*       ; call multiPurposeDelay
0404AC             0723*   
0404AC             0724*   ; restore everything
0404AC 2A 4F 06 04 0725*       ld hl, (uhl)
0404B0 ED 4B 52 06 0726*       ld bc, (ubc)
       04          
0404B5 ED 5B 55 06 0727*       ld de, (ude)
       04          
0404BA DD 2A 58 06 0728*       ld ix, (uix)
       04          
0404BF FD 2A 5B 06 0729*       ld iy, (uiy)
       04          
0404C4 F1          0730*       pop af
0404C5             0731*   ; all done
0404C5 C9          0732*       ret
0404C6             0733*   
0404C6             0734*   ; print registers to screen in hexidecimal format
0404C6             0735*   ; inputs: none
0404C6             0736*   ; outputs: values of every register printed to screen
0404C6             0737*   ;    values of each register in global scratch memory
0404C6             0738*   ; destroys: nothing
0404C6             0739*   dumpRegistersHex:
0404C6             0740*   ; store everything in scratch
0404C6 22 4F 06 04 0741*       ld (uhl),hl
0404CA ED 43 52 06 0742*       ld (ubc),bc
       04          
0404CF ED 53 55 06 0743*       ld (ude),de
       04          
0404D4 DD 22 58 06 0744*       ld (uix),ix
       04          
0404D9 FD 22 5B 06 0745*       ld (uiy),iy
       04          
0404DE F5          0746*       push af ; fml
0404DF E1          0747*       pop hl ; thanks, zilog
0404E0 22 4C 06 04 0748*       ld (uaf),hl
0404E4 F5          0749*       push af ; dammit
0404E5             0750*   
0404E5             0751*   ; home the cursor
0404E5             0752*       ; call vdu_home_cursor
0404E5             0753*       ; call printNewLine
0404E5             0754*   
0404E5             0755*   ; print each register
0404E5 21 D2 05 04 0756*       ld hl,str_afu
0404E9 CD 17 01 04 0757*       call printString
0404ED 2A 4C 06 04 0758*       ld hl,(uaf)
0404F1 CD 37 01 04 0759*       call printHex24
0404F5 CD 2C 01 04 0760*       call printNewLine
0404F9             0761*   
0404F9 21 D7 05 04 0762*       ld hl,str_hlu
0404FD CD 17 01 04 0763*       call printString
040501 2A 4F 06 04 0764*       ld hl,(uhl)
040505 CD 37 01 04 0765*       call printHex24
040509 CD 2C 01 04 0766*       call printNewLine
04050D             0767*   
04050D 21 DC 05 04 0768*       ld hl,str_bcu
040511 CD 17 01 04 0769*       call printString
040515 2A 52 06 04 0770*       ld hl,(ubc)
040519 CD 37 01 04 0771*       call printHex24
04051D CD 2C 01 04 0772*       call printNewLine
040521             0773*   
040521 21 E1 05 04 0774*       ld hl,str_deu
040525 CD 17 01 04 0775*       call printString
040529 2A 55 06 04 0776*       ld hl,(ude)
04052D CD 37 01 04 0777*       call printHex24
040531 CD 2C 01 04 0778*       call printNewLine
040535             0779*   
040535 21 E6 05 04 0780*       ld hl,str_ixu
040539 CD 17 01 04 0781*       call printString
04053D 2A 58 06 04 0782*       ld hl,(uix)
040541 CD 37 01 04 0783*       call printHex24
040545 CD 2C 01 04 0784*       call printNewLine
040549             0785*   
040549 21 EB 05 04 0786*       ld hl,str_iyu
04054D CD 17 01 04 0787*       call printString
040551 2A 5B 06 04 0788*       ld hl,(uiy)
040555 CD 37 01 04 0789*       call printHex24
040559             0790*       ; call printNewLine
040559             0791*   
040559             0792*       ; call vdu_vblank
040559             0793*   
040559             0794*       ; call printNewLine
040559             0795*   ; restore everything
040559 2A 4F 06 04 0796*       ld hl, (uhl)
04055D ED 4B 52 06 0797*       ld bc, (ubc)
       04          
040562 ED 5B 55 06 0798*       ld de, (ude)
       04          
040567 DD 2A 58 06 0799*       ld ix, (uix)
       04          
04056C FD 2A 5B 06 0800*       ld iy, (uiy)
       04          
040571 F1          0801*       pop af
040572             0802*   ; all done
040572 C9          0803*       ret
040573             0804*   
040573             0805*   dumpRegistersHexPrime:
040573 D9          0806*       exx
040574 08          0807*       ex af,af'
040575 CD C6 04 04 0808*       call dumpRegistersHex
040579 08          0809*       ex af,af'
04057A D9          0810*       exx
04057B C9          0811*       ret
04057C             0812*   
04057C             0813*   ; additionally dump prime registers
04057C             0814*   ; inputs: none
04057C             0815*   ; outputs: values of every register printed to screen
04057C             0816*   ; destroys: nothing
04057C             0817*   dumpRegistersHexAll:
04057C CD C6 04 04 0818*       call dumpRegistersHex
040580 08          0819*       ex af,af'
040581 D9          0820*       exx
040582 CD C6 04 04 0821*       call dumpRegistersHex
040586 08          0822*       ex af,af'
040587 D9          0823*       exx
040588 C9          0824*       ret
040589             0825*   
040589             0826*   ; print hlu to screen in hexidecimal format
040589             0827*   ; inputs: none
040589             0828*   ; destroys: nothing
040589             0829*   print_hex_hl:
040589 F5          0830*       push af
04058A E5          0831*       push hl
04058B 21 D7 05 04 0832*       ld hl,str_hlu
04058F CD 17 01 04 0833*       call printString
040593 E1          0834*       pop hl
040594 E5          0835*       push hl
040595 CD 37 01 04 0836*       call printHex24
040599 3E 20       0837*       ld a,' '
04059B 5B D7       0838*       rst.lil 10h
04059D E1          0839*       pop hl
04059E F1          0840*       pop af
04059F C9          0841*       ret
0405A0             0842*   
0405A0             0843*   ; print bcu to screen in hexidecimal format
0405A0             0844*   ; inputs: none
0405A0             0845*   ; destroys: nothing
0405A0             0846*   print_hex_bc:
0405A0 F5          0847*       push af
0405A1 E5          0848*       push hl
0405A2 C5          0849*       push bc
0405A3 21 DC 05 04 0850*       ld hl,str_bcu
0405A7 CD 17 01 04 0851*       call printString
0405AB E1          0852*       pop hl
0405AC E5          0853*       push hl
0405AD CD 37 01 04 0854*       call printHex24
0405B1 3E 20       0855*       ld a,' '
0405B3 5B D7       0856*       rst.lil 10h
0405B5 C1          0857*       pop bc
0405B6 E1          0858*       pop hl
0405B7 F1          0859*       pop af
0405B8 C9          0860*       ret
0405B9             0861*   
0405B9             0862*   ; print deu to screen in hexidecimal format
0405B9             0863*   ; inputs: none
0405B9             0864*   ; destroys: nothing
0405B9             0865*   print_hex_de:
0405B9 F5          0866*       push af
0405BA E5          0867*       push hl
0405BB D5          0868*       push de
0405BC 21 E1 05 04 0869*       ld hl,str_deu
0405C0 CD 17 01 04 0870*       call printString
0405C4 E1          0871*       pop hl
0405C5 E5          0872*       push hl
0405C6 CD 37 01 04 0873*       call printHex24
0405CA 3E 20       0874*       ld a,' '
0405CC 5B D7       0875*       rst.lil 10h
0405CE D1          0876*       pop de
0405CF E1          0877*       pop hl
0405D0 F1          0878*       pop af
0405D1 C9          0879*       ret
0405D2             0880*   
0405D2 20 61 66 3D 0881*   str_afu: db " af=",0
       00          
0405D7 20 68 6C 3D 0882*   str_hlu: db " hl=",0
       00          
0405DC 20 62 63 3D 0883*   str_bcu: db " bc=",0
       00          
0405E1 20 64 65 3D 0884*   str_deu: db " de=",0
       00          
0405E6 20 69 78 3D 0885*   str_ixu: db " ix=",0
       00          
0405EB 20 69 79 3D 0886*   str_iyu: db " iy=",0
       00          
0405F0             0887*   
0405F0             0888*   ; print udeuhl to screen in hexidecimal format
0405F0             0889*   ; inputs: none
0405F0             0890*   ; outputs: concatenated hexidecimal udeuhl
0405F0             0891*   ; destroys: nothing
0405F0             0892*   dumpUDEUHLHex:
0405F0             0893*   ; store everything in scratch
0405F0 22 4F 06 04 0894*       ld (uhl),hl
0405F4 ED 43 52 06 0895*       ld (ubc),bc
       04          
0405F9 ED 53 55 06 0896*       ld (ude),de
       04          
0405FE DD 22 58 06 0897*       ld (uix),ix
       04          
040603 FD 22 5B 06 0898*       ld (uiy),iy
       04          
040608 F5          0899*       push af
040609             0900*   
040609             0901*   ; print each register
040609             0902*   
040609 21 43 06 04 0903*       ld hl,str_udeuhl
04060D CD 17 01 04 0904*       call printString
040611 2A 55 06 04 0905*       ld hl,(ude)
040615 CD 37 01 04 0906*       call printHex24
040619 3E 2E       0907*       ld a,'.' ; print a dot to separate the values
04061B 5B D7       0908*       rst.lil 10h
04061D 2A 4F 06 04 0909*       ld hl,(uhl)
040621 CD 37 01 04 0910*       call printHex24
040625 CD 2C 01 04 0911*       call printNewLine
040629             0912*   
040629             0913*   ; restore everything
040629 2A 4F 06 04 0914*       ld hl, (uhl)
04062D ED 4B 52 06 0915*       ld bc, (ubc)
       04          
040632 ED 5B 55 06 0916*       ld de, (ude)
       04          
040637 DD 2A 58 06 0917*       ld ix, (uix)
       04          
04063C FD 2A 5B 06 0918*       ld iy, (uiy)
       04          
040641 F1          0919*       pop af
040642             0920*   ; all done
040642 C9          0921*       ret
040643             0922*   
040643 75 64 65 2E 0923*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04064C             0924*   
04064C             0925*   ; global scratch memory for registers
04064C 00 00 00    0926*   uaf: dl 0
04064F 00 00 00    0927*   uhl: dl 0
040652 00 00 00    0928*   ubc: dl 0
040655 00 00 00    0929*   ude: dl 0
040658 00 00 00    0930*   uix: dl 0
04065B 00 00 00    0931*   uiy: dl 0
04065E 00 00 00    0932*   usp: dl 0
040661 00 00 00    0933*   upc: dl 0
040664             0934*   
040664             0935*   ; inputs: whatever is in the flags register
040664             0936*   ; outputs: binary representation of flags
040664             0937*   ;          with a header so we know which is what
040664             0938*   ; destroys: nothing
040664             0939*   ; preserves: everything
040664             0940*   dumpFlags:
040664             0941*   ; first we curse zilog for not giving direct access to flags
040664 F5          0942*       push af ; this is so we can send it back unharmed
040665 F5          0943*       push af ; this is so we can pop it to hl
040666             0944*   ; store everything in scratch
040666 22 4F 06 04 0945*       ld (uhl),hl
04066A ED 43 52 06 0946*       ld (ubc),bc
       04          
04066F ED 53 55 06 0947*       ld (ude),de
       04          
040674 DD 22 58 06 0948*       ld (uix),ix
       04          
040679 FD 22 5B 06 0949*       ld (uiy),iy
       04          
04067E             0950*   ; next we print the header
04067E 21 AA 06 04 0951*       ld hl,@header
040682 CD 17 01 04 0952*       call printString
040686 E1          0953*       pop hl ; flags are now in l
040687 7D          0954*       ld a,l ; flags are now in a
040688 CD B5 03 04 0955*       call printBin8
04068C CD 2C 01 04 0956*       call printNewLine
040690             0957*   ; restore everything
040690 2A 4F 06 04 0958*       ld hl, (uhl)
040694 ED 4B 52 06 0959*       ld bc, (ubc)
       04          
040699 ED 5B 55 06 0960*       ld de, (ude)
       04          
04069E DD 2A 58 06 0961*       ld ix, (uix)
       04          
0406A3 FD 2A 5B 06 0962*       ld iy, (uiy)
       04          
0406A8 F1          0963*       pop af ; send her home the way she came
0406A9 C9          0964*       ret
0406AA             0965*   ; Bit 7 (S): Sign flag
0406AA             0966*   ; Bit 6 (Z): Zero flag
0406AA             0967*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0406AA             0968*   ; Bit 4 (H): Half Carry flag
0406AA             0969*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0406AA             0970*   ; Bit 2 (PV): Parity/Overflow flag
0406AA             0971*   ; Bit 1 (N): Subtract flag
0406AA             0972*   ; Bit 0 (C): Carry flag
0406AA 53 5A 78 48 0973*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0406B5             0974*   
0406B5             0975*   ; set all the bits in the flag register
0406B5             0976*   ; more of an academic exercise than anything useful
0406B5             0977*   ; inputs; none
0406B5             0978*   ; outputs; a=0,f=255
0406B5             0979*   ; destroys: flags, hl
0406B5             0980*   ; preserves: a, because why not
0406B5             0981*   setAllFlags:
0406B5 21 FF 00 00 0982*       ld hl,255
0406B9 67          0983*       ld h,a ; four cycles to preserve a is cheap
0406BA E5          0984*       push hl
0406BB F1          0985*       pop af
0406BC C9          0986*       ret
0406BD             0987*   
0406BD             0988*   ; reset all the bits in the flag register
0406BD             0989*   ; unlike its inverse counterpart, this may actually be useful
0406BD             0990*   ; inputs; none
0406BD             0991*   ; outputs; a=0,f=0
0406BD             0992*   ; destroys: flags, hl
0406BD             0993*   ; preserves: a, because why not
0406BD             0994*   resetAllFlags:
0406BD 21 00 00 00 0995*       ld hl,0
0406C1 67          0996*       ld h,a ; four cycles to preserve a is cheap
0406C2 E5          0997*       push hl
0406C3 F1          0998*       pop af
0406C4 C9          0999*       ret
0406C5             1000*   
0406C5             1001*   ; wait until user presses a key
0406C5             1002*   ; inputs: none
0406C5             1003*   ; outputs: ascii code of key pressed in a
0406C5             1004*   ; destroys: af,ix
0406C5             1005*   waitKeypress:
0406C5             1006*       MOSCALL mos_getkey
0406C5 3E 00       0001*M1 			LD	A, function
0406C7 5B CF       0002*M1 			RST.LIL	08h
0406C9 C9          1007*       ret
0406CA             1008*   
0406CA             1009*   ; print bytes from an address to the screen in hexidecimal format
0406CA             1010*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0406CA             1011*   ; outputs: values of each byte printed to screen separated by spaces
0406CA             1012*   ; destroys: nothing
0406CA             1013*   dumpMemoryHex:
0406CA             1014*   ; save registers to the stack
0406CA C5          1015*       push bc
0406CB E5          1016*       push hl
0406CC F5          1017*       push af
0406CD             1018*   
0406CD             1019*   ; print the address and separator
0406CD CD 37 01 04 1020*       call printHex24
0406D1 3E 3A       1021*       ld a,':'
0406D3 5B D7       1022*       rst.lil 10h
0406D5 3E 20       1023*       ld a,' '
0406D7 5B D7       1024*       rst.lil 10h
0406D9             1025*   
0406D9             1026*   ; set b to be our loop counter
0406D9 F1          1027*       pop af
0406DA 47          1028*       ld b,a
0406DB E1          1029*       pop hl
0406DC E5          1030*       push hl
0406DD F5          1031*       push af
0406DE             1032*   @loop:
0406DE             1033*   ; print the byte
0406DE 7E          1034*       ld a,(hl)
0406DF CD 45 01 04 1035*       call printHex8
0406E3             1036*   ; print a space
0406E3 3E 20       1037*       ld a,' '
0406E5 5B D7       1038*       rst.lil 10h
0406E7 23          1039*       inc hl
0406E8 10 F4       1040*       djnz @loop
0406EA CD 2C 01 04 1041*       call printNewLine
0406EE             1042*   
0406EE             1043*   ; restore everything
0406EE F1          1044*       pop af
0406EF E1          1045*       pop hl
0406F0 C1          1046*       pop bc
0406F1             1047*   
0406F1             1048*   ; all done
0406F1 C9          1049*       ret
0406F2             1050*   
0406F2             1051*   
0406F2             1052*   ; print bytes from an address to the screen in binary format
0406F2             1053*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0406F2             1054*   ; outputs: values of each byte printed to screen separated by spaces
0406F2             1055*   ; destroys: nothing
0406F2             1056*   dumpMemoryBin:
0406F2             1057*   ; save all registers to the stack
0406F2 F5          1058*       push af
0406F3 C5          1059*       push bc
0406F4 D5          1060*       push de
0406F5 E5          1061*       push hl
0406F6 DD E5       1062*       push ix
0406F8 FD E5       1063*       push iy
0406FA             1064*   
0406FA             1065*   ; set b to be our loop counter
0406FA 47          1066*       ld b,a
0406FB             1067*   @loop:
0406FB             1068*   ; print the byte
0406FB 7E          1069*       ld a,(hl)
0406FC E5          1070*       push hl
0406FD C5          1071*       push bc
0406FE CD B5 03 04 1072*       call printBin8
040702 C1          1073*       pop bc
040703             1074*   ; print a space
040703 3E 20       1075*       ld a,' '
040705 5B D7       1076*       rst.lil 10h
040707 E1          1077*       pop hl
040708 23          1078*       inc hl
040709 10 F0       1079*       djnz @loop
04070B CD 2C 01 04 1080*       call printNewLine
04070F             1081*   
04070F             1082*   ; restore everything
04070F FD E1       1083*       pop iy
040711 DD E1       1084*       pop ix
040713 E1          1085*       pop hl
040714 D1          1086*       pop de
040715 C1          1087*       pop bc
040716 F1          1088*       pop af
040717             1089*   ; all done
040717 C9          1090*       ret
040718             1091*   
040718             1092*   ; print bytes from an address to the screen in binary format
040718             1093*   ; with the bits of each byte in reverse order (lsb first)
040718             1094*   ; inputs: hl = address of first byte to print, a = number of bytes to print
040718             1095*   ; outputs: values of each byte printed to screen separated by spaces
040718             1096*   ; destroys: nothing
040718             1097*   dumpMemoryBinRev:
040718             1098*   ; save all registers to the stack
040718 F5          1099*       push af
040719 C5          1100*       push bc
04071A D5          1101*       push de
04071B E5          1102*       push hl
04071C DD E5       1103*       push ix
04071E FD E5       1104*       push iy
040720             1105*   
040720             1106*   ; set b to be our loop counter
040720 47          1107*       ld b,a
040721             1108*   @loop:
040721             1109*   ; print the byte
040721 7E          1110*       ld a,(hl)
040722 E5          1111*       push hl
040723 C5          1112*       push bc
040724 CD DA 03 04 1113*       call printBin8Rev
040728 C1          1114*       pop bc
040729             1115*   ; print a space
040729 3E 20       1116*       ld a,' '
04072B 5B D7       1117*       rst.lil 10h
04072D E1          1118*       pop hl
04072E 23          1119*       inc hl
04072F 10 F0       1120*       djnz @loop
040731 CD 2C 01 04 1121*       call printNewLine
040735             1122*   
040735             1123*   ; restore everything
040735 FD E1       1124*       pop iy
040737 DD E1       1125*       pop ix
040739 E1          1126*       pop hl
04073A D1          1127*       pop de
04073B C1          1128*       pop bc
04073C F1          1129*       pop af
04073D             1130*   ; all done
04073D C9          1131*       ret
04073E             0031        include "arith24.inc"
04073E             0001*   ;------------------------------------------------------------------------
04073E             0002*   ;  arith24.asm
04073E             0003*   ;  24-bit ez80 arithmetic routines
04073E             0004*   ;  Copyright (c) Shawn Sijnstra 2024
04073E             0005*   ;  MIT license
04073E             0006*   ;
04073E             0007*   ;  This library was created as a tool to help make ez80
04073E             0008*   ;  24-bit native assembly routines for simple mathematical problems
04073E             0009*   ;  more widely available.
04073E             0010*   ;
04073E             0011*   ;------------------------------------------------------------------------
04073E             0012*   
04073E             0013*   ; ;------------------------------------------------------------------------
04073E             0014*   ; ; DEPRECATED BY umul24 in fixed168.inc
04073E             0015*   ; ;------------------------------------------------------------------------
04073E             0016*   ; ; umul24:	HL = HL*DE (unsigned)
04073E             0017*   ; ; Preserves AF, BC, DE
04073E             0018*   ; ; Uses a fast multiply routine.
04073E             0019*   ; ;------------------------------------------------------------------------
04073E             0020*   ; umul24:
04073E             0021*   ; 	push	DE
04073E             0022*   ; 	push	BC
04073E             0023*   ; 	push	AF
04073E             0024*   ; 	push	HL
04073E             0025*   ; 	pop		BC
04073E             0026*   ;     ld	 	a, 24 ; No. of bits to process
04073E             0027*   ;     ld	 	hl, 0 ; Result
04073E             0028*   ; umul24_lp:
04073E             0029*   ; 	add	hl,hl
04073E             0030*   ; 	ex	de,hl
04073E             0031*   ; 	add	hl,hl
04073E             0032*   ; 	ex	de,hl
04073E             0033*   ; 	jr	nc,umul24_nc
04073E             0034*   ; 	add	hl,bc
04073E             0035*   ; umul24_nc:
04073E             0036*   ; 	dec	a
04073E             0037*   ; 	jr	nz,umul24_lp
04073E             0038*   ; 	pop	af
04073E             0039*   ; 	pop	bc
04073E             0040*   ; 	pop	de
04073E             0041*   ; 	ret
04073E             0042*   
04073E             0043*   
04073E             0044*   ;------------------------------------------------------------------------
04073E             0045*   ; udiv24
04073E             0046*   ; Unsigned 24-bit division
04073E             0047*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04073E             0048*   ;
04073E             0049*   ; Uses AF BC DE HL
04073E             0050*   ; Uses Restoring Division algorithm
04073E             0051*   ;------------------------------------------------------------------------
04073E             0052*   
04073E             0053*   udiv24:
04073E E5          0054*   	push	hl
04073F C1          0055*   	pop		bc	;move dividend to BCU
040740 21 00 00 00 0056*   	ld		hl,0	;result
040744 A7          0057*   	and		a
040745 ED 52       0058*   	sbc		hl,de	;test for div by 0
040747 C8          0059*   	ret		z		;it's zero, carry flag is clear
040748 19          0060*   	add		hl,de	;HL is 0 again
040749 3E 18       0061*   	ld		a,24	;number of loops through.
04074B             0062*   udiv1:
04074B C5          0063*   	push	bc	;complicated way of doing this because of lack of access to top bits
04074C E3          0064*   	ex		(sp),hl
04074D 37          0065*   	scf
04074E ED 6A       0066*   	adc	hl,hl
040750 E3          0067*   	ex	(sp),hl
040751 C1          0068*   	pop	bc		;we now have bc = (bc * 2) + 1
040752             0069*   
040752 ED 6A       0070*   	adc	hl,hl
040754 A7          0071*   	and	a		;is this the bug
040755 ED 52       0072*   	sbc	hl,de
040757 30 02       0073*   	jr	nc,udiv2
040759 19          0074*   	add	hl,de
04075A             0075*   ;	dec	c
04075A 0B          0076*   	dec	bc
04075B             0077*   udiv2:
04075B 3D          0078*   	dec	a
04075C 20 ED       0079*   	jr	nz,udiv1
04075E 37          0080*   	scf		;flag used for div0 error
04075F C5          0081*   	push	bc
040760 D1          0082*   	pop		de	;remainder
040761 C9          0083*   	ret
040762             0084*   
040762             0085*   
040762             0086*   
040762             0087*   ;------------------------------------------------------------------------
040762             0088*   ; neg24
040762             0089*   ; Returns: HLU = 0-HLU
040762             0090*   ; preserves all other registers
040762             0091*   ;------------------------------------------------------------------------
040762             0092*   neg24:
040762 D5          0093*   	push	de
040763 EB          0094*   	ex		de,hl
040764 21 00 00 00 0095*   	ld		hl,0
040768 B7          0096*   	or		a
040769 ED 52       0097*   	sbc		hl,de
04076B D1          0098*   	pop		de
04076C C9          0099*   	ret
04076D             0100*   
04076D             0101*   ;------------------------------------------------------------------------
04076D             0102*   ; or_hlu_deu: 24 bit bitwise OR
04076D             0103*   ; Returns: hlu = hlu OR deu
04076D             0104*   ; preserves all other registers
04076D             0105*   ;------------------------------------------------------------------------
04076D             0106*   or_hlu_deu:
04076D 22 F6 07 04 0107*   	ld	(bitbuf1),hl
040771 ED 53 F9 07 0108*   	ld	(bitbuf2),de
       04          
040776 D5          0109*   	push	de	;preserve DEU
040777 C5          0110*   	push	bc	;preserve BCU
040778 06 03       0111*   	ld		b,3
04077A 21 F6 07 04 0112*   	ld	hl,bitbuf1
04077E 11 F6 07 04 0113*   	ld	de,bitbuf1
040782             0114*   orloop_24:
040782 1A          0115*   	ld	a,(de)
040783 B6          0116*   	or	(hl)
040784 12          0117*   	ld	(de),a
040785 13          0118*   	inc	de
040786 23          0119*   	inc	hl
040787 10 F9       0120*   	djnz	orloop_24
040789 2A F9 07 04 0121*   	ld	hl,(bitbuf2)
04078D C1          0122*   	pop		bc	;restore BC
04078E D1          0123*   	pop		de	;restore DE
04078F             0124*   
04078F             0125*   ;------------------------------------------------------------------------
04078F             0126*   ; and_hlu_deu: 24 bit bitwise AND
04078F             0127*   ; Returns: hlu = hlu AND deu
04078F             0128*   ; preserves all other registers
04078F             0129*   ;------------------------------------------------------------------------
04078F             0130*   and_hlu_deu:
04078F 22 F6 07 04 0131*   	ld	(bitbuf1),hl
040793 ED 53 F9 07 0132*   	ld	(bitbuf2),de
       04          
040798 D5          0133*   	push	de	;preserve DEU
040799 C5          0134*   	push	bc	;preserve BCU
04079A 06 03       0135*   	ld		b,3
04079C 21 F6 07 04 0136*   	ld	hl,bitbuf1
0407A0 11 F6 07 04 0137*   	ld	de,bitbuf1
0407A4             0138*   andloop_24:
0407A4 1A          0139*   	ld	a,(de)
0407A5 A6          0140*   	and	(hl)
0407A6 12          0141*   	ld	(de),a
0407A7 13          0142*   	inc	de
0407A8 23          0143*   	inc	hl
0407A9 10 F9       0144*   	djnz	andloop_24
0407AB 2A F9 07 04 0145*   	ld	hl,(bitbuf2)
0407AF C1          0146*   	pop		bc	;restore BC
0407B0 D1          0147*   	pop		de	;restore DE
0407B1             0148*   
0407B1             0149*   ;------------------------------------------------------------------------
0407B1             0150*   ; xor_hlu_deu: 24 bit bitwise XOR
0407B1             0151*   ; Returns: hlu = hlu XOR deu
0407B1             0152*   ; preserves all other registers
0407B1             0153*   ;------------------------------------------------------------------------
0407B1             0154*   xor_hlu_deu:
0407B1 22 F6 07 04 0155*   	ld	(bitbuf1),hl
0407B5 ED 53 F9 07 0156*   	ld	(bitbuf2),de
       04          
0407BA D5          0157*   	push	de	;preserve DEU
0407BB C5          0158*   	push	bc	;preserve BCU
0407BC 06 03       0159*   	ld		b,3
0407BE 21 F6 07 04 0160*   	ld	hl,bitbuf1
0407C2 11 F6 07 04 0161*   	ld	de,bitbuf1
0407C6             0162*   xorloop_24:
0407C6 1A          0163*   	ld	a,(de)
0407C7 AE          0164*   	xor	(hl)
0407C8 12          0165*   	ld	(de),a
0407C9 13          0166*   	inc	de
0407CA 23          0167*   	inc	hl
0407CB 10 F9       0168*   	djnz	xorloop_24
0407CD 2A F9 07 04 0169*   	ld	hl,(bitbuf2)
0407D1 C1          0170*   	pop		bc	;restore BC
0407D2 D1          0171*   	pop		de	;restore DE
0407D3             0172*   
0407D3             0173*   ;------------------------------------------------------------------------
0407D3             0174*   ; shl_hlu: 24 bit shift left hlu by a positions
0407D3             0175*   ; Returns: hlu = hlu << a
0407D3             0176*   ;		   a = 0
0407D3             0177*   ; NOTE: only considers a up to 16 bits.
0407D3             0178*   ; preserves all other registers
0407D3             0179*   ; modified by Brandon R. Gates to use a instead of de
0407D3             0180*   ;------------------------------------------------------------------------
0407D3             0181*   shl_hlu:
0407D3 B7          0182*   	or a
0407D4 C8          0183*   	ret		z		;we're done
0407D5 29          0184*   	add		hl,hl	;shift HLU left
0407D6 3D          0185*   	dec a
0407D7 18 FA       0186*   	jr		shl_hlu
0407D9             0187*   
0407D9             0188*   ;------------------------------------------------------------------------
0407D9             0189*   ; shr_hlu: 24 bit shift right hlu by a positions
0407D9             0190*   ; Returns: hlu = hlu >> a
0407D9             0191*   ;		   a = 0
0407D9             0192*   ; NOTE: only considers a up to 16 bits.
0407D9             0193*   ; preserves all other registers
0407D9             0194*   ; modified by Brandon R. Gates to use a instead of de
0407D9             0195*   ;------------------------------------------------------------------------
0407D9             0196*   shr_hlu:
0407D9 22 F6 07 04 0197*   	ld		(bitbuf1),hl
0407DD 21 F8 07 04 0198*   	ld		hl,bitbuf1+2
0407E1             0199*   @shr_loop:
0407E1 B7          0200*   	or a
0407E2 28 0D       0201*   	jr		z,@shr_done		;we're done
0407E4             0202*   ;carry is clear from or instruction
0407E4 CB 1E       0203*   	rr		(hl)
0407E6 2B          0204*   	dec		hl
0407E7 CB 1E       0205*   	rr		(hl)
0407E9 2B          0206*   	dec		hl
0407EA CB 1E       0207*   	rr		(hl)
0407EC 23          0208*   	inc		hl
0407ED 23          0209*   	inc		hl
0407EE 3D          0210*   	dec a
0407EF 18 F0       0211*   	jr		@shr_loop
0407F1             0212*   @shr_done:
0407F1 2A F6 07 04 0213*   	ld		hl,(bitbuf1)	;collect result
0407F5 C9          0214*   	ret
0407F6             0215*   
0407F6             0216*   ;------------------------------------------------------------------------
0407F6             0217*   ; Scratch area for calculations
0407F6             0218*   ;------------------------------------------------------------------------
0407F6 00 00 00    0219*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0407F9 00 00 00    0220*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0407FC             0221*   
0407FC             0222*   ; -----------------------------------------------------------------------
0407FC             0223*   ; Functions added by Brandon R. Gates
0407FC             0224*   ; -----------------------------------------------------------------------
0407FC             0225*   
0407FC             0226*   ;------------------------------------------------------------------------
0407FC             0227*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
0407FC             0228*   ;              Determines the LSB of A and shifts HLU accordingly.
0407FC             0229*   ;              HLU = HLU >> LSB(A)
0407FC             0230*   ; Returns: HLU = HLU >> LSB(A)
0407FC             0231*   ; Destroys: af
0407FC             0232*   ;------------------------------------------------------------------------
0407FC             0233*   shr_hlu_log2a:
0407FC B7          0234*   	or a    ; check for zero
0407FD C8          0235*   	ret z   ; nothing to shift so we're done
0407FE C5          0236*   	push 	bc ; preserve
0407FF 06 00       0237*   	ld		b,0 ; clear b
040801             0238*   @find_bit:
040801 0F          0239*   	rrca ; bit 0 to carry
040802 DA 0B 08 04 0240*   	jp c,@found_bit
040806 04          0241*   	inc b ; next bit
040807 C3 01 08 04 0242*   	jp @find_bit
04080B             0243*   @found_bit:
04080B 78          0244*   	ld a,b
04080C CD D9 07 04 0245*   	call shr_hlu
040810 C1          0246*   	pop 	bc ; restore
040811 C9          0247*   	ret
040812             0248*   ; end shr_hlu_log2a
040812             0249*   
040812             0250*   ;------------------------------------------------------------------------
040812             0251*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040812             0252*   ;                Determines the LSB of A and shifts HLU accordingly.
040812             0253*   ;                HLU = HLU << LSB(A)
040812             0254*   ; Returns: HLU = HLU << LSB(A)
040812             0255*   ; Destroys: af
040812             0256*   ;------------------------------------------------------------------------
040812             0257*   shl_hlu_log2a:
040812 B7          0258*   	or a    ; check for zero
040813 C8          0259*   	ret z   ; nothing to shift so we're done
040814 C5          0260*   	push 	bc ; preserve
040815 06 00       0261*   	ld		b,0 ; clear b
040817             0262*   @find_bit:
040817 0F          0263*   	rrca ; bit 0 to carry
040818 DA 21 08 04 0264*   	jp c,@found_bit
04081C 04          0265*   	inc b ; next bit
04081D C3 17 08 04 0266*   	jp @find_bit
040821             0267*   @found_bit:
040821 78          0268*   	ld a,b
040822 CD D3 07 04 0269*   	call shl_hlu
040826 C1          0270*   	pop 	bc ; restore
040827 C9          0271*   	ret
040828             0272*   ; end shl_hlu_log2a
040828             0032        include "maths.inc"
040828 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040900             0002*   ; test the sign of HL
040900             0003*   ; inputs: HL obviously
040900             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040900             0005*   ; destroys: flags
040900             0006*       MACRO sign_hlu
040900             0007*       add hl,de
040900             0008*       or a ; clear flags
040900             0009*       sbc hl,de
040900             0010*       ENDMACRO
040900             0011*   
040900             0012*   
040900             0013*   ;------------------------------------------------------------------------
040900             0014*   ; Scratch area for calculations
040900             0015*   ;------------------------------------------------------------------------
040900 00 00 00    0016*   scratch1: dw24 0 ;bit manipulation buffer 1
040903 00 00 00    0017*   scratch2: dw24 0 ;bit manipulation buffer 2
040906             0018*   
040906             0019*   ; absolute value of hlu
040906             0020*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040906             0021*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040906             0022*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040906             0023*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040906             0024*   ; destroys: a
040906             0025*   hlu_abs:
040906 19          0026*       add hl,de
040907 B7          0027*       or a
040908 ED 52       0028*       sbc hl,de
04090A FA 0F 09 04 0029*       jp m,@is_neg
04090E C9          0030*       ret ; hlu is positive or zero so we're done
04090F             0031*   @is_neg:
04090F F5          0032*       push af ; otherwise, save current flags for return
040910 CD 16 09 04 0033*       call neg_hlu ; negate hlu
040914 F1          0034*       pop af ; get back flags
040915 C9          0035*       ret
040916             0036*   
040916             0037*   ; flip the sign of hlu
040916             0038*   ; inputs: hlu
040916             0039*   ; returns: 0-hlu, flags set appropriately for the result:
040916             0040*   ;         s1,z0,pv0,n1,c1 if result is negative
040916             0041*   ;         s0,z1,pv0,n1,c0 if result is zero
040916             0042*   ;         s0,z0,pv0,n1,c1 if result is positive
040916             0043*   ; destroys a
040916             0044*   neg_hlu:
040916 D5          0045*       push de ; save de
040917 EB          0046*       ex de,hl ; put hl into de
040918 21 00 00 00 0047*       ld hl,0 ; clear hl
04091C AF          0048*       xor a ; clear carry
04091D ED 52       0049*       sbc hl,de ; 0-hlu = -hlu
04091F D1          0050*       pop de ; get de back
040920 C9          0051*       ret ; easy peasy
040921             0052*   
040921             0053*   ;------------------------------------------------------------------------
040921             0054*   ; divide hlu by 2, inspired by above
040921             0055*   ;------------------------------------------------------------------------
040921             0056*   hlu_div2:
040921 22 00 09 04 0057*       ld (scratch1),hl
040925 21 02 09 04 0058*       ld hl,scratch1+2
040929 CB 1E       0059*       rr (hl)
04092B 2B          0060*       dec hl
04092C CB 1E       0061*       rr (hl)
04092E 2B          0062*       dec hl
04092F CB 1E       0063*       rr (hl)
040931 23          0064*       inc hl
040932 23          0065*       inc hl
040933 2A 00 09 04 0066*       ld hl,(scratch1)
040937 C9          0067*       ret
040938             0068*   
040938             0069*   ; this is my little hack to divide by 16
040938             0070*   hlu_div16:
040938 AF          0071*       xor a
040939 29          0072*       add hl,hl
04093A 17          0073*       rla
04093B 29          0074*       add hl,hl
04093C 17          0075*       rla
04093D 29          0076*       add hl,hl
04093E 17          0077*       rla
04093F 29          0078*       add hl,hl
040940 17          0079*       rla
040941 22 4E 09 04 0080*       ld (@scratch),hl
040945 32 51 09 04 0081*       ld (@scratch+3),a
040949 2A 4F 09 04 0082*       ld hl,(@scratch+1)
04094D C9          0083*       ret
04094E             0084*   @scratch: ds 4
040952             0085*   
040952             0086*   ; hlu signed division by 256
040952             0087*   ; returns: hlu / 256
040952             0088*   ; destroys: af
040952             0089*   hlu_sdiv256:
       FF FF FF FF 
040952 AF          0090*       xor a ; assume hl is positive
040953 22 69 09 04 0091*       ld (@buffer),hl
040957             0092*       sign_hlu
040957 19          0001*M1     add hl,de
040958 B7          0002*M1     or a ; clear flags
040959 ED 52       0003*M1     sbc hl,de
04095B F2 60 09 04 0093*       jp p,@hl_pos
04095F 3D          0094*       dec a
040960             0095*   @hl_pos:
040960 32 6C 09 04 0096*       ld (@buffer+3),a
040964 2A 6A 09 04 0097*       ld hl,(@buffer+1)
040968 C9          0098*       ret
040969             0099*   @buffer: ds 4
04096D             0100*   
04096D             0101*   ; hlu 1 byte right shift, unsigned
04096D             0102*   ; returns: hlu / 256, fractional portion in a
04096D             0103*   ; destroys: af
04096D             0104*   hlu_udiv256:
       FF FF FF FF 
04096D AF          0105*       xor a
04096E 32 7F 09 04 0106*       ld (@buffer+3),a
040972 7D          0107*       ld a,l ; save the fractional portion
040973 22 7C 09 04 0108*       ld (@buffer),hl
040977 2A 7D 09 04 0109*       ld hl,(@buffer+1)
04097B C9          0110*       ret
04097C             0111*   @buffer: ds 4
040980             0112*   
040980             0113*       MACRO hlu_mul256
040980             0114*       add hl,hl ; * 2
040980             0115*       add hl,hl ; * 4
040980             0116*       add hl,hl ; * 8
040980             0117*       add hl,hl ; * 16
040980             0118*       add hl,hl ; * 32
040980             0119*       add hl,hl ; * 64
040980             0120*       add hl,hl ; * 128
040980             0121*       add hl,hl ; * 256
040980             0122*       ENDMACRO
040980             0123*   
       FF FF FF FF 
040980 00 00 00 00 0124*   add_bcd_arg1: db #00,#00,#00,#00
040984 00 00 00 00 0125*   add_bcd_arg2: db #00,#00,#00,#00
040988             0126*   
040988             0127*   ; set bcd values in a scratch memory address from registers bcde
040988             0128*   ; input: hl; scratch address,bcde; 8-place bcd number
040988             0129*   ; destroys ; hl
040988             0130*   set_bcd:
040988 73          0131*       ld (hl),e
040989 23          0132*       inc hl
04098A 72          0133*       ld (hl),d
04098B 23          0134*       inc hl
04098C 71          0135*       ld (hl),c
04098D 23          0136*       inc hl
04098E 70          0137*       ld (hl),b
04098F C9          0138*       ret
040990             0139*   
040990             0140*   ; load bcd values from a scratch memory address to bcde
040990             0141*   ; input: hl; scratch address
040990             0142*   ; output: bcde; 8-place bcd number
040990             0143*   ; destroys: hl
040990             0144*   get_bcd:
040990 5E          0145*       ld e,(hl)
040991 23          0146*       inc hl
040992 56          0147*       ld d,(hl)
040993 23          0148*       inc hl
040994 4E          0149*       ld c,(hl)
040995 23          0150*       inc hl
040996 46          0151*       ld b,(hl)
040997 C9          0152*       ret
040998             0153*   
040998             0154*   ; BCD addition
040998             0155*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040998             0156*   ;       a is the number of bytes holding each number (number of places/2)
040998             0157*   ; outputs: (hl) + (de) --> (hl)
040998             0158*   ; destroys: a,b,de,hl
040998             0159*   add_bcd:
040998 47          0160*       ld b,a ; loop counter
040999 AF          0161*       xor a ; reset a, clear carry flag
04099A             0162*   adcec:
04099A 1A          0163*       ld a,(de) ; addend to acc
04099B 8E          0164*       adc a,(hl) ; add (hl) to acc
04099C 27          0165*       daa ; adjust result to bcd
04099D 77          0166*       ld (hl),a ; store result
04099E 23          0167*       inc hl ; advance memory pointers
04099F 13          0168*       inc de
0409A0 10 F8       0169*       djnz adcec ; loop until b == 0
0409A2 C9          0170*       ret
0409A3             0171*   
0409A3             0172*   ; BCD subtraction
0409A3             0173*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0409A3             0174*   ;       a is the number of bytes holding each number (number of places/2)
0409A3             0175*   ; outputs: (hl) - (de) --> (hl)
0409A3             0176*   ; destroys: a,b,de,hl
0409A3             0177*   sub_bcd:
0409A3 47          0178*       ld b,a ; loop counter
0409A4 AF          0179*       xor a ; reset a,clear carry flag
0409A5             0180*   subdec:
0409A5 1A          0181*       ld a,(de) ; subtrahend to acc
0409A6 9E          0182*       sbc a,(hl) ; subtract (hl) from acc
0409A7 27          0183*       daa ; adjust result to bcd
0409A8 77          0184*       ld (hl),a ; store result
0409A9 23          0185*       inc hl ; advance memory pointers
0409AA 13          0186*       inc de
0409AB 10 F8       0187*       djnz subdec ; loop until b == 0
0409AD C9          0188*       ret
0409AE             0189*   
0409AE             0190*   ; http://www.z80.info/pseudo-random.txt
0409AE             0191*   rand_8:
0409AE C5          0192*       push bc
0409AF 3A C2 09 04 0193*       ld a,(r_seed)
0409B3 4F          0194*       ld c,a
0409B4             0195*   
0409B4 0F          0196*       rrca ; multiply by 32
0409B5 0F          0197*       rrca
0409B6 0F          0198*       rrca
0409B7 EE 1F       0199*       xor 0x1f
0409B9             0200*   
0409B9 81          0201*       add a,c
0409BA DE FF       0202*       sbc a,255 ; carry
0409BC             0203*   
0409BC 32 C2 09 04 0204*       ld (r_seed),a
0409C0 C1          0205*       pop bc
0409C1 C9          0206*       ret
0409C2 50          0207*   r_seed: defb $50
0409C3             0208*   
0409C3             0209*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0409C3             0210*   prng24:
0409C3             0211*   ;;Expects ADL mode.
0409C3             0212*   ;;Output: HL
0409C3             0213*   ;;50cc
0409C3             0214*   ;;33 bytes
0409C3             0215*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0409C3 ED 5B E4 09 0216*       ld de,(seed1)
       04          
0409C8 B7          0217*       or a
0409C9 ED 62       0218*       sbc hl,hl
0409CB 19          0219*       add hl,de
0409CC 29          0220*       add hl,hl
0409CD 29          0221*       add hl,hl
0409CE 2C          0222*       inc l
0409CF 19          0223*       add hl,de
0409D0 22 E4 09 04 0224*       ld (seed1),hl
0409D4 2A E7 09 04 0225*       ld hl,(seed2)
0409D8 29          0226*       add hl,hl
0409D9 9F          0227*       sbc a,a
0409DA E6 1B       0228*       and %00011011
0409DC AD          0229*       xor l
0409DD 6F          0230*       ld l,a
0409DE 22 E7 09 04 0231*       ld (seed2),hl
0409E2 19          0232*       add hl,de
0409E3 C9          0233*       ret
0409E4 00 00 00    0234*   seed1: dl 0
0409E7 00 00 00    0235*   seed2: dl 0
0409EA             0033        include "files.inc"
0409EA             0001*   ; load to onboard 8k sram
0409EA             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
0409EA             0034        include "fixed168.inc"
0409EA FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
040A00             0002*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040A00             0003*   ; uses EZ80 MLT instruction for speed
040A00             0004*   ; operation: UHL * A --> UHL
040A00             0005*   ; destroys: AF, HL
040A00             0006*   smul24x8:
040A00             0007*   ; make hl positive and store sign flag
040A00 CD 06 09 04 0008*       call hlu_abs
040A04 F5          0009*       push af
040A05             0010*   ; do the division
040A05 CD 10 0A 04 0011*       call mul24x8 ; hl = product
040A09             0012*   ; adjust sign of result
040A09 F1          0013*       pop af ; sign de
040A0A F0          0014*       ret p ; hl was positive, nothing to do
040A0B CD 16 09 04 0015*       call neg_hlu ; result is negative
040A0F C9          0016*       ret
040A10             0017*   
040A10             0018*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040A10             0019*   ; uses EZ80 MLT instruction for speed
040A10             0020*   ; operation: UHL * A --> AUHL
040A10             0021*   ; destroys: AF, HL
040A10             0022*   mul24x8:
040A10 D5          0023*       push de ; preserve de
040A11             0024*   ; low byte
040A11 5D          0025*       ld e,l
040A12 57          0026*       ld d,a
040A13 ED 5C       0027*       mlt de
040A15 6B          0028*       ld l,e ; product low byte
040A16 08          0029*       ex af,af' ; save multiplier
040A17 7A          0030*       ld a,d ; carry
040A18 08          0031*       ex af,af' ; save carry, restore multiplier
040A19             0032*   ; high byte
040A19 5C          0033*       ld e,h
040A1A 57          0034*       ld d,a
040A1B ED 5C       0035*       mlt de
040A1D 08          0036*       ex af,af' ; save multiplier, restore carry
040A1E 83          0037*       add a,e ; add carry
040A1F 67          0038*       ld h,a ; product middle byte
040A20 7A          0039*       ld a,d ; carry
040A21 08          0040*       ex af,af' ; save carry, restore multiplier
040A22             0041*   ; upper byte
040A22 22 3D 0A 04 0042*       ld (@scratch),hl ; 7 cycles
040A26 5F          0043*       ld e,a
040A27 3A 3F 0A 04 0044*       ld a,(@scratch+2)
040A2B 57          0045*       ld d,a
040A2C ED 5C       0046*       mlt de
040A2E 08          0047*       ex af,af' ; restore carry
040A2F 8B          0048*       adc a,e ; add carry
040A30 32 3F 0A 04 0049*       ld (@scratch+2),a ; 5 cycles
040A34 2A 3D 0A 04 0050*       ld hl,(@scratch) ; 7 cycles
040A38             0051*   ; highest byte
040A38 3E 00       0052*       ld a,0 ; preserve carry flag
040A3A 8A          0053*       adc a,d ; product highest byte
040A3B D1          0054*       pop de ; restore de
040A3C C9          0055*       ret
040A3D             0056*   @scratch: ds 3
040A40             0057*   
       FF FF FF 
040A40 00 00 00 00 0058*   mul24out: blkb 6,0
       00 00       
040A46             0059*   
040A46             0060*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040A46             0061*   ; operation: UHL * UDE --> mul24out
040A46             0062*   mul24:
040A46 DD E5       0063*       push ix ; preserve
040A48             0064*   ; point to output buffer and clear it
040A48 DD 21 40 0A 0065*       ld ix,mul24out
       04          
040A4D C5          0066*       push bc
040A4E 01 00 00 00 0067*       ld bc,0
040A52 DD 0F 00    0068*       ld (ix),bc
040A55 DD 0F 03    0069*       ld (ix+3),bc
040A58 C1          0070*       pop bc
040A59             0071*   ; STEP 1: UHL * E
040A59 7B          0072*       ld a,e
040A5A E5          0073*       push hl
040A5B CD 10 0A 04 0074*       call mul24x8
040A5F DD 2F 00    0075*       ld (ix+0),hl
040A62 DD 77 03    0076*       ld (ix+3),a
040A65             0077*   ; STEP 2: UHL * D
040A65 E1          0078*       pop hl
040A66 E5          0079*       push hl
040A67 7A          0080*       ld a,d
040A68 CD 10 0A 04 0081*       call mul24x8
040A6C CD 85 0A 04 0082*       call @accumulate
040A70             0083*   ; STEP 3: UHL * DEU
040A70 E1          0084*       pop hl
040A71 ED 53 B5 0A 0085*       ld (@de),de
       04          
040A76 3A B7 0A 04 0086*       ld a,(@de+2)
040A7A CD 10 0A 04 0087*       call mul24x8
040A7E CD 85 0A 04 0088*       call @accumulate
040A82             0089*   ; all done
040A82 DD E1       0090*       pop ix ; restore
040A84 C9          0091*       ret
040A85             0092*   @accumulate:
040A85 DD 23       0093*       inc ix
040A87             0094*   ; highest byte of product to carry
040A87 DD 77 03    0095*       ld (ix+3),a
040A8A             0096*   ; low byte of product
040A8A 7D          0097*       ld a,l
040A8B DD 86 00    0098*       add a,(ix+0)
040A8E DD 77 00    0099*       ld (ix+0),a
040A91             0100*   ; high byte of product
040A91 7C          0101*       ld a,h
040A92 DD 8E 01    0102*       adc a,(ix+1)
040A95 DD 77 01    0103*       ld (ix+1),a
040A98             0104*   ; uppper byte of product
040A98 22 B2 0A 04 0105*       ld (@hl),hl
040A9C 3A B4 0A 04 0106*       ld a,(@hl+2)
040AA0 DD 8E 02    0107*       adc a,(ix+2)
040AA3 DD 77 02    0108*       ld (ix+2),a
040AA6             0109*   ; carry
040AA6 3E 00       0110*       ld a,0 ; preserve flags
040AA8 DD 8E 03    0111*       adc a,(ix+3)
040AAB DD 77 03    0112*       ld (ix+3),a
040AAE C9          0113*       ret
040AAF             0114*   
040AAF 00 00 00    0115*   @ix: dl 0
040AB2 00 00 00    0116*   @hl: dl 0
040AB5 00 00 00    0117*   @de: dl 0
040AB8             0118*   
040AB8             0119*   ; UHL * UDE --> UHL (unsigned)
040AB8             0120*   umul24:
040AB8 CD 46 0A 04 0121*       call mul24
040ABC 2A 40 0A 04 0122*       ld hl,(mul24out)
040AC0 C9          0123*       ret
040AC1             0124*   
040AC1             0125*   ; UH.L = UH.L*UD.E (unsigned)
040AC1             0126*   umul168:
040AC1 CD 46 0A 04 0127*       call mul24
040AC5 2A 41 0A 04 0128*       ld hl,(mul24out+1)
040AC9 C9          0129*       ret
040ACA             0130*   
040ACA             0131*   ; UH.L * UD.E --> UH.L (signed)
040ACA             0132*   smul168:
040ACA             0133*   ; make everything positive and store sign flags
040ACA CD 06 09 04 0134*       call hlu_abs
040ACE F5          0135*       push af
040ACF EB          0136*       ex de,hl
040AD0 CD 06 09 04 0137*       call hlu_abs
040AD4 EB          0138*       ex de,hl
040AD5 F5          0139*       push af
040AD6             0140*   ; do the division
040AD6 CD C1 0A 04 0141*       call umul168 ; hl = product
040ADA             0142*   ; adjust sign of result
040ADA F1          0143*       pop af ; sign de
040ADB FA E6 0A 04 0144*       jp m,@de_neg
040ADF F1          0145*       pop af ; sign hl
040AE0 F0          0146*       ret p ; both positive, nothing to do
040AE1             0147*   @hl_neg:
040AE1 CD 16 09 04 0148*       call neg_hlu ; de pos, hl neg, result is negative
040AE5 C9          0149*       ret
040AE6             0150*   @de_neg:
040AE6 F1          0151*       pop af
040AE7 F8          0152*       ret m ; both negative, nothing to do
040AE8 CD 16 09 04 0153*       call neg_hlu ; result is negative
040AEC C9          0154*       ret
040AED             0155*   
040AED             0156*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040AED             0157*   ; perform unsigned division of 16.8 fixed place values
040AED             0158*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040AED             0159*   udiv168:
040AED             0160*   ; back up divisor
040AED ED 53 24 0B 0161*       ld (@ude),de
       04          
040AF2             0162*   ; get the 16-bit integer part of the quotient
040AF2 CD 3E 07 04 0163*       call udiv24 ; de = quotient, hl = remainder
040AF6             0164*   ; load quotient to upper three bytes of output
040AF6 ED 53 2B 0B 0165*       ld (div168_out+1),de
       04          
040AFB             0166*   @div256:
040AFB             0167*   ; multiply remainder by 256
040AFB             0168*       hlu_mul256
040AFB 29          0001*M1     add hl,hl ; * 2
040AFC 29          0002*M1     add hl,hl ; * 4
040AFD 29          0003*M1     add hl,hl ; * 8
040AFE 29          0004*M1     add hl,hl ; * 16
040AFF 29          0005*M1     add hl,hl ; * 32
040B00 29          0006*M1     add hl,hl ; * 64
040B01 29          0007*M1     add hl,hl ; * 128
040B02 29          0008*M1     add hl,hl ; * 256
040B03             0169*   ; skip fractional computation if remainder is zero
040B03             0170*       sign_hlu
040B03 19          0001*M1     add hl,de
040B04 B7          0002*M1     or a ; clear flags
040B05 ED 52       0003*M1     sbc hl,de
040B07 20 03       0171*       jr nz,@div_frac
040B09 AF          0172*       xor a
040B0A 18 0A       0173*       jr @write_frac
040B0C             0174*   ; now divide the shifted remainder by the divisor
040B0C             0175*   @div_frac:
040B0C ED 5B 24 0B 0176*       ld de,(@ude) ; get back divisor
       04          
040B11 CD 3E 07 04 0177*       call udiv24 ; de = quotient, hl = remainder
040B15             0178*   ; load low byte of quotient to low byte of output
040B15 7B          0179*       ld a,e
040B16             0180*   @write_frac:
040B16 32 2A 0B 04 0181*       ld (div168_out),a
040B1A             0182*   ; load de with return value
040B1A ED 5B 2A 0B 0183*       ld de,(div168_out)
       04          
040B1F             0184*   ; load a with any overflow
040B1F 3A 2D 0B 04 0185*       ld a,(div168_out+3)
040B23 C9          0186*       ret ; ud.e is the 16.8 result
040B24             0187*   @ude: ds 6
040B2A             0188*   div168_out: ds 4 ; the extra byte is for overflow
040B2E             0189*   
040B2E             0190*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040B2E             0191*   ; perform signed division of 16.8 fixed place values
040B2E             0192*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040B2E             0193*   sdiv168:
040B2E             0194*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040B2E CD 06 09 04 0195*       call hlu_abs
040B32 F5          0196*       push af
040B33 EB          0197*       ex de,hl
040B34 CD 06 09 04 0198*       call hlu_abs
040B38 EB          0199*       ex de,hl
040B39 F5          0200*       push af
040B3A             0201*   ; do the division
040B3A CD ED 0A 04 0202*       call udiv168 ; de = quotient, hl = remainder
040B3E             0203*   ; adjust sign of result
040B3E F1          0204*       pop af ; sign de
040B3F FA 4C 0B 04 0205*       jp m,@de_neg
040B43 F1          0206*       pop af ; sign hl
040B44 F0          0207*       ret p ; both positive, nothing to do
040B45             0208*   @hl_neg:
040B45 EB          0209*       ex de,hl ; hl = quotient, de = remainder
040B46 CD 16 09 04 0210*       call neg_hlu ; de pos, hl neg, result is negative
040B4A EB          0211*       ex de,hl ; de = negated quotient, hl = remainder
040B4B C9          0212*       ret
040B4C             0213*   @de_neg:
040B4C F1          0214*       pop af
040B4D F8          0215*       ret m ; both negative, nothing to do
040B4E EB          0216*       ex de,hl ; hl = quotient, de = remainder
040B4F CD 16 09 04 0217*       call neg_hlu ; result is negative
040B53 EB          0218*       ex de,hl ; de = negated quotient, hl = remainder
040B54 C9          0219*       ret
040B55             0220*   
040B55             0221*   ; convert signed angles from a 360 to 256 degree circle
040B55             0222*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040B55             0223*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040B55             0224*   ; destroys: TODO
040B55             0225*   deg_360_to_256:
040B55 D5          0226*       push de ; preserve de
040B56             0227*   ; make angle positive and store sign flag
040B56 CD 06 09 04 0228*       call hlu_abs
040B5A F5          0229*       push af
040B5B             0230*   ; multiply by coversion factor of 256/360
040B5B 11 B6 00 00 0231*       ld de,0x0000B6 ; 0.711
040B5F CD C1 0A 04 0232*       call umul168 ; uh.l = uh.l * 0.711
040B63             0233*   ; restore sign flag and adjust output accordingly
040B63 F1          0234*       pop af
040B64 F2 6C 0B 04 0235*       jp p,@pos ; positive number
040B68 CD 16 09 04 0236*       call neg_hlu
040B6C             0237*   @pos:
040B6C             0238*   ; restore de and return uh.l as the result
040B6C D1          0239*       pop de
040B6D C9          0240*       ret
040B6E             0241*   
040B6E             0242*   ; convert signed angles from a 256 to 360 degree circle
040B6E             0243*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040B6E             0244*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040B6E             0245*   ; destroys: TODO
040B6E             0246*   deg_256_to_360:
040B6E D5          0247*       push de ; preserve de
040B6F             0248*   ; make angle positive and store sign flag
040B6F CD 06 09 04 0249*       call hlu_abs
040B73 F5          0250*       push af
040B74             0251*   ; multiply by coversion factor of 360/256
040B74 11 68 01 00 0252*       ld de,0x000168 ; 1.406
040B78 CD C1 0A 04 0253*       call umul168 ; uh.l = uh.l * 1.406
040B7C             0254*   ; restore sign flag and adjust output accordingly
040B7C F1          0255*       pop af
040B7D F2 85 0B 04 0256*       jp p,@pos ; positive number
040B81 CD 16 09 04 0257*       call neg_hlu
040B85             0258*   @pos:
040B85             0259*   ; restore de and return uh.l as the result
040B85 D1          0260*       pop de
040B86 C9          0261*       ret
040B87             0262*   
040B87             0263*   ; fixed 16.8 routine
040B87             0264*   ; cos(uh.l) --> uh.l
040B87             0265*   ; destroys: f, hl
040B87             0266*   cos168:
040B87 D5          0267*       push de ; preserve de
040B88             0268*   ; for cos we simply increment the angle by 90 degrees
040B88             0269*   ; or 0x004000 in 16.8 degrees256
040B88             0270*   ; which makes it a sin problem
040B88 11 00 40 00 0271*       ld de,0x004000
040B8C 19          0272*       add hl,de ; modulo 256 happens below
040B8D D1          0273*       pop de ; restore de
040B8E             0274*   ; fall through to sin168
040B8E             0275*   
040B8E             0276*   ; ---------------------
040B8E             0277*   ; fixed 16.8 routine
040B8E             0278*   ; sin(uh.l) --> uh.l
040B8E             0279*   ; destroys: f, hl
040B8E             0280*   sin168:
040B8E D5          0281*       push de
040B8F             0282*   ; handle negative angles appropriately
040B8F CD 06 09 04 0283*       call hlu_abs
040B93 F2 9C 0B 04 0284*       jp p,@F
040B97 11 00 00 FF 0285*       ld de,-256*256
040B9B 19          0286*       add hl,de
040B9C             0287*   @@:
040B9C 2E 03       0288*       ld l,3 ; multiply by 3 to get our lookup index
040B9E ED 6C       0289*       mlt hl
040BA0 11 4E 0E 04 0290*       ld de,sin_lut_168 ; grab the lut address
040BA4 19          0291*       add hl,de ; bump hl by the index
040BA5 ED 27       0292*       ld hl,(hl) ; don't try this on a z80!
040BA7 D1          0293*       pop de
040BA8 C9          0294*       ret
040BA9             0295*   
040BA9             0296*   ; 16.8 fixed inputs / outputs
040BA9             0297*   ; takes: uh.l as angle in degrees 256
040BA9             0298*   ;        ud.e as radius
040BA9             0299*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040BA9             0300*   ;        displacements from origin (0,0)
040BA9             0301*   ; destroys: everything except indexes
040BA9             0302*   polar_to_cartesian:
040BA9             0303*   ; back up input parameters
040BA9 22 D8 0B 04 0304*       ld (@angle), hl
040BAD ED 53 DB 0B 0305*       ld (@radius), de
       04          
040BB2             0306*   ; compute dx = sin(uh.l) * ud.e
040BB2 CD 8E 0B 04 0307*       call sin168 ; uh.l = sin(uh.l)
040BB6 ED 5B DB 0B 0308*       ld de,(@radius)
       04          
040BBB CD CA 0A 04 0309*       call smul168 ; uh.l = dx
040BBF E5          0310*       push hl
040BC0             0311*   ; compute dy = -cos(uh.l) * ud.e
040BC0 2A D8 0B 04 0312*       ld hl,(@angle)
040BC4 CD 87 0B 04 0313*       call cos168 ; uh.l = cos(uh.l)
040BC8 ED 5B DB 0B 0314*       ld de,(@radius)
       04          
040BCD CD CA 0A 04 0315*       call smul168 ; uh.l = dy
040BD1 CD 16 09 04 0316*       call neg_hlu ; invert dy for screen coords convention
040BD5 EB          0317*       ex de,hl ; de = dy for output
040BD6 C1          0318*       pop bc ; bc = dx for output
040BD7             0319*   ; and out
040BD7 C9          0320*       ret
040BD8             0321*   @angle: ds 3
040BDB             0322*   @radius: ds 3
040BDE             0323*   
040BDE             0324*   ; 16.8 fixed inputs / outputs
040BDE             0325*   ; inputs: ub.c as dx, ud.e as dy
040BDE             0326*   ;        displacements from origin (0,0)
040BDE             0327*   ; returns: uh.l as angle in degrees 256
040BDE             0328*   ;        ud.e as radius
040BDE             0329*   ; destroys: everything except indexes
040BDE             0330*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040BDE ED 43 37 0C 0331*       ld (dx168),bc ; dx argument for distance168
       04          
040BE3 ED 53 3D 0C 0332*       ld (dy168),de ; dy argument for distance168
       04          
040BE8             0333*   ; compute radius
040BE8 CD 43 0C 04 0334*       call distance168 ; uh.l = radius
040BEC E5          0335*       push hl ; save radius
040BED             0336*   ; compute angle
040BED ED 4B 37 0C 0337*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040BF2 ED 5B 3D 0C 0338*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040BF7 CD 9D 0C 04 0339*       call atan2_168fast ; uh.l = angle
040BFB             0340*   ; return result
040BFB D1          0341*       pop de ; de = radius (was hl)
040BFC C9          0342*       ret
040BFD             0343*   ; end cartesian_to_polar
040BFD             0344*   
040BFD             0345*   ; 16.8 fixed inputs / outputs
040BFD             0346*   ; inputs: ub.c as dx, ud.e as dy
040BFD             0347*   ;        displacements from origin (0,0)
040BFD             0348*   ; returns: uh.l as angle in degrees 256
040BFD             0349*   ;        ud.e as radius
040BFD             0350*   ; destroys: everything except indexes
040BFD             0351*   ; note: uses distance168sm which is more accurate for small deltas
040BFD             0352*   cartesian_to_polar_sm:
040BFD ED 43 37 0C 0353*       ld (dx168),bc ; dx argument for distance168
       04          
040C02 ED 53 3D 0C 0354*       ld (dy168),de ; dy argument for distance168
       04          
040C07             0355*   ; compute radius
040C07 CD 78 0C 04 0356*       call distance168sm ; uh.l = radius
040C0B E5          0357*       push hl ; save radius
040C0C             0358*   ; compute angle
040C0C ED 4B 37 0C 0359*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040C11 ED 5B 3D 0C 0360*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040C16 CD 9D 0C 04 0361*       call atan2_168fast ; uh.l = angle
040C1A             0362*   ; return result
040C1A D1          0363*       pop de ; de = radius (was hl)
040C1B C9          0364*       ret
040C1C             0365*   ; end cartesian_to_polar
040C1C             0366*   
040C1C             0367*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040C1C             0368*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040C1C             0369*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040C1C             0370*   ;         also populates scratch locations dx168 and dy168
040C1C             0371*   ; destroys: a,hl,bc,de
040C1C             0372*   dxy168:
040C1C             0373*   ; compute dx = x1-x0
040C1C AF          0374*       xor a ; clear carry
040C1D DD E5       0375*       push ix ; move ix to hl via the stack
040C1F E1          0376*       pop hl ; hl = x1
040C20 ED 42       0377*       sbc hl,bc ; hl = dx
040C22 22 37 0C 04 0378*       ld (dx168),hl ; dx to scratch
040C26             0379*   ; compute dy = y1-y0
040C26 AF          0380*       xor a ; clear carry
040C27 FD E5       0381*       push iy ; move iy to hl via the stack
040C29 E1          0382*       pop hl ; hl = y1
040C2A ED 52       0383*       sbc hl,de ; hl = dy
040C2C 22 3D 0C 04 0384*       ld (dy168),hl ; dy to scratch
040C30             0385*   ; populate output registers and return
040C30 EB          0386*       ex de,hl ; ud.e = dy
040C31 ED 4B 37 0C 0387*       ld bc,(dx168) ; ub.c = dx
       04          
040C36 C9          0388*       ret
040C37 00 00 00 00 0389*   dx168: blkb 6,0
       00 00       
040C3D 00 00 00 00 0390*   dy168: blkb 6,0
       00 00       
040C43             0391*   
040C43             0392*   ; compute the euclidian distance between two cartesian coordinates
040C43             0393*   ; using the formula d = sqrt(dx^2+dy^2)
040C43             0394*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C43             0395*   ; output; uh.l is the 16.8 fixed format distance
040C43             0396*   ;         also populates scratch locations dx168 and dy168
040C43             0397*   ; destroys: a,hl,bc,de
040C43             0398*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040C43             0399*   ;       thus the result will always be an integer, albeit in 16.8 format
040C43             0400*   distance168:
040C43             0401*   ; compute dy^2
040C43 2A 3D 0C 04 0402*       ld hl,(dy168)
040C47 CD 06 09 04 0403*       call hlu_abs
040C4B CD 6D 09 04 0404*       call hlu_udiv256 ; make integer to avoid overflow
040C4F E5          0405*       push hl
040C50 D1          0406*       pop de
040C51 CD B8 0A 04 0407*       call umul24 ; hl = dy^2
040C55 E5          0408*       push hl ; save dy^2
040C56             0409*   ; compute dx^2
040C56 2A 37 0C 04 0410*       ld hl,(dx168)
040C5A CD 06 09 04 0411*       call hlu_abs
040C5E CD 6D 09 04 0412*       call hlu_udiv256 ; make integer to avoid overflow
040C62 E5          0413*       push hl
040C63 D1          0414*       pop de
040C64 CD B8 0A 04 0415*       call umul24 ; hl = dx^2
040C68             0416*   ; add dx^2 and dy^2
040C68 D1          0417*       pop de ; de = dy^2 (was hl)
040C69 19          0418*       add hl,de ; hl = dx^2 + dy^2
040C6A             0419*   ; compute the square root
040C6A CD 68 0D 04 0420*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C6E EB          0421*       ex de,hl ; hl = distance
040C6F             0422*       hlu_mul256 ; convert back to 16.8 fixed
040C6F 29          0001*M1     add hl,hl ; * 2
040C70 29          0002*M1     add hl,hl ; * 4
040C71 29          0003*M1     add hl,hl ; * 8
040C72 29          0004*M1     add hl,hl ; * 16
040C73 29          0005*M1     add hl,hl ; * 32
040C74 29          0006*M1     add hl,hl ; * 64
040C75 29          0007*M1     add hl,hl ; * 128
040C76 29          0008*M1     add hl,hl ; * 256
040C77 C9          0423*       ret
040C78             0424*   
040C78             0425*   ; compute the euclidian distance between two cartesian coordinates
040C78             0426*   ; using the formula d = sqrt(dx^2+dy^2)
040C78             0427*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040C78             0428*   ; output; uh.l is the 16.8 fixed format distance
040C78             0429*   ;         also populates scratch locations dx168 and dy168
040C78             0430*   ; destroys: a,hl,bc,de
040C78             0431*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040C78             0432*   ;       making it more accurate for small deltas,
040C78             0433*   ;       but will overflow if used for screen-sized deltas
040C78             0434*   distance168sm:
040C78             0435*   ; compute dy^2
040C78 2A 3D 0C 04 0436*       ld hl,(dy168)
040C7C CD 06 09 04 0437*       call hlu_abs
040C80 E5          0438*       push hl
040C81 D1          0439*       pop de
040C82 CD B8 0A 04 0440*       call umul24 ; hl = dy^2
040C86 E5          0441*       push hl ; save dy^2
040C87             0442*   ; compute dx^2
040C87 2A 37 0C 04 0443*       ld hl,(dx168)
040C8B CD 06 09 04 0444*       call hlu_abs
040C8F E5          0445*       push hl
040C90 D1          0446*       pop de
040C91 CD B8 0A 04 0447*       call umul24 ; hl = dx^2
040C95             0448*   ; add dx^2 and dy^2
040C95 D1          0449*       pop de ; de = dy^2 (was hl)
040C96 19          0450*       add hl,de ; hl = dx^2 + dy^2
040C97             0451*   ; compute the square root
040C97 CD 68 0D 04 0452*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040C9B EB          0453*       ex de,hl ; hl = distance
040C9C C9          0454*       ret
040C9D             0455*   
040C9D             0456*   ; atan2_(ub.c,ud.e) --> uh.l
040C9D             0457*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C9D             0458*   ;   whether inputs are integers or fractional doesn't matter
040C9D             0459*   ;   so long as the sign bit of the upper byte is correct
040C9D             0460*   ; output: uh.l is the 16.8 fixed angle in degrees 256
040C9D             0461*   ; angles are COMPASS HEADINGS based on
040C9D             0462*   ; screen coordinate conventions,where the y axis is flipped
040C9D             0463*   ; #E0 224      0       32 #20
040C9D             0464*   ;        -x,-y | +x,-y
040C9D             0465*   ; #C0 192------+------ 64 #40
040C9D             0466*   ;        -x,+y | +x,+y
040C9D             0467*   ; #A0 160   128 #80   96 #60
040C9D             0468*   atan2_168fast:
040C9D             0469*   ; get signs and make everything positive
040C9D             0470*   ; get abs(x) and store its original sign
040C9D C5          0471*       push bc
040C9E E1          0472*       pop hl
040C9F CD 06 09 04 0473*       call hlu_abs ; if x was negative this also sets the sign flag
040CA3 E5          0474*       push hl ; store abs(x)
040CA4 C1          0475*       pop bc ; bc = abs(x)
040CA5 F5          0476*       push af ; store sign of x
040CA6             0477*   ; get abs(y) and store its original sign
040CA6 EB          0478*       ex de,hl ; hl = y
040CA7 CD 06 09 04 0479*       call hlu_abs ; if y was negative this also sets the sign flag
040CAB EB          0480*       ex de,hl ; de = abs(y)
040CAC F5          0481*       push af ; store sign of y
040CAD             0482*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040CAD             0483*   ; this ensures that our lookup value is between 0 and 1 inclusive
040CAD AF          0484*       xor a ; clear the carry flag
040CAE D5          0485*       push de
040CAF E1          0486*       pop hl
040CB0 ED 42       0487*       sbc hl,bc
040CB2 F5          0488*       push af ; save sign of de - bc
040CB3 F2 BC 0C 04 0489*       jp p,@1 ; bc <= de, so we skip ahead
040CB7             0490*   ; otherwise we swap bc and de
040CB7 C5          0491*       push bc
040CB8 E1          0492*       pop hl
040CB9 EB          0493*       ex de,hl
040CBA E5          0494*       push hl
040CBB C1          0495*       pop bc
040CBC             0496*   @1:
040CBC             0497*   ; now we're ready to snag our preliminary result
040CBC C5          0498*       push bc
040CBD E1          0499*       pop hl
040CBE CD 2C 0D 04 0500*       call atan_168fast ; uh.l comes back with prelim result
040CC2             0501*   ; now we adjust uh.l based on sign of de - bc
040CC2 F1          0502*       pop af
040CC3 F2 CF 0C 04 0503*       jp p,@2 ; bc <= de,so we skip ahead
040CC7 EB          0504*       ex de,hl
040CC8 21 00 40 00 0505*       ld hl,64*256 ; subtract from 64 (90) degrees
040CCC AF          0506*       xor a ; clear the carry flag
040CCD ED 52       0507*       sbc hl,de
040CCF             0508*   @2:
040CCF             0509*   ; adjust the result based on quadrant
040CCF             0510*   ; #E0 224      0       32 #20
040CCF             0511*   ;        -x,-y | +x,-y
040CCF             0512*   ; #C0 192------+------ 64 #40
040CCF             0513*   ;        -x,+y | +x,+y
040CCF             0514*   ; #A0 160   128 #80   96 #60
040CCF F1          0515*       pop af ; sign of y
040CD0 CA 0D 0D 04 0516*       jp z,@y_zero
040CD4 F2 ED 0C 04 0517*       jp p,@y_pos
040CD8             0518*   ; y neg,check x
040CD8 F1          0519*       pop af ; sign of x
040CD9 CA E7 0C 04 0520*       jp z,@y_neg_x_zero
040CDD F2 EC 0C 04 0521*       jp p,@y_neg_x_pos
040CE1             0522*   ; y neg,x neg
040CE1             0523*   ; angle is 128 to 256 (270 to 360)
040CE1             0524*   ; negating the intermediate does the trick
040CE1 CD 16 09 04 0525*       call neg_hlu
040CE5 18 31       0526*       jr @zero_hlu
040CE7             0527*   
040CE7             0528*   @y_neg_x_zero:
040CE7             0529*   ; y neg,x zero
040CE7             0530*   ; angle is 0
040CE7 21 00 00 00 0531*       ld hl,0
040CEB C9          0532*       ret
040CEC             0533*   @y_neg_x_pos:
040CEC             0534*   ; y neg,x pos
040CEC             0535*   ; angle is 0 to 64 (0 to 90)
040CEC             0536*   ; so we're good
040CEC C9          0537*       ret
040CED             0538*   
040CED             0539*   @y_pos:
040CED F1          0540*       pop af ; sign of x
040CEE CA FD 0C 04 0541*       jp z,@y_pos_x_zero
040CF2 F2 02 0D 04 0542*       jp p,@y_pos_x_pos
040CF6             0543*   ; y pos,x neg
040CF6             0544*   ; angle is 128 to 192 (180-270)
040CF6             0545*   ; so we add 128 to intermediate
040CF6 11 00 80 00 0546*       ld de,128*256
040CFA 19          0547*       add hl,de
040CFB 18 1B       0548*       jr @zero_hlu
040CFD             0549*   @y_pos_x_zero:
040CFD             0550*   ; y pos,x zero
040CFD             0551*   ; angle is 128 (180)
040CFD 21 00 80 00 0552*       ld hl,128*256
040D01 C9          0553*       ret
040D02             0554*   @y_pos_x_pos:
040D02             0555*   ; y pos,x pos
040D02             0556*   ; angle is 64 to 128 (90 to 180)
040D02             0557*   ; neg the intermediate and add 180 degrees
040D02 CD 16 09 04 0558*       call neg_hlu
040D06 11 00 80 00 0559*       ld de,128*256
040D0A 19          0560*       add hl,de
040D0B 18 0B       0561*       jr @zero_hlu
040D0D             0562*   
040D0D             0563*   @y_zero:
040D0D F1          0564*       pop af ; sign of x
040D0E FA 13 0D 04 0565*       jp m,@y_zero_x_neg
040D12             0566*   ; y zero,x pos
040D12             0567*   ; angle is 64 (90),nothing to do
040D12 C9          0568*       ret
040D13             0569*   @y_zero_x_neg:
040D13             0570*   ; y zero ,x neg
040D13             0571*   ; angle is 192 (270)
040D13 21 00 C0 00 0572*       ld hl,192*256
040D17 C9          0573*       ret
040D18             0574*   @zero_hlu:
040D18 AF          0575*       xor a
040D19 22 26 0D 04 0576*       ld (@scratch),hl
040D1D 32 28 0D 04 0577*       ld (@scratch+2),a
040D21 2A 26 0D 04 0578*       ld hl,(@scratch)
040D25 C9          0579*       ret
040D26             0580*   @scratch: ds 6
040D2C             0581*   
040D2C             0582*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040D2C             0583*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040D2C             0584*   ; destroys: a,hl,bc,de
040D2C             0585*   ; note: only works for angles from 0 to 32 (45) degrees
040D2C             0586*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040D2C             0587*   atan_168fast:
040D2C             0588*   ; because we use compass headings instead of geometric angles
040D2C             0589*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040D2C             0590*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040D2C CD ED 0A 04 0591*       call udiv168 ; ud.e = dx/dy
040D30 EB          0592*       ex de,hl ; uh.l = dx/dy
040D31             0593*   ; test uh.l for 0
040D31 19          0594*       add hl,de
040D32 B7          0595*       or a
040D33 ED 52       0596*       sbc hl,de
040D35 28 22       0597*       jr z,@is_zero
040D37             0598*   ; test uh.l for 1
040D37 AF          0599*       xor a ; clear carry
040D38 EB          0600*       ex de,hl
040D39 21 00 01 00 0601*       ld hl,1*256 ; 1 in 16.8 fixed format
040D3D ED 52       0602*       sbc hl,de
040D3F 28 13       0603*       jr z,@is_45
040D41 EB          0604*       ex de,hl
040D42             0605*   ; no special cases so we move on
040D42             0606*   ; l contains the fractional portion of tan(uh.l)
040D42             0607*   ; we multiply it by three to get our lookup table index
040D42 26 03       0608*       ld h,3
040D44 ED 6C       0609*       mlt hl ; index into lut
040D46 11 00 00 00 0610*       ld de,0 ; clear deu
040D4A 54          0611*       ld d,h ; copy hl to de
040D4B 5D          0612*       ld e,l ; de contains our index
040D4C 21 51 11 04 0613*       ld hl,atan_lut_168 ; grab the lut address
040D50 19          0614*       add hl,de ; bump hl by the index
040D51 ED 27       0615*       ld hl,(hl) ; don't try this on a z80!
040D53 C9          0616*       ret ; and out
040D54             0617*   @is_45:
040D54 21 00 20 00 0618*       ld hl,32*256
040D58 C9          0619*       ret
040D59             0620*   ; for the case tan(0)
040D59             0621*   @is_zero:
040D59 21 00 00 00 0622*       ld hl,0*256
040D5D C9          0623*       ret
040D5E             0624*   
040D5E             0625*   ; Expects  ADL mode
040D5E             0626*   ; Inputs:  UH.L
040D5E             0627*   ; Outputs: UH.L is the 16.8 square root
040D5E             0628*   ;          UDE is the integer difference inputHL-DE^2
040D5E             0629*   sqrt168:
040D5E CD 68 0D 04 0630*       call sqrt24
040D62 EB          0631*       ex de,hl
040D63 29          0632*       add hl,hl
040D64 29          0633*       add hl,hl
040D65 29          0634*       add hl,hl
040D66 29          0635*       add hl,hl
040D67 C9          0636*       ret
040D68             0637*   
040D68             0638*   ; credit: xeda112358
040D68             0639*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040D68             0640*   sqrt24:
040D68             0641*   ; Expects ADL mode
040D68             0642*   ; Inputs: HL
040D68             0643*   ; Outputs: DE is the integer square root
040D68             0644*   ;  HL is the difference inputHL-DE^2
040D68             0645*   ;  c flag reset
040D68 01 00 00 00 0646*       ld bc,0 ; clear bcu
040D6C 11 00 00 00 0647*       ld de,0 ; clear deu
040D70 AF          0648*       xor a
040D71 45          0649*       ld b,l
040D72 C5          0650*       push bc
040D73 47          0651*       ld b,a
040D74 6F          0652*       ld l,a
040D75             0653*   ; Iteration 1
040D75 29          0654*       add hl,hl
040D76 CB 11       0655*       rl c
040D78 29          0656*       add hl,hl
040D79 CB 11       0657*       rl c
040D7B 91          0658*       sub c
040D7C 30 04       0659*       jr nc,$+6
040D7E 1C          0660*       inc e
040D7F 1C          0661*       inc e
040D80 2F          0662*       cpl
040D81 4F          0663*       ld c,a
040D82             0664*   ; Iteration 2
040D82 29          0665*       add hl,hl
040D83 CB 11       0666*       rl c
040D85 29          0667*       add hl,hl
040D86 CB 11       0668*       rl c
040D88 CB 13       0669*       rl e
040D8A 7B          0670*       ld a,e
040D8B 91          0671*       sub c
040D8C 30 04       0672*       jr nc,$+6
040D8E 1C          0673*       inc e
040D8F 1C          0674*       inc e
040D90 2F          0675*       cpl
040D91 4F          0676*       ld c,a
040D92             0677*   ; Iteration 3
040D92 29          0678*       add hl,hl
040D93 CB 11       0679*       rl c
040D95 29          0680*       add hl,hl
040D96 CB 11       0681*       rl c
040D98 CB 13       0682*       rl e
040D9A 7B          0683*       ld a,e
040D9B 91          0684*       sub c
040D9C 30 04       0685*       jr nc,$+6
040D9E 1C          0686*       inc e
040D9F 1C          0687*       inc e
040DA0 2F          0688*       cpl
040DA1 4F          0689*       ld c,a
040DA2             0690*   ; Iteration 4
040DA2 29          0691*       add hl,hl
040DA3 CB 11       0692*       rl c
040DA5 29          0693*       add hl,hl
040DA6 CB 11       0694*       rl c
040DA8 CB 13       0695*       rl e
040DAA 7B          0696*       ld a,e
040DAB 91          0697*       sub c
040DAC 30 04       0698*       jr nc,$+6
040DAE 1C          0699*       inc e
040DAF 1C          0700*       inc e
040DB0 2F          0701*       cpl
040DB1 4F          0702*       ld c,a
040DB2             0703*   ; Iteration 5
040DB2 29          0704*       add hl,hl
040DB3 CB 11       0705*       rl c
040DB5 29          0706*       add hl,hl
040DB6 CB 11       0707*       rl c
040DB8 CB 13       0708*       rl e
040DBA 7B          0709*       ld a,e
040DBB 91          0710*       sub c
040DBC 30 04       0711*       jr nc,$+6
040DBE 1C          0712*       inc e
040DBF 1C          0713*       inc e
040DC0 2F          0714*       cpl
040DC1 4F          0715*       ld c,a
040DC2             0716*   ; Iteration 6
040DC2 29          0717*       add hl,hl
040DC3 CB 11       0718*       rl c
040DC5 29          0719*       add hl,hl
040DC6 CB 11       0720*       rl c
040DC8 CB 13       0721*       rl e
040DCA 7B          0722*       ld a,e
040DCB 91          0723*       sub c
040DCC 30 04       0724*       jr nc,$+6
040DCE 1C          0725*       inc e
040DCF 1C          0726*       inc e
040DD0 2F          0727*       cpl
040DD1 4F          0728*       ld c,a
040DD2             0729*   ; Iteration 7
040DD2 29          0730*       add hl,hl
040DD3 CB 11       0731*       rl c
040DD5 29          0732*       add hl,hl
040DD6 CB 11       0733*       rl c
040DD8 CB 10       0734*       rl b
040DDA EB          0735*       ex de,hl
040DDB 29          0736*       add hl,hl
040DDC E5          0737*       push hl
040DDD ED 42       0738*       sbc hl,bc
040DDF 30 06       0739*       jr nc,$+8
040DE1 7C          0740*       ld a,h
040DE2 2F          0741*       cpl
040DE3 47          0742*       ld b,a
040DE4 7D          0743*       ld a,l
040DE5 2F          0744*       cpl
040DE6 4F          0745*       ld c,a
040DE7 E1          0746*       pop hl
040DE8 30 02       0747*       jr nc,$+4
040DEA 23          0748*       inc hl
040DEB 23          0749*       inc hl
040DEC EB          0750*       ex de,hl
040DED             0751*   ; Iteration 8
040DED 29          0752*       add hl,hl
040DEE 69          0753*       ld l,c
040DEF 60          0754*       ld h,b
040DF0 ED 6A       0755*       adc hl,hl
040DF2 ED 6A       0756*       adc hl,hl
040DF4 EB          0757*       ex de,hl
040DF5 29          0758*       add hl,hl
040DF6 ED 52       0759*       sbc hl,de
040DF8 19          0760*       add hl,de
040DF9 EB          0761*       ex de,hl
040DFA 30 04       0762*       jr nc,$+6
040DFC ED 52       0763*       sbc hl,de
040DFE 13          0764*       inc de
040DFF 13          0765*       inc de
040E00             0766*   ; Iteration 9
040E00 F1          0767*       pop af
040E01 17          0768*       rla
040E02 ED 6A       0769*       adc hl,hl
040E04 17          0770*       rla
040E05 ED 6A       0771*       adc hl,hl
040E07 EB          0772*       ex de,hl
040E08 29          0773*       add hl,hl
040E09 ED 52       0774*       sbc hl,de
040E0B 19          0775*       add hl,de
040E0C EB          0776*       ex de,hl
040E0D 30 04       0777*       jr nc,$+6
040E0F ED 52       0778*       sbc hl,de
040E11 13          0779*       inc de
040E12 13          0780*       inc de
040E13             0781*   ; Iteration 10
040E13 17          0782*       rla
040E14 ED 6A       0783*       adc hl,hl
040E16 17          0784*       rla
040E17 ED 6A       0785*       adc hl,hl
040E19 EB          0786*       ex de,hl
040E1A 29          0787*       add hl,hl
040E1B ED 52       0788*       sbc hl,de
040E1D 19          0789*       add hl,de
040E1E EB          0790*       ex de,hl
040E1F 30 04       0791*       jr nc,$+6
040E21 ED 52       0792*       sbc hl,de
040E23 13          0793*       inc de
040E24 13          0794*       inc de
040E25             0795*   ; Iteration 11
040E25 17          0796*       rla
040E26 ED 6A       0797*       adc hl,hl
040E28 17          0798*       rla
040E29 ED 6A       0799*       adc hl,hl
040E2B EB          0800*       ex de,hl
040E2C 29          0801*       add hl,hl
040E2D ED 52       0802*       sbc hl,de
040E2F 19          0803*       add hl,de
040E30 EB          0804*       ex de,hl
040E31 30 04       0805*       jr nc,$+6
040E33 ED 52       0806*       sbc hl,de
040E35 13          0807*       inc de
040E36 13          0808*       inc de
040E37             0809*   ; Iteration 12
040E37 17          0810*       rla
040E38 ED 6A       0811*       adc hl,hl
040E3A 17          0812*       rla
040E3B ED 6A       0813*       adc hl,hl
040E3D EB          0814*       ex de,hl
040E3E 29          0815*       add hl,hl
040E3F ED 52       0816*       sbc hl,de
040E41 19          0817*       add hl,de
040E42 EB          0818*       ex de,hl
040E43 30 04       0819*       jr nc,$+6
040E45 ED 52       0820*       sbc hl,de
040E47 13          0821*       inc de
040E48 13          0822*       inc de
040E49 CB 1A       0823*       rr d
040E4B CB 1B       0824*       rr e
040E4D C9          0825*       ret
040E4E             0826*   
040E4E             0827*   sin_lut_168:
040E4E 00 00 00    0828*       dl 0x000000 ; 0.000 00, 0.000
040E51 06 00 00    0829*       dl 0x000006 ; 1.406 01, 0.025
040E54 0C 00 00    0830*       dl 0x00000C ; 2.813 02, 0.049
040E57 12 00 00    0831*       dl 0x000012 ; 4.219 03, 0.074
040E5A 19 00 00    0832*       dl 0x000019 ; 5.625 04, 0.098
040E5D 1F 00 00    0833*       dl 0x00001F ; 7.031 05, 0.122
040E60 25 00 00    0834*       dl 0x000025 ; 8.438 06, 0.147
040E63 2B 00 00    0835*       dl 0x00002B ; 9.844 07, 0.171
040E66 31 00 00    0836*       dl 0x000031 ; 11.250 08, 0.195
040E69 38 00 00    0837*       dl 0x000038 ; 12.656 09, 0.219
040E6C 3E 00 00    0838*       dl 0x00003E ; 14.063 0A, 0.243
040E6F 44 00 00    0839*       dl 0x000044 ; 15.469 0B, 0.267
040E72 4A 00 00    0840*       dl 0x00004A ; 16.875 0C, 0.290
040E75 50 00 00    0841*       dl 0x000050 ; 18.281 0D, 0.314
040E78 56 00 00    0842*       dl 0x000056 ; 19.688 0E, 0.337
040E7B 5C 00 00    0843*       dl 0x00005C ; 21.094 0F, 0.360
040E7E 61 00 00    0844*       dl 0x000061 ; 22.500 10, 0.383
040E81 67 00 00    0845*       dl 0x000067 ; 23.906 11, 0.405
040E84 6D 00 00    0846*       dl 0x00006D ; 25.313 12, 0.428
040E87 73 00 00    0847*       dl 0x000073 ; 26.719 13, 0.450
040E8A 78 00 00    0848*       dl 0x000078 ; 28.125 14, 0.471
040E8D 7E 00 00    0849*       dl 0x00007E ; 29.531 15, 0.493
040E90 83 00 00    0850*       dl 0x000083 ; 30.938 16, 0.514
040E93 88 00 00    0851*       dl 0x000088 ; 32.344 17, 0.535
040E96 8E 00 00    0852*       dl 0x00008E ; 33.750 18, 0.556
040E99 93 00 00    0853*       dl 0x000093 ; 35.156 19, 0.576
040E9C 98 00 00    0854*       dl 0x000098 ; 36.563 1A, 0.596
040E9F 9D 00 00    0855*       dl 0x00009D ; 37.969 1B, 0.615
040EA2 A2 00 00    0856*       dl 0x0000A2 ; 39.375 1C, 0.634
040EA5 A7 00 00    0857*       dl 0x0000A7 ; 40.781 1D, 0.653
040EA8 AB 00 00    0858*       dl 0x0000AB ; 42.188 1E, 0.672
040EAB B0 00 00    0859*       dl 0x0000B0 ; 43.594 1F, 0.690
040EAE B5 00 00    0860*       dl 0x0000B5 ; 45.000 20, 0.707
040EB1 B9 00 00    0861*       dl 0x0000B9 ; 46.406 21, 0.724
040EB4 BD 00 00    0862*       dl 0x0000BD ; 47.813 22, 0.741
040EB7 C1 00 00    0863*       dl 0x0000C1 ; 49.219 23, 0.757
040EBA C5 00 00    0864*       dl 0x0000C5 ; 50.625 24, 0.773
040EBD C9 00 00    0865*       dl 0x0000C9 ; 52.031 25, 0.788
040EC0 CD 00 00    0866*       dl 0x0000CD ; 53.438 26, 0.803
040EC3 D1 00 00    0867*       dl 0x0000D1 ; 54.844 27, 0.818
040EC6 D4 00 00    0868*       dl 0x0000D4 ; 56.250 28, 0.831
040EC9 D8 00 00    0869*       dl 0x0000D8 ; 57.656 29, 0.845
040ECC DB 00 00    0870*       dl 0x0000DB ; 59.063 2A, 0.858
040ECF DE 00 00    0871*       dl 0x0000DE ; 60.469 2B, 0.870
040ED2 E1 00 00    0872*       dl 0x0000E1 ; 61.875 2C, 0.882
040ED5 E4 00 00    0873*       dl 0x0000E4 ; 63.281 2D, 0.893
040ED8 E7 00 00    0874*       dl 0x0000E7 ; 64.688 2E, 0.904
040EDB EA 00 00    0875*       dl 0x0000EA ; 66.094 2F, 0.914
040EDE EC 00 00    0876*       dl 0x0000EC ; 67.500 30, 0.924
040EE1 EE 00 00    0877*       dl 0x0000EE ; 68.906 31, 0.933
040EE4 F1 00 00    0878*       dl 0x0000F1 ; 70.313 32, 0.942
040EE7 F3 00 00    0879*       dl 0x0000F3 ; 71.719 33, 0.950
040EEA F4 00 00    0880*       dl 0x0000F4 ; 73.125 34, 0.957
040EED F6 00 00    0881*       dl 0x0000F6 ; 74.531 35, 0.964
040EF0 F8 00 00    0882*       dl 0x0000F8 ; 75.938 36, 0.970
040EF3 F9 00 00    0883*       dl 0x0000F9 ; 77.344 37, 0.976
040EF6 FB 00 00    0884*       dl 0x0000FB ; 78.750 38, 0.981
040EF9 FC 00 00    0885*       dl 0x0000FC ; 80.156 39, 0.985
040EFC FD 00 00    0886*       dl 0x0000FD ; 81.563 3A, 0.989
040EFF FE 00 00    0887*       dl 0x0000FE ; 82.969 3B, 0.992
040F02 FE 00 00    0888*       dl 0x0000FE ; 84.375 3C, 0.995
040F05 FF 00 00    0889*       dl 0x0000FF ; 85.781 3D, 0.997
040F08 FF 00 00    0890*       dl 0x0000FF ; 87.188 3E, 0.999
040F0B FF 00 00    0891*       dl 0x0000FF ; 88.594 3F, 1.000
040F0E 00 01 00    0892*       dl 0x000100 ; 90.000 40, 1.000
040F11 FF 00 00    0893*       dl 0x0000FF ; 91.406 41, 1.000
040F14 FF 00 00    0894*       dl 0x0000FF ; 92.813 42, 0.999
040F17 FF 00 00    0895*       dl 0x0000FF ; 94.219 43, 0.997
040F1A FE 00 00    0896*       dl 0x0000FE ; 95.625 44, 0.995
040F1D FE 00 00    0897*       dl 0x0000FE ; 97.031 45, 0.992
040F20 FD 00 00    0898*       dl 0x0000FD ; 98.438 46, 0.989
040F23 FC 00 00    0899*       dl 0x0000FC ; 99.844 47, 0.985
040F26 FB 00 00    0900*       dl 0x0000FB ; 101.250 48, 0.981
040F29 F9 00 00    0901*       dl 0x0000F9 ; 102.656 49, 0.976
040F2C F8 00 00    0902*       dl 0x0000F8 ; 104.063 4A, 0.970
040F2F F6 00 00    0903*       dl 0x0000F6 ; 105.469 4B, 0.964
040F32 F4 00 00    0904*       dl 0x0000F4 ; 106.875 4C, 0.957
040F35 F3 00 00    0905*       dl 0x0000F3 ; 108.281 4D, 0.950
040F38 F1 00 00    0906*       dl 0x0000F1 ; 109.688 4E, 0.942
040F3B EE 00 00    0907*       dl 0x0000EE ; 111.094 4F, 0.933
040F3E EC 00 00    0908*       dl 0x0000EC ; 112.500 50, 0.924
040F41 EA 00 00    0909*       dl 0x0000EA ; 113.906 51, 0.914
040F44 E7 00 00    0910*       dl 0x0000E7 ; 115.313 52, 0.904
040F47 E4 00 00    0911*       dl 0x0000E4 ; 116.719 53, 0.893
040F4A E1 00 00    0912*       dl 0x0000E1 ; 118.125 54, 0.882
040F4D DE 00 00    0913*       dl 0x0000DE ; 119.531 55, 0.870
040F50 DB 00 00    0914*       dl 0x0000DB ; 120.938 56, 0.858
040F53 D8 00 00    0915*       dl 0x0000D8 ; 122.344 57, 0.845
040F56 D4 00 00    0916*       dl 0x0000D4 ; 123.750 58, 0.831
040F59 D1 00 00    0917*       dl 0x0000D1 ; 125.156 59, 0.818
040F5C CD 00 00    0918*       dl 0x0000CD ; 126.563 5A, 0.803
040F5F C9 00 00    0919*       dl 0x0000C9 ; 127.969 5B, 0.788
040F62 C5 00 00    0920*       dl 0x0000C5 ; 129.375 5C, 0.773
040F65 C1 00 00    0921*       dl 0x0000C1 ; 130.781 5D, 0.757
040F68 BD 00 00    0922*       dl 0x0000BD ; 132.188 5E, 0.741
040F6B B9 00 00    0923*       dl 0x0000B9 ; 133.594 5F, 0.724
040F6E B5 00 00    0924*       dl 0x0000B5 ; 135.000 60, 0.707
040F71 B0 00 00    0925*       dl 0x0000B0 ; 136.406 61, 0.690
040F74 AB 00 00    0926*       dl 0x0000AB ; 137.813 62, 0.672
040F77 A7 00 00    0927*       dl 0x0000A7 ; 139.219 63, 0.653
040F7A A2 00 00    0928*       dl 0x0000A2 ; 140.625 64, 0.634
040F7D 9D 00 00    0929*       dl 0x00009D ; 142.031 65, 0.615
040F80 98 00 00    0930*       dl 0x000098 ; 143.438 66, 0.596
040F83 93 00 00    0931*       dl 0x000093 ; 144.844 67, 0.576
040F86 8E 00 00    0932*       dl 0x00008E ; 146.250 68, 0.556
040F89 88 00 00    0933*       dl 0x000088 ; 147.656 69, 0.535
040F8C 83 00 00    0934*       dl 0x000083 ; 149.063 6A, 0.514
040F8F 7E 00 00    0935*       dl 0x00007E ; 150.469 6B, 0.493
040F92 78 00 00    0936*       dl 0x000078 ; 151.875 6C, 0.471
040F95 73 00 00    0937*       dl 0x000073 ; 153.281 6D, 0.450
040F98 6D 00 00    0938*       dl 0x00006D ; 154.688 6E, 0.428
040F9B 67 00 00    0939*       dl 0x000067 ; 156.094 6F, 0.405
040F9E 61 00 00    0940*       dl 0x000061 ; 157.500 70, 0.383
040FA1 5C 00 00    0941*       dl 0x00005C ; 158.906 71, 0.360
040FA4 56 00 00    0942*       dl 0x000056 ; 160.313 72, 0.337
040FA7 50 00 00    0943*       dl 0x000050 ; 161.719 73, 0.314
040FAA 4A 00 00    0944*       dl 0x00004A ; 163.125 74, 0.290
040FAD 44 00 00    0945*       dl 0x000044 ; 164.531 75, 0.267
040FB0 3E 00 00    0946*       dl 0x00003E ; 165.938 76, 0.243
040FB3 38 00 00    0947*       dl 0x000038 ; 167.344 77, 0.219
040FB6 31 00 00    0948*       dl 0x000031 ; 168.750 78, 0.195
040FB9 2B 00 00    0949*       dl 0x00002B ; 170.156 79, 0.171
040FBC 25 00 00    0950*       dl 0x000025 ; 171.563 7A, 0.147
040FBF 1F 00 00    0951*       dl 0x00001F ; 172.969 7B, 0.122
040FC2 19 00 00    0952*       dl 0x000019 ; 174.375 7C, 0.098
040FC5 12 00 00    0953*       dl 0x000012 ; 175.781 7D, 0.074
040FC8 0C 00 00    0954*       dl 0x00000C ; 177.188 7E, 0.049
040FCB 06 00 00    0955*       dl 0x000006 ; 178.594 7F, 0.025
040FCE 00 00 00    0956*       dl 0x000000 ; 180.000 80, 0.000
040FD1 FA FF FF    0957*       dl 0xFFFFFA ; 181.406 81, -0.025
040FD4 F4 FF FF    0958*       dl 0xFFFFF4 ; 182.813 82, -0.049
040FD7 EE FF FF    0959*       dl 0xFFFFEE ; 184.219 83, -0.074
040FDA E7 FF FF    0960*       dl 0xFFFFE7 ; 185.625 84, -0.098
040FDD E1 FF FF    0961*       dl 0xFFFFE1 ; 187.031 85, -0.122
040FE0 DB FF FF    0962*       dl 0xFFFFDB ; 188.438 86, -0.147
040FE3 D5 FF FF    0963*       dl 0xFFFFD5 ; 189.844 87, -0.171
040FE6 CF FF FF    0964*       dl 0xFFFFCF ; 191.250 88, -0.195
040FE9 C8 FF FF    0965*       dl 0xFFFFC8 ; 192.656 89, -0.219
040FEC C2 FF FF    0966*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040FEF BC FF FF    0967*       dl 0xFFFFBC ; 195.469 8B, -0.267
040FF2 B6 FF FF    0968*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040FF5 B0 FF FF    0969*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040FF8 AA FF FF    0970*       dl 0xFFFFAA ; 199.688 8E, -0.337
040FFB A4 FF FF    0971*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040FFE 9F FF FF    0972*       dl 0xFFFF9F ; 202.500 90, -0.383
041001 99 FF FF    0973*       dl 0xFFFF99 ; 203.906 91, -0.405
041004 93 FF FF    0974*       dl 0xFFFF93 ; 205.313 92, -0.428
041007 8D FF FF    0975*       dl 0xFFFF8D ; 206.719 93, -0.450
04100A 88 FF FF    0976*       dl 0xFFFF88 ; 208.125 94, -0.471
04100D 82 FF FF    0977*       dl 0xFFFF82 ; 209.531 95, -0.493
041010 7D FF FF    0978*       dl 0xFFFF7D ; 210.938 96, -0.514
041013 78 FF FF    0979*       dl 0xFFFF78 ; 212.344 97, -0.535
041016 72 FF FF    0980*       dl 0xFFFF72 ; 213.750 98, -0.556
041019 6D FF FF    0981*       dl 0xFFFF6D ; 215.156 99, -0.576
04101C 68 FF FF    0982*       dl 0xFFFF68 ; 216.563 9A, -0.596
04101F 63 FF FF    0983*       dl 0xFFFF63 ; 217.969 9B, -0.615
041022 5E FF FF    0984*       dl 0xFFFF5E ; 219.375 9C, -0.634
041025 59 FF FF    0985*       dl 0xFFFF59 ; 220.781 9D, -0.653
041028 55 FF FF    0986*       dl 0xFFFF55 ; 222.188 9E, -0.672
04102B 50 FF FF    0987*       dl 0xFFFF50 ; 223.594 9F, -0.690
04102E 4B FF FF    0988*       dl 0xFFFF4B ; 225.000 A0, -0.707
041031 47 FF FF    0989*       dl 0xFFFF47 ; 226.406 A1, -0.724
041034 43 FF FF    0990*       dl 0xFFFF43 ; 227.813 A2, -0.741
041037 3F FF FF    0991*       dl 0xFFFF3F ; 229.219 A3, -0.757
04103A 3B FF FF    0992*       dl 0xFFFF3B ; 230.625 A4, -0.773
04103D 37 FF FF    0993*       dl 0xFFFF37 ; 232.031 A5, -0.788
041040 33 FF FF    0994*       dl 0xFFFF33 ; 233.438 A6, -0.803
041043 2F FF FF    0995*       dl 0xFFFF2F ; 234.844 A7, -0.818
041046 2C FF FF    0996*       dl 0xFFFF2C ; 236.250 A8, -0.831
041049 28 FF FF    0997*       dl 0xFFFF28 ; 237.656 A9, -0.845
04104C 25 FF FF    0998*       dl 0xFFFF25 ; 239.063 AA, -0.858
04104F 22 FF FF    0999*       dl 0xFFFF22 ; 240.469 AB, -0.870
041052 1F FF FF    1000*       dl 0xFFFF1F ; 241.875 AC, -0.882
041055 1C FF FF    1001*       dl 0xFFFF1C ; 243.281 AD, -0.893
041058 19 FF FF    1002*       dl 0xFFFF19 ; 244.688 AE, -0.904
04105B 16 FF FF    1003*       dl 0xFFFF16 ; 246.094 AF, -0.914
04105E 14 FF FF    1004*       dl 0xFFFF14 ; 247.500 B0, -0.924
041061 12 FF FF    1005*       dl 0xFFFF12 ; 248.906 B1, -0.933
041064 0F FF FF    1006*       dl 0xFFFF0F ; 250.313 B2, -0.942
041067 0D FF FF    1007*       dl 0xFFFF0D ; 251.719 B3, -0.950
04106A 0C FF FF    1008*       dl 0xFFFF0C ; 253.125 B4, -0.957
04106D 0A FF FF    1009*       dl 0xFFFF0A ; 254.531 B5, -0.964
041070 08 FF FF    1010*       dl 0xFFFF08 ; 255.938 B6, -0.970
041073 07 FF FF    1011*       dl 0xFFFF07 ; 257.344 B7, -0.976
041076 05 FF FF    1012*       dl 0xFFFF05 ; 258.750 B8, -0.981
041079 04 FF FF    1013*       dl 0xFFFF04 ; 260.156 B9, -0.985
04107C 03 FF FF    1014*       dl 0xFFFF03 ; 261.563 BA, -0.989
04107F 02 FF FF    1015*       dl 0xFFFF02 ; 262.969 BB, -0.992
041082 02 FF FF    1016*       dl 0xFFFF02 ; 264.375 BC, -0.995
041085 01 FF FF    1017*       dl 0xFFFF01 ; 265.781 BD, -0.997
041088 01 FF FF    1018*       dl 0xFFFF01 ; 267.188 BE, -0.999
04108B 01 FF FF    1019*       dl 0xFFFF01 ; 268.594 BF, -1.000
04108E 00 FF FF    1020*       dl 0xFFFF00 ; 270.000 C0, -1.000
041091 01 FF FF    1021*       dl 0xFFFF01 ; 271.406 C1, -1.000
041094 01 FF FF    1022*       dl 0xFFFF01 ; 272.813 C2, -0.999
041097 01 FF FF    1023*       dl 0xFFFF01 ; 274.219 C3, -0.997
04109A 02 FF FF    1024*       dl 0xFFFF02 ; 275.625 C4, -0.995
04109D 02 FF FF    1025*       dl 0xFFFF02 ; 277.031 C5, -0.992
0410A0 03 FF FF    1026*       dl 0xFFFF03 ; 278.438 C6, -0.989
0410A3 04 FF FF    1027*       dl 0xFFFF04 ; 279.844 C7, -0.985
0410A6 05 FF FF    1028*       dl 0xFFFF05 ; 281.250 C8, -0.981
0410A9 07 FF FF    1029*       dl 0xFFFF07 ; 282.656 C9, -0.976
0410AC 08 FF FF    1030*       dl 0xFFFF08 ; 284.063 CA, -0.970
0410AF 0A FF FF    1031*       dl 0xFFFF0A ; 285.469 CB, -0.964
0410B2 0C FF FF    1032*       dl 0xFFFF0C ; 286.875 CC, -0.957
0410B5 0D FF FF    1033*       dl 0xFFFF0D ; 288.281 CD, -0.950
0410B8 0F FF FF    1034*       dl 0xFFFF0F ; 289.688 CE, -0.942
0410BB 12 FF FF    1035*       dl 0xFFFF12 ; 291.094 CF, -0.933
0410BE 14 FF FF    1036*       dl 0xFFFF14 ; 292.500 D0, -0.924
0410C1 16 FF FF    1037*       dl 0xFFFF16 ; 293.906 D1, -0.914
0410C4 19 FF FF    1038*       dl 0xFFFF19 ; 295.313 D2, -0.904
0410C7 1C FF FF    1039*       dl 0xFFFF1C ; 296.719 D3, -0.893
0410CA 1F FF FF    1040*       dl 0xFFFF1F ; 298.125 D4, -0.882
0410CD 22 FF FF    1041*       dl 0xFFFF22 ; 299.531 D5, -0.870
0410D0 25 FF FF    1042*       dl 0xFFFF25 ; 300.938 D6, -0.858
0410D3 28 FF FF    1043*       dl 0xFFFF28 ; 302.344 D7, -0.845
0410D6 2C FF FF    1044*       dl 0xFFFF2C ; 303.750 D8, -0.831
0410D9 2F FF FF    1045*       dl 0xFFFF2F ; 305.156 D9, -0.818
0410DC 33 FF FF    1046*       dl 0xFFFF33 ; 306.563 DA, -0.803
0410DF 37 FF FF    1047*       dl 0xFFFF37 ; 307.969 DB, -0.788
0410E2 3B FF FF    1048*       dl 0xFFFF3B ; 309.375 DC, -0.773
0410E5 3F FF FF    1049*       dl 0xFFFF3F ; 310.781 DD, -0.757
0410E8 43 FF FF    1050*       dl 0xFFFF43 ; 312.188 DE, -0.741
0410EB 47 FF FF    1051*       dl 0xFFFF47 ; 313.594 DF, -0.724
0410EE 4B FF FF    1052*       dl 0xFFFF4B ; 315.000 E0, -0.707
0410F1 50 FF FF    1053*       dl 0xFFFF50 ; 316.406 E1, -0.690
0410F4 55 FF FF    1054*       dl 0xFFFF55 ; 317.813 E2, -0.672
0410F7 59 FF FF    1055*       dl 0xFFFF59 ; 319.219 E3, -0.653
0410FA 5E FF FF    1056*       dl 0xFFFF5E ; 320.625 E4, -0.634
0410FD 63 FF FF    1057*       dl 0xFFFF63 ; 322.031 E5, -0.615
041100 68 FF FF    1058*       dl 0xFFFF68 ; 323.438 E6, -0.596
041103 6D FF FF    1059*       dl 0xFFFF6D ; 324.844 E7, -0.576
041106 72 FF FF    1060*       dl 0xFFFF72 ; 326.250 E8, -0.556
041109 78 FF FF    1061*       dl 0xFFFF78 ; 327.656 E9, -0.535
04110C 7D FF FF    1062*       dl 0xFFFF7D ; 329.063 EA, -0.514
04110F 82 FF FF    1063*       dl 0xFFFF82 ; 330.469 EB, -0.493
041112 88 FF FF    1064*       dl 0xFFFF88 ; 331.875 EC, -0.471
041115 8D FF FF    1065*       dl 0xFFFF8D ; 333.281 ED, -0.450
041118 93 FF FF    1066*       dl 0xFFFF93 ; 334.688 EE, -0.428
04111B 99 FF FF    1067*       dl 0xFFFF99 ; 336.094 EF, -0.405
04111E 9F FF FF    1068*       dl 0xFFFF9F ; 337.500 F0, -0.383
041121 A4 FF FF    1069*       dl 0xFFFFA4 ; 338.906 F1, -0.360
041124 AA FF FF    1070*       dl 0xFFFFAA ; 340.313 F2, -0.337
041127 B0 FF FF    1071*       dl 0xFFFFB0 ; 341.719 F3, -0.314
04112A B6 FF FF    1072*       dl 0xFFFFB6 ; 343.125 F4, -0.290
04112D BC FF FF    1073*       dl 0xFFFFBC ; 344.531 F5, -0.267
041130 C2 FF FF    1074*       dl 0xFFFFC2 ; 345.938 F6, -0.243
041133 C8 FF FF    1075*       dl 0xFFFFC8 ; 347.344 F7, -0.219
041136 CF FF FF    1076*       dl 0xFFFFCF ; 348.750 F8, -0.195
041139 D5 FF FF    1077*       dl 0xFFFFD5 ; 350.156 F9, -0.171
04113C DB FF FF    1078*       dl 0xFFFFDB ; 351.563 FA, -0.147
04113F E1 FF FF    1079*       dl 0xFFFFE1 ; 352.969 FB, -0.122
041142 E7 FF FF    1080*       dl 0xFFFFE7 ; 354.375 FC, -0.098
041145 EE FF FF    1081*       dl 0xFFFFEE ; 355.781 FD, -0.074
041148 F4 FF FF    1082*       dl 0xFFFFF4 ; 357.188 FE, -0.049
04114B FA FF FF    1083*       dl 0xFFFFFA ; 358.594 FF, -0.025
04114E 00 00 00    1084*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
041151             1085*   
041151             1086*   atan_lut_168:
041151 00 00 00    1087*       dl 0x000000 ; 000000, 0.000
041154 28 00 00    1088*       dl 0x000028 ; 000001, 0.224
041157 51 00 00    1089*       dl 0x000051 ; 000002, 0.448
04115A 7A 00 00    1090*       dl 0x00007A ; 000003, 0.671
04115D A2 00 00    1091*       dl 0x0000A2 ; 000004, 0.895
041160 CB 00 00    1092*       dl 0x0000CB ; 000005, 1.119
041163 F4 00 00    1093*       dl 0x0000F4 ; 000006, 1.343
041166 1D 01 00    1094*       dl 0x00011D ; 000007, 1.566
041169 45 01 00    1095*       dl 0x000145 ; 000008, 1.790
04116C 6E 01 00    1096*       dl 0x00016E ; 000009, 2.013
04116F 97 01 00    1097*       dl 0x000197 ; 00000A, 2.237
041172 BF 01 00    1098*       dl 0x0001BF ; 00000B, 2.460
041175 E8 01 00    1099*       dl 0x0001E8 ; 00000C, 2.684
041178 11 02 00    1100*       dl 0x000211 ; 00000D, 2.907
04117B 39 02 00    1101*       dl 0x000239 ; 00000E, 3.130
04117E 62 02 00    1102*       dl 0x000262 ; 00000F, 3.353
041181 8B 02 00    1103*       dl 0x00028B ; 000010, 3.576
041184 B3 02 00    1104*       dl 0x0002B3 ; 000011, 3.799
041187 DC 02 00    1105*       dl 0x0002DC ; 000012, 4.022
04118A 04 03 00    1106*       dl 0x000304 ; 000013, 4.245
04118D 2D 03 00    1107*       dl 0x00032D ; 000014, 4.467
041190 55 03 00    1108*       dl 0x000355 ; 000015, 4.690
041193 7E 03 00    1109*       dl 0x00037E ; 000016, 4.912
041196 A6 03 00    1110*       dl 0x0003A6 ; 000017, 5.134
041199 CE 03 00    1111*       dl 0x0003CE ; 000018, 5.356
04119C F7 03 00    1112*       dl 0x0003F7 ; 000019, 5.578
04119F 1F 04 00    1113*       dl 0x00041F ; 00001A, 5.799
0411A2 48 04 00    1114*       dl 0x000448 ; 00001B, 6.021
0411A5 70 04 00    1115*       dl 0x000470 ; 00001C, 6.242
0411A8 98 04 00    1116*       dl 0x000498 ; 00001D, 6.463
0411AB C0 04 00    1117*       dl 0x0004C0 ; 00001E, 6.684
0411AE E8 04 00    1118*       dl 0x0004E8 ; 00001F, 6.905
0411B1 11 05 00    1119*       dl 0x000511 ; 000020, 7.125
0411B4 39 05 00    1120*       dl 0x000539 ; 000021, 7.345
0411B7 61 05 00    1121*       dl 0x000561 ; 000022, 7.565
0411BA 89 05 00    1122*       dl 0x000589 ; 000023, 7.785
0411BD B1 05 00    1123*       dl 0x0005B1 ; 000024, 8.005
0411C0 D9 05 00    1124*       dl 0x0005D9 ; 000025, 8.224
0411C3 01 06 00    1125*       dl 0x000601 ; 000026, 8.443
0411C6 28 06 00    1126*       dl 0x000628 ; 000027, 8.662
0411C9 50 06 00    1127*       dl 0x000650 ; 000028, 8.881
0411CC 78 06 00    1128*       dl 0x000678 ; 000029, 9.099
0411CF A0 06 00    1129*       dl 0x0006A0 ; 00002A, 9.317
0411D2 C7 06 00    1130*       dl 0x0006C7 ; 00002B, 9.535
0411D5 EF 06 00    1131*       dl 0x0006EF ; 00002C, 9.752
0411D8 16 07 00    1132*       dl 0x000716 ; 00002D, 9.970
0411DB 3E 07 00    1133*       dl 0x00073E ; 00002E, 10.187
0411DE 65 07 00    1134*       dl 0x000765 ; 00002F, 10.403
0411E1 8D 07 00    1135*       dl 0x00078D ; 000030, 10.620
0411E4 B4 07 00    1136*       dl 0x0007B4 ; 000031, 10.836
0411E7 DB 07 00    1137*       dl 0x0007DB ; 000032, 11.051
0411EA 03 08 00    1138*       dl 0x000803 ; 000033, 11.267
0411ED 2A 08 00    1139*       dl 0x00082A ; 000034, 11.482
0411F0 51 08 00    1140*       dl 0x000851 ; 000035, 11.697
0411F3 78 08 00    1141*       dl 0x000878 ; 000036, 11.911
0411F6 9F 08 00    1142*       dl 0x00089F ; 000037, 12.125
0411F9 C6 08 00    1143*       dl 0x0008C6 ; 000038, 12.339
0411FC ED 08 00    1144*       dl 0x0008ED ; 000039, 12.553
0411FF 13 09 00    1145*       dl 0x000913 ; 00003A, 12.766
041202 3A 09 00    1146*       dl 0x00093A ; 00003B, 12.978
041205 61 09 00    1147*       dl 0x000961 ; 00003C, 13.191
041208 87 09 00    1148*       dl 0x000987 ; 00003D, 13.403
04120B AE 09 00    1149*       dl 0x0009AE ; 00003E, 13.614
04120E D4 09 00    1150*       dl 0x0009D4 ; 00003F, 13.825
041211 FB 09 00    1151*       dl 0x0009FB ; 000040, 14.036
041214 21 0A 00    1152*       dl 0x000A21 ; 000041, 14.247
041217 47 0A 00    1153*       dl 0x000A47 ; 000042, 14.457
04121A 6D 0A 00    1154*       dl 0x000A6D ; 000043, 14.666
04121D 94 0A 00    1155*       dl 0x000A94 ; 000044, 14.876
041220 BA 0A 00    1156*       dl 0x000ABA ; 000045, 15.085
041223 E0 0A 00    1157*       dl 0x000AE0 ; 000046, 15.293
041226 05 0B 00    1158*       dl 0x000B05 ; 000047, 15.501
041229 2B 0B 00    1159*       dl 0x000B2B ; 000048, 15.709
04122C 51 0B 00    1160*       dl 0x000B51 ; 000049, 15.916
04122F 77 0B 00    1161*       dl 0x000B77 ; 00004A, 16.123
041232 9C 0B 00    1162*       dl 0x000B9C ; 00004B, 16.329
041235 C2 0B 00    1163*       dl 0x000BC2 ; 00004C, 16.535
041238 E7 0B 00    1164*       dl 0x000BE7 ; 00004D, 16.740
04123B 0C 0C 00    1165*       dl 0x000C0C ; 00004E, 16.945
04123E 32 0C 00    1166*       dl 0x000C32 ; 00004F, 17.150
041241 57 0C 00    1167*       dl 0x000C57 ; 000050, 17.354
041244 7C 0C 00    1168*       dl 0x000C7C ; 000051, 17.558
041247 A1 0C 00    1169*       dl 0x000CA1 ; 000052, 17.761
04124A C6 0C 00    1170*       dl 0x000CC6 ; 000053, 17.964
04124D EB 0C 00    1171*       dl 0x000CEB ; 000054, 18.166
041250 0F 0D 00    1172*       dl 0x000D0F ; 000055, 18.368
041253 34 0D 00    1173*       dl 0x000D34 ; 000056, 18.569
041256 58 0D 00    1174*       dl 0x000D58 ; 000057, 18.770
041259 7D 0D 00    1175*       dl 0x000D7D ; 000058, 18.970
04125C A1 0D 00    1176*       dl 0x000DA1 ; 000059, 19.170
04125F C6 0D 00    1177*       dl 0x000DC6 ; 00005A, 19.370
041262 EA 0D 00    1178*       dl 0x000DEA ; 00005B, 19.569
041265 0E 0E 00    1179*       dl 0x000E0E ; 00005C, 19.767
041268 32 0E 00    1180*       dl 0x000E32 ; 00005D, 19.965
04126B 56 0E 00    1181*       dl 0x000E56 ; 00005E, 20.163
04126E 7A 0E 00    1182*       dl 0x000E7A ; 00005F, 20.360
041271 9E 0E 00    1183*       dl 0x000E9E ; 000060, 20.556
041274 C1 0E 00    1184*       dl 0x000EC1 ; 000061, 20.752
041277 E5 0E 00    1185*       dl 0x000EE5 ; 000062, 20.947
04127A 08 0F 00    1186*       dl 0x000F08 ; 000063, 21.142
04127D 2C 0F 00    1187*       dl 0x000F2C ; 000064, 21.337
041280 4F 0F 00    1188*       dl 0x000F4F ; 000065, 21.531
041283 72 0F 00    1189*       dl 0x000F72 ; 000066, 21.724
041286 95 0F 00    1190*       dl 0x000F95 ; 000067, 21.917
041289 B8 0F 00    1191*       dl 0x000FB8 ; 000068, 22.109
04128C DB 0F 00    1192*       dl 0x000FDB ; 000069, 22.301
04128F FE 0F 00    1193*       dl 0x000FFE ; 00006A, 22.493
041292 21 10 00    1194*       dl 0x001021 ; 00006B, 22.683
041295 44 10 00    1195*       dl 0x001044 ; 00006C, 22.874
041298 66 10 00    1196*       dl 0x001066 ; 00006D, 23.063
04129B 89 10 00    1197*       dl 0x001089 ; 00006E, 23.253
04129E AB 10 00    1198*       dl 0x0010AB ; 00006F, 23.441
0412A1 CD 10 00    1199*       dl 0x0010CD ; 000070, 23.629
0412A4 EF 10 00    1200*       dl 0x0010EF ; 000071, 23.817
0412A7 11 11 00    1201*       dl 0x001111 ; 000072, 24.004
0412AA 33 11 00    1202*       dl 0x001133 ; 000073, 24.191
0412AD 55 11 00    1203*       dl 0x001155 ; 000074, 24.376
0412B0 77 11 00    1204*       dl 0x001177 ; 000075, 24.562
0412B3 99 11 00    1205*       dl 0x001199 ; 000076, 24.747
0412B6 BA 11 00    1206*       dl 0x0011BA ; 000077, 24.931
0412B9 DC 11 00    1207*       dl 0x0011DC ; 000078, 25.115
0412BC FD 11 00    1208*       dl 0x0011FD ; 000079, 25.298
0412BF 1E 12 00    1209*       dl 0x00121E ; 00007A, 25.481
0412C2 3F 12 00    1210*       dl 0x00123F ; 00007B, 25.663
0412C5 60 12 00    1211*       dl 0x001260 ; 00007C, 25.844
0412C8 81 12 00    1212*       dl 0x001281 ; 00007D, 26.025
0412CB A2 12 00    1213*       dl 0x0012A2 ; 00007E, 26.206
0412CE C3 12 00    1214*       dl 0x0012C3 ; 00007F, 26.386
0412D1 E4 12 00    1215*       dl 0x0012E4 ; 000080, 26.565
0412D4 04 13 00    1216*       dl 0x001304 ; 000081, 26.744
0412D7 25 13 00    1217*       dl 0x001325 ; 000082, 26.922
0412DA 45 13 00    1218*       dl 0x001345 ; 000083, 27.100
0412DD 65 13 00    1219*       dl 0x001365 ; 000084, 27.277
0412E0 85 13 00    1220*       dl 0x001385 ; 000085, 27.453
0412E3 A5 13 00    1221*       dl 0x0013A5 ; 000086, 27.629
0412E6 C5 13 00    1222*       dl 0x0013C5 ; 000087, 27.805
0412E9 E5 13 00    1223*       dl 0x0013E5 ; 000088, 27.979
0412EC 05 14 00    1224*       dl 0x001405 ; 000089, 28.154
0412EF 24 14 00    1225*       dl 0x001424 ; 00008A, 28.327
0412F2 44 14 00    1226*       dl 0x001444 ; 00008B, 28.501
0412F5 63 14 00    1227*       dl 0x001463 ; 00008C, 28.673
0412F8 83 14 00    1228*       dl 0x001483 ; 00008D, 28.845
0412FB A2 14 00    1229*       dl 0x0014A2 ; 00008E, 29.017
0412FE C1 14 00    1230*       dl 0x0014C1 ; 00008F, 29.187
041301 E0 14 00    1231*       dl 0x0014E0 ; 000090, 29.358
041304 FF 14 00    1232*       dl 0x0014FF ; 000091, 29.527
041307 1E 15 00    1233*       dl 0x00151E ; 000092, 29.697
04130A 3C 15 00    1234*       dl 0x00153C ; 000093, 29.865
04130D 5B 15 00    1235*       dl 0x00155B ; 000094, 30.033
041310 79 15 00    1236*       dl 0x001579 ; 000095, 30.201
041313 98 15 00    1237*       dl 0x001598 ; 000096, 30.368
041316 B6 15 00    1238*       dl 0x0015B6 ; 000097, 30.534
041319 D4 15 00    1239*       dl 0x0015D4 ; 000098, 30.700
04131C F2 15 00    1240*       dl 0x0015F2 ; 000099, 30.865
04131F 10 16 00    1241*       dl 0x001610 ; 00009A, 31.030
041322 2E 16 00    1242*       dl 0x00162E ; 00009B, 31.194
041325 4C 16 00    1243*       dl 0x00164C ; 00009C, 31.357
041328 6A 16 00    1244*       dl 0x00166A ; 00009D, 31.520
04132B 87 16 00    1245*       dl 0x001687 ; 00009E, 31.682
04132E A5 16 00    1246*       dl 0x0016A5 ; 00009F, 31.844
041331 C2 16 00    1247*       dl 0x0016C2 ; 0000A0, 32.005
041334 DF 16 00    1248*       dl 0x0016DF ; 0000A1, 32.166
041337 FC 16 00    1249*       dl 0x0016FC ; 0000A2, 32.326
04133A 19 17 00    1250*       dl 0x001719 ; 0000A3, 32.486
04133D 36 17 00    1251*       dl 0x001736 ; 0000A4, 32.645
041340 53 17 00    1252*       dl 0x001753 ; 0000A5, 32.803
041343 70 17 00    1253*       dl 0x001770 ; 0000A6, 32.961
041346 8C 17 00    1254*       dl 0x00178C ; 0000A7, 33.118
041349 A9 17 00    1255*       dl 0x0017A9 ; 0000A8, 33.275
04134C C5 17 00    1256*       dl 0x0017C5 ; 0000A9, 33.431
04134F E2 17 00    1257*       dl 0x0017E2 ; 0000AA, 33.587
041352 FE 17 00    1258*       dl 0x0017FE ; 0000AB, 33.742
041355 1A 18 00    1259*       dl 0x00181A ; 0000AC, 33.896
041358 36 18 00    1260*       dl 0x001836 ; 0000AD, 34.050
04135B 52 18 00    1261*       dl 0x001852 ; 0000AE, 34.203
04135E 6E 18 00    1262*       dl 0x00186E ; 0000AF, 34.356
041361 8A 18 00    1263*       dl 0x00188A ; 0000B0, 34.509
041364 A5 18 00    1264*       dl 0x0018A5 ; 0000B1, 34.660
041367 C1 18 00    1265*       dl 0x0018C1 ; 0000B2, 34.811
04136A DC 18 00    1266*       dl 0x0018DC ; 0000B3, 34.962
04136D F7 18 00    1267*       dl 0x0018F7 ; 0000B4, 35.112
041370 13 19 00    1268*       dl 0x001913 ; 0000B5, 35.262
041373 2E 19 00    1269*       dl 0x00192E ; 0000B6, 35.410
041376 49 19 00    1270*       dl 0x001949 ; 0000B7, 35.559
041379 64 19 00    1271*       dl 0x001964 ; 0000B8, 35.707
04137C 7F 19 00    1272*       dl 0x00197F ; 0000B9, 35.854
04137F 99 19 00    1273*       dl 0x001999 ; 0000BA, 36.001
041382 B4 19 00    1274*       dl 0x0019B4 ; 0000BB, 36.147
041385 CE 19 00    1275*       dl 0x0019CE ; 0000BC, 36.293
041388 E9 19 00    1276*       dl 0x0019E9 ; 0000BD, 36.438
04138B 03 1A 00    1277*       dl 0x001A03 ; 0000BE, 36.582
04138E 1D 1A 00    1278*       dl 0x001A1D ; 0000BF, 36.726
041391 37 1A 00    1279*       dl 0x001A37 ; 0000C0, 36.870
041394 51 1A 00    1280*       dl 0x001A51 ; 0000C1, 37.013
041397 6B 1A 00    1281*       dl 0x001A6B ; 0000C2, 37.155
04139A 85 1A 00    1282*       dl 0x001A85 ; 0000C3, 37.297
04139D 9F 1A 00    1283*       dl 0x001A9F ; 0000C4, 37.439
0413A0 B9 1A 00    1284*       dl 0x001AB9 ; 0000C5, 37.579
0413A3 D2 1A 00    1285*       dl 0x001AD2 ; 0000C6, 37.720
0413A6 EC 1A 00    1286*       dl 0x001AEC ; 0000C7, 37.859
0413A9 05 1B 00    1287*       dl 0x001B05 ; 0000C8, 37.999
0413AC 1E 1B 00    1288*       dl 0x001B1E ; 0000C9, 38.137
0413AF 37 1B 00    1289*       dl 0x001B37 ; 0000CA, 38.276
0413B2 50 1B 00    1290*       dl 0x001B50 ; 0000CB, 38.413
0413B5 69 1B 00    1291*       dl 0x001B69 ; 0000CC, 38.550
0413B8 82 1B 00    1292*       dl 0x001B82 ; 0000CD, 38.687
0413BB 9B 1B 00    1293*       dl 0x001B9B ; 0000CE, 38.823
0413BE B4 1B 00    1294*       dl 0x001BB4 ; 0000CF, 38.959
0413C1 CC 1B 00    1295*       dl 0x001BCC ; 0000D0, 39.094
0413C4 E5 1B 00    1296*       dl 0x001BE5 ; 0000D1, 39.228
0413C7 FD 1B 00    1297*       dl 0x001BFD ; 0000D2, 39.362
0413CA 16 1C 00    1298*       dl 0x001C16 ; 0000D3, 39.496
0413CD 2E 1C 00    1299*       dl 0x001C2E ; 0000D4, 39.629
0413D0 46 1C 00    1300*       dl 0x001C46 ; 0000D5, 39.762
0413D3 5E 1C 00    1301*       dl 0x001C5E ; 0000D6, 39.894
0413D6 76 1C 00    1302*       dl 0x001C76 ; 0000D7, 40.025
0413D9 8E 1C 00    1303*       dl 0x001C8E ; 0000D8, 40.156
0413DC A5 1C 00    1304*       dl 0x001CA5 ; 0000D9, 40.286
0413DF BD 1C 00    1305*       dl 0x001CBD ; 0000DA, 40.416
0413E2 D5 1C 00    1306*       dl 0x001CD5 ; 0000DB, 40.546
0413E5 EC 1C 00    1307*       dl 0x001CEC ; 0000DC, 40.675
0413E8 04 1D 00    1308*       dl 0x001D04 ; 0000DD, 40.803
0413EB 1B 1D 00    1309*       dl 0x001D1B ; 0000DE, 40.931
0413EE 32 1D 00    1310*       dl 0x001D32 ; 0000DF, 41.059
0413F1 49 1D 00    1311*       dl 0x001D49 ; 0000E0, 41.186
0413F4 60 1D 00    1312*       dl 0x001D60 ; 0000E1, 41.312
0413F7 77 1D 00    1313*       dl 0x001D77 ; 0000E2, 41.438
0413FA 8E 1D 00    1314*       dl 0x001D8E ; 0000E3, 41.564
0413FD A5 1D 00    1315*       dl 0x001DA5 ; 0000E4, 41.689
041400 BB 1D 00    1316*       dl 0x001DBB ; 0000E5, 41.814
041403 D2 1D 00    1317*       dl 0x001DD2 ; 0000E6, 41.938
041406 E9 1D 00    1318*       dl 0x001DE9 ; 0000E7, 42.061
041409 FF 1D 00    1319*       dl 0x001DFF ; 0000E8, 42.184
04140C 15 1E 00    1320*       dl 0x001E15 ; 0000E9, 42.307
04140F 2C 1E 00    1321*       dl 0x001E2C ; 0000EA, 42.429
041412 42 1E 00    1322*       dl 0x001E42 ; 0000EB, 42.551
041415 58 1E 00    1323*       dl 0x001E58 ; 0000EC, 42.672
041418 6E 1E 00    1324*       dl 0x001E6E ; 0000ED, 42.793
04141B 84 1E 00    1325*       dl 0x001E84 ; 0000EE, 42.913
04141E 99 1E 00    1326*       dl 0x001E99 ; 0000EF, 43.033
041421 AF 1E 00    1327*       dl 0x001EAF ; 0000F0, 43.152
041424 C5 1E 00    1328*       dl 0x001EC5 ; 0000F1, 43.271
041427 DA 1E 00    1329*       dl 0x001EDA ; 0000F2, 43.390
04142A F0 1E 00    1330*       dl 0x001EF0 ; 0000F3, 43.508
04142D 05 1F 00    1331*       dl 0x001F05 ; 0000F4, 43.625
041430 1B 1F 00    1332*       dl 0x001F1B ; 0000F5, 43.742
041433 30 1F 00    1333*       dl 0x001F30 ; 0000F6, 43.859
041436 45 1F 00    1334*       dl 0x001F45 ; 0000F7, 43.975
041439 5A 1F 00    1335*       dl 0x001F5A ; 0000F8, 44.091
04143C 6F 1F 00    1336*       dl 0x001F6F ; 0000F9, 44.206
04143F 84 1F 00    1337*       dl 0x001F84 ; 0000FA, 44.321
041442 99 1F 00    1338*       dl 0x001F99 ; 0000FB, 44.435
041445 AD 1F 00    1339*       dl 0x001FAD ; 0000FC, 44.549
041448 C2 1F 00    1340*       dl 0x001FC2 ; 0000FD, 44.662
04144B D7 1F 00    1341*       dl 0x001FD7 ; 0000FE, 44.775
04144E EB 1F 00    1342*       dl 0x001FEB ; 0000FF, 44.888
041451 00 20 00    1343*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041454             0035        ; include "fonts.inc"
041454             0036        ; include "images.inc"
041454             0037        include "timer.inc"
041454 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
041500             0002*   
041500             0003*   ; Table 32. Timer Control Registers
041500             0004*   ; this constant is the base address of the timer control registers
041500             0005*   ; each timer takes three bytes:
041500             0006*   ;   0: control register
041500             0007*   ;   1: low byte of timer reset value
041500             0008*   ;   2: high byte of timer reset value
041500             0009*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041500             0010*   ; which correctly force the high and upper bytes of the address bus to zero
041500             0011*   TMR_CTL:     equ 80h
041500             0012*   
041500             0013*   ; Timer Control Register Bit Definitions
041500             0014*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041500             0015*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041500             0016*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041500             0017*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041500             0018*                               ; the TMRx_CTL register is read.
041500             0019*   
041500             0020*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041500             0021*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041500             0022*   
041500             0023*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041500             0024*                               ;  0,and counting stops when the end-of-count value is reached.
041500             0025*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041500             0026*                               ; written to the counter when the end-of-count value is reached.
041500             0027*   
041500             0028*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041500             0029*   CLK_DIV_256:  equ %00001100 ;
041500             0030*   CLK_DIV_64:   equ %00001000 ;
041500             0031*   CLK_DIV_16:   equ %00000100 ;
041500             0032*   CLK_DIV_4:    equ %00000000 ;
041500             0033*   
041500             0034*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041500             0035*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041500             0036*                               ; When a 1 is written to this bit,the values in the reload registers
041500             0037*                               ;  are loaded into the downcounter when the timer restarts. The
041500             0038*                               ; programmer must ensure that this bit is set to 1 each time
041500             0039*                               ; SINGLE-PASS mode is used.
041500             0040*   
041500             0041*   ; disable/enable the programmable reload timer
041500             0042*   PRT_EN_0:     equ %00000000 ;
041500             0043*   PRT_EN_1:     equ %00000001 ;
041500             0044*   
041500             0045*   ; Table 37. Timer Input Source Select Register
041500             0046*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041500             0047*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041500             0048*   ;   00: System clock / CLK_DIV
041500             0049*   ;   01: RTC / CLK_DIV
041500             0050*   ;   NOTE: these are the values given in the manual,but it may be a typo
041500             0051*   ;   10: GPIO port B pin 1.
041500             0052*   ;   11: GPIO port B pin 1.
041500             0053*   TMR_ISS:   equ 92h ; register address
041500             0054*   
041500             0055*   ; Table 51. Real-Time Clock Control Register
041500             0056*   RTC_CTRL: equ EDh ; register address
041500             0057*   
041500             0058*   ; alarm interrupt disable/enable
041500             0059*   RTC_ALARM_0:    equ %00000000
041500             0060*   RTC_ALARM_1:    equ %10000000
041500             0061*   
041500             0062*   ; interrupt on alarm disable/enable
041500             0063*   RTC_INT_ENT_0:  equ %00000000
041500             0064*   RTC_INT_ENT_1:  equ %01000000
041500             0065*   
041500             0066*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041500             0067*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041500             0068*   
041500             0069*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041500             0070*                                   ; On-chip 32768 Hz oscillator is enabled.
041500             0071*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041500             0072*                                   ; On-chip 32768 Hz oscillator is disabled.
041500             0073*   
041500             0074*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041500             0075*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041500             0076*   
041500             0077*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041500             0078*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041500             0079*   
041500             0080*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041500             0081*                                   ; RTC counter is enabled.
041500             0082*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041500             0083*                                   ; RTC counter is disabled.
041500             0084*   
041500             0085*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041500             0086*   
041500             0087*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041500             0088*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041500 00 00 00    0089*   prt_reload: dl 0x000000
041503             0090*   
041503             0091*   ; set PRT timer
041503             0092*   prt_set:
041503 21 00 00 00 0093*       ld hl,0
041507 22 51 15 04 0094*       ld (prt_irq_counter),hl
04150B 2A 00 15 04 0095*       ld hl,(prt_reload)
04150F ED 29 84    0096*       out0 ($84),l
041512 ED 21 85    0097*   	out0 ($85),h
041515             0098*   ; disable timer
041515 3E 06       0099*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041517 ED 39 83    0100*   	out0 ($83),a
04151A             0101*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04151A 3E 57       0102*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04151C ED 39 83    0103*   	out0 ($83),a
04151F C9          0104*       ret
041520             0105*   
041520             0106*   ; ===============================================
041520             0107*   ; PRT Timer Interrupt Handling
041520             0108*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
041520             0109*   ; -----------------------------------------------
041520             0110*   prt_irq_init:
041520             0111*       ; set up interrupt vector table 2
041520 21 00 00 00 0112*   	ld hl,0
041524 3A 0C 01 00 0113*   	ld a,($10c)
041528 6F          0114*   	ld l,a
041529 3A 0D 01 00 0115*   	ld a,($10d)
04152D 67          0116*   	ld h,a
04152E             0117*   
04152E             0118*   	; skip over CALL ($c3)
04152E 23          0119*   	inc hl
04152F             0120*   	; load address of jump into vector table 2 (in ram)
04152F ED 27       0121*   	ld hl,(hl)
041531             0122*   
041531             0123*   	; write CALL prt_irq_handler to vector table 2
041531 3E C3       0124*   	ld a,$c3
041533 77          0125*   	ld (hl),a
041534 23          0126*   	inc hl
041535 11 3C 15 04 0127*   	ld de,prt_irq_handler
041539 ED 1F       0128*   	ld (hl),de
04153B             0129*   
04153B C9          0130*       ret
04153C             0131*   
04153C             0132*   prt_irq_handler:
04153C F3          0133*   	di
04153D F5          0134*   	push af
04153E E5          0135*       push hl
04153F ED 38 83    0136*   	in0 a,($83)
041542 2A 51 15 04 0137*   	ld hl,(prt_irq_counter)
041546 23          0138*   	inc hl
041547 22 51 15 04 0139*   	ld (prt_irq_counter),hl
04154B E1          0140*       pop hl
04154C F1          0141*   	pop af
04154D FB          0142*   	ei
04154E 5B ED 4D    0143*   	reti.l
041551             0144*   
041551             0145*   prt_irq_counter:
041551 00 00 00    0146*   	.dl 0
041554             0147*   prt_irq_counter_saved:
041554 00 00 00    0148*       .dl 0
041557             0149*   
041557             0150*   prt_loop_reset:
041557 E5          0151*       push hl
041558 21 00 00 00 0152*   	ld hl,0
04155C 22 51 15 04 0153*   	ld (prt_irq_counter),hl
041560 22 C2 15 04 0154*       ld (prt_loop_counter),hl
041564 22 C5 15 04 0155*       ld (prt_loops),hl
041568 CD 03 15 04 0156*       call prt_set
04156C E1          0157*       pop hl
04156D C9          0158*       ret
04156E             0159*   
04156E             0160*   prt_loop_start:
04156E E5          0161*       push hl
04156F 21 00 00 00 0162*   	ld hl,0
041573 22 51 15 04 0163*   	ld (prt_irq_counter),hl
041577 E1          0164*       pop hl
041578 C9          0165*       ret
041579             0166*   
041579             0167*   prt_loop_stop:
041579 E5          0168*       push hl
04157A D5          0169*       push de
04157B 2A 51 15 04 0170*       ld hl,(prt_irq_counter)
04157F ED 5B C2 15 0171*       ld de,(prt_loop_counter)
       04          
041584 19          0172*       add hl,de
041585 22 C2 15 04 0173*       ld (prt_loop_counter),hl
041589 21 00 00 00 0174*       ld hl,0
04158D 22 51 15 04 0175*       ld (prt_irq_counter),hl
041591 2A C5 15 04 0176*       ld hl,(prt_loops)
041595 23          0177*       inc hl
041596 22 C5 15 04 0178*       ld (prt_loops),hl
04159A D1          0179*       pop de
04159B E1          0180*       pop hl
04159C C9          0181*       ret
04159D             0182*   
04159D             0183*   ; inputs: bc = y,x text coordinates to print
04159D             0184*   prt_loop_print:
04159D F5          0185*       push af
04159E E5          0186*       push hl
04159F C5          0187*       push bc
0415A0 D5          0188*       push de
0415A1 DD E5       0189*       push ix
0415A3 FD E5       0190*       push iy
0415A5 CD 37 17 04 0191*       call vdu_move_cursor
0415A9             0192*   
0415A9 2A C2 15 04 0193*       ld hl,(prt_loop_counter)
0415AD CD 16 02 04 0194*       call printDec
0415B1             0195*   
0415B1 2A C5 15 04 0196*       ld hl,(prt_loops)
0415B5 CD 16 02 04 0197*       call printDec
0415B9             0198*   
0415B9 FD E1       0199*       pop iy
0415BB DD E1       0200*       pop ix
0415BD D1          0201*       pop de
0415BE C1          0202*       pop bc
0415BF E1          0203*       pop hl
0415C0 F1          0204*       pop af
0415C1 C9          0205*       ret
0415C2             0206*   
0415C2             0207*   prt_loop_counter:
0415C2 00 00 00    0208*       .dl 0
0415C5             0209*   prt_loops:
0415C5 00 00 00    0210*       .dl 0
0415C8             0211*   
0415C8             0212*   ; ===============================================
0415C8             0213*   ; Timer functions
0415C8             0214*   ; -----------------------------------------------
0415C8             0215*   ; set a countdown timer
0415C8             0216*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415C8             0217*   ; returns: hl = current time
0415C8             0218*   tmr_set:
0415C8 FD 2F 03    0219*       ld (iy+3),hl            ; set time remaining
0415CB             0220*       MOSCALL mos_sysvars     ; ix points to syvars table
0415CB 3E 08       0001*M1 			LD	A, function
0415CD 5B CF       0002*M1 			RST.LIL	08h
0415CF DD 27 00    0221*       ld hl,(ix+sysvar_time)  ; get current time
0415D2 FD 2F 00    0222*       ld (iy+0),hl            ; set start time
0415D5 C9          0223*       ret
0415D6             0224*   
0415D6             0225*   ; gets time remaining on a countdown timer
0415D6             0226*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0415D6             0227*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0415D6             0228*   ;          sign flags: pos = time not expired,zero or neg = time expired
0415D6             0229*   tmr_get:
0415D6             0230*       MOSCALL mos_sysvars     ; ix points to syvars table
0415D6 3E 08       0001*M1 			LD	A, function
0415D8 5B CF       0002*M1 			RST.LIL	08h
0415DA DD 17 00    0231*       ld de,(ix+sysvar_time)  ; get current time
0415DD FD 27 00    0232*       ld hl,(iy+0)            ; get start time
0415E0 AF          0233*       xor a                   ; clear carry
0415E1 ED 52       0234*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0415E3 FD 17 03    0235*       ld de,(iy+3)            ; get timer set value
0415E6 AF          0236*       xor a                   ; clear carry
0415E7 ED 5A       0237*       adc hl,de               ; hl = time remaining
0415E9             0238*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0415E9 C9          0239*       ret
0415EA             0240*   
0415EA             0241*   tmr_test: ds 6 ; example of a buffer to hold timer data
0415F0             0242*   
       FF FF FF FF 
       FF FF 
0415F0 00 00 00    0243*   timestamp_now: dl 0
0415F3 00 00 00    0244*   timestamp_old: dl 0
0415F6 00 00 00    0245*   timestamp_chg: dl 0
0415F9             0246*   
0415F9             0247*   ; update the global timestamp from the system clock
0415F9             0248*   ; inputs: none
0415F9             0249*   ; returns: hl = time elapsed in 1/120ths of a second
0415F9             0250*   ;          ix = pointer to syvars table
0415F9             0251*   ; destroys: af,hl,de,ix
0415F9             0252*   timestamp_tick:
0415F9 ED 5B F0 15 0253*       ld de,(timestamp_now)   ; get previous time
       04          
0415FE ED 53 F3 15 0254*       ld (timestamp_old),de   ; save previous time
       04          
041603             0255*       MOSCALL mos_sysvars     ; ix points to syvars table
041603 3E 08       0001*M1 			LD	A, function
041605 5B CF       0002*M1 			RST.LIL	08h
041607 DD 27 00    0256*       ld hl,(ix+sysvar_time)  ; get current time
04160A 22 F0 15 04 0257*       ld (timestamp_now),hl   ; save current time
04160E AF          0258*       xor a                   ; clear carry
04160F ED 52       0259*       sbc hl,de               ; hl = time elapsed
041611 22 F6 15 04 0260*       ld (timestamp_chg),hl   ; save elapsed time
041615 C9          0261*       ret
041616             0262*   
041616             0263*   ; set a countdown timer
041616             0264*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041616             0265*   ; requires: timestamp_tick to be called at least once before this function
041616             0266*   ; returns: hl = current time
041616             0267*   ; destroys: hl
041616             0268*   timestamp_tmr_set:
041616 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041619 2A F0 15 04 0270*       ld hl,(timestamp_now)   ; get current timestamp
04161D FD 2F 00    0271*       ld (iy+0),hl            ; set start time
041620 C9          0272*       ret
041621             0273*   
041621             0274*   ; gets time remaining on a countdown timer following the global timestamp
041621             0275*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041621             0276*   ; requires: timestamp_tick to be called at least once before this function
041621             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041621             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
041621             0279*   ; destroys: af,hl,de
041621             0280*   timestamp_tmr_get:
041621 ED 5B F0 15 0281*       ld de,(timestamp_now)   ; get current timestamp
       04          
041626 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041629 AF          0283*       xor a                   ; clear carry
04162A ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04162C FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04162F AF          0286*       xor a                   ; clear carry
041630 ED 5A       0287*       adc hl,de               ; hl = time remaining
041632             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041632 C9          0289*       ret
041633             0290*   
041633             0291*   ; set a stopwatch
041633             0292*   ; returns: hl = start time
041633             0293*   ; destroys: hl,ix
041633             0294*   stopwatch_set:
041633             0295*       MOSCALL mos_sysvars     ; ix points to syvars table
041633 3E 08       0001*M1 			LD	A, function
041635 5B CF       0002*M1 			RST.LIL	08h
041637 DD 27 00    0296*       ld hl,(ix+sysvar_time)  ; get current time
04163A 22 4F 16 04 0297*       ld (stopwatch_started),hl            ; set start time
04163E C9          0298*       ret
04163F             0299*   
04163F             0300*   ; gets time elapsed on a stopwatch
04163F             0301*   ; returns: hl = time elapsed in 1/120ths of a second
04163F             0302*   ; destroys: af,hl,de,ix
04163F             0303*   stopwatch_get:
04163F             0304*       MOSCALL mos_sysvars     ; ix points to syvars table
04163F 3E 08       0001*M1 			LD	A, function
041641 5B CF       0002*M1 			RST.LIL	08h
041643 DD 27 00    0305*       ld hl,(ix+sysvar_time)  ; get current time
041646 ED 5B 4F 16 0306*       ld de,(stopwatch_started)            ; get start time
       04          
04164B AF          0307*       xor a                   ; clear carry
04164C ED 52       0308*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04164E C9          0309*       ret
04164F             0310*   
04164F             0311*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041652             0312*   
041652             0313*   ; ------------------
041652             0314*   ; delay routine
041652             0315*   ; Author: Richard Turrnidge
041652             0316*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041652             0317*   ; routine waits a fixed time,then returns
041652             0318*   ; arrive with A =  the delay byte. One bit to be set only.
041652             0319*   ; eg. ld A,00000100b
041652             0320*   
041652             0321*   multiPurposeDelay:
       FF FF FF 
041652 F5          0322*       push af
041653 C5          0323*       push bc
041654 DD E5       0324*       push ix
041656 47          0325*       ld b,a
041657 3E 08       0326*       ld a,$08
041659 5B CF       0327*       RST.LIL	08h                 ; get IX pointer to sysvars
04165B             0328*   
04165B             0329*   waitLoop:
04165B             0330*   
04165B DD 7E 00    0331*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04165E             0332*   
04165E             0333*                                   ;   we check if bit set is same as last time we checked.
04165E             0334*                                   ;   bit 0 - don't use
04165E             0335*                                   ;   bit 1 - changes 64 times per second
04165E             0336*                                   ;   bit 2 - changes 32 times per second
04165E             0337*                                   ;   bit 3 - changes 16 times per second
04165E             0338*   
04165E             0339*                                   ;   bit 4 - changes 8 times per second
04165E             0340*                                   ;   bit 5 - changes 4 times per second
04165E             0341*                                   ;   bit 6 - changes 2 times per second
04165E             0342*                                   ;   bit 7 - changes 1 times per second
04165E A0          0343*       and b
04165F 4F          0344*       ld c,a
041660 3A 71 16 04 0345*       ld a,(oldTimeStamp)
041664 B9          0346*       cp c                        ; is A same as last value?
041665 28 F4       0347*       jr z,waitLoop              ; loop here if it is
041667 79          0348*       ld a,c
041668 32 71 16 04 0349*       ld (oldTimeStamp),a        ; set new value
04166C             0350*   
04166C DD E1       0351*       pop ix
04166E C1          0352*       pop bc
04166F F1          0353*       pop af
041670 C9          0354*       ret
041671             0355*   
041671 00          0356*   oldTimeStamp:   .db 00h
041672             0038        include "vdu.inc"
041672 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
041700             0002*   
041700             0003*   ; VDU 30: Home cursor
041700             0004*   vdu_home_cursor:
041700 3E 1E       0005*       ld a,30
041702 5B D7       0006*   	rst.lil $10
041704 C9          0007*   	ret
041705             0008*   
041705             0009*   vdu_cursor_on:
041705 21 10 17 04 0010*   	ld hl,@cmd
041709 01 03 00 00 0011*   	ld bc,@end-@cmd
04170D 5B DF       0012*   	rst.lil $18
04170F C9          0013*   	ret
041710             0014*   @cmd:
041710 17 01 01    0015*   	db 23,1,1
041713             0016*   @end:
041713             0017*   
041713             0018*   vdu_cursor_off:
041713 21 1E 17 04 0019*   	ld hl,@cmd
041717 01 03 00 00 0020*   	ld bc,@end-@cmd
04171B 5B DF       0021*   	rst.lil $18
04171D C9          0022*   	ret
04171E             0023*   @cmd:
04171E 17 01 00    0024*   	db 23,1,0
041721             0025*   @end:
041721             0026*   
041721             0027*   ; VDU 5: Write text at graphics cursor
041721             0028*   ; inputs: a is the character to write to the screen
041721             0029*   ; prerequisites: the graphics cursor at the intended position on screen
041721             0030*   ; outputs: see the name of the function
041721             0031*   ; destroys: a, hl, bc
041721             0032*   vdu_char_to_gfx_cursor:
041721 32 31 17 04 0033*   	ld (@arg),a
041725 21 30 17 04 0034*   	ld hl,@cmd
041729 01 02 00 00 0035*   	ld bc,@end-@cmd
04172D 5B DF       0036*   	rst.lil $18
04172F C9          0037*   	ret
041730 05          0038*   @cmd: db 5
041731 00          0039*   @arg: db 0
041732             0040*   @end:
041732             0041*   ; VDU 9: Move cursor forward one character
041732             0042*   vdu_cursor_forward:
041732 3E 09       0043*       ld a,9
041734 5B D7       0044*   	rst.lil $10
041736 C9          0045*   	ret
041737             0046*   
041737             0047*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041737             0048*   ; inputs: c=x, b=y 8-bit unsigned integers
041737             0049*   vdu_move_cursor:
041737 ED 43 48 17 0050*       ld (@x0),bc
       04          
04173C 21 47 17 04 0051*   	ld hl,@cmd
041740 01 03 00 00 0052*   	ld bc,@end-@cmd
041744 5B DF       0053*   	rst.lil $18
041746 C9          0054*   	ret
041747 1F          0055*   @cmd: 	db 31
041748 00          0056*   @x0:	db 0
041749 00          0057*   @y0: 	db 0
04174A 00          0058*   @end: 	db 0 ; padding
04174B             0059*   
04174B             0060*   ; VDU 12: Clear text area (CLS)
04174B             0061*   vdu_cls:
04174B 3E 0C       0062*       ld a,12
04174D 5B D7       0063*   	rst.lil $10
04174F C9          0064*   	ret
041750             0065*   
041750             0066*   vdu_flip:
041750 21 5B 17 04 0067*   	ld hl,@cmd
041754 01 03 00 00 0068*   	ld bc,@end-@cmd
041758 5B DF       0069*   	rst.lil $18
04175A C9          0070*   	ret
04175B 17 00 C3    0071*   @cmd: db 23,0,0xC3
04175E             0072*   @end:
04175E             0073*   
04175E             0074*   ; VDU 16: Clear graphics area (CLG)
04175E             0075*   vdu_clg:
04175E 3E 10       0076*       ld a,16
041760 5B D7       0077*   	rst.lil $10
041762 C9          0078*   	ret
041763             0079*   
041763             0080*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041763             0081*   ; VDU 23, 7: Scrolling
041763             0082*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041763             0083*   ; inputs: a, extent; l, direction; h; speed
041763             0084*   vdu_scroll_down:
041763 32 78 17 04 0085*   	ld (@extent),a
041767 22 79 17 04 0086*   	ld (@dir),hl ; implicitly populates @speed
04176B 21 76 17 04 0087*   	ld hl,@cmd
04176F 01 05 00 00 0088*   	ld bc,@end-@cmd
041773 5B DF       0089*   	rst.lil $18     ;; Sending command to VDP
041775 C9          0090*   	ret
041776 17 07       0091*   @cmd:       db 23,7
041778 00          0092*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041779 00          0093*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04177A 00          0094*   @speed:     db 0x00 ; pixels
04177B 00          0095*   @end:		db 0x00 ; padding
04177C             0096*   
04177C             0097*   ; COLOUR MODES
04177C             0098*   ; Mode	Effect
04177C             0099*   ; 0	Set on-screen pixel to target colour value
04177C             0100*   ; 1	OR value with the on-screen pixel
04177C             0101*   ; 2	AND value with the on-screen pixel
04177C             0102*   ; 3	XOR value with the on-screen pixel
04177C             0103*   ; 4	Invert the on-screen pixel
04177C             0104*   ; 5	No operation
04177C             0105*   ; 6	AND the inverse of the specified colour with the on-screen pixel
04177C             0106*   ; 7	OR the inverse of the specified colour with the on-screen pixel
04177C             0107*   
04177C             0108*   ; VDU 17, colour: Define text colour (COLOUR)
04177C             0109*   vdu_colour_text:
04177C 32 8C 17 04 0110*   	ld (@arg),a
041780 21 8B 17 04 0111*   	ld hl,@cmd
041784 01 02 00 00 0112*   	ld bc,@end-@cmd
041788 5B DF       0113*   	rst.lil $18
04178A C9          0114*   	ret
04178B 11          0115*   @cmd: db 17
04178C 00          0116*   @arg: db 0
04178D             0117*   @end:
04178D             0118*   
04178D             0119*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04178D             0120*   ; inputs: a=mode, c=colour (add 128 to set background colour)
04178D             0121*   vdu_gcol:
04178D 32 A2 17 04 0122*   	ld (@mode),a
041791 79          0123*       ld a,c
041792 32 A3 17 04 0124*       ld (@col),a
041796 21 A1 17 04 0125*   	ld hl,@cmd
04179A 01 03 00 00 0126*   	ld bc,@end-@cmd
04179E 5B DF       0127*   	rst.lil $18
0417A0 C9          0128*   	ret
0417A1 12          0129*   @cmd:  db 18
0417A2 00          0130*   @mode: db 0
0417A3 00          0131*   @col:  db 0
0417A4             0132*   @end:
0417A4             0133*   
0417A4             0134*   
0417A4             0135*   ; VDU 28, left, bottom, right, top: Set text viewport **
0417A4             0136*   ; MIND THE LITTLE-ENDIANESS
0417A4             0137*   ; inputs: c=left,b=bottom,e=right,d=top
0417A4             0138*   ; outputs; nothing
0417A4             0139*   ; destroys: a might make it out alive
0417A4             0140*   vdu_set_txt_viewport:
0417A4 ED 43 BA 17 0141*       ld (@lb),bc
       04          
0417A9 ED 53 BC 17 0142*   	ld (@rt),de
       04          
0417AE 21 B9 17 04 0143*   	ld hl,@cmd
0417B2 01 05 00 00 0144*   	ld bc,@end-@cmd
0417B6 5B DF       0145*   	rst.lil $18
0417B8 C9          0146*   	ret
0417B9 1C          0147*   @cmd:   db 28 ; set text viewport command
0417BA 00 00       0148*   @lb: 	dw 0x0000 ; set by bc
0417BC 00 00       0149*   @rt: 	dw 0x0000 ; set by de
0417BE 00          0150*   @end:   db 0x00	  ; padding
0417BF             0151*   
0417BF             0152*   ; Wait for VBLANK interrupt
0417BF             0153*   vdu_vblank:
0417BF DD E5       0154*       PUSH 	IX
0417C1             0155*   	MOSCALL	mos_sysvars
0417C1 3E 08       0001*M1 			LD	A, function
0417C3 5B CF       0002*M1 			RST.LIL	08h
0417C5 DD 7E 00    0156*   	LD	A, (IX + sysvar_time + 0)
0417C8             0157*   @wait:
0417C8 DD BE 00    0158*       CP 	A, (IX + sysvar_time + 0)
0417CB 28 FB       0159*       JR	Z, @wait
0417CD DD E1       0160*       POP	IX
0417CF C9          0161*       RET
0417D0             0162*   
0417D0             0163*   ; VDU 29, x; y;: Set graphics origin
0417D0             0164*   ; This command sets the graphics origin.
0417D0             0165*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0417D0             0166*   ; inputs: bc=x0,de=y0
0417D0             0167*   ; outputs; nothing
0417D0             0168*   ; destroys: a might make it out alive
0417D0             0169*   vdu_set_gfx_origin:
0417D0 ED 43 E6 17 0170*       ld (@x0),bc
       04          
0417D5 ED 53 E8 17 0171*       ld (@y0),de
       04          
0417DA 21 E5 17 04 0172*       ld hl,@cmd
0417DE 01 05 00 00 0173*       ld bc,@end-@cmd
0417E2 5B DF       0174*       rst.lil $18
0417E4 C9          0175*       ret
0417E5 1D          0176*   @cmd:   db 29 ; set graphics origin command
0417E6 00 00       0177*   @x0: 	dw 0x0000 ; set by bc
0417E8 00 00       0178*   @y0: 	dw 0x0000 ; set by de
0417EA 00          0179*   @end:   db 0x00	  ; padding
0417EB             0180*   
0417EB             0181*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0417EB             0182*   ; NOTE: the order of the y-coordinate parameters are inverted
0417EB             0183*   ; 	because we have turned off logical screen scaling
0417EB             0184*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0417EB             0185*   ; outputs; nothing
0417EB             0186*   ; destroys: a might make it out alive
0417EB             0187*   vdu_set_gfx_viewport:
0417EB ED 43 0B 18 0188*       ld (@x0),bc
       04          
0417F0 FD 22 0D 18 0189*       ld (@y1),iy
       04          
0417F5 DD 22 0F 18 0190*   	ld (@x1),ix
       04          
0417FA ED 53 11 18 0191*   	ld (@y0),de
       04          
0417FF 21 0A 18 04 0192*   	ld hl,@cmd
041803 01 09 00 00 0193*   	ld bc,@end-@cmd
041807 5B DF       0194*   	rst.lil $18
041809 C9          0195*   	ret
04180A 18          0196*   @cmd:   db 24 ; set graphics viewport command
04180B 00 00       0197*   @x0: 	dw 0x0000 ; set by bc
04180D 00 00       0198*   @y1: 	dw 0x0000 ; set by iy
04180F 00 00       0199*   @x1: 	dw 0x0000 ; set by ix
041811 00 00       0200*   @y0: 	dw 0x0000 ; set by de
041813 00          0201*   @end:   db 0x00	  ; padding
041814             0202*   
041814             0203*   ; SCREEN MODES
041814             0204*   ; ===============================
041814             0205*   ; Mode  Horz  Vert  Cols  Refresh
041814             0206*   ; ---   ----  ----  ----  -------
041814             0207*   ; 11    320   240   2     60hz
041814             0208*   ; 139   320   240   2     60hz
041814             0209*   ; 23    512   384   2     60hz
041814             0210*   ; 151   512   384   2     60hz
041814             0211*   ; 6     640   240   2     60hz
041814             0212*   ; 134   640   240   2     60hz
041814             0213*   ; 2     640   480   2     60hz
041814             0214*   ; 130   640   480   2     60hz
041814             0215*   ; 17    800   600   2     60hz
041814             0216*   ; 145   800   600   2     60hz
041814             0217*   ; 18    1024  768   2     60hz
041814             0218*   ; 146   1024  768   2     60hz
041814             0219*   ; ---   ----  ----  ----  -------
041814             0220*   ; 10    320   240   4     60hz
041814             0221*   ; 138   320   240   4     60hz
041814             0222*   ; 22    512   384   4     60hz
041814             0223*   ; 150   512   384   4     60hz
041814             0224*   ; 5     640   240   4     60hz
041814             0225*   ; 133   640   240   4     60hz
041814             0226*   ; 1     640   480   4     60hz
041814             0227*   ; 129   640   480   4     60hz
041814             0228*   ; 16    800   600   4     60hz
041814             0229*   ; 19    1024  768   4     60hz
041814             0230*   ; ---   ----  ----  ----  -------
041814             0231*   ; 9     320   240   16    60hz
041814             0232*   ; 137   320   240   16    60hz
041814             0233*   ; 21    512   384   16    60hz
041814             0234*   ; 149   512   384   16    60hz
041814             0235*   ; 4     640   240   16    60hz
041814             0236*   ; 132   640   240   16    60hz
041814             0237*   ; 0     640   480   16    60hz
041814             0238*   ; 7     n/a   n/a   16    60hz
041814             0239*   ; ---   ----  ----  ----  -------
041814             0240*   ; 8     320   240   64    60hz
041814             0241*   ; 136   320   240   64    60hz
041814             0242*   ; 20    512   384   64    60hz
041814             0243*   ; 3     640   240   64    60hz
041814             0244*   ; ---   ----  ----  ----  -------
041814             0245*   vdu_set_screen_mode:
041814 32 24 18 04 0246*   	ld (@arg),a
041818 21 23 18 04 0247*   	ld hl,@cmd
04181C 01 02 00 00 0248*   	ld bc,@end-@cmd
041820 5B DF       0249*   	rst.lil $18
041822 C9          0250*   	ret
041823 16          0251*   @cmd: db 22 ; set screen mode
041824 00          0252*   @arg: db 0  ; screen mode parameter
041825             0253*   @end:
041825             0254*   
041825             0255*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041825             0256*   ; inputs: a is scaling mode, 1=on, 0=off
041825             0257*   ; note: default setting on boot is scaling ON
041825             0258*   vdu_set_scaling:
041825 32 37 18 04 0259*   	ld (@arg),a
041829 21 34 18 04 0260*   	ld hl,@cmd
04182D 01 04 00 00 0261*   	ld bc,@end-@cmd
041831 5B DF       0262*   	rst.lil $18
041833 C9          0263*   	ret
041834 17 00 C0    0264*   @cmd: db 23,0,0xC0
041837 00          0265*   @arg: db 0  ; scaling on/off
041838             0266*   @end:
041838             0267*   
041838             0268*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041838             0269*   ; inputs: hl=bufferId
041838             0270*   vdu_buff_select:
041838 22 4A 18 04 0271*   	ld (@bufferId),hl
04183C 21 47 18 04 0272*   	ld hl,@cmd
041840 01 05 00 00 0273*   	ld bc,@end-@cmd
041844 5B DF       0274*   	rst.lil $18
041846 C9          0275*   	ret
041847 17 1B 20    0276*   @cmd: db 23,27,0x20
04184A 00 00       0277*   @bufferId: dw 0x0000
04184C 00          0278*   @end: db 0x00 ; padding
04184D             0279*   
04184D             0280*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04184D             0281*   ; inputs: a=format; bc=width; de=height
04184D             0282*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04184D             0283*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04184D             0284*   ; 0 	RGBA8888 (4-bytes per pixel)
04184D             0285*   ; 1 	RGBA2222 (1-bytes per pixel)
04184D             0286*   ; 2 	Mono/Mask (1-bit per pixel)
04184D             0287*   ; 3 	Reserved for internal use by VDP (“native” format)
04184D             0288*   vdu_bmp_create:
04184D ED 43 69 18 0289*       ld (@width),bc
       04          
041852 ED 53 6B 18 0290*       ld (@height),de
       04          
041857 32 6D 18 04 0291*       ld (@fmt),a
04185B 21 66 18 04 0292*   	ld hl,@cmd
04185F 01 08 00 00 0293*   	ld bc,@end-@cmd
041863 5B DF       0294*   	rst.lil $18
041865 C9          0295*   	ret
041866 17 1B 21    0296*   @cmd:       db 23,27,0x21
041869 00 00       0297*   @width:     dw 0x0000
04186B 00 00       0298*   @height:    dw 0x0000
04186D 00          0299*   @fmt:       db 0x00
04186E             0300*   @end:
04186E             0301*   
04186E             0302*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04186E             0303*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04186E             0304*   vdu_load_img_rgba2_to_8:
04186E             0305*   ; backup the target buffer id and image dimensions
04186E E5          0306*       push hl
04186F D5          0307*       push de
041870 C5          0308*       push bc
041871             0309*   ; load the rgba2 image to working buffer 65534
041871 21 FE FF 00 0310*       ld hl,65534 ; temporary working buffer id
041875 CD 78 19 04 0311*   	call vdu_load_buffer_from_file
041879             0312*   ; restore the image dimensions and target buffer id
041879 C1          0313*       pop bc
04187A D1          0314*       pop de
04187B E1          0315*       pop hl
04187C             0316*   ; fall through to vdu_rgba2_to_8
04187C             0317*   
04187C             0318*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04187C             0319*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04187C             0320*   ; the "expand bitmap" command is:
04187C             0321*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04187C             0322*   ; and then to reverse the byte order to fix endian-ness:
04187C             0323*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04187C             0324*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04187C             0325*   ; VDU 23,27,&20,targetBufferID%;
04187C             0326*   ; VDU 23,27,&21,width%;height%;0
04187C             0327*   ; -------------------------------------------------------------------
04187C             0328*   ; inputs: bc,de image width,height ; hl = targetBufferId
04187C             0329*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04187C             0330*   vdu_rgba2_to_8:
04187C             0331*   ; load the image dimensions and buffer id parameters
04187C ED 43 D8 18 0332*       ld (@width),bc
       04          
041881 ED 53 DA 18 0333*       ld (@height),de
       04          
041886 22 BD 18 04 0334*       ld (@bufferId0),hl
04188A 22 CA 18 04 0335*       ld (@bufferId2),hl
04188E 22 D3 18 04 0336*       ld (@bufferId1),hl
041892             0337*   ; clean up bytes that got stomped on by the ID loads
041892 3E 48       0338*       ld a,0x48
041894 32 BF 18 04 0339*       ld (@bufferId0+2),a
041898 3E 17       0340*       ld a,23
04189A 32 D5 18 04 0341*       ld (@bufferId1+2),a
04189E 3E 18       0342*       ld a,24
0418A0 32 CC 18 04 0343*       ld (@bufferId2+2),a
0418A4 AF          0344*       xor a
0418A5 32 DC 18 04 0345*       ld (@height+2),a
0418A9             0346*   ; send the vdu command strings
0418A9 21 B4 18 04 0347*       ld hl,@beg
0418AD 01 29 00 00 0348*       ld bc,@end-@beg
0418B1 5B DF       0349*       rst.lil $18
0418B3 C9          0350*       ret
0418B4             0351*   @beg:
0418B4             0352*   ; Command 14: Consolidate blocks in a buffer
0418B4             0353*   ; VDU 23, 0, &A0, bufferId; 14
0418B4 17 00 A0    0354*       db 23,0,0xA0
0418B7 FE FF       0355*       dw 65534 ; workingBufferId
0418B9 0E          0356*       db 14 ; consolidate blocks
0418BA             0357*   ; the "expand bitmap" command is:
0418BA             0358*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0418BA 17 00 A0    0359*       db 23,0,0xA0
0418BD 00 00       0360*   @bufferId0: dw 0x0000 ; targetBufferId
0418BF 48          0361*       db 0x48 ; given as decimal command 72 in the docs
0418C0 02          0362*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0418C1 FE FF       0363*       dw 65534 ; sourceBufferId
0418C3 00 7F BF FF 0364*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0418C7             0365*   ; reverse the byte order to fix endian-ness:
0418C7             0366*   ; Command 24: Reverse the order of data of blocks within a buffer
0418C7             0367*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0418C7             0368*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0418C7 17 00 A0    0369*       db 23,0,0xA0
0418CA 00 00       0370*   @bufferId2:    dw 0x0000 ; targetBufferId
0418CC 18          0371*       db 24 ; reverse byte order
0418CD 04          0372*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0418CE 04 00       0373*       dw 4 ; size (4 bytes)
0418D0             0374*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0418D0             0375*   ; VDU 23,27,&20,targetBufferID%;
0418D0 17 1B 20    0376*       db 23,27,0x20 ; select bitmap
0418D3 00 00       0377*   @bufferId1: dw 0x0000 ; targetBufferId
0418D5             0378*   ; VDU 23,27,&21,width%;height%;0
0418D5 17 1B 21    0379*       db 23,27,0x21 ; create bitmap from buffer
0418D8 00 00       0380*   @width: dw 0x0000
0418DA 00 00       0381*   @height: dw 0x0000
0418DC 00          0382*       db 0x00 ; rgba8888 format
0418DD             0383*   @end:
0418DD             0384*   
0418DD             0385*   ; scratch variables
0418DD 00 00 00    0386*   bufferId0: dl 0x000000
0418E0 00 00 00    0387*   bufferId1: dl 0x000000
0418E3             0388*   
0418E3             0389*   ; load a vdu buffer from local memory
0418E3             0390*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0418E3             0391*   vdu_load_buffer:
0418E3 ED 43 0C 19 0392*       ld (@length),bc
       04          
0418E8 D5          0393*       push de ; save data pointer
0418E9             0394*   ; send the vdu command string
0418E9 7D          0395*       ld a,l
0418EA 32 09 19 04 0396*       ld (@bufferId),a
0418EE 7C          0397*       ld a,h
0418EF 32 0A 19 04 0398*       ld (@bufferId+1),a
0418F3 21 06 19 04 0399*       ld hl,@cmd
0418F7 01 08 00 00 0400*       ld bc,@end-@cmd
0418FB 5B DF       0401*       rst.lil $18
0418FD             0402*   ; send the buffer data
0418FD E1          0403*       pop hl ; pointer to data
0418FE ED 4B 0C 19 0404*       ld bc,(@length)
       04          
041903 5B DF       0405*       rst.lil $18 ; send it
041905 C9          0406*       ret
041906             0407*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041906 17 00 A0    0408*   @cmd:       db 23,0,0xA0
041909 00 00       0409*   @bufferId:	dw 0x0000
04190B 00          0410*   		    db 0 ; load buffer
04190C 00 00       0411*   @length:	dw 0x0000
04190E 00          0412*   @end: db 0 ; padding
04190F             0413*   
04190F             0414*   ; clear a buffer
04190F             0415*   ; inputs: hl = bufferId
04190F             0416*   vdu_clear_buffer:
04190F 7D          0417*       ld a,l
041910 32 27 19 04 0418*       ld (@bufferId),a
041914 7C          0419*       ld a,h
041915 32 28 19 04 0420*       ld (@bufferId+1),a
041919 21 24 19 04 0421*       ld hl,@cmd
04191D 01 06 00 00 0422*       ld bc,@end-@cmd
041921 5B DF       0423*       rst.lil $18
041923 C9          0424*       ret
041924 17 00 A0    0425*   @cmd:       db 23,0,0xA0
041927 00 00       0426*   @bufferId:	dw 0x0000
041929 02          0427*   		    db 2 ; clear buffer
04192A             0428*   @end:
04192A             0429*   
04192A             0430*   vdu_clear_all_buffers:
04192A             0431*   ; clear all buffers
04192A 21 35 19 04 0432*       ld hl,@beg
04192E 01 06 00 00 0433*       ld bc,@end-@beg
041932 5B DF       0434*       rst.lil $18
041934 C9          0435*       ret
041935 17 00 A0    0436*   @beg: db 23,0,$A0
041938 FF FF       0437*         dw -1 ; clear all buffers
04193A 02          0438*         db 2  ; command 2: clear a buffer
04193B             0439*   @end:
04193B             0440*   
04193B             0441*   ; Command 14: Consolidate blocks in a buffer
04193B             0442*   vdu_consolidate_buffer:
04193B             0443*   ; set parameters for vdu call
04193B 7D          0444*       ld a,l
04193C 32 53 19 04 0445*       ld (@bufferId),a
041940 7C          0446*       ld a,h
041941 32 54 19 04 0447*       ld (@bufferId+1),a
041945 21 50 19 04 0448*       ld hl,@beg
041949 01 06 00 00 0449*       ld bc,@end-@beg
04194D 5B DF       0450*       rst.lil $18
04194F C9          0451*       ret
041950             0452*   ; VDU 23, 0, &A0, bufferId; 14
041950 17 00 A0    0453*   @beg: db 23,0,0xA0
041953 00 00       0454*   @bufferId: dw 0x0000
041955 0E          0455*              db 14
041956             0456*   @end:
041956             0457*   
041956             0458*   ; load an image file to a buffer and make it a bitmap
041956             0459*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041956             0460*   vdu_load_img:
041956             0461*   ; back up image type and dimension parameters
041956 22 DD 18 04 0462*       ld (bufferId0),hl
04195A F5          0463*       push af
04195B C5          0464*   	push bc
04195C D5          0465*   	push de
04195D             0466*   ; load the image
04195D CD 78 19 04 0467*   	call vdu_load_buffer_from_file
041961             0468*   ; now make it a bitmap
041961 2A DD 18 04 0469*       ld hl,(bufferId0)
041965 CD 3B 19 04 0470*       call vdu_consolidate_buffer
041969 2A DD 18 04 0471*       ld hl,(bufferId0)
04196D CD 38 18 04 0472*       call vdu_buff_select
041971 D1          0473*   	pop de ; image height
041972 C1          0474*   	pop bc ; image width
041973 F1          0475*   	pop af ; image type
041974 C3 4D 18 04 0476*   	jp vdu_bmp_create ; will return to caller from there
041978             0477*   
041978             0478*   ; inputs: hl = bufferId; iy = pointer to filename
041978             0479*   vdu_load_buffer_from_file:
041978 22 DD 18 04 0480*       ld (bufferId0),hl
04197C             0481*   
04197C             0482*   ; clear target buffer
04197C CD 0F 19 04 0483*       call vdu_clear_buffer
041980             0484*   
041980             0485*   ; open the file in read mode
041980             0486*   ; Open a file
041980             0487*   ; HLU: Filename
041980             0488*   ;   C: Mode
041980             0489*   ; Returns:
041980             0490*   ;   A: Filehandle, or 0 if couldn't open
041980 FD E5       0491*   	push iy ; pointer to filename
041982 E1          0492*   	pop hl
041983 0E 01       0493*   	ld c,fa_read
041985             0494*       MOSCALL mos_fopen
041985 3E 0A       0001*M1 			LD	A, function
041987 5B CF       0002*M1 			RST.LIL	08h
041989 32 C4 19 04 0495*       ld (@filehandle),a
04198D             0496*   
04198D             0497*   @read_file:
04198D             0498*   ; Read a block of data from a file
04198D             0499*   ;   C: Filehandle
04198D             0500*   ; HLU: Pointer to where to write the data to
04198D             0501*   ; DEU: Number of bytes to read
04198D             0502*   ; Returns:
04198D             0503*   ; DEU: Number of bytes read
04198D 3A C4 19 04 0504*       ld a,(@filehandle)
041991 4F          0505*       ld c,a
041992 21 00 E0 B7 0506*       ld hl,filedata
041996 11 00 20 00 0507*       ld de,8192 ; max we can read into onboard sram at one time
04199A             0508*       MOSCALL mos_fread
04199A 3E 1A       0001*M1 			LD	A, function
04199C 5B CF       0002*M1 			RST.LIL	08h
04199E             0509*   
04199E             0510*   ; test de for zero bytes read
04199E 21 00 00 00 0511*       ld hl,0
0419A2 AF          0512*       xor a ; clear carry
0419A3 ED 52       0513*       sbc hl,de
0419A5 CA BB 19 04 0514*       jp z,@close_file
0419A9             0515*   
0419A9             0516*   ; load a vdu buffer from local memory
0419A9             0517*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0419A9 2A DD 18 04 0518*       ld hl,(bufferId0)
0419AD D5          0519*       push de ; chunksize
0419AE C1          0520*       pop bc
0419AF 11 00 E0 B7 0521*       ld de,filedata
0419B3 CD E3 18 04 0522*       call vdu_load_buffer
0419B7             0523*   
0419B7             0524*   ; read the next block
0419B7 C3 8D 19 04 0525*       jp @read_file
0419BB             0526*   
0419BB             0527*   ; close the file
0419BB             0528*   @close_file:
0419BB 3A C4 19 04 0529*       ld a,(@filehandle)
0419BF             0530*       MOSCALL mos_fclose
0419BF 3E 0B       0001*M1 			LD	A, function
0419C1 5B CF       0002*M1 			RST.LIL	08h
0419C3 C9          0531*       ret ; vdu_load_buffer_from_file
0419C4             0532*   
0419C4 00          0533*   @filehandle: db 0 ; file handle
0419C5 00 00 00    0534*   @fil: dl 0 ; pointer to FIL struct
0419C8             0535*   
0419C8 00 00 00    0536*   @chunkpointer: dl 0 ; pointer to current chunk
0419CB             0537*   
0419CB             0538*   ; File information structure (FILINFO)
0419CB             0539*   @filinfo:
0419CB 00 00 00 00 0540*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0419CF 00 00       0541*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0419D1 00 00       0542*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0419D3 00          0543*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0419D4 00 00 00 00 0544*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0419E1 00 00 00 00 0545*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041AE1             0039        ; include "vdu_fonts.inc"
041AE1             0040        ; include "vdu_plot.inc"
041AE1             0041        ; include "vdu_sprites.inc"
041AE1             0042    
041AE1             0043    ; ; APPLICATION INCLUDES
041AE1             0044    ;     include "collisions.inc"
041AE1             0045    ;     include "enemies.inc"
041AE1             0046    ;     include "enemy_fireball.inc"
041AE1             0047    ;     include "enemy_seeker.inc"
041AE1             0048    ;     include "fonts_list.inc"
041AE1             0049    ;     include "images_tiles_dg.inc"
041AE1             0050    ;     ; include "images_tiles_xevious.inc"
041AE1             0051    ;     include "images_sprites.inc"
041AE1             0052    ;     include "images_ui.inc"
041AE1             0053    ;     include "laser.inc"
041AE1             0054    ;     include "levels.inc"
041AE1             0055    ;     include "levels_tileset_0.inc"
041AE1             0056    ;     ; include "levels_xevious.inc"
041AE1             0057    ;     include "player.inc"
041AE1             0058    ;     include "sprites.inc"
041AE1             0059    ;     include "state.inc"
041AE1             0060    ;     include "targeting.inc"
041AE1             0061    
041AE1             0062    ;     include "tiles.inc"
041AE1             0063    ;     include "tile_pad_small.inc"
041AE1             0064    ;     include "tile_turret_fireball.inc"
041AE1             0065    
041AE1             0066        include "test.inc"
041AE1             0001*   
041AE1             0002*   
041AE1             0003*   ; compute orientation to player
041AE1             0004*   ; based on relative positions
041AE1             0005*   ; returns: h.l 16.8 fixed angle256 to player
041AE1             0006*   ;    ub.c and ud.e as 16.8 signed fixed point numbers
041AE1             0007*   ;    representing delta-x/y *to* target respectively
041AE1             0008*   orientation_to_player:
041AE1 DD 2A 09 1B 0009*       ld ix,(sprite_x)
       04          
041AE6 FD 2A 0C 1B 0010*       ld iy,(sprite_y)
       04          
041AEB ED 4B 0F 1B 0011*       ld bc,(player_x)
       04          
041AF0 ED 5B 12 1B 0012*       ld de,(player_y)
       04          
041AF5 CD 1C 0C 04 0013*       call dxy168
041AF9 C5          0014*       push bc ; dx
041AFA D5          0015*       push de ; dy
041AFB CD 9D 0C 04 0016*       call atan2_168fast ; uh.l = angle to player
041AFF 22 1B 1B 04 0017*       ld (Bearing_t),hl
041B03 D1          0018*       pop de ; dy
041B04 C1          0019*       pop bc ; dx
041B05 C9          0020*       ret
041B06             0021*   ; end orientation_to_player
041B06             0022*   
041B06             0023*   ; DEBUG input variables
041B06 00 06 00    0024*   Vp: dl 0x000600 ; 6.000
041B09 00 80 00    0025*   sprite_x: dl 0x008000 ; 128.000
041B0C 00 00 00    0026*   sprite_y: dl 0x000000 ; 0.000
041B0F 00 00 00    0027*   player_x: dl 0x000000 ; 0.000
041B12 00 20 00    0028*   player_y: dl 0x002000 ; 32.000
041B15 00 00 00    0029*   player_xvel: dl 0x000000 ; 0.000
041B18 00 FD FF    0030*   player_yvel: dl 0xFFFD00 ; -4.000
041B1B             0031*   ; END DEBUG input variables
041B1B             0032*   
041B1B             0033*   ; targeting_computer variables fixed 16.8 format
041B1B 00 00 00    0034*   Bearing_t: dl 0x000000 ; angle to target
041B1E 00 00 00    0035*   Heading_t: dl 0x000000 ; angle of target motion
041B21             0036*   ; Vp: dl 0x000000 ; velocity of projectile
041B21 00 00 00    0037*   Vp_x: dl 0x000000 ; x component of projectile velocity
041B24 00 00 00    0038*   Vp_y: dl 0x000000 ; y component of projectile velocity
041B27 00 00 00    0039*   Vt: dl 0x000000 ; velocity of target
041B2A 00 00 00    0040*   Vt_x: dl 0x000000 ; x component of target velocity
041B2D 00 00 00    0041*   Vt_y: dl 0x000000 ; y component of target velocity
041B30             0042*   
041B30 00 00 00    0043*   Heading_p: dl 0x000000 ; angle of projectile motion
041B33 00 00 00    0044*   lead_angle: dl 0x000000 ; lead angle
041B36             0045*   
041B36             0046*   
041B36             0047*   ; Inputs:   Bearing_t, Vp
041B36             0048*   ; Note:     a call to orientation_to_player provides Bearing_t
041B36             0049*   ; Outputs:  uh.l is the 16.8 fixed firing angle256
041B36             0050*   ;           ub.c and ud.e are the 16.8 fixed x,y component projectile velocities
041B36             0051*   ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
041B36             0052*   targeting_computer:
041B36             0053*       ; call vdu_home_cursor ; DEBUG
041B36             0054*   ; compute target velocity from x,y component velocities
041B36 ED 4B 15 1B 0055*       ld bc,(player_xvel)
       04          
041B3B ED 5B 18 1B 0056*       ld de,(player_yvel)
       04          
041B40 21 00 FF FF 0057*       ld hl,-1*256 ; account for vertical ground movement
041B44 19          0058*       add hl,de
041B45 EB          0059*       ex de,hl ; ud.e = player_yvel-1
041B46 CD FD 0B 04 0060*       call cartesian_to_polar_sm ; uh.l = Heading_t, ud.e = Vt
041B4A 22 1E 1B 04 0061*       ld (Heading_t),hl ; PASSES
041B4E ED 53 27 1B 0062*       ld (Vt),de ; PASSES
       04          
041B53             0063*   ; Bearing_t should have been set by orientation_to_player
041B53             0064*   ; compute Heading_t-Bearing_t PASSES
041B53 ED 5B 1B 1B 0065*       ld de,(Bearing_t)
       04          
041B58 A7          0066*       and a ; clear carry
041B59 ED 52       0067*       sbc hl,de ; Uh.l = Heading_t-Bearing_t
041B5B             0068*   ; compute sin(Heading_t-Bearing_t)
041B5B CD 8E 0B 04 0069*       call sin168 ; uh.l = sin(Heading_t-Bearing_t)
041B5F             0070*   ; compute (Vt*sin(Heading_t-Bearing_t))
041B5F ED 5B 27 1B 0071*       ld de,(Vt)
       04          
041B64 CD CA 0A 04 0072*       call smul168 ; uh.l = (Vt*sin(Heading_t-Bearing_t))
041B68             0073*   ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
041B68 ED 5B 06 1B 0074*       ld de,(Vp)
       04          
041B6D CD 2E 0B 04 0075*       call sdiv168 ; ud.e = (Vt*sin(Heading_t-Bearing_t)) / Vp
041B71 EB          0076*       ex de,hl ; uh.l = (Vt*sin(Heading_t-Bearing_t)) / Vp
041B72             0077*   ; answer is in radians, convert to degrees256
041B72 11 BE 28 00 0078*       ld de,0x0028BE ; 40.74 = 57.29578*256/360
041B76 CD CA 0A 04 0079*       call smul168 ; uh.l = angle in degrees256
041B7A 22 33 1B 04 0080*       ld (lead_angle),hl ; DEBUG
041B7E             0081*   ; add lead angle to target bearing
041B7E ED 5B 1B 1B 0082*       ld de,(Bearing_t)
       04          
041B83 19          0083*       add hl,de ; h.l = lead angle+target bearing
041B84 E5          0084*       push hl
041B85             0085*   ; compute component projectile velocities
041B85 ED 5B 06 1B 0086*       ld de,(Vp)
       04          
041B8A CD A9 0B 04 0087*       call polar_to_cartesian ; ub.c = Vp_x, ud.e = Vp_y
041B8E ED 43 21 1B 0088*       ld (Vp_x),bc
       04          
041B93 ED 53 24 1B 0089*       ld (Vp_y),de
       04          
041B98 E1          0090*       pop hl ; uh.l = lead angle+target bearing
041B99 22 30 1B 04 0091*       ld (Heading_p),hl
041B9D             0092*   
041B9D             0093*       PUSH_ALL
041B9D 08          0001*M1     ex af,af'
041B9E D9          0002*M1     exx
041B9F F5          0003*M1     push af
041BA0 E5          0004*M1     push hl
041BA1 C5          0005*M1     push bc
041BA2 D5          0006*M1     push de
041BA3             0007*M1 
041BA3 08          0008*M1     ex af,af'
041BA4 D9          0009*M1     exx
041BA5 F5          0010*M1     push af
041BA6 E5          0011*M1     push hl
041BA7 C5          0012*M1     push bc
041BA8 D5          0013*M1     push de
041BA9 DD E5       0014*M1     push ix
041BAB FD E5       0015*M1     push iy
041BAD             0094*       ; call vdu_home_cursor
041BAD CD 2C 01 04 0095*       call printNewLine
041BB1 CD 10 01 04 0096*       call printInline
041BB5 42 74 20 00 0097*       asciz "Bt "
041BB9 2A 1B 1B 04 0098*       ld hl,(Bearing_t)
041BBD CD 38 03 04 0099*       call print_s168_hl
041BC1             0100*   
041BC1             0101*       ; call printInline
041BC1             0102*       ; asciz "\r\nHt "
041BC1             0103*       ; ld hl,(Heading_t)
041BC1             0104*       ; call print_s168_hl
041BC1             0105*   
041BC1             0106*       ; call printInline
041BC1             0107*       ; asciz "\r\nVt "
041BC1             0108*       ; ld hl,(Vt)
041BC1             0109*       ; call print_s168_hl
041BC1             0110*   
041BC1             0111*       ; call printInline
041BC1             0112*       ; asciz "\r\nVtx"
041BC1             0113*       ; ld hl,(player_xvel)
041BC1             0114*       ; call print_s168_hl
041BC1             0115*   
041BC1             0116*       ; call printInline
041BC1             0117*       ; asciz "\r\nVty"
041BC1             0118*       ; ld hl,(player_yvel)
041BC1             0119*       ; ld de,-1*256 ; account for vertical ground movement
041BC1             0120*       ; add hl,de
041BC1             0121*       ; call print_s168_hl
041BC1             0122*   
041BC1 CD 10 01 04 0123*       call printInline
041BC5 0D 0A 4C 64 0124*       asciz "\r\nLda"
       61 00       
041BCB 2A 33 1B 04 0125*       ld hl,(lead_angle)
041BCF CD 38 03 04 0126*       call print_s168_hl
041BD3             0127*   
041BD3 CD 10 01 04 0128*       call printInline
041BD7 0D 0A 48 70 0129*       asciz "\r\nHp "
       20 00       
041BDD 2A 30 1B 04 0130*       ld hl,(Heading_p)
041BE1 CD 38 03 04 0131*       call print_s168_hl
041BE5             0132*   
041BE5             0133*       ; call printInline
041BE5             0134*       ; asciz "\r\nVp "
041BE5             0135*       ; ld hl,(Vp)
041BE5             0136*       ; call print_s168_hl
041BE5             0137*   
041BE5             0138*       ; call printInline
041BE5             0139*       ; asciz "\r\nVpx"
041BE5             0140*       ; ld hl,(Vp_x)
041BE5             0141*       ; call print_s168_hl
041BE5             0142*   
041BE5             0143*       ; call printInline
041BE5             0144*       ; asciz "\r\nVpy"
041BE5             0145*       ; ld hl,(Vp_y)
041BE5             0146*       ; call print_s168_hl
041BE5             0147*   
041BE5             0148*       POP_ALL
041BE5 FD E1       0001*M1     pop iy
041BE7 DD E1       0002*M1     pop ix
041BE9 D1          0003*M1     pop de
041BEA C1          0004*M1     pop bc
041BEB E1          0005*M1     pop hl
041BEC F1          0006*M1     pop af
041BED 08          0007*M1     ex af,af'
041BEE D9          0008*M1     exx
041BEF             0009*M1 
041BEF D1          0010*M1     pop de
041BF0 C1          0011*M1     pop bc
041BF1 E1          0012*M1     pop hl
041BF2 F1          0013*M1     pop af
041BF3 08          0014*M1     ex af,af'
041BF4 D9          0015*M1     exx
041BF5 C9          0149*       ret
041BF6             0067    
041BF6 FF FF FF FF 0068        align 256
       FF FF FF FF 
       FF FF       
041C00             0069    
041C00             0070    ; --- MAIN PROGRAM FILE ---
041C00             0071    
041C00             0072    init:
041C00             0073    
041C00 C9          0074        ret
041C01             0075    
041C01             0076    main:
041C01 CD 2C 01 04 0077        call printNewLine
041C05 CD E1 1A 04 0078        call orientation_to_player
041C09 CD 36 1B 04 0079        call targeting_computer
041C0D             0080    
041C0D             0081    
041C0D C9          0082        ret
041C0E             0083    
041C0E             0084    
041C0E             0085    DEBUG_PRINT:
041C0E             0086        PUSH_ALL
041C0E 08          0001M1      ex af,af'
041C0F D9          0002M1      exx
041C10 F5          0003M1      push af
041C11 E5          0004M1      push hl
041C12 C5          0005M1      push bc
041C13 D5          0006M1      push de
041C14             0007M1  
041C14 08          0008M1      ex af,af'
041C15 D9          0009M1      exx
041C16 F5          0010M1      push af
041C17 E5          0011M1      push hl
041C18 C5          0012M1      push bc
041C19 D5          0013M1      push de
041C1A DD E5       0014M1      push ix
041C1C FD E5       0015M1      push iy
041C1E 0E 00       0087        ld c,0
041C20 06 00       0088        ld b,0
041C22 CD 37 17 04 0089        call vdu_move_cursor
041C26             0090        POP_ALL
041C26 FD E1       0001M1      pop iy
041C28 DD E1       0002M1      pop ix
041C2A D1          0003M1      pop de
041C2B C1          0004M1      pop bc
041C2C E1          0005M1      pop hl
041C2D F1          0006M1      pop af
041C2E 08          0007M1      ex af,af'
041C2F D9          0008M1      exx
041C30             0009M1  
041C30 D1          0010M1      pop de
041C31 C1          0011M1      pop bc
041C32 E1          0012M1      pop hl
041C33 F1          0013M1      pop af
041C34 08          0014M1      ex af,af'
041C35 D9          0015M1      exx
041C36             0091        PUSH_ALL
041C36 08          0001M1      ex af,af'
041C37 D9          0002M1      exx
041C38 F5          0003M1      push af
041C39 E5          0004M1      push hl
041C3A C5          0005M1      push bc
041C3B D5          0006M1      push de
041C3C             0007M1  
041C3C 08          0008M1      ex af,af'
041C3D D9          0009M1      exx
041C3E F5          0010M1      push af
041C3F E5          0011M1      push hl
041C40 C5          0012M1      push bc
041C41 D5          0013M1      push de
041C42 DD E5       0014M1      push ix
041C44 FD E5       0015M1      push iy
041C46 CD 64 06 04 0092        call dumpFlags
041C4A             0093        POP_ALL
041C4A FD E1       0001M1      pop iy
041C4C DD E1       0002M1      pop ix
041C4E D1          0003M1      pop de
041C4F C1          0004M1      pop bc
041C50 E1          0005M1      pop hl
041C51 F1          0006M1      pop af
041C52 08          0007M1      ex af,af'
041C53 D9          0008M1      exx
041C54             0009M1  
041C54 D1          0010M1      pop de
041C55 C1          0011M1      pop bc
041C56 E1          0012M1      pop hl
041C57 F1          0013M1      pop af
041C58 08          0014M1      ex af,af'
041C59 D9          0015M1      exx
041C5A             0094        PUSH_ALL
041C5A 08          0001M1      ex af,af'
041C5B D9          0002M1      exx
041C5C F5          0003M1      push af
041C5D E5          0004M1      push hl
041C5E C5          0005M1      push bc
041C5F D5          0006M1      push de
041C60             0007M1  
041C60 08          0008M1      ex af,af'
041C61 D9          0009M1      exx
041C62 F5          0010M1      push af
041C63 E5          0011M1      push hl
041C64 C5          0012M1      push bc
041C65 D5          0013M1      push de
041C66 DD E5       0014M1      push ix
041C68 FD E5       0015M1      push iy
041C6A CD C6 04 04 0095        call dumpRegistersHex
041C6E             0096        ; call waitKeypress
041C6E             0097        POP_ALL
041C6E FD E1       0001M1      pop iy
041C70 DD E1       0002M1      pop ix
041C72 D1          0003M1      pop de
041C73 C1          0004M1      pop bc
041C74 E1          0005M1      pop hl
041C75 F1          0006M1      pop af
041C76 08          0007M1      ex af,af'
041C77 D9          0008M1      exx
041C78             0009M1  
041C78 D1          0010M1      pop de
041C79 C1          0011M1      pop bc
041C7A E1          0012M1      pop hl
041C7B F1          0013M1      pop af
041C7C 08          0014M1      ex af,af'
041C7D D9          0015M1      exx
041C7E C9          0098        ret
