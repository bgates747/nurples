PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "src/asm/macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 51 6E 04 0030   	call	init			; Initialization code
040050 CD DC 6E 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "src/asm/images2.inc"
040060             0001*  ; Bitmap indices:
040060             0002*  BUF_0TILE_EMPTY: equ $0100
040060             0003*  BUF_1TILE_CROSS: equ $0101
040060             0004*  BUF_2TILE_HORIZ: equ $0102
040060             0005*  BUF_3TILE_VERT: equ $0103
040060             0006*  BUF_4TILE_SQUARE: equ $0104
040060             0007*  BUF_5TILE_CIRCLE: equ $0105
040060             0008*  BUF_6TILE_PAD: equ $0106
040060             0009*  BUF_7TILE_TURRET: equ $0107
040060             0010*  BUF_CIRCLE: equ $0108
040060             0011*  BUF_CRATER: equ $0109
040060             0012*  BUF_EXPLOSION_A: equ $010A
040060             0013*  BUF_EXPLOSION_B: equ $010B
040060             0014*  BUF_EXPLOSION_C: equ $010C
040060             0015*  BUF_EXPLOSION_D: equ $010D
040060             0016*  BUF_EXPLOSION_E: equ $010E
040060             0017*  BUF_FIREBALL_A: equ $010F
040060             0018*  BUF_FIREBALL_B: equ $0110
040060             0019*  BUF_LASER_A: equ $0111
040060             0020*  BUF_LASER_B: equ $0112
040060             0021*  BUF_PAD: equ $0113
040060             0022*  BUF_SEEKER_000: equ $0114
040060             0023*  BUF_SEEKER_001: equ $0115
040060             0024*  BUF_SEEKER_002: equ $0116
040060             0025*  BUF_SEEKER_003: equ $0117
040060             0026*  BUF_SEEKER_004: equ $0118
040060             0027*  BUF_SEEKER_005: equ $0119
040060             0028*  BUF_SEEKER_006: equ $011A
040060             0029*  BUF_SEEKER_007: equ $011B
040060             0030*  BUF_SEEKER_008: equ $011C
040060             0031*  BUF_SEEKER_009: equ $011D
040060             0032*  BUF_SEEKER_010: equ $011E
040060             0033*  BUF_SEEKER_011: equ $011F
040060             0034*  BUF_SEEKER_012: equ $0120
040060             0035*  BUF_SEEKER_013: equ $0121
040060             0036*  BUF_SEEKER_014: equ $0122
040060             0037*  BUF_SEEKER_015: equ $0123
040060             0038*  BUF_SEEKER_016: equ $0124
040060             0039*  BUF_SEEKER_017: equ $0125
040060             0040*  BUF_SEEKER_018: equ $0126
040060             0041*  BUF_SEEKER_019: equ $0127
040060             0042*  BUF_SEEKER_020: equ $0128
040060             0043*  BUF_SEEKER_021: equ $0129
040060             0044*  BUF_SEEKER_022: equ $012A
040060             0045*  BUF_SEEKER_023: equ $012B
040060             0046*  BUF_SEEKER_024: equ $012C
040060             0047*  BUF_SEEKER_025: equ $012D
040060             0048*  BUF_SEEKER_026: equ $012E
040060             0049*  BUF_SEEKER_027: equ $012F
040060             0050*  BUF_SEEKER_028: equ $0130
040060             0051*  BUF_SEEKER_029: equ $0131
040060             0052*  BUF_SEEKER_030: equ $0132
040060             0053*  BUF_SEEKER_031: equ $0133
040060             0054*  BUF_SHIP_0L: equ $0134
040060             0055*  BUF_SHIP_1C: equ $0135
040060             0056*  BUF_SHIP_2R: equ $0136
040060             0057*  BUF_SHIP_SMALL: equ $0137
040060             0058*  BUF_STAR: equ $0138
040060             0059*  BUF_TURRET: equ $0139
040060             0060*  BUF_TURRET_ROT: equ $013A
040060             0061*  
040060             0062*  ; import .rgba bitmap files and load them into VDP buffers
040060             0063*  bmp2_init:
040060 21 6B 00 04 0064*  	ld hl, @cmd
040064 01 76 3C 00 0065*  	ld bc, @end-@cmd
040068 5B DF       0066*  	rst.lil $18
04006A C9          0067*  	ret
04006B             0068*  @cmd:
04006B             0069*  	LOADBMPBUFFER2 BUF_0TILE_EMPTY,16,16,"src/rgba2/0tile_empty.rgba2"
04006B             0001*M 
04006B             0002*M     ; Clear buffer
04006B 17 00 A0    0003*M     db 23,0,0xA0
04006E 00 01       0004*M     dw bufferId
040070 02          0005*M     db 2
040071             0006*M 
040071 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040074 00 01       0008*M     dw bufferId
040076             0009*M 
040076             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040076 17 00 A0    0011*M     db 23,0,0xA0
040079 00 01       0012*M     dw bufferId
04007B 00          0013*M     db 0
04007C 00 01       0014*M 	dw width * height ; length of data in bytes
04007E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04017E             0016*M 
04017E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04017E 17 1B 21    0018*M     db 23,27,0x21
040181 10 00       0019*M     dw width ; in pixels
040183 10 00       0020*M     dw height ; in pixels
040185 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040186             0070*  	LOADBMPBUFFER2 BUF_1TILE_CROSS,16,16,"src/rgba2/1tile_cross.rgba2"
040186             0001*M 
040186             0002*M     ; Clear buffer
040186 17 00 A0    0003*M     db 23,0,0xA0
040189 01 01       0004*M     dw bufferId
04018B 02          0005*M     db 2
04018C             0006*M 
04018C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04018F 01 01       0008*M     dw bufferId
040191             0009*M 
040191             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040191 17 00 A0    0011*M     db 23,0,0xA0
040194 01 01       0012*M     dw bufferId
040196 00          0013*M     db 0
040197 00 01       0014*M 	dw width * height ; length of data in bytes
040199 00 00 D0 F5 0015*M     incbin file ; bitmap data
       FA FF FF FF 
       FF FF FF EA 
       F5 D0 00 00 
       00 00 D0 F5 
       FA EA FF FF 
       FF FF EA EA 
       F5 D0 00 00 
       D0 D0 D0 F5 
       FA FF FF FF 
       FF FF EA EA 
       F5 D0 D0 D0 
       F5 F5 F5 F5 
       FB FA EA EA 
       EA EA EA E5 
       F5 F5 F5 F5 
       D1 E5 E5 D0 
       FA FB E5 FA 
       FA FA FA FA 
       C0 D0 D0 D0 
       E1 E1 D0 D0 
       FA D1 D0 D1 
       D0 D0 D0 EA 
       D1 D1 D1 D1 
       FA FF E5 E5 
       E5 D0 F8 FD 
       FE F8 D0 E5 
       D1 E5 E5 E5 
       FA FF FA E5 
       E5 D0 F8 FD 
       FE F8 D0 FA 
       E5 E5 E5 E5 
       E5 FB FA E5 
       E5 D0 F8 FD 
       FE F8 E1 FA 
       E5 E5 E5 E5 
       FA FA FA E5 
       E5 D0 F8 FD 
       FD F8 D0 FA 
       E5 E5 E5 E5 
       E5 E5 E5 E5 
       E5 D0 F8 F8 
       F8 F8 D0 FA 
       D1 D1 D1 D1 
       E1 E1 E1 E1 
       D1 D0 D0 D0 
       D0 D0 D0 E5 
       D0 D1 D0 D0 
       F5 F5 F5 F5 
       E5 D1 E1 E5 
       E5 E5 E5 E5 
       F5 F5 F5 F5 
       D0 D0 D0 F5 
       E5 E5 E5 E5 
       E6 E5 E5 E5 
       F5 D0 D0 D0 
       00 00 D0 F5 
       E5 E6 D6 E6 
       D7 E6 E6 E5 
       F5 D0 00 00 
       00 00 D0 F5 
       E5 E6 E6 D6 
       D6 D6 E6 E5 
       F5 D0 00 00 
040299             0016*M 
040299             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040299 17 1B 21    0018*M     db 23,27,0x21
04029C 10 00       0019*M     dw width ; in pixels
04029E 10 00       0020*M     dw height ; in pixels
0402A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0402A1             0071*  	LOADBMPBUFFER2 BUF_2TILE_HORIZ,16,16,"src/rgba2/2tile_horiz.rgba2"
0402A1             0001*M 
0402A1             0002*M     ; Clear buffer
0402A1 17 00 A0    0003*M     db 23,0,0xA0
0402A4 02 01       0004*M     dw bufferId
0402A6 02          0005*M     db 2
0402A7             0006*M 
0402A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0402AA 02 01       0008*M     dw bufferId
0402AC             0009*M 
0402AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0402AC 17 00 A0    0011*M     db 23,0,0xA0
0402AF 02 01       0012*M     dw bufferId
0402B1 00          0013*M     db 0
0402B2 00 01       0014*M 	dw width * height ; length of data in bytes
0402B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF F8 
       F8 F8 F8 EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF FF 
       EA EA FA FA 
       F8 F8 EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FA E5 
       F8 F8 EA EA 
       D0 E6 E6 D1 
       D1 D1 D1 EA 
       EA F8 F5 F5 
       EA F8 EA D0 
       C0 D1 D1 D1 
       D1 D2 D1 D0 
       D0 EA F5 E5 
       EA EA F8 E5 
       E5 E6 E6 E6 
       E6 E6 D1 F8 
       E5 EA E5 E5 
       EA E5 D1 D1 
       D1 D1 D1 D1 
       D1 D1 C0 D1 
       EA D1 EA D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0403B4             0016*M 
0403B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0403B4 17 1B 21    0018*M     db 23,27,0x21
0403B7 10 00       0019*M     dw width ; in pixels
0403B9 10 00       0020*M     dw height ; in pixels
0403BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0403BC             0072*  	LOADBMPBUFFER2 BUF_3TILE_VERT,16,16,"src/rgba2/3tile_vert.rgba2"
0403BC             0001*M 
0403BC             0002*M     ; Clear buffer
0403BC 17 00 A0    0003*M     db 23,0,0xA0
0403BF 03 01       0004*M     dw bufferId
0403C1 02          0005*M     db 2
0403C2             0006*M 
0403C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0403C5 03 01       0008*M     dw bufferId
0403C7             0009*M 
0403C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0403C7 17 00 A0    0011*M     db 23,0,0xA0
0403CA 03 01       0012*M     dw bufferId
0403CC 00          0013*M     db 0
0403CD 00 01       0014*M 	dw width * height ; length of data in bytes
0403CF 00 00 D0 F5 0015*M     incbin file ; bitmap data
       D0 D0 D0 D0 
       E5 E5 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 E5 E5 
       E5 F8 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E5 E5 
       FA F8 FD F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E1 E5 
       E5 E5 FA F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 D0 D1 
       E6 E6 FA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D1 D1 D1 
       FB EA FB D1 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 EA C0 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E1 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 C0 EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 F8 F8 
       FA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       EA EA F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 E5 F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
0404CF             0016*M 
0404CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0404CF 17 1B 21    0018*M     db 23,27,0x21
0404D2 10 00       0019*M     dw width ; in pixels
0404D4 10 00       0020*M     dw height ; in pixels
0404D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0404D7             0073*  	LOADBMPBUFFER2 BUF_4TILE_SQUARE,16,16,"src/rgba2/4tile_square.rgba2"
0404D7             0001*M 
0404D7             0002*M     ; Clear buffer
0404D7 17 00 A0    0003*M     db 23,0,0xA0
0404DA 04 01       0004*M     dw bufferId
0404DC 02          0005*M     db 2
0404DD             0006*M 
0404DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0404E0 04 01       0008*M     dw bufferId
0404E2             0009*M 
0404E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0404E2 17 00 A0    0011*M     db 23,0,0xA0
0404E5 04 01       0012*M     dw bufferId
0404E7 00          0013*M     db 0
0404E8 00 01       0014*M 	dw width * height ; length of data in bytes
0404EA D0 D1 E5 D1 0015*M     incbin file ; bitmap data
       E5 E5 D0 D5 
       D0 D0 D0 D0 
       D0 D5 D0 D1 
       D5 EA EA EA 
       EA E5 E5 E5 
       E5 E5 E5 D5 
       D1 FF E9 D5 
       D0 EA EA D5 
       D5 D5 D1 D5 
       D4 D4 FE FE 
       D1 EA E5 D5 
       D0 C0 D1 D1 
       D2 D2 E6 E9 
       FE FE FE FE 
       C0 C0 C0 D1 
       D0 D1 D1 D2 
       D2 D2 E6 D4 
       E9 E9 FE FE 
       D1 D0 D0 D0 
       D0 D1 D2 D2 
       D2 D2 D5 C0 
       D1 D1 D4 E9 
       D1 C0 E5 D0 
       D0 D1 C0 D5 
       D5 D5 E6 E6 
       E6 E6 D1 E5 
       E5 C0 E5 E5 
       D0 D1 D1 E9 
       FE D5 D1 D2 
       D2 D1 D1 E9 
       E9 C0 D1 D0 
       E5 D1 C0 D0 
       E5 D0 D1 D2 
       D2 D1 D1 E5 
       E5 C0 EA D0 
       E5 E5 C0 C0 
       D5 C1 D5 D1 
       D1 C1 D1 D0 
       D4 D5 EA D0 
       E5 E5 D5 D2 
       D2 D2 D0 D0 
       D5 D5 D5 E9 
       E9 C0 EA E5 
       E5 E5 D5 D2 
       D2 D2 EA E9 
       FA FA D4 E6 
       E5 D5 E5 D1 
       D0 EA D5 D2 
       D1 C1 D5 E5 
       E9 E9 D0 E5 
       D0 E5 E5 E5 
       D0 D4 E9 D4 
       C0 C0 D5 C0 
       D0 D0 C0 D0 
       D0 EA EA D0 
       D0 D4 D4 D5 
       C0 D0 D5 C0 
       C0 C0 D0 C0 
       D0 D0 D0 D0 
       D0 D0 D0 C0 
       C0 D0 D0 D0 
       D5 D0 D0 C0 
       D0 D5 D0 D0 
0405EA             0016*M 
0405EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0405EA 17 1B 21    0018*M     db 23,27,0x21
0405ED 10 00       0019*M     dw width ; in pixels
0405EF 10 00       0020*M     dw height ; in pixels
0405F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0405F2             0074*  	LOADBMPBUFFER2 BUF_5TILE_CIRCLE,16,16,"src/rgba2/5tile_circle.rgba2"
0405F2             0001*M 
0405F2             0002*M     ; Clear buffer
0405F2 17 00 A0    0003*M     db 23,0,0xA0
0405F5 05 01       0004*M     dw bufferId
0405F7 02          0005*M     db 2
0405F8             0006*M 
0405F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0405FB 05 01       0008*M     dw bufferId
0405FD             0009*M 
0405FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0405FD 17 00 A0    0011*M     db 23,0,0xA0
040600 05 01       0012*M     dw bufferId
040602 00          0013*M     db 0
040603 00 01       0014*M 	dw width * height ; length of data in bytes
040605 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 D0 D0 D1 
       EA D1 D1 D0 
       D0 00 00 00 
       00 00 D0 D0 
       D0 D1 D1 EA 
       FB EA D1 D1 
       D0 D0 00 00 
       00 D0 D0 D1 
       D1 D0 D0 D1 
       D1 EA D1 E5 
       EA D0 D0 00 
       00 D0 E1 D1 
       D0 D0 CA EA 
       EA D7 EA E6 
       D1 D1 D0 00 
       D0 D1 E1 FA 
       D1 CA EF FF 
       FF EF D7 D0 
       D1 D1 D1 D0 
       D0 D0 D0 E5 
       FB EA EF FF 
       FF EF EA D0 
       E5 D0 D0 D0 
       D0 E1 D0 EA 
       EA EF EF EF 
       EF EF EA E5 
       EA D0 D0 D0 
       D0 D0 D0 D1 
       EA F8 EA EA 
       EA EA F8 D0 
       EA D0 D1 D0 
       D0 D0 D1 D1 
       E5 EA F8 F8 
       F8 F8 E5 E1 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D1 E5 E5 E1 
       E1 E1 E1 D0 
       D0 D1 D0 D0 
       00 D0 D0 D0 
       D0 D0 C0 D0 
       D0 C0 D0 D0 
       D0 C0 D0 00 
       00 D0 D0 D0 
       C0 C0 EA E6 
       E6 D1 C0 C0 
       D0 D0 D0 00 
       00 00 D0 D0 
       C0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 D0 00 00 
       00 00 00 D0 
       D0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040705             0016*M 
040705             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040705 17 1B 21    0018*M     db 23,27,0x21
040708 10 00       0019*M     dw width ; in pixels
04070A 10 00       0020*M     dw height ; in pixels
04070C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04070D             0075*  	LOADBMPBUFFER2 BUF_6TILE_PAD,16,16,"src/rgba2/6tile_pad.rgba2"
04070D             0001*M 
04070D             0002*M     ; Clear buffer
04070D 17 00 A0    0003*M     db 23,0,0xA0
040710 06 01       0004*M     dw bufferId
040712 02          0005*M     db 2
040713             0006*M 
040713 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040716 06 01       0008*M     dw bufferId
040718             0009*M 
040718             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040718 17 00 A0    0011*M     db 23,0,0xA0
04071B 06 01       0012*M     dw bufferId
04071D 00          0013*M     db 0
04071E 00 01       0014*M 	dw width * height ; length of data in bytes
040720 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
040820             0016*M 
040820             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040820 17 1B 21    0018*M     db 23,27,0x21
040823 10 00       0019*M     dw width ; in pixels
040825 10 00       0020*M     dw height ; in pixels
040827 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040828             0076*  	LOADBMPBUFFER2 BUF_7TILE_TURRET,16,16,"src/rgba2/7tile_turret.rgba2"
040828             0001*M 
040828             0002*M     ; Clear buffer
040828 17 00 A0    0003*M     db 23,0,0xA0
04082B 07 01       0004*M     dw bufferId
04082D 02          0005*M     db 2
04082E             0006*M 
04082E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040831 07 01       0008*M     dw bufferId
040833             0009*M 
040833             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040833 17 00 A0    0011*M     db 23,0,0xA0
040836 07 01       0012*M     dw bufferId
040838 00          0013*M     db 0
040839 00 01       0014*M 	dw width * height ; length of data in bytes
04083B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
04093B             0016*M 
04093B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04093B 17 1B 21    0018*M     db 23,27,0x21
04093E 10 00       0019*M     dw width ; in pixels
040940 10 00       0020*M     dw height ; in pixels
040942 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040943             0077*  	LOADBMPBUFFER2 BUF_CIRCLE,16,16,"src/rgba2/circle.rgba2"
040943             0001*M 
040943             0002*M     ; Clear buffer
040943 17 00 A0    0003*M     db 23,0,0xA0
040946 08 01       0004*M     dw bufferId
040948 02          0005*M     db 2
040949             0006*M 
040949 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04094C 08 01       0008*M     dw bufferId
04094E             0009*M 
04094E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04094E 17 00 A0    0011*M     db 23,0,0xA0
040951 08 01       0012*M     dw bufferId
040953 00          0013*M     db 0
040954 00 01       0014*M 	dw width * height ; length of data in bytes
040956 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040A56             0016*M 
040A56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040A56 17 1B 21    0018*M     db 23,27,0x21
040A59 10 00       0019*M     dw width ; in pixels
040A5B 10 00       0020*M     dw height ; in pixels
040A5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040A5E             0078*  	LOADBMPBUFFER2 BUF_CRATER,16,16,"src/rgba2/crater.rgba2"
040A5E             0001*M 
040A5E             0002*M     ; Clear buffer
040A5E 17 00 A0    0003*M     db 23,0,0xA0
040A61 09 01       0004*M     dw bufferId
040A63 02          0005*M     db 2
040A64             0006*M 
040A64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040A67 09 01       0008*M     dw bufferId
040A69             0009*M 
040A69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A69 17 00 A0    0011*M     db 23,0,0xA0
040A6C 09 01       0012*M     dw bufferId
040A6E 00          0013*M     db 0
040A6F 00 01       0014*M 	dw width * height ; length of data in bytes
040A71 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E2 C0 F2 
       C0 D1 E2 00 
       00 00 00 00 
       00 00 D2 D5 
       C0 D2 C0 C6 
       D1 C6 D1 C1 
       C0 E2 00 00 
       00 F2 EA D5 
       DF C0 D1 D2 
       DF D2 D1 C1 
       C0 EA C0 00 
       00 F2 D5 C0 
       C0 C0 CB D1 
       D6 DF D5 C0 
       C0 C0 D5 00 
       F2 D5 C0 C6 
       C0 CB D1 D6 
       D6 D7 D6 C0 
       D5 C1 C0 C0 
       D5 C0 C0 D5 
       C1 D1 C1 D6 
       C2 D7 C2 C1 
       C0 CB C1 C1 
       C1 C6 C0 C1 
       DF C2 D6 D7 
       D7 DB D6 CB 
       C1 D6 D6 D5 
       C0 C0 C0 D5 
       F7 D6 D7 DB 
       EB EF D7 D6 
       D6 CB C1 C1 
       C1 D6 C0 C1 
       D6 EB EB FF 
       CB FF FF EB 
       D6 C1 C1 D5 
       EA D5 C0 DF 
       C2 EA EA FF 
       FF FF EA C0 
       D6 D2 D5 C0 
       00 FA C2 D5 
       D5 C1 C0 CB 
       EA C0 D6 C1 
       C1 D5 E2 00 
       00 F2 FA C1 
       D5 D6 D5 C2 
       C0 D2 D2 D5 
       D6 C1 D5 00 
       00 00 FA F2 
       EB D6 C0 C0 
       C1 D5 D6 D6 
       EA D5 00 00 
       00 00 00 00 
       00 FA F6 F2 
       FA F6 F6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71             0016*M 
040B71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040B71 17 1B 21    0018*M     db 23,27,0x21
040B74 10 00       0019*M     dw width ; in pixels
040B76 10 00       0020*M     dw height ; in pixels
040B78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040B79             0079*  	LOADBMPBUFFER2 BUF_EXPLOSION_A,16,16,"src/rgba2/explosion_a.rgba2"
040B79             0001*M 
040B79             0002*M     ; Clear buffer
040B79 17 00 A0    0003*M     db 23,0,0xA0
040B7C 0A 01       0004*M     dw bufferId
040B7E 02          0005*M     db 2
040B7F             0006*M 
040B7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040B82 0A 01       0008*M     dw bufferId
040B84             0009*M 
040B84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B84 17 00 A0    0011*M     db 23,0,0xA0
040B87 0A 01       0012*M     dw bufferId
040B89 00          0013*M     db 0
040B8A 00 01       0014*M 	dw width * height ; length of data in bytes
040B8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 EF 
       EF EF C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C8C             0016*M 
040C8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040C8C 17 1B 21    0018*M     db 23,27,0x21
040C8F 10 00       0019*M     dw width ; in pixels
040C91 10 00       0020*M     dw height ; in pixels
040C93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040C94             0080*  	LOADBMPBUFFER2 BUF_EXPLOSION_B,16,16,"src/rgba2/explosion_b.rgba2"
040C94             0001*M 
040C94             0002*M     ; Clear buffer
040C94 17 00 A0    0003*M     db 23,0,0xA0
040C97 0B 01       0004*M     dw bufferId
040C99 02          0005*M     db 2
040C9A             0006*M 
040C9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040C9D 0B 01       0008*M     dw bufferId
040C9F             0009*M 
040C9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040C9F 17 00 A0    0011*M     db 23,0,0xA0
040CA2 0B 01       0012*M     dw bufferId
040CA4 00          0013*M     db 0
040CA5 00 01       0014*M 	dw width * height ; length of data in bytes
040CA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 00 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 00 C7 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040DA7             0016*M 
040DA7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040DA7 17 1B 21    0018*M     db 23,27,0x21
040DAA 10 00       0019*M     dw width ; in pixels
040DAC 10 00       0020*M     dw height ; in pixels
040DAE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040DAF             0081*  	LOADBMPBUFFER2 BUF_EXPLOSION_C,16,16,"src/rgba2/explosion_c.rgba2"
040DAF             0001*M 
040DAF             0002*M     ; Clear buffer
040DAF 17 00 A0    0003*M     db 23,0,0xA0
040DB2 0C 01       0004*M     dw bufferId
040DB4 02          0005*M     db 2
040DB5             0006*M 
040DB5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040DB8 0C 01       0008*M     dw bufferId
040DBA             0009*M 
040DBA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040DBA 17 00 A0    0011*M     db 23,0,0xA0
040DBD 0C 01       0012*M     dw bufferId
040DBF 00          0013*M     db 0
040DC0 00 01       0014*M 	dw width * height ; length of data in bytes
040DC2 00 C7 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 C6 
       C7 C7 C6 00 
       00 00 00 00 
       C7 C7 EF EF 
       EF EF C7 C6 
       C7 C7 C6 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C6 C6 00 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 EF 
       EF EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       00 C6 C6 C6 
       C6 EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 C7 EF 
       C7 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 00 C7 
       C7 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 C6 C6 C6 
       C6 C7 EF EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040EC2             0016*M 
040EC2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040EC2 17 1B 21    0018*M     db 23,27,0x21
040EC5 10 00       0019*M     dw width ; in pixels
040EC7 10 00       0020*M     dw height ; in pixels
040EC9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040ECA             0082*  	LOADBMPBUFFER2 BUF_EXPLOSION_D,16,16,"src/rgba2/explosion_d.rgba2"
040ECA             0001*M 
040ECA             0002*M     ; Clear buffer
040ECA 17 00 A0    0003*M     db 23,0,0xA0
040ECD 0D 01       0004*M     dw bufferId
040ECF 02          0005*M     db 2
040ED0             0006*M 
040ED0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040ED3 0D 01       0008*M     dw bufferId
040ED5             0009*M 
040ED5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040ED5 17 00 A0    0011*M     db 23,0,0xA0
040ED8 0D 01       0012*M     dw bufferId
040EDA 00          0013*M     db 0
040EDB 00 01       0014*M 	dw width * height ; length of data in bytes
040EDD 00 C7 C7 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C7 C7 00 
       00 00 C6 C6 
       C6 C6 00 C6 
       00 00 00 00 
       00 00 00 00 
       C6 C6 C7 C7 
       C7 C7 C6 C6 
       C6 C6 00 00 
       00 00 00 C6 
       C7 C7 EF EF 
       EF EF EF EF 
       C6 C6 00 C6 
       00 00 C6 C7 
       EF EF EF EF 
       EF EF EF C6 
       C7 C6 00 00 
       00 00 C6 C7 
       EF EF EF 00 
       00 EF EF EF 
       C7 C6 C6 00 
       00 C6 C7 EF 
       EF EF 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       00 C6 C7 EF 
       EF 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       00 C7 C7 C7 
       C7 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       C7 C6 C7 EF 
       EF C7 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       C6 00 C6 C7 
       EF C7 EF 00 
       00 EF EF EF 
       C7 C6 00 00 
       C6 00 C6 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 C6 00 00 
       C6 00 00 C6 
       C7 C7 EF EF 
       EF EF C7 C7 
       C6 00 00 00 
       00 C6 C6 C6 
       C7 C6 C7 C7 
       C7 C7 C6 C6 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FDD             0016*M 
040FDD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040FDD 17 1B 21    0018*M     db 23,27,0x21
040FE0 10 00       0019*M     dw width ; in pixels
040FE2 10 00       0020*M     dw height ; in pixels
040FE4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040FE5             0083*  	LOADBMPBUFFER2 BUF_EXPLOSION_E,16,16,"src/rgba2/explosion_e.rgba2"
040FE5             0001*M 
040FE5             0002*M     ; Clear buffer
040FE5 17 00 A0    0003*M     db 23,0,0xA0
040FE8 0E 01       0004*M     dw bufferId
040FEA 02          0005*M     db 2
040FEB             0006*M 
040FEB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040FEE 0E 01       0008*M     dw bufferId
040FF0             0009*M 
040FF0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040FF0 17 00 A0    0011*M     db 23,0,0xA0
040FF3 0E 01       0012*M     dw bufferId
040FF5 00          0013*M     db 0
040FF6 00 01       0014*M 	dw width * height ; length of data in bytes
040FF8 00 00 00 C6 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 C6 C7 C7 
       C7 C7 C7 C6 
       00 00 00 00 
       00 00 C6 C6 
       C7 C7 00 00 
       00 00 00 00 
       C7 00 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0410F8             0016*M 
0410F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0410F8 17 1B 21    0018*M     db 23,27,0x21
0410FB 10 00       0019*M     dw width ; in pixels
0410FD 10 00       0020*M     dw height ; in pixels
0410FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041100             0084*  	LOADBMPBUFFER2 BUF_FIREBALL_A,7,7,"src/rgba2/fireball_a.rgba2"
041100             0001*M 
041100             0002*M     ; Clear buffer
041100 17 00 A0    0003*M     db 23,0,0xA0
041103 0F 01       0004*M     dw bufferId
041105 02          0005*M     db 2
041106             0006*M 
041106 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041109 0F 01       0008*M     dw bufferId
04110B             0009*M 
04110B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04110B 17 00 A0    0011*M     db 23,0,0xA0
04110E 0F 01       0012*M     dw bufferId
041110 00          0013*M     db 0
041111 31 00       0014*M 	dw width * height ; length of data in bytes
041113 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 D2 CB 
       D1 00 D2 CB 
       D6 D7 DB D7 
       D2 D7 D2 D6 
       DB D2 D2 D2 
       D2 D2 D6 D6 
       D6 C3 D1 00 
       D1 C3 D2 CB 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041144             0016*M 
041144             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041144 17 1B 21    0018*M     db 23,27,0x21
041147 07 00       0019*M     dw width ; in pixels
041149 07 00       0020*M     dw height ; in pixels
04114B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04114C             0085*  	LOADBMPBUFFER2 BUF_FIREBALL_B,7,7,"src/rgba2/fireball_b.rgba2"
04114C             0001*M 
04114C             0002*M     ; Clear buffer
04114C 17 00 A0    0003*M     db 23,0,0xA0
04114F 10 01       0004*M     dw bufferId
041151 02          0005*M     db 2
041152             0006*M 
041152 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041155 10 01       0008*M     dw bufferId
041157             0009*M 
041157             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041157 17 00 A0    0011*M     db 23,0,0xA0
04115A 10 01       0012*M     dw bufferId
04115C 00          0013*M     db 0
04115D 31 00       0014*M 	dw width * height ; length of data in bytes
04115F 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 DF CB 
       D1 00 D2 D2 
       C7 C3 D7 D2 
       D1 D7 C3 DF 
       CB CB C3 D2 
       D2 D2 C7 CB 
       C7 C3 D1 00 
       D1 C3 C3 D2 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041190             0016*M 
041190             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041190 17 1B 21    0018*M     db 23,27,0x21
041193 07 00       0019*M     dw width ; in pixels
041195 07 00       0020*M     dw height ; in pixels
041197 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041198             0086*  	LOADBMPBUFFER2 BUF_LASER_A,5,13,"src/rgba2/laser_a.rgba2"
041198             0001*M 
041198             0002*M     ; Clear buffer
041198 17 00 A0    0003*M     db 23,0,0xA0
04119B 11 01       0004*M     dw bufferId
04119D 02          0005*M     db 2
04119E             0006*M 
04119E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411A1 11 01       0008*M     dw bufferId
0411A3             0009*M 
0411A3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411A3 17 00 A0    0011*M     db 23,0,0xA0
0411A6 11 01       0012*M     dw bufferId
0411A8 00          0013*M     db 0
0411A9 41 00       0014*M 	dw width * height ; length of data in bytes
0411AB 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 E5 
       FF E5 00 00 
       00 FF E5 00 
       00 00 FF E5 
       00 00 00 FA 
       00 00 00 00 
       E5 00 00 00 
       00 E5 00 00 
       00 00 00 00 
       00          
0411EC             0016*M 
0411EC             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0411EC 17 1B 21    0018*M     db 23,27,0x21
0411EF 05 00       0019*M     dw width ; in pixels
0411F1 0D 00       0020*M     dw height ; in pixels
0411F3 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0411F4             0087*  	LOADBMPBUFFER2 BUF_LASER_B,5,13,"src/rgba2/laser_b.rgba2"
0411F4             0001*M 
0411F4             0002*M     ; Clear buffer
0411F4 17 00 A0    0003*M     db 23,0,0xA0
0411F7 12 01       0004*M     dw bufferId
0411F9 02          0005*M     db 2
0411FA             0006*M 
0411FA 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411FD 12 01       0008*M     dw bufferId
0411FF             0009*M 
0411FF             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411FF 17 00 A0    0011*M     db 23,0,0xA0
041202 12 01       0012*M     dw bufferId
041204 00          0013*M     db 0
041205 41 00       0014*M 	dw width * height ; length of data in bytes
041207 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 FA 
       FF E5 00 00 
       E5 E5 00 00 
       00 00 E5 00 
       00 00 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E5 00 
       00          
041248             0016*M 
041248             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041248 17 1B 21    0018*M     db 23,27,0x21
04124B 05 00       0019*M     dw width ; in pixels
04124D 0D 00       0020*M     dw height ; in pixels
04124F 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041250             0088*  	LOADBMPBUFFER2 BUF_PAD,16,16,"src/rgba2/pad.rgba2"
041250             0001*M 
041250             0002*M     ; Clear buffer
041250 17 00 A0    0003*M     db 23,0,0xA0
041253 13 01       0004*M     dw bufferId
041255 02          0005*M     db 2
041256             0006*M 
041256 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041259 13 01       0008*M     dw bufferId
04125B             0009*M 
04125B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04125B 17 00 A0    0011*M     db 23,0,0xA0
04125E 13 01       0012*M     dw bufferId
041260 00          0013*M     db 0
041261 00 01       0014*M 	dw width * height ; length of data in bytes
041263 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
041363             0016*M 
041363             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041363 17 1B 21    0018*M     db 23,27,0x21
041366 10 00       0019*M     dw width ; in pixels
041368 10 00       0020*M     dw height ; in pixels
04136A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04136B             0089*  	LOADBMPBUFFER2 BUF_SEEKER_000,16,16,"src/rgba2/seeker_000.rgba2"
04136B             0001*M 
04136B             0002*M     ; Clear buffer
04136B 17 00 A0    0003*M     db 23,0,0xA0
04136E 14 01       0004*M     dw bufferId
041370 02          0005*M     db 2
041371             0006*M 
041371 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041374 14 01       0008*M     dw bufferId
041376             0009*M 
041376             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041376 17 00 A0    0011*M     db 23,0,0xA0
041379 14 01       0012*M     dw bufferId
04137B 00          0013*M     db 0
04137C 00 01       0014*M 	dw width * height ; length of data in bytes
04137E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA F5 
       E1 E5 00 00 
       00 00 00 00 
       00 FA 00 00 
       EA 00 FF FF 
       EE EA 00 EA 
       00 00 EA 00 
       F6 E2 E5 00 
       E1 F6 FB FF 
       EB E5 E2 E1 
       00 E5 E1 E2 
       F6 E1 F6 E2 
       E1 EB FB FA 
       F6 E6 D7 E1 
       F7 F6 E1 E1 
       F5 E1 E1 00 
       F6 EA FA F5 
       F5 E5 D5 F6 
       00 E1 E1 E1 
       00 E1 E1 E2 
       E1 F6 F8 FC 
       F8 F4 E1 E1 
       E2 E1 E1 00 
       00 E1 00 00 
       E1 E1 FC FE 
       FD F8 E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 FD FE 
       FD F9 D0 E1 
       00 00 E1 00 
       00 FA 00 00 
       E1 E1 F5 FD 
       F9 E1 D0 E1 
       00 00 EA 00 
       EF DB DB 00 
       E5 E1 E2 F5 
       F5 D1 D0 E5 
       00 DB DB DB 
       00 DF 00 00 
       00 E1 E2 F5 
       E1 D1 D0 00 
       00 00 DF 00 
       EF DB DB 00 
       00 E1 E2 00 
       00 D1 D0 00 
       00 DB DB DB 
       00 EB 00 00 
       00 E2 FB 00 
       00 E6 D1 00 
       00 00 D7 00 
       00 C3 00 00 
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
04147E             0016*M 
04147E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04147E 17 1B 21    0018*M     db 23,27,0x21
041481 10 00       0019*M     dw width ; in pixels
041483 10 00       0020*M     dw height ; in pixels
041485 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041486             0090*  	LOADBMPBUFFER2 BUF_SEEKER_001,16,16,"src/rgba2/seeker_001.rgba2"
041486             0001*M 
041486             0002*M     ; Clear buffer
041486 17 00 A0    0003*M     db 23,0,0xA0
041489 15 01       0004*M     dw bufferId
04148B 02          0005*M     db 2
04148C             0006*M 
04148C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04148F 15 01       0008*M     dw bufferId
041491             0009*M 
041491             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041491 17 00 A0    0011*M     db 23,0,0xA0
041494 15 01       0012*M     dw bufferId
041496 00          0013*M     db 0
041497 00 01       0014*M 	dw width * height ; length of data in bytes
041499 00 FA 00 00 0015*M     incbin file ; bitmap data
       00 00 FA 00 
       F5 F5 E0 00 
       00 00 00 00 
       00 00 FA 00 
       EA 00 00 FF 
       F5 E5 D0 00 
       00 00 00 00 
       00 E6 FA 00 
       00 EA 00 FA 
       F5 E0 E5 E5 
       00 00 00 00 
       00 F2 E1 E5 
       00 E6 F6 FF 
       FF EA E5 00 
       EA 00 00 00 
       00 E1 E1 E2 
       E1 E2 FB FB 
       FF EA E5 E2 
       EA 00 FF EA 
       F5 E4 E1 E1 
       F1 E6 EB FB 
       FA E6 E6 E2 
       E1 E9 E5 E6 
       00 E0 E1 E2 
       E1 F6 FA F9 
       F5 E5 D6 E2 
       F6 F6 E1 E1 
       D0 E0 00 E2 
       E1 E5 F8 FC 
       F8 F4 E5 E5 
       F2 E1 E1 E1 
       F5 E5 00 E0 
       E1 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E0 
       EB EB 00 E1 
       E0 E5 FD FE 
       FD E4 D1 E1 
       00 E0 E1 00 
       DF DB DB E5 
       E5 E1 F5 FD 
       E5 D0 D0 E0 
       00 E0 E0 00 
       DF DF 00 FF 
       E4 E2 F6 F5 
       E1 D0 E5 E1 
       00 F5 F5 00 
       DB DB D6 00 
       E0 E2 E1 E1 
       D1 D0 E5 F0 
       EB DB DB 00 
       E7 00 00 E1 
       E2 E7 00 D1 
       D1 D0 00 00 
       00 DF DB 00 
       C3 00 00 F2 
       F3 FF 00 E6 
       E6 C0 00 DB 
       DB DB EB 00 
       00 00 00 00 
       00 00 E6 00 
       E2 E2 00 00 
       D7 DB DB 00 
041599             0016*M 
041599             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041599 17 1B 21    0018*M     db 23,27,0x21
04159C 10 00       0019*M     dw width ; in pixels
04159E 10 00       0020*M     dw height ; in pixels
0415A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0415A1             0091*  	LOADBMPBUFFER2 BUF_SEEKER_002,16,16,"src/rgba2/seeker_002.rgba2"
0415A1             0001*M 
0415A1             0002*M     ; Clear buffer
0415A1 17 00 A0    0003*M     db 23,0,0xA0
0415A4 16 01       0004*M     dw bufferId
0415A6 02          0005*M     db 2
0415A7             0006*M 
0415A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0415AA 16 01       0008*M     dw bufferId
0415AC             0009*M 
0415AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415AC 17 00 A0    0011*M     db 23,0,0xA0
0415AF 16 01       0012*M     dw bufferId
0415B1 00          0013*M     db 0
0415B2 00 01       0014*M 	dw width * height ; length of data in bytes
0415B4 00 00 00 FE 0015*M     incbin file ; bitmap data
       00 FA 00 00 
       00 E1 F5 00 
       00 00 00 00 
       00 00 F6 FA 
       FF 00 FA 00 
       FF F1 F5 E0 
       00 00 00 00 
       00 00 E2 E1 
       E5 00 EA 00 
       FA F5 E0 E1 
       00 D0 00 00 
       00 F5 E1 E1 
       E6 E1 E2 F6 
       FF FA E5 E5 
       E5 00 00 00 
       00 E1 E0 E1 
       E2 E1 E7 FB 
       FF FF EA D5 
       00 EA E5 00 
       00 E0 E1 E2 
       E2 F6 EB FB 
       FA FA E5 E2 
       E6 EA 00 FA 
       00 E0 E0 F3 
       E1 E5 F9 F9 
       F5 E5 E6 E2 
       E1 F7 E5 EA 
       FA F5 00 E4 
       E1 E1 F8 FC 
       F8 F4 E5 E6 
       F6 F6 E5 E1 
       DB EB 00 E0 
       E0 E5 FD FE 
       FD F4 E1 E5 
       E2 E1 E1 E1 
       DF DB 00 E5 
       E1 E5 FE FE 
       FD E4 E1 E1 
       E2 E1 E0 E1 
       DB F1 00 E5 
       E1 E2 F9 F9 
       E5 D0 E1 E4 
       00 E0 E1 00 
       DB DB 00 E0 
       E2 F2 F5 E1 
       D1 D0 E0 00 
       00 E0 E0 00 
       00 00 E1 E1 
       E2 E1 E0 D1 
       D0 E5 E5 00 
       EA E5 00 00 
       00 00 F2 F7 
       FB 00 D2 D1 
       D0 00 F0 EB 
       DB DA 00 00 
       00 00 00 F2 
       00 00 E6 E5 
       D0 00 E7 DF 
       DF DB 00 00 
       00 00 00 00 
       00 00 00 E2 
       D1 00 EB DB 
       DB E7 00 00 
0416B4             0016*M 
0416B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0416B4 17 1B 21    0018*M     db 23,27,0x21
0416B7 10 00       0019*M     dw width ; in pixels
0416B9 10 00       0020*M     dw height ; in pixels
0416BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0416BC             0092*  	LOADBMPBUFFER2 BUF_SEEKER_003,16,16,"src/rgba2/seeker_003.rgba2"
0416BC             0001*M 
0416BC             0002*M     ; Clear buffer
0416BC 17 00 A0    0003*M     db 23,0,0xA0
0416BF 17 01       0004*M     dw bufferId
0416C1 02          0005*M     db 2
0416C2             0006*M 
0416C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0416C5 17 01       0008*M     dw bufferId
0416C7             0009*M 
0416C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0416C7 17 00 A0    0011*M     db 23,0,0xA0
0416CA 17 01       0012*M     dw bufferId
0416CC 00          0013*M     db 0
0416CD 00 01       0014*M 	dw width * height ; length of data in bytes
0416CF 00 00 00 F7 0015*M     incbin file ; bitmap data
       FA FF 00 F5 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 F6 
       E2 E5 00 EA 
       00 FF 00 F5 
       F5 00 00 00 
       00 00 F5 E1 
       E1 E5 00 FA 
       00 FA F5 F5 
       E0 00 00 00 
       00 00 E0 E1 
       E1 E2 E1 E2 
       F6 FF F5 E0 
       E5 00 00 00 
       00 E0 E1 E1 
       E2 F1 E6 EB 
       FB FF FF EA 
       E5 00 00 00 
       00 E1 E0 00 
       E2 E1 E6 FB 
       FB FA EA E5 
       00 FE 00 F5 
       EB FA 00 00 
       E1 E1 F9 F9 
       F5 F5 E6 E2 
       E2 EA 00 00 
       CB DB 00 E0 
       E1 E1 FC FC 
       F8 E5 E6 D6 
       E1 D1 C4 EA 
       DF E7 F0 E5 
       E0 F9 FE FE 
       F8 F4 E5 F6 
       F6 F6 F5 E5 
       DB D6 FF E5 
       E1 F5 FD FD 
       FD E4 E1 E1 
       E1 E1 E1 E1 
       C6 00 E0 E1 
       E2 F6 F9 E5 
       E4 D0 E1 E2 
       E1 E1 E0 E1 
       00 E2 E1 E2 
       E2 F5 E1 D1 
       D0 E0 E1 00 
       E0 E1 E0 00 
       00 F3 F7 FB 
       00 E0 D1 D1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 00 00 FF 
       00 E6 D1 D0 
       E5 F0 DB EA 
       E5 00 00 00 
       00 00 00 F7 
       00 E6 D1 D0 
       00 00 DB DA 
       DB 00 00 00 
       00 00 00 00 
       00 F3 E2 00 
       DB DB DF DF 
       EB 00 00 00 
0417CF             0016*M 
0417CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0417CF 17 1B 21    0018*M     db 23,27,0x21
0417D2 10 00       0019*M     dw width ; in pixels
0417D4 10 00       0020*M     dw height ; in pixels
0417D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0417D7             0093*  	LOADBMPBUFFER2 BUF_SEEKER_004,16,16,"src/rgba2/seeker_004.rgba2"
0417D7             0001*M 
0417D7             0002*M     ; Clear buffer
0417D7 17 00 A0    0003*M     db 23,0,0xA0
0417DA 18 01       0004*M     dw bufferId
0417DC 02          0005*M     db 2
0417DD             0006*M 
0417DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0417E0 18 01       0008*M     dw bufferId
0417E2             0009*M 
0417E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0417E2 17 00 A0    0011*M     db 23,0,0xA0
0417E5 18 01       0012*M     dw bufferId
0417E7 00          0013*M     db 0
0417E8 00 01       0014*M 	dw width * height ; length of data in bytes
0417EA 00 00 00 00 0015*M     incbin file ; bitmap data
       F6 E2 FA 00 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 E1 E5 00 
       EA 00 00 00 
       F5 00 00 00 
       00 00 00 E0 
       E1 F1 E6 D0 
       EA 00 FA F6 
       F5 F5 00 00 
       00 00 E0 E1 
       E1 E1 E2 E1 
       E2 FB FF F5 
       F1 E0 E0 00 
       EF F5 E0 E0 
       E2 E2 F6 EA 
       FB FB FF EA 
       E0 E5 00 00 
       DB EB F0 00 
       D4 E1 F6 FA 
       FB FB FF EE 
       EA E5 00 00 
       DF DB 00 E1 
       E1 E1 F5 F8 
       F5 F5 EA E5 
       D1 00 00 00 
       DB 00 F0 E5 
       E0 E5 FC FD 
       F8 E5 E6 E7 
       E2 EA EA EA 
       EB 00 E5 E5 
       E1 F9 FE FE 
       F8 F4 E5 E2 
       E1 D0 00 00 
       00 00 E0 E1 
       E2 F9 FD FD 
       F8 E4 E1 F6 
       F6 F6 E5 EA 
       00 E1 F2 E2 
       F5 F5 E5 E5 
       D4 E1 E1 E2 
       E1 E1 E1 E1 
       F3 F7 FB E3 
       E4 E1 D1 D0 
       D0 E1 E4 E2 
       E1 E1 E1 E1 
       00 00 FF 00 
       D2 D1 D1 D5 
       E5 E1 00 E1 
       E1 E0 E0 00 
       00 00 E6 EA 
       E6 D1 D0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 00 00 
       E2 C0 00 00 
       00 DB EA F5 
       00 00 00 00 
       00 00 00 00 
       F3 00 00 EB 
       DB DF DB DB 
       00 00 00 00 
0418EA             0016*M 
0418EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0418EA 17 1B 21    0018*M     db 23,27,0x21
0418ED 10 00       0019*M     dw width ; in pixels
0418EF 10 00       0020*M     dw height ; in pixels
0418F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0418F2             0094*  	LOADBMPBUFFER2 BUF_SEEKER_005,16,16,"src/rgba2/seeker_005.rgba2"
0418F2             0001*M 
0418F2             0002*M     ; Clear buffer
0418F2 17 00 A0    0003*M     db 23,0,0xA0
0418F5 19 01       0004*M     dw bufferId
0418F7 02          0005*M     db 2
0418F8             0006*M 
0418F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0418FB 19 01       0008*M     dw bufferId
0418FD             0009*M 
0418FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418FD 17 00 A0    0011*M     db 23,0,0xA0
041900 19 01       0012*M     dw bufferId
041902 00          0013*M     db 0
041903 00 01       0014*M 	dw width * height ; length of data in bytes
041905 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 E2 E6 
       FA 00 F5 00 
       00 00 00 00 
       00 00 00 00 
       E1 E1 E1 F6 
       C8 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E1 E2 
       D1 EA EA 00 
       00 00 00 00 
       FF EF F5 E0 
       E1 E2 E2 E1 
       E1 E2 00 FA 
       F5 F5 F5 00 
       DF DA EA 00 
       00 E2 E1 F6 
       EB FB FB FF 
       E0 F5 E0 00 
       DF DB DB 00 
       E1 E1 E1 FA 
       FB FB FF FF 
       E5 E1 00 00 
       DB 00 F0 E5 
       E0 E1 F4 F8 
       F9 F6 FA EA 
       EA E5 E6 E5 
       DB 00 E5 E5 
       E1 E9 FD FD 
       F8 F5 E5 E5 
       E1 00 00 00 
       00 E0 E0 E1 
       E2 F9 FE FE 
       F8 F4 E6 D7 
       E2 FA EA F5 
       F2 E2 E2 E2 
       F6 F9 FD FD 
       F8 E0 E5 E2 
       E1 00 00 00 
       F3 FB F7 E4 
       F5 E1 E1 E4 
       E4 E1 E1 F6 
       F7 E6 E5 EA 
       00 00 00 00 
       D1 D1 D0 D0 
       E0 E1 E2 E1 
       E1 E1 E1 E6 
       00 E6 EA E6 
       D1 D0 D5 E5 
       E0 00 00 E0 
       E1 E1 E1 E2 
       00 00 00 E6 
       D0 D0 FF F0 
       00 00 E0 E1 
       E0 E1 00 00 
       00 00 00 F2 
       D1 00 D6 E7 
       DB E6 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 DB DB DF 
       CB EA 00 00 
       00 00 00 00 
041A05             0016*M 
041A05             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041A05 17 1B 21    0018*M     db 23,27,0x21
041A08 10 00       0019*M     dw width ; in pixels
041A0A 10 00       0020*M     dw height ; in pixels
041A0C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041A0D             0095*  	LOADBMPBUFFER2 BUF_SEEKER_006,16,16,"src/rgba2/seeker_006.rgba2"
041A0D             0001*M 
041A0D             0002*M     ; Clear buffer
041A0D 17 00 A0    0003*M     db 23,0,0xA0
041A10 1A 01       0004*M     dw bufferId
041A12 02          0005*M     db 2
041A13             0006*M 
041A13 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041A16 1A 01       0008*M     dw bufferId
041A18             0009*M 
041A18             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041A18 17 00 A0    0011*M     db 23,0,0xA0
041A1B 1A 01       0012*M     dw bufferId
041A1D 00          0013*M     db 0
041A1E 00 01       0014*M 	dw width * height ; length of data in bytes
041A20 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 F5 E1 
       E2 FA FF 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       FF EF EB F5 
       E0 E1 E1 E1 
       E2 D1 EA EA 
       00 F5 00 00 
       DF DF DB FA 
       00 00 E2 F2 
       E1 E1 E6 00 
       FA 00 00 00 
       DB DF EB 00 
       00 D4 E1 E1 
       F6 E7 F6 FF 
       FA F5 F5 00 
       DB E7 F0 E5 
       E0 E1 E1 F6 
       FA FB FB FF 
       FA E0 F5 E0 
       00 00 00 E5 
       E1 E5 F8 F8 
       F9 FA FA FF 
       EA E0 E0 D0 
       E2 E1 E0 E1 
       E1 F9 FE FD 
       FC F5 F6 EA 
       EA E5 FA 00 
       F3 F7 E2 E2 
       F6 FD FE FE 
       F8 F4 E6 E6 
       E1 00 00 00 
       00 FF E3 E5 
       F5 F5 F9 FD 
       F4 E4 D6 E2 
       E2 EA EA 00 
       00 00 00 D0 
       E1 D1 E0 D4 
       E1 E1 F6 E1 
       E1 00 00 EA 
       00 00 E6 D1 
       D1 D0 D0 D0 
       E1 E1 E2 FB 
       F6 E5 FE 00 
       00 F3 E6 D0 
       D0 E5 E5 E0 
       E0 F3 E1 E1 
       E1 E1 EA FA 
       00 00 E2 D0 
       00 00 00 00 
       00 E1 E0 E0 
       E1 E1 E2 00 
       00 00 00 00 
       DB F1 DB DA 
       E5 E0 E1 E0 
       E1 00 00 00 
       00 00 00 00 
       DB DB DF DA 
       FA 00 00 00 
       00 00 00 00 
041B20             0016*M 
041B20             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041B20 17 1B 21    0018*M     db 23,27,0x21
041B23 10 00       0019*M     dw width ; in pixels
041B25 10 00       0020*M     dw height ; in pixels
041B27 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041B28             0096*  	LOADBMPBUFFER2 BUF_SEEKER_007,16,16,"src/rgba2/seeker_007.rgba2"
041B28             0001*M 
041B28             0002*M     ; Clear buffer
041B28 17 00 A0    0003*M     db 23,0,0xA0
041B2B 1B 01       0004*M     dw bufferId
041B2D 02          0005*M     db 2
041B2E             0006*M 
041B2E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041B31 1B 01       0008*M     dw bufferId
041B33             0009*M 
041B33             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041B33 17 00 A0    0011*M     db 23,0,0xA0
041B36 1B 01       0012*M     dw bufferId
041B38 00          0013*M     db 0
041B39 00 01       0014*M 	dw width * height ; length of data in bytes
041B3B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 E5 
       F5 E2 E6 FE 
       00 00 00 00 
       EF EF EF EF 
       F5 E0 E0 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       EB DB DF DB 
       FA E0 E1 E1 
       E1 E2 E9 00 
       00 00 00 00 
       EB DB 00 EB 
       00 00 00 E2 
       F6 E1 E1 EA 
       EA 00 00 00 
       00 DB 00 F0 
       E1 E0 E5 E1 
       F6 E6 E6 E2 
       00 FA 00 00 
       00 00 00 E5 
       E5 E0 E1 E5 
       FA EB FB FA 
       FA FA E0 F5 
       F2 E1 E0 E1 
       E1 E5 FD F8 
       F8 FA FB FF 
       FA E0 F5 F5 
       F7 FB E2 E2 
       F2 F9 FE FE 
       FC F5 FA FF 
       EE E1 E0 E0 
       00 FB E2 E5 
       F5 FD FD FD 
       F8 E5 E5 EA 
       EA E5 FF 00 
       E6 00 00 E1 
       E1 E5 F9 F8 
       F4 E5 D6 E2 
       E2 00 00 E5 
       00 EA D5 D1 
       D1 D0 D0 E4 
       E1 E5 E2 E1 
       E6 EA 00 00 
       00 E2 D1 D0 
       D0 E5 E0 E1 
       E1 E1 F6 E6 
       00 00 E6 00 
       00 F2 D0 00 
       FF E5 E1 E0 
       E2 E2 E1 F6 
       E5 00 00 00 
       00 00 00 D6 
       00 DB 00 00 
       00 E0 E1 E1 
       E1 FA EA 00 
       00 00 00 DB 
       DF DB EA E5 
       E0 E1 E0 E1 
       E1 E2 00 EA 
       00 C3 D7 DB 
       DF DB EA F4 
       E0 00 E0 00 
       00 00 00 00 
041C3B             0016*M 
041C3B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041C3B 17 1B 21    0018*M     db 23,27,0x21
041C3E 10 00       0019*M     dw width ; in pixels
041C40 10 00       0020*M     dw height ; in pixels
041C42 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041C43             0097*  	LOADBMPBUFFER2 BUF_SEEKER_008,16,16,"src/rgba2/seeker_008.rgba2"
041C43             0001*M 
041C43             0002*M     ; Clear buffer
041C43 17 00 A0    0003*M     db 23,0,0xA0
041C46 1C 01       0004*M     dw bufferId
041C48 02          0005*M     db 2
041C49             0006*M 
041C49 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041C4C 1C 01       0008*M     dw bufferId
041C4E             0009*M 
041C4E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041C4E 17 00 A0    0011*M     db 23,0,0xA0
041C51 1C 01       0012*M     dw bufferId
041C53 00          0013*M     db 0
041C54 00 01       0014*M 	dw width * height ; length of data in bytes
041C56 00 00 EF 00 0015*M     incbin file ; bitmap data
       EF 00 00 00 
       00 F5 F6 F6 
       00 00 00 00 
       C3 EB DB DF 
       DB FA E1 E1 
       E1 E1 E1 E2 
       FA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 E2 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       F3 E2 E1 E1 
       E1 E1 E1 E1 
       F6 EA EB F6 
       00 00 00 00 
       00 FB E2 E2 
       E2 F5 FD FC 
       F8 FA FB FB 
       FF FA 00 00 
       00 00 00 F5 
       F5 FD FE FE 
       FC F5 FA FF 
       FF F5 F5 F5 
       00 00 00 E1 
       F5 F9 FD FD 
       F8 F5 F6 EB 
       EE E1 E1 E1 
       00 E6 D1 D1 
       D1 E1 F9 F8 
       F4 E5 E6 E5 
       EA E5 00 00 
       F3 D1 D0 D0 
       D0 D0 D0 E1 
       E1 D5 D7 E2 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 F7 00 
       00 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       C3 D7 DB DF 
       DB EA E1 E1 
       E1 E1 E1 E1 
       EA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       00 E1 E1 E2 
       00 00 00 00 
041D56             0016*M 
041D56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041D56 17 1B 21    0018*M     db 23,27,0x21
041D59 10 00       0019*M     dw width ; in pixels
041D5B 10 00       0020*M     dw height ; in pixels
041D5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041D5E             0098*  	LOADBMPBUFFER2 BUF_SEEKER_009,16,16,"src/rgba2/seeker_009.rgba2"
041D5E             0001*M 
041D5E             0002*M     ; Clear buffer
041D5E 17 00 A0    0003*M     db 23,0,0xA0
041D61 1D 01       0004*M     dw bufferId
041D63 02          0005*M     db 2
041D64             0006*M 
041D64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041D67 1D 01       0008*M     dw bufferId
041D69             0009*M 
041D69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D69 17 00 A0    0011*M     db 23,0,0xA0
041D6C 1D 01       0012*M     dw bufferId
041D6E 00          0013*M     db 0
041D6F 00 01       0014*M 	dw width * height ; length of data in bytes
041D71 00 C3 E7 DB 0015*M     incbin file ; bitmap data
       DF DF EB F5 
       D0 00 F5 00 
       00 00 00 00 
       00 00 00 DB 
       DF DB EB E5 
       E0 E0 E4 E1 
       F2 E6 00 FA 
       00 00 00 D6 
       00 DB 00 00 
       00 E1 E1 E1 
       E1 FA FA 00 
       00 F2 E1 00 
       FF E5 E1 E0 
       E2 E2 E1 E2 
       E5 00 00 00 
       00 F3 E2 E0 
       E4 E5 E0 E1 
       E1 E1 F1 E1 
       00 00 EA 00 
       00 FF E7 E2 
       E2 E1 E5 E1 
       E5 F6 E6 E2 
       E6 EA 00 00 
       E6 00 00 E1 
       F6 F5 FD FD 
       F8 FA EB FB 
       F6 00 00 FA 
       00 E6 D1 E1 
       F5 FD FE FE 
       FC F9 FB FB 
       FF FA FF 00 
       E2 E6 D1 D1 
       E1 E5 FD FD 
       F8 F5 FA FF 
       FF F5 F5 F5 
       E2 C0 D0 D0 
       D0 D0 E4 F4 
       F4 E5 E6 EA 
       EA E0 E5 F5 
       00 00 00 E5 
       E5 D0 D1 E1 
       E5 D6 E6 E5 
       E5 E5 D0 E0 
       00 DB 00 F0 
       E1 E0 E1 E1 
       E5 E2 E2 E2 
       00 E5 00 00 
       D7 DB 00 EB 
       00 00 00 E2 
       F2 F6 E1 EA 
       EA 00 00 00 
       DB DB DF DB 
       F5 E0 E0 E1 
       E1 F6 E9 00 
       00 00 00 00 
       DB EB DB DB 
       F5 E0 E1 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E6 EA 
       00 00 00 00 
041E71             0016*M 
041E71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041E71 17 1B 21    0018*M     db 23,27,0x21
041E74 10 00       0019*M     dw width ; in pixels
041E76 10 00       0020*M     dw height ; in pixels
041E78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041E79             0099*  	LOADBMPBUFFER2 BUF_SEEKER_010,16,16,"src/rgba2/seeker_010.rgba2"
041E79             0001*M 
041E79             0002*M     ; Clear buffer
041E79 17 00 A0    0003*M     db 23,0,0xA0
041E7C 1E 01       0004*M     dw bufferId
041E7E 02          0005*M     db 2
041E7F             0006*M 
041E7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041E82 1E 01       0008*M     dw bufferId
041E84             0009*M 
041E84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E84 17 00 A0    0011*M     db 23,0,0xA0
041E87 1E 01       0012*M     dw bufferId
041E89 00          0013*M     db 0
041E8A 00 01       0014*M 	dw width * height ; length of data in bytes
041E8C 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB F1 DB EB 
       F5 E0 E0 E1 
       F5 00 00 00 
       00 00 F2 E1 
       00 00 00 00 
       00 E0 E1 E0 
       E1 E2 F6 00 
       00 F2 F7 E1 
       E0 E5 E5 E0 
       E4 F3 E2 E1 
       E1 E1 FA FE 
       00 00 FB E2 
       E2 E1 E1 E0 
       E1 E1 E2 E2 
       E6 E5 FF 00 
       00 00 00 E1 
       F2 E2 E5 E5 
       E1 E5 F6 E1 
       E1 00 00 FA 
       00 E6 D2 E0 
       F5 F9 FE FD 
       F8 F9 EB E7 
       E2 EA FA 00 
       E2 E5 D1 D1 
       E1 F9 FE FE 
       FC F9 FB FB 
       F6 00 00 00 
       D1 D0 D0 D0 
       D1 E5 FD FD 
       F8 F5 FA FF 
       FF FA FF 00 
       00 00 00 E5 
       D0 D0 E4 F4 
       F4 E5 FA FF 
       FA F5 F1 E1 
       EB E7 F0 E5 
       E0 E1 E1 E1 
       E5 E6 E5 EA 
       E5 E0 F5 F5 
       DB DF EB 00 
       00 E4 E1 E5 
       E6 E2 E2 D5 
       E5 E1 E0 00 
       DB DF DB EA 
       00 00 E2 E2 
       F6 E1 E6 00 
       E5 00 00 00 
       E7 DB DA E5 
       E0 E0 E1 E1 
       F6 F7 EA EA 
       00 D0 00 00 
       00 00 00 00 
       E0 E1 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 E1 E1 
       E1 EA FA 00 
       00 00 00 00 
041F8C             0016*M 
041F8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041F8C 17 1B 21    0018*M     db 23,27,0x21
041F8F 10 00       0019*M     dw width ; in pixels
041F91 10 00       0020*M     dw height ; in pixels
041F93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041F94             0100*  	LOADBMPBUFFER2 BUF_SEEKER_011,16,16,"src/rgba2/seeker_011.rgba2"
041F94             0001*M 
041F94             0002*M     ; Clear buffer
041F94 17 00 A0    0003*M     db 23,0,0xA0
041F97 1F 01       0004*M     dw bufferId
041F99 02          0005*M     db 2
041F9A             0006*M 
041F9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041F9D 1F 01       0008*M     dw bufferId
041F9F             0009*M 
041F9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F9F 17 00 A0    0011*M     db 23,0,0xA0
041FA2 1F 01       0012*M     dw bufferId
041FA4 00          0013*M     db 0
041FA5 00 01       0014*M 	dw width * height ; length of data in bytes
041FA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 C6 DB DF 
       CB EB 00 00 
       00 00 00 00 
       00 00 00 F3 
       E2 00 D6 E7 
       DB FA E1 E0 
       00 00 00 00 
       00 00 00 F7 
       E1 E0 FF F0 
       00 00 E0 E1 
       E0 F5 00 00 
       00 F7 FF FB 
       E2 E1 E5 E5 
       E0 00 00 E1 
       E1 E1 F6 F7 
       00 00 00 00 
       E2 E2 E1 E0 
       E1 E1 E2 E2 
       E1 E1 E2 FA 
       F3 E6 E6 E0 
       F5 F6 F5 F9 
       E1 E1 E1 F1 
       E2 E5 E5 FF 
       E2 D1 D1 D1 
       E1 F9 FD FE 
       FC F9 E6 E6 
       E1 00 00 00 
       00 D0 D0 D1 
       D1 E5 FD FE 
       FC F9 FB EB 
       E2 FA EA F5 
       DB 00 E5 E5 
       D0 E4 FD F8 
       F8 F5 FB FB 
       F6 00 00 00 
       DB 00 F0 E5 
       E0 D0 E4 F4 
       E5 F5 FA FF 
       FF FA FF FA 
       DF DB DB 00 
       E1 E1 E1 E5 
       E6 E6 EA FF 
       F5 F5 00 00 
       DF DA EA 00 
       00 E2 E1 F6 
       D6 E2 E5 EA 
       E0 F5 F5 00 
       EB DB E5 E0 
       E0 E1 E1 F6 
       E1 E2 00 E5 
       E5 E0 F5 00 
       00 00 00 E0 
       E1 E1 E1 F6 
       D1 EA FE 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E1 F5 
       C4 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E5 
       EA 00 F5 00 
       00 00 00 00 
0420A7             0016*M 
0420A7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0420A7 17 1B 21    0018*M     db 23,27,0x21
0420AA 10 00       0019*M     dw width ; in pixels
0420AC 10 00       0020*M     dw height ; in pixels
0420AE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0420AF             0101*  	LOADBMPBUFFER2 BUF_SEEKER_012,16,16,"src/rgba2/seeker_012.rgba2"
0420AF             0001*M 
0420AF             0002*M     ; Clear buffer
0420AF 17 00 A0    0003*M     db 23,0,0xA0
0420B2 20 01       0004*M     dw bufferId
0420B4 02          0005*M     db 2
0420B5             0006*M 
0420B5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0420B8 20 01       0008*M     dw bufferId
0420BA             0009*M 
0420BA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420BA 17 00 A0    0011*M     db 23,0,0xA0
0420BD 20 01       0012*M     dw bufferId
0420BF 00          0013*M     db 0
0420C0 00 01       0014*M 	dw width * height ; length of data in bytes
0420C2 00 00 00 00 0015*M     incbin file ; bitmap data
       F3 00 00 EB 
       DB DF DB EF 
       00 00 00 00 
       00 00 00 00 
       F7 E1 00 00 
       00 DB EB F5 
       00 00 00 00 
       00 00 E6 FF 
       FB F2 E0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 EA 00 
       E3 E2 E1 E5 
       E5 E1 00 E0 
       E1 E0 F5 00 
       F3 E2 E6 D2 
       E4 F5 E2 E1 
       E0 E1 D4 E2 
       E1 E1 E1 F6 
       00 C0 D1 D1 
       E1 F5 F9 F9 
       E5 E1 E1 E2 
       E1 F1 E1 E2 
       00 00 D0 D1 
       D1 E5 FD FE 
       FC F5 F6 F6 
       E2 E6 E5 FA 
       EB 00 E5 D5 
       D0 E5 FD FE 
       FD F8 FA EA 
       E1 D0 00 00 
       DB 00 F0 E5 
       D0 D4 F8 F8 
       F8 F5 FB FB 
       E2 EA EA FA 
       DF DB 00 E1 
       E1 E1 E4 F4 
       E5 F5 FB FB 
       FB 00 00 00 
       DB EA F0 00 
       E4 E1 E1 E5 
       E6 EA FF FF 
       FF FA 00 00 
       DB F5 E0 E1 
       E2 E2 F6 E2 
       E7 E5 EE EA 
       F5 F6 00 00 
       00 00 E0 E1 
       E1 E1 F6 E1 
       E2 D1 EA E0 
       F1 F5 F5 00 
       00 00 00 E0 
       E1 E1 F6 D0 
       EA 00 E5 E5 
       E0 F5 00 00 
       00 00 00 E0 
       E1 E1 E5 00 
       EA 00 00 00 
       E0 00 00 00 
       00 00 00 00 
       E1 E1 EA 00 
       EA 00 00 00 
       00 00 00 00 
0421C2             0016*M 
0421C2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0421C2 17 1B 21    0018*M     db 23,27,0x21
0421C5 10 00       0019*M     dw width ; in pixels
0421C7 10 00       0020*M     dw height ; in pixels
0421C9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0421CA             0102*  	LOADBMPBUFFER2 BUF_SEEKER_013,16,16,"src/rgba2/seeker_013.rgba2"
0421CA             0001*M 
0421CA             0002*M     ; Clear buffer
0421CA 17 00 A0    0003*M     db 23,0,0xA0
0421CD 21 01       0004*M     dw bufferId
0421CF 02          0005*M     db 2
0421D0             0006*M 
0421D0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0421D3 21 01       0008*M     dw bufferId
0421D5             0009*M 
0421D5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0421D5 17 00 A0    0011*M     db 23,0,0xA0
0421D8 21 01       0012*M     dw bufferId
0421DA 00          0013*M     db 0
0421DB 00 01       0014*M 	dw width * height ; length of data in bytes
0421DD 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F3 F2 00 
       DB DB DF DF 
       FF 00 00 00 
       00 00 00 E6 
       00 FB E2 E0 
       00 00 DB DA 
       EF 00 00 00 
       00 00 00 EA 
       00 F7 E2 E0 
       E5 F0 DB EA 
       F5 00 00 00 
       00 F2 E6 E6 
       00 E4 E2 E1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 D1 D0 D1 
       D1 F5 F6 E2 
       E1 E0 E1 00 
       E1 E1 E1 00 
       DB 00 D0 D0 
       D1 E1 F9 F9 
       E9 E1 E1 E2 
       E2 E1 E1 F5 
       DB D6 FF D5 
       D0 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E2 
       DF E7 F0 E5 
       D0 E4 FD FE 
       FD F8 FA F6 
       E1 E2 F6 E6 
       CB DB 00 E0 
       E0 E4 F8 F8 
       F8 F9 FB EB 
       E1 D1 C8 FA 
       EA E6 00 00 
       E1 E1 E0 F4 
       F5 F6 FB FB 
       E2 EA 00 00 
       00 E1 E0 00 
       E2 E1 E5 E6 
       E5 FA FF FB 
       00 EA 00 F5 
       00 E0 E1 E0 
       E1 F6 E2 D7 
       E5 EA FF FF 
       FA 00 00 00 
       00 00 E0 E1 
       E1 F7 E1 E2 
       E1 EA E5 E0 
       F5 00 00 00 
       00 00 E1 E1 
       E1 E6 00 FA 
       00 E5 E1 F5 
       F5 00 00 00 
       00 00 00 E1 
       E1 E5 00 EA 
       00 E6 00 E0 
       F5 00 00 00 
       00 00 00 E2 
       E6 EA 00 F5 
       00 E5 00 00 
       00 00 00 00 
0422DD             0016*M 
0422DD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0422DD 17 1B 21    0018*M     db 23,27,0x21
0422E0 10 00       0019*M     dw width ; in pixels
0422E2 10 00       0020*M     dw height ; in pixels
0422E4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0422E5             0103*  	LOADBMPBUFFER2 BUF_SEEKER_014,16,16,"src/rgba2/seeker_014.rgba2"
0422E5             0001*M 
0422E5             0002*M     ; Clear buffer
0422E5 17 00 A0    0003*M     db 23,0,0xA0
0422E8 22 01       0004*M     dw bufferId
0422EA 02          0005*M     db 2
0422EB             0006*M 
0422EB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0422EE 22 01       0008*M     dw bufferId
0422F0             0009*M 
0422F0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0422F0 17 00 A0    0011*M     db 23,0,0xA0
0422F3 22 01       0012*M     dw bufferId
0422F5 00          0013*M     db 0
0422F6 00 01       0014*M 	dw width * height ; length of data in bytes
0422F8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F3 
       E2 00 DB DB 
       DF FF 00 00 
       00 00 00 F3 
       00 00 FF F7 
       E1 00 E7 DF 
       DF EF 00 00 
       00 00 E2 E6 
       E6 00 E3 E2 
       E0 00 F0 EB 
       DB EB 00 00 
       00 00 D0 D0 
       D1 D0 E5 E2 
       E1 E5 E5 00 
       FA F5 00 00 
       DB DB 00 D0 
       D1 E1 F5 F6 
       E1 E1 E0 00 
       00 E0 E0 00 
       DB F1 00 E5 
       D0 D1 F5 FD 
       F9 E5 E1 D4 
       00 E1 E0 00 
       DF DB 00 E5 
       D0 E0 F9 FE 
       FE F8 E1 E1 
       E2 E1 E0 F5 
       DA DA 00 E0 
       D0 D4 FD FE 
       FD F8 F6 E1 
       F2 E1 E1 E1 
       FA E5 00 E0 
       E1 E1 F4 F8 
       FC F9 FA F6 
       E1 E2 E5 E2 
       00 E0 E1 F3 
       E1 E1 E4 F4 
       F5 FA FB E7 
       E1 D1 E5 FA 
       00 E1 E0 E1 
       E2 F6 D6 E6 
       F6 FA FB F6 
       E6 EA 00 FF 
       00 E0 E0 E1 
       FB E1 E2 E6 
       EA FF FF FF 
       00 EA E5 00 
       00 E1 E1 E1 
       F6 E1 E2 E1 
       EA EA FA FA 
       FA 00 00 00 
       00 00 E1 E1 
       E5 00 EA 00 
       E5 E0 E0 F5 
       00 F5 00 00 
       00 00 E2 EA 
       FE 00 EA 00 
       FA E0 F5 F5 
       00 00 00 00 
       00 00 00 FA 
       00 EA 00 00 
       00 D0 E0 00 
       00 00 00 00 
0423F8             0016*M 
0423F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0423F8 17 1B 21    0018*M     db 23,27,0x21
0423FB 10 00       0019*M     dw width ; in pixels
0423FD 10 00       0020*M     dw height ; in pixels
0423FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042400             0104*  	LOADBMPBUFFER2 BUF_SEEKER_015,16,16,"src/rgba2/seeker_015.rgba2"
042400             0001*M 
042400             0002*M     ; Clear buffer
042400 17 00 A0    0003*M     db 23,0,0xA0
042403 23 01       0004*M     dw bufferId
042405 02          0005*M     db 2
042406             0006*M 
042406 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042409 23 01       0008*M     dw bufferId
04240B             0009*M 
04240B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04240B 17 00 A0    0011*M     db 23,0,0xA0
04240E 23 01       0012*M     dw bufferId
042410 00          0013*M     db 0
042411 00 01       0014*M 	dw width * height ; length of data in bytes
042413 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E6 00 
       F7 F2 00 00 
       EB EB EF 00 
       C3 00 00 F2 
       E2 EA 00 FB 
       FB E1 00 DB 
       DB DB EF 00 
       D7 00 00 D0 
       D1 D5 00 E2 
       E2 E0 00 00 
       00 DF EF 00 
       DB DB D6 00 
       D0 D1 E1 E5 
       E2 E1 E5 F0 
       EB DB EF 00 
       DF DF 00 FF 
       D0 D1 E1 F5 
       F2 E1 E5 E1 
       00 FA F5 00 
       DB DB DB E5 
       E5 D0 E5 FD 
       F9 E5 E0 E0 
       00 E0 E0 00 
       EA EA 00 E1 
       E0 D0 F9 FD 
       FE FD E1 E5 
       00 E1 E0 00 
       F4 E5 00 E0 
       E1 E4 F8 FD 
       FE F8 E5 E1 
       E2 E1 E1 E5 
       E0 E0 00 E2 
       E1 E1 F4 F8 
       FC F8 FA F6 
       F6 E1 E1 F5 
       00 E1 E0 E2 
       E1 E5 E5 E5 
       F5 FA EB E6 
       E1 E2 E1 E2 
       E0 E0 E1 E1 
       F6 E2 D6 E5 
       FA FB FB E6 
       E1 E9 E5 E6 
       00 E1 E1 F6 
       E6 E1 E2 EA 
       FF FF FA E2 
       EA 00 FF FE 
       00 E1 E1 E5 
       00 E6 E2 EA 
       EE FA FA 00 
       EA 00 00 00 
       00 E2 FA 00 
       00 EA 00 E5 
       E1 E0 FA FA 
       00 00 00 00 
       00 00 EA 00 
       E6 00 00 FF 
       E0 F5 E0 00 
       00 00 00 00 
       00 EA 00 00 
       00 00 E5 00 
       E0 F5 F5 00 
       00 00 00 00 
042513             0016*M 
042513             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042513 17 1B 21    0018*M     db 23,27,0x21
042516 10 00       0019*M     dw width ; in pixels
042518 10 00       0020*M     dw height ; in pixels
04251A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04251B             0105*  	LOADBMPBUFFER2 BUF_SEEKER_016,16,16,"src/rgba2/seeker_016.rgba2"
04251B             0001*M 
04251B             0002*M     ; Clear buffer
04251B 17 00 A0    0003*M     db 23,0,0xA0
04251E 24 01       0004*M     dw bufferId
042520 02          0005*M     db 2
042521             0006*M 
042521 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042524 24 01       0008*M     dw bufferId
042526             0009*M 
042526             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042526 17 00 A0    0011*M     db 23,0,0xA0
042529 24 01       0012*M     dw bufferId
04252B 00          0013*M     db 0
04252C 00 01       0014*M 	dw width * height ; length of data in bytes
04252E 00 C3 00 00 0015*M     incbin file ; bitmap data
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
       00 D7 00 00 
       00 D1 E6 00 
       00 FB E2 00 
       00 00 EB 00 
       DB DB DB 00 
       00 D0 D1 00 
       00 E2 E1 00 
       00 DB DB EF 
       00 DF 00 00 
       00 D0 D1 E1 
       F5 E2 E1 00 
       00 00 DF 00 
       DB DB DB 00 
       E5 D0 D1 F5 
       F5 E2 E1 E5 
       00 DB DB EF 
       00 EA 00 00 
       E1 D0 E1 F9 
       FD F5 E1 E1 
       00 00 FA 00 
       00 E1 00 00 
       E1 D0 F9 FD 
       FE FD E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 F8 FD 
       FE FC E1 E1 
       00 00 E1 00 
       00 E1 E1 E2 
       E1 E1 F4 F8 
       FC F8 F6 E1 
       E2 E1 E1 00 
       E1 E1 E1 00 
       F6 D5 E5 F5 
       F5 FA EA F6 
       00 E1 E1 F5 
       E1 E1 F6 F7 
       E1 D7 E6 F6 
       FA FB EB E1 
       E2 F6 E1 F6 
       E2 E1 E5 00 
       E1 E2 E5 EB 
       FF FB F6 E1 
       00 E5 E2 F6 
       00 EA 00 00 
       EA 00 EA EE 
       FF FF 00 EA 
       00 00 FA 00 
       00 00 00 00 
       00 00 E5 E1 
       F5 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
04262E             0016*M 
04262E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04262E 17 1B 21    0018*M     db 23,27,0x21
042631 10 00       0019*M     dw width ; in pixels
042633 10 00       0020*M     dw height ; in pixels
042635 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042636             0106*  	LOADBMPBUFFER2 BUF_SEEKER_017,16,16,"src/rgba2/seeker_017.rgba2"
042636             0001*M 
042636             0002*M     ; Clear buffer
042636 17 00 A0    0003*M     db 23,0,0xA0
042639 25 01       0004*M     dw bufferId
04263B 02          0005*M     db 2
04263C             0006*M 
04263C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04263F 25 01       0008*M     dw bufferId
042641             0009*M 
042641             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042641 17 00 A0    0011*M     db 23,0,0xA0
042644 25 01       0012*M     dw bufferId
042646 00          0013*M     db 0
042647 00 01       0014*M 	dw width * height ; length of data in bytes
042649 00 DB DB D7 0015*M     incbin file ; bitmap data
       00 00 E2 E2 
       00 E6 00 00 
       00 00 00 00 
       00 EB DB DB 
       DB 00 C0 E6 
       E6 00 FF F3 
       F2 00 00 C3 
       00 DB DF 00 
       00 00 D0 D1 
       D1 00 E7 E2 
       E1 00 00 E7 
       00 DB DB EB 
       F0 E5 D0 D1 
       E1 E1 E2 E0 
       00 D6 DB DB 
       00 F5 F5 00 
       E1 E5 D0 E1 
       F5 F6 E2 E4 
       FF 00 DF DF 
       00 E0 E0 00 
       E0 D0 D0 E5 
       FD F5 E1 E5 
       E5 DB DB DF 
       00 E1 E0 00 
       E1 D1 E4 FD 
       FE FD E5 E0 
       E1 00 EB EB 
       E0 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 E1 
       E0 00 E5 F5 
       E1 E1 E1 F2 
       E5 E5 F4 F8 
       FC F8 E5 E1 
       E2 00 E0 D0 
       E1 E1 F6 F6 
       E2 D6 E5 F5 
       F9 FA F6 E1 
       E2 E1 E0 00 
       E6 E5 E9 E1 
       E2 E6 E6 FA 
       FB EB E6 F1 
       E1 E1 E4 F5 
       EA FF 00 EA 
       E2 E5 EA FF 
       FB FB E2 E1 
       E2 E1 E1 00 
       00 00 00 EA 
       00 E5 EA FF 
       FF F6 E6 00 
       E5 E1 F2 00 
       00 00 00 00 
       E5 E5 E0 F5 
       FA 00 EA 00 
       00 FA E6 00 
       00 00 00 00 
       00 D0 E5 F5 
       FF 00 00 EA 
       00 FA 00 00 
       00 00 00 00 
       00 E0 F5 F5 
       00 FA 00 00 
       00 00 FA 00 
042749             0016*M 
042749             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042749 17 1B 21    0018*M     db 23,27,0x21
04274C 10 00       0019*M     dw width ; in pixels
04274E 10 00       0020*M     dw height ; in pixels
042750 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042751             0107*  	LOADBMPBUFFER2 BUF_SEEKER_018,16,16,"src/rgba2/seeker_018.rgba2"
042751             0001*M 
042751             0002*M     ; Clear buffer
042751 17 00 A0    0003*M     db 23,0,0xA0
042754 26 01       0004*M     dw bufferId
042756 02          0005*M     db 2
042757             0006*M 
042757 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04275A 26 01       0008*M     dw bufferId
04275C             0009*M 
04275C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04275C 17 00 A0    0011*M     db 23,0,0xA0
04275F 26 01       0012*M     dw bufferId
042761 00          0013*M     db 0
042762 00 01       0014*M 	dw width * height ; length of data in bytes
042764 00 00 E7 DB 0015*M     incbin file ; bitmap data
       DB EB 00 D1 
       E2 00 00 00 
       00 00 00 00 
       00 00 DB DF 
       DF E7 00 D0 
       E5 E6 00 00 
       F2 00 00 00 
       00 00 DA DB 
       EB F0 00 D0 
       D1 D2 00 FB 
       F7 F2 00 00 
       00 00 E5 EA 
       00 E5 E5 D0 
       D1 E0 E1 E2 
       E1 E1 00 00 
       00 E0 E0 00 
       00 E0 D0 D1 
       E1 F5 F2 E2 
       E0 00 DB DB 
       00 E1 E0 00 
       E4 E1 D0 E5 
       F9 F9 E2 E1 
       E5 00 F1 DB 
       E1 E0 E1 E2 
       E1 E1 E4 FD 
       FE FE E5 E1 
       E5 00 DB DF 
       E1 E1 E1 E2 
       E5 E1 F4 FD 
       FE FD E5 E0 
       E0 00 EB DB 
       E1 E5 F6 F6 
       E6 E5 F4 F8 
       FC F8 E1 E1 
       E4 00 F5 FA 
       EA E5 F7 E1 
       E2 E6 E5 F5 
       F9 F9 E5 E1 
       F3 E0 E0 00 
       FA 00 EA E6 
       E2 E5 FA FA 
       FB EB F6 E2 
       E2 E1 E0 00 
       00 E5 EA 00 
       D5 EA FF FF 
       FB E7 E1 E2 
       E1 E0 E1 00 
       00 00 00 E5 
       E5 E5 FA FF 
       F6 E2 E1 E6 
       E1 E1 F5 00 
       00 00 D0 00 
       E1 E0 F5 FA 
       00 EA 00 E5 
       E1 E2 00 00 
       00 00 00 00 
       E0 F5 F1 FF 
       00 FA 00 FF 
       FA F6 00 00 
       00 00 00 00 
       00 F5 E1 00 
       00 00 FA 00 
       FE 00 00 00 
042864             0016*M 
042864             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042864 17 1B 21    0018*M     db 23,27,0x21
042867 10 00       0019*M     dw width ; in pixels
042869 10 00       0020*M     dw height ; in pixels
04286B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04286C             0108*  	LOADBMPBUFFER2 BUF_SEEKER_019,16,16,"src/rgba2/seeker_019.rgba2"
04286C             0001*M 
04286C             0002*M     ; Clear buffer
04286C 17 00 A0    0003*M     db 23,0,0xA0
04286F 27 01       0004*M     dw bufferId
042871 02          0005*M     db 2
042872             0006*M 
042872 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042875 27 01       0008*M     dw bufferId
042877             0009*M 
042877             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042877 17 00 A0    0011*M     db 23,0,0xA0
04287A 27 01       0012*M     dw bufferId
04287C 00          0013*M     db 0
04287D 00 01       0014*M 	dw width * height ; length of data in bytes
04287F 00 00 00 EB 0015*M     incbin file ; bitmap data
       DF DF DB DB 
       00 E2 F3 00 
       00 00 00 00 
       00 00 00 DB 
       DA DB 00 00 
       D0 D1 E6 00 
       F7 00 00 00 
       00 00 00 E5 
       EA DB F0 E5 
       D0 D1 E6 00 
       FF 00 00 00 
       00 00 E0 E0 
       00 00 E5 E5 
       D1 D1 E0 00 
       FB F7 F3 00 
       00 E0 E1 E0 
       00 E1 E0 D0 
       D1 E1 F5 E2 
       E2 E1 E2 00 
       E1 E0 E1 E1 
       E2 E1 D0 E4 
       E5 F9 F6 E2 
       E1 E0 00 C6 
       E1 E1 E1 E1 
       E1 E1 E4 FD 
       FD FD F5 E1 
       E5 FF D6 DB 
       E5 F5 F6 F6 
       F6 E5 F4 F8 
       FE FE F9 E0 
       E5 F0 E7 DF 
       EA C4 D1 E1 
       D6 E6 E5 F8 
       FC FC E1 E1 
       E0 00 DB CB 
       00 00 EA E2 
       E2 E6 F5 F5 
       F9 F9 E1 E1 
       00 00 FA EB 
       F5 00 FE 00 
       E5 EA FA FB 
       FB E6 E1 E2 
       00 E0 E1 00 
       00 00 00 E5 
       EA FF FF FB 
       EB E6 F1 E2 
       E1 E1 E0 00 
       00 00 00 E5 
       E0 F5 FF F6 
       E2 E1 E2 E1 
       E1 E0 00 00 
       00 00 00 E0 
       F5 F5 FA 00 
       FA 00 E5 E1 
       E1 F5 00 00 
       00 00 00 F5 
       F5 00 FF 00 
       EA 00 E5 E2 
       F6 00 00 00 
       00 00 00 00 
       00 00 FA 00 
       F5 00 FF FA 
       F7 00 00 00 
04297F             0016*M 
04297F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04297F 17 1B 21    0018*M     db 23,27,0x21
042982 10 00       0019*M     dw width ; in pixels
042984 10 00       0020*M     dw height ; in pixels
042986 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042987             0109*  	LOADBMPBUFFER2 BUF_SEEKER_020,16,16,"src/rgba2/seeker_020.rgba2"
042987             0001*M 
042987             0002*M     ; Clear buffer
042987 17 00 A0    0003*M     db 23,0,0xA0
04298A 28 01       0004*M     dw bufferId
04298C 02          0005*M     db 2
04298D             0006*M 
04298D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042990 28 01       0008*M     dw bufferId
042992             0009*M 
042992             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042992 17 00 A0    0011*M     db 23,0,0xA0
042995 28 01       0012*M     dw bufferId
042997 00          0013*M     db 0
042998 00 01       0014*M 	dw width * height ; length of data in bytes
04299A 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
       00 00 00 00 
       F5 EA DB 00 
       00 00 C0 E2 
       00 00 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 D0 D1 E6 
       EA E6 00 00 
       00 E0 E0 E1 
       E1 00 E1 E5 
       D5 D1 D1 D2 
       00 FF 00 00 
       E1 E1 E1 E1 
       E2 E4 E1 D0 
       D0 D1 E1 E4 
       E3 FB F7 F3 
       E1 E1 E1 E1 
       E2 E1 E1 D4 
       E5 E5 F5 F5 
       E2 F2 E1 00 
       EA E5 F6 F6 
       F6 E1 E4 F8 
       FD FD F9 E2 
       E1 E0 00 00 
       00 00 D0 E1 
       E2 E5 F4 F8 
       FE FE F9 E1 
       E5 E5 00 EB 
       EA EA EA E2 
       E7 E6 E5 F8 
       FD FC E5 E0 
       E5 F0 00 DB 
       00 00 00 D1 
       E5 EA F5 F5 
       F8 F5 E1 E1 
       E1 00 DB DF 
       00 00 E5 EA 
       EE FF FB FB 
       FA F6 E1 D4 
       00 F0 EB DB 
       00 00 E5 E0 
       EA FF FB FB 
       EA F6 E2 E2 
       E0 E0 F5 EF 
       00 E0 E0 F1 
       F5 FF FB E2 
       E1 E2 E1 E1 
       E1 E0 00 00 
       00 00 F5 F5 
       F6 FA 00 EA 
       D0 E6 F1 E1 
       E0 00 00 00 
       00 00 00 F5 
       00 00 00 EA 
       00 E5 E1 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       00 FA E2 F6 
       00 00 00 00 
042A9A             0016*M 
042A9A             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042A9A 17 1B 21    0018*M     db 23,27,0x21
042A9D 10 00       0019*M     dw width ; in pixels
042A9F 10 00       0020*M     dw height ; in pixels
042AA1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042AA2             0110*  	LOADBMPBUFFER2 BUF_SEEKER_021,16,16,"src/rgba2/seeker_021.rgba2"
042AA2             0001*M 
042AA2             0002*M     ; Clear buffer
042AA2 17 00 A0    0003*M     db 23,0,0xA0
042AA5 29 01       0004*M     dw bufferId
042AA7 02          0005*M     db 2
042AA8             0006*M 
042AA8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042AAB 29 01       0008*M     dw bufferId
042AAD             0009*M 
042AAD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042AAD 17 00 A0    0011*M     db 23,0,0xA0
042AB0 29 01       0012*M     dw bufferId
042AB2 00          0013*M     db 0
042AB3 00 01       0014*M 	dw width * height ; length of data in bytes
042AB5 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 EA CB 
       DF DB DB 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E6 DB 
       E7 D6 00 D1 
       F2 00 00 00 
       00 00 E1 E0 
       E1 E0 00 00 
       F0 FF D0 D0 
       E6 00 00 00 
       E2 E1 E1 E1 
       E0 00 00 E0 
       E5 D5 D0 D1 
       E6 EA E6 00 
       E6 E1 E1 E1 
       E1 E2 E1 E0 
       D0 D0 D1 D1 
       00 00 00 00 
       EA E5 E6 F7 
       F6 E1 E1 E4 
       E4 E1 E1 F5 
       E4 F7 FB F3 
       00 00 00 E1 
       E2 E5 E0 F8 
       FD FD F9 F6 
       E2 E2 E2 F2 
       F5 EA FA E2 
       D7 E6 F4 F8 
       FE FE F9 E2 
       E1 E0 E0 00 
       00 00 00 E1 
       E5 E5 F5 F8 
       FD FD E9 E1 
       E5 E5 00 DB 
       E5 E6 E5 EA 
       EA FA F6 F9 
       F8 F4 E1 E0 
       E5 F0 00 DB 
       00 00 E1 E5 
       FF FF FB FB 
       FA E1 E1 E1 
       00 DB DB DF 
       00 E0 F5 E0 
       FF FB FB EB 
       F6 E1 E2 00 
       00 EA DA DF 
       00 F5 F5 F5 
       FA 00 E2 E1 
       E1 E2 E2 E1 
       E0 F5 EF FF 
       00 00 00 00 
       00 EA EA D1 
       E2 E1 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 C8 
       F6 E1 E1 E1 
       00 00 00 00 
       00 00 00 00 
       00 F5 00 FA 
       E6 E2 F5 00 
       00 00 00 00 
042BB5             0016*M 
042BB5             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042BB5 17 1B 21    0018*M     db 23,27,0x21
042BB8 10 00       0019*M     dw width ; in pixels
042BBA 10 00       0020*M     dw height ; in pixels
042BBC 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042BBD             0111*  	LOADBMPBUFFER2 BUF_SEEKER_022,16,16,"src/rgba2/seeker_022.rgba2"
042BBD             0001*M 
042BBD             0002*M     ; Clear buffer
042BBD 17 00 A0    0003*M     db 23,0,0xA0
042BC0 2A 01       0004*M     dw bufferId
042BC2 02          0005*M     db 2
042BC3             0006*M 
042BC3 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042BC6 2A 01       0008*M     dw bufferId
042BC8             0009*M 
042BC8             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042BC8 17 00 A0    0011*M     db 23,0,0xA0
042BCB 2A 01       0012*M     dw bufferId
042BCD 00          0013*M     db 0
042BCE 00 01       0014*M 	dw width * height ; length of data in bytes
042BD0 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 FA 
       DA DF DB DB 
       00 00 00 00 
       00 00 00 E1 
       E0 E1 E0 E5 
       DA DB F1 DB 
       00 00 00 00 
       00 E2 E1 E1 
       E0 E0 E1 00 
       00 00 00 00 
       D0 E2 00 00 
       FA EA E1 E1 
       E1 E1 F3 E0 
       E0 E5 E5 D0 
       D0 E6 F3 00 
       00 FE E5 F6 
       FB E2 E1 E1 
       D0 D0 D0 D1 
       D1 E6 00 00 
       EA 00 00 E1 
       E1 F6 E1 E1 
       D4 E0 D1 E1 
       D0 00 00 00 
       00 EA EA E2 
       E2 D6 E4 F4 
       FD F9 F5 F5 
       E5 E3 FF 00 
       00 00 00 E1 
       E6 E6 F4 F8 
       FE FE FD F6 
       E2 E2 F7 F3 
       00 FA E5 EA 
       EA F6 F5 FC 
       FD FE F9 E1 
       E1 E0 E1 E2 
       D0 E0 E0 EA 
       FF FA FA F9 
       F8 F8 E5 E1 
       E5 00 00 00 
       E0 F5 E0 FA 
       FF FB FB FA 
       F6 E1 E1 E0 
       E5 F0 E7 DB 
       00 F5 F5 FA 
       FF F6 E7 F6 
       E1 E1 D4 00 
       00 EB DF DB 
       00 00 00 FA 
       00 E6 E1 E1 
       F2 E2 00 00 
       FA DB DF DF 
       00 00 F5 00 
       EA EA D1 E2 
       E1 E1 E1 E0 
       F5 EB EF FF 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FF FA E2 
       E1 F5 00 00 
       00 00 00 00 
042CD0             0016*M 
042CD0             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042CD0 17 1B 21    0018*M     db 23,27,0x21
042CD3 10 00       0019*M     dw width ; in pixels
042CD5 10 00       0020*M     dw height ; in pixels
042CD7 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042CD8             0112*  	LOADBMPBUFFER2 BUF_SEEKER_023,16,16,"src/rgba2/seeker_023.rgba2"
042CD8             0001*M 
042CD8             0002*M     ; Clear buffer
042CD8 17 00 A0    0003*M     db 23,0,0xA0
042CDB 2B 01       0004*M     dw bufferId
042CDD 02          0005*M     db 2
042CDE             0006*M 
042CDE 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042CE1 2B 01       0008*M     dw bufferId
042CE3             0009*M 
042CE3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042CE3 17 00 A0    0011*M     db 23,0,0xA0
042CE6 2B 01       0012*M     dw bufferId
042CE8 00          0013*M     db 0
042CE9 00 01       0014*M 	dw width * height ; length of data in bytes
042CEB 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 00 E0 
       F4 EA DB DF 
       DB D7 C3 00 
       EA 00 E2 E1 
       E1 E0 E1 E0 
       E5 EA DB DF 
       DB 00 00 00 
       00 EA FA E1 
       E1 E1 E0 00 
       00 00 DB 00 
       D6 00 00 00 
       00 00 00 E5 
       F6 E1 E2 E2 
       E0 E1 E5 FF 
       00 D0 F2 00 
       00 E6 00 00 
       E6 F6 E1 E1 
       E1 E0 E5 D0 
       D0 D1 E2 00 
       00 00 EA E6 
       E1 E2 E5 E1 
       E4 D0 D0 D1 
       D1 D5 EA 00 
       E5 00 00 E2 
       E2 D6 E5 F4 
       F8 F9 E5 E1 
       E1 00 00 E6 
       00 FF E5 EA 
       EA E5 E5 F8 
       FD FD FD F5 
       E5 E2 FB 00 
       E0 E0 E1 EE 
       FF FA F5 FC 
       FE FE F9 F2 
       E2 E2 FB F7 
       F5 F5 E0 FA 
       FF FB FA F8 
       F8 FD E5 E1 
       E1 E0 E1 F2 
       F5 E0 FA FA 
       FA FB EB FA 
       E5 E1 E0 E5 
       E5 00 00 00 
       00 00 FA 00 
       E2 E6 E6 F6 
       E1 E5 E0 E1 
       F0 00 DB 00 
       00 00 00 EA 
       EA E1 E1 F6 
       E2 00 00 00 
       EB 00 DB EB 
       00 00 00 00 
       00 E9 E2 E1 
       E1 E1 E0 FA 
       DB DF DB EB 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E0 E0 F5 
       EF EF EF EF 
       00 00 00 00 
       FE E6 E2 F5 
       E5 00 00 00 
       00 00 00 00 
042DEB             0016*M 
042DEB             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042DEB 17 1B 21    0018*M     db 23,27,0x21
042DEE 10 00       0019*M     dw width ; in pixels
042DF0 10 00       0020*M     dw height ; in pixels
042DF2 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042DF3             0113*  	LOADBMPBUFFER2 BUF_SEEKER_024,16,16,"src/rgba2/seeker_024.rgba2"
042DF3             0001*M 
042DF3             0002*M     ; Clear buffer
042DF3 17 00 A0    0003*M     db 23,0,0xA0
042DF6 2C 01       0004*M     dw bufferId
042DF8 02          0005*M     db 2
042DF9             0006*M 
042DF9 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042DFC 2C 01       0008*M     dw bufferId
042DFE             0009*M 
042DFE             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042DFE 17 00 A0    0011*M     db 23,0,0xA0
042E01 2C 01       0012*M     dw bufferId
042E03 00          0013*M     db 0
042E04 00 01       0014*M 	dw width * height ; length of data in bytes
042E06 00 00 00 00 0015*M     incbin file ; bitmap data
       E2 E1 E1 00 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 EA 
       E1 E1 E1 E1 
       E1 E1 EA DB 
       DF DB D7 C3 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 00 
       00 F7 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       E2 D7 D5 E1 
       E1 D0 D0 D0 
       D0 D0 D1 F3 
       00 00 E5 EA 
       E5 E6 E5 F4 
       F8 F9 E1 D1 
       D1 D1 E6 00 
       E1 E1 E1 EE 
       EB F6 F5 F8 
       FD FD F9 F5 
       E1 00 00 00 
       F5 F5 F5 FF 
       FF FA F5 FC 
       FE FE FD F5 
       F5 00 00 00 
       00 00 FA FF 
       FB FB FA F8 
       FC FD F5 E2 
       E2 E2 FB 00 
       00 00 00 00 
       F6 EB EA F6 
       E1 E1 E1 E1 
       E1 E1 E2 F3 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 E2 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FA 
       E2 E1 E1 E1 
       E1 E1 FA DB 
       DF DB EB C3 
       00 00 00 00 
       F6 F6 F5 00 
       00 00 00 EF 
       00 EF 00 00 
042F06             0016*M 
042F06             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042F06 17 1B 21    0018*M     db 23,27,0x21
042F09 10 00       0019*M     dw width ; in pixels
042F0B 10 00       0020*M     dw height ; in pixels
042F0D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042F0E             0114*  	LOADBMPBUFFER2 BUF_SEEKER_025,16,16,"src/rgba2/seeker_025.rgba2"
042F0E             0001*M 
042F0E             0002*M     ; Clear buffer
042F0E 17 00 A0    0003*M     db 23,0,0xA0
042F11 2D 01       0004*M     dw bufferId
042F13 02          0005*M     db 2
042F14             0006*M 
042F14 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042F17 2D 01       0008*M     dw bufferId
042F19             0009*M 
042F19             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042F19 17 00 A0    0011*M     db 23,0,0xA0
042F1C 2D 01       0012*M     dw bufferId
042F1E 00          0013*M     db 0
042F1F 00 01       0014*M 	dw width * height ; length of data in bytes
042F21 00 00 00 00 0015*M     incbin file ; bitmap data
       EA E6 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E1 E0 F5 
       DB DB EB DB 
       00 00 00 00 
       00 E9 F6 E1 
       E1 E0 E0 F5 
       DB DF DB DB 
       00 00 00 EA 
       EA E1 F6 F2 
       E2 00 00 00 
       EB 00 DB D7 
       00 00 E5 00 
       E2 E2 E2 E5 
       E1 E1 E0 E1 
       F0 00 DB 00 
       E0 D0 E5 E5 
       E5 E6 D6 E5 
       E1 D1 D0 E5 
       E5 00 00 00 
       F5 E5 E0 EA 
       EA E6 E5 F4 
       F4 E4 D0 D0 
       D0 D0 C0 E2 
       F5 F5 F5 FF 
       FF FA F5 F8 
       FD FD E5 E1 
       D1 D1 E6 E2 
       00 FF FA FF 
       FB FB F9 FC 
       FE FE FD F5 
       E1 D1 E6 00 
       FA 00 00 F6 
       FB EB FA F8 
       FD FD F5 F6 
       E1 00 00 E6 
       00 00 EA E6 
       E2 E6 F6 E5 
       E1 E5 E1 E2 
       E2 E7 FF 00 
       00 EA 00 00 
       E1 F1 E1 E1 
       E1 E0 E5 E4 
       E0 E2 F3 00 
       00 00 00 E5 
       E2 E1 E2 E2 
       E0 E1 E5 FF 
       00 E1 F2 00 
       00 FA FA E1 
       E1 E1 E1 00 
       00 00 DB 00 
       D6 00 00 00 
       FA 00 E6 F2 
       E1 E4 E0 E0 
       E5 EB DB DF 
       DB 00 00 00 
       00 00 00 00 
       00 F5 00 D0 
       F5 EB DF DF 
       DB E7 C3 00 
043021             0016*M 
043021             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043021 17 1B 21    0018*M     db 23,27,0x21
043024 10 00       0019*M     dw width ; in pixels
043026 10 00       0020*M     dw height ; in pixels
043028 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043029             0115*  	LOADBMPBUFFER2 BUF_SEEKER_026,16,16,"src/rgba2/seeker_026.rgba2"
043029             0001*M 
043029             0002*M     ; Clear buffer
043029 17 00 A0    0003*M     db 23,0,0xA0
04302C 2E 01       0004*M     dw bufferId
04302E 02          0005*M     db 2
04302F             0006*M 
04302F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043032 2E 01       0008*M     dw bufferId
043034             0009*M 
043034             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043034 17 00 A0    0011*M     db 23,0,0xA0
043037 2E 01       0012*M     dw bufferId
043039 00          0013*M     db 0
04303A 00 01       0014*M 	dw width * height ; length of data in bytes
04303C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 FA EA E1 
       E1 E1 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E1 E0 
       00 00 00 00 
       00 00 D0 00 
       EA EA F7 F6 
       E1 E1 E0 E0 
       E5 DA DB E7 
       00 00 00 E5 
       00 E6 E1 F6 
       E2 E2 00 00 
       EA DB DF DB 
       00 E0 E1 E5 
       D5 E2 E2 E6 
       E5 E1 E4 00 
       00 EB DF DB 
       F5 F5 E0 E5 
       EA E5 E6 E5 
       E1 E1 E1 E0 
       E5 F0 E7 EB 
       E1 F1 F5 FA 
       FF FA E5 F4 
       F4 E4 D0 D0 
       E5 00 00 00 
       00 FF FA FF 
       FF FA F5 F8 
       FD FD E5 D1 
       D0 D0 D0 D1 
       00 00 00 F6 
       FB FB F9 FC 
       FE FE F9 E1 
       D1 D1 E5 E2 
       00 FA EA E2 
       E7 EB F9 F8 
       FD FE F9 F5 
       E0 D2 E6 00 
       FA 00 00 E1 
       E1 F6 E5 E1 
       E5 E5 E2 F2 
       E1 00 00 00 
       00 FF E5 E6 
       E2 E2 E1 E1 
       E0 E1 E1 E2 
       E2 FB 00 00 
       FE FA E1 E1 
       E1 E2 F3 E4 
       E0 E5 E5 E0 
       E1 F7 F2 00 
       00 F6 E2 E1 
       E0 E1 E0 00 
       00 00 00 00 
       E1 F2 00 00 
       00 00 00 F5 
       E1 E0 E0 F5 
       EB DB F1 DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       DB DF DB DB 
       00 00 00 00 
04313C             0016*M 
04313C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04313C 17 1B 21    0018*M     db 23,27,0x21
04313F 10 00       0019*M     dw width ; in pixels
043141 10 00       0020*M     dw height ; in pixels
043143 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043144             0116*  	LOADBMPBUFFER2 BUF_SEEKER_027,16,16,"src/rgba2/seeker_027.rgba2"
043144             0001*M 
043144             0002*M     ; Clear buffer
043144 17 00 A0    0003*M     db 23,0,0xA0
043147 2F 01       0004*M     dw bufferId
043149 02          0005*M     db 2
04314A             0006*M 
04314A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04314D 2F 01       0008*M     dw bufferId
04314F             0009*M 
04314F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04314F 17 00 A0    0011*M     db 23,0,0xA0
043152 2F 01       0012*M     dw bufferId
043154 00          0013*M     db 0
043155 00 01       0014*M 	dw width * height ; length of data in bytes
043157 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 00 EA 
       E5 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C4 
       F5 E1 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FE EA D1 
       F6 E1 E1 E1 
       E0 00 00 00 
       00 F5 E0 E5 
       E5 00 E2 E1 
       F6 E1 E1 E0 
       E0 E5 DB EB 
       00 F5 F5 E0 
       EA E5 E2 D6 
       F6 E1 E2 00 
       00 EA DA DF 
       00 00 F5 F5 
       FF EA E6 E6 
       E5 E1 E1 E1 
       00 DB DB DF 
       FA FF FA FF 
       FF FA F5 E5 
       F4 E4 D0 E0 
       E5 F0 00 DB 
       00 00 00 F6 
       FB FB F5 F8 
       F8 FD E4 D0 
       E5 E5 00 DB 
       F5 EA FA E2 
       EB FB F9 FC 
       FE FD E5 D1 
       D1 D0 D0 00 
       00 00 00 E1 
       E6 E6 F9 FC 
       FE FD F9 E1 
       D1 D1 D1 E2 
       FF E5 E5 E2 
       F1 E1 E1 E1 
       F9 F5 F6 F5 
       E0 E6 E6 F3 
       FA E2 E1 E1 
       E2 E2 E1 E1 
       E0 E1 E2 E2 
       00 00 00 00 
       F7 F6 E1 E1 
       E1 00 00 E0 
       E5 E5 E1 E2 
       FB FF F7 00 
       00 00 F5 E0 
       E1 E0 00 00 
       F0 FF E0 E1 
       F7 00 00 00 
       00 00 00 00 
       E0 E1 FA DB 
       E7 D6 00 E2 
       F3 00 00 00 
       00 00 00 00 
       00 00 EB CB 
       DF DB C6 00 
       00 00 00 00 
043257             0016*M 
043257             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043257 17 1B 21    0018*M     db 23,27,0x21
04325A 10 00       0019*M     dw width ; in pixels
04325C 10 00       0020*M     dw height ; in pixels
04325E 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04325F             0117*  	LOADBMPBUFFER2 BUF_SEEKER_028,16,16,"src/rgba2/seeker_028.rgba2"
04325F             0001*M 
04325F             0002*M     ; Clear buffer
04325F 17 00 A0    0003*M     db 23,0,0xA0
043262 30 01       0004*M     dw bufferId
043264 02          0005*M     db 2
043265             0006*M 
043265 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043268 30 01       0008*M     dw bufferId
04326A             0009*M 
04326A             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04326A 17 00 A0    0011*M     db 23,0,0xA0
04326D 30 01       0012*M     dw bufferId
04326F 00          0013*M     db 0
043270 00 01       0014*M 	dw width * height ; length of data in bytes
043272 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 EA 
       00 EA E1 E1 
       00 00 00 00 
       00 00 00 E0 
       00 00 00 EA 
       00 E5 E1 E1 
       E0 00 00 00 
       00 00 F5 E0 
       E5 E5 00 EA 
       D0 F6 E1 E1 
       E0 00 00 00 
       00 F5 F5 F1 
       E0 EA D1 E2 
       E1 F6 E1 E1 
       E1 E0 00 00 
       00 00 F6 F5 
       EA EE E5 E7 
       E2 F6 E2 E2 
       E1 E0 F5 DB 
       00 00 FA FF 
       FF FF EA E6 
       E5 E1 E1 E4 
       00 F0 EA DB 
       00 00 00 FB 
       FB FB F5 E5 
       F4 E4 E1 E1 
       E1 00 DB DF 
       FA EA EA E2 
       FB FB F5 F8 
       F8 F8 D4 D0 
       E5 F0 00 DB 
       00 00 D0 E1 
       EA FA F8 FD 
       FE FD E5 D0 
       D5 E5 00 EB 
       FA E5 E6 E2 
       F6 F6 F5 FC 
       FE FD E5 D1 
       D1 D0 00 00 
       E2 E1 F1 E1 
       E2 E1 E1 E5 
       F9 F9 F5 E1 
       D1 D1 C0 00 
       F6 E1 E1 E1 
       E2 D4 E1 E0 
       E1 E2 F5 E4 
       D2 E6 E2 F3 
       00 F5 E0 E1 
       E0 00 E1 E5 
       E5 E1 E2 E3 
       00 EA 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 E0 F2 FB 
       FF E6 00 00 
       00 00 00 00 
       F5 EB DB 00 
       00 00 E1 F7 
       00 00 00 00 
       00 00 00 00 
       EF DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
043372             0016*M 
043372             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043372 17 1B 21    0018*M     db 23,27,0x21
043375 10 00       0019*M     dw width ; in pixels
043377 10 00       0020*M     dw height ; in pixels
043379 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04337A             0118*  	LOADBMPBUFFER2 BUF_SEEKER_029,16,16,"src/rgba2/seeker_029.rgba2"
04337A             0001*M 
04337A             0002*M     ; Clear buffer
04337A 17 00 A0    0003*M     db 23,0,0xA0
04337D 31 01       0004*M     dw bufferId
04337F 02          0005*M     db 2
043380             0006*M 
043380 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043383 31 01       0008*M     dw bufferId
043385             0009*M 
043385             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043385 17 00 A0    0011*M     db 23,0,0xA0
043388 31 01       0012*M     dw bufferId
04338A 00          0013*M     db 0
04338B 00 01       0014*M 	dw width * height ; length of data in bytes
04338D 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E5 00 
       F5 00 EA E6 
       E2 00 00 00 
       00 00 00 F5 
       E0 00 E6 00 
       EA 00 E5 E1 
       E1 00 00 00 
       00 00 00 F5 
       F5 E1 E5 00 
       FA 00 E6 E1 
       E1 E1 00 00 
       00 00 00 F5 
       E0 E5 EA E1 
       E2 E1 F7 E1 
       E1 E0 00 00 
       00 00 00 FA 
       FF FF EA E5 
       D7 E2 F6 E1 
       E0 E1 E0 00 
       F5 00 EA 00 
       FB FF FA E5 
       E6 E5 E1 E2 
       00 E0 E1 00 
       00 00 EA E2 
       FB FB F6 F5 
       F4 E0 E1 E1 
       00 00 E6 EA 
       FA C8 D1 E1 
       EB FB F9 F8 
       F8 F8 E4 E0 
       E0 00 DB CB 
       E6 F6 E2 E1 
       F6 FA F8 FD 
       FE FD E4 D0 
       E5 F0 E7 DF 
       E2 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 D0 
       D5 FF D6 DB 
       F5 E1 E1 E2 
       E2 E1 E1 E9 
       F9 F9 E1 D1 
       D0 D0 00 DB 
       00 E1 E1 E1 
       00 E1 E0 E1 
       E2 F6 F5 D1 
       D1 D0 D1 00 
       00 00 E0 E0 
       00 00 E5 E5 
       E1 E2 E4 00 
       E6 E6 F2 00 
       00 00 00 F5 
       EA DB F0 E5 
       E0 E2 F7 00 
       EA 00 00 00 
       00 00 00 EF 
       DA DB 00 00 
       E0 E2 FB 00 
       E6 00 00 00 
       00 00 00 FF 
       DF DF DB DB 
       00 F2 F3 00 
       00 00 00 00 
04348D             0016*M 
04348D             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04348D 17 1B 21    0018*M     db 23,27,0x21
043490 10 00       0019*M     dw width ; in pixels
043492 10 00       0020*M     dw height ; in pixels
043494 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043495             0119*  	LOADBMPBUFFER2 BUF_SEEKER_030,16,16,"src/rgba2/seeker_030.rgba2"
043495             0001*M 
043495             0002*M     ; Clear buffer
043495 17 00 A0    0003*M     db 23,0,0xA0
043498 32 01       0004*M     dw bufferId
04349A 02          0005*M     db 2
04349B             0006*M 
04349B 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04349E 32 01       0008*M     dw bufferId
0434A0             0009*M 
0434A0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0434A0 17 00 A0    0011*M     db 23,0,0xA0
0434A3 32 01       0012*M     dw bufferId
0434A5 00          0013*M     db 0
0434A6 00 01       0014*M 	dw width * height ; length of data in bytes
0434A8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 D0 00 
       00 00 EA 00 
       FA 00 00 00 
       00 00 00 00 
       F5 F5 E0 FA 
       00 EA 00 FE 
       EA E2 00 00 
       00 00 F5 00 
       F5 E0 E0 E5 
       00 EA 00 E5 
       E1 E1 00 00 
       00 00 00 FA 
       FA FA EA EA 
       E1 E2 E1 F6 
       E1 E1 E1 00 
       00 E5 EA 00 
       FF FF FF EA 
       E6 E2 E1 FB 
       E1 E0 E0 00 
       FF 00 EA E6 
       F6 FB FA F6 
       E6 D6 F6 E2 
       E1 E0 E1 00 
       FA E5 D1 E1 
       E7 FB FA F5 
       F4 E4 E1 E1 
       F3 E1 E0 00 
       E2 E5 E2 E1 
       F6 FA F9 FC 
       F8 F4 E1 E1 
       E0 00 E5 FA 
       E1 E1 E1 F2 
       E1 F6 F8 FD 
       FE FD D4 D0 
       E0 00 DA DA 
       F5 E0 E1 E2 
       E1 E1 F8 FE 
       FE F9 E0 D0 
       E5 00 DB DF 
       00 E0 E1 00 
       D4 E1 E5 F9 
       FD F5 D1 D0 
       E5 00 F1 DB 
       00 E0 E0 00 
       00 E0 E1 E1 
       F6 F5 E1 D1 
       D0 00 DB DB 
       00 00 F5 FA 
       00 E5 E5 E1 
       E2 E5 D0 D1 
       D0 D0 00 00 
       00 00 EB DB 
       EB F0 00 E0 
       E2 E3 00 E6 
       E6 E2 00 00 
       00 00 EF DF 
       DF E7 00 E1 
       F7 FF 00 00 
       F3 00 00 00 
       00 00 FF DF 
       DB DB 00 E2 
       F3 00 00 00 
       00 00 00 00 
0435A8             0016*M 
0435A8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0435A8 17 1B 21    0018*M     db 23,27,0x21
0435AB 10 00       0019*M     dw width ; in pixels
0435AD 10 00       0020*M     dw height ; in pixels
0435AF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0435B0             0120*  	LOADBMPBUFFER2 BUF_SEEKER_031,16,16,"src/rgba2/seeker_031.rgba2"
0435B0             0001*M 
0435B0             0002*M     ; Clear buffer
0435B0 17 00 A0    0003*M     db 23,0,0xA0
0435B3 33 01       0004*M     dw bufferId
0435B5 02          0005*M     db 2
0435B6             0006*M 
0435B6 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0435B9 33 01       0008*M     dw bufferId
0435BB             0009*M 
0435BB             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0435BB 17 00 A0    0011*M     db 23,0,0xA0
0435BE 33 01       0012*M     dw bufferId
0435C0 00          0013*M     db 0
0435C1 00 01       0014*M 	dw width * height ; length of data in bytes
0435C3 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 F5 E0 
       00 E5 00 00 
       00 00 EA 00 
       00 00 00 00 
       00 E0 F5 E0 
       FF 00 00 E6 
       00 EA 00 00 
       00 00 00 00 
       FA FA E0 E1 
       E5 00 EA 00 
       00 FA E2 00 
       00 00 00 EA 
       00 FA FA EE 
       EA E2 E6 00 
       E5 E1 E1 00 
       FE FF 00 EA 
       E2 FA FF FF 
       EA E2 E1 E6 
       F6 E1 E1 00 
       E6 E5 E9 E1 
       E6 FB FB FA 
       E5 D6 E2 F6 
       E1 E1 E0 E0 
       E2 E1 E2 E1 
       E6 EB FA F5 
       E5 E5 E5 E1 
       E2 E0 E1 00 
       F5 E1 E1 F6 
       F6 FA F8 FC 
       F8 F4 E1 E1 
       E2 00 E0 E0 
       E5 E1 E1 E2 
       E1 E5 F8 FE 
       FD F8 E4 E1 
       E0 00 E5 F4 
       00 E0 E1 00 
       E5 E1 FD FE 
       FD F9 D0 E0 
       E1 00 EA EA 
       00 E0 E0 00 
       E0 E0 E5 F9 
       FD E5 D0 E5 
       E5 DB DB DB 
       00 F5 FA 00 
       E1 E5 E1 F2 
       F5 E1 D1 D0 
       FF 00 DF DF 
       00 EF DB EB 
       F0 E5 E1 E2 
       E5 E1 D1 D0 
       00 D6 DB DB 
       00 EF DF 00 
       00 00 E0 E2 
       E2 00 D5 D1 
       D0 00 00 D7 
       00 EF DB DB 
       DB 00 E1 FB 
       FB 00 EA E2 
       F2 00 00 C3 
       00 EF EB EB 
       00 00 F2 F7 
       00 E6 00 00 
       00 00 00 00 
0436C3             0016*M 
0436C3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0436C3 17 1B 21    0018*M     db 23,27,0x21
0436C6 10 00       0019*M     dw width ; in pixels
0436C8 10 00       0020*M     dw height ; in pixels
0436CA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0436CB             0121*  	LOADBMPBUFFER2 BUF_SHIP_0L,16,16,"src/rgba2/ship_0l.rgba2"
0436CB             0001*M 
0436CB             0002*M     ; Clear buffer
0436CB 17 00 A0    0003*M     db 23,0,0xA0
0436CE 34 01       0004*M     dw bufferId
0436D0 02          0005*M     db 2
0436D1             0006*M 
0436D1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0436D4 34 01       0008*M     dw bufferId
0436D6             0009*M 
0436D6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0436D6 17 00 A0    0011*M     db 23,0,0xA0
0436D9 34 01       0012*M     dw bufferId
0436DB 00          0013*M     db 0
0436DC 00 01       0014*M 	dw width * height ; length of data in bytes
0436DE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 C6 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 CA 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C6 CA 
       CB C7 DB 00 
       00 00 00 00 
       00 00 C7 00 
       C7 CA C6 CA 
       CB C7 CB DB 
       00 00 C7 00 
       00 00 C7 00 
       CA CA C6 CA 
       CB C7 CB CB 
       DB 00 C7 00 
       00 00 C7 C7 
       CA C6 C6 CA 
       CB C7 C7 CB 
       CB DB C7 00 
       00 00 C7 CA 
       C6 C6 C6 CA 
       CB C7 C7 C7 
       CB CB C7 00 
       00 00 C7 CA 
       C6 CA C6 CA 
       CB C7 CB C7 
       C7 CB C7 00 
       00 00 C7 CA 
       C7 C7 C6 CA 
       CB C7 DB DB 
       C7 CB C7 00 
       00 00 C7 00 
       00 00 C6 00 
       00 C7 00 00 
       DB CB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB DB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
0437DE             0016*M 
0437DE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0437DE 17 1B 21    0018*M     db 23,27,0x21
0437E1 10 00       0019*M     dw width ; in pixels
0437E3 10 00       0020*M     dw height ; in pixels
0437E5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0437E6             0122*  	LOADBMPBUFFER2 BUF_SHIP_1C,16,16,"src/rgba2/ship_1c.rgba2"
0437E6             0001*M 
0437E6             0002*M     ; Clear buffer
0437E6 17 00 A0    0003*M     db 23,0,0xA0
0437E9 35 01       0004*M     dw bufferId
0437EB 02          0005*M     db 2
0437EC             0006*M 
0437EC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0437EF 35 01       0008*M     dw bufferId
0437F1             0009*M 
0437F1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0437F1 17 00 A0    0011*M     db 23,0,0xA0
0437F4 35 01       0012*M     dw bufferId
0437F6 00          0013*M     db 0
0437F7 00 01       0014*M 	dw width * height ; length of data in bytes
0437F9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C7 DB 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C7 CB DB 
       00 00 C7 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C7 CB CB 
       DB 00 C7 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C7 C7 CB 
       CB DB C7 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C7 C7 C7 
       CB CB C7 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C7 CB C7 
       C7 CB C7 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C7 DB DB 
       C7 CB C7 00 
       00 DB DB DB 
       00 00 DB 00 
       00 C7 00 00 
       DB DB C7 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438F9             0016*M 
0438F9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0438F9 17 1B 21    0018*M     db 23,27,0x21
0438FC 10 00       0019*M     dw width ; in pixels
0438FE 10 00       0020*M     dw height ; in pixels
043900 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043901             0123*  	LOADBMPBUFFER2 BUF_SHIP_2R,16,16,"src/rgba2/ship_2r.rgba2"
043901             0001*M 
043901             0002*M     ; Clear buffer
043901 17 00 A0    0003*M     db 23,0,0xA0
043904 36 01       0004*M     dw bufferId
043906 02          0005*M     db 2
043907             0006*M 
043907 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04390A 36 01       0008*M     dw bufferId
04390C             0009*M 
04390C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04390C 17 00 A0    0011*M     db 23,0,0xA0
04390F 36 01       0012*M     dw bufferId
043911 00          0013*M     db 0
043912 00 01       0014*M 	dw width * height ; length of data in bytes
043914 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C6 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C6 C7 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C6 CA C7 
       00 C6 00 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C6 CA CA 
       00 C6 00 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C6 C6 CA 
       C7 C6 00 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C6 C6 C6 
       CA C6 00 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C6 CA C6 
       CA C6 00 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C6 C7 C7 
       CA C6 00 00 
       00 DB CB DB 
       00 00 DB 00 
       00 C6 00 00 
       00 C6 00 00 
       00 DB DB DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A14             0016*M 
043A14             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A14 17 1B 21    0018*M     db 23,27,0x21
043A17 10 00       0019*M     dw width ; in pixels
043A19 10 00       0020*M     dw height ; in pixels
043A1B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A1C             0124*  	LOADBMPBUFFER2 BUF_SHIP_SMALL,8,8,"src/rgba2/ship_small.rgba2"
043A1C             0001*M 
043A1C             0002*M     ; Clear buffer
043A1C 17 00 A0    0003*M     db 23,0,0xA0
043A1F 37 01       0004*M     dw bufferId
043A21 02          0005*M     db 2
043A22             0006*M 
043A22 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A25 37 01       0008*M     dw bufferId
043A27             0009*M 
043A27             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A27 17 00 A0    0011*M     db 23,0,0xA0
043A2A 37 01       0012*M     dw bufferId
043A2C 00          0013*M     db 0
043A2D 40 00       0014*M 	dw width * height ; length of data in bytes
043A2F 00 00 00 CB 0015*M     incbin file ; bitmap data
       CA 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       CB 00 00 CB 
       CA 00 00 CA 
       CB 00 CB C7 
       C6 CB 00 CA 
       CB CB C7 CB 
       CA C6 CB CA 
       CB C7 CB CB 
       CA CB C6 CA 
       CB 00 00 00 
       00 00 00 CA 
043A6F             0016*M 
043A6F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A6F 17 1B 21    0018*M     db 23,27,0x21
043A72 08 00       0019*M     dw width ; in pixels
043A74 08 00       0020*M     dw height ; in pixels
043A76 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A77             0125*  	LOADBMPBUFFER2 BUF_STAR,5,5,"src/rgba2/star.rgba2"
043A77             0001*M 
043A77             0002*M     ; Clear buffer
043A77 17 00 A0    0003*M     db 23,0,0xA0
043A7A 38 01       0004*M     dw bufferId
043A7C 02          0005*M     db 2
043A7D             0006*M 
043A7D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A80 38 01       0008*M     dw bufferId
043A82             0009*M 
043A82             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A82 17 00 A0    0011*M     db 23,0,0xA0
043A85 38 01       0012*M     dw bufferId
043A87 00          0013*M     db 0
043A88 19 00       0014*M 	dw width * height ; length of data in bytes
043A8A 00 00 D1 00 0015*M     incbin file ; bitmap data
       00 00 00 E6 
       00 00 D1 E6 
       FF E6 D1 00 
       00 E6 00 00 
       00 00 D1 00 
       00          
043AA3             0016*M 
043AA3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043AA3 17 1B 21    0018*M     db 23,27,0x21
043AA6 05 00       0019*M     dw width ; in pixels
043AA8 05 00       0020*M     dw height ; in pixels
043AAA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043AAB             0126*  	LOADBMPBUFFER2 BUF_TURRET,16,16,"src/rgba2/turret.rgba2"
043AAB             0001*M 
043AAB             0002*M     ; Clear buffer
043AAB 17 00 A0    0003*M     db 23,0,0xA0
043AAE 39 01       0004*M     dw bufferId
043AB0 02          0005*M     db 2
043AB1             0006*M 
043AB1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043AB4 39 01       0008*M     dw bufferId
043AB6             0009*M 
043AB6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043AB6 17 00 A0    0011*M     db 23,0,0xA0
043AB9 39 01       0012*M     dw bufferId
043ABB 00          0013*M     db 0
043ABC 00 01       0014*M 	dw width * height ; length of data in bytes
043ABE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043BBE             0016*M 
043BBE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043BBE 17 1B 21    0018*M     db 23,27,0x21
043BC1 10 00       0019*M     dw width ; in pixels
043BC3 10 00       0020*M     dw height ; in pixels
043BC5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043BC6             0127*  	LOADBMPBUFFER2 BUF_TURRET_ROT,16,16,"src/rgba2/turret_rot.rgba2"
043BC6             0001*M 
043BC6             0002*M     ; Clear buffer
043BC6 17 00 A0    0003*M     db 23,0,0xA0
043BC9 3A 01       0004*M     dw bufferId
043BCB 02          0005*M     db 2
043BCC             0006*M 
043BCC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043BCF 3A 01       0008*M     dw bufferId
043BD1             0009*M 
043BD1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043BD1 17 00 A0    0011*M     db 23,0,0xA0
043BD4 3A 01       0012*M     dw bufferId
043BD6 00          0013*M     db 0
043BD7 00 01       0014*M 	dw width * height ; length of data in bytes
043BD9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 DF DF 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 DF DF 
       DF D0 F5 C3 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 DF 
       DF DF C3 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 D0 
       DF C3 DF D0 
       F5 C3 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 DF DF DF 
       C3 F5 F5 F5 
       C3 F5 F5 D0 
       D0 F5 F5 C3 
       F5 D0 DF C3 
       DF D0 F5 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 C3 DF 
       DF DF D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 F5 
       F5 C3 F5 D0 
       DF DF DF C3 
       D0 D0 D0 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       D0 DF C3 FA 
       E5 E5 D0 D0 
       00 D0 F5 F5 
       F5 F5 F5 C3 
       D0 C3 FA FA 
       FA E5 D0 00 
       00 D0 F5 F5 
       F5 F5 C3 F5 
       D0 D0 E5 FA 
       E5 E5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       D0 D0 E5 E5 
       E5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 D0 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043CD9             0016*M 
043CD9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043CD9 17 1B 21    0018*M     db 23,27,0x21
043CDC 10 00       0019*M     dw width ; in pixels
043CDE 10 00       0020*M     dw height ; in pixels
043CE0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043CE1             0128*  @end:
043CE1             0048   	include "src/asm/fonts.inc"
043CE1             0001*  font_nurples:
043CE1 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
043CE9 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
043CF1 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
043CF9 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
043D01 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
043D09 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
043D11 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
043D19 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
043D21 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
043D29 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
043D31 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
043D39 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
043D41 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
043D49 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
043D51 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
043D59 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
043D61 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
043D69 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
043D71 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
043D79 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
043D81 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
043D89 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
043D91 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
043D99 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
043DA1 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
043DA9 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
043DB1 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
043DB9 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
043DC1 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
043DC9 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
043DD1 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
043DD9 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
043DE1 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
043DE9 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
043DF1 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
043DF9 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
043E01 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
043E09 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
043E11 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
043E19 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
043E21 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
043E29 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
043E31 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
043E39 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
043E41 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
043E49 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
043E51 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
043E59 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
043E61 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
043E69 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
043E71 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
043E79 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
043E81 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
043E89 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
043E91 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
043E99 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
043EA1 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
043EA9 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
043EB1 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
043EB9 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
043EC1 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
043EC9 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
043ED1 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
043ED9 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
043EE1 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
043EE9 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
043EF1 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
043EF9 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
043F01 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
043F09 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
043F11 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
043F19 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
043F21 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
043F29 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
043F31 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
043F39 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
043F41 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
043F49 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
043F51 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
043F59 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
043F61 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
043F69 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
043F71 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
043F79 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
043F81 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
043F89 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
043F91 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
043F99 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
043FA1 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
043FA9 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
043FB1 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
043FB9 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
043FC1 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
043FC9 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
043FD1 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
043FD9 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
043FE1 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
043FE9 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
043FF1 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
043FF9 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
044001 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
044009 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
044011 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
044019 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
044021 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
044029 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
044031 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
044039 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
044041 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
044049 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
044051 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
044059 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
044061 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
044069 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
044071 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
044079 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
044081 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
044089 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
044091 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
044099 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
0440A1 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
0440A9 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
0440B1 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
0440B9 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
0440C1 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
0440C9 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
0440D1 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
0440D9 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
0440E1 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
0440E9 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
0440F1 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
0440F9 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
044101 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
044109 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
044111 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
044119 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
044121 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
044129 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
044131 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
044139 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
044141 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
044149 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
044151 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
044159 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
044161             0049   	include "src/asm/levels.inc"
044161 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
044162 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044172 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
044182 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044192 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441A2 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
0441B2 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0441C2 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441D2 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
0441E2 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
0441F2 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044202 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
044212 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
044222 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
044232 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
044242 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044252 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
044262 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
044272 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044282 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044292 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
0442A2 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
0442B2 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
0442C2 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
0442D2 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0442E2 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
0442F2 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044302 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044312 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044322 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044332 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044342 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
044352 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044362 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044372 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044382 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044392 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0443A2 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443B2 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443C2 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0443D2 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0443E2 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0443F2 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044402 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044412 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044422 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044432 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044442 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044452 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044462 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044472 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044482 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044492 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0444A2 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0444B2 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0444C2 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444D2 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444E2 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0444F2 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044502 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044512 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044522 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044532 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044542 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044552 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044562 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044572 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
044582 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044592 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0445A2 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0445B2 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
0445C2 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
0445D2 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
0445E2 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0445F2 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044602 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044612 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044622 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044632 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044642 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044652 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044662 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044672 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044682 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044692 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0446A2 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446B2 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446C2 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0446D2 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
0446E2 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
0446F2 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044702 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044712 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044722 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
044732 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
044742 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
044752 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
044762 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044772 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044782 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
044792 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447A2 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447B2 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447C2 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447D2 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447E2 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447F2 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044802 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044812 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044822 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044832 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044842 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044852 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
044862 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044872 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044882 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044892 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
0448A2 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
0448B2 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0448C2 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448D2 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448E2 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0448F2 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
044902 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
044912 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044922 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044932 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044942 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044952 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044962 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044972 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044982 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
044992 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
0449A2 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0449B2 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449C2 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449D2 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449E2 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449F2 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A02 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044A12 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
044A22 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
044A32 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044A42 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A52 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A62 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044A72 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
044A82 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
044A92 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
044AA2 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AB2 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AC2 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044AD2 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
044AE2 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
044AF2 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044B02 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B12 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B22 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044B32 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B42 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B52 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
044B62 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
044B72 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
044B82 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
044B92 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BA2 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BB2 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
044BC2 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
044BD2 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
044BE2 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
044BF2 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C02 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C12 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C22 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C32 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C42 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C52 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C62 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C72 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C82 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C92 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CA2 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CB2 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044CC2 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CD2 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CE2 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044CF2 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D02 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D12 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044D22 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D32 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D42 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044D52 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D62 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D72 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044D82 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044D92 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044DA2 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044DB2 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DC2 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DD2 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044DE2 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044DF2 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044E02 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044E12 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E22 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E32 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
044E42 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E52 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E62 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044E72 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E82 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E92 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
044EA2 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
044EB2 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
044EC2 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
044ED2 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
044EE2 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
044EF2 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
044F02 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
044F12 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F22 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F32 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044F42 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F52 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F62 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
044F72 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F82 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F92 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044FA2 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FB2 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FC2 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044FD2 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FE2 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FF2 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
045002 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045012 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045022 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
045032 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045042 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045052 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
045062 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045072 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045082 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
045092 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450A2 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450B2 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0450C2 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450D2 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450E2 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0450F2 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045102 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045112 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
045122 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
045132 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
045142 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
045152 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045162             0258*  
045162             0259*  
045162 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
045163 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045173 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045183 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045193 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451A3 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451B3 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451C3 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451D3 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451E3 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451F3 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045203 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045213 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045223 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045233 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045243 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045253 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045263             0277*  
045263             0050   
045263             0051   	include "src/asm/sprites.inc"
045263             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
045263             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
045263             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
045263             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
045263             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
045263             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
045263             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
045263             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
045263             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
045263             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
045263             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
045263             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045263             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045263             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
045263             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
045263             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
045263             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
045263             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
045263             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
045263             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
045263             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
045263             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
045263             0023*  
045263             0024*  ; ###### SPRITE TABLE VARIABLES ######
045263             0025*  ; maximum number of sprites
045263             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
045263             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
045263             0028*  
045263             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
045263             0030*  table_base:
045263 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0452FB             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0452FB             0033*  
0452FB             0034*  ; pointer to top address of current record, initialized to table_base
0452FB 63 52 04    0035*  table_pointer: dl table_base
0452FE             0036*  ; how many active sprites
0452FE 00          0037*  table_active_sprites: db 0x00
0452FF             0038*  ; flag indicating collision with screen edge
0452FF             0039*  ; uses orientation codes to specify which edge(s)
0452FF 00          0040*  sprite_screen_edge: db #00
045300             0041*  ; next sprite id to use
045300 00          0042*  sprite_next_id: db 0
045301             0043*  
045301             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
045301             0045*  ; integer coordinates are all that are needed for collision calculations
045301 00          0046*  collision_x: db 0x00
045302 00          0047*  collision_y: db 0x00
045303 00          0048*  collision_dim_x: db 0x00
045304 00          0049*  collision_dim_y: db 0x00
045305             0050*  
045305             0051*  ; scratch variables
045305 00          0052*  x: db 0x00 ; 8-bit signed integer
045306 00          0053*  y: db 0x00 ; 8-bit signed integer
045307 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
04530A 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04530D 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
045310 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
045313 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
045316 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
045319             0060*  
045319             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
045319 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04531C 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04531F 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
045322             0065*  
045322             0066*  ; gets the next available sprite id
045322             0067*  ; inputs; none
045322             0068*  ; returns: if new sprite available, a = sprite id,
045322             0069*  ;           ix pointing to new sprite vars, carry set
045322             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
045322             0071*  ; destroys: a,b,hl,ix
045322             0072*  ; affects: bumps table_active_sprites by one
045322             0073*  table_get_next_id:
045322 DD 21 63 52 0074*      ld ix,table_base
       04          
045327 11 26 00 00 0075*      ld de,table_bytes_per_record
04532B 06 04       0076*      ld b,table_max_records
04532D             0077*  @loop:
04532D DD 7E 01    0078*      ld a,(ix+sprite_type)
045330 A7          0079*      and a
045331 28 06       0080*      jr z,@found
045333 DD 19       0081*      add ix,de
045335 10 F6       0082*      djnz @loop
045337             0083*  @notfound:
045337 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
045338 C9          0085*      ret
045339             0086*  @found:
045339             0087*  ; bump number of active sprites
045339 21 FE 52 04 0088*      ld hl,table_active_sprites
04533D 34          0089*      inc (hl)
04533E             0090*  ; return sprite id
04533E 3E 04       0091*      ld a,table_max_records
045340 90          0092*      sub b
045341 32 00 53 04 0093*      ld (sprite_next_id),a
045345 37          0094*      scf ; sets carry flag indicating we found a free sprite
045346 C9          0095*      ret ; done
045347             0096*  
045347             0097*  ; deactivate the sprite with the given id
045347             0098*  ; inputs: a = sprite id
045347             0099*  ; outputs: nothing
045347             0100*  ; destroys: a,ix,de
045347             0101*  ; affects: decrements table_active_sprites by one
045347             0102*  table_deactivate_sprite:
045347 F5          0103*      push af ; save sprite id bc we need it later
045348 CD A1 5B 04 0104*      call vdu_sprite_select
04534C CD 25 5C 04 0105*      call vdu_sprite_hide
045350 F1          0106*      pop af ; restore sprite id
045351 11 00 00 00 0107*      ld de,0 ; clear deu
045355 57          0108*      ld d,a
045356 1E 26       0109*      ld e,table_bytes_per_record
045358 ED 5C       0110*      mlt de
04535A DD 21 63 52 0111*      ld ix,table_base
       04          
04535F DD 19       0112*      add ix,de
045361 AF          0113*      xor a
045362 DD 77 01    0114*      ld (ix+sprite_type),a
045365 DD 21 FE 52 0115*      ld ix,table_active_sprites
       04          
04536A DD 35 00    0116*      dec (ix)
04536D C9          0117*      ret
04536E             0052   ; API includes
04536E             0053       include "src/asm/mos_api.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04536E             0002*  ; Title:	AGON MOS - API for user projects
04536E             0003*  ; Author:	Dean Belfield
04536E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04536E             0005*  ;			Added MOS error codes for return in HL
04536E             0006*  ; Created:	03/08/2022
04536E             0007*  ; Last Updated:	10/08/2023
04536E             0008*  ;
04536E             0009*  ; Modinfo:
04536E             0010*  ; 05/08/2022:	Added mos_feof
04536E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04536E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04536E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04536E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04536E             0015*  ; 13/10/2022:	Added mos_oscli
04536E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04536E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04536E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04536E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04536E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04536E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04536E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04536E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04536E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04536E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04536E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04536E             0027*  ; 03/08/2023:	Added mos_setkbvector
04536E             0028*  ; 10/08/2023:	Added mos_getkbmap
04536E             0029*  
04536E             0030*  ; VDP control (VDU 23, 0, n)
04536E             0031*  ;
04536E             0032*  vdp_gp:				EQU 80h
04536E             0033*  vdp_keycode:		EQU 81h
04536E             0034*  vdp_cursor:			EQU	82h
04536E             0035*  vdp_scrchar:		EQU	83h
04536E             0036*  vdp_scrpixel:		EQU	84h
04536E             0037*  vdp_audio:			EQU	85h
04536E             0038*  vdp_mode:			EQU	86h
04536E             0039*  vdp_rtc:			EQU	87h
04536E             0040*  vdp_keystate:		EQU	88h
04536E             0041*  vdp_logicalcoords:	EQU	C0h
04536E             0042*  vdp_terminalmode:	EQU	FFh
04536E             0043*  
04536E             0044*  ; MOS high level functions
04536E             0045*  ;
04536E             0046*  mos_getkey:			EQU	00h
04536E             0047*  mos_load:			EQU	01h
04536E             0048*  mos_save:			EQU	02h
04536E             0049*  mos_cd:				EQU	03h
04536E             0050*  mos_dir:			EQU	04h
04536E             0051*  mos_del:			EQU	05h
04536E             0052*  mos_ren:			EQU	06h
04536E             0053*  mos_mkdir:			EQU	07h
04536E             0054*  mos_sysvars:		EQU	08h
04536E             0055*  mos_editline:		EQU	09h
04536E             0056*  mos_fopen:			EQU	0Ah
04536E             0057*  mos_fclose:			EQU	0Bh
04536E             0058*  mos_fgetc:			EQU	0Ch
04536E             0059*  mos_fputc:			EQU	0Dh
04536E             0060*  mos_feof:			EQU	0Eh
04536E             0061*  mos_getError:		EQU	0Fh
04536E             0062*  mos_oscli:			EQU	10h
04536E             0063*  mos_copy:			EQU	11h
04536E             0064*  mos_getrtc:			EQU	12h
04536E             0065*  mos_setrtc:			EQU	13h
04536E             0066*  mos_setintvector:	EQU	14h
04536E             0067*  mos_uopen:			EQU	15h
04536E             0068*  mos_uclose:			EQU	16h
04536E             0069*  mos_ugetc:			EQU	17h
04536E             0070*  mos_uputc:			EQU	18h
04536E             0071*  mos_getfil:			EQU	19h
04536E             0072*  mos_fread:			EQU	1Ah
04536E             0073*  mos_fwrite:			EQU	1Bh
04536E             0074*  mos_flseek:			EQU	1Ch
04536E             0075*  mos_setkbvector:	EQU	1Dh
04536E             0076*  mos_getkbmap:		EQU	1Eh
04536E             0077*  
04536E             0078*  ; MOS program exit codes
04536E             0079*  ;
04536E             0080*  EXIT_OK:				EQU  0;	"OK",
04536E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04536E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04536E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04536E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04536E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04536E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04536E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04536E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04536E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04536E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04536E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04536E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04536E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04536E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04536E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04536E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04536E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04536E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04536E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04536E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04536E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04536E             0102*  ; FatFS file access functions
04536E             0103*  ;
04536E             0104*  ffs_fopen:			EQU	80h
04536E             0105*  ffs_fclose:			EQU	81h
04536E             0106*  ffs_fread:			EQU	82h
04536E             0107*  ffs_fwrite:			EQU	83h
04536E             0108*  ffs_flseek:			EQU	84h
04536E             0109*  ffs_ftruncate:		EQU	85h
04536E             0110*  ffs_fsync:			EQU	86h
04536E             0111*  ffs_fforward:		EQU	87h
04536E             0112*  ffs_fexpand:		EQU	88h
04536E             0113*  ffs_fgets:			EQU	89h
04536E             0114*  ffs_fputc:			EQU	8Ah
04536E             0115*  ffs_fputs:			EQU	8Bh
04536E             0116*  ffs_fprintf:		EQU	8Ch
04536E             0117*  ffs_ftell:			EQU	8Dh
04536E             0118*  ffs_feof:			EQU	8Eh
04536E             0119*  ffs_fsize:			EQU	8Fh
04536E             0120*  ffs_ferror:			EQU	90h
04536E             0121*  
04536E             0122*  ; FatFS directory access functions
04536E             0123*  ;
04536E             0124*  ffs_dopen:			EQU	91h
04536E             0125*  ffs_dclose:			EQU	92h
04536E             0126*  ffs_dread:			EQU	93h
04536E             0127*  ffs_dfindfirst:		EQU	94h
04536E             0128*  ffs_dfindnext:		EQU	95h
04536E             0129*  
04536E             0130*  ; FatFS file and directory management functions
04536E             0131*  ;
04536E             0132*  ffs_stat:			EQU	96h
04536E             0133*  ffs_unlink:			EQU	97h
04536E             0134*  ffs_rename:			EQU	98h
04536E             0135*  ffs_chmod:			EQU	99h
04536E             0136*  ffs_utime:			EQU	9Ah
04536E             0137*  ffs_mkdir:			EQU	9Bh
04536E             0138*  ffs_chdir:			EQU	9Ch
04536E             0139*  ffs_chdrive:		EQU	9Dh
04536E             0140*  ffs_getcwd:			EQU	9Eh
04536E             0141*  
04536E             0142*  ; FatFS volume management and system configuration functions
04536E             0143*  ;
04536E             0144*  ffs_mount:			EQU	9Fh
04536E             0145*  ffs_mkfs:			EQU	A0h
04536E             0146*  ffs_fdisk:			EQU	A1h
04536E             0147*  ffs_getfree:		EQU	A2h
04536E             0148*  ffs_getlabel:		EQU	A3h
04536E             0149*  ffs_setlabel:		EQU	A4h
04536E             0150*  ffs_setcp:			EQU	A5h
04536E             0151*  
04536E             0152*  ; File access modes
04536E             0153*  ;
04536E             0154*  fa_read:			EQU	01h
04536E             0155*  fa_write:			EQU	02h
04536E             0156*  fa_open_existing:	EQU	00h
04536E             0157*  fa_create_new:		EQU	04h
04536E             0158*  fa_create_always:	EQU	08h
04536E             0159*  fa_open_always:		EQU	10h
04536E             0160*  fa_open_append:		EQU	30h
04536E             0161*  
04536E             0162*  ; System variable indexes for api_sysvars
04536E             0163*  ; Index into _sysvars in globals.inc
04536E             0164*  ;
04536E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04536E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04536E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04536E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04536E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04536E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04536E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04536E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04536E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04536E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04536E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04536E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04536E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04536E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04536E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04536E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04536E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04536E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04536E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04536E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04536E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04536E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04536E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04536E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04536E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04536E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04536E             0191*  
04536E             0192*  ; Flags for the VPD protocol
04536E             0193*  ;
04536E             0194*  vdp_pflag_cursor:		EQU	00000001b
04536E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04536E             0196*  vdp_pflag_point:		EQU	00000100b
04536E             0197*  vdp_pflag_audio:		EQU	00001000b
04536E             0198*  vdp_pflag_mode:			EQU	00010000b
04536E             0199*  vdp_pflag_rtc:			EQU	00100000b
04536E             0200*  
04536E             0201*  ;
04536E             0202*  ; FatFS structures
04536E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04536E             0204*  ;
04536E             0205*  ; Object ID and allocation information (FFOBJID)
04536E             0206*  ;
04536E             0207*  ; Indexes into FFOBJID structure
04536E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04536E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04536E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04536E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04536E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04536E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04536E             0214*  ;
04536E             0215*  ; File object structure (FIL)
04536E             0216*  ;
04536E             0217*  ; Indexes into FIL structure
04536E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04536E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04536E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04536E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04536E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04536E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04536E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04536E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04536E             0226*  ;
04536E             0227*  ; Directory object structure (DIR)
04536E             0228*  ; Indexes into DIR structure
04536E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04536E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04536E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04536E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04536E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04536E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04536E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04536E             0236*  ;
04536E             0237*  ; File information structure (FILINFO)
04536E             0238*  ;
04536E             0239*  ; Indexes into FILINFO structure
04536E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04536E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04536E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04536E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04536E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04536E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04536E             0246*  ;
04536E             0247*  ; Macro for calling the API
04536E             0248*  ; Parameters:
04536E             0249*  ; - function: One of the function numbers listed above
04536E             0250*  ;
04536E             0251*  	MACRO	MOSCALL	function
04536E             0252*  			LD	A, function
04536E             0253*  			RST.LIL	08h
04536E             0254*  	ENDMACRO
04536E             0054       include "src/asm/functions.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04536E             0002*  ; Print a zero-terminated string
04536E             0003*  ; HL: Pointer to string
04536E             0004*  printString:
04536E C5          0005*  	PUSH	BC
04536F 01 00 00 00 0006*  	LD		BC,0
045373 3E 00       0007*  	LD 	 	A,0
045375 5B DF       0008*  	RST.LIL 18h
045377 C1          0009*  	POP		BC
045378 C9          0010*  	RET
045379             0011*  ; print a VDU sequence
045379             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
045379             0013*  sendVDUsequence:
045379 C5          0014*  	PUSH	BC
04537A 01 00 00 00 0015*  	LD		BC, 0
04537E 4E          0016*  	LD		C, (HL)
04537F 5B DF       0017*  	RST.LIL	18h
045381 C1          0018*  	POP		BC
045382 C9          0019*  	RET
045383             0020*  ; Print Newline sequence to VDP
045383             0021*  printNewLine:
045383 3E 0D       0022*  	LD	A, '\r'
045385 5B D7       0023*  	RST.LIL 10h
045387 3E 0A       0024*  	LD	A, '\n'
045389 5B D7       0025*  	RST.LIL 10h
04538B C9          0026*  	RET
04538C             0027*  ; Print a 24-bit HEX number
04538C             0028*  ; HLU: Number to print
04538C             0029*  printHex24:
04538C E5          0030*  	PUSH	HL
04538D 21 02 00 00 0031*  	LD		HL, 2
045391 39          0032*  	ADD		HL, SP
045392 7E          0033*  	LD		A, (HL)
045393 E1          0034*  	POP		HL
045394 CD 9E 53 04 0035*  	CALL	printHex8
045398             0036*  ; Print a 16-bit HEX number
045398             0037*  ; HL: Number to print
045398             0038*  printHex16:
045398 7C          0039*  	LD		A,H
045399 CD 9E 53 04 0040*  	CALL	printHex8
04539D 7D          0041*  	LD		A,L
04539E             0042*  ; Print an 8-bit HEX number
04539E             0043*  ; A: Number to print
04539E             0044*  printHex8:
04539E 4F          0045*  	LD		C,A
04539F 1F          0046*  	RRA
0453A0 1F          0047*  	RRA
0453A1 1F          0048*  	RRA
0453A2 1F          0049*  	RRA
0453A3 CD A8 53 04 0050*  	CALL	@F
0453A7 79          0051*  	LD		A,C
0453A8             0052*  @@:
0453A8 E6 0F       0053*  	AND		0Fh
0453AA C6 90       0054*  	ADD		A,90h
0453AC 27          0055*  	DAA
0453AD CE 40       0056*  	ADC		A,40h
0453AF 27          0057*  	DAA
0453B0 5B D7       0058*  	RST.LIL	10h
0453B2 C9          0059*  	RET
0453B3             0060*  
0453B3             0061*  ; Print a 0x HEX prefix
0453B3             0062*  DisplayHexPrefix:
0453B3 3E 30       0063*  	LD	A, '0'
0453B5 5B D7       0064*  	RST.LIL 10h
0453B7 3E 78       0065*  	LD	A, 'x'
0453B9 5B D7       0066*  	RST.LIL 10h
0453BB C9          0067*  	RET
0453BC             0068*  
0453BC             0069*  
0453BC             0070*  ; Prints the right justified decimal value in HL without leading zeroes
0453BC             0071*  ; HL : Value to print
0453BC             0072*  printDec:
0453BC 11 E0 53 04 0073*  	LD	 DE, _printDecBuffer
0453C0 CD E9 53 04 0074*  	CALL Num2String
0453C4             0075*  ; BEGIN MY CODE
0453C4             0076*  ; replace leading zeroes with spaces
0453C4 21 E0 53 04 0077*      LD	 HL, _printDecBuffer
0453C8 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0453CA             0079*  @loop:
0453CA 7E          0080*      LD	 A, (HL)
0453CB FE 30       0081*      CP	 '0'
0453CD C2 DB 53 04 0082*      JP	 NZ, @done
0453D1 3E 20       0083*      LD   A, ' '
0453D3 77          0084*      LD	 (HL), A
0453D4 23          0085*      INC	 HL
0453D5 CD B7 57 04 0086*      CALL vdu_cursor_forward
0453D9 10 EF       0087*      DJNZ @loop
0453DB             0088*  @done:
0453DB             0089*  ; END MY CODE
0453DB             0090*  	; LD	 HL, _printDecBuffer
0453DB CD 6E 53 04 0091*  	CALL printString
0453DF C9          0092*  	RET
0453E0 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0453E9             0094*  
0453E9             0095*  ; This routine converts the value from HL into it's ASCII representation,
0453E9             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0453E9             0097*  ; so it will allways be 8 characters length
0453E9             0098*  ; HL : Value to convert to string
0453E9             0099*  ; DE : pointer to buffer, at least 8 byte + 0
0453E9             0100*  Num2String:
0453E9 01 80 69 67 0101*  	LD	 BC,-10000000
0453ED CD 20 54 04 0102*  	CALL OneDigit
0453F1 01 C0 BD F0 0103*  	LD	 BC,-1000000
0453F5 CD 20 54 04 0104*  	CALL OneDigit
0453F9 01 60 79 FE 0105*  	LD	 BC,-100000
0453FD CD 20 54 04 0106*  	CALL OneDigit
045401 01 F0 D8 FF 0107*  	LD   BC,-10000
045405 CD 20 54 04 0108*  	CALL OneDigit
045409 01 18 FC FF 0109*  	LD   BC,-1000
04540D CD 20 54 04 0110*  	CALL OneDigit
045411 01 9C FF FF 0111*  	LD   BC,-100
045415 CD 20 54 04 0112*  	CALL OneDigit
045419 0E F6       0113*  	LD   C,-10
04541B CD 20 54 04 0114*  	CALL OneDigit
04541F 48          0115*  	LD   C,B
045420             0116*  OneDigit:
045420 3E 2F       0117*  	LD   A,'0'-1
045422             0118*  DivideMe:
045422 3C          0119*  	INC  A
045423 09          0120*  	ADD  HL,BC
045424 38 FC       0121*  	JR   C,DivideMe
045426 ED 42       0122*  	SBC  HL,BC
045428 12          0123*  	LD   (DE),A
045429 13          0124*  	INC  DE
04542A C9          0125*  	RET
04542B             0126*  
04542B             0127*  
04542B             0128*  ; #### new functions added by Brandon R. Gates ####
04542B             0129*  
04542B             0130*  ; print the binary representation of the 8-bit value in a
04542B             0131*  ; destroys a, hl, bc
04542B             0132*  printBin8:
04542B 06 08       0133*      ld b,8      ; loop counter for 8 bits
04542D 21 48 54 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
045431             0135*                  ; (which will be the high bit of the value in a)
045431             0136*  @loop:
045431 07          0137*      rlca ; put the next highest bit into carry
045432 38 04       0138*      jr c,@one
045434 36 30       0139*      ld (hl),'0'
045436 18 02       0140*      jr @next_bit
045438             0141*  @one:
045438 36 31       0142*      ld (hl),'1'
04543A             0143*  @next_bit:
04543A 23          0144*      inc hl
04543B 10 F4       0145*      djnz @loop
04543D             0146*  ; print it
04543D 21 48 54 04 0147*  	ld hl,@cmd
045441 01 08 00 00 0148*  	ld bc,@end-@cmd
045445 5B DF       0149*  	rst.lil $18
045447 C9          0150*  	ret
045448             0151*  @cmd: ds 8 ; eight bytes for eight bits
045450             0152*  @end:
045450             0153*  
045450             0154*  ; print the binary representation of the 8-bit value in a
045450             0155*  ; in reverse order (lsb first)
045450             0156*  ; destroys a, hl, bc
045450             0157*  printBin8Rev:
045450 06 08       0158*      ld b,8      ; loop counter for 8 bits
045452 21 6D 54 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
045456             0160*                  ; (which will be the high bit of the value in a)
045456             0161*  @loop:
045456 0F          0162*      rrca ; put the next lowest bit into carry
045457 38 04       0163*      jr c,@one
045459 36 30       0164*      ld (hl),'0'
04545B 18 02       0165*      jr @next_bit
04545D             0166*  @one:
04545D 36 31       0167*      ld (hl),'1'
04545F             0168*  @next_bit:
04545F 23          0169*      inc hl
045460 10 F4       0170*      djnz @loop
045462             0171*  ; print it
045462 21 6D 54 04 0172*  	ld hl,@cmd
045466 01 08 00 00 0173*  	ld bc,@end-@cmd
04546A 5B DF       0174*  	rst.lil $18
04546C C9          0175*  	ret
04546D             0176*  @cmd: ds 8 ; eight bytes for eight bits
045475             0177*  @end:
045475             0178*  
045475             0179*  ; print registers to screen in hexidecimal format
045475             0180*  ; inputs: none
045475             0181*  ; outputs: values of every register printed to screen
045475             0182*  ;    values of each register in global scratch memory
045475             0183*  ; destroys: nothing
045475             0184*  stepRegistersHex:
045475             0185*  ; store everything in scratch
045475 22 74 56 04 0186*      ld (uhl),hl
045479 ED 43 77 56 0187*      ld (ubc),bc
       04          
04547E ED 53 7A 56 0188*      ld (ude),de
       04          
045483 DD 22 7D 56 0189*      ld (uix),ix
       04          
045488 FD 22 80 56 0190*      ld (uiy),iy
       04          
04548D F5          0191*      push af ; fml
04548E E1          0192*      pop hl  ; thanks, zilog
04548F 22 71 56 04 0193*      ld (uaf),hl
045493 F5          0194*      push af ; dammit
045494             0195*  
045494             0196*  ; home the cursor
045494 CD FE 58 04 0197*      call vdu_home_cursor
045498             0198*  
045498             0199*  ; print each register
045498 21 FD 55 04 0200*      ld hl,str_afu
04549C CD 6E 53 04 0201*      call printString
0454A0 2A 71 56 04 0202*      ld hl,(uaf)
0454A4 CD 8C 53 04 0203*      call printHex24
0454A8 CD 83 53 04 0204*      call printNewLine
0454AC             0205*  
0454AC 21 01 56 04 0206*      ld hl,str_hlu
0454B0 CD 6E 53 04 0207*      call printString
0454B4 2A 74 56 04 0208*      ld hl,(uhl)
0454B8 CD 8C 53 04 0209*      call printHex24
0454BC CD 83 53 04 0210*      call printNewLine
0454C0             0211*  
0454C0 21 05 56 04 0212*      ld hl,str_bcu
0454C4 CD 6E 53 04 0213*      call printString
0454C8 2A 77 56 04 0214*      ld hl,(ubc)
0454CC CD 8C 53 04 0215*      call printHex24
0454D0 CD 83 53 04 0216*      call printNewLine
0454D4             0217*  
0454D4 21 09 56 04 0218*      ld hl,str_deu
0454D8 CD 6E 53 04 0219*      call printString
0454DC 2A 7A 56 04 0220*      ld hl,(ude)
0454E0 CD 8C 53 04 0221*      call printHex24
0454E4 CD 83 53 04 0222*      call printNewLine
0454E8             0223*  
0454E8 21 0D 56 04 0224*      ld hl,str_ixu
0454EC CD 6E 53 04 0225*      call printString
0454F0 2A 7D 56 04 0226*      ld hl,(uix)
0454F4 CD 8C 53 04 0227*      call printHex24
0454F8 CD 83 53 04 0228*      call printNewLine
0454FC             0229*  
0454FC 21 11 56 04 0230*      ld hl,str_iyu
045500 CD 6E 53 04 0231*      call printString
045504 2A 80 56 04 0232*      ld hl,(uiy)
045508 CD 8C 53 04 0233*      call printHex24
04550C CD 83 53 04 0234*      call printNewLine
045510             0235*  
045510             0236*      ; call vdu_vblank
045510             0237*  
045510 CD 83 53 04 0238*      call printNewLine
045514             0239*  
045514             0240*  ; check for right shift key and quit if pressed
045514             0241*  	MOSCALL mos_getkbmap
045514 3E 1E       0001*M 			LD	A, function
045516 5B CF       0002*M 			RST.LIL	08h
045518             0242*  @stayhere:
045518             0243*  ; 7 RightShift
045518 DD CB 00 76 0244*      bit 6,(ix+0)
04551C 20 02       0245*      jr nz,@RightShift
04551E 18 F8       0246*      jr @stayhere
045520             0247*  @RightShift:
045520 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
045524 3E 80       0249*      ld a,%10000000
045526 CD F2 6D 04 0250*      call multiPurposeDelay
04552A             0251*  
04552A             0252*  ; restore everything
04552A 2A 74 56 04 0253*      ld hl, (uhl)
04552E ED 4B 77 56 0254*      ld bc, (ubc)
       04          
045533 ED 5B 7A 56 0255*      ld de, (ude)
       04          
045538 DD 2A 7D 56 0256*      ld ix, (uix)
       04          
04553D FD 2A 80 56 0257*      ld iy, (uiy)
       04          
045542 F1          0258*      pop af
045543             0259*  ; all done
045543 C9          0260*      ret
045544             0261*  
045544             0262*  ; print registers to screen in hexidecimal format
045544             0263*  ; inputs: none
045544             0264*  ; outputs: values of every register printed to screen
045544             0265*  ;    values of each register in global scratch memory
045544             0266*  ; destroys: nothing
045544             0267*  dumpRegistersHex:
045544             0268*  ; store everything in scratch
045544 22 74 56 04 0269*      ld (uhl),hl
045548 ED 43 77 56 0270*      ld (ubc),bc
       04          
04554D ED 53 7A 56 0271*      ld (ude),de
       04          
045552 DD 22 7D 56 0272*      ld (uix),ix
       04          
045557 FD 22 80 56 0273*      ld (uiy),iy
       04          
04555C F5          0274*      push af ; fml
04555D E1          0275*      pop hl  ; thanks, zilog
04555E 22 71 56 04 0276*      ld (uaf),hl
045562 F5          0277*      push af ; dammit
045563             0278*  
045563             0279*  ; home the cursor
045563 CD FE 58 04 0280*      call vdu_home_cursor
045567             0281*  
045567             0282*  ; print each register
045567 21 FD 55 04 0283*      ld hl,str_afu
04556B CD 6E 53 04 0284*      call printString
04556F 2A 71 56 04 0285*      ld hl,(uaf)
045573 CD 8C 53 04 0286*      call printHex24
045577 CD 83 53 04 0287*      call printNewLine
04557B             0288*  
04557B 21 01 56 04 0289*      ld hl,str_hlu
04557F CD 6E 53 04 0290*      call printString
045583 2A 74 56 04 0291*      ld hl,(uhl)
045587 CD 8C 53 04 0292*      call printHex24
04558B CD 83 53 04 0293*      call printNewLine
04558F             0294*  
04558F 21 05 56 04 0295*      ld hl,str_bcu
045593 CD 6E 53 04 0296*      call printString
045597 2A 77 56 04 0297*      ld hl,(ubc)
04559B CD 8C 53 04 0298*      call printHex24
04559F CD 83 53 04 0299*      call printNewLine
0455A3             0300*  
0455A3 21 09 56 04 0301*      ld hl,str_deu
0455A7 CD 6E 53 04 0302*      call printString
0455AB 2A 7A 56 04 0303*      ld hl,(ude)
0455AF CD 8C 53 04 0304*      call printHex24
0455B3 CD 83 53 04 0305*      call printNewLine
0455B7             0306*  
0455B7 21 0D 56 04 0307*      ld hl,str_ixu
0455BB CD 6E 53 04 0308*      call printString
0455BF 2A 7D 56 04 0309*      ld hl,(uix)
0455C3 CD 8C 53 04 0310*      call printHex24
0455C7 CD 83 53 04 0311*      call printNewLine
0455CB             0312*  
0455CB 21 11 56 04 0313*      ld hl,str_iyu
0455CF CD 6E 53 04 0314*      call printString
0455D3 2A 80 56 04 0315*      ld hl,(uiy)
0455D7 CD 8C 53 04 0316*      call printHex24
0455DB CD 83 53 04 0317*      call printNewLine
0455DF             0318*  
0455DF             0319*      ; call vdu_vblank
0455DF             0320*  
0455DF CD 83 53 04 0321*      call printNewLine
0455E3             0322*  ; restore everything
0455E3 2A 74 56 04 0323*      ld hl, (uhl)
0455E7 ED 4B 77 56 0324*      ld bc, (ubc)
       04          
0455EC ED 5B 7A 56 0325*      ld de, (ude)
       04          
0455F1 DD 2A 7D 56 0326*      ld ix, (uix)
       04          
0455F6 FD 2A 80 56 0327*      ld iy, (uiy)
       04          
0455FB F1          0328*      pop af
0455FC             0329*  ; all done
0455FC C9          0330*      ret
0455FD             0331*  
0455FD 61 66 3D 00 0332*  str_afu: db "af=",0
045601 68 6C 3D 00 0333*  str_hlu: db "hl=",0
045605 62 63 3D 00 0334*  str_bcu: db "bc=",0
045609 64 65 3D 00 0335*  str_deu: db "de=",0
04560D 69 78 3D 00 0336*  str_ixu: db "ix=",0
045611 69 79 3D 00 0337*  str_iyu: db "iy=",0
045615             0338*  
045615             0339*  ; print udeuhl to screen in hexidecimal format
045615             0340*  ; inputs: none
045615             0341*  ; outputs: concatenated hexidecimal udeuhl
045615             0342*  ; destroys: nothing
045615             0343*  dumpUDEUHLHex:
045615             0344*  ; store everything in scratch
045615 22 74 56 04 0345*      ld (uhl),hl
045619 ED 43 77 56 0346*      ld (ubc),bc
       04          
04561E ED 53 7A 56 0347*      ld (ude),de
       04          
045623 DD 22 7D 56 0348*      ld (uix),ix
       04          
045628 FD 22 80 56 0349*      ld (uiy),iy
       04          
04562D F5          0350*      push af
04562E             0351*  
04562E             0352*  ; print each register
04562E             0353*  
04562E 21 68 56 04 0354*      ld hl,str_udeuhl
045632 CD 6E 53 04 0355*      call printString
045636 2A 7A 56 04 0356*      ld hl,(ude)
04563A CD 8C 53 04 0357*      call printHex24
04563E 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
045640 5B D7       0359*  	rst.lil 10h
045642 2A 74 56 04 0360*      ld hl,(uhl)
045646 CD 8C 53 04 0361*      call printHex24
04564A CD 83 53 04 0362*      call printNewLine
04564E             0363*  
04564E             0364*  ; restore everything
04564E 2A 74 56 04 0365*      ld hl, (uhl)
045652 ED 4B 77 56 0366*      ld bc, (ubc)
       04          
045657 ED 5B 7A 56 0367*      ld de, (ude)
       04          
04565C DD 2A 7D 56 0368*      ld ix, (uix)
       04          
045661 FD 2A 80 56 0369*      ld iy, (uiy)
       04          
045666 F1          0370*      pop af
045667             0371*  ; all done
045667 C9          0372*      ret
045668             0373*  
045668 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
045671             0375*  
045671             0376*  ; global scratch memory for registers
045671 00 00 00    0377*  uaf: dl 0
045674 00 00 00    0378*  uhl: dl 0
045677 00 00 00    0379*  ubc: dl 0
04567A 00 00 00    0380*  ude: dl 0
04567D 00 00 00    0381*  uix: dl 0
045680 00 00 00    0382*  uiy: dl 0
045683 00 00 00    0383*  usp: dl 0
045686 00 00 00    0384*  upc: dl 0
045689             0385*  
045689             0386*  ; inputs: whatever is in the flags register
045689             0387*  ; outputs: binary representation of flags
045689             0388*  ;          with a header so we know which is what
045689             0389*  ; destroys: nothing
045689             0390*  ; preserves: everything
045689             0391*  dumpFlags:
045689             0392*  ; first we curse zilog for not giving direct access to flags
045689 F5          0393*      push af ; this is so we can send it back unharmed
04568A F5          0394*      push af ; this is so we can pop it to hl
04568B             0395*  ; store everything in scratch
04568B 22 74 56 04 0396*      ld (uhl),hl
04568F ED 43 77 56 0397*      ld (ubc),bc
       04          
045694 ED 53 7A 56 0398*      ld (ude),de
       04          
045699 DD 22 7D 56 0399*      ld (uix),ix
       04          
04569E FD 22 80 56 0400*      ld (uiy),iy
       04          
0456A3             0401*  ; next we print the header
0456A3 21 CF 56 04 0402*      ld hl,@header
0456A7 CD 6E 53 04 0403*      call printString
0456AB E1          0404*      pop hl ; flags are now in l
0456AC 7D          0405*      ld a,l ; flags are now in a
0456AD CD 2B 54 04 0406*      call printBin8
0456B1 CD 83 53 04 0407*  	call printNewLine
0456B5             0408*  ; restore everything
0456B5 2A 74 56 04 0409*      ld hl, (uhl)
0456B9 ED 4B 77 56 0410*      ld bc, (ubc)
       04          
0456BE ED 5B 7A 56 0411*      ld de, (ude)
       04          
0456C3 DD 2A 7D 56 0412*      ld ix, (uix)
       04          
0456C8 FD 2A 80 56 0413*      ld iy, (uiy)
       04          
0456CD F1          0414*      pop af ; send her home the way she came
0456CE C9          0415*      ret
0456CF             0416*  ; Bit 7 (S): Sign flag
0456CF             0417*  ; Bit 6 (Z): Zero flag
0456CF             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0456CF             0419*  ; Bit 4 (H): Half Carry flag
0456CF             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0456CF             0421*  ; Bit 2 (PV): Parity/Overflow flag
0456CF             0422*  ; Bit 1 (N): Subtract flag
0456CF             0423*  ; Bit 0 (C): Carry flag
0456CF 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0456DA             0425*  
0456DA             0426*  ; set all the bits in the flag register
0456DA             0427*  ; more of an academic exercise than anything useful
0456DA             0428*  ; inputs; none
0456DA             0429*  ; outputs; a=0,f=255
0456DA             0430*  ; destroys: flags, hl
0456DA             0431*  ; preserves: a, because why not
0456DA             0432*  setAllFlags:
0456DA 21 FF 00 00 0433*      ld hl,255
0456DE 67          0434*      ld h,a ; four cycles to preserve a is cheap
0456DF E5          0435*      push hl
0456E0 F1          0436*      pop af
0456E1 C9          0437*      ret
0456E2             0438*  
0456E2             0439*  ; reset all the bits in the flag register
0456E2             0440*  ; unlike its inverse counterpart, this may actually be useful
0456E2             0441*  ; inputs; none
0456E2             0442*  ; outputs; a=0,f=0
0456E2             0443*  ; destroys: flags, hl
0456E2             0444*  ; preserves: a, because why not
0456E2             0445*  resetAllFlags:
0456E2 21 00 00 00 0446*      ld hl,0
0456E6 67          0447*      ld h,a ; four cycles to preserve a is cheap
0456E7 E5          0448*      push hl
0456E8 F1          0449*      pop af
0456E9 C9          0450*      ret
0456EA             0451*  
0456EA             0452*  ; wait until user presses a key
0456EA             0453*  ; inputs: none
0456EA             0454*  ; outputs: none
0456EA             0455*  ; destroys: af,ix
0456EA             0456*  waitKeypress:
0456EA             0457*      MOSCALL mos_sysvars
0456EA 3E 08       0001*M 			LD	A, function
0456EC 5B CF       0002*M 			RST.LIL	08h
0456EE AF          0458*      xor a ; zero out any prior keypresses
0456EF DD 77 05    0459*      ld (ix+sysvar_keyascii),a
0456F2             0460*  @loop:
0456F2 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
0456F5 A7          0462*      and a
0456F6 C0          0463*      ret nz
0456F7 18 F9       0464*      jr @loop
0456F9             0465*  
0456F9             0466*  
0456F9             0467*  ; print bytes from an address to the screen in hexidecimal format
0456F9             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0456F9             0469*  ; outputs: values of each byte printed to screen separated by spaces
0456F9             0470*  ; destroys: nothing
0456F9             0471*  dumpMemoryHex:
0456F9             0472*  ; save all registers to the stack
0456F9 F5          0473*      push af
0456FA C5          0474*      push bc
0456FB D5          0475*      push de
0456FC E5          0476*      push hl
0456FD DD E5       0477*      push ix
0456FF FD E5       0478*      push iy
045701             0479*  
045701             0480*  ; set b to be our loop counter
045701 47          0481*      ld b,a
045702             0482*  @loop:
045702             0483*  ; print the byte
045702 7E          0484*      ld a,(hl)
045703 CD 9E 53 04 0485*      call printHex8
045707             0486*  ; print a space
045707 3E 20       0487*      ld a,' '
045709 5B D7       0488*      rst.lil 10h
04570B 23          0489*      inc hl
04570C 10 F4       0490*      djnz @loop
04570E CD 83 53 04 0491*      call printNewLine
045712             0492*  
045712             0493*  ; restore everything
045712 FD E1       0494*      pop iy
045714 DD E1       0495*      pop ix
045716 E1          0496*      pop hl
045717 D1          0497*      pop de
045718 C1          0498*      pop bc
045719 F1          0499*      pop af
04571A             0500*  ; all done
04571A C9          0501*      ret
04571B             0502*  
04571B             0503*  
04571B             0504*  ; print bytes from an address to the screen in binary format
04571B             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04571B             0506*  ; outputs: values of each byte printed to screen separated by spaces
04571B             0507*  ; destroys: nothing
04571B             0508*  dumpMemoryBin:
04571B             0509*  ; save all registers to the stack
04571B F5          0510*      push af
04571C C5          0511*      push bc
04571D D5          0512*      push de
04571E E5          0513*      push hl
04571F DD E5       0514*      push ix
045721 FD E5       0515*      push iy
045723             0516*  
045723             0517*  ; set b to be our loop counter
045723 47          0518*      ld b,a
045724             0519*  @loop:
045724             0520*  ; print the byte
045724 7E          0521*      ld a,(hl)
045725 E5          0522*      push hl
045726 C5          0523*      push bc
045727 CD 2B 54 04 0524*      call printBin8
04572B C1          0525*      pop bc
04572C             0526*  ; print a space
04572C 3E 20       0527*      ld a,' '
04572E 5B D7       0528*      rst.lil 10h
045730 E1          0529*      pop hl
045731 23          0530*      inc hl
045732 10 F0       0531*      djnz @loop
045734 CD 83 53 04 0532*      call printNewLine
045738             0533*  
045738             0534*  ; restore everything
045738 FD E1       0535*      pop iy
04573A DD E1       0536*      pop ix
04573C E1          0537*      pop hl
04573D D1          0538*      pop de
04573E C1          0539*      pop bc
04573F F1          0540*      pop af
045740             0541*  ; all done
045740 C9          0542*      ret
045741             0543*  
045741             0544*  ; print bytes from an address to the screen in binary format
045741             0545*  ; with the bits of each byte in reverse order (lsb first)
045741             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
045741             0547*  ; outputs: values of each byte printed to screen separated by spaces
045741             0548*  ; destroys: nothing
045741             0549*  dumpMemoryBinRev:
045741             0550*  ; save all registers to the stack
045741 F5          0551*      push af
045742 C5          0552*      push bc
045743 D5          0553*      push de
045744 E5          0554*      push hl
045745 DD E5       0555*      push ix
045747 FD E5       0556*      push iy
045749             0557*  
045749             0558*  ; set b to be our loop counter
045749 47          0559*      ld b,a
04574A             0560*  @loop:
04574A             0561*  ; print the byte
04574A 7E          0562*      ld a,(hl)
04574B E5          0563*      push hl
04574C C5          0564*      push bc
04574D CD 50 54 04 0565*      call printBin8Rev
045751 C1          0566*      pop bc
045752             0567*  ; print a space
045752 3E 20       0568*      ld a,' '
045754 5B D7       0569*      rst.lil 10h
045756 E1          0570*      pop hl
045757 23          0571*      inc hl
045758 10 F0       0572*      djnz @loop
04575A CD 83 53 04 0573*      call printNewLine
04575E             0574*  
04575E             0575*  ; restore everything
04575E FD E1       0576*      pop iy
045760 DD E1       0577*      pop ix
045762 E1          0578*      pop hl
045763 D1          0579*      pop de
045764 C1          0580*      pop bc
045765 F1          0581*      pop af
045766             0582*  ; all done
045766 C9          0583*      ret
045767             0055       include "src/asm/vdu.inc"
045767             0001*  ; The following is a high-level list of the VDU sequences that are supported:
045767             0002*  ; VDU 0: Null (no operation)
045767             0003*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
045767             0004*  ; VDU 2: Enable “printer” §§
045767             0005*  ; VDU 3: Disable “printer” §§
045767             0006*  ; VDU 4: Write text at text cursor
045767             0007*  ; VDU 5: Write text at graphics cursor
045767             0008*  ; VDU 6: Enable screen (opposite of VDU 21) §§
045767             0009*  ; VDU 7: Make a short beep (BEL)
045767             0010*  ; VDU 8: Move cursor back one character
045767             0011*  ; VDU 9: Move cursor forward one character
045767             0012*  ; VDU 10: Move cursor down one line
045767             0013*  ; VDU 11: Move cursor up one line
045767             0014*  ; VDU 12: Clear text area (CLS)
045767             0015*  ; VDU 13: Carriage return
045767             0016*  ; VDU 14: Page mode On *
045767             0017*  ; VDU 15: Page mode Off *
045767             0018*  ; VDU 16: Clear graphics area (CLG)
045767             0019*  ; VDU 17, colour: Define text colour (COLOUR)
045767             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
045767             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
045767             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
045767             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) §§
045767             0024*  ; VDU 22, n: Select screen mode (MODE n)
045767             0025*  ; VDU 23, n: Re-program display character / System Commands
045767             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
045767             0027*  ; VDU 25, mode, x; y;: PLOT command
045767             0028*  ; VDU 26: Reset graphics and text viewports **
045767             0029*  ; VDU 27, char: Output character to screen §
045767             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
045767             0031*  ; VDU 29, x; y;: Set graphics origin
045767             0032*  ; VDU 30: Home cursor
045767             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
045767             0034*  ; VDU 127: Backspace
045767             0035*  
045767             0036*  ; VDU 0: Null (no operation)
045767             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
045767             0038*  ;     This may be useful for padding out a VDU command sequence,
045767             0039*  ;     or for inserting a placeholder for a command that will be added later.
045767             0040*  ; inputs: none
045767             0041*  ; outputs: an empty byte somewhere in VDU
045767             0042*  ; destroys: a
045767             0043*  vdu_null:
045767 AF          0044*      xor a
045768 5B D7       0045*  	rst.lil $10
04576A C9          0046*  	ret
04576B             0047*  
04576B             0048*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
04576B             0049*  ;     Ensures that the next character received by the VDP is sent through to
04576B             0050*  ;     the “printer”, and not to the screen. This is useful for sending control
04576B             0051*  ;     codes to the “printer”, or for sending data to the “printer” that is not
04576B             0052*  ;     intended to be displayed on the screen. It allows characters that would
04576B             0053*  ;     not otherwise normally be sent through to the “printer” to be sent.
04576B             0054*  ;     If the “printer” has not been enabled then this command will just discard
04576B             0055*  ;     the next byte sent to the VDP.
04576B             0056*  ; inputs: a is the ascii code of the character to send
04576B             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
04576B             0058*  ; outputs: a character on the serial terminal connected to the USB port
04576B             0059*  ;           and the same character on the screen at the current text cursor location
04576B             0060*  ; QUESTION: does it also advance the text cursor?
04576B             0061*  ; destroys: hl, bc
04576B             0062*  vdu_char_to_printer:
04576B 32 7B 57 04 0063*  	ld (@arg),a
04576F 21 7A 57 04 0064*  	ld hl,@cmd
045773 01 02 00 00 0065*  	ld bc,@end-@cmd
045777 5B DF       0066*  	rst.lil $18
045779 C9          0067*  	ret
04577A 01          0068*  @cmd: db 1
04577B 00          0069*  @arg: db 0
04577C             0070*  @end:
04577C             0071*  
04577C             0072*  ; VDU 2: Enable “printer” §§
04577C             0073*  ;     Enables the “printer”.
04577C             0074*  ;     In the context of the Agon platform, the “printer” is a serial
04577C             0075*  ;     terminal that is connected to the VDP’s USB port. Typically
04577C             0076*  ;     this port is used for power, but it can also be used to send and
04577C             0077*  ;     receive data to and from the VDP.
04577C             0078*  ;     When the “printer” is enabled, the VDP will send characters it receives
04577C             0079*  ;     to the “printer” as well as to the screen. It will additionally send
04577C             0080*  ;     through control codes 8-13. To send other control codes to the “printer”,
04577C             0081*  ;     use the VDU 1 command.
04577C             0082*  ;     The VDP will not send through other control codes to the printer,
04577C             0083*  ;     and will will not send through data it receives as part of other commands.
04577C             0084*  vdu_enable_printer:
04577C 3E 02       0085*      ld a,2
04577E 5B D7       0086*  	rst.lil $10
045780 C9          0087*  	ret
045781             0088*  
045781             0089*  ; VDU 3: Disable “printer” §§
045781             0090*  ; inputs: none
045781             0091*  ; outputs: a USB port bereft of communication with the VDP
045781             0092*  ; destroys: a
045781             0093*  vdu_disable_printer:
045781 3E 03       0094*      ld a,3
045783 5B D7       0095*  	rst.lil $10
045785 C9          0096*  	ret
045786             0097*  
045786             0098*  ; VDU 4: Write text at text cursor
045786             0099*  ;     This causes text to be written at the current text cursor position.
045786             0100*  ;     This is the default mode for text display.
045786             0101*  ;     Text is written using the current text foreground and background colours.
045786             0102*  ; inputs: a is the character to write to the screen
045786             0103*  ; prerequisites: the text cursor at the intended position on screen
045786             0104*  ; outputs: prints the character and moves text cursor right one position
045786             0105*  ; destroys: a, hl, bc
045786             0106*  vdu_char_to_text_cursor:
045786 32 96 57 04 0107*  	ld (@arg),a
04578A 21 95 57 04 0108*  	ld hl,@cmd
04578E 01 02 00 00 0109*  	ld bc,@end-@cmd
045792 5B DF       0110*  	rst.lil $18
045794 C9          0111*  	ret
045795 04          0112*  @cmd: db 4
045796 00          0113*  @arg: db 0
045797             0114*  @end:
045797             0115*  
045797             0116*  ; VDU 5: Write text at graphics cursor
045797             0117*  ;     This causes text to be written at the current graphics cursor position.
045797             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
045797             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
045797             0120*  ;     or for positioning text at a specific location on the screen.
045797             0121*  ;     Characters are plotted using the current graphics foreground colour,
045797             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
045797             0123*  ;     The character background is transparent, and will not overwrite any
045797             0124*  ;     graphics that are already present at the character’s location.
045797             0125*  ;     The exception to this is VDU 27, the “delete” character, which backspaces
045797             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
045797             0127*  ;     graphics background colour.
045797             0128*  ; inputs: a is the character to write to the screen
045797             0129*  ; prerequisites: the graphics cursor at the intended position on screen
045797             0130*  ; outputs: see the name of the function
045797             0131*  ; destroys: a, hl, bc
045797             0132*  vdu_char_to_gfx_cursor:
045797 32 A7 57 04 0133*  	ld (@arg),a
04579B 21 A6 57 04 0134*  	ld hl,@cmd
04579F 01 02 00 00 0135*  	ld bc,@end-@cmd
0457A3 5B DF       0136*  	rst.lil $18
0457A5 C9          0137*  	ret
0457A6 05          0138*  @cmd: db 5
0457A7 00          0139*  @arg: db 0
0457A8             0140*  @end:
0457A8             0141*  
0457A8             0142*  ; VDU 6: Enable screen (opposite of VDU 21) §§
0457A8             0143*  ;     This enables the screen, and re-enables VDU command processing,
0457A8             0144*  ;     reversing the effect of VDU 21.
0457A8             0145*  ; inputs: none
0457A8             0146*  ; outputs: a functioning screen and VDU
0457A8             0147*  ; destroys: a
0457A8             0148*  vdu_enable_screen:
0457A8 3E 06       0149*      ld a,6
0457AA 5B D7       0150*  	rst.lil $10
0457AC C9          0151*  	ret
0457AD             0152*  
0457AD             0153*  ; PASSES
0457AD             0154*  ; VDU 7: Make a short beep (BEL)
0457AD             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
0457AD             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
0457AD             0157*  ; inputs: none
0457AD             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
0457AD             0159*  ; destroys: a
0457AD             0160*  vdu_beep:
0457AD 3E 07       0161*      ld a,7
0457AF 5B D7       0162*  	rst.lil $10
0457B1 C9          0163*  	ret
0457B2             0164*  
0457B2             0165*  ; VDU 8: Move cursor back one character
0457B2             0166*  ;     Moves the text cursor one character in the negative “X” direction.
0457B2             0167*  ;     By default, when at the start of a line it will move to the end of
0457B2             0168*  ;     the previous line (as defined by the current text viewport).
0457B2             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
0457B2             0170*  ;     The cursor remains constrained to the current text viewport.
0457B2             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
0457B2             0172*  ;     The cursor is just moved left by one character width.
0457B2             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
0457B2             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
0457B2             0175*  ;     support adjusting the direction of the cursor’s X axis, so this command
0457B2             0176*  ;     will move the cursor to the left. This is likely to change in the future.
0457B2             0177*  vdu_cursor_back:
0457B2 3E 08       0178*      ld a,8
0457B4 5B D7       0179*  	rst.lil $10
0457B6 C9          0180*  	ret
0457B7             0181*  
0457B7             0182*  ; VDU 9: Move cursor forward one character
0457B7             0183*  vdu_cursor_forward:
0457B7 3E 09       0184*      ld a,9
0457B9 5B D7       0185*  	rst.lil $10
0457BB C9          0186*  	ret
0457BC             0187*  
0457BC             0188*  ; VDU 10: Move cursor down one line
0457BC             0189*  vdu_cursor_down:
0457BC 3E 0A       0190*      ld a,10
0457BE 5B D7       0191*  	rst.lil $10
0457C0 C9          0192*  	ret
0457C1             0193*  
0457C1             0194*  ; VDU 11: Move cursor up one line
0457C1             0195*  vdu_cursor_up:
0457C1 3E 0B       0196*      ld a,11
0457C3 5B D7       0197*  	rst.lil $10
0457C5 C9          0198*  	ret
0457C6             0199*  
0457C6             0200*  ; VDU 12: Clear text area (CLS)
0457C6             0201*  vdu_cls:
0457C6 3E 0C       0202*      ld a,12
0457C8 5B D7       0203*  	rst.lil $10
0457CA C9          0204*  	ret
0457CB             0205*  
0457CB             0206*  ; VDU 13: Carriage return
0457CB             0207*  vdu_cr:
0457CB 3E 0D       0208*      ld a,13
0457CD 5B D7       0209*  	rst.lil $10
0457CF C9          0210*  	ret
0457D0             0211*  
0457D0             0212*  ; VDU 14: Page mode On *
0457D0             0213*  vdu_page_on:
0457D0 3E 0E       0214*      ld a,14
0457D2 5B D7       0215*  	rst.lil $10
0457D4 C9          0216*  	ret
0457D5             0217*  
0457D5             0218*  ; VDU 15: Page mode Off *
0457D5             0219*  vdu_page_off:
0457D5 3E 0F       0220*      ld a,15
0457D7 5B D7       0221*  	rst.lil $10
0457D9 C9          0222*  	ret
0457DA             0223*  
0457DA             0224*  ; VDU 16: Clear graphics area (CLG)
0457DA             0225*  vdu_clg:
0457DA 3E 10       0226*      ld a,16
0457DC 5B D7       0227*  	rst.lil $10
0457DE C9          0228*  	ret
0457DF             0229*  
0457DF             0230*  ; VDU 17, colour: Define text colour (COLOUR)
0457DF             0231*  vdu_colour_text:
0457DF 32 EF 57 04 0232*  	ld (@arg),a
0457E3 21 EE 57 04 0233*  	ld hl,@cmd
0457E7 01 02 00 00 0234*  	ld bc,@end-@cmd
0457EB 5B DF       0235*  	rst.lil $18
0457ED C9          0236*  	ret
0457EE 11          0237*  @cmd: db 17
0457EF 00          0238*  @arg: db 0
0457F0             0239*  @end:
0457F0             0240*  
0457F0             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0457F0             0242*  ; inputs: a is the plotting mode, c is the colour
0457F0             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
0457F0             0244*  vdu_gcol_fg:
0457F0             0245*  ; This command will set both the current graphics colour,
0457F0             0246*  ; and the current graphics plotting mode.
0457F0             0247*  ; As with VDU 17 the colour number will set the foreground colour
0457F0             0248*  ; if it is in the range 0-127, or the background colour if it is
0457F0             0249*  ; in the range 128-255, and will be interpreted in the same manner.
0457F0             0250*  ; Support for different plotting modes on Agon is currently very limited.
0457F0             0251*  ; The only fully supported mode is mode 0, which is the default mode.
0457F0             0252*  ; This mode will plot the given colour at the given graphics coordinate,
0457F0             0253*  ; and will overwrite any existing graphics at that coordinate. There is
0457F0             0254*  ; very limited support for mode 4, which will invert the colour of any
0457F0             0255*  ; existing graphics at the given coordinate, but this is not fully supported
0457F0             0256*  ; and may not work as expected.
0457F0             0257*  ; Support for other plotting modes, matching those provided by Acorn’s
0457F0             0258*  ; original VDU system, may be added in the future.
0457F0             0259*  ; This command is identical to the BASIC GCOL keyword.
0457F0 32 05 58 04 0260*  	ld (@mode),a
0457F4 79          0261*      ld a,c
0457F5 32 06 58 04 0262*      ld (@col),a
0457F9 21 04 58 04 0263*  	ld hl,@cmd
0457FD 01 03 00 00 0264*  	ld bc,@end-@cmd
045801 5B DF       0265*  	rst.lil $18
045803 C9          0266*  	ret
045804 12          0267*  @cmd: db 18
045805 00          0268*  @mode: db 0
045806 00          0269*  @col: db 0
045807             0270*  @end:
045807             0271*  
045807             0272*  vdu_gcol_bg:
045807 32 1E 58 04 0273*  	ld (@mode),a
04580B 79          0274*      ld a,c
04580C C6 80       0275*      add a,128
04580E 32 1F 58 04 0276*      ld (@col),a
045812 21 1D 58 04 0277*  	ld hl,@cmd
045816 01 03 00 00 0278*  	ld bc,@end-@cmd
04581A 5B DF       0279*  	rst.lil $18
04581C C9          0280*  	ret
04581D 12          0281*  @cmd:  db 18
04581E 00          0282*  @mode: db 0
04581F 00          0283*  @col:  db 0
045820             0284*  @end:
045820             0285*  
045820             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
045820             0287*  ;     This command sets the colour palette, by mapping a logical colour
045820             0288*  ;     to a physical colour. This is useful for defining custom colours,
045820             0289*  ;     or for redefining the default colours.
045820             0290*  ;     If the physical colour number is given as 255 then the colour will
045820             0291*  ;     be defined using the red, green, and blue values given. If the physical
045820             0292*  ;     colour number is given as any other value then the colour will be defined
045820             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
045820             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
045820             0295*  ;     must still be provided, but will be ignored.
045820             0296*  ;     The values for red, green and blue must be given in the range 0-255.
045820             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
045820             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
045820             0299*  ;     requested. The nearest colour will be chosen.
045820             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
045820             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
045820             0302*  vdu_def_log_colour:
045820 32 45 58 04 0303*  	ld (@physical),a
045824 47          0304*      ld b,a
045825 32 44 58 04 0305*      ld (@logical),a
045829 79          0306*      ld a,c
04582A 32 46 58 04 0307*      ld (@red),a
04582E 7C          0308*      ld a,h
04582F 32 47 58 04 0309*      ld (@green),a
045833 7D          0310*      ld a,l
045834 32 48 58 04 0311*      ld (@blue),a
045838 21 43 58 04 0312*  	ld hl,@cmd
04583C 01 06 00 00 0313*  	ld bc,@end-@cmd
045840 5B DF       0314*  	rst.lil $18
045842 C9          0315*  	ret
045843 13          0316*  @cmd: db 19
045844 00          0317*  @logical: db 0
045845 00          0318*  @physical: db 0
045846 00          0319*  @red: db 0
045847 00          0320*  @green: db 0
045848 00          0321*  @blue: db 0
045849             0322*  @end:
045849             0323*  
045849             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
045849             0325*  vdu_reset_gfx:
045849 3E 14       0326*      ld a,20
04584B 5B D7       0327*  	rst.lil $10
04584D C9          0328*  	ret
04584E             0329*  
04584E             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
04584E             0331*  ; except for VDU 1 and VDU 6) §§
04584E             0332*  vdu_disable_screen:
04584E 3E 15       0333*      ld a,21
045850 5B D7       0334*  	rst.lil $10
045852 C9          0335*  	ret
045853             0336*  
045853             0337*  ; VDU 22, n: Select screen mode (MODE n)
045853             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
045853             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
045853             0340*  ; Screen modes
045853             0341*  ; Modes over 128 are double-buffered
045853             0342*  ; From Version 1.04 or greater
045853             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
045853             0344*  ; 0 	640 	480 	16 	    60hz
045853             0345*  ; * 1 	640 	480 	4 	    60hz
045853             0346*  ; 2 	640 	480 	2 	    60hz
045853             0347*  ; 3 	640 	240 	64 	    60hz
045853             0348*  ; 4 	640 	240 	16 	    60hz
045853             0349*  ; 5 	640 	240 	4 	    60hz
045853             0350*  ; 6 	640 	240 	2 	    60hz
045853             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
045853             0352*  ; 8 	320 	240 	64 	    60hz
045853             0353*  ; 9 	320 	240 	16 	    60hz
045853             0354*  ; 10 	320 	240 	4 	    60hz
045853             0355*  ; 11 	320 	240 	2 	    60hz
045853             0356*  ; 12 	320 	200 	64 	    70hz
045853             0357*  ; 13 	320 	200 	16 	    70hz
045853             0358*  ; 14 	320 	200 	4 	    70hz
045853             0359*  ; 15 	320 	200 	2 	    70hz
045853             0360*  ; 16 	800 	600 	4 	    60hz
045853             0361*  ; 17 	800 	600 	2 	    60hz
045853             0362*  ; 18 	1024 	768 	2 	    60hz
045853             0363*  ; 129 	640 	480 	4 	    60hz
045853             0364*  ; 130 	640 	480 	2 	    60hz
045853             0365*  ; 132 	640 	240 	16 	    60hz
045853             0366*  ; 133 	640 	240 	4 	    60hz
045853             0367*  ; 134 	640 	240 	2 	    60hz
045853             0368*  ; 136 	320 	240 	64 	    60hz
045853             0369*  ; 137 	320 	240 	16 	    60hz
045853             0370*  ; 138 	320 	240 	4 	    60hz
045853             0371*  ; 139 	320 	240 	2 	    60hz
045853             0372*  ; 140 	320 	200 	64 	    70hz
045853             0373*  ; 141 	320 	200 	16 	    70hz
045853             0374*  ; 142 	320 	200 	4 	    70hz
045853             0375*  ; 143 	320 	200 	2 	    70hz
045853             0376*  ; * Mode 1 is the “default” mode, and is the mode that the system will use on startup.
045853             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
045853             0378*  ; change to the requested mode.
045853             0379*  ; ** Mode 7 is the “Teletext” mode, and essentially works in a very similar manner to
045853             0380*  ; the BBC Micro’s Teletext mode, which was also mode 7.
045853             0381*  vdu_set_screen_mode:
045853 32 63 58 04 0382*  	ld (@arg),a
045857 21 62 58 04 0383*  	ld hl,@cmd
04585B 01 02 00 00 0384*  	ld bc,@end-@cmd
04585F 5B DF       0385*  	rst.lil $18
045861 C9          0386*  	ret
045862 16          0387*  @cmd: db 22 ; set screen mode
045863 00          0388*  @arg: db 0  ; screen mode parameter
045864             0389*  @end:
045864             0390*  
045864             0391*  ; VDU 23, n: Re-program display character / System Commands
045864             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
045864             0393*  vdu_define_character:
045864 32 80 58 04 0394*  	ld (@ascii),a
045868 11 81 58 04 0395*  	ld de,@data
04586C 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
04586E             0397*  @loop:
04586E 7E          0398*  	ld a,(hl)
04586F 12          0399*  	ld (de),a
045870 23          0400*  	inc hl
045871 13          0401*  	inc de
045872 10 FA       0402*  	djnz @loop
045874 21 7F 58 04 0403*  	ld hl,@cmd
045878 01 0A 00 00 0404*  	ld bc,@end-@cmd
04587C 5B DF       0405*  	rst.lil $18
04587E C9          0406*  	ret
04587F 17          0407*  @cmd:   db 23
045880 00          0408*  @ascii: db 0
045881             0409*  @data:  ds 8
045889             0410*  @end:
045889             0411*  
045889             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
045889             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
045889             0414*  ; 	because we have turned off logical screen scaling
045889             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
045889             0416*  ; outputs; nothing
045889             0417*  ; destroys: a might make it out alive
045889             0418*  vdu_set_gfx_viewport:
045889 ED 43 A9 58 0419*      ld (@x0),bc
       04          
04588E FD 22 AB 58 0420*      ld (@y1),iy
       04          
045893 DD 22 AD 58 0421*  	ld (@x1),ix
       04          
045898 ED 53 AF 58 0422*  	ld (@y0),de
       04          
04589D 21 A8 58 04 0423*  	ld hl,@cmd
0458A1 01 09 00 00 0424*  	ld bc,@end-@cmd
0458A5 5B DF       0425*  	rst.lil $18
0458A7 C9          0426*  	ret
0458A8 18          0427*  @cmd:   db 24 ; set graphics viewport command
0458A9 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
0458AB 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
0458AD 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
0458AF 00 00       0431*  @y0: 	dw 0x0000 ; set by de
0458B1 00          0432*  @end:   db 0x00	  ; padding
0458B2             0433*  
0458B2             0434*  ; VDU 25, mode, x; y;: PLOT command
0458B2             0435*  ; Implemented in vdu_plot.inc
0458B2             0436*  
0458B2             0437*  ; VDU 26: Reset graphics and text viewports **
0458B2             0438*  vdu_reset_txt_gfx_view:
0458B2 3E 1A       0439*      ld a,26
0458B4 5B D7       0440*  	rst.lil $10
0458B6 C9          0441*  	ret
0458B7             0442*  
0458B7             0443*  ; PASSES
0458B7             0444*  ; VDU 27, char: Output character to screen §
0458B7             0445*  ; inputs: a is the ascii code of the character to draw
0458B7             0446*  vdu_draw_char:
0458B7 32 C7 58 04 0447*  	ld (@arg),a
0458BB 21 C6 58 04 0448*  	ld hl,@cmd
0458BF 01 02 00 00 0449*  	ld bc,@end-@cmd
0458C3 5B DF       0450*  	rst.lil $18
0458C5 C9          0451*  	ret
0458C6 1B          0452*  @cmd: db 27
0458C7 00          0453*  @arg: db 0  ; ascii code of character to draw
0458C8             0454*  @end:
0458C8             0455*  
0458C8             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
0458C8             0457*  ; MIND THE LITTLE-ENDIANESS
0458C8             0458*  ; inputs: c=left,b=bottom,e=right,d=top
0458C8             0459*  ; outputs; nothing
0458C8             0460*  ; destroys: a might make it out alive
0458C8             0461*  vdu_set_txt_viewport:
0458C8 ED 43 DE 58 0462*      ld (@lb),bc
       04          
0458CD ED 53 E0 58 0463*  	ld (@rt),de
       04          
0458D2 21 DD 58 04 0464*  	ld hl,@cmd
0458D6 01 05 00 00 0465*  	ld bc,@end-@cmd
0458DA 5B DF       0466*  	rst.lil $18
0458DC C9          0467*  	ret
0458DD 1C          0468*  @cmd:   db 28 ; set text viewport command
0458DE 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
0458E0 00 00       0470*  @rt: 	dw 0x0000 ; set by de
0458E2 00          0471*  @end:   db 0x00	  ; padding
0458E3             0472*  
0458E3             0473*  ; PASSES
0458E3             0474*  ; VDU 29, x; y;: Set graphics origin
0458E3             0475*  ; inputs: bc,de x,y coordinates
0458E3             0476*  vdu_set_gfx_origin:
0458E3 ED 43 F9 58 0477*      ld (@x0),bc
       04          
0458E8 ED 53 FB 58 0478*      ld (@y0),de
       04          
0458ED 21 F8 58 04 0479*  	ld hl,@cmd
0458F1 01 05 00 00 0480*  	ld bc,@end-@cmd
0458F5 5B DF       0481*  	rst.lil $18
0458F7 C9          0482*  	ret
0458F8 1D          0483*  @cmd:	db 29
0458F9 00 00       0484*  @x0: 	dw 0
0458FB 00 00       0485*  @y0: 	dw 0
0458FD 00          0486*  @end: 	db 0 ; padding
0458FE             0487*  
0458FE             0488*  ; PASSES
0458FE             0489*  ; VDU 30: Home cursor
0458FE             0490*  vdu_home_cursor:
0458FE 3E 1E       0491*      ld a,30
045900 5B D7       0492*  	rst.lil $10
045902 C9          0493*  	ret
045903             0494*  
045903             0495*  ; PASSES
045903             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
045903             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
045903             0498*  vdu_move_cursor:
045903 ED 43 14 59 0499*      ld (@x0),bc
       04          
045908 21 13 59 04 0500*  	ld hl,@cmd
04590C 01 03 00 00 0501*  	ld bc,@end-@cmd
045910 5B DF       0502*  	rst.lil $18
045912 C9          0503*  	ret
045913 1F          0504*  @cmd: 	db 31
045914 00          0505*  @x0:	db 0
045915 00          0506*  @y0: 	db 0
045916 00          0507*  @end: 	db 0 ; padding
045917             0508*  
045917             0509*  
045917             0510*  ; VDU 127: Backspace
045917             0511*  vdu_bksp:
045917 3E 7F       0512*      ld a,127
045919 5B D7       0513*  	rst.lil $10
04591B C9          0514*  	ret
04591C             0515*  
04591C             0516*  ; activate a bitmap in preparation to draw it
04591C             0517*  ; inputs: a holding the bitmap index
04591C             0518*  vdu_bmp_select:
04591C 32 2E 59 04 0519*  	ld (@bmp),a
045920 21 2B 59 04 0520*  	ld hl,@cmd
045924 01 04 00 00 0521*  	ld bc,@end-@cmd
045928 5B DF       0522*  	rst.lil $18
04592A C9          0523*  	ret
04592B 17 1B 00    0524*  @cmd: db 23,27,0
04592E 00          0525*  @bmp: db 0
04592F             0526*  @end:
04592F             0527*  
04592F             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04592F             0529*  ; inputs: hl=bufferId
04592F             0530*  vdu_buff_select:
04592F 22 41 59 04 0531*  	ld (@bufferId),hl
045933 21 3E 59 04 0532*  	ld hl,@cmd
045937 01 05 00 00 0533*  	ld bc,@end-@cmd
04593B 5B DF       0534*  	rst.lil $18
04593D C9          0535*  	ret
04593E 17 1B 20    0536*  @cmd: db 23,27,0x20
045941 00 00       0537*  @bufferId: dw 0x0000
045943 00          0538*  @end: db 0x00 ; padding
045944             0539*  
045944             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
045944             0541*  ; inputs: a=format; bc=width; de=height
045944             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
045944             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
045944             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
045944             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
045944             0546*  ; 2 	Mono/Mask (1-bit per pixel)
045944             0547*  ; 3 	Reserved for internal use by VDP (“native” format)
045944             0548*  vdu_bmp_create:
045944 ED 43 60 59 0549*      ld (@width),bc
       04          
045949 ED 53 62 59 0550*      ld (@height),de
       04          
04594E 32 64 59 04 0551*      ld (@fmt),a
045952 21 5D 59 04 0552*  	ld hl,@cmd
045956 01 08 00 00 0553*  	ld bc,@end-@cmd
04595A 5B DF       0554*  	rst.lil $18
04595C C9          0555*  	ret
04595D 17 1B 21    0556*  @cmd:       db 23,27,0x21
045960 00 00       0557*  @width:     dw 0x0000
045962 00 00       0558*  @height:    dw 0x0000
045964 00          0559*  @fmt:       db 0x00
045965             0560*  @end:
045965             0561*  
045965             0562*  ; Draw a bitmap on the screen
045965             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
045965             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
045965             0565*  vdu_bmp_draw:
045965 ED 43 7D 59 0566*      ld (@x0),bc
       04          
04596A ED 53 7F 59 0567*      ld (@y0),de
       04          
04596F 21 7A 59 04 0568*  	ld hl,@cmd
045973 01 07 00 00 0569*  	ld bc,@end-@cmd
045977 5B DF       0570*  	rst.lil $18
045979 C9          0571*  	ret
04597A 17 1B 03    0572*  @cmd: db 23,27,3
04597D 00 00       0573*  @x0:  dw 0x0000
04597F 00 00       0574*  @y0:  dw 0x0000
045981 00          0575*  @end: db 0x00 ; padding
045982             0576*  
045982             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
045982             0578*  ; inputs: a is scaling mode, 1=on, 0=off
045982             0579*  ; note: default setting on boot is scaling ON
045982             0580*  vdu_set_scaling:
045982 32 94 59 04 0581*  	ld (@arg),a
045986 21 91 59 04 0582*  	ld hl,@cmd
04598A 01 04 00 00 0583*  	ld bc,@end-@cmd
04598E 5B DF       0584*  	rst.lil $18
045990 C9          0585*  	ret
045991 17 00 C0    0586*  @cmd: db 23,0,0xC0
045994 00          0587*  @arg: db 0  ; scaling on/off
045995             0588*  @end:
045995             0589*  
045995             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
045995             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
045995             0592*  ; 	(all modes).
045995             0593*  
045995             0594*  ; 	This command will swap the screen buffer, if the current screen mode
045995             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
045995             0596*  ; 	mode is not double-buffered then this command will wait for the next
045995             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
045995             0598*  ; 	screen with the vertical refresh rate of the monitor.
045995             0599*  
045995             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
045995             0601*  ; 	as it will prevent tearing of the screen.
045995             0602*  ; inputs: none
045995             0603*  ; outputs: none
045995             0604*  ; destroys: hl, bc
045995             0605*  vdu_flip:
045995 21 A0 59 04 0606*  	ld hl,@cmd
045999 01 03 00 00 0607*  	ld bc,@end-@cmd
04599D 5B DF       0608*  	rst.lil $18
04599F C9          0609*  	ret
0459A0 17 00 C3    0610*  @cmd: db 23,0,0xC3
0459A3             0611*  @end:
0459A3             0612*  
0459A3             0613*  ; Command 64: Compress a buffer
0459A3             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
0459A3             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
0459A3             0616*  
0459A3             0617*  
0459A3             0618*  ; Command 65: Decompress a buffer
0459A3             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
0459A3             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
0459A3             0621*  ; inputs: hl=sourceBufferId/targetBufferId
0459A3             0622*  vdu_decompress_buffer:
0459A3 22 BF 59 04 0623*  	ld (@targetBufferId),hl
0459A7 22 C2 59 04 0624*  	ld (@sourceBufferId),hl
0459AB 3E 41       0625*  	ld a,65
0459AD 32 C1 59 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
0459B1 21 BC 59 04 0627*  	ld hl,@cmd
0459B5 01 08 00 00 0628*  	ld bc,@end-@cmd
0459B9 5B DF       0629*  	rst.lil $18
0459BB C9          0630*  	ret
0459BC 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
0459BF 00 00       0632*  @targetBufferId: dw 0x0000
0459C1 41          0633*  @cmd1:	db 65
0459C2 00 00       0634*  @sourceBufferId: dw 0x0000
0459C4 00          0635*  @end: 	db 0x00 ; padding
0459C5             0636*  
0459C5             0637*  ; Command 65: Decompress a buffer
0459C5             0638*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
0459C5             0639*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
0459C5             0640*  ; inputs: hl=sourceBufferId/targetBufferId
0459C5             0641*  ; 0x7FFF for the source buffer is just an easy-to remember aribtrary value
0459C5             0642*  vdu_decompress_buffer_different:
0459C5 22 E5 59 04 0643*  	ld (@targetBufferId),hl
0459C9 21 FF 7F 00 0644*      ld hl,0x7FFF
0459CD 22 E8 59 04 0645*  	ld (@sourceBufferId),hl
0459D1 3E 41       0646*  	ld a,65
0459D3 32 E7 59 04 0647*  	ld (@cmd1),a ; restore the part of command that got stomped on
0459D7 21 E2 59 04 0648*  	ld hl,@cmd
0459DB 01 08 00 00 0649*  	ld bc,@end-@cmd
0459DF 5B DF       0650*  	rst.lil $18
0459E1 C9          0651*  	ret
0459E2 17 00 A0    0652*  @cmd: 	db 23,0,0xA0
0459E5 00 00       0653*  @targetBufferId: dw 0x0000
0459E7 41          0654*  @cmd1:	db 65
0459E8 00 00       0655*  @sourceBufferId: dw 0x0000
0459EA 00          0656*  @end: 	db 0x00 ; padding
0459EB             0657*  
0459EB             0658*  ; #### from vdp.inc ####
0459EB             0659*  
0459EB             0660*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0459EB             0661*  ; VDU 23, 7: Scrolling
0459EB             0662*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0459EB             0663*  ; inputs: a, extent; l, direction; h; speed
0459EB             0664*  vdu_scroll_down:
0459EB 32 00 5A 04 0665*  	ld (@extent),a
0459EF 22 01 5A 04 0666*  	ld (@dir),hl ; implicitly populates @speed
0459F3 21 FE 59 04 0667*  	ld hl,@cmd
0459F7 01 05 00 00 0668*  	ld bc,@end-@cmd
0459FB 5B DF       0669*  	rst.lil $18     ;; Sending command to VDP
0459FD C9          0670*  	ret
0459FE 17 07       0671*  @cmd:       db 23,7
045A00 00          0672*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
045A01 00          0673*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
045A02 00          0674*  @speed:     db 0x00 ; pixels
045A03 00          0675*  @end:		db 0x00 ; padding
045A04             0676*  
045A04             0677*  cursor_on:
045A04 21 0F 5A 04 0678*  	ld hl,@cmd
045A08 01 03 00 00 0679*  	ld bc,@end-@cmd
045A0C 5B DF       0680*  	rst.lil $18
045A0E C9          0681*  	ret
045A0F             0682*  @cmd:
045A0F 17 01 01    0683*  	db 23,1,1
045A12             0684*  @end:
045A12             0685*  
045A12             0686*  cursor_off:
045A12 21 1D 5A 04 0687*  	ld hl,@cmd
045A16 01 03 00 00 0688*  	ld bc,@end-@cmd
045A1A 5B DF       0689*  	rst.lil $18
045A1C C9          0690*  	ret
045A1D             0691*  @cmd:
045A1D 17 01 00    0692*  	db 23,1,0
045A20             0693*  @end:
045A20             0694*  
045A20 DD E5       0695*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
045A22             0696*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
045A22 3E 08       0001*M 			LD	A, function
045A24 5B CF       0002*M 			RST.LIL	08h
045A26 DD 7E 00    0697*  			LD	A, (IX + sysvar_time + 0)
045A29 DD BE 00    0698*  @wait:			CP 	A, (IX + sysvar_time + 0)
045A2C 28 FB       0699*  			JR	Z, @wait
045A2E DD E1       0700*  			POP	IX
045A30 C9          0701*  			RET
045A31             0702*  
045A31             0703*  ; #### from vdu_bmp.inc ####
045A31             0704*  ; =========================================================================
045A31             0705*  ; Bitmaps
045A31             0706*  ; -------------------------------------------------------------------------
045A31             0707*  ; VDU 23, 27, 0, n: Select bitmap n
045A31             0708*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
045A31             0709*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
045A31             0710*  
045A31             0711*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
045A31             0712*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
045A31             0713*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
045A31             0714*  ; typically "move" style plot commands are used to define the rectangle.
045A31             0715*  ; To be clear, this command should be performed after two "move" style PLOT commands.
045A31             0716*  ; inputs: hl; target bufferId
045A31             0717*  ; all the following are in 16.8 fixed point format
045A31             0718*  ;   ub.c; top-left x coordinate
045A31             0719*  ;   ud.e; top-left y coordinate
045A31             0720*  ;   ui.x; width
045A31             0721*  ;   ui.y; height
045A31             0722*  vdu_buff_screen_capture168:
045A31 ED 53 68 5A 0723*          ld (@y0-1),de
       04          
045A36 ED 43 66 5A 0724*          ld (@x0-1),bc
       04          
045A3B 3E 44       0725*          ld a,0x44 ; plot_pt+mv_abs
045A3D 32 66 5A 04 0726*          ld (@x0-1),a
045A41             0727*  
045A41 DD 22 6D 5A 0728*          ld (@x1),ix
       04          
045A46 FD 22 6F 5A 0729*          ld (@y1),iy
       04          
045A4B 3E 17       0730*          ld a,23
045A4D 32 71 5A 04 0731*          ld (@y1+2),a
045A51             0732*  
045A51 22 74 5A 04 0733*          ld (@bufId),hl
045A55 AF          0734*          xor a
045A56 32 76 5A 04 0735*          ld (@bufId+2),a
045A5A             0736*  
045A5A 21 65 5A 04 0737*          ld hl,@begin
045A5E 01 13 00 00 0738*          ld bc,@end-@begin
045A62 5B DF       0739*          rst.lil $18
045A64 C9          0740*          ret
045A65             0741*  @begin:
045A65             0742*  ; absolute move gfx cursor to top-left screen coordinate
045A65             0743*  ; VDU 25, mode, x; y;: PLOT command
045A65 19 44       0744*          db 25,0x44 ; plot_pt+mv_abs
045A67 40 00       0745*  @x0: 	dw 64
045A69 40 00       0746*  @y0: 	dw 64
045A6B             0747*  ; relative move gfx cursor to bottom-right screen coordinate
045A6B             0748*  ; VDU 25, mode, x; y;: PLOT command
045A6B 19 40       0749*          db 25,0x40 ; plot_pt+mv_rel
045A6D 0F 00       0750*  @x1: 	dw 15
045A6F 0F 00       0751*  @y1: 	dw 15
045A71             0752*  ; now the main event
045A71             0753*  ; VDU 23, 27, &21, bitmapId; 0;
045A71 17 1B 21    0754*          db 23,27,0x21
045A74 00 20 00 00 0755*  @bufId: dw 0x2000,0x0000
045A78             0756*  @end: ; no padding required
045A78             0757*  
045A78             0758*  vdu_buff_screen_capture_full:
045A78 21 83 5A 04 0759*          ld hl,@begin
045A7C 01 13 00 00 0760*          ld bc,@end-@begin
045A80 5B DF       0761*          rst.lil $18
045A82 C9          0762*          ret
045A83             0763*  @begin:
045A83             0764*  ; absolute move gfx cursor to top-left screen coordinate
045A83             0765*  ; VDU 25, mode, x; y;: PLOT command
045A83 19 44       0766*          db 25,0x44 ; plot_pt+mv_abs
045A85 00 00       0767*  @x0: 	dw 0
045A87 00 00       0768*  @y0: 	dw 0
045A89             0769*  ; relative move gfx cursor to bottom-right screen coordinate
045A89             0770*  ; VDU 25, mode, x; y;: PLOT command
045A89 19 40       0771*          db 25,0x40 ; plot_pt+mv_rel
045A8B 3F 01       0772*  @x1: 	dw 319
045A8D EF 00       0773*  @y1: 	dw 239
045A8F             0774*  ; now the main event
045A8F             0775*  ; VDU 23, 27, &21, bitmapId; 0;
045A8F 17 1B 21    0776*          db 23,27,0x21
045A92 00 20 00 00 0777*  @bufId: dw 0x2000,0x0000
045A96             0778*  @end: ; no padding required
045A96             0779*  
045A96             0780*  vdu_buff_screen_paste_full:
045A96 21 A1 5A 04 0781*          ld hl,@begin
045A9A 01 0B 00 00 0782*          ld bc,@end-@begin
045A9E 5B DF       0783*          rst.lil $18
045AA0 C9          0784*          ret
045AA1             0785*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045AA1 17 1B 20    0786*  @begin:    db 23,27,0x20
045AA4 00 20       0787*  @bufferId: dw 0x2000
045AA6             0788*  ; VDU 25, mode, x; y;: PLOT command
045AA6 19 ED       0789*             db 25,0xED ; plot_bmp+dr_abs_fg
045AA8 00 00 00 00 0790*             dw 0x0000,0x0000
045AAC             0791*  @end: ; no padding required
045AAC             0792*  
045AAC             0793*  vdu_buff_screen_capture_tiles:
045AAC 21 B7 5A 04 0794*          ld hl,@begin
045AB0 01 13 00 00 0795*          ld bc,@end-@begin
045AB4 5B DF       0796*          rst.lil $18
045AB6 C9          0797*          ret
045AB7             0798*  @begin:
045AB7             0799*  ; absolute move gfx cursor to top-left screen coordinate
045AB7             0800*  ; VDU 25, mode, x; y;: PLOT command
045AB7 19 44       0801*          db 25,0x44 ; plot_pt+mv_abs
045AB9 00 00       0802*  @x0: 	dw 0
045ABB 00 00       0803*  @y0: 	dw 0
045ABD             0804*  ; relative move gfx cursor to bottom-right screen coordinate
045ABD             0805*  ; VDU 25, mode, x; y;: PLOT command
045ABD 19 40       0806*          db 25,0x40 ; plot_pt+mv_rel
045ABF FF 00       0807*  @x1: 	dw 319-64
045AC1 EF 00       0808*  @y1: 	dw 239
045AC3             0809*  ; now the main event
045AC3             0810*  ; VDU 23, 27, &21, bitmapId; 0;
045AC3 17 1B 21    0811*          db 23,27,0x21
045AC6 00 20 00 00 0812*  @bufId: dw 0x2000,0x0000
045ACA             0813*  @end: ; no padding required
045ACA             0814*  
045ACA             0815*  vdu_buff_screen_paste_tiles:
045ACA 21 D5 5A 04 0816*          ld hl,@begin
045ACE 01 0B 00 00 0817*          ld bc,@end-@begin
045AD2 5B DF       0818*          rst.lil $18
045AD4 C9          0819*          ret
045AD5             0820*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045AD5 17 1B 20    0821*  @begin:    db 23,27,0x20
045AD8 00 20       0822*  @bufferId: dw 0x2000
045ADA             0823*  ; VDU 25, mode, x; y;: PLOT command
045ADA 19 ED       0824*             db 25,0xED ; plot_bmp+dr_abs_fg
045ADC 00 00 01 00 0825*             dw 0x0000,0x0001
045AE0             0826*  @end: ; no padding required
045AE0             0827*  
045AE0             0828*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
045AE0             0829*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
045AE0             0830*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
045AE0             0831*  ; Value	Meaning
045AE0             0832*  ; 0	RGBA8888 (4-bytes per pixel)
045AE0             0833*  ; 1	RGBA2222 (1-bytes per pixel)
045AE0             0834*  ; 2	Mono/Mask (1-bit per pixel)
045AE0             0835*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
045AE0             0836*  ;     They have some significant limitations, and are not intended for general use.
045AE0             0837*  
045AE0             0838*  ; =========================================================================
045AE0             0839*  ; Sprites
045AE0             0840*  ; -------------------------------------------------------------------------
045AE0             0841*  ; VDU 23, 27, 4, n: Select sprite n
045AE0             0842*  ; VDU 23, 27, 5: Clear frames in current sprite
045AE0             0843*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045AE0             0844*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045AE0             0845*  ; VDU 23, 27, 7, n: Activate n sprites
045AE0             0846*  ; VDU 23, 27, 8: Select next frame of current sprite
045AE0             0847*  ; VDU 23, 27, 9: Select previous frame of current sprite
045AE0             0848*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045AE0             0849*  ; VDU 23, 27, 11: Show current sprite
045AE0             0850*  ; VDU 23, 27, 12: Hide current sprite
045AE0             0851*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045AE0             0852*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045AE0             0853*  ; VDU 23, 27, 15: Update the sprites in the GPU
045AE0             0854*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045AE0             0855*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045AE0             0856*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045AE0             0857*  
045AE0             0858*  ; =========================================================================
045AE0             0859*  ; Mouse cursor
045AE0             0860*  ; -------------------------------------------------------------------------
045AE0             0861*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
045AE0             0862*  
045AE0             0863*  ; #### from vdu_plot.inc ####
045AE0             0864*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045AE0             0865*  ; PLOT code 	(Decimal) 	Effect
045AE0             0866*  ; &00-&07 	0-7 	Solid line, includes both ends
045AE0             0867*  plot_sl_both: equ 0x00
045AE0             0868*  
045AE0             0869*  ; &08-&0F 	8-15 	Solid line, final point omitted
045AE0             0870*  plot_sl_first: equ 0x08
045AE0             0871*  
045AE0             0872*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
045AE0             0873*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
045AE0             0874*  
045AE0             0875*  ; &20-&27 	32-39 	Solid line, first point omitted
045AE0             0876*  plot_sl_last: equ 0x20
045AE0             0877*  
045AE0             0878*  ; &28-&2F 	40-47 	Solid line, both points omitted
045AE0             0879*  plot_sl_none: equ 0x28
045AE0             0880*  
045AE0             0881*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
045AE0             0882*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
045AE0             0883*  
045AE0             0884*  ; &40-&47 	64-71 	Point plot
045AE0             0885*  plot_pt: equ 0x40
045AE0             0886*  
045AE0             0887*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
045AE0             0888*  plot_lf_lr_non_bg: equ 0x48
045AE0             0889*  
045AE0             0890*  ; &50-&57 	80-87 	Triangle fill
045AE0             0891*  plot_tf: equ 0x50
045AE0             0892*  
045AE0             0893*  ; &58-&5F 	88-95 	Line fill right to background §§
045AE0             0894*  plot_lf_r_bg: equ 0x58
045AE0             0895*  
045AE0             0896*  ; &60-&67 	96-103 	Rectangle fill
045AE0             0897*  plot_rf: equ 0x60
045AE0             0898*  
045AE0             0899*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
045AE0             0900*  plot_lf_lr_fg: equ 0x60
045AE0             0901*  
045AE0             0902*  ; &70-&77 	112-119 	Parallelogram fill
045AE0             0903*  plot_pf: equ 0x70
045AE0             0904*  
045AE0             0905*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
045AE0             0906*  plot_lf_r_non_fg: equ 0x78
045AE0             0907*  
045AE0             0908*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
045AE0             0909*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
045AE0             0910*  
045AE0             0911*  ; &90-&97 	144-151 	Circle outline
045AE0             0912*  plot_co: equ 0x90
045AE0             0913*  
045AE0             0914*  ; &98-&9F 	152-159 	Circle fill
045AE0             0915*  plot_cf: equ 0x98
045AE0             0916*  
045AE0             0917*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
045AE0             0918*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
045AE0             0919*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
045AE0             0920*  
045AE0             0921*  ; &B8-&BF 	184-191 	Rectangle copy/move
045AE0             0922*  plot_rcm: equ 0xB8
045AE0             0923*  
045AE0             0924*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
045AE0             0925*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
045AE0             0926*  ; &D0-&D7 	208-215 	Not defined
045AE0             0927*  ; &D8-&DF 	216-223 	Not defined
045AE0             0928*  ; &E0-&E7 	224-231 	Not defined
045AE0             0929*  
045AE0             0930*  ; &E8-&EF 	232-239 	Bitmap plot §
045AE0             0931*  plot_bmp: equ 0xE8
045AE0             0932*  
045AE0             0933*  ; &F0-&F7 	240-247 	Not defined
045AE0             0934*  ; &F8-&FF 	248-255 	Not defined
045AE0             0935*  
045AE0             0936*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
045AE0             0937*  ; Agon Console8 VDP 2.2.0
045AE0             0938*  
045AE0             0939*  ; Within each group of eight plot codes, the effects are as follows:
045AE0             0940*  ; Plot code 	Effect
045AE0             0941*  ; 0 	Move relative
045AE0             0942*  mv_rel: equ 0
045AE0             0943*  
045AE0             0944*  ; 1 	Plot relative in current foreground colour
045AE0             0945*  dr_rel_fg: equ 1
045AE0             0946*  
045AE0             0947*  ; 2 	Not supported (Plot relative in logical inverse colour)
045AE0             0948*  ; 3 	Plot relative in current background colour
045AE0             0949*  dr_rel_bg: equ 3
045AE0             0950*  
045AE0             0951*  ; 4 	Move absolute
045AE0             0952*  mv_abs: equ 4
045AE0             0953*  
045AE0             0954*  ; 5 	Plot absolute in current foreground colour
045AE0             0955*  dr_abs_fg: equ 5
045AE0             0956*  
045AE0             0957*  ; 6 	Not supported (Plot absolute in logical inverse colour)
045AE0             0958*  ; 7 	Plot absolute in current background colour
045AE0             0959*  dr_abs_bg: equ 7
045AE0             0960*  
045AE0             0961*  ; Codes 0-3 use the position data provided as part of the command
045AE0             0962*  ; as a relative position, adding the position given to the current
045AE0             0963*  ; graphical cursor position. Codes 4-7 use the position data provided
045AE0             0964*  ; as part of the command as an absolute position, setting the current
045AE0             0965*  ; graphical cursor position to the position given.
045AE0             0966*  
045AE0             0967*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
045AE0             0968*  ; current pixel colour. These operations cannot currently be supported
045AE0             0969*  ; by the graphics system the Agon VDP uses, so these codes are not
045AE0             0970*  ; supported. Support for these codes may be added in a future version
045AE0             0971*  ; of the VDP firmware.
045AE0             0972*  
045AE0             0973*  ; 16 colour palette constants
045AE0             0974*  c_black: equ 0
045AE0             0975*  c_red_dk: equ 1
045AE0             0976*  c_green_dk: equ 2
045AE0             0977*  c_yellow_dk: equ 3
045AE0             0978*  c_blue_dk: equ 4
045AE0             0979*  c_magenta_dk: equ 5
045AE0             0980*  c_cyan_dk: equ 6
045AE0             0981*  c_grey: equ 7
045AE0             0982*  c_grey_dk: equ 8
045AE0             0983*  c_red: equ 9
045AE0             0984*  c_green: equ 10
045AE0             0985*  c_yellow: equ 11
045AE0             0986*  c_blue: equ 12
045AE0             0987*  c_magenta: equ 13
045AE0             0988*  c_cyan: equ 14
045AE0             0989*  c_white: equ 15
045AE0             0990*  
045AE0             0991*  ; VDU 25, mode, x; y;: PLOT command
045AE0             0992*  ; inputs: a=mode, bc=x0, de=y0
045AE0             0993*  vdu_plot:
045AE0 32 FA 5A 04 0994*      ld (@mode),a
045AE4 ED 43 FB 5A 0995*      ld (@x0),bc
       04          
045AE9 ED 53 FD 5A 0996*      ld (@y0),de
       04          
045AEE 21 F9 5A 04 0997*  	ld hl,@cmd
045AF2 01 06 00 00 0998*  	ld bc,@end-@cmd
045AF6 5B DF       0999*  	rst.lil $18
045AF8 C9          1000*  	ret
045AF9 19          1001*  @cmd:   db 25
045AFA 00          1002*  @mode:  db 0
045AFB 00 00       1003*  @x0: 	dw 0
045AFD 00 00       1004*  @y0: 	dw 0
045AFF 00          1005*  @end:   db 0 ; extra byte to soak up deu
045B00             1006*  
045B00             1007*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045B00             1008*  ; &E8-&EF 	232-239 	Bitmap plot §
045B00             1009*  ; VDU 25, mode, x; y;: PLOT command
045B00             1010*  ; inputs: bc=x0, de=y0
045B00             1011*  ; prerequisites: vdu_buff_select
045B00             1012*  vdu_plot_bmp:
045B00 ED 43 17 5B 1013*      ld (@x0),bc
       04          
045B05 ED 53 19 5B 1014*      ld (@y0),de
       04          
045B0A 21 15 5B 04 1015*  	ld hl,@cmd
045B0E 01 06 00 00 1016*  	ld bc,@end-@cmd
045B12 5B DF       1017*  	rst.lil $18
045B14 C9          1018*  	ret
045B15 19          1019*  @cmd:   db 25
045B16 ED          1020*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045B17 00 00       1021*  @x0: 	dw 0x0000
045B19 00 00       1022*  @y0: 	dw 0x0000
045B1B 00          1023*  @end:   db 0x00 ; padding
045B1C             1024*  
045B1C             1025*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045B1C             1026*  ; &E8-&EF 	232-239 	Bitmap plot §
045B1C             1027*  ; VDU 25, mode, x; y;: PLOT command
045B1C             1028*  ; inputs: bc=x0, de=y0
045B1C             1029*  ; USING 16.8 FIXED POINT COORDINATES
045B1C             1030*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045B1C             1031*  ;   the fractional portiion of the inputs are truncated
045B1C             1032*  ;   leaving only the 16-bit integer portion
045B1C             1033*  ; prerequisites: vdu_buff_select
045B1C             1034*  vdu_plot_bmp168:
045B1C             1035*  ; populate in the reverse of normal to keep the
045B1C             1036*  ; inputs from stomping on each other
045B1C ED 53 3A 5B 1037*      ld (@y0-1),de
       04          
045B21 ED 43 38 5B 1038*      ld (@x0-1),bc
       04          
045B26 3E ED       1039*      ld a,plot_bmp+dr_abs_fg ; 0xED
045B28 32 38 5B 04 1040*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
045B2C 21 37 5B 04 1041*  	ld hl,@cmd
045B30 01 06 00 00 1042*  	ld bc,@end-@cmd
045B34 5B DF       1043*  	rst.lil $18
045B36 C9          1044*  	ret
045B37 19          1045*  @cmd:   db 25
045B38 ED          1046*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045B39 00 00       1047*  @x0: 	dw 0x0000
045B3B 00 00       1048*  @y0: 	dw 0x0000
045B3D             1049*  @end:  ; no padding required b/c we shifted de right
045B3D             1050*  
045B3D             1051*  ; draw a filled rectangle
045B3D             1052*  vdu_plot_rf:
045B3D ED 43 64 5B 1053*      ld (@x0),bc
       04          
045B42 ED 53 66 5B 1054*      ld (@y0),de
       04          
045B47 DD 22 6A 5B 1055*      ld (@x1),ix
       04          
045B4C FD 22 6C 5B 1056*      ld (@y1),iy
       04          
045B51 3E 19       1057*      ld a,25 ; we have to reload the 2nd plot command
045B53 32 68 5B 04 1058*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045B57 21 62 5B 04 1059*  	ld hl,@cmd0
045B5B 01 0C 00 00 1060*  	ld bc,@end-@cmd0
045B5F 5B DF       1061*  	rst.lil $18
045B61 C9          1062*      ret
045B62 19          1063*  @cmd0:  db 25 ; plot
045B63 04          1064*  @arg0:  db plot_sl_both+mv_abs
045B64 00 00       1065*  @x0:    dw 0x0000
045B66 00 00       1066*  @y0:    dw 0x0000
045B68 19          1067*  @cmd1:  db 25 ; plot
045B69 65          1068*  @arg1:  db plot_rf+dr_abs_fg
045B6A 00 00       1069*  @x1:    dw 0x0000
045B6C 00 00       1070*  @y1:    dw 0x0000
045B6E 00          1071*  @end:   db 0x00 ; padding
045B6F             1072*  
045B6F             1073*  ; draw a filled circle
045B6F             1074*  vdu_plot_cf:
045B6F ED 43 96 5B 1075*      ld (@x0),bc
       04          
045B74 ED 53 98 5B 1076*      ld (@y0),de
       04          
045B79 DD 22 9C 5B 1077*      ld (@x1),ix
       04          
045B7E FD 22 9E 5B 1078*      ld (@y1),iy
       04          
045B83 3E 19       1079*      ld a,25 ; we have to reload the 2nd plot command
045B85 32 9A 5B 04 1080*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045B89 21 94 5B 04 1081*  	ld hl,@cmd0
045B8D 01 0C 00 00 1082*  	ld bc,@end-@cmd0
045B91 5B DF       1083*  	rst.lil $18
045B93 C9          1084*      ret
045B94 19          1085*  @cmd0:  db 25 ; plot
045B95 04          1086*  @arg0:  db plot_sl_both+mv_abs
045B96 00 00       1087*  @x0:    dw 0x0000
045B98 00 00       1088*  @y0:    dw 0x0000
045B9A 19          1089*  @cmd1:  db 25 ; plot
045B9B 9D          1090*  @arg1:  db plot_cf+dr_abs_fg
045B9C 00 00       1091*  @x1:    dw 0x0000
045B9E 00 00       1092*  @y1:    dw 0x0000
045BA0 00          1093*  @end:   db 0x00 ; padding
045BA1             1094*  
045BA1             1095*  ; #### from vdu_sprites.inc ####
045BA1             1096*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
045BA1             1097*  ; the VDP can support up to 256 sprites. They must be defined
045BA1             1098*  ; contiguously, and so the first sprite is sprite 0.
045BA1             1099*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
045BA1             1100*  ; Once a selection of sprites have been defined, you can activate
045BA1             1101*  ; them using the VDU 23, 27, 7, n command, where n is the number
045BA1             1102*  ; of sprites to activate. This will activate the first n sprites,
045BA1             1103*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
045BA1             1104*  
045BA1             1105*  ; A single sprite can have multiple "frames", referring to
045BA1             1106*  ; different bitmaps.
045BA1             1107*  ; (These bitmaps do not need to be the same size.)
045BA1             1108*  ; This allows a sprite to include an animation sequence,
045BA1             1109*  ; which can be stepped through one frame at a time, or picked
045BA1             1110*  ; in any order.
045BA1             1111*  
045BA1             1112*  ; Any format of bitmap can be used as a sprite frame. It should
045BA1             1113*  ; be noted however that "native" format bitmaps are not
045BA1             1114*  ; recommended for use as sprite frames, as they cannot get
045BA1             1115*  ; erased from the screen. (As noted above, the "native" bitmap
045BA1             1116*  ; format is not really intended for general use.) This is part
045BA1             1117*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
045BA1             1118*  ; screen are now stored in RGBA2222 format.
045BA1             1119*  
045BA1             1120*  ; An "active" sprite can be hidden, so it will stop being drawn,
045BA1             1121*  ; and then later shown again.
045BA1             1122*  
045BA1             1123*  ; Moving sprites around the screen is done by changing the
045BA1             1124*  ; position of the sprite. This can be done either by setting
045BA1             1125*  ; the absolute position of the sprite, or by moving the sprite
045BA1             1126*  ; by a given number of pixels. (Sprites are positioned using
045BA1             1127*  ; pixel coordinates, and not by the logical OS coordinate system.)
045BA1             1128*  ; In the current sprite system, sprites will not update their
045BA1             1129*  ; position on-screen until either another drawing operation is
045BA1             1130*  ; performed or an explicit VDU 23, 27, 15 command is performed.
045BA1             1131*  
045BA1             1132*  ; Here are the sprite commands:
045BA1             1133*  ;
045BA1             1134*  ; VDU 23, 27, 4,  n: Select sprite n
045BA1             1135*  ; inputs: a is the 8-bit sprite id
045BA1             1136*  ; vdu_sprite_select:
045BA1             1137*  
045BA1             1138*  ; VDU 23, 27, 5:  Clear frames in current sprite
045BA1             1139*  ; inputs: none
045BA1             1140*  ; prerequisites: vdu_sprite_select
045BA1             1141*  ; vdu_sprite_clear_frames:
045BA1             1142*  
045BA1             1143*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045BA1             1144*  ; inputs: a is the 8-bit bitmap number
045BA1             1145*  ; prerequisites: vdu_sprite_select
045BA1             1146*  ; vdu_sprite_add_bmp:
045BA1             1147*  
045BA1             1148*  ; VDU 23, 27, 7,  n: Activate n sprites
045BA1             1149*  ; inputs: a is the number of sprites to activate
045BA1             1150*  ; vdu_sprite_activate:
045BA1             1151*  
045BA1             1152*  ; VDU 23, 27, 8:  Select next frame of current sprite
045BA1             1153*  ; inputs: none
045BA1             1154*  ; prerequisites: vdu_sprite_select
045BA1             1155*  ; vdu_sprite_next_frame:
045BA1             1156*  
045BA1             1157*  ; VDU 23, 27, 9:  Select previous frame of current sprite
045BA1             1158*  ; inputs: none
045BA1             1159*  ; prerequisites: vdu_sprite_select
045BA1             1160*  ; vdu_sprite_prev_frame:
045BA1             1161*  
045BA1             1162*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045BA1             1163*  ; inputs: a is frame number to select
045BA1             1164*  ; prerequisites: vdu_sprite_select
045BA1             1165*  ; vdu_sprite_select_frame:
045BA1             1166*  
045BA1             1167*  ; VDU 23, 27, 11: Show current sprite
045BA1             1168*  ; inputs: none
045BA1             1169*  ; prerequisites: vdu_sprite_select
045BA1             1170*  ; vdu_sprite_show:
045BA1             1171*  
045BA1             1172*  ; VDU 23, 27, 12: Hide current sprite
045BA1             1173*  ; inputs: none
045BA1             1174*  ; prerequisites: vdu_sprite_select
045BA1             1175*  ; vdu_sprite_hide:
045BA1             1176*  
045BA1             1177*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045BA1             1178*  ; inputs: bc is x coordinate, de is y coordinate
045BA1             1179*  ; prerequisites: vdu_sprite_select
045BA1             1180*  ; vdu_sprite_move_abs:
045BA1             1181*  ;
045BA1             1182*  ; USING 16.8 FIXED POINT COORDINATES
045BA1             1183*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045BA1             1184*  ;   the fractional portiion of the inputs are truncated
045BA1             1185*  ;   leaving only the 16-bit integer portion
045BA1             1186*  ; prerequisites: vdu_sprite_select
045BA1             1187*  ; vdu_sprite_move_abs168:
045BA1             1188*  
045BA1             1189*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045BA1             1190*  ; inputs: bc is x coordinate, de is y coordinate
045BA1             1191*  ; prerequisites: vdu_sprite_select
045BA1             1192*  ; vdu_sprite_move_rel:
045BA1             1193*  ;
045BA1             1194*  ; USING 16.8 FIXED POINT COORDINATES
045BA1             1195*  ; inputs: ub.c is dx, ud.e is dy
045BA1             1196*  ;   the fractional portiion of the inputs are truncated
045BA1             1197*  ;   leaving only the 16-bit integer portion
045BA1             1198*  ; prerequisites: vdu_sprite_select
045BA1             1199*  ; vdu_sprite_move_rel168:
045BA1             1200*  
045BA1             1201*  ; VDU 23, 27, 15: Update the sprites in the GPU
045BA1             1202*  ; inputs: none
045BA1             1203*  ; vdu_sprite_update:
045BA1             1204*  
045BA1             1205*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045BA1             1206*  ; inputs: none
045BA1             1207*  ; vdu_sprite_bmp_reset:
045BA1             1208*  
045BA1             1209*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045BA1             1210*  ; inputs: none
045BA1             1211*  ; vdu_sprite_reset:
045BA1             1212*  
045BA1             1213*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045BA1             1214*  ; inputs: a is the GCOL paint mode
045BA1             1215*  ; prerequisites: vdu_sprite_select
045BA1             1216*  ; vdu_sprite_set_gcol:
045BA1             1217*  
045BA1             1218*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045BA1             1219*  ; inputs: hl=bufferId
045BA1             1220*  ; prerequisites: vdu_sprite_select
045BA1             1221*  ; vdu_sprite_add_buff:
045BA1             1222*  
045BA1             1223*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
045BA1             1224*  
045BA1             1225*  ; VDU 23, 27, 4, n: Select sprite n
045BA1             1226*  ; inputs: a is the 8-bit sprite id
045BA1             1227*  vdu_sprite_select:
045BA1 32 B3 5B 04 1228*      ld (@sprite),a
045BA5 21 B0 5B 04 1229*      ld hl,@cmd
045BA9 01 04 00 00 1230*      ld bc,@end-@cmd
045BAD 5B DF       1231*      rst.lil $18
045BAF C9          1232*      ret
045BB0 17 1B 04    1233*  @cmd:    db 23,27,4
045BB3 00          1234*  @sprite: db 0x00
045BB4             1235*  @end:
045BB4             1236*  
045BB4             1237*  ; VDU 23, 27, 5: Clear frames in current sprite
045BB4             1238*  ; inputs: none
045BB4             1239*  ; prerequisites: vdu_sprite_select
045BB4             1240*  vdu_sprite_clear_frames:
045BB4 21 BF 5B 04 1241*      ld hl,@cmd
045BB8 01 03 00 00 1242*      ld bc,@end-@cmd
045BBC 5B DF       1243*      rst.lil $18
045BBE C9          1244*      ret
045BBF 17 1B 05    1245*  @cmd: db 23,27,5
045BC2             1246*  @end:
045BC2             1247*  
045BC2             1248*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045BC2             1249*  ; inputs: a is the 8-bit bitmap number
045BC2             1250*  ; prerequisites: vdu_sprite_select
045BC2             1251*  vdu_sprite_add_bmp:
045BC2 32 D4 5B 04 1252*      ld (@bmp),a
045BC6 21 D1 5B 04 1253*      ld hl,@cmd
045BCA 01 04 00 00 1254*      ld bc,@end-@cmd
045BCE 5B DF       1255*      rst.lil $18
045BD0 C9          1256*      ret
045BD1 17 1B 06    1257*  @cmd: db 23,27,6
045BD4 00          1258*  @bmp: db 0x00
045BD5             1259*  @end:
045BD5             1260*  
045BD5             1261*  ; VDU 23, 27, 7, n: Activate n sprites
045BD5             1262*  ; inputs: a is the number of sprites to activate
045BD5             1263*  vdu_sprite_activate:
045BD5 32 E7 5B 04 1264*      ld (@num),a
045BD9 21 E4 5B 04 1265*      ld hl,@cmd
045BDD 01 04 00 00 1266*      ld bc,@end-@cmd
045BE1 5B DF       1267*      rst.lil $18
045BE3 C9          1268*      ret
045BE4 17 1B 07    1269*  @cmd: db 23,27,7
045BE7 00          1270*  @num: db 0x00
045BE8             1271*  @end:
045BE8             1272*  
045BE8             1273*  ; VDU 23, 27, 8: Select next frame of current sprite
045BE8             1274*  ; inputs: none
045BE8             1275*  ; prerequisites: vdu_sprite_select
045BE8             1276*  vdu_sprite_next_frame:
045BE8 21 F3 5B 04 1277*      ld hl,@cmd
045BEC 01 03 00 00 1278*      ld bc,@end-@cmd
045BF0 5B DF       1279*      rst.lil $18
045BF2 C9          1280*      ret
045BF3 17 1B 08    1281*  @cmd: db 23,27,8
045BF6             1282*  @end:
045BF6             1283*  
045BF6             1284*  ; VDU 23, 27, 9: Select previous frame of current sprite
045BF6             1285*  ; inputs: none
045BF6             1286*  ; prerequisites: vdu_sprite_select
045BF6             1287*  vdu_sprite_prev_frame:
045BF6 21 01 5C 04 1288*      ld hl,@cmd
045BFA 01 03 00 00 1289*      ld bc,@end-@cmd
045BFE 5B DF       1290*      rst.lil $18
045C00 C9          1291*      ret
045C01 17 1B 09    1292*  @cmd: db 23,27,9
045C04             1293*  @end:
045C04             1294*  
045C04             1295*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045C04             1296*  ; inputs: a is frame number to select
045C04             1297*  ; prerequisites: vdu_sprite_select
045C04             1298*  vdu_sprite_select_frame:
045C04 32 16 5C 04 1299*      ld (@frame),a
045C08 21 13 5C 04 1300*      ld hl,@cmd
045C0C 01 04 00 00 1301*      ld bc,@end-@cmd
045C10 5B DF       1302*      rst.lil $18
045C12 C9          1303*      ret
045C13 17 1B 0A    1304*  @cmd:    db 23,27,10
045C16 00          1305*  @frame:  db 0x00
045C17             1306*  @end:
045C17             1307*  
045C17             1308*  ; VDU 23, 27, 11: Show current sprite
045C17             1309*  ; inputs: none
045C17             1310*  ; prerequisites: vdu_sprite_select
045C17             1311*  vdu_sprite_show:
045C17 21 22 5C 04 1312*      ld hl,@cmd
045C1B 01 03 00 00 1313*      ld bc,@end-@cmd
045C1F 5B DF       1314*      rst.lil $18
045C21 C9          1315*      ret
045C22 17 1B 0B    1316*  @cmd: db 23,27,11
045C25             1317*  @end:
045C25             1318*  
045C25             1319*  ; VDU 23, 27, 12: Hide current sprite
045C25             1320*  ; inputs: none
045C25             1321*  ; prerequisites: vdu_sprite_select
045C25             1322*  vdu_sprite_hide:
045C25 21 30 5C 04 1323*      ld hl,@cmd
045C29 01 03 00 00 1324*      ld bc,@end-@cmd
045C2D 5B DF       1325*      rst.lil $18
045C2F C9          1326*      ret
045C30 17 1B 0C    1327*  @cmd: db 23,27,12
045C33             1328*  @end:
045C33             1329*  
045C33             1330*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045C33             1331*  ; inputs: bc is x coordinate, de is y coordinate
045C33             1332*  ; prerequisites: vdu_sprite_select
045C33             1333*  vdu_sprite_move_abs:
045C33 ED 43 4B 5C 1334*      ld (@xpos),bc
       04          
045C38 ED 53 4D 5C 1335*      ld (@ypos),de
       04          
045C3D 21 48 5C 04 1336*      ld hl,@cmd
045C41 01 07 00 00 1337*      ld bc,@end-@cmd
045C45 5B DF       1338*      rst.lil $18
045C47 C9          1339*      ret
045C48 17 1B 0D    1340*  @cmd:  db 23,27,13
045C4B 00 00       1341*  @xpos: dw 0x0000
045C4D 00 00       1342*  @ypos: dw 0x0000
045C4F 00          1343*  @end:  db 0x00 ; padding
045C50             1344*  
045C50             1345*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045C50             1346*  ; inputs: bc is x coordinate, de is y coordinate
045C50             1347*  ; prerequisites: vdu_sprite_select
045C50             1348*  vdu_sprite_move_rel:
045C50 ED 43 68 5C 1349*      ld (@dx),bc
       04          
045C55 ED 53 6A 5C 1350*      ld (@dy),de
       04          
045C5A 21 65 5C 04 1351*      ld hl,@cmd
045C5E 01 07 00 00 1352*      ld bc,@end-@cmd
045C62 5B DF       1353*      rst.lil $18
045C64 C9          1354*      ret
045C65 17 1B 0E    1355*  @cmd: db 23,27,14
045C68 00 00       1356*  @dx:  dw 0x0000
045C6A 00 00       1357*  @dy:  dw 0x0000
045C6C 00          1358*  @end: db 0x00 ; padding
045C6D             1359*  
045C6D             1360*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045C6D             1361*  ; USING 16.8 FIXED POINT COORDINATES
045C6D             1362*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045C6D             1363*  ;   the fractional portiion of the inputs are truncated
045C6D             1364*  ;   leaving only the 16-bit integer portion
045C6D             1365*  ; prerequisites: vdu_sprite_select
045C6D             1366*  vdu_sprite_move_abs168:
045C6D             1367*  ; populate in the reverse of normal to keep the
045C6D             1368*  ; inputs from stomping on each other
045C6D ED 53 8C 5C 1369*      ld (@ypos-1),de
       04          
045C72 ED 43 8A 5C 1370*      ld (@xpos-1),bc
       04          
045C77 3E 0D       1371*      ld a,13       ; restore the final byte of the command
045C79 32 8A 5C 04 1372*      ld (@cmd+2),a ; string that got stomped on by bcu
045C7D 21 88 5C 04 1373*      ld hl,@cmd
045C81 01 07 00 00 1374*      ld bc,@end-@cmd
045C85 5B DF       1375*      rst.lil $18
045C87 C9          1376*      ret
045C88 17 1B 0D    1377*  @cmd:  db 23,27,13
045C8B 00 00       1378*  @xpos: dw 0x0000
045C8D 00 00       1379*  @ypos: dw 0x0000
045C8F             1380*  @end:  ; no padding required b/c we shifted de right
045C8F             1381*  
045C8F             1382*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045C8F             1383*  ; USING 16.8 FIXED POINT COORDINATES
045C8F             1384*  ; inputs: ub.c is dx, ud.e is dy
045C8F             1385*  ;   the fractional portiion of the inputs are truncated
045C8F             1386*  ;   leaving only the 16-bit integer portion
045C8F             1387*  ; prerequisites: vdu_sprite_select
045C8F             1388*  vdu_sprite_move_rel168:
045C8F             1389*  ; populate in the reverse of normal to keep the
045C8F             1390*  ; inputs from stomping on each other
045C8F ED 53 AE 5C 1391*      ld (@dy-1),de
       04          
045C94 ED 43 AC 5C 1392*      ld (@dx-1),bc
       04          
045C99 3E 0E       1393*      ld a,14       ; restore the final byte of the command
045C9B 32 AC 5C 04 1394*      ld (@cmd+2),a ; string that got stomped on by bcu
045C9F 21 AA 5C 04 1395*      ld hl,@cmd
045CA3 01 07 00 00 1396*      ld bc,@end-@cmd
045CA7 5B DF       1397*      rst.lil $18
045CA9 C9          1398*      ret
045CAA 17 1B 0E    1399*  @cmd:  db 23,27,14
045CAD 00 00       1400*  @dx: dw 0x0000
045CAF 00 00       1401*  @dy: dw 0x0000
045CB1             1402*  @end:  ; no padding required b/c we shifted de right
045CB1             1403*  
045CB1             1404*  ; VDU 23, 27, 15: Update the sprites in the GPU
045CB1             1405*  ; inputs: none
045CB1             1406*  vdu_sprite_update:
045CB1 21 BC 5C 04 1407*      ld hl,@cmd
045CB5 01 03 00 00 1408*      ld bc,@end-@cmd
045CB9 5B DF       1409*      rst.lil $18
045CBB C9          1410*      ret
045CBC 17 1B 0F    1411*  @cmd: db 23,27,15
045CBF             1412*  @end:
045CBF             1413*  
045CBF             1414*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045CBF             1415*  ; inputs: none
045CBF             1416*  vdu_sprite_bmp_reset:
045CBF 21 CA 5C 04 1417*      ld hl,@cmd
045CC3 01 03 00 00 1418*      ld bc,@end-@cmd
045CC7 5B DF       1419*      rst.lil $18
045CC9 C9          1420*      ret
045CCA 17 1B 10    1421*  @cmd: db 23,27,16
045CCD             1422*  @end:
045CCD             1423*  
045CCD             1424*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045CCD             1425*  ; inputs: none
045CCD             1426*  vdu_sprite_reset:
045CCD 21 D8 5C 04 1427*      ld hl,@cmd
045CD1 01 03 00 00 1428*      ld bc,@end-@cmd
045CD5 5B DF       1429*      rst.lil $18
045CD7 C9          1430*      ret
045CD8 17 1B 11    1431*  @cmd: db 23,27,17
045CDB             1432*  @end:
045CDB             1433*  
045CDB             1434*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045CDB             1435*  ; inputs: a is the GCOL paint mode
045CDB             1436*  ; prerequisites: vdu_sprite_select
045CDB             1437*  vdu_sprite_set_gcol:
045CDB 32 ED 5C 04 1438*      ld (@mode),a
045CDF 21 EA 5C 04 1439*      ld hl,@cmd
045CE3 01 04 00 00 1440*      ld bc,@end-@cmd
045CE7 5B DF       1441*      rst.lil $18
045CE9 C9          1442*      ret
045CEA 17 1B 12    1443*  @cmd:  db 23,27,18
045CED 00          1444*  @mode: db 0x00
045CEE             1445*  @end:
045CEE             1446*  
045CEE             1447*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
045CEE             1448*  ;     as a frame to current sprite using a 16-bit buffer ID
045CEE             1449*  ; inputs: hl=bufferId
045CEE             1450*  ; prerequisites: vdu_sprite_select
045CEE             1451*  vdu_sprite_add_buff:
045CEE 22 00 5D 04 1452*      ld (@bufferId),hl
045CF2 21 FD 5C 04 1453*      ld hl,@cmd
045CF6 01 05 00 00 1454*      ld bc,@end-@cmd
045CFA 5B DF       1455*      rst.lil $18
045CFC C9          1456*      ret
045CFD 17 1B 26    1457*  @cmd:      db 23,27,0x26
045D00 00 00       1458*  @bufferId: dw 0x0000
045D02 00          1459*  @end:      db 0x00 ; padding
045D03             1460*  
045D03             1461*  
045D03             1462*  ; #### from sfx.inc ####
045D03 00          1463*  sfx_last_channel: db 0x00 ; 8-bit value between 0 and 31
045D04             1464*  
045D04             1465*  ; ; play a sound effect on the next available channel at full volume for its full duration
045D04             1466*  ; ; inputs: hl = bufferId
045D04             1467*  ; sfx_play:
045D04             1468*  ; 	ld iy,sfx_last_channel
045D04             1469*  ; 	ld a,(iy+0)
045D04             1470*  ; 	ld (@bufferId),hl
045D04             1471*  ; @find_next_channel:
045D04             1472*  ; 	inc a ; bump to next channel
045D04             1473*  ; 	and 31 ; modulo 32 channel
045D04             1474*  ; 	cp (iy+0) ; if this is zero we've wrapped around and not found a free channel
045D04             1475*  ; 	ret z ; so we return to caller without doing anything
045D04             1476*  ; 	push af ; back up channel
045D04             1477*  ; 	call vdu_channel_status ; a comes back with channel status bitmask
045D04             1478*  ; 	and %00000010 ; bit 1 is the "is playing" flag
045D04             1479*  ; 	jr z,@play_sfx ; if not playing, we can use this channel
045D04             1480*  ; 	pop af ; restore channel
045D04             1481*  ; 	jr @find_next_channel ; try the next channel
045D04             1482*  ; @play_sfx:
045D04             1483*  ; 	pop af ; restore channel
045D04             1484*  ; 	ld (iy+0),a ; store channel
045D04             1485*  ; 	ld hl,(@bufferId)
045D04             1486*  ; 	ld c,a ; channel
045D04             1487*  ; 	ld b,127 ; full volume
045D04             1488*  ; 	ld de,1000 ; 1 second duration (should have no effect)
045D04             1489*  ; 	jp vdu_play_sample
045D04             1490*  ; @bufferId:
045D04             1491*  ; 	dw 0x0000 ; 16-bit value
045D04             1492*  
045D04             1493*  vdu_clear_all_buffers:
045D04             1494*  ; clear all buffers
045D04 21 0F 5D 04 1495*      ld hl,@beg
045D08 01 06 00 00 1496*      ld bc,@end-@beg
045D0C 5B DF       1497*      rst.lil $18
045D0E C9          1498*      ret
045D0F 17 00 A0    1499*  @beg: db 23,0,$A0
045D12 FF FF       1500*        dw -1 ; clear all buffers
045D14 02          1501*        db 2  ; command 2: clear a buffer
045D15             1502*  @end:
045D15             0056       include "src/asm/vdu_buff.inc"
045D15             0001*  ; VDP Buffered Commands API
045D15             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
045D15             0003*  
045D15             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045D15             0005*  ; This command is used to store a data block (a sequence of bytes)
045D15             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
045D15             0007*  ; It could be a sequence of VDU commands which can be executed
045D15             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
045D15             0009*  ; When used for a sequence of VDU commands, this effectively
045D15             0010*  ; allows for functions or stored procedures to be created.
045D15             0011*  
045D15             0012*  ; This is the most common command to use to send data to the VDP.
045D15             0013*  ; Typically you will call command 2 first to ensure that the
045D15             0014*  ; buffer is empty, and then make a series of calls to this command
045D15             0015*  ; to send data to the buffer.
045D15             0016*  
045D15             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
045D15             0018*  ; write to. Writing to the same buffer ID multiple times will add
045D15             0019*  ; new blocks to that buffer. This allows a buffer to be built up
045D15             0020*  ; over time, essentially allowing for a command to be sent across
045D15             0021*  ; to the VDP in multiple separate packets.
045D15             0022*  
045D15             0023*  ; Whilst the length of an individual block added using this command
045D15             0024*  ; is restricted to 65535 bytes (as the largest value that can be
045D15             0025*  ; sent in a 16-bit number) the total size of a buffer is not
045D15             0026*  ; restricted to this size, as multiple blocks can be added to a
045D15             0027*  ; buffer. Given how long it takes to send data to the VDP it is
045D15             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
045D15             0029*  ; data or less at a time.
045D15             0030*  
045D15             0031*  ; As writing to a single buffer ID is cumulative with this command,
045D15             0032*  ; care should be taken to ensure that the buffer is cleared out
045D15             0033*  ; before writing to it.
045D15             0034*  
045D15             0035*  ; When building up a complex sequence of commands it is often
045D15             0036*  ; advisable to use multiple blocks within a buffer. Typically
045D15             0037*  ; this is easier to code, as otherwise working out exactly how
045D15             0038*  ; many bytes long a command sequence is can be can be onerously
045D15             0039*  ; difficult. It is also easier to modify a command sequences that
045D15             0040*  ; are broken up into multiple blocks.
045D15             0041*  
045D15             0042*  ; As mentioned above it is advisable to send large pieces of data,
045D15             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
045D15             0044*  ; each packet of data sent to a buffer, the user can then perform
045D15             0045*  ; other operations, such as updating the screen to indicate
045D15             0046*  ; progress. This allows for long-running operations to be performed
045D15             0047*  ; without blocking the screen, and larger amounts of data to be
045D15             0048*  ; transferred over to the VDP than may otherwise be practical given
045D15             0049*  ; the limitations of the eZ80.
045D15             0050*  
045D15             0051*  ; If a buffer ID of 65535 is used then this command will be
045D15             0052*  ; ignored, and the data discarded. This is because this buffer ID
045D15             0053*  ; is reserved for special functions.
045D15             0054*  
045D15             0055*  ; Using buffers for bitmaps
045D15             0056*  
045D15             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
045D15             0058*  ; they cannot be used if they are spread over multiple blocks.
045D15             0059*  ; To use a bitmap its data must be in a single contiguous block,
045D15             0060*  ; and this is achieved by using the “consolidate” command &0E.
045D15             0061*  
045D15             0062*  ; Once you have a block that is ready to be used for a bitmap,
045D15             0063*  ; the buffer must be selected, and then a bitmap created for that
045D15             0064*  ; buffer using the bitmap and sprites API. This is done with the
045D15             0065*  ; following commands:
045D15             0066*  
045D15             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
045D15             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
045D15             0069*  
045D15             0070*  ; Until the “create bitmap” call has been made the buffer cannot
045D15             0071*  ; be used as a bitmap. That is because the system needs to
045D15             0072*  ; understand the dimensions of the bitmap, as well as the format
045D15             0073*  ; of the data. Usually this only needs to be done once. The format
045D15             0074*  ; is given as an 8-bit value, with the following values supported:
045D15             0075*  ; Value 	Type 	Description
045D15             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
045D15             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
045D15             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
045D15             0079*  
045D15             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
045D15             0081*  ; and these are automatically stored in buffers numbered 64000-64255
045D15             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
045D15             0083*  ; simply a matter of adding 64000. All bitmaps created with that
045D15             0084*  ; API will be RGBA8888 format.
045D15             0085*  
045D15             0086*  ; There is one other additional call added to the bitmap and
045D15             0087*  ; sprites API, which allows for bitmaps referenced with a
045D15             0088*  ; buffer ID to be added to sprites. This is done with the
045D15             0089*  ; following command:
045D15             0090*  
045D15             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
045D15             0092*  
045D15             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
045D15             0094*  
045D15             0095*  ; It should be noted that it is possible to modify the buffer
045D15             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
045D15             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
045D15             0098*  ; can allow you to do things such as changing colours in a bitmap,
045D15             0099*  ; or flipping an image horizontally or vertically. This will even
045D15             0100*  ; work on bitmaps that are being used inside sprites.
045D15             0101*  
045D15             0102*  ; Using commands targetting a buffer that create new blocks,
045D15             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
045D15             0104*  ; and remove it from use.
045D15             0105*  
045D15             0106*  ; Using buffers for sound samples
045D15             0107*  
045D15             0108*  ; Much like with bitmaps, it is advisable to send samples over
045D15             0109*  ; to the VDP in multiple blocks for the same reasons.
045D15             0110*  
045D15             0111*  ; In contrast to bitmaps, the sound system can play back samples
045D15             0112*  ; that are spread over multiple blocks, so there is no need to
045D15             0113*  ; consolidate buffers. As a result of this, the sample playback
045D15             0114*  ; system is also more tolerant of modifications being made to
045D15             0115*  ; the buffer after a sample has been created from it, even if
045D15             0116*  ; the sample is currently playing. It should be noted that
045D15             0117*  ; splitting a buffer may result in unexpected behaviour if
045D15             0118*  ; the sample is currently playing, such as skipping to other
045D15             0119*  ; parts of the sample.
045D15             0120*  
045D15             0121*  ; Once you have a buffer that contains block(s) that are ready
045D15             0122*  ; to be used for a sound sample, the following command must be
045D15             0123*  ; used to indicate that a sample should be created from that buffer:
045D15             0124*  
045D15             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
045D15             0126*  
045D15             0127*  ; The format parameter is an 8-bit value that indicates the
045D15             0128*  ; format of the sample data. The following values are supported:
045D15             0129*  ; Value 	Description
045D15             0130*  ; 0 	8-bit signed, 16KHz
045D15             0131*  ; 1 	8-bit unsigned, 16KHz
045D15             0132*  
045D15             0133*  ; Once a sample has been created in this way, the sample can
045D15             0134*  ; be selected for use on a channel using the following command:
045D15             0135*  
045D15             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
045D15             0137*  
045D15             0138*  ; Samples uploaded using the existing “load sample” command
045D15             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
045D15             0140*  ; are also stored in buffers automatically. A sample number using this system is in
045D15             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
045D15             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
045D15             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
045D15             0144*  ; buffer 64257, and so on.
045D15             0145*  ; Command 1: Call a buffer
045D15             0146*  
045D15             0147*  ; VDU 23, 0 &A0, bufferId; 1
045D15             0148*  
045D15             0149*  ; This command will attempt to execute all of the commands
045D15             0150*  ; stored in the buffer with the given ID. If the buffer does
045D15             0151*  ; not exist, or is empty, then this command will do nothing.
045D15             0152*  
045D15             0153*  ; Essentially, this command passes the contents of the buffer
045D15             0154*  ; to the VDP’s VDU command processor system, and executes them
045D15             0155*  ; as if they were sent directly to the VDP.
045D15             0156*  
045D15             0157*  ; As noted against command 0, it is possible to build up a
045D15             0158*  ; buffer over time by sending across multiple commands to write
045D15             0159*  ; to the same buffer ID. When calling a buffer with multiple
045D15             0160*  ; blocks, the blocks are executed in order.
045D15             0161*  
045D15             0162*  ; Care should be taken when using this command within a buffer,
045D15             0163*  ; as it is possible to create an infinite loop. For instance,
045D15             0164*  ; if a buffer contains a command to call itself, then this will
045D15             0165*  ; result in an infinite loop. This will cause the VDP to hang,
045D15             0166*  ; and the only way to recover from this is to reset the VDP.
045D15             0167*  
045D15             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
045D15             0169*  ; to be executed. This can be useful for creating loops within
045D15             0170*  ; a buffer. It will be ignored if used outside of a buffered
045D15             0171*  ; command sequence.
045D15             0172*  
045D15             0173*  ; Command 2: Clear a buffer
045D15             0174*  ; VDU 23, 0 &A0, bufferId; 2
045D15             0175*  
045D15             0176*  ; This command will clear the buffer with the given ID. If
045D15             0177*  ; the buffer does not exist then this command will do nothing.
045D15             0178*  
045D15             0179*  ; Please note that this clears out all of the blocks sent to
045D15             0180*  ; a buffer via command 0, not just the last one. i.e. if you
045D15             0181*  ; have built up a buffer over time by sending multiple commands
045D15             0182*  ; to write to the same buffer ID, this command will clear out
045D15             0183*  ; all of those commands.
045D15             0184*  
045D15             0185*  ; Calling this command with a bufferId value of -1 (65535) will
045D15             0186*  ; clear out all buffers.
045D15             0187*  
045D15             0188*  ; Command 3: Create a writeable buffer
045D15             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
045D15             0190*  ; This command will create a new writeable buffer with the given
045D15             0191*  ; ID. If a buffer with the given ID already exists then this
045D15             0192*  ; command will do nothing. This command is primarily intended
045D15             0193*  ; for use to create a buffer that can be used to capture output
045D15             0194*  ; using the “set output stream” command (see below), or to store
045D15             0195*  ; data that can be used for other commands.
045D15             0196*  
045D15             0197*  ; It is generally quite rare that you will want to use this
045D15             0198*  ; command. Typically you will instead want to use command 0
045D15             0199*  ; to write data to a buffer. It is not necessary to use this
045D15             0200*  ; command before using command 0, and indeed doing so will
045D15             0201*  ; lead to errors as you will end up with two blocks in the
045D15             0202*  ; buffer, the first of which will be empty. If you do wish
045D15             0203*  ; to use this command to create a buffer for data and then
045D15             0204*  ; write to it, you would need to use operation 2 of command 5,
045D15             0205*  ; the “set” operation in the “buffer adjust” command, to set a
045D15             0206*  ; sequence of bytes in the buffer to the data you want to write.
045D15             0207*  ; This is not recommended, as it is much easier to just use
045D15             0208*  ; command 0 to write a data block to a buffer.
045D15             0209*  
045D15             0210*  ; This new buffer will be a single empty single block upon
045D15             0211*  ; creation, containing zeros.
045D15             0212*  
045D15             0213*  ; The length parameter is a 16-bit integer that specifies
045D15             0214*  ; the maximum size of the buffer. This is the maximum number
045D15             0215*  ; of bytes that can be stored in the buffer. If the buffer
045D15             0216*  ; is full then no more data can be written to it, and subsequent
045D15             0217*  ; writes will be ignored.
045D15             0218*  
045D15             0219*  ; After creating a buffer with this command it is possible to
045D15             0220*  ; use command 0 to write further blocks to the buffer, however
045D15             0221*  ; this is probably not advisable.
045D15             0222*  
045D15             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
045D15             0224*  ; values have special meanings for writable buffers. See command 4.
045D15             0225*  
045D15             0226*  ; Command 4: Set output stream to a buffer
045D15             0227*  ; VDU 23, 0 &A0, bufferId; 4
045D15             0228*  
045D15             0229*  ; Sets then current output stream to the buffer with the given ID.
045D15             0230*  ; With two exceptions, noted below, this needs to be a writable
045D15             0231*  ; buffer created with command 3. If the buffer does not exist,
045D15             0232*  ; or the first block within the buffer is not writable, then
045D15             0233*  ; this command will do nothing.
045D15             0234*  
045D15             0235*  ; Following this command, any subsequent VDU commands that send
045D15             0236*  ; response packets will have those packets written to the specified
045D15             0237*  ; output buffer. This allows the user to capture the response
045D15             0238*  ; packets from a command sent to the VDP.
045D15             0239*  
045D15             0240*  ; By default, the output stream (for the main VDU command processor)
045D15             0241*  ; is the communications channel from the VDP to MOS running on the
045D15             0242*  ; eZ80.
045D15             0243*  
045D15             0244*  ; Passing a buffer ID of -1 (65535) to this command will
045D15             0245*  ; remove/detach the output buffer. From that point onwards,
045D15             0246*  ; any subsequent VDU commands that send response packets will
045D15             0247*  ; have those responses discarded/ignored.
045D15             0248*  
045D15             0249*  ; Passing a buffer ID of 0 to this command will set the output
045D15             0250*  ; buffer back to its original value for the current command stream.
045D15             0251*  ; Typically that will be the communications channel from the VDP to
045D15             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
045D15             0253*  ; call has been made.
045D15             0254*  
045D15             0255*  ; When used inside a buffered command sequence, this command will
045D15             0256*  ; only affect the output stream for that sequence of commands, and
045D15             0257*  ; any other buffered command sequences that are called from within
045D15             0258*  ; that sequence. Once the buffered command sequence has completed,
045D15             0259*  ; the output stream will effectively be reset to its original value.
045D15             0260*  
045D15             0261*  ; It is strongly recommended to only use this command from within a
045D15             0262*  ; buffered command sequence. Whilst it is possible to use this
045D15             0263*  ; command from within a normal VDU command sequence, it is not
045D15             0264*  ; recommended as it may cause unexpected behaviour. If you do use
045D15             0265*  ; it in that context, it is very important to remember to restore
045D15             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
045D15             0267*  ; future, this command may be disabled from being used outside of
045D15             0268*  ; a buffered command sequence.)
045D15             0269*  
045D15             0270*  ; At present, writable buffers can only be written to until the end
045D15             0271*  ; of the buffer has been reached; once that happens no more data
045D15             0272*  ; will be written to the buffer. It is not currently possible to
045D15             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
045D15             0274*  ; that the buffer is large enough to capture all of the data that
045D15             0275*  ; is expected to be written to it. The only current way to “rewind”
045D15             0276*  ; an output stream would be to clear the buffer and create a new
045D15             0277*  ; one, and then call set output stream again with the newly created
045D15             0278*  ; buffer.
045D15             0279*  
045D15             0280*  ; Command 5: Adjust buffer contents
045D15             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
045D15             0282*  
045D15             0283*  ; This command will adjust the contents of a buffer, at a given
045D15             0284*  ; offset. The exact nature of the adjustment will depend on the
045D15             0285*  ; operation used.
045D15             0286*  
045D15             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
045D15             0288*  ; the contents of the current buffer. This will only work if this
045D15             0289*  ; command is used within a buffered command sequence, otherwise the
045D15             0290*  ; command will not do anything.
045D15             0291*  
045D15             0292*  ; The basic set of adjustment operations are as follows:
045D15             0293*  ; Operation 	Description
045D15             0294*  ; 0 	NOT
045D15             0295*  ; 1 	Negate
045D15             0296*  ; 2 	Set value
045D15             0297*  ; 3 	Add
045D15             0298*  ; 4 	Add with carry
045D15             0299*  ; 5 	AND
045D15             0300*  ; 6 	OR
045D15             0301*  ; 7 	XOR
045D15             0302*  
045D15             0303*  ; All of these operations will modify a byte found at the given
045D15             0304*  ; offset in the buffer. The only exception to that is the “Add with
045D15             0305*  ; carry” operation, which will also store the “carry” value in the
045D15             0306*  ; byte at the next offset. With the exception of NOT and Negate,
045D15             0307*  ; each command requires an operand value to be specified.
045D15             0308*  
045D15             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
045D15             0310*  ; need to use the NOT operation, and so the following command would
045D15             0311*  ; be used:
045D15             0312*  
045D15             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
045D15             0314*  
045D15             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
045D15             0316*  ; to use the Add operation, and so the following command would be
045D15             0317*  ; used:
045D15             0318*  
045D15             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
045D15             0320*  
045D15             0321*  ; When using add with carry, the carry value is stored in the byte
045D15             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
045D15             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
045D15             0324*  ; you would need to use the Add with carry operation, and so the
045D15             0325*  ; following command would be used:
045D15             0326*  
045D15             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
045D15             0328*  
045D15             0329*  ; Advanced operations
045D15             0330*  
045D15             0331*  ; Whilst these operations are useful, they are not particularly
045D15             0332*  ; powerful as they only operate one one byte at a time, with a
045D15             0333*  ; fixed operand value, and potentially cannot reach all bytes in
045D15             0334*  ; a buffer. To address this, the API supports a number of advanced
045D15             0335*  ; operations.
045D15             0336*  
045D15             0337*  ; The operation value used is an 8-bit value that can have bits
045D15             0338*  ; set to modify the behaviour of the operation. The following bits
045D15             0339*  ; are defined:
045D15             0340*  ; Bit 	Description
045D15             0341*  ; &10 	Use “advanced” offsets
045D15             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045D15             0343*  ; &40 	Multiple target values should be adjusted
045D15             0344*  ; &80 	Multiple operand values should be used
045D15             0345*  
045D15             0346*  ; These bits can be combined together to modify the behaviour of
045D15             0347*  ; the operation.
045D15             0348*  
045D15             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
045D15             0350*  ; offset one byte at a time. When either of the “multiple” variants
045D15             0351*  ; are used, a 16-bit count must be provided to indicate how many
045D15             0352*  ; bytes should be altered.
045D15             0353*  
045D15             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
045D15             0355*  ; order, which can allow for buffers that are larger than 64kb
045D15             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
045D15             0357*  ; the 16-bit value immediately following the offset is used as a
045D15             0358*  ; block index number, and the remaining 23-bits of the offset value
045D15             0359*  ; are used as an offset within that block. When the “advanced”
045D15             0360*  ; offset mode bit has been set then all offsets associated with
045D15             0361*  ; this command must be sent as advanced offsets.
045D15             0362*  
045D15             0363*  ; The “buffer-fetched value” mode allows for the operand value to
045D15             0364*  ; be fetched from a buffer. The operand sent as part of the
045D15             0365*  ; command in this case is a pair of 16-bit values giving the
045D15             0366*  ; buffer ID and offset to indicate where the actual operand value
045D15             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
045D15             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
045D15             0369*  ; used inside a buffered command sequence. If the advanced offset
045D15             0370*  ; mode is used, then the operand value is an advanced offset value.
045D15             0371*  
045D15             0372*  ; The “multiple target values” mode allows for multiple bytes to
045D15             0373*  ; be adjusted at once. When this mode is used, the count value
045D15             0374*  ; must be provided to indicate how many bytes should be adjusted.
045D15             0375*  ; Unless the “multiple operand values” mode is also used, the
045D15             0376*  ; operand value is used for all bytes adjusted.
045D15             0377*  
045D15             0378*  ; The “multiple operand values” mode allows for multiple operand
045D15             0379*  ; values to be used. When this mode is used, the count value must
045D15             0380*  ; be provided to indicate how many operand values should be used.
045D15             0381*  ; This can allow, for instance, to add together several bytes in a
045D15             0382*  ; buffer. When this mode is used in conjunction with the “multiple
045D15             0383*  ; target values” mode, the number of operand values must match the
045D15             0384*  ; number of target values, and the operation happens one byte at a
045D15             0385*  ; time.
045D15             0386*  
045D15             0387*  ; Some examples of advanced operations are as follows:
045D15             0388*  
045D15             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
045D15             0390*  
045D15             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
045D15             0392*  
045D15             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
045D15             0394*  ; modifier (&40).
045D15             0395*  
045D15             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
045D15             0397*  
045D15             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
045D15             0399*  
045D15             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
045D15             0401*  
045D15             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
045D15             0403*  
045D15             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
045D15             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
045D15             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
045D15             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
045D15             0408*  ; in little-endian order. As the top bit of the offset is set, this
045D15             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
045D15             0410*  ; Finally the value to write is sent, 42.
045D15             0411*  
045D15             0412*  ; An operation like this could be used to set the position as part
045D15             0413*  ; of a draw command.
045D15             0414*  
045D15             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
045D15             0416*  ; values 1, 2, 3, 4, 5:
045D15             0417*  
045D15             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
045D15             0419*  ; offset 12 (set it to 0)
045D15             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
045D15             0421*  
045D15             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
045D15             0423*  ; 7 bytes in buffer 4 starting at offset 42:
045D15             0424*  
045D15             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
045D15             0426*  
045D15             0427*  ; As we are working on a little-endian system, integers longer
045D15             0428*  ; than one byte are sent with their least significant byte first.
045D15             0429*  ; This means that the add with carry operation can be used to add
045D15             0430*  ; together integers of any size, so long as they are the same size.
045D15             0431*  ; To do this, both the “multiple target values” and “multiple
045D15             0432*  ; operand values” modes must be used.
045D15             0433*  
045D15             0434*  ; The following commands will add together a 16-bit, 24-bit,
045D15             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
045D15             0436*  ; in buffer 3 starting at offset 12, and all using the operand
045D15             0437*  ; value of 42:
045D15             0438*  
045D15             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
045D15             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
045D15             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
045D15             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
045D15             0443*  
045D15             0444*  ; Take note of how the operand value is padded out with zeros
045D15             0445*  ; to match the size of the target value. 42; is used as a base
045D15             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
045D15             0447*  ; 16-bits to pad it out to the required size. The “carry” value
045D15             0448*  ; will be stored at the next offset in the target buffer after
045D15             0449*  ; the complete target value. So for a 16-bit value, the carry
045D15             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
045D15             0451*  ; at offset 15, and so on.
045D15             0452*  
045D15             0453*  ; Command 6: Conditionally call a buffer
045D15             0454*  
045D15             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
045D15             0456*  
045D15             0457*  ; This command will conditionally call a buffer if the condition
045D15             0458*  ; operation passes. This command works in a similar manner to the
045D15             0459*  ; “Adjust buffer contents” command.
045D15             0460*  
045D15             0461*  ; With this command a buffer ID of 65535 (-1) is always
045D15             0462*  ; interpretted as “current buffer”, and so can only be used
045D15             0463*  ; within a buffered command sequence. If used outside of a
045D15             0464*  ; buffered command sequence then this command will do nothing.
045D15             0465*  
045D15             0466*  ; The basic set of condition operations are as follows:
045D15             0467*  ; Operation 	Description
045D15             0468*  ; 0 	Exists (value is non-zero)
045D15             0469*  ; 1 	Not exists (value is zero)
045D15             0470*  ; 2 	Equal
045D15             0471*  ; 3 	Not equal
045D15             0472*  ; 4 	Less than
045D15             0473*  ; 5 	Greater than
045D15             0474*  ; 6 	Less than or equal
045D15             0475*  ; 7 	Greater than or equal
045D15             0476*  ; 8 	AND
045D15             0477*  ; 9 	OR
045D15             0478*  
045D15             0479*  ; The value that is being checked is fetched from the specified
045D15             0480*  ; check buffer ID and offset. With the exception of “Exists” and
045D15             0481*  ; “Not exists”, each command requires an operand value to be
045D15             0482*  ; specified to check against.
045D15             0483*  
045D15             0484*  ; The operation value used is an 8-bit value that can have bits
045D15             0485*  ; set to modify the behaviour of the operation. The following bits
045D15             0486*  ; are defined:
045D15             0487*  ; Bit value 	Description
045D15             0488*  ; &10 	Use advanced offsets
045D15             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045D15             0490*  
045D15             0491*  ; These modifiers can be combined together to modify the behaviour
045D15             0492*  ; of the operation.
045D15             0493*  
045D15             0494*  ; At this time, unlike with the “adjust” command, multiple target
045D15             0495*  ; values and multiple operand values are not supported. All
045D15             0496*  ; comparisons are therefore only conducted on single 8-bit values.
045D15             0497*  ; (If comparisons of 16-bit values are required, multiple calls
045D15             0498*  ; can be combined.) Support for them may be added in the future.
045D15             0499*  
045D15             0500*  ; The AND and OR operations are logical operations, and so the
045D15             0501*  ; operand value is used as a boolean value. Any non-zero value is
045D15             0502*  ; considered to be true, and zero is considered to be false. These
045D15             0503*  ; operations therefore are most useful when used with buffer-fetched
045D15             0504*  ; operand values (operations &28, &29, &38 and &39).
045D15             0505*  
045D15             0506*  ; Some examples of condition operations are as follows:
045D15             0507*  
045D15             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
045D15             0509*  ; (is non-zero):
045D15             0510*  
045D15             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045D15             0512*  
045D15             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
045D15             0514*  ; exist (is zero):
045D15             0515*  
045D15             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045D15             0517*  
045D15             0518*  ; Combining the above two examples is effectively equivalent to
045D15             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
045D15             0520*  
045D15             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045D15             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045D15             0523*  
045D15             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
045D15             0525*  
045D15             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
045D15             0527*  
045D15             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
045D15             0529*  ; the value in buffer 2 at offset 8:
045D15             0530*  
045D15             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
045D15             0532*  
045D15             0533*  ; Command 7: Jump to a buffer
045D15             0534*  
045D15             0535*  ; VDU 23, 0, &A0, bufferId; 7
045D15             0536*  
045D15             0537*  ; This command will jump to the buffer with the given ID. If
045D15             0538*  ; the buffer does not exist, or is empty, then this command will
045D15             0539*  ; do nothing.
045D15             0540*  
045D15             0541*  ; This essentially works the same as the call command (command 1),
045D15             0542*  ;  except that it does not return to the caller. This command is
045D15             0543*  ;  therefore useful for creating loops.
045D15             0544*  
045D15             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
045D15             0546*  ; treated as a “jump to end of current buffer”. This will return
045D15             0547*  ; execution to the caller, and can be useful for exiting a loop.
045D15             0548*  
045D15             0549*  ; ## Command 8: Conditional Jump to a buffer
045D15             0550*  
045D15             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
045D15             0552*  
045D15             0553*  ; This command operates in a similar manner to the “Conditionally
045D15             0554*  ; call a buffer” command (command 6), except that it will jump to
045D15             0555*  ; the buffer if the condition operation passes.
045D15             0556*  
045D15             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
045D15             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
045D15             0559*  ; Command 9: Jump to an offset in a buffer
045D15             0560*  
045D15             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
045D15             0562*  
045D15             0563*  ; This command will jump to the given offset in the buffer with the
045D15             0564*  ; given ID. If the buffer does not exist, or is empty, then this
045D15             0565*  ; command will do nothing.
045D15             0566*  
045D15             0567*  ; The offset in this command is always an “advanced” offset, given
045D15             0568*  ; as a 24-bit value in little-endian order. As with other uses of
045D15             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
045D15             0570*  ; offset value, a block number must also be provided.
045D15             0571*  
045D15             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
045D15             0573*  ; meaning “jump within current buffer”. This can be useful for
045D15             0574*  ; creating loops within a buffer, or when building up command
045D15             0575*  ; sequences that may be copied across multiple buffers.
045D15             0576*  
045D15             0577*  ; Jumping to an offset that is beyond the end of the buffer is
045D15             0578*  ; equivalent to jumping to the end of the buffer.
045D15             0579*  ; Command 10: Conditional jump to an offset in a buffer
045D15             0580*  
045D15             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
045D15             0582*  
045D15             0583*  ; A conditional jump with an offset works in a similar manner to
045D15             0584*  ; the “Conditional call a buffer” command (command 6), except that
045D15             0585*  ; it will jump to the given offset in the buffer if the condition
045D15             0586*  ; operation passes.
045D15             0587*  
045D15             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
045D15             0589*  ; the offset in this command is always an “advanced” offset, given
045D15             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
045D15             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
045D15             0592*  ; treated as meaning “jump within current buffer”.
045D15             0593*  ; Command 11: Call buffer with an offset
045D15             0594*  
045D15             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
045D15             0596*  
045D15             0597*  ; Works just like “Call a buffer” (command 1), except that it also
045D15             0598*  ; accepts an advanced offset.
045D15             0599*  
045D15             0600*  ; Command 12: Conditional call buffer with an offset
045D15             0601*  
045D15             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
045D15             0603*  
045D15             0604*  ; Works just like the “Conditional call a buffer” command
045D15             0605*  ; (command 6), except that it also accepts an advanced offset.
045D15             0606*  
045D15             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
045D15             0608*  
045D15             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
045D15             0610*  
045D15             0611*  ; This command will copy the contents of multiple buffers into a
045D15             0612*  ; single buffer. The buffers to copy from are specified as a list
045D15             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
045D15             0614*  ; buffers are copied in the order they are specified.
045D15             0615*  
045D15             0616*  ; This is a block-wise copy, so the blocks from the source buffers
045D15             0617*  ; are copied into the target buffer. The blocks are copied in the
045D15             0618*  ; order they are found in the source buffers.
045D15             0619*  
045D15             0620*  ; The target buffer will be overwritten with the contents of the
045D15             0621*  ; source buffers. This will not be done however until after all the
045D15             0622*  ; data has been gathered and copied. The target buffer can therefore
045D15             0623*  ; included in the list of the source buffers.
045D15             0624*  
045D15             0625*  ; If a source buffer that does not exist is specified, or a source
045D15             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
045D15             0627*  
045D15             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
045D15             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
045D15             0630*  ; copied multiple times into the target buffer.
045D15             0631*  
045D15             0632*  ; If there is insufficient memory available on the VDP to complete
045D15             0633*  ; this command then it will fail, and the target buffer will be
045D15             0634*  ; left unchanged.
045D15             0635*  
045D15             0636*  
045D15             0637*  ; Command 14: Consolidate blocks in a buffer
045D15             0638*  
045D15             0639*  ; VDU 23, 0, &A0, bufferId; 14
045D15             0640*  
045D15             0641*  ; Takes all the blocks in a buffer and consolidates them into a
045D15             0642*  ; single block. This is useful for bitmaps, as it allows for a
045D15             0643*  ; bitmap to be built up over time in multiple blocks, and then
045D15             0644*  ; consolidated into a single block for use as a bitmap.
045D15             0645*  
045D15             0646*  ; If there is insufficient memory available on the VDP to complete
045D15             0647*  ; this command then it will fail, and the buffer will be left
045D15             0648*  ; unchanged.
045D15             0649*  
045D15             0650*  ; Command 15: Split a buffer into multiple blocks
045D15             0651*  
045D15             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
045D15             0653*  
045D15             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
045D15             0655*  ; is a 16-bit integer that specifies the target size of each block.
045D15             0656*  ; If the source data is not a multiple of the block size then the
045D15             0657*  ; last block will be smaller than the specified block size.
045D15             0658*  
045D15             0659*  ; If this command is used on a buffer that is already split into
045D15             0660*  ; multiple blocks, then the blocks will be consolidated first,
045D15             0661*  ; and then re-split into the new block size.
045D15             0662*  
045D15             0663*  ; If there is insufficient memory available on the VDP to complete
045D15             0664*  ; this command then it will fail, and the buffer will be left
045D15             0665*  ; unchanged.
045D15             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
045D15             0667*  ; multiple buffers
045D15             0668*  
045D15             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
045D15             0670*  
045D15             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
045D15             0672*  ; then spreads the resultant blocks across the target buffers.
045D15             0673*  ; The target buffers are specified as a list of buffer IDs,
045D15             0674*  ; terminated by a buffer ID of -1 (65535).
045D15             0675*  
045D15             0676*  ; The blocks are spread across the target buffers in the order
045D15             0677*  ; they are specified, and the spread will loop around the buffers
045D15             0678*  ; until all the blocks have been distributed. The target buffers
045D15             0679*  ; will be cleared out before the blocks are spread across them.
045D15             0680*  
045D15             0681*  ; What this means is that if the source buffer is, let’s say,
045D15             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
045D15             0683*  ; then we will end up with 10 blocks. If we then spread those
045D15             0684*  ; blocks across 3 target buffers, then the first buffer will
045D15             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
045D15             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
045D15             0687*  ; blocks 3, 6 and 9.
045D15             0688*  
045D15             0689*  ; This command attempts to ensure that, in the event of
045D15             0690*  ; insufficient memory being available on the VDP to complete
045D15             0691*  ; the command, it will leave the targets as they were before
045D15             0692*  ; the command was executed. However this may not always be
045D15             0693*  ; possible. The first step of this command is to consolidate
045D15             0694*  ; the source buffer into a single block, and this may fail from
045D15             0695*  ; insufficient memory. If that happens then all the buffers will
045D15             0696*  ; be left as they were. After this however the target buffers
045D15             0697*  ; will be cleared. If there is insufficient memory to successfully
045D15             0698*  ; split the buffer into multiple blocks then the call will exit,
045D15             0699*  ; and the target buffers will be left empty.
045D15             0700*  ; Command 17: Split a buffer and spread across blocks, starting
045D15             0701*  ; at target buffer ID
045D15             0702*  
045D15             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
045D15             0704*  
045D15             0705*  ; As per the above two commands, this will split a buffer into
045D15             0706*  ; multiple blocks. It will then spread the blocks across buffers
045D15             0707*  ; starting at the target buffer ID, incrementing the target buffer
045D15             0708*  ; ID until all the blocks have been distributed.
045D15             0709*  
045D15             0710*  ; Target blocks will be cleared before a block is stored in them.
045D15             0711*  ; Each target will contain a single block. The exception to this
045D15             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
045D15             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
045D15             0714*  ; will be placed into buffer 65534.
045D15             0715*  
045D15             0716*  ; With this command if there is insufficient memory available on
045D15             0717*  ; the VDP to complete the command then it will fail, and the target
045D15             0718*  ; buffers will be left unchanged.
045D15             0719*  
045D15             0720*  ; Command 18: Split a buffer into blocks by width
045D15             0721*  
045D15             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
045D15             0723*  
045D15             0724*  ; This command splits a buffer into a given number of blocks by
045D15             0725*  ; first of all splitting the buffer into blocks of a given width
045D15             0726*  ; (number of bytes), and then consolidating those blocks into the
045D15             0727*  ; given number of blocks.
045D15             0728*  
045D15             0729*  ; This is useful for splitting a bitmap into a number of separate
045D15             0730*  ; columns, which can then be manipulated individually. This can be
045D15             0731*  ; useful for dealing with sprite sheets.
045D15             0732*  ; Command 19: Split by width into blocks and spread across target
045D15             0733*  ; buffers
045D15             0734*  
045D15             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
045D15             0736*  
045D15             0737*  ; This command essentially operates the same as command 18, but the
045D15             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
045D15             0739*  
045D15             0740*  ; Command 20: Split by width into blocks and spread across blocks
045D15             0741*  ; starting at target buffer ID
045D15             0742*  
045D15             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
045D15             0744*  
045D15             0745*  ; This command essentially operates the same as command 18, but
045D15             0746*  ; the generated blocks are spread across blocks starting at the
045D15             0747*  ; target buffer ID, as per command 17.
045D15             0748*  
045D15             0749*  ; Command 21: Spread blocks from a buffer across multiple target
045D15             0750*  ; buffers
045D15             0751*  
045D15             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
045D15             0753*  
045D15             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
045D15             0755*  ; The target buffers are specified as a list of buffer IDs,
045D15             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
045D15             0757*  ; across the target buffers in the order they are specified, and
045D15             0758*  ; the spread will loop around the buffers until all the blocks have
045D15             0759*  ; been distributed.
045D15             0760*  
045D15             0761*  ; It should be noted that this command does not copy the blocks,
045D15             0762*  ; and nor does it move them. Unless the source buffer has been
045D15             0763*  ; included in the list of targets, it will remain completely
045D15             0764*  ; intact. The blocks distributed across the target buffers will
045D15             0765*  ; point to the same memory as the blocks in the source buffer.
045D15             0766*  ; Operations to modify data in the source buffer will also modify
045D15             0767*  ; the data in the target buffers. Clearing the source buffer
045D15             0768*  ; however will not clear the target buffers.
045D15             0769*  
045D15             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
045D15             0771*  ; at target buffer ID
045D15             0772*  
045D15             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
045D15             0774*  
045D15             0775*  ; Spreads the blocks from a buffer across blocks starting at
045D15             0776*  ; the target buffer ID.
045D15             0777*  
045D15             0778*  ; This essentially works the same as command 21, and the same
045D15             0779*  ; notes about copying and moving blocks apply. Blocks are spread
045D15             0780*  ; in the same manner as commands 17 and 20.
045D15             0781*  
045D15             0782*  ; Command 23: Reverse the order of blocks in a buffer
045D15             0783*  
045D15             0784*  ; VDU 23, 0, &A0, bufferId; 23
045D15             0785*  
045D15             0786*  ; Reverses the order of the blocks in a buffer.
045D15             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
045D15             0788*  
045D15             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045D15             0790*  
045D15             0791*  ; Reverses the order of the data within the blocks of a buffer.
045D15             0792*  ; The options parameter is an 8-bit value that can have bits set
045D15             0793*  ; to modify the behaviour of the operation. The following bits
045D15             0794*  ; are defined:
045D15             0795*  ; Bit value 	Description
045D15             0796*  ; 1 	Values are 16-bits in size
045D15             0797*  ; 2 	Values are 32-bits in size
045D15             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
045D15             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
045D15             0800*  ; 8 	Reverse blocks
045D15             0801*  
045D15             0802*  ; These modifiers can be combined together to modify the behaviour
045D15             0803*  ; of the operation.
045D15             0804*  
045D15             0805*  ; If no value size is set in the options (i.e. the value of the
045D15             0806*  ; bottom two bits of the options is zero) then the value size is
045D15             0807*  ; assumed to be 8-bits.
045D15             0808*  
045D15             0809*  ; It is probably easiest to understand what this operation is
045D15             0810*  ; capable of by going through some examples of how it can be used
045D15             0811*  ; to manipulate bitmaps. The VDP supports two different formats
045D15             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
045D15             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
045D15             0814*  ; pixel.
045D15             0815*  
045D15             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
045D15             0817*  ; degrees, which can be done by just reversing the order of
045D15             0818*  ; bytes in the buffer:
045D15             0819*  
045D15             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
045D15             0821*  
045D15             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
045D15             0823*  ; little more complex, as each pixel is made up of 4 bytes.
045D15             0824*  ; However with this command it is still a simple operation, as
045D15             0825*  ; we can just reverse the order of the 32-bit values that make
045D15             0826*  ; up the bitmap by using an options value of 2:
045D15             0827*  
045D15             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
045D15             0829*  
045D15             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
045D15             0831*  ; the order of rows of pixels. To do this we can set a custom
045D15             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
045D15             0833*  ; bitmap we can just set a custom value size to our bitmap width:
045D15             0834*  
045D15             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
045D15             0836*  
045D15             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
045D15             0838*  ; our width by 4:
045D15             0839*  
045D15             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
045D15             0841*  
045D15             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
045D15             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
045D15             0844*  ; just set a custom chunk size to our bitmap width:
045D15             0845*  
045D15             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
045D15             0847*  
045D15             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
045D15             0849*  ; 32-bit values as well as a custom chunk size:
045D15             0850*  
045D15             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
045D15             0852*  
045D15             0853*  ; Command 25: Copy blocks from multiple buffers by reference
045D15             0854*  
045D15             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
045D15             0856*  
045D15             0857*  ; This command is essentially a version of command 13 that copies
045D15             0858*  ; blocks by reference rather than by value. The parameters for
045D15             0859*  ; this command are the same as for command 13, and the same rules
045D15             0860*  ; apply.
045D15             0861*  
045D15             0862*  ; If the target buffer is included in the list of source buffers
045D15             0863*  ; then it will be skipped to prevent a reference loop.
045D15             0864*  
045D15             0865*  ; Copying by reference means that the blocks in the target buffer
045D15             0866*  ; will point to the same memory as the blocks in the source
045D15             0867*  ; buffers. Operations to modify data blocks in the source buffers
045D15             0868*  ; will therefore also modify those blocks in the target buffer.
045D15             0869*  ; Clearing the source buffers will not clear the target buffer -
045D15             0870*  ; it will still point to the original data blocks. Data blocks
045D15             0871*  ; are only freed from memory when no buffers are left with any
045D15             0872*  ; references to them.
045D15             0873*  
045D15             0874*  ; Buffers that get consolidated become new blocks, so will lose
045D15             0875*  ; their links to the original blocks, thus after a “consolidate”
045D15             0876*  ; operation modifications to the original blocks will no longer be
045D15             0877*  ; reflected in the consolidated buffer.
045D15             0878*  
045D15             0879*  ; This command is useful to construct a single buffer from multiple
045D15             0880*  ; sources without the copy overhead, which can be costly. For
045D15             0881*  ; example, this can be useful for constructing a bitmap from
045D15             0882*  ; multiple constituent parts before consolidating it into a
045D15             0883*  ; single block. In such an example, using command 13 instead
045D15             0884*  ; would first make a copy of the contents of the source buffers,
045D15             0885*  ; and then consolidate them into a single block. Using this
045D15             0886*  ; command does not make that first copy, and so would be faster.
045D15             0887*  
045D15             0888*  ; This command is also useful for creating multiple buffers that
045D15             0889*  ; all point to the same data.
045D15             0890*  
045D15             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
045D15             0892*  
045D15             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
045D15             0057       ; include "src/asm/vdu_plot.inc"
045D15             0058   	; include "src/asm/vdu_sprites.inc"
045D15             0059   	; include "src/asm/vdp.inc"
045D15             0060   	include "src/asm/div_168_signed.inc"
045D15             0001*  ; 24-bit integer and 16.8 fixed point division routines
045D15             0002*  ; by Brandon R. Gates (BeeGee747)
045D15             0003*  ; have undergone cursory testing and seem to be generating
045D15             0004*  ; correct results (assuming no overflows) but seem very inefficient,
045D15             0005*  ; so they have been published for review and improvement
045D15             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
045D15             0007*  ;
045D15             0008*  ; ---------------------------------------------------------
045D15             0009*  ; BEGIN DIVISION ROUTINES
045D15             0010*  ; ---------------------------------------------------------
045D15             0011*  ;
045D15             0012*  ; perform signed division of 16.8 fixed place values
045D15             0013*  ; with an signed 16.8 fixed place result
045D15             0014*  ; inputs: ub.c is dividend,ud.e is divisor
045D15             0015*  ; outputs: uh.l is quotient
045D15             0016*  ; destroys: a,bc
045D15             0017*  ; note: uses carry flag to test for sign of operands and result
045D15             0018*  ;       which can be confusing and should perhaps be changed
045D15             0019*  ; note2: helper functions abs_hlu and neg_hlu have been modified
045D15             0020*  ;       to return accurate flags according to the origional signs
045D15             0021*  ;       (or zero) of this function's inputs
045D15             0022*  sdiv168:
045D15             0023*  ; make everything positive and save signs
045D15 C5          0024*      push bc         ; get bc to hl
045D16 E1          0025*      pop hl          ; for the next call
045D17 CD BC 5D 04 0026*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
045D1B CA 4E 5D 04 0027*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045D1F F5          0028*      push af         ; save sign of bc
045D20 E5          0029*      push hl         ; now put abs(hl)
045D21 C1          0030*      pop bc          ; back into bc = abs(bc)
045D22 EB          0031*      ex de,hl        ; now we do de same way
045D23 CD BC 5D 04 0032*      call abs_hlu
045D27 CA 50 5D 04 0033*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
045D2B EB          0034*      ex de,hl        ; hl back to de = abs(de)
045D2C             0035*  ; determine sign of result
045D2C F2 37 5D 04 0036*      jp p,@de_pos    ; sign positive,de is positive
045D30 F1          0037*      pop af          ; get back sign of bc
045D31 FA 40 5D 04 0038*      jp m,@result_pos  ; bc and de negative, result is positive
045D35 18 05       0039*      jr @result_neg
045D37             0040*  @de_pos:
045D37 F1          0041*      pop af          ; get back sign of bc
045D38 F2 40 5D 04 0042*      jp p,@result_pos   ; bc and de are both positive so result is positive
045D3C             0043*                      ; fall through to result_neg
045D3C             0044*  @result_neg:
045D3C AF          0045*      xor a           ; zero a and clear carry
045D3D 3D          0046*      dec a           ; set sign flag to negative
045D3E 18 02       0047*      jr @do_div
045D40             0048*  @result_pos:
045D40 AF          0049*      xor a           ; zero a and clear carry
045D41 3C          0050*      inc a           ; set sign flag to negative
045D42             0051*                      ; fall through to do_div
045D42             0052*  @do_div:
045D42 F5          0053*      push af         ; save sign of result
045D43 CD 53 5D 04 0054*      call udiv168
045D47 F1          0055*      pop af          ; get back sign of result
045D48 F0          0056*      ret p           ; result is positive so nothing to do
045D49 CD CC 5D 04 0057*      call neg_hlu    ; result is negative so negate it
045D4D C9          0058*      ret
045D4E             0059*  @is_zero:           ; result is zero
045D4E AF          0060*      xor a           ; sets zero flag, which we want,
045D4F             0061*                      ; sets pv flag which we might not (zero is parity even)
045D4F             0062*                      ; resets all others which is okay
045D4F C9          0063*      ret
045D50             0064*  @div_by_zero:       ; result is undefined, which isn't defined in binary
045D50             0065*                      ; so we'll just return zero until i can think of something better
045D50 F1          0066*      pop af          ; dummy pop
045D51 AF          0067*      xor a           ; sets zero flag, which is ok,
045D52             0068*                      ; sets pv flag which could be interpreted as overflow, which is good
045D52             0069*                      ; resets all others which is okay
045D52 C9          0070*      ret
045D53             0071*  
045D53             0072*  ; ; perform unsigned division of 16.8 fixed place values
045D53             0073*  ; ; with an unsigned 16.8 fixed place result
045D53             0074*  ; ; inputs: ub.c is dividend,ud.e is divisor
045D53             0075*  ; ; outputs: uh.l is quotient
045D53             0076*  ; ; destroys: a,bc
045D53             0077*  ; udiv168:
045D53             0078*  ; ; get the 16-bit integer part of the quotient
045D53             0079*  ;     ; call div_24
045D53             0080*  ;     call udiv24
045D53             0081*  ;     ; call dumpRegistersHex
045D53             0082*  ; ; load quotient to upper three bytes of output
045D53             0083*  ;     ld (div168_out+1),bc
045D53             0084*  ; ; TODO: THIS MAY BE BUGGED
045D53             0085*  ; ; check remainder for zero, and if it is
045D53             0086*  ; ; we can skip calculating the fractional part
045D53             0087*  ;     add hl,de
045D53             0088*  ;     or a
045D53             0089*  ;     sbc hl,de
045D53             0090*  ;     jr nz,@div256
045D53             0091*  ;     xor a
045D53             0092*  ;     jr @write_frac
045D53             0093*  ; ; END TODO
045D53             0094*  ; @div256:
045D53             0095*  ; ; divide divisor by 256
045D53             0096*  ;     push hl ; save remainder
045D53             0097*  ; ; TODO: it feels like this could be more efficient
045D53             0098*  ;     ld (ude),de
045D53             0099*  ;     ld a,d
045D53             0100*  ;     ld (ude),a
045D53             0101*  ;     ld a,(ude+2)
045D53             0102*  ;     ld (ude+1),a
045D53             0103*  ;     xor a
045D53             0104*  ;     ld (ude+2),a
045D53             0105*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
045D53             0106*  ; ; TODO: THIS MAY BE BUGGED
045D53             0107*  ; ; now we check the shifted divisor for zero, and if it is
045D53             0108*  ; ; we again set the fractional part to zero
045D53             0109*  ;     add hl,de
045D53             0110*  ;     or a
045D53             0111*  ;     sbc hl,de
045D53             0112*  ;     ex de,hl ; now de is where it's supposed to be
045D53             0113*  ;     pop hl ; get remainder back
045D53             0114*  ; ; TODO: THIS MAY BE BUGGED
045D53             0115*  ;     jr nz,@div_frac
045D53             0116*  ;     xor a
045D53             0117*  ;     jr @write_frac
045D53             0118*  ; ; END TODO
045D53             0119*  ; ; now divide the remainder by the shifted divisor
045D53             0120*  ; @div_frac:
045D53             0121*  ;     push hl ; my kingdom for ld bc,hl
045D53             0122*  ;     pop bc  ; or even ex bc,hl
045D53             0123*  ;     ; call div_24
045D53             0124*  ;     call udiv24
045D53             0125*  ; ; load low byte of quotient to low byte of output
045D53             0126*  ;     ld a,c
045D53             0127*  ; @write_frac:
045D53             0128*  ;     ld (div168_out),a
045D53             0129*  ; ; load hl with return value
045D53             0130*  ;     ld hl,(div168_out)
045D53             0131*  ; ; load a with any overflow
045D53             0132*  ;     ld a,(div168_out+3)
045D53             0133*  ;     ret ; uh.l is the 16.8 result
045D53             0134*  ; div168_out: ds 4 ; the extra byte is for overflow
045D53             0135*  
045D53             0136*  ; perform unsigned division of fixed place values
045D53             0137*  ; with an unsigned 16.8 fixed place result
045D53             0138*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
045D53             0139*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
045D53             0140*  ; destroys: a,bc
045D53             0141*  udiv168:
045D53             0142*  ; shift dividend left 8 bits
045D53 ED 43 78 56 0143*      ld (ubc+1),bc
       04          
045D58 AF          0144*      xor a
045D59 32 77 56 04 0145*      ld (ubc),a
045D5D ED 4B 77 56 0146*      ld bc,(ubc)
       04          
045D62 CD E9 5D 04 0147*      call udiv24
045D66             0148*  ; flip-flop outptuts to satisfy downstream consumers
045D66             0149*  ; TODO: this is a hack and should be fixed
045D66             0150*  ; (so says copilot ... but it's not wrong)
045D66 E5          0151*      push hl
045D67 C5          0152*      push bc
045D68 E1          0153*      pop hl
045D69 C1          0154*      pop bc
045D6A C9          0155*      ret
045D6B             0156*  
045D6B             0157*  ; this is an adaptation of Div16 extended to 24 bits
045D6B             0158*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
045D6B             0159*  ; it works by shifting each byte of the dividend left into carry 8 times
045D6B             0160*  ; and adding the dividend into hl if the carry is set
045D6B             0161*  ; thus hl accumulates a remainder depending on the result of each iteration
045D6B             0162*  ; ---------------------------------------------------------
045D6B             0163*  ; Divide 24-bit unsigned values
045D6B             0164*  ;   with 24-bit unsigned result
045D6B             0165*  ;   and 24-bit remainder
045D6B             0166*  ; In: Divide ubc by ude
045D6B             0167*  ; Out: ubc = result, uhl = remainder
045D6B             0168*  ; Destroys: a,hl,bc
045D6B             0169*  div_24:
045D6B 21 00 00 00 0170*      ld hl,0     ; Clear accumulator for remainder
045D6F             0171*  ; put dividend in scratch so we can get at all its bytes
045D6F ED 43 77 56 0172*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
045D74 3A 79 56 04 0173*      ld a,(ubc+2); grab the upper byte of the dividend
045D78 06 08       0174*      ld b,8      ; loop counter for 8 bits in a byte
045D7A             0175*  @loop0:
045D7A 17          0176*      rla         ; shift the next bit of dividend into the carry flag
045D7B ED 6A       0177*      adc hl,hl   ; shift the remainder left one bit and add carry if any
045D7D ED 52       0178*      sbc hl,de   ; subtract divisor from remainder
045D7F 30 01       0179*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
045D81             0180*                  ; meaning remainder is divisible by divisor
045D81 19          0181*      add hl,de   ; otherwise add divisor back to remainder
045D82             0182*                  ; reversing the previous subtraction
045D82             0183*  @noadd0:
045D82 10 F6       0184*      djnz @loop0 ; repeat for all 8 bits
045D84 17          0185*      rla         ; now we shift a left one more time
045D85 2F          0186*      cpl         ; then flip its bits for some reason
045D86 32 79 56 04 0187*      ld (ubc+2),a; magically this is the upper byte of the quotient
045D8A 3A 78 56 04 0188*      ld a,(ubc+1); now we pick up the middle byte of the dividend
045D8E 06 08       0189*      ld b,8      ; set up the next loop and do it all again ...
045D90             0190*  @loop1:
045D90 17          0191*      rla
045D91 ED 6A       0192*      adc hl,hl
045D93 ED 52       0193*      sbc hl,de
045D95 30 01       0194*      jr nc,@noadd1
045D97 19          0195*      add hl,de
045D98             0196*  @noadd1:
045D98 10 F6       0197*      djnz @loop1
045D9A 17          0198*      rla
045D9B 2F          0199*      cpl
045D9C 32 78 56 04 0200*      ld (ubc+1),a ; writing the middle byte of quotient
045DA0 3A 77 56 04 0201*      ld a,(ubc)
045DA4 06 08       0202*      ld b,8
045DA6             0203*  @loop2:          ; compute low byte of quotient
045DA6 17          0204*      rla
045DA7 ED 6A       0205*      adc hl,hl
045DA9 ED 52       0206*      sbc hl,de
045DAB 30 01       0207*      jr nc,@noadd2
045DAD 19          0208*      add hl,de
045DAE             0209*  @noadd2:
045DAE 10 F6       0210*      djnz @loop2
045DB0 17          0211*      rla
045DB1 2F          0212*      cpl
045DB2 32 77 56 04 0213*      ld (ubc),a  ; ... write low byte of quotient
045DB6 ED 4B 77 56 0214*      ld bc,(ubc) ; load quotient into bc for return
       04          
045DBB C9          0215*      ret         ; hl already contains remainder so we're done
045DBC             0216*  
045DBC             0217*  ; ---------------------------------------------------------
045DBC             0218*  ; BEGIN HELPER ROUTINES
045DBC             0219*  ; ---------------------------------------------------------
045DBC             0220*  ;
045DBC             0221*  ; absolute value of hlu
045DBC             0222*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
045DBC             0223*  ;         s1,z0,pv0,n1,c0 if hlu was negative
045DBC             0224*  ;         s0,z1,pv0,n1,c0 if hlu was zero
045DBC             0225*  ;         s0,z0,pv0,n1,c0 if hlu was positive
045DBC             0226*  ; destroys: a
045DBC             0227*  abs_hlu:
045DBC 19          0228*      add hl,de
045DBD B7          0229*      or a
045DBE ED 52       0230*      sbc hl,de
045DC0 FA C5 5D 04 0231*      jp m,@is_neg
045DC4 C9          0232*      ret         ; hlu is positive or zero so we're done
045DC5             0233*  @is_neg:
045DC5 F5          0234*      push af     ; otherwise, save current flags for return
045DC6 CD CC 5D 04 0235*      call neg_hlu ; negate hlu
045DCA F1          0236*      pop af      ; get back flags
045DCB C9          0237*      ret
045DCC             0238*  
045DCC             0239*  ; flip the sign of hlu
045DCC             0240*  ; inputs: hlu
045DCC             0241*  ; returns: 0-hlu, flags set appropriately for the result:
045DCC             0242*  ;         s1,z0,pv0,n1,c1 if result is negative
045DCC             0243*  ;         s0,z1,pv0,n1,c0 if result is zero
045DCC             0244*  ;         s0,z0,pv0,n1,c1 if result is positive
045DCC             0245*  ; destroys a
045DCC             0246*  neg_hlu:
045DCC D5          0247*      push de     ; save de
045DCD EB          0248*      ex de,hl    ; put hl into de
045DCE 21 00 00 00 0249*      ld hl,0     ; clear hl
045DD2 AF          0250*      xor a       ; clear carry
045DD3 ED 52       0251*      sbc hl,de   ; 0-hlu = -hlu
045DD5 D1          0252*      pop de      ; get de back
045DD6 C9          0253*      ret         ; easy peasy
045DD7             0254*  
045DD7             0255*  ; -----------------------------------------------------------------------
045DD7             0256*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
045DD7             0257*  ;------------------------------------------------------------------------
045DD7             0258*  ;  arith24.asm
045DD7             0259*  ;  24-bit ez80 arithmetic routines
045DD7             0260*  ;  Copyright (c) Shawn Sijnstra 2024
045DD7             0261*  ;  MIT license
045DD7             0262*  ;
045DD7             0263*  ;  This library was created as a tool to help make ez80
045DD7             0264*  ;  24-bit native assembly routines for simple mathematical problems
045DD7             0265*  ;  more widely available.
045DD7             0266*  ;
045DD7             0267*  ;------------------------------------------------------------------------
045DD7             0268*  
045DD7             0269*  ;------------------------------------------------------------------------
045DD7             0270*  ; umul24:	HLU = BCU*DEU (unsigned)
045DD7             0271*  ; Preserves AF, BCU, DEU
045DD7             0272*  ; Uses a fast multiply routine.
045DD7             0273*  ;------------------------------------------------------------------------
045DD7             0274*  ; modified to take BCU as multiplier instead of HLU
045DD7             0275*  umul24:
045DD7             0276*  	; push	DE
045DD7             0277*  	; push	BC
045DD7             0278*  	; push	AF
045DD7             0279*  	; push	HL
045DD7             0280*  	; pop		BC
045DD7 3E 18       0281*      ld	 	a,24 ; No. of bits to process
045DD9 21 00 00 00 0282*      ld	 	hl,0 ; Result
045DDD             0283*  umul24_lp:
045DDD 29          0284*  	add	hl,hl
045DDE EB          0285*  	ex	de,hl
045DDF 29          0286*  	add	hl,hl
045DE0 EB          0287*  	ex	de,hl
045DE1 30 01       0288*  	jr	nc,umul24_nc
045DE3 09          0289*  	add	hl,bc
045DE4             0290*  umul24_nc:
045DE4 3D          0291*  	dec	a
045DE5 20 F6       0292*  	jr	nz,umul24_lp
045DE7 0B          0293*      dec bc ; debug
045DE8             0294*  	; pop	af
045DE8             0295*  	; pop	bc
045DE8             0296*  	; pop	de
045DE8 C9          0297*  	ret
045DE9             0298*  
045DE9             0299*  
045DE9             0300*  ;------------------------------------------------------------------------
045DE9             0301*  ; udiv24
045DE9             0302*  ; Unsigned 24-bit division
045DE9             0303*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
045DE9             0304*  ;
045DE9             0305*  ; Uses AF BC DE HL
045DE9             0306*  ; Uses Restoring Division algorithm
045DE9             0307*  ;------------------------------------------------------------------------
045DE9             0308*  ; modified to take BCU as dividend instead of HLU
045DE9             0309*  ; and give BCU as quotient instead of DEU
045DE9             0310*  ; -----------------------------------------------------------------------
045DE9             0311*  udiv24:
045DE9             0312*  	; push	hl
045DE9             0313*  	; pop		bc	;move dividend to BCU
045DE9 21 00 00 00 0314*  	ld		hl,0	;result
045DED A7          0315*  	and		a
045DEE ED 52       0316*  	sbc		hl,de	;test for div by 0
045DF0 C8          0317*  	ret		z		;it's zero, carry flag is clear
045DF1 19          0318*  	add		hl,de	;HL is 0 again
045DF2 3E 18       0319*  	ld		a,24	;number of loops through.
045DF4             0320*  udiv1:
045DF4 C5          0321*  	push	bc	;complicated way of doing this because of lack of access to top bits
045DF5 E3          0322*  	ex		(sp),hl
045DF6 37          0323*  	scf
045DF7 ED 6A       0324*  	adc	hl,hl
045DF9 E3          0325*  	ex	(sp),hl
045DFA C1          0326*  	pop	bc		;we now have bc = (bc * 2) + 1
045DFB             0327*  
045DFB ED 6A       0328*  	adc	hl,hl
045DFD A7          0329*  	and	a		;is this the bug
045DFE ED 52       0330*  	sbc	hl,de
045E00 30 02       0331*  	jr	nc,udiv2
045E02 19          0332*  	add	hl,de
045E03             0333*  ;	dec	c
045E03 0B          0334*  	dec	bc
045E04             0335*  udiv2:
045E04 3D          0336*  	dec	a
045E05 20 ED       0337*  	jr	nz,udiv1
045E07 37          0338*  	scf		;flag used for div0 error
045E08             0339*  	; push	bc
045E08             0340*  	; pop		de	;remainder
045E08 C9          0341*  	ret
045E09             0342*  
045E09             0343*  
045E09             0344*  
045E09             0345*  ;------------------------------------------------------------------------
045E09             0346*  ; neg24
045E09             0347*  ; Returns: HLU = 0-HLU
045E09             0348*  ; preserves all other registers
045E09             0349*  ;------------------------------------------------------------------------
045E09             0350*  neg24:
045E09 D5          0351*  	push	de
045E0A EB          0352*  	ex		de,hl
045E0B 21 00 00 00 0353*  	ld		hl,0
045E0F B7          0354*  	or		a
045E10 ED 52       0355*  	sbc		hl,de
045E12 D1          0356*  	pop		de
045E13 C9          0357*  	ret
045E14             0358*  
045E14             0359*  ;------------------------------------------------------------------------
045E14             0360*  ; or_hlu_deu: 24 bit bitwise OR
045E14             0361*  ; Returns: hlu = hlu OR deu
045E14             0362*  ; preserves all other registers
045E14             0363*  ;------------------------------------------------------------------------
045E14             0364*  or_hlu_deu:
045E14 22 D0 5E 04 0365*  	ld	(bitbuf1),hl
045E18 ED 53 D3 5E 0366*  	ld	(bitbuf2),de
       04          
045E1D D5          0367*  	push	de	;preserve DEU
045E1E C5          0368*  	push	bc	;preserve BCU
045E1F 06 03       0369*  	ld		b,3
045E21 21 D0 5E 04 0370*  	ld	hl,bitbuf1
045E25 11 D0 5E 04 0371*  	ld	de,bitbuf1
045E29             0372*  orloop_24:
045E29 1A          0373*  	ld	a,(de)
045E2A B6          0374*  	or	(hl)
045E2B 12          0375*  	ld	(de),a
045E2C 13          0376*  	inc	de
045E2D 23          0377*  	inc	hl
045E2E 10 F9       0378*  	djnz	orloop_24
045E30 2A D3 5E 04 0379*  	ld	hl,(bitbuf2)
045E34 C1          0380*  	pop		bc	;restore BC
045E35 D1          0381*  	pop		de	;restore DE
045E36             0382*  
045E36             0383*  ;------------------------------------------------------------------------
045E36             0384*  ; and_hlu_deu: 24 bit bitwise AND
045E36             0385*  ; Returns: hlu = hlu AND deu
045E36             0386*  ; preserves all other registers
045E36             0387*  ;------------------------------------------------------------------------
045E36             0388*  and_hlu_deu:
045E36 22 D0 5E 04 0389*  	ld	(bitbuf1),hl
045E3A ED 53 D3 5E 0390*  	ld	(bitbuf2),de
       04          
045E3F D5          0391*  	push	de	;preserve DEU
045E40 C5          0392*  	push	bc	;preserve BCU
045E41 06 03       0393*  	ld		b,3
045E43 21 D0 5E 04 0394*  	ld	hl,bitbuf1
045E47 11 D0 5E 04 0395*  	ld	de,bitbuf1
045E4B             0396*  andloop_24:
045E4B 1A          0397*  	ld	a,(de)
045E4C A6          0398*  	and	(hl)
045E4D 12          0399*  	ld	(de),a
045E4E 13          0400*  	inc	de
045E4F 23          0401*  	inc	hl
045E50 10 F9       0402*  	djnz	andloop_24
045E52 2A D3 5E 04 0403*  	ld	hl,(bitbuf2)
045E56 C1          0404*  	pop		bc	;restore BC
045E57 D1          0405*  	pop		de	;restore DE
045E58             0406*  
045E58             0407*  ;------------------------------------------------------------------------
045E58             0408*  ; xor_hlu_deu: 24 bit bitwise XOR
045E58             0409*  ; Returns: hlu = hlu XOR deu
045E58             0410*  ; preserves all other registers
045E58             0411*  ;------------------------------------------------------------------------
045E58             0412*  xor_hlu_deu:
045E58 22 D0 5E 04 0413*  	ld	(bitbuf1),hl
045E5C ED 53 D3 5E 0414*  	ld	(bitbuf2),de
       04          
045E61 D5          0415*  	push	de	;preserve DEU
045E62 C5          0416*  	push	bc	;preserve BCU
045E63 06 03       0417*  	ld		b,3
045E65 21 D0 5E 04 0418*  	ld	hl,bitbuf1
045E69 11 D0 5E 04 0419*  	ld	de,bitbuf1
045E6D             0420*  xorloop_24:
045E6D 1A          0421*  	ld	a,(de)
045E6E AE          0422*  	xor	(hl)
045E6F 12          0423*  	ld	(de),a
045E70 13          0424*  	inc	de
045E71 23          0425*  	inc	hl
045E72 10 F9       0426*  	djnz	xorloop_24
045E74 2A D3 5E 04 0427*  	ld	hl,(bitbuf2)
045E78 C1          0428*  	pop		bc	;restore BC
045E79 D1          0429*  	pop		de	;restore DE
045E7A             0430*  
045E7A             0431*  ;------------------------------------------------------------------------
045E7A             0432*  ; shl_hlu: 24 bit shift left hlu by deu positions
045E7A             0433*  ; Returns: hlu = hlu << deu
045E7A             0434*  ;		   de = 0
045E7A             0435*  ; NOTE: only considers deu up to 16 bits.
045E7A             0436*  ; preserves all other registers
045E7A             0437*  ;------------------------------------------------------------------------
045E7A             0438*  shl_hlu:
045E7A 7A          0439*  	ld		a,d		;up to 16 bit.
045E7B B3          0440*  	or		e
045E7C C8          0441*  	ret		z		;we're done
045E7D 29          0442*  	add		hl,hl	;shift HLU left
045E7E 1B          0443*  	dec		de
045E7F 18 F9       0444*  	jr		shl_hlu
045E81             0445*  
045E81             0446*  ;------------------------------------------------------------------------
045E81             0447*  ; shr_hlu: 24 bit shift right hlu by deu positions
045E81             0448*  ; Returns: hlu = hlu >> deu
045E81             0449*  ;		   de = 0
045E81             0450*  ; NOTE: only considers deu up to 16 bits.
045E81             0451*  ; preserves all other registers
045E81             0452*  ;------------------------------------------------------------------------
045E81             0453*  shr_hlu:
045E81 22 D0 5E 04 0454*  	ld		(bitbuf1),hl
045E85 21 D2 5E 04 0455*  	ld		hl,bitbuf1+2
045E89             0456*  shr_loop:
045E89 7A          0457*  	ld		a,d		;up to 16 bit.
045E8A B3          0458*  	or		e
045E8B 28 0D       0459*  	jr		z,shr_done		;we're done
045E8D             0460*  ;carry is clear from or instruction
045E8D CB 1E       0461*  	rr		(hl)
045E8F 2B          0462*  	dec		hl
045E90 CB 1E       0463*  	rr		(hl)
045E92 2B          0464*  	dec		hl
045E93 CB 1E       0465*  	rr		(hl)
045E95 23          0466*  	inc		hl
045E96 23          0467*  	inc		hl
045E97 1B          0468*  	dec		de
045E98 18 EF       0469*  	jr		shr_loop
045E9A             0470*  shr_done:
045E9A 2A D0 5E 04 0471*  	ld		hl,(bitbuf1)	;collect result
045E9E C9          0472*  	ret
045E9F             0473*  
045E9F             0474*  ;------------------------------------------------------------------------
045E9F             0475*  ; divide hlu by 2, inspired by above
045E9F             0476*  ;------------------------------------------------------------------------
045E9F             0477*  hlu_div2:
045E9F 22 D0 5E 04 0478*  	ld		(bitbuf1),hl
045EA3 21 D2 5E 04 0479*  	ld		hl,bitbuf1+2
045EA7 CB 1E       0480*  	rr		(hl)
045EA9 2B          0481*  	dec		hl
045EAA CB 1E       0482*  	rr		(hl)
045EAC 2B          0483*  	dec		hl
045EAD CB 1E       0484*  	rr		(hl)
045EAF 23          0485*  	inc		hl
045EB0 23          0486*  	inc		hl
045EB1 2A D0 5E 04 0487*      ld hl,(bitbuf1)
045EB5 C9          0488*      ret
045EB6             0489*  
045EB6             0490*  ; this is my little hack to divide by 16
045EB6             0491*  hlu_div16:
045EB6 AF          0492*      xor a
045EB7 29          0493*      add hl,hl
045EB8 17          0494*      rla
045EB9 29          0495*      add hl,hl
045EBA 17          0496*      rla
045EBB 29          0497*      add hl,hl
045EBC 17          0498*      rla
045EBD 29          0499*      add hl,hl
045EBE 17          0500*      rla
045EBF 22 CC 5E 04 0501*      ld (@scratch),hl
045EC3 32 CF 5E 04 0502*      ld (@scratch+3),a
045EC7 2A CD 5E 04 0503*      ld hl,(@scratch+1)
045ECB C9          0504*      ret
045ECC             0505*  @scratch: ds 4
045ED0             0506*  
045ED0             0507*  ;------------------------------------------------------------------------
045ED0             0508*  ; Scratch area for calculations
045ED0             0509*  ;------------------------------------------------------------------------
045ED0 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
045ED3 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
045ED6             0512*  
045ED6             0513*  
045ED6             0514*  ; -----------------------------------------------------------------------
045ED6             0515*  ; EEMES TUTORIALS
045ED6             0516*  ; -----------------------------------------------------------------------
045ED6             0517*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
045ED6             0518*  ; DEHL=BC*DE
045ED6             0519*  Mul16:
045ED6 21 00 00 00 0520*      ld hl,0
045EDA 3E 10       0521*      ld a,16
045EDC             0522*  Mul16Loop:
045EDC 29          0523*      add hl,hl
045EDD CB 13       0524*      rl e
045EDF CB 12       0525*      rl d
045EE1 D2 EB 5E 04 0526*      jp nc,NoMul16
045EE5 09          0527*      add hl,bc
045EE6 D2 EB 5E 04 0528*      jp nc,NoMul16
045EEA 13          0529*      inc de
045EEB             0530*  NoMul16:
045EEB 3D          0531*      dec a
045EEC C2 DC 5E 04 0532*      jp nz,Mul16Loop
045EF0 C9          0533*      ret
045EF1             0534*  
045EF1             0535*  ; DEUHLU=BCU*DEU
045EF1             0536*  umul2448:
045EF1 21 00 00 00 0537*      ld hl,0
045EF5 3E 18       0538*      ld a,24
045EF7             0539*  umul2448Loop:
045EF7 29          0540*      add hl,hl
045EF8 EB          0541*      ex de,hl
045EF9 ED 6A       0542*      adc hl,hl
045EFB EB          0543*      ex de,hl
045EFC D2 06 5F 04 0544*      jp nc,Noumul2448
045F00 09          0545*      add hl,bc
045F01 D2 06 5F 04 0546*      jp nc,Noumul2448
045F05 13          0547*      inc de
045F06             0548*  Noumul2448:
045F06 3D          0549*      dec a
045F07 C2 F7 5E 04 0550*      jp nz,umul2448Loop
045F0B C9          0551*      ret
045F0C             0552*  
045F0C             0553*  umul168:
045F0C CD F1 5E 04 0554*      call umul2448
045F10             0555*  
045F10             0556*      ; call dumpUDEUHLHex
045F10             0557*  
045F10             0558*  ; UDEU.HL is the 32.16 fixed result
045F10             0559*  ; we want UH.L to be the 16.8 fixed result
045F10             0560*  ; so we divide by 256 by shiftng down a byte
045F10             0561*  ; easiest way is to write deu and hlu to scratch
045F10 ED 53 25 5F 0562*      ld (umul168out+3),de
       04          
045F15 22 22 5F 04 0563*      ld (umul168out),hl
045F19             0564*  ; then load hlu from scratch shfited forward a byte
045F19 2A 23 5F 04 0565*      ld hl,(umul168out+1)
045F1D 3A 27 5F 04 0566*      ld a,(umul168out+5) ; send a back with any overflow
045F21 C9          0567*      ret
045F22             0568*  umul168out: ds 6
045F28             0569*  
045F28             0570*  ; perform signed multiplication of 16.8 fixed place values
045F28             0571*  ; with an signed 16.8 fixed place result
045F28             0572*  ; inputs: ub.c and ud.e are the operands
045F28             0573*  ; outputs: uh.l is the product
045F28             0574*  ; destroys: a,bc
045F28             0575*  ; TODO: make flags appropriate to the sign of the result
045F28             0576*  smul168:
045F28             0577*  ; make everything positive and save signs
045F28 C5          0578*      push bc         ; get bc to hl
045F29 E1          0579*      pop hl          ; for the next call
045F2A CD BC 5D 04 0580*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
045F2E             0581*  
045F2E             0582*      ; call dumpFlags ; passes
045F2E             0583*  
045F2E CA 61 5F 04 0584*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045F32 F5          0585*      push af         ; save sign of bc
045F33 E5          0586*      push hl         ; now put abs(hl)
045F34 C1          0587*      pop bc          ; back into bc = abs(bc)
045F35 EB          0588*      ex de,hl        ; now we do de same way
045F36 CD BC 5D 04 0589*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
045F3A             0590*  
045F3A             0591*      ; call dumpFlags ; passes
045F3A             0592*  
045F3A CA 61 5F 04 0593*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
045F3E EB          0594*      ex de,hl        ; hl back to de = abs(de)
045F3F             0595*  ; determine sign of result
045F3F F2 4A 5F 04 0596*      jp p,@de_pos    ; sign positive,de is positive
045F43             0597*  
045F43             0598*      ; call dumpFlags ; correctly doesnt make it here
045F43             0599*  
045F43 F1          0600*      pop af          ; get back sign of bc
045F44             0601*  
045F44             0602*      ; call dumpFlags ; correctly doesn't make it here
045F44             0603*  
045F44 FA 53 5F 04 0604*      jp m,@result_pos  ; bc and de negative, result is positive
045F48             0605*  
045F48             0606*      ; call dumpFlags  ; corectly doesn't make it here
045F48             0607*  
045F48 18 05       0608*      jr @result_neg
045F4A             0609*  @de_pos:
045F4A F1          0610*      pop af          ; get back sign of bc
045F4B             0611*  
045F4B             0612*      ; call dumpFlags  ; passes
045F4B             0613*  
045F4B F2 53 5F 04 0614*      jp p,@result_pos   ; bc and de are both positive so result is positive
045F4F             0615*  
045F4F             0616*      ; call dumpFlags ; correctly makes it here
045F4F             0617*  
045F4F             0618*                      ; fall through to result_neg
045F4F             0619*  @result_neg:
045F4F AF          0620*      xor a           ; zero a and clear carry
045F50 3D          0621*      dec a           ; set sign flag to negative
045F51             0622*  
045F51             0623*      ; call dumpFlags ; passes
045F51             0624*  
045F51 18 02       0625*      jr @do_mul
045F53             0626*  @result_pos:
045F53 AF          0627*      xor a           ; zero a and clear carry
045F54 3C          0628*      inc a           ; set sign flag to positive
045F55             0629*                      ; fall through to do_mul
045F55             0630*  
045F55             0631*      ; call dumpFlags ; correctly doesn't make it here
045F55             0632*  
045F55             0633*  @do_mul:
045F55 F5          0634*      push af         ; save sign of result
045F56 CD 0C 5F 04 0635*      call umul168
045F5A F1          0636*      pop af          ; get back sign of result
045F5B             0637*  
045F5B             0638*      ; call dumpFlags ; passes
045F5B             0639*  
045F5B F0          0640*      ret p           ; result is positive so nothing to do
045F5C             0641*  
045F5C             0642*      ; call dumpRegistersHex ; passes
045F5C             0643*  
045F5C CD CC 5D 04 0644*      call neg_hlu    ; result is negative so negate it
045F60             0645*  
045F60             0646*      ; call dumpRegistersHex ; passes
045F60 C9          0647*      ret
045F61             0648*  @is_zero:           ; result is zero
045F61 AF          0649*      xor a           ; sets zero flag, which we want,
045F62             0650*                      ; sets pv flag which we might not (zero is parity even)
045F62             0651*                      ; resets all others which is okay
045F62 C9          0652*      ret
045F63             0061   	include "src/asm/maths24.inc"
045F63             0001*  ; http://www.z80.info/pseudo-random.txt
045F63             0002*  rand_8:
045F63 C5          0003*      push bc
045F64 3A 77 5F 04 0004*      ld a,(r_seed)
045F68 4F          0005*      ld c,a
045F69             0006*  
045F69 0F          0007*      rrca ; multiply by 32
045F6A 0F          0008*      rrca
045F6B 0F          0009*      rrca
045F6C EE 1F       0010*      xor 0x1f
045F6E             0011*  
045F6E 81          0012*      add a,c
045F6F DE FF       0013*      sbc a,255 ; carry
045F71             0014*  
045F71 32 77 5F 04 0015*      ld (r_seed),a
045F75 C1          0016*      pop bc
045F76 C9          0017*      ret
045F77 50          0018*  r_seed: defb $50
045F78             0019*  
045F78             0020*  ; tests the sign of 24-bit register hlu
045F78             0021*  ; returns: a in [-1,0,1]
045F78             0022*  ;   sign and zero flags as expected
045F78             0023*  ;   hl is untouched
045F78             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
045F78             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
045F78             0026*  get_sign_hlu:
045F78             0027*      ; Load the upper byte of HLU into A
045F78 E5          0028*      push hl
045F79 DD 21 00 00 0029*      ld ix,0
       00          
045F7E DD 39       0030*      add ix,sp
045F80 DD 7E 02    0031*      ld a,(ix+2)
045F83 E1          0032*      pop hl
045F84             0033*  
045F84 B5          0034*      or l                ; OR with the low byte to check if HL is zero
045F85 C8          0035*      ret z               ; Return if HL is zero
045F86             0036*  
045F86 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
045F88 CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
045F8A C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
045F8B             0040*  
045F8B 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
045F8D A7          0042*      and a               ; Reset the zero flag
045F8E C9          0043*      ret                 ; Return with A set to 1
045F8F             0044*  
045F8F             0045*  ; 16.8 fixed inputs / outputs
045F8F             0046*  ; takes: uh.l as angle in degrees 256
045F8F             0047*  ;        ud.e as radius
045F8F             0048*  ; returns ub.c as dx, ud.e as dy
045F8F             0049*  ;        displacements from origin (0,0)
045F8F             0050*  ; destroys: everything except indexes
045F8F             0051*  polar_to_cartesian:
045F8F             0052*  ; back up input parameters
045F8F 22 74 56 04 0053*      ld (uhl),hl
045F93 ED 53 7A 56 0054*      ld (ude),de
       04          
045F98             0055*  ; compute dx = sin(uh.l) * ud.e
045F98 CD C7 5F 04 0056*      call sin168
045F9C E5          0057*      push hl
045F9D C1          0058*      pop bc ; ub.c = sin(uh.l)
045F9E ED 5B 7A 56 0059*  	ld de,(ude) ; get radius back
       04          
045FA3 CD 28 5F 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
045FA7 E5          0061*      push hl ; store dx for output
045FA8             0062*  ; compute dy = -cos(uh.l) * ud.e
045FA8 2A 74 56 04 0063*      ld hl,(uhl)
045FAC CD C2 5F 04 0064*      call cos168
045FB0 CD CC 5D 04 0065*  	call neg_hlu ; invert dy for screen coords convention
045FB4 E5          0066*      push hl
045FB5 C1          0067*      pop bc ; ub.c = -cos(uh.l)
045FB6 ED 5B 7A 56 0068*      ld de,(ude) ; get radius back
       04          
045FBB CD 28 5F 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
045FBF EB          0070*      ex de,hl    ; de = dy for output
045FC0 C1          0071*      pop bc      ; bc = dx for output
045FC1             0072*  ; and out
045FC1 C9          0073*      ret
045FC2             0074*  
045FC2             0075*  ; fixed 16.8 routine
045FC2             0076*  ; cos(uh.l) --> uh.l
045FC2             0077*  ; destroys: de
045FC2             0078*  cos168:
045FC2             0079*  ; for cos we simply increment the angle by 90 degrees
045FC2             0080*  ; or 0x004000 in 16.8 degrees256
045FC2             0081*  ; which makes it a sin problem
045FC2 11 00 40 00 0082*      ld de,0x004000
045FC6 19          0083*      add hl,de ; modulo 256 happens below
045FC7             0084*  ; fall through to sin168
045FC7             0085*  ; ---------------------
045FC7             0086*  ; fixed 16.8 routine
045FC7             0087*  ; sin(uh.l) --> uh.l
045FC7             0088*  ; destroys: de
045FC7             0089*  sin168:
045FC7             0090*  ; h contains the integer portion of our angle
045FC7             0091*  ; we multiply it by three to get our lookup table index
045FC7 2E 03       0092*      ld l,3
045FC9 ED 6C       0093*      mlt hl ; gosh that is handy
045FCB 11 00 00 00 0094*      ld de,0 ; clear deu
045FCF 54          0095*      ld d,h ; copy hl to de
045FD0 5D          0096*      ld e,l ; de contains our index
045FD1 21 D8 61 04 0097*      ld hl,sin_lut_168 ; grab the lut address
045FD5 19          0098*      add hl,de ; bump hl by the index
045FD6 ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
045FD8 C9          0100*      ret ; and out
045FD9             0101*  
045FD9             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
045FD9             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
045FD9             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
045FD9             0105*  ;         also populates scratch locations dx168 and dy168
045FD9             0106*  ; destroys: a,hl,bc,de
045FD9             0107*  dxy168:
045FD9             0108*  ; compute dx = x1-x0
045FD9 AF          0109*      xor a ; clear carry
045FDA DD E5       0110*      push ix ; move ix to hl via the stack
045FDC E1          0111*      pop hl ; hl = x1
045FDD ED 42       0112*      sbc hl,bc ; hl = dx
045FDF 22 34 60 04 0113*      ld (dx168),hl ; dx to scratch
045FE3             0114*  ; compute dy = y1-y0
045FE3 AF          0115*      xor a ; clear carry
045FE4 FD E5       0116*      push iy ; move iy to hl via the stack
045FE6 E1          0117*      pop hl ; hl = y1
045FE7 ED 52       0118*      sbc hl,de ; hl = dy
045FE9 22 3A 60 04 0119*      ld (dy168),hl ; dy to scratch
045FED             0120*  ; populate output registers and return
045FED EB          0121*      ex de,hl        ; ud.e = dy
045FEE ED 4B 34 60 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
045FF3 C9          0123*      ret
045FF4             0124*  
045FF4             0125*  ; compute the euclidian distance between two cartesian coordinates
045FF4             0126*  ; using the formula d = sqrt(dx^2+dy^2
045FF4             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
045FF4             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
045FF4             0129*  ; output; uh.l is the 16.8 fixed format distance
045FF4             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
045FF4             0131*  ; destroys: a,hl,bc,de
045FF4             0132*  distance168:
045FF4             0133*  ; compute dx = x1-x0
045FF4 AF          0134*      xor a ; clear carry
045FF5 DD E5       0135*      push ix ; move ix to hl via the stack
045FF7 E1          0136*      pop hl ; hl = x1
045FF8 ED 42       0137*      sbc hl,bc ; hl = dx
045FFA 22 34 60 04 0138*      ld (dx168),hl ; dx to scratch
045FFE             0139*  ; ; test dx for overflow
045FFE             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
045FFE             0141*  ; 	ex de,hl
045FFE             0142*  ; 	sbc hl,de ; test for overflow
045FFE             0143*  ; 	push af ; carry indicates overflow
045FFE             0144*  ; compute dy = y1-y0
045FFE AF          0145*      xor a ; clear carry
045FFF FD E5       0146*      push iy ; move iy to hl via the stack
046001 E1          0147*      pop hl ; hl = y1
046002 ED 52       0148*      sbc hl,de ; hl = dy
046004 22 3A 60 04 0149*      ld (dy168),hl ; dy to scratch
046008             0150*  ; ; test dy for overflow
046008             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
046008             0152*  ; 	ex de,hl
046008             0153*  ; 	sbc hl,de ; test for overflow
046008             0154*  ; 	push af ; carry indicates overflow
046008             0155*  ; compute dy^2
046008 2A 3A 60 04 0156*  	ld hl,(dy168)
04600C CD BC 5D 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
046010             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046010 E5          0159*      push hl ; load hl/2 to bc via the stack
046011 C1          0160*      pop bc ; bc = dy/2
046012 EB          0161*      ex de,hl ; de = dy/2
046013 CD 0C 5F 04 0162*      call umul168 ; uh.l = dy^2/2
046017 E5          0163*      push hl ; dy^2/2 to the stack
046018             0164*  ; compute dx^2
046018 2A 34 60 04 0165*      ld hl,(dx168) ; get back dx
04601C CD BC 5D 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
046020             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046020 E5          0168*      push hl ; load hl/2 to bc via the stack
046021 C1          0169*      pop bc ; bc = dx/2
046022 EB          0170*      ex de,hl ; de = dx/2
046023 CD 0C 5F 04 0171*      call umul168 ; uh.l = dx^2/2
046027             0172*  ; commpute dy^2+dx^2
046027 D1          0173*      pop de ; get back dx^2/2
046028 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
046029             0175*  ; compute sqrt(dx^2/2+dy^2/2)
046029 CD ED 60 04 0176*      call sqrt168 ; uh.l = distance/2
04602D             0177*      ; add hl,hl ; hl = distance
04602D             0178*  ; ; check for overflow
04602D             0179*  ; 	pop af ; get back the overflow flags
04602D             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
04602D             0181*  ; 	ld b,a ; save the overflow flag
04602D             0182*  ; 	pop af ; get back the overflow flags
04602D             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
04602D             0184*  ; 	add a,b ; if a != 0 then we had overflow
04602D             0185*  ;     ret z ; no overflow we're done
04602D             0186*  ; @overflow:
04602D             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
04602D C9          0188*  	ret
04602E             0189*  @scratch: ds 6
046034             0190*  dx168: ds 6
04603A             0191*  dy168: ds 6
046040             0192*  
046040             0193*  ; atan2(ub.c,ud.e) --> uh.l
046040             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046040             0195*  ;   whether inputs are integers or fractional doesn't matter
046040             0196*  ;   so long as the sign bit of the upper byte is correct
046040             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
046040             0198*  ; angles are COMPASS HEADINGS based on
046040             0199*  ; screen coordinate conventions,where the y axis is flipped
046040             0200*  ; #E0 315      0       45 #20
046040             0201*  ;        -x,-y | +x,-y
046040             0202*  ; #C0 270------+------ 90 #40
046040             0203*  ;        -x,+y | +x,+y
046040             0204*  ; #A0 225   180 #80   135 #60
046040             0205*  atan2_168game:
046040             0206*  ; get signs and make everything positive
046040             0207*  ; get abs(x) and store its original sign
046040 C5          0208*      push bc
046041 E1          0209*      pop hl
046042 CD BC 5D 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
046046 E5          0211*      push hl ; store abs(x)
046047 C1          0212*      pop bc ; bc = abs(x)
046048 F5          0213*      push af ; store sign of x
046049             0214*  ; get abs(y) and store its original sign
046049 EB          0215*      ex de,hl ; hl = y
04604A CD BC 5D 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
04604E EB          0217*      ex de,hl ; de = abs(y)
04604F F5          0218*      push af ; store sign of y
046050             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
046050             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
046050 AF          0221*      xor a ; clear the carry flag
046051 D5          0222*      push de
046052 E1          0223*      pop hl
046053 ED 42       0224*      sbc hl,bc
046055 F5          0225*      push af ; save sign of de - bc
046056 F2 5F 60 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
04605A             0227*  ; otherwise we swap bc and de
04605A C5          0228*      push bc
04605B E1          0229*      pop hl
04605C EB          0230*      ex de,hl
04605D E5          0231*      push hl
04605E C1          0232*      pop bc
04605F             0233*  @1:
04605F             0234*  ; now we're ready to snag our preliminary result
04605F CD CD 60 04 0235*      call atan_168game ; uh.l comes back with prelim result
046063             0236*  ; now we adjust uh.l based on sign of de - bc
046063 F1          0237*      pop af
046064 F2 70 60 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
046068 EB          0239*      ex de,hl
046069 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
04606D AF          0241*      xor a ; clear the carry flag
04606E ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
046070             0243*      ; ld de,0 ; prep to clear hlu
046070             0244*      ; ld d,h
046070             0245*      ; ld e,l
046070             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
046070             0247*      ; fall through
046070             0248*  @2:
046070             0249*  ; now the fun part of adjusting the result
046070             0250*  ; based on which quadrant (x,y) is in
046070             0251*  ; #E0 315      0       45 #20
046070             0252*  ;        -x,-y | +x,-y
046070             0253*  ; #C0 270------+------ 90 #40
046070             0254*  ;        -x,+y | +x,+y
046070             0255*  ; #A0 225   180 #80   135 #60
046070 F1          0256*      pop af ; sign of y
046071 CA AE 60 04 0257*      jp z,@y_zero
046075 F2 8E 60 04 0258*      jp p,@y_pos
046079             0259*  ; y neg,check x
046079 F1          0260*      pop af ; sign of x
04607A CA 88 60 04 0261*      jp z,@y_neg_x_zero
04607E F2 8D 60 04 0262*      jp p,@y_neg_x_pos
046082             0263*  ; y neg,x neg
046082             0264*  ; angle is 270-360
046082             0265*  ; negating the intermediate does the trick
046082 CD CC 5D 04 0266*      call neg_hlu
046086 18 31       0267*      jr @zero_hlu
046088             0268*  
046088             0269*  @y_neg_x_zero:
046088             0270*  ; y neg,x zero
046088             0271*  ; angle is 0
046088 21 00 00 00 0272*      ld hl,0
04608C C9          0273*      ret
04608D             0274*  @y_neg_x_pos:
04608D             0275*  ; y neg,x pos
04608D             0276*  ; angle is 0 to 90
04608D             0277*  ; so we're good
04608D C9          0278*      ret
04608E             0279*  
04608E             0280*  @y_pos:
04608E F1          0281*      pop af ; sign of x
04608F CA 9E 60 04 0282*      jp z,@y_pos_x_zero
046093 F2 A3 60 04 0283*      jp p,@y_pos_x_pos
046097             0284*  ; y pos,x neg
046097             0285*  ; angle is 180-270
046097             0286*  ; so we add 180 to intermediate
046097 11 00 80 00 0287*      ld de,0x008000
04609B 19          0288*      add hl,de
04609C 18 1B       0289*      jr @zero_hlu
04609E             0290*  @y_pos_x_zero:
04609E             0291*  ; y pos,x zero
04609E             0292*  ; angle is 180
04609E 21 00 80 00 0293*      ld hl,0x008000
0460A2 C9          0294*      ret
0460A3             0295*  @y_pos_x_pos:
0460A3             0296*  ; y pos,x pos
0460A3             0297*  ; angle is 90-180
0460A3             0298*  ; neg the intermediate and add 180 degrees
0460A3 CD CC 5D 04 0299*      call neg_hlu
0460A7 11 00 80 00 0300*      ld de,0x008000
0460AB 19          0301*      add hl,de
0460AC 18 0B       0302*      jr @zero_hlu
0460AE             0303*  
0460AE             0304*  @y_zero:
0460AE F1          0305*      pop af ; sign of x
0460AF FA B4 60 04 0306*      jp m,@y_zero_x_neg
0460B3             0307*  ; y zero,x pos
0460B3             0308*  ; angle is 90,nothing to do
0460B3 C9          0309*      ret
0460B4             0310*  @y_zero_x_neg:
0460B4             0311*  ; y zero ,x neg
0460B4             0312*  ; angle is 270
0460B4 21 00 C0 00 0313*      ld hl,0x00C000
0460B8 C9          0314*      ret
0460B9             0315*  @zero_hlu:
0460B9 AF          0316*      xor a
0460BA 22 C7 60 04 0317*      ld (@scratch),hl
0460BE 32 C9 60 04 0318*      ld (@scratch+2),a
0460C2 2A C7 60 04 0319*      ld hl,(@scratch)
0460C6 C9          0320*      ret
0460C7             0321*  @scratch: ds 6
0460CD             0322*  
0460CD             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0460CD             0324*  ; output: uh.l is the 16.8 fixed format angle
0460CD             0325*  ; destroys: a,hl,bc,de
0460CD             0326*  ; the following note was written by github copilot:
0460CD             0327*  ; note: this routine is a bit of a hack
0460CD             0328*  ;      but it works
0460CD             0329*  ;      and it's fast
0460CD             0330*  ;      and it's small
0460CD             0331*  ;      and it's accurate
0460CD             0332*  ;      and it's easy to understand
0460CD             0333*  ;      and it's easy to modify
0460CD             0334*  ;      and it's easy to use
0460CD             0335*  ;      and it's easy to remember
0460CD             0336*  ;      and it's easy to love
0460CD             0337*  ;      and it's easy to hate
0460CD             0338*  ;      and it's easy to ignore
0460CD             0339*  ;      and it's easy to forget
0460CD             0340*  ;      and it's easy to remember
0460CD             0341*  ;      and it's easy to forget
0460CD             0342*  ;      and it's easy to remember
0460CD             0343*  ;      (ok the bot is stuck in a loop)
0460CD             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0460CD             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0460CD             0346*  atan_168game:
0460CD             0347*  ; because we use compass headings instead of geometric angles
0460CD             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0460CD             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
0460CD CD 53 5D 04 0350*  	call udiv168 ; uh.l = dx/dy
0460D1             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0460D1             0352*  ; ; test uh.l for 0
0460D1             0353*  ;     add hl,de
0460D1             0354*  ;     or a
0460D1             0355*  ;     sbc hl,de
0460D1             0356*  ;     jr z,@is_zero
0460D1             0357*  ; ; test uh.l for 1
0460D1             0358*  ;     xor a ; clear carry
0460D1             0359*  ;     ex de,hl
0460D1             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0460D1             0361*  ;     sbc hl,de
0460D1             0362*  ;     jr z,@is_45
0460D1             0363*  ; ; END TODO
0460D1             0364*  
0460D1             0365*  ; no special cases so we move on
0460D1             0366*  ; l contains the fractional portion of tan(uh.l)
0460D1             0367*  ; we multiply it by three to get our lookup table index
0460D1 26 03       0368*      ld h,3
0460D3 ED 6C       0369*      mlt hl ; gosh that is handy
0460D5 11 00 00 00 0370*      ld de,0 ; clear deu
0460D9 54          0371*      ld d,h ; copy hl to de
0460DA 5D          0372*      ld e,l ; de contains our index
0460DB 21 D8 64 04 0373*      ld hl,atan_lut_168 ; grab the lut address
0460DF 19          0374*      add hl,de ; bump hl by the index
0460E0 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
0460E2 C9          0376*      ret ; and out
0460E3             0377*  @is_45:
0460E3 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
0460E7 C9          0379*      ret
0460E8             0380*  ; for the case tan(0)
0460E8             0381*  @is_zero:
0460E8 21 00 00 00 0382*      ld hl,0x000000
0460EC C9          0383*      ret
0460ED             0384*  
0460ED             0385*  ; Expects  ADL mode
0460ED             0386*  ; Inputs:  UH.L
0460ED             0387*  ; Outputs: UH.L is the 16.8 square root
0460ED             0388*  ;          UD.E is the difference inputHL-DE^2
0460ED             0389*  ;          c flag reset
0460ED             0390*  sqrt168:
0460ED CD F7 60 04 0391*      call sqrt24
0460F1 EB          0392*      ex de,hl
0460F2 29          0393*      add hl,hl
0460F3 29          0394*      add hl,hl
0460F4 29          0395*      add hl,hl
0460F5 29          0396*      add hl,hl
0460F6 C9          0397*      ret
0460F7             0398*  
0460F7             0399*  ; Expects  ADL mode
0460F7             0400*  ; Inputs:  HL
0460F7             0401*  ; Outputs: DE is the integer square root
0460F7             0402*  ;          HL is the difference inputHL-DE^2
0460F7             0403*  ;          c flag reset
0460F7             0404*  sqrt24:
0460F7 AF          0405*      xor a
0460F8 45          0406*      ld b,l
0460F9 C5          0407*      push bc
0460FA 47          0408*      ld b,a
0460FB 57          0409*      ld d,a
0460FC 4F          0410*      ld c,a
0460FD 6F          0411*      ld l,a
0460FE 5F          0412*      ld e,a
0460FF             0413*  
0460FF             0414*      ;Iteration 1
0460FF 29          0415*      add hl,hl
046100 CB 11       0416*      rl c
046102 29          0417*      add hl,hl
046103 CB 11       0418*      rl c
046105 91          0419*      sub c
046106 30 04       0420*      jr nc,$+6
046108 1C          0421*      inc e
046109 1C          0422*      inc e
04610A 2F          0423*      cpl
04610B 4F          0424*      ld c,a
04610C             0425*  
04610C             0426*      ;Iteration 2
04610C 29          0427*      add hl,hl
04610D CB 11       0428*      rl c
04610F 29          0429*      add hl,hl
046110 CB 11       0430*      rl c
046112 CB 13       0431*      rl e
046114 7B          0432*      ld a,e
046115 91          0433*      sub c
046116 30 04       0434*      jr nc,$+6
046118 1C          0435*      inc e
046119 1C          0436*      inc e
04611A 2F          0437*      cpl
04611B 4F          0438*      ld c,a
04611C             0439*  
04611C             0440*      ;Iteration 3
04611C 29          0441*      add hl,hl
04611D CB 11       0442*      rl c
04611F 29          0443*      add hl,hl
046120 CB 11       0444*      rl c
046122 CB 13       0445*      rl e
046124 7B          0446*      ld a,e
046125 91          0447*      sub c
046126 30 04       0448*      jr nc,$+6
046128 1C          0449*      inc e
046129 1C          0450*      inc e
04612A 2F          0451*      cpl
04612B 4F          0452*      ld c,a
04612C             0453*  
04612C             0454*      ;Iteration 4
04612C 29          0455*      add hl,hl
04612D CB 11       0456*      rl c
04612F 29          0457*      add hl,hl
046130 CB 11       0458*      rl c
046132 CB 13       0459*      rl e
046134 7B          0460*      ld a,e
046135 91          0461*      sub c
046136 30 04       0462*      jr nc,$+6
046138 1C          0463*      inc e
046139 1C          0464*      inc e
04613A 2F          0465*      cpl
04613B 4F          0466*      ld c,a
04613C             0467*  
04613C             0468*      ;Iteration 5
04613C 29          0469*      add hl,hl
04613D CB 11       0470*      rl c
04613F 29          0471*      add hl,hl
046140 CB 11       0472*      rl c
046142 CB 13       0473*      rl e
046144 7B          0474*      ld a,e
046145 91          0475*      sub c
046146 30 04       0476*      jr nc,$+6
046148 1C          0477*      inc e
046149 1C          0478*      inc e
04614A 2F          0479*      cpl
04614B 4F          0480*      ld c,a
04614C             0481*  
04614C             0482*      ;Iteration 6
04614C 29          0483*      add hl,hl
04614D CB 11       0484*      rl c
04614F 29          0485*      add hl,hl
046150 CB 11       0486*      rl c
046152 CB 13       0487*      rl e
046154 7B          0488*      ld a,e
046155 91          0489*      sub c
046156 30 04       0490*      jr nc,$+6
046158 1C          0491*      inc e
046159 1C          0492*      inc e
04615A 2F          0493*      cpl
04615B 4F          0494*      ld c,a
04615C             0495*  
04615C             0496*      ;Iteration 7
04615C 29          0497*      add hl,hl
04615D CB 11       0498*      rl c
04615F 29          0499*      add hl,hl
046160 CB 11       0500*      rl c
046162 CB 10       0501*      rl b
046164 EB          0502*      ex de,hl
046165 29          0503*      add hl,hl
046166 E5          0504*      push hl
046167 ED 42       0505*      sbc hl,bc
046169 30 06       0506*      jr nc,$+8
04616B 7C          0507*      ld a,h
04616C 2F          0508*      cpl
04616D 47          0509*      ld b,a
04616E 7D          0510*      ld a,l
04616F 2F          0511*      cpl
046170 4F          0512*      ld c,a
046171 E1          0513*      pop hl
046172 30 02       0514*      jr nc,$+4
046174 23          0515*      inc hl
046175 23          0516*      inc hl
046176 EB          0517*      ex de,hl
046177             0518*  
046177             0519*      ;Iteration 8
046177 29          0520*      add hl,hl
046178 69          0521*      ld l,c
046179 60          0522*      ld h,b
04617A ED 6A       0523*      adc hl,hl
04617C ED 6A       0524*      adc hl,hl
04617E EB          0525*      ex de,hl
04617F 29          0526*      add hl,hl
046180 ED 52       0527*      sbc hl,de
046182 19          0528*      add hl,de
046183 EB          0529*      ex de,hl
046184 30 04       0530*      jr nc,$+6
046186 ED 52       0531*      sbc hl,de
046188 13          0532*      inc de
046189 13          0533*      inc de
04618A             0534*  
04618A             0535*      ;Iteration 9
04618A F1          0536*      pop af
04618B 17          0537*      rla
04618C ED 6A       0538*      adc hl,hl
04618E 17          0539*      rla
04618F ED 6A       0540*      adc hl,hl
046191 EB          0541*      ex de,hl
046192 29          0542*      add hl,hl
046193 ED 52       0543*      sbc hl,de
046195 19          0544*      add hl,de
046196 EB          0545*      ex de,hl
046197 30 04       0546*      jr nc,$+6
046199 ED 52       0547*      sbc hl,de
04619B 13          0548*      inc de
04619C 13          0549*      inc de
04619D             0550*  
04619D             0551*      ;Iteration 10
04619D 17          0552*      rla
04619E ED 6A       0553*      adc hl,hl
0461A0 17          0554*      rla
0461A1 ED 6A       0555*      adc hl,hl
0461A3 EB          0556*      ex de,hl
0461A4 29          0557*      add hl,hl
0461A5 ED 52       0558*      sbc hl,de
0461A7 19          0559*      add hl,de
0461A8 EB          0560*      ex de,hl
0461A9 30 04       0561*      jr nc,$+6
0461AB ED 52       0562*      sbc hl,de
0461AD 13          0563*      inc de
0461AE 13          0564*      inc de
0461AF             0565*  
0461AF             0566*      ;Iteration 11
0461AF 17          0567*      rla
0461B0 ED 6A       0568*      adc hl,hl
0461B2 17          0569*      rla
0461B3 ED 6A       0570*      adc hl,hl
0461B5 EB          0571*      ex de,hl
0461B6 29          0572*      add hl,hl
0461B7 ED 52       0573*      sbc hl,de
0461B9 19          0574*      add hl,de
0461BA EB          0575*      ex de,hl
0461BB 30 04       0576*      jr nc,$+6
0461BD ED 52       0577*      sbc hl,de
0461BF 13          0578*      inc de
0461C0 13          0579*      inc de
0461C1             0580*  
0461C1             0581*      ;Iteration 11
0461C1 17          0582*      rla
0461C2 ED 6A       0583*      adc hl,hl
0461C4 17          0584*      rla
0461C5 ED 6A       0585*      adc hl,hl
0461C7 EB          0586*      ex de,hl
0461C8 29          0587*      add hl,hl
0461C9 ED 52       0588*      sbc hl,de
0461CB 19          0589*      add hl,de
0461CC EB          0590*      ex de,hl
0461CD 30 04       0591*      jr nc,$+6
0461CF ED 52       0592*      sbc hl,de
0461D1 13          0593*      inc de
0461D2 13          0594*      inc de
0461D3             0595*  
0461D3 CB 1A       0596*      rr d
0461D5 CB 1B       0597*      rr e
0461D7 C9          0598*      ret
0461D8             0599*  
0461D8             0600*  sin_lut_168:
0461D8 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
0461DB 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
0461DE 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
0461E1 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
0461E4 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
0461E7 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
0461EA 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
0461ED 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
0461F0 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
0461F3 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
0461F6 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
0461F9 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
0461FC 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
0461FF 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
046202 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
046205 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
046208 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
04620B 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
04620E 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
046211 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
046214 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
046217 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
04621A 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
04621D 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
046220 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
046223 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
046226 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
046229 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
04622C A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
04622F A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
046232 AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
046235 B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
046238 B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
04623B B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
04623E BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
046241 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
046244 C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
046247 C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
04624A CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
04624D D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
046250 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
046253 D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
046256 DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
046259 DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
04625C E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
04625F E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
046262 E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
046265 EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
046268 EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
04626B EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
04626E F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
046271 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
046274 F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
046277 F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
04627A F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
04627D F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
046280 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
046283 FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
046286 FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
046289 FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
04628C FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
04628F FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
046292 FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
046295 FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
046298 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
04629B FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
04629E FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
0462A1 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
0462A4 FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
0462A7 FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
0462AA FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
0462AD FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
0462B0 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
0462B3 F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
0462B6 F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
0462B9 F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
0462BC F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
0462BF F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
0462C2 F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
0462C5 EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
0462C8 EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
0462CB EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
0462CE E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
0462D1 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
0462D4 E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
0462D7 DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
0462DA DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
0462DD D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
0462E0 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
0462E3 D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
0462E6 CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
0462E9 C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
0462EC C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
0462EF C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
0462F2 BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
0462F5 B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
0462F8 B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
0462FB B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
0462FE AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
046301 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
046304 A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
046307 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
04630A 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
04630D 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
046310 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
046313 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
046316 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
046319 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
04631C 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
04631F 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
046322 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
046325 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
046328 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
04632B 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
04632E 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
046331 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
046334 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
046337 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
04633A 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
04633D 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
046340 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
046343 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
046346 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
046349 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
04634C 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
04634F 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
046352 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
046355 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
046358 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
04635B FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
04635E F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
046361 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
046364 E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
046367 E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
04636A DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
04636D D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
046370 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
046373 C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
046376 C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
046379 BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
04637C B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
04637F B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
046382 AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
046385 A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
046388 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
04638B 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
04638E 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
046391 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
046394 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
046397 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
04639A 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
04639D 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
0463A0 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
0463A3 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
0463A6 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0463A9 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0463AC 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0463AF 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0463B2 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0463B5 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0463B8 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0463BB 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0463BE 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0463C1 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0463C4 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0463C7 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0463CA 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0463CD 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0463D0 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0463D3 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0463D6 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0463D9 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0463DC 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0463DF 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0463E2 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0463E5 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0463E8 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0463EB 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0463EE 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0463F1 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0463F4 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0463F7 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0463FA 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0463FD 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
046400 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
046403 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
046406 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
046409 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
04640C 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
04640F 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
046412 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
046415 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
046418 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
04641B 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
04641E 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
046421 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
046424 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
046427 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
04642A 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
04642D 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
046430 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
046433 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
046436 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
046439 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
04643C 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
04643F 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
046442 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
046445 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
046448 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
04644B 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
04644E 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
046451 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
046454 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
046457 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
04645A 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
04645D 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
046460 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
046463 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
046466 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
046469 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
04646C 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
04646F 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
046472 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
046475 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
046478 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
04647B 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
04647E 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
046481 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
046484 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
046487 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
04648A 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
04648D 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
046490 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
046493 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
046496 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
046499 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
04649C 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
04649F 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0464A2 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0464A5 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0464A8 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0464AB A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0464AE AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0464B1 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0464B4 B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0464B7 BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0464BA C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0464BD C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0464C0 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0464C3 D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0464C6 DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0464C9 E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0464CC E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0464CF EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0464D2 F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0464D5 FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0464D8             0857*  
0464D8             0858*  atan_lut_168:
0464D8 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
0464DB 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
0464DE 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
0464E1 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
0464E4 A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
0464E7 CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
0464EA F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
0464ED 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
0464F0 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
0464F3 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
0464F6 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
0464F9 BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
0464FC E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
0464FF 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
046502 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
046505 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
046508 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
04650B B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
04650E DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
046511 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
046514 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
046517 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
04651A 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
04651D A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
046520 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
046523 F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
046526 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
046529 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
04652C 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
04652F 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
046532 C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
046535 E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
046538 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
04653B 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
04653E 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
046541 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
046544 B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
046547 D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
04654A 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
04654D 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
046550 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
046553 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
046556 A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
046559 C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
04655C EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
04655F 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
046562 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
046565 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
046568 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
04656B B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
04656E DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
046571 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
046574 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
046577 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
04657A 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
04657D 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
046580 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
046583 ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
046586 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
046589 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
04658C 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
04658F 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
046592 AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
046595 D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
046598 FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
04659B 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
04659E 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
0465A1 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
0465A4 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
0465A7 BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
0465AA E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
0465AD 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
0465B0 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
0465B3 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
0465B6 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
0465B9 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
0465BC C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
0465BF E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
0465C2 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
0465C5 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
0465C8 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
0465CB 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
0465CE A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
0465D1 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
0465D4 EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
0465D7 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
0465DA 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
0465DD 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
0465E0 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
0465E3 A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
0465E6 C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
0465E9 EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
0465EC 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
0465EF 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
0465F2 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
0465F5 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
0465F8 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
0465FB C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
0465FE E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
046601 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
046604 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
046607 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
04660A 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
04660D 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
046610 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
046613 DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
046616 FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
046619 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
04661C 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
04661F 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
046622 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
046625 AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
046628 CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
04662B EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
04662E 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
046631 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
046634 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
046637 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
04663A 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
04663D BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
046640 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
046643 FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
046646 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
046649 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
04664C 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
04664F 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
046652 A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
046655 C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
046658 E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
04665B 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
04665E 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
046661 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
046664 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
046667 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
04666A A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
04666D C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
046670 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
046673 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
046676 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
046679 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
04667C 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
04667F 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
046682 A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
046685 C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
046688 E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
04668B FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
04668E 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
046691 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
046694 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
046697 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
04669A 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
04669D B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
0466A0 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
0466A3 F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
0466A6 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
0466A9 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
0466AC 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
0466AF 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
0466B2 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
0466B5 A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
0466B8 C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
0466BB DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
0466BE FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
0466C1 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
0466C4 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
0466C7 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
0466CA 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
0466CD 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
0466D0 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
0466D3 C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
0466D6 E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
0466D9 FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
0466DC 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
0466DF 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
0466E2 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
0466E5 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
0466E8 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
0466EB A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
0466EE C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
0466F1 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
0466F4 F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
0466F7 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
0466FA 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
0466FD 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
046700 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
046703 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
046706 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
046709 B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
04670C CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
04670F E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
046712 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
046715 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
046718 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
04671B 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
04671E 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
046721 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
046724 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
046727 B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
04672A D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
04672D EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
046730 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
046733 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
046736 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
046739 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
04673C 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
04673F 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
046742 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
046745 B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
046748 CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
04674B E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
04674E FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
046751 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
046754 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
046757 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
04675A 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
04675D 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
046760 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
046763 A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
046766 BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
046769 D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
04676C EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
04676F 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
046772 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
046775 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
046778 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
04677B 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
04677E 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
046781 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
046784 A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
046787 BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
04678A D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
04678D E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
046790 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
046793 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
046796 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
046799 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
04679C 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
04679F 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
0467A2 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
0467A5 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
0467A8 AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
0467AB C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
0467AE DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
0467B1 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
0467B4 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
0467B7 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
0467BA 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
0467BD 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
0467C0 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
0467C3 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
0467C6 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
0467C9 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
0467CC AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
0467CF C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
0467D2 D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
0467D5 EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
0467D8 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0467DB             0062   ; App-specific includes
0467DB             0063   	include "src/asm/player.inc"
0467DB             0001*  ; ######## GAME STATE VARIABLES #######
0467DB             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
0467DB 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
0467DE             0004*  ; player current shields,binary
0467DE             0005*  ; when < 0 player splodes
0467DE             0006*  ; restores to player_max_shields when new ship spawns
0467DE 10          0007*  player_shields: db 16 ; binary
0467DF             0008*  ; max player shields,binary
0467DF             0009*  ; can increase with power-ups (todo)
0467DF 10          0010*  player_max_shields: db 16 ; binary
0467E0             0011*  ; when reaches zero,game ends
0467E0             0012*  ; can increase based on TODO
0467E0 03          0013*  player_ships: db 0x03 ; binary
0467E1             0014*  
0467E1             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
0467E1             0016*  ; uses the same offsets from its table base as the main sprite table:
0467E1             0017*  player_start_variables: ; label marking beginning of table
0467E1 04          0018*  player_id:               db table_max_records
0467E2 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
0467E3 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
0467E6 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0467E9 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0467EA 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0467EB 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0467EC 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0467EF 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0467F2 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0467F5 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0467F8 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0467FB 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0467FE 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
046801 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
046802 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
046803 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
046804 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
046805 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
046806 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
046807             0038*  player_end_variables: ; for when we want to traverse this table in reverse
046807             0039*  
046807             0040*  ; set initial player position
046807             0041*  ; inputs: none,everything is hardcoded
046807             0042*  ; outputs: player_x/y set to bottom-left corner of screen
046807             0043*  ; destroys: a
046807             0044*  player_init:
046807 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
046809 CD A1 5B 04 0046*  	call vdu_sprite_select
04680D CD B4 5B 04 0047*      call vdu_sprite_clear_frames
046811 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
046815 CD EE 5C 04 0049*      call vdu_sprite_add_buff
046819 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
04681D CD EE 5C 04 0051*      call vdu_sprite_add_buff
046821 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
046825 CD EE 5C 04 0053*      call vdu_sprite_add_buff
046829 01 00 00 00 0054*      ld bc,0
04682D ED 43 EC 67 0055*      ld (player_x),bc
       04          
046832 11 00 DF 00 0056*      ld de,0x00DF00
046836 ED 53 EF 67 0057*      ld (player_y),de
       04          
04683B CD 6D 5C 04 0058*      call vdu_sprite_move_abs168
04683F CD 17 5C 04 0059*      call vdu_sprite_show
046843 C9          0060*      ret
046844             0061*  
046844             0062*  ; process player keyboard input, set player bitmap
046844             0063*  ; velocities and draw player bitmap at updated coordinates
046844             0064*  ; Inputs: player_x/y set at desired position
046844             0065*  ; Returns: player bitmap drawn at updated position
046844             0066*  ; Destroys: probably everything except maybe iy
046844             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
046844             0068*  ; TODO: requires sprite implementation
046844             0069*  player_input:
046844             0070*  ; reset player component velocities to zero as the default
046844 21 00 00 00 0071*  	ld hl,0
046848 22 F2 67 04 0072*  	ld (player_xvel),hl
04684C 22 F5 67 04 0073*  	ld (player_yvel),hl
046850             0074*  ; make ship the active sprite
046850 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
046852 CD A1 5B 04 0076*      call vdu_sprite_select
046856             0077*  ; check for keypresses and branch accordingly
046856             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
046856             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
046856 3E 1E       0001*M 			LD	A, function
046858 5B CF       0002*M 			RST.LIL	08h
04685A             0080*  ; we test all four arrow keys and add/subract velocities accordingly
04685A             0081*  ; this handles the case where two opposing movement keys
04685A             0082*  ; are down simultaneously (velocities will net to zero)
04685A             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
04685A             0084*  ; it also allows movement and action keys to be detected simultaneously
04685A             0085*  ; so we can walk and chew gum at the same time
04685A 3E 01       0086*      ld a,1 ; set ship's default animation to center
04685C             0087*          ; if left and right are both down a will net to
04685C             0088*  
04685C             0089*  @left:
04685C DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
046860 28 0E       0091*      jr z,@right
046862 2A F2 67 04 0092*      ld hl,(player_xvel)
046866 01 00 FD FF 0093*      ld bc,-speed_player
04686A 09          0094*      add hl,bc
04686B 22 F2 67 04 0095*      ld (player_xvel),hl
04686F 3D          0096*      dec a ; set ship's animation to left
046870             0097*  @right:
046870 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
046874 28 0E       0099*  	jr z,@up
046876 2A F2 67 04 0100*      ld hl,(player_xvel)
04687A 01 00 03 00 0101*      ld bc,speed_player
04687E 09          0102*      add hl,bc
04687F 22 F2 67 04 0103*      ld (player_xvel),hl
046883 3C          0104*      inc a ; set ship's animation to right
046884             0105*  @up:
046884 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
046888 28 0D       0107*  	jr z,@down
04688A 2A F5 67 04 0108*      ld hl,(player_yvel)
04688E 01 00 FD FF 0109*      ld bc,-speed_player
046892 09          0110*      add hl,bc
046893 22 F5 67 04 0111*      ld (player_yvel),hl
046897             0112*  @down:
046897 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
04689B 28 0D       0114*  	jr z,@done_keyboard
04689D 2A F5 67 04 0115*      ld hl,(player_yvel)
0468A1 01 00 03 00 0116*      ld bc,speed_player
0468A5 09          0117*      add hl,bc
0468A6 22 F5 67 04 0118*      ld (player_yvel),hl
0468AA             0119*  @done_keyboard:
0468AA             0120*  ; move player sprite according to velocities set by keypresses
0468AA 2A F2 67 04 0121*      ld hl,(player_xvel)
0468AE             0122*  ; compute new x position
0468AE ED 5B EC 67 0123*      ld de,(player_x)
       04          
0468B3 19          0124*      add hl,de ; hl = player_x + player_xvel
0468B4             0125*      ; check for horizontal screen edge collisions
0468B4             0126*      ; and adjust coordinate as necessary
0468B4             0127*  ; TODO: make this work using 24-bit registers
0468B4             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
0468B4             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
0468B4             0130*      ; ld a,8 ; set x to leftmost allowable position
0468B4             0131*  ; @check_right:
0468B4             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
0468B4             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
0468B4             0134*  ;     ld a,248 ; set x to rightmost allowable position
0468B4             0135*  @x_ok:
0468B4             0136*  ; save the updated drawing coordinate
0468B4 22 EC 67 04 0137*      ld (player_x),hl
0468B8             0138*  ;compute new y position
0468B8 2A EF 67 04 0139*      ld hl,(player_y)
0468BC ED 5B F5 67 0140*      ld de,(player_yvel)
       04          
0468C1 19          0141*      add hl,de ; hl = player_y + player_yvel
0468C2             0142*  ; TODO: make this work using 24-bit registers
0468C2             0143*  ;     ; check for vertical screen edge collisions
0468C2             0144*  ;     ; and adjust coordinate as necessary
0468C2             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
0468C2             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0468C2             0147*  ;     ld a,8 ; set y to topmost allowable position
0468C2             0148*  ; @check_top:
0468C2             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
0468C2             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
0468C2             0151*  ;     ld a,232 ; set y to bottommost allowable position
0468C2             0152*  @y_ok:
0468C2 22 EF 67 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
0468C6             0154*  ; a should land here loaded with the correct frame
0468C6 CD 04 5C 04 0155*      call vdu_sprite_select_frame
0468CA             0156*  ; draw player at updated position
0468CA ED 4B EC 67 0157*      ld bc,(player_x)
       04          
0468CF ED 5B EF 67 0158*  	ld de,(player_y)
       04          
0468D4             0159*  
0468D4             0160*      ; call dumpRegistersHex
0468D4             0161*  
0468D4 CD 6D 5C 04 0162*  	call vdu_sprite_move_abs168
0468D8             0163*  
0468D8             0164*  ; end player_input
0468D8 C9          0165*  	ret
0468D9             0166*  
0468D9             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
0468D9             0168*  ; ; INSTEAD OF FRACTIONAL
0468D9             0169*  ; ; ----------------------------------------------------------------
0468D9             0170*  ; ; process player keyboard input, set player bitmap
0468D9             0171*  ; ; velocities and draw player bitmap at updated coordinates
0468D9             0172*  ; ; Inputs: player_x/y set at desired position
0468D9             0173*  ; ; Returns: player bitmap drawn at updated position
0468D9             0174*  ; ; Destroys: probably everything except maybe iy
0468D9             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
0468D9             0176*  ; ; TODO: requires sprite implementation
0468D9             0177*  ; player_input:
0468D9             0178*  ; ; reset player component velocities to zero as the default
0468D9             0179*  ; 	ld hl,0
0468D9             0180*  ; 	ld (player_xvel),hl
0468D9             0181*  ; 	ld (player_yvel),hl
0468D9             0182*  ; ; check for keypresses and branch accordingly
0468D9             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0468D9             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0468D9             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
0468D9             0186*  ; ; this handles the case where two opposing movement keys
0468D9             0187*  ; ; are down simultaneously (velocities will net to zero)
0468D9             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
0468D9             0189*  ; ; it also allows movement and action keys to be detected simultaneously
0468D9             0190*  ; ; so we can walk and chew gum at the same time
0468D9             0191*  ; @left:
0468D9             0192*  ;     bit 1,(ix+3) ; keycode 26
0468D9             0193*  ;     jr z,@right
0468D9             0194*  ;     ld hl,(player_xvel)
0468D9             0195*  ;     ld bc,-3
0468D9             0196*  ;     add hl,bc
0468D9             0197*  ;     ld (player_xvel),hl
0468D9             0198*  ; @right:
0468D9             0199*  ;     bit 1,(ix+15) ; keycode 122
0468D9             0200*  ; 	jr z,@up
0468D9             0201*  ;     ld hl,(player_xvel)
0468D9             0202*  ;     ld bc,3
0468D9             0203*  ;     add hl,bc
0468D9             0204*  ;     ld (player_xvel),hl
0468D9             0205*  ; @up:
0468D9             0206*  ;     bit 1,(ix+7) ; keycode 58
0468D9             0207*  ; 	jr z,@down
0468D9             0208*  ;     ld hl,(player_yvel)
0468D9             0209*  ;     ld bc,-3
0468D9             0210*  ;     add hl,bc
0468D9             0211*  ;     ld (player_yvel),hl
0468D9             0212*  ; @down:
0468D9             0213*  ;     bit 1,(ix+5) ; keycode 42
0468D9             0214*  ; 	jr z,@done_keyboard
0468D9             0215*  ;     ld hl,(player_yvel)
0468D9             0216*  ;     ld bc,3
0468D9             0217*  ;     add hl,bc
0468D9             0218*  ;     ld (player_yvel),hl
0468D9             0219*  ; @done_keyboard:
0468D9             0220*  ; ; move player sprite according to velocities set by keypresses
0468D9             0221*  ;     ld hl,(player_xvel)
0468D9             0222*  ; ; compute new x position
0468D9             0223*  ;     ld de,(player_x)
0468D9             0224*  ;     add hl,de ; hl = player_x + player_xvel
0468D9             0225*  ;     ; check for horizontal screen edge collisions
0468D9             0226*  ;     ; and adjust coordinate as necessary
0468D9             0227*  ; ; TODO: make this work using 24-bit registers
0468D9             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
0468D9             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
0468D9             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
0468D9             0231*  ; ; @check_right:
0468D9             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
0468D9             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
0468D9             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
0468D9             0235*  ; @x_ok:
0468D9             0236*  ;     ; save the updated drawing coordinate
0468D9             0237*  ;     ld (player_x),hl
0468D9             0238*  ; ;compute new y position
0468D9             0239*  ;     ld hl,(player_y)
0468D9             0240*  ;     ld de,(player_yvel)
0468D9             0241*  ;     add hl,de ; hl = player_y + player_yvel
0468D9             0242*  ; ; TODO: make this work using 24-bit registers
0468D9             0243*  ; ;     ; check for vertical screen edge collisions
0468D9             0244*  ; ;     ; and adjust coordinate as necessary
0468D9             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
0468D9             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0468D9             0247*  ; ;     ld a,8 ; set y to topmost allowable position
0468D9             0248*  ; ; @check_top:
0468D9             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
0468D9             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
0468D9             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
0468D9             0252*  ; @y_ok:
0468D9             0253*  ;     ld (player_y),hl
0468D9             0254*  ; ; draw player at updated position
0468D9             0255*  ;     ld a,table_max_records ; this is always player spriteId
0468D9             0256*  ;     call vdu_sprite_select
0468D9             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
0468D9             0258*  ;     call get_sign_hlu ; to set the proper animation
0468D9             0259*  ;     add a,1 ; ...
0468D9             0260*  ;     call vdu_sprite_select_frame
0468D9             0261*  ;     ld bc,(player_x)
0468D9             0262*  ; 	ld de,(player_y)
0468D9             0263*  ; 	call vdu_sprite_move_abs
0468D9             0264*  ; ; end player_input
0468D9             0265*  ; 	ret
0468D9             0266*  
0468D9             0267*  
0468D9             0268*  ; ###################################################################
0468D9             0269*  ; TODO: the below is all stuff from the original code we need to port
0468D9             0270*  ; ###################################################################
0468D9             0271*  
0468D9             0272*  ; kill_player:
0468D9             0273*  ; ; set player status to dead
0468D9             0274*  ;     xor a; sets all player flags to zero
0468D9             0275*  ;     ld (player_collisions),a
0468D9             0276*  ; ; deduct a ship from the inventory
0468D9             0277*  ;     ld a,(player_ships)
0468D9             0278*  ;     dec a
0468D9             0279*  ;     ld (player_ships),a
0468D9             0280*  ; ; are we out of ships?
0468D9             0281*  ;     jp z,game_over
0468D9             0282*  ; ; wait a few ticks
0468D9             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
0468D9             0284*  ;     ld (player_move_timer),a
0468D9             0285*  ; kill_player_loop:
0468D9             0286*  ;     call vdu_vblank
0468D9             0287*  ;     ld a,(player_move_timer)
0468D9             0288*  ;     dec a
0468D9             0289*  ;     ld (player_move_timer),a
0468D9             0290*  ;     jr nz,kill_player_loop
0468D9             0291*  ;     call player_init ; player respawn if timer zero
0468D9             0292*  ;     ret ; and out
0468D9             0293*  
0468D9             0294*  
0468D9             0295*  ; player_move:
0468D9             0296*  ; ; begin setting player to active sprite
0468D9             0297*  ;     ld hl,player
0468D9             0298*  ;     ld (sprite_base_bufferId),hl
0468D9             0299*  ;     ld hl,0 ; north
0468D9             0300*  ;     ld (sprite_heading),hl
0468D9             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
0468D9             0302*  ;     ld (sprite_animation),a
0468D9             0303*  ;     ; we set position here for the time being as a default
0468D9             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
0468D9             0305*  ;     ld hl,(player_x)
0468D9             0306*  ;     ld (sprite_x),hl
0468D9             0307*  ;     ld hl,(player_y)
0468D9             0308*  ;     ld (sprite_y),hl
0468D9             0309*  ; ; did we just die?
0468D9             0310*  ;     ld a,(player_collisions)
0468D9             0311*  ;     and %00000010 ; zero flag will be set if not dead
0468D9             0312*  ;     jr z,player_not_dead
0468D9             0313*  ; ; yes we died
0468D9             0314*  ;     call kill_player
0468D9             0315*  ;     ret ; done
0468D9             0316*  ; ; yay we didn't die
0468D9             0317*  ; player_not_dead:
0468D9             0318*  ; ; set player movements to zero by default
0468D9             0319*  ;     ld hl,0
0468D9             0320*  ;     ld (player_xvel),hl
0468D9             0321*  ;     ld (player_yvel),hl
0468D9             0322*  ; ; do we move it?
0468D9             0323*  ;     in a,(#82) ; keyboard
0468D9             0324*  ;     or a ; if zero,don't move
0468D9             0325*  ;     jr z,player_draw
0468D9             0326*  ; ; move it
0468D9             0327*  ;     call player_move_calc
0468D9             0328*  ; player_draw:
0468D9             0329*  ;     call vdu_bmp_select
0468D9             0330*  ;     call vdu_bmp_draw
0468D9             0331*  ; player_move_done:
0468D9             0332*  ;     ; write updated x,y coordinates back to player table
0468D9             0333*  ;     ld hl,(sprite_x)
0468D9             0334*  ;     ld (player_x),hl
0468D9             0335*  ;     ld hl,(sprite_y)
0468D9             0336*  ;     ld (player_y),hl
0468D9             0337*  ;     ret
0468D9             0064   	include "src/asm/tiles.inc"
0468D9             0001*  ; ######### TILES #########
0468D9             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
0468D9             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
0468D9 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
0468DC 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
0468DD             0006*                          ; initialize to zero for a maximum of 256 rows in a level
0468DD 00          0007*  cur_level: db 0
0468DE             0008*  num_levels: equ 2 ; number of levels,duh
0468DE             0009*  
0468DE             0010*  ; lookup table for level definitions
0468DE 61 41 04 62 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       51 04       
0468E4             0012*  
0468E4             0013*  ; tiles_bufferId: dl 0
0468E4 00 00 00    0014*  tiles_x_plot: dl 0
0468E7 F1 FF FF    0015*  tiles_y_plot: dl -15
0468EA             0016*  
0468EA             0017*  
0468EA             0018*  tiles_plot:
0468EA             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
0468EA             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
0468EA             0021*  ; ;       but don't want
0468EA             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
0468EA             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
0468EA             0024*  ; 	ld bc,0 ; leftmost x-coord
0468EA             0025*  ; 	ld de,0 ; topmost y-coord
0468EA             0026*  ; 	ld ix,255 ; rightmost x-coord
0468EA             0027*  ; 	ld iy,1 ; bottommost y-coord
0468EA             0028*  ; 	call vdu_set_gfx_viewport
0468EA             0029*  
0468EA 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
0468EE 22 E4 68 04 0031*      ld (tiles_x_plot),hl
0468F2 2A D9 68 04 0032*      ld hl,(tiles_row_defs)
0468F6 06 10       0033*  	ld b,16 ; loop counter
0468F8             0034*  @loop:
0468F8 C5          0035*  	push bc ; save the loop counter
0468F9             0036*  ; read the tile defintion for the current column
0468F9 7E          0037*      ld a,(hl) ; a has tile definition
0468FA E5          0038*      push hl  ; save pointer to tile definition
0468FB 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
0468FF 6F          0040*      ld l,a ; l is tile defintion
046900 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
046902 CD 2F 59 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
046906             0043*  
046906             0044*  ; plot the active bitmap
046906 ED 4B E4 68 0045*      ld bc,(tiles_x_plot)
       04          
04690B ED 5B E7 68 0046*      ld de,(tiles_y_plot)
       04          
046910 CD 00 5B 04 0047*      call vdu_plot_bmp
046914             0048*  
046914             0049*  ; bump x-coords the width of one tile and save it
046914 2A E4 68 04 0050*      ld hl,(tiles_x_plot)
046918 01 10 00 00 0051*      ld bc,16
04691C 09          0052*      add hl,bc
04691D 22 E4 68 04 0053*      ld (tiles_x_plot),hl
046921             0054*  
046921             0055*  ; prepare to loop to next column
046921 E1          0056*      pop hl ; get back pointer to tile def
046922 23          0057*      inc hl ; bump it to the next column
046923 C1          0058*  	pop bc ; snag our loop counter
046924 10 D2       0059*      djnz @loop
046926             0060*  
046926             0061*  ; increment tiles plotting y-coordinate
046926             0062*  ; when it hits zero, we go to next row of tiles in the map
046926             0063*  ; (we use ix b/c we want to preserve hl for the next step)
046926 DD 21 E7 68 0064*  	ld ix,tiles_y_plot
       04          
04692B DD 34 00    0065*  	inc (ix)
04692E C0          0066*  	ret nz
04692F             0067*  
04692F             0068*  ; time to bump tiles_row_defs to next row
04692F             0069*  ; (hl was already there at the end of the loop)
04692F 22 D9 68 04 0070*      ld (tiles_row_defs),hl
046933             0071*  
046933             0072*  ; reset coords to plot next row of tiles
046933 21 00 00 00 0073*      ld hl,0
046937 22 E4 68 04 0074*      ld (tiles_x_plot),hl
04693B 21 F1 FF FF 0075*      ld hl,-15
04693F 22 E7 68 04 0076*      ld (tiles_y_plot),hl
046943             0077*  
046943             0078*  ; decrement tiles row counter
046943 21 DC 68 04 0079*      ld hl,tiles_row
046947 35          0080*      dec (hl)
046948 C0          0081*      ret nz
046949             0082*  
046949             0083*  ; queue up next level
046949 3A DD 68 04 0084*      ld a,(cur_level)
04694D FE 01       0085*      cp num_levels-1
04694F 20 02       0086*      jr nz,@inc_level
046951 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
046953             0088*  
046953             0089*  @inc_level:
046953 3C          0090*      inc a
046954 32 DD 68 04 0091*      ld (cur_level),a
046958             0092*  
046958             0093*  ; increase the number of enemy sprites
046958 3A A7 69 04 0094*      ld a,(max_enemy_sprites)
04695C 3C          0095*      inc a
04695D FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
04695F 28 04       0097*      jr z,init_level
046961 32 A7 69 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
046965             0099*  ; fall through to init_level
046965             0100*  
046965             0101*  init_level:
046965             0102*  ; look up address of level's tile defintion
046965 21 DE 68 04 0103*      ld hl,tiles_levels
046969 3A DD 68 04 0104*      ld a,(cur_level)
04696D 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
046971 57          0106*      ld d,a
046972 1E 03       0107*      ld e,3
046974 ED 5C       0108*      mlt de
046976 19          0109*      add hl,de
046977 ED 37       0110*      ld ix,(hl)
046979 DD 22 D9 68 0111*      ld (tiles_row_defs),ix
       04          
04697E             0112*  
04697E             0113*  ; set tiles_row counter
04697E DD 7E 00    0114*      ld a,(ix)
046981 32 DC 68 04 0115*      ld (tiles_row),a
046985 DD 23       0116*      inc ix ; now ix points first element of first row tile def
046987 DD 22 D9 68 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
04698C C9          0118*      ret
04698D             0119*  
04698D             0120*  
04698D             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
04698D             0122*  ; dt_is_active:
04698D             0123*  ; ; a lands here containing a tile index in the low nibble
04698D             0124*  ; ; we test the values for the tiles which are active
04698D             0125*  ;     cp #07
04698D             0126*  ;     call z,ld_act_landing_pad
04698D             0127*  ;     cp #08
04698D             0128*  ;     call z,ld_act_laser_turret
04698D             0129*  ;     ; fall through
04698D             0130*  ;     ret
04698D             0131*  
04698D             0132*  ; ; some tiles become active sprites,so we load those here
04698D             0133*  ; ; sprite_x/y have already been loaded
04698D             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
04698D             0135*  ; ; we don't want sprite drawn to background like other tiles
04698D             0136*  ; ; so this routine only adds them to the sprite table
04698D             0137*  ; dt_ld_act:
04698D             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
04698D             0139*  ;     ld (sprite_y+1),a ; just the integer part
04698D             0140*  ;     ld (sprite_base_bufferId),hl
04698D             0141*  ;     call vdu_bmp_select
04698D             0142*  ;     call table_add_record
04698D             0143*  ;     call sprite_variables_from_stack
04698D             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
04698D             0145*  ;     ret ; and back
04698D             0146*  
04698D             0147*  ; ld_act_landing_pad:
04698D             0148*  ;     call sprite_variables_to_stack
04698D             0149*  
04698D             0150*  ;     ld hl,move_landing_pad
04698D             0151*  ;     ld (sprite_move_program),hl
04698D             0152*  
04698D             0153*  ;     xor a
04698D             0154*  ;     ld (sprite_animation),a ; animation 0
04698D             0155*  
04698D             0156*  ;     call rand_8     ; snag a random number
04698D             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04698D             0158*  ;     add a,64 ; range is now 64-127
04698D             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04698D             0160*  
04698D             0161*  ;     ld a,%10 ; collides with laser but not player
04698D             0162*  ;     ld (iy+sprite_collisions),a
04698D             0163*  
04698D             0164*  ;     ld a,#05 ; BCD
04698D             0165*  ;     ld (sprite_points),a
04698D             0166*  ;     ld a,0 ; binary
04698D             0167*  ;     ld (sprite_shield_damage),a
04698D             0168*  
04698D             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
04698D             0170*  ;     jr dt_ld_act
04698D             0171*  
04698D             0172*  ; ld_act_laser_turret:
04698D             0173*  ;     call sprite_variables_to_stack
04698D             0174*  
04698D             0175*  ;     ld hl,move_laser_turret
04698D             0176*  ;     ld (sprite_move_program),hl
04698D             0177*  
04698D             0178*  ;     xor a
04698D             0179*  ;     ld (sprite_animation),a
04698D             0180*  ;     ld (sprite_move_step),a
04698D             0181*  
04698D             0182*  ;     call rand_8     ; snag a random number
04698D             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04698D             0184*  ;     add a,64 ; range is now 64-127
04698D             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04698D             0186*  
04698D             0187*  ;     ld a,%10 ; collides with laser but not player
04698D             0188*  ;     ld (iy+sprite_collisions),a
04698D             0189*  
04698D             0190*  ;     ld a,#10 ; BCD
04698D             0191*  ;     ld (sprite_points),a
04698D             0192*  ;     ld a,0 ; binary
04698D             0193*  ;     ld (sprite_shield_damage),a
04698D             0194*  
04698D             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
04698D             0196*  ;     jp dt_ld_act
04698D             0197*  
04698D             0198*  
04698D             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
04698D             0200*  ; deletes sprites from table when they wrap around to top of screen
04698D             0201*  move_active_tiles:
04698D             0202*  ; get current position
04698D 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
046991 3C          0204*      inc a
046992             0205*  ; are we at the bottom of the screen?
046992 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
046994             0207*  ; otherwise kill sprite
046994 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
046996 FD 77 08    0209*      ld (iy+sprite_collisions),a
046999 C9          0210*      ret ; debug
04699A             0211*  move_active_tiles_draw_sprite:
04699A 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
04699E CD 1C 59 04 0213*      call vdu_bmp_select
0469A2 CD 65 59 04 0214*      call vdu_bmp_draw ; draw it
0469A6 C9          0215*      ret ; and done
0469A7             0065   	include "src/asm/enemies.inc"
0469A7 10          0001*  max_enemy_sprites: db 16
0469A8             0002*  
0469A8             0003*  ; sprite_type
0469A8             0004*  enemy_dead: equ 0
0469A8             0005*  enemy_small: equ 1
0469A8             0006*  enemy_medium: equ 2
0469A8             0007*  enemy_large: equ 3
0469A8             0008*  landing_pad: equ 4
0469A8             0009*  laser_turret: equ 5
0469A8             0010*  fireballs: equ 6
0469A8             0011*  explosion: equ 7
0469A8             0012*  
0469A8             0013*  
0469A8             0014*  respawn_countdown:
0469A8 2A C9 69 04 0015*      ld hl,(respawn_timer)
0469AC 2B          0016*      dec hl
0469AD 22 C9 69 04 0017*      ld (respawn_timer),hl
0469B1             0018*  ; check hl for zero
0469B1 19          0019*      add hl,de
0469B2 B7          0020*      or a
0469B3 ED 52       0021*      sbc hl,de
0469B5 C0          0022*      ret nz
0469B6 06 04       0023*      ld b,table_max_records
0469B8             0024*  @respawn_loop:
0469B8 C5          0025*      push bc
0469B9 CD BA 6A 04 0026*      call enemy_init_from_landing_pad
0469BD C1          0027*      pop bc
0469BE 10 F8       0028*      djnz @respawn_loop
0469C0 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
0469C4 22 C9 69 04 0030*      ld (respawn_timer),hl
0469C8 C9          0031*      ret
0469C9 3C 00 00    0032*  respawn_timer: dl 1*60
0469CC             0033*  
0469CC             0034*  move_enemies:
0469CC             0035*  ; are there any active enemies or explosions?
0469CC 21 00 00 00 0036*      ld hl,0
0469D0 3A FE 52 04 0037*      ld a,(table_active_sprites)
0469D4 6F          0038*      ld l,a
0469D5             0039*      ; call dumpRegistersHex
0469D5 A7          0040*      and a ; will be zero if no alive enemies or explosions
0469D6             0041*      ; ret z ; so nothing to do but go back
0469D6             0042*      ; ld hl,(respawn_timer)
0469D6             0043*      ; call dumpRegistersHex
0469D6 20 05       0044*      jr nz,move_enemies_do
0469D8 CD A8 69 04 0045*      call respawn_countdown
0469DC C9          0046*      ret
0469DD             0047*  move_enemies_do:
0469DD             0048*  ; initialize pointers and loop counter
0469DD FD 21 63 52 0049*      ld iy,table_base ; set iy to first record in table
       04          
0469E2 06 04       0050*      ld b,table_max_records ; loop counter
0469E4             0051*  move_enemies_loop:
0469E4 FD 22 FB 52 0052*      ld (table_pointer),iy ; update table pointer
       04          
0469E9 C5          0053*      push bc ; backup loop counter
0469EA             0054*  ; check sprite_type to see if sprite is active
0469EA FD 7E 01    0055*      ld a,(iy+sprite_type)
0469ED A7          0056*      and a ; if zero, sprite is dead
0469EE 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
0469F0             0058*  ; otherwise we prepare to move the sprite
0469F0 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
0469F3 CD A1 5B 04 0060*      call vdu_sprite_select ; select sprite
0469F7 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0469FA E9          0062*      jp (hl)  ; ... and jump to it
0469FB             0063*  ; we always jp back here from behavior subroutines
0469FB             0064*  move_enemies_loop_return:
0469FB FD 2A FB 52 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
046A00             0066*  ; now we check results of all the moves
046A00 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
046A03 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
046A05 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
046A08 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
046A0A CD 47 53 04 0071*      call table_deactivate_sprite ; otherwise we ded
046A0E AF          0072*      xor a ; zero a so that we can ...
046A0F FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
046A12 18 0A       0074*      jr move_enemies_next_record ; and to the next record
046A14             0075*  move_enemies_draw_sprite:
046A14             0076*  ; if we got here sprite will have already been activated
046A14             0077*  ; so all we need to do is set its coordinates and draw it
046A14 FD 07 0B    0078*      ld bc,(iy+sprite_x)
046A17 FD 17 0E    0079*      ld de,(iy+sprite_y)
046A1A CD 6D 5C 04 0080*      call vdu_sprite_move_abs168
046A1E             0081*  ; fall through to next record
046A1E             0082*  move_enemies_next_record:
046A1E 11 26 00 00 0083*      ld de,table_bytes_per_record
046A22 FD 19       0084*      add iy,de ; point to next record
046A24 AF          0085*      xor a ; clears carry flag
046A25 32 FF 52 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
046A29 C1          0087*      pop bc ; get back our loop counter
046A2A 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
046A2C C9          0089*      ret ; and we're out
046A2D             0090*  
046A2D             0091*  en_nav_zigzag_start:
046A2D FD 2A FB 52 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046A32 CD 63 5F 04 0093*      call rand_8
046A36 E6 3F       0094*      and %00111111 ; limit it to 64
046A38 CB DF       0095*      set 3,a ; make sure it's at least 8
046A3A FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
046A3D             0097*      ; fall through to en_nav_zigzag
046A3D             0098*  en_nav_zigzag:
046A3D FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
046A40 3D          0100*      dec a
046A41 FD 77 22    0101*      ld (iy+sprite_move_timer),a
046A44 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
046A46             0103*      ; otherwise flip direction and restart timer
046A46 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
046A49 EE 01       0105*      xor %1 ; flips bit one
046A4B FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
046A4E 20 09       0107*      jr nz,en_nav_zigzag_right
046A50             0108*  ;otherwise zag left
046A50 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
046A54 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
046A57 18 D4       0111*      jr en_nav_zigzag_start
046A59             0112*  en_nav_zigzag_right:
046A59 21 00 60 00 0113*      ld hl,0x006000; southeast heading
046A5D FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
046A60 18 CB       0115*      jr en_nav_zigzag_start
046A62             0116*  en_nav_zigzag_no_switch:
046A62             0117*      ; ld a,(sprite_orientation)
046A62 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
046A65 18 13       0119*      jr en_nav_computevelocities
046A67             0120*  
046A67             0121*  ; contains the logic for how to move the enemy
046A67             0122*  ; and then does the moving
046A67             0123*  ; inputs: a fully-populated active sprite table
046A67             0124*  ;         player position variables
046A67             0125*  ; destroys: everything except index registers
046A67             0126*  ; outputs: moving enemies
046A67             0127*  en_nav:
046A67             0128*  ; set velocity and orientation by player's relative location
046A67             0129*  ; move enemies y-axis
046A67             0130*  ; where is player relative to us?
046A67 CD 3D 6B 04 0131*      call orientation_to_player
046A6B             0132*  ;    h.l 16.8 fixed angle256 to player
046A6B             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046A6B             0134*  ; is player above or below us?
046A6B ED 53 7A 56 0135*      ld (ude),de ; dy
       04          
046A70 3A 7C 56 04 0136*      ld a,(ude+2) ; deu
046A74 17          0137*      rla ; shift sign bit into carry
046A75 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
046A77             0139*  ; player is even or above,so home in on current heading
046A77 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
046A7A             0141*  
046A7A             0142*  ; we land here from zig-zag program so as not to
046A7A             0143*  ; redundantly save orientation and heading
046A7A             0144*  en_nav_computevelocities:
046A7A             0145*  ; set x/y component velocities based on bearing to player
046A7A FD 2A FB 52 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046A7F E5          0147*      push hl ; we need it back to set rotation frame
046A80 FD 17 17    0148*      ld de,(iy+sprite_vel)
046A83 CD 8F 5F 04 0149*      call polar_to_cartesian
046A87 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
046A8A FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
046A8D             0152*  ; change the animation frame to match heading
046A8D             0153*  ; by dividng the heading by 8
046A8D E1          0154*      pop hl ; get back Heading
046A8E 7C          0155*      ld a,h
046A8F CB 3F       0156*      srl a
046A91 CB 3F       0157*      srl a
046A93 CB 3F       0158*      srl a
046A95 CD 04 5C 04 0159*      call vdu_sprite_select_frame
046A99             0160*  ; update sprite position
046A99             0161*  move_enemy_sprite:
046A99 FD 27 0B    0162*      ld hl,(iy+sprite_x)
046A9C FD 17 11    0163*      ld de,(iy+sprite_xvel)
046A9F 19          0164*      add hl,de
046AA0 FD 2F 0B    0165*      ld (iy+sprite_x),hl
046AA3             0166*  
046AA3 FD 27 0E    0167*      ld hl,(iy+sprite_y)
046AA6 FD 17 14    0168*      ld de,(iy+sprite_yvel)
046AA9 19          0169*      add hl,de
046AAA FD 2F 0E    0170*      ld (iy+sprite_y),hl
046AAD C9          0171*      ret
046AAE             0172*  
046AAE             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
046AAE             0174*  ; move_enemy_sprite:
046AAE             0175*  ; ; x-axis movement first
046AAE             0176*  ;     ld hl,(iy+sprite_x)
046AAE             0177*  ;     push hl ; save pre-move position
046AAE             0178*  ;     pop bc ; to detect screen edge collision
046AAE             0179*  ;     ld de,(iy+sprite_xvel)
046AAE             0180*  ;     add hl,de ;compute new x position
046AAE             0181*  ;     ld (iy+sprite_x),hl ; store it
046AAE             0182*  ;     and a ; clear the carry flag
046AAE             0183*  ;     sbc hl,bc ; test which direction was our movement
046AAE             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
046AAE             0185*  ;     jp p,@move_right ; sign positive means moved right
046AAE             0186*  ; @move_left: ; otherwise we moved left
046AAE             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
046AAE             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
046AAE             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
046AAE             0190*  ;     ld a,#20 ; west
046AAE             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AAE             0192*  ;     jr @move_y
046AAE             0193*  ; @move_right:
046AAE             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
046AAE             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046AAE             0196*  ;     ld l,0x00
046AAE             0197*  ;     ld a,(iy+sprite_dim_x)
046AAE             0198*  ;     ld h,a
046AAE             0199*  ;     ld a,0x00
046AAE             0200*  ;     sub h
046AAE             0201*  ;     ld h,a
046AAE             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
046AAE             0203*  ;     ld a,0x02 ; east
046AAE             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AAE             0205*  ; @move_y:
046AAE             0206*  ;     ld hl,(iy+sprite_y)
046AAE             0207*  ;     ld b,h ; save pre-move position
046AAE             0208*  ;     ld c,l ; to detect screen edge collision
046AAE             0209*  ;     ld de,(iy+sprite_yvel)
046AAE             0210*  ;     add hl,de ;compute new y position
046AAE             0211*  ;     ld (iy+sprite_y),hl ; store it
046AAE             0212*  ;     and a ; clear the carry flag
046AAE             0213*  ;     sbc hl,bc ; test which direction was our movement
046AAE             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
046AAE             0215*  ;     jp p,@move_dn ; sign positive means moved down
046AAE             0216*  ; @move_up:
046AAE             0217*  ;     add hl,bc ; get back new y position
046AAE             0218*  ;     ld de,0x5000 ; top edge of visible screen
046AAE             0219*  ;     and a ; clear the carry flag
046AAE             0220*  ;     sbc hl,de
046AAE             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
046AAE             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
046AAE             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
046AAE             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046AAE             0225*  ;     or 0x80 ; north
046AAE             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AAE             0227*  ;     jr @move_ret
046AAE             0228*  ; @move_dn:
046AAE             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
046AAE             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046AAE             0231*  ;     ld l,0x00
046AAE             0232*  ;     ld a,(iy+sprite_dim_y)
046AAE             0233*  ;     ld h,a
046AAE             0234*  ;     ld a,0x00
046AAE             0235*  ;     sub h
046AAE             0236*  ;     ld h,a
046AAE             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
046AAE             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046AAE             0239*  ;     or 0x08 ; south
046AAE             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AAE             0241*  ; @move_ret:
046AAE             0242*  ;     ret
046AAE             0243*  
046AAE             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
046AAE             0245*  ; ; each sprite in the table must have one of these defined
046AAE             0246*  ; ; but they need not be unique to a particular sprite
046AAE             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
046AAE             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
046AAE             0249*  ; ; but they can call anything they want between those two endpoints
046AAE             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
046AAE             0251*  
046AAE             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
046AAE             0253*  ;     jp move_enemies_loop_return
046AAE             0254*  
046AAE             0255*  ; move_explosion:
046AAE             0256*  ;     call animate_explosion
046AAE             0257*  ;     jp move_enemies_loop_return
046AAE             0258*  
046AAE             0259*  move_enemy_small:
046AAE CD 67 6A 04 0260*      call en_nav
046AB2 CD D9 6B 04 0261*      call check_collisions
046AB6 C3 FB 69 04 0262*      jp move_enemies_loop_return
046ABA             0263*  
046ABA             0264*  ; move_enemy_medium:
046ABA             0265*  ;     call en_nav
046ABA             0266*  ;     call check_collisions
046ABA             0267*  ;     jp move_enemies_loop_return
046ABA             0268*  
046ABA             0269*  ; move_enemy_large:
046ABA             0270*  ;     call en_nav
046ABA             0271*  ;     call check_collisions
046ABA             0272*  ;     jp move_enemies_loop_return
046ABA             0273*  
046ABA             0274*  ; move_landing_pad:
046ABA             0275*  ;     call move_active_tiles
046ABA             0276*  ;     call check_collisions
046ABA             0277*  ; ; is it time to launch an enemy?
046ABA             0278*  ;     ld hl,sprite_move_timer
046ABA             0279*  ;     dec (hl)
046ABA             0280*  ;     jp nz,move_enemies_loop_return
046ABA             0281*  ;     call enemy_init_from_landing_pad
046ABA             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
046ABA             0283*  ;     call rand_8     ; snag a random number
046ABA             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046ABA             0285*  ;     add a,64 ; range is now 64-127
046ABA             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
046ABA             0287*  ;     jp move_enemies_loop_return
046ABA             0288*  
046ABA             0289*  enemy_init_from_landing_pad:
046ABA             0290*  ; get next available spriteId
046ABA CD 22 53 04 0291*      call table_get_next_id
046ABE D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
046ABF             0293*  ; ix comes back with the pointer to the new sprite variables
046ABF DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
046AC1             0295*  ; a comes back with the spriteId of the new sprite
046AC1 32 17 6B 04 0296*      ld (@id),a
046AC5             0297*  ; initialize the new sprite
046AC5 CD A1 5B 04 0298*      call vdu_sprite_select
046AC9 CD B4 5B 04 0299*      call vdu_sprite_clear_frames
046ACD 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
046AD1 06 20       0301*      ld b,32
046AD3             0302*  @load_frames:
046AD3 C5          0303*      push bc
046AD4 E5          0304*      push hl
046AD5 CD EE 5C 04 0305*      call vdu_sprite_add_buff
046AD9 E1          0306*      pop hl
046ADA 23          0307*      inc hl
046ADB C1          0308*      pop bc
046ADC 10 F5       0309*      djnz @load_frames
046ADE             0310*  ; copy coordinates of active sprite to new sprite
046ADE FD 2A FB 52 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046AE3             0312*      ; ld hl,(iy+sprite_x)
046AE3             0313*  	; ld hl,0x008000 ; debug
046AE3             0314*  
046AE3 CD 63 5F 04 0315*      call rand_8
046AE7 21 00 00 00 0316*      ld hl,0
046AEB 67          0317*      ld h,a
046AEC             0318*  
046AEC 22 22 6B 04 0319*      ld (@x),hl
046AF0             0320*      ; ld hl,(iy+sprite_y)
046AF0             0321*      ; ld hl,0x002000 ; debug
046AF0             0322*  
046AF0 CD 63 5F 04 0323*      call rand_8
046AF4 21 00 00 00 0324*      ld hl,0
046AF8 67          0325*      ld h,a
046AF9             0326*  
046AF9 22 25 6B 04 0327*      ld (@y),hl
046AFD CD 63 5F 04 0328*      call rand_8
046B01 E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
046B03 32 3A 6B 04 0330*      ld (@move_step),a
046B07             0331*  ; now copy to the table
046B07 21 17 6B 04 0332*      ld hl,@id ; address to copy from
046B0B D1          0333*      pop de ; address to copy to (was ix)
046B0C 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
046B10 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
046B12             0336*  ; finally, make the new sprite visible
046B12 CD 17 5C 04 0337*      call vdu_sprite_show
046B16 C9          0338*      ret
046B17 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
046B18 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
046B19 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
046B1C AE 6A 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
046B1F 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
046B20 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
046B21 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
046B22 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
046B25 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046B28 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046B2B 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046B2E 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
046B31 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046B34 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
046B37 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
046B38 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
046B39 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
046B3A 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
046B3B 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
046B3C 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
046B3D             0359*  
046B3D             0360*  ; move_laser_turret:
046B3D             0361*  ; ; compute orientation to player
046B3D             0362*  ;     call orientation_to_player
046B3D             0363*  ; ; h.l 8.8 fixed angle256 to player
046B3D             0364*  ; ; bc and de as signed 16-bit integers
046B3D             0365*  ; ; representing delta-x/y *to* target respectively
046B3D             0366*  ;     ld (Bearing_t),hl
046B3D             0367*  ;     ld hl,0x0400
046B3D             0368*  ;     ld (Vp),hl
046B3D             0369*  ;     call targeting_computer
046B3D             0370*  ;     ld (sprite_heading),hl ; store bearing to player
046B3D             0371*  ; ; is it time to launch a fireball?
046B3D             0372*  ;     ld hl,sprite_move_timer
046B3D             0373*  ;     dec (hl)
046B3D             0374*  ;     jp nz,move_laser_turret_boilerplate
046B3D             0375*  ;     call fireballs_init
046B3D             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
046B3D             0377*  ;     call rand_8     ; snag a random number
046B3D             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046B3D             0379*  ;     add a,64 ; range is now 64-127
046B3D             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
046B3D             0381*  ; move_laser_turret_boilerplate:
046B3D             0382*  ;     call move_active_tiles
046B3D             0383*  ;     call check_collisions
046B3D             0384*  ;     jp move_enemies_loop_return
046B3D             0385*  
046B3D             0386*  ; fireballs_init:
046B3D             0387*  ;     call sprite_variables_to_stack
046B3D             0388*  
046B3D             0389*  ;     ld hl,fireballs
046B3D             0390*  ;     ld (sprite_base_bufferId),hl
046B3D             0391*  
046B3D             0392*  ;     ld hl,move_fireballs
046B3D             0393*  ;     ld (sprite_move_program),hl
046B3D             0394*  
046B3D             0395*  ;     ld a,%11 ; collides with laser and player
046B3D             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
046B3D             0397*  ;     ld (iy+sprite_collisions),a
046B3D             0398*  
046B3D             0399*  ;     ld hl,(Vp)
046B3D             0400*  ;     ld (sprite_vel),hl
046B3D             0401*  ;     ld hl,(Vp_x)
046B3D             0402*  ;     ld (sprite_xvel),hl
046B3D             0403*  ;     ld hl,(Vp_y)
046B3D             0404*  ;     inc h ; account for ground movement
046B3D             0405*  ;     ld (sprite_yvel),hl
046B3D             0406*  
046B3D             0407*  ;     xor a ; zero a
046B3D             0408*  ;     ld (sprite_animation),a
046B3D             0409*  ;     ld (sprite_move_step),a
046B3D             0410*  ;     ld (sprite_move_timer),a
046B3D             0411*  
046B3D             0412*  ;     ld a,6 ; 1/10th of a second timer
046B3D             0413*  ;     ld (sprite_animation_timer),a
046B3D             0414*  
046B3D             0415*  ;     ld a,0x00 ; BCD
046B3D             0416*  ;     ld (sprite_points),a
046B3D             0417*  ;     ld a,1 ; binary
046B3D             0418*  ;     ld (sprite_shield_damage),a
046B3D             0419*  
046B3D             0420*  ;     call table_add_record ; plops that on the sprite stack for later
046B3D             0421*  ;     call sprite_variables_from_stack ; come back to where we started
046B3D             0422*  ;     ret
046B3D             0423*  
046B3D             0424*  ; move_fireballs:
046B3D             0425*  ;     call move_enemy_sprite ; move sprite
046B3D             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
046B3D             0427*  ;     and a ; if zero we're still within screen bounds
046B3D             0428*  ;     jr z,move_fireballs_alive
046B3D             0429*  ; ; otherwise kill sprite
046B3D             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
046B3D             0431*  ;     ld (iy+sprite_collisions),a
046B3D             0432*  ;     jp move_enemies_loop_return
046B3D             0433*  ; move_fireballs_alive:
046B3D             0434*  ;     ld a,(sprite_animation_timer)
046B3D             0435*  ;     dec a
046B3D             0436*  ;     ld (sprite_animation_timer),a
046B3D             0437*  ;     jr nz,move_fireballs_draw
046B3D             0438*  ;     ld a,(sprite_animation)
046B3D             0439*  ;     xor %1
046B3D             0440*  ;     ld (sprite_animation),a
046B3D             0441*  ;     ld a,6 ; 1/10th of a second timer
046B3D             0442*  ;     ld (sprite_animation_timer),a
046B3D             0443*  ;     ; fall through
046B3D             0444*  
046B3D             0445*  ; move_fireballs_draw:
046B3D             0446*  ;     call vdu_bmp_select
046B3D             0447*  ;     call vdu_bmp_draw
046B3D             0448*  ;     call check_collisions
046B3D             0449*  ;     jp move_enemies_loop_return
046B3D             0450*  
046B3D             0451*  ; compute orientation to player
046B3D             0452*  ; based on relative positions
046B3D             0453*  ; returns: h.l 16.8 fixed angle256 to player
046B3D             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046B3D             0455*  ;    representing delta-x/y *to* target respectively
046B3D             0456*  orientation_to_player:
046B3D FD 2A FB 52 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046B42 FD E5       0458*      push iy ; so we can send it back intact
046B44 FD 07 0B    0459*      ld bc,(iy+sprite_x)
046B47 FD 17 0E    0460*      ld de,(iy+sprite_y)
046B4A DD 2A EC 67 0461*      ld ix,(player_x)
       04          
046B4F FD 2A EF 67 0462*      ld iy,(player_y)
       04          
046B54 CD D9 5F 04 0463*      call dxy168
046B58 CD 40 60 04 0464*      call atan2_168game
046B5C ED 4B 34 60 0465*      ld bc,(dx168)
       04          
046B61 ED 5B 3A 60 0466*      ld de,(dy168)
       04          
046B66 FD E1       0467*      pop iy ; restore table pointer
046B68 C9          0468*      ret
046B69             0469*  
046B69             0470*  
046B69             0471*  ; targeting_computer scratch variables
046B69 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
046B6B 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
046B6D 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
046B6F 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
046B71 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
046B73 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
046B75 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
046B77 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
046B79             0480*  
046B79             0481*  
046B79             0482*  ; ; Inputs:   see scratch variables
046B79             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
046B79             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
046B79             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
046B79             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
046B79             0487*  ; targeting_computer:
046B79             0488*  ; ; compute target velocity from x,y component velocities
046B79             0489*  ;     ld bc,(player_xvel)
046B79             0490*  ;     ld de,(player_yvel)
046B79             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
046B79             0492*  
046B79             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
046B79             0494*  ;     ld (Heading_t),bc
046B79             0495*  ;     ld (Vt),de
046B79             0496*  
046B79             0497*  ; ; compute Heading_t-Bearing_t
046B79             0498*  ;     ld h,b
046B79             0499*  ;     ld l,c
046B79             0500*  ;     ld bc,(Bearing_t)
046B79             0501*  ;     and a ; clear carry
046B79             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
046B79             0503*  
046B79             0504*  ; ; compute sin(Heading_t-Bearing_t)
046B79             0505*  ;     ld b,h
046B79             0506*  ;     ld c,l
046B79             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
046B79             0508*  
046B79             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
046B79             0510*  ;     ex de,hl
046B79             0511*  ;     ld bc,(Vt)
046B79             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
046B79             0513*  
046B79             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
046B79             0515*  ;     ld b,h
046B79             0516*  ;     ld c,l
046B79             0517*  ;     ld de,(Vp)
046B79             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
046B79             0519*  ; ; answer is in radians, convert to degrees256
046B79             0520*  ;     ex de,hl
046B79             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
046B79             0522*  ;     call BC_Mul_DE_88
046B79             0523*  
046B79             0524*  ; ; add lead angle to target bearing
046B79             0525*  ;     ld de,(Bearing_t)
046B79             0526*  ;     add hl,de ; h.l=lead angle+target bearing
046B79             0527*  ;     push hl
046B79             0528*  
046B79             0529*  ; ; compute component projectile velocities
046B79             0530*  ;     ld b,h
046B79             0531*  ;     ld c,l
046B79             0532*  ;     ld de,(Vp)
046B79             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
046B79             0534*  
046B79             0535*  ;     ld (Vp_x),bc
046B79             0536*  ;     ld (Vp_y),de
046B79             0537*  ;     pop hl ; h.l=lead angle+target bearing
046B79             0538*  ;     ret
046B79             0539*  
046B79             0540*  ; this routine vanquishes the enemy sprite
046B79             0541*  ; and replaces it with an animated explosion
046B79             0542*  ; we jump here instead of call because
046B79             0543*  ; we want to return to differing locations in the loop
046B79             0544*  ; depending on whether we're still sploding
046B79             0545*  ; destroys: everything except index registers
046B79             0546*  ; returns: an incandescent ball of debris and gas
046B79             0547*  kill_nurple:
046B79             0548*  ; ; tally up points
046B79             0549*  ;     ld bc,0
046B79             0550*  ;     ld a,(sprite_points)
046B79             0551*  ;     ld e,a
046B79             0552*  ;     ld d,0
046B79             0553*  ;     ld hl,add_bcd_arg2
046B79             0554*  ;     call set_bcd
046B79             0555*  ;     ld hl,player_score
046B79             0556*  ;     ld de,add_bcd_arg2
046B79             0557*  ;     ld a,3 ; number of bytes to add
046B79             0558*  ;     call add_bcd
046B79             0559*  ; ; initialize explosion
046B79             0560*  ; init_explosion:
046B79             0561*  ;     ld hl,explosion
046B79             0562*  ;     ld (sprite_base_bufferId),hl
046B79             0563*  ;     ld hl,move_explosion
046B79             0564*  ;     ld (sprite_move_program),hl
046B79             0565*  ;     ld a,%00000000 ; collides with nothing
046B79             0566*  ;     ld (iy+sprite_collisions),a
046B79             0567*  ;     ld hl,0 ; north
046B79             0568*  ;     ld (sprite_heading),hl
046B79             0569*  ;     ld a,0x04 ; will decrement to 03
046B79             0570*  ;     ld (sprite_animation),a
046B79             0571*  ;     ld a,0x07 ; 7/60th of a second timer
046B79             0572*  ;     ld (sprite_animation_timer),a
046B79             0573*  ;     xor a
046B79             0574*  ;     ld (sprite_move_timer),a
046B79             0575*  ;     call vdu_bmp_select
046B79             0576*  ; ; fall through to next_explosion
046B79             0577*  ; next_explosion:
046B79             0578*  ;     ld a,(sprite_animation)
046B79             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
046B79             0580*  ;     jp m,done_explosion
046B79             0581*  ;     ld (sprite_animation),a
046B79             0582*  ;     ld a,0x7 ; 7/60th of a second timer
046B79             0583*  ;     ld (sprite_animation_timer),a
046B79             0584*  ; ; fall through to animate_explosion
046B79             0585*  ; animate_explosion:
046B79             0586*  ;     ld hl,sprite_y+1
046B79             0587*  ;     inc (hl) ; move explosion down 1 pixel
046B79             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
046B79             0589*  ;     ld hl,sprite_animation_timer
046B79             0590*  ;     dec (hl) ; if timer is zero,we do next animation
046B79             0591*  ;     jr z,next_explosion
046B79             0592*  ;     ;otherwise we fall through to draw the current one
046B79             0593*  ;     call vdu_bmp_select
046B79             0594*  ;     call vdu_bmp_draw
046B79             0595*  ;     ret ; now we go back to caller
046B79             0596*  ; done_explosion:
046B79 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
046B7B FD 2A FB 52 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
046B80 FD 77 08    0599*      ld (iy+sprite_collisions),a
046B83 C9          0600*      ret ; now we go back to caller
046B84             0601*  
046B84             0602*  ; game_over:
046B84             0603*  ;     jp new_game
046B84             0604*  
046B84             0605*  ; it's presumed we've already checked that laser is alive
046B84             0606*  collision_enemy_with_laser:
046B84 DD 2A 11 6C 0607*      ld ix,(laser_x)
       04          
046B89 FD 2A 14 6C 0608*      ld iy,(laser_y)
       04          
046B8E 3A 0F 6C 04 0609*      ld a,(laser_dim_x)
046B92 CB 2F       0610*      sra a ; divide by 2
046B94 F5          0611*      push af ; we need this later
046B95             0612*      ; ld de,0
046B95             0613*      ; ld d,a
046B95             0614*      ; add ix,de
046B95             0615*      ; add iy,de
046B95 18 11       0616*      jr collision_enemy
046B97             0617*  
046B97             0618*  ; it's presumed we've already checked that player is alive
046B97             0619*  collision_enemy_with_player:
046B97 DD 2A EC 67 0620*      ld ix,(player_x)
       04          
046B9C FD 2A EF 67 0621*      ld iy,(player_y)
       04          
046BA1 3A EA 67 04 0622*      ld a,(player_dim_x)
046BA5             0623*  
046BA5             0624*      ; call dumpRegistersHex
046BA5             0625*  
046BA5 CB 2F       0626*      sra a ; divide by 2
046BA7 F5          0627*      push af ; we need this later
046BA8             0628*      ; ld de,0
046BA8             0629*      ; ld d,a
046BA8             0630*      ; add ix,de
046BA8             0631*      ; add iy,de
046BA8             0632*      ; fall through to collision_enemy
046BA8             0633*  
046BA8             0634*  ; compute the distance between the two sprites' centers
046BA8             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
046BA8             0636*  collision_enemy:
046BA8             0637*  ; back up iy because we need it as the sprite table pointer
046BA8 FD E5       0638*      push iy
046BAA FD 2A FB 52 0639*      ld iy,(table_pointer)
       04          
046BAF FD 27 0B    0640*      ld hl,(iy+sprite_x)
046BB2 FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
046BB5 CB 2F       0642*      sra a
046BB7 F5          0643*      push af ; we need this later
046BB8             0644*      ; ld de,0
046BB8             0645*      ; ld d,a
046BB8             0646*      ; add hl,de
046BB8 E5          0647*      push hl
046BB9 C1          0648*      pop bc ; bc = x0
046BBA FD 27 0E    0649*      ld hl,(iy+sprite_y)
046BBD FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
046BC0             0651*      ; sra a
046BC0             0652*      ; ld de,0
046BC0             0653*      ; ld d,a
046BC0             0654*      ; add hl,de
046BC0 EB          0655*      ex de,hl ; de = y0
046BC1 F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
046BC2 FD E1       0657*      pop iy
046BC4 F5          0658*      push af
046BC5             0659*  
046BC5             0660*      ; call dumpRegistersHex
046BC5             0661*  
046BC5 CD F4 5F 04 0662*      call distance168
046BC9             0663*      ; CALL dumpRegistersHex
046BC9             0664*  ; ; subtract sum of radii from distance between centers
046BC9             0665*  ;     ld de,0
046BC9             0666*  ;     pop af ; radius of enemy sprite
046BC9             0667*  ;     ld e,a
046BC9             0668*  ;     pop af ; radius of player or laser sprite
046BC9             0669*  ;     add a,e
046BC9             0670*  ;     ld e,a
046BC9             0671*  ;     and a ; clear carry
046BC9             0672*  ;     sbc hl,de
046BC9             0673*  ;     jr c,collision_enemy_is
046BC9             0674*  ;     xor a
046BC9             0675*  ;     ret
046BC9             0676*  ; temp fix TODO: remove this
046BC9 F1          0677*      pop af
046BCA F1          0678*      pop af
046BCB 11 00 10 00 0679*      ld de,16*256
046BCF A7          0680*      and a
046BD0 ED 52       0681*      sbc hl,de
046BD2 38 02       0682*      jr c,collision_enemy_is
046BD4 AF          0683*      xor a
046BD5             0684*      ; call dumpRegistersHex
046BD5 C9          0685*      ret
046BD6             0686*  collision_enemy_is:
046BD6 AF          0687*      xor a
046BD7 3C          0688*      inc a
046BD8             0689*      ; call dumpRegistersHex
046BD8 C9          0690*      ret
046BD9             0691*  
046BD9             0692*  ; ; looks up what enemy sprite collides with
046BD9             0693*  ; ; detects collisions
046BD9             0694*  ; ; and sets things to sploding accordingly
046BD9             0695*  ; check_collisions:
046BD9             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
046BD9             0697*  ;     and a ; if this is zero,
046BD9             0698*  ;     ret z ; there's nothing to do
046BD9             0699*  ;     and %01 ; do we collide with player?
046BD9             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
046BD9             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
046BD9             0702*  ;     and a ; was there a collision?
046BD9             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
046BD9             0704*  ; ; yes collision with player
046BD9             0705*  ;     ; deduct shield damage
046BD9             0706*  ;     ld hl,sprite_shield_damage
046BD9             0707*  ;     ld a,(player_shields)
046BD9             0708*  ;     sub (hl)
046BD9             0709*  ;     ld (player_shields),a
046BD9             0710*  ; ; if shields >= 0,player survives
046BD9             0711*  ;     jp p,check_collisions_kill_nurple
046BD9             0712*  ; ; otherwise update player status so it will die
046BD9             0713*  ;     ld a,(player_collisions)
046BD9             0714*  ;     or %10 ; sets bit 1,meaning player just died
046BD9             0715*  ;     ld (player_collisions),a
046BD9             0716*  ;     ; fall through
046BD9             0717*  ; check_collisions_kill_nurple:
046BD9             0718*  ; ; kill enemy and replace with explosion
046BD9             0719*  ;     call kill_nurple
046BD9             0720*  ;     ret ; and out
046BD9             0721*  
046BD9             0722*  check_collisions:
046BD9 CD 97 6B 04 0723*      call collision_enemy_with_player ; did we hit the player?
046BDD A7          0724*      and a ; was there a collision?
046BDE C8          0725*      ret z ; if not,we're done
046BDF CD 79 6B 04 0726*      call kill_nurple ; otherwise kill enemy
046BE3 C9          0727*      ret
046BE4             0728*  
046BE4             0729*  ; did we hit the laser?
046BE4             0730*  move_enemies_laser:
046BE4 FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
046BE7 E6 02       0732*      and %10 ; do we even collide with laser?
046BE9 C8          0733*      ret z ; if not,we're out
046BEA 3A 0E 6C 04 0734*      ld a,(laser_collisions) ; is laser alive?
046BEE E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
046BF0 C8          0736*      ret z ; so we're out
046BF1 CD 84 6B 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
046BF5 A7          0738*      and a ; was there a collision?
046BF6 C8          0739*      ret z ; if not,we're done
046BF7             0740*  ; otherwise we mark laser for termination and kill enemy
046BF7             0741*  ; update laser status so it will die
046BF7 3A 0E 6C 04 0742*      ld a,(laser_collisions)
046BFB F6 02       0743*      or %10 ; bit 1 set means laser just died
046BFD 32 0E 6C 04 0744*      ld (laser_collisions),a
046C01 CD 79 6B 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
046C05 C9          0746*      ret ; we're outta' here
046C06             0066   	include "src/asm/laser.inc"
046C06             0001*  ; ##### LASER SPRITE PARAMETERS #####
046C06             0002*  ; uses the same offsets from its table base as the main sprite table:
046C06             0003*  laser_start_variables: ; label marking beginning of table
046C06 05          0004*  laser_id:               db table_max_records+1
046C07 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
046C08 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
046C0B 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
046C0E 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046C0F 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046C10 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046C11 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046C14 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046C17 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046C1A 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046C1D 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
046C20 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046C23 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
046C26 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
046C27 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
046C28 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
046C29 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
046C2A 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
046C2B 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
046C2C             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
046C2C             0025*  
046C2C             0026*  ; laser_control:
046C2C             0027*  ; ; is laser already active?
046C2C             0028*  ;     ld a,(laser_collisions)
046C2C             0029*  ;     and %00000001 ; bit zero is lit if laser is active
046C2C             0030*  ;     jr nz,laser_move ; move laser if not zero
046C2C             0031*  ; ; otherwise check if laser fired
046C2C             0032*  ;     in a,(#82) ; keyboard
046C2C             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
046C2C             0034*  ;     ret z ; go back if laser not fired
046C2C             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
046C2C             0036*  ; ; set laser status to active (set bit 0)
046C2C             0037*  ;     ld a,%1
046C2C             0038*  ;     ld (laser_collisions),a
046C2C             0039*  ; ; initialize laser position
046C2C             0040*  ;     ld a,(player_x+1) ; we only need the integer part
046C2C             0041*  ;     ; add a,6 ; horizontal center with player sprite
046C2C             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
046C2C             0043*  ;     ld a,(player_y+1) ; we only need the integer part
046C2C             0044*  ;     add a,-6 ; set laser y a few pixels above player
046C2C             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
046C2C             0046*  ;     ; fall through to laser_move
046C2C             0047*  
046C2C             0048*  ; laser_move:
046C2C             0049*  ; ; begin setting laser to active sprite
046C2C             0050*  ;     ld hl,lasers
046C2C             0051*  ;     ld (sprite_base_bufferId),hl
046C2C             0052*  ;     ld hl,0 ; north
046C2C             0053*  ;     ld (sprite_heading),hl
046C2C             0054*  ;     xor a ; laser has no animations yet :-(
046C2C             0055*  ;     ld (sprite_animation),a
046C2C             0056*  ;     ; we set position here for the time being as a default
046C2C             0057*  ;     ; in case the laser is flagged for deletion
046C2C             0058*  ;     ; load sprite_x with laser x position (we do y further down)
046C2C             0059*  ;     ld hl,(laser_x)
046C2C             0060*  ;     ld (sprite_x),hl
046C2C             0061*  ; ; did laser just die?
046C2C             0062*  ;     ld a,(laser_collisions)
046C2C             0063*  ;     bit 1,a ; z if laser didn't just die
046C2C             0064*  ;     jr z,laser_not_dead_yet
046C2C             0065*  ; ; yes laser died
046C2C             0066*  ;     call kill_laser
046C2C             0067*  ;     ret ; done
046C2C             0068*  ; laser_not_dead_yet:
046C2C             0069*  ; ; draw it
046C2C             0070*  ; ; update laser y position
046C2C             0071*  ;     ld hl,(laser_y) ; grab laser y position
046C2C             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
046C2C             0073*  ;     add hl,de ; add y velocity to y pos
046C2C             0074*  ;     ld (sprite_y),hl ; update laser y position
046C2C             0075*  ;     ld (laser_y),hl ; update laser y position
046C2C             0076*  ; ; are we at top of screen?
046C2C             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
046C2C             0078*  ;     sub h ; no carry if above threshold
046C2C             0079*  ;     jr c,finally_draw_the_frikken_laser
046C2C             0080*  ;     ; if at top of screen,laser dies
046C2C             0081*  ;     call kill_laser
046C2C             0082*  ;     ret
046C2C             0083*  ; ; otherwise,finally draw the frikken laser
046C2C             0084*  ; finally_draw_the_frikken_laser:
046C2C             0085*  ;     call vdu_bmp_select
046C2C             0086*  ;     call vdu_bmp_draw
046C2C             0087*  ; ; all done
046C2C             0088*  ;     ret
046C2C             0089*  
046C2C             0090*  ; kill_laser:
046C2C             0091*  ; ; update status to inactive
046C2C             0092*  ;     xor a ; zero out a
046C2C             0093*  ;     ld (laser_collisions),a
046C2C             0094*  ;     ret
046C2C             0067   
046C2C             0068   	include "src/asm/timer.inc"
046C2C             0001*  ; Table 32. Timer Control Registers
046C2C             0002*  ; this constant is the base address of the timer control registers
046C2C             0003*  ; each timer takes three bytes:
046C2C             0004*  ;   0: control register
046C2C             0005*  ;   1: low byte of timer reset value
046C2C             0006*  ;   2: high byte of timer reset value
046C2C             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
046C2C             0008*  ; which correctly force the high and upper bytes of the address bus to zero
046C2C             0009*  TMR_CTL:     equ 80h
046C2C             0010*  
046C2C             0011*  ; Timer Control Register Bit Definitions
046C2C             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
046C2C             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
046C2C             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
046C2C             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
046C2C             0016*                              ; the TMRx_CTL register is read.
046C2C             0017*  
046C2C             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
046C2C             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
046C2C             0020*  
046C2C             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
046C2C             0022*                              ;  0,and counting stops when the end-of-count value is reached.
046C2C             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
046C2C             0024*                              ; written to the counter when the end-of-count value is reached.
046C2C             0025*  
046C2C             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
046C2C             0027*  CLK_DIV_256:  equ %00001100 ;
046C2C             0028*  CLK_DIV_64:   equ %00001000 ;
046C2C             0029*  CLK_DIV_16:   equ %00000100 ;
046C2C             0030*  CLK_DIV_4:    equ %00000000 ;
046C2C             0031*  
046C2C             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
046C2C             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
046C2C             0034*                              ; When a 1 is written to this bit,the values in the reload registers
046C2C             0035*                              ;  are loaded into the downcounter when the timer restarts. The
046C2C             0036*                              ; programmer must ensure that this bit is set to 1 each time
046C2C             0037*                              ; SINGLE-PASS mode is used.
046C2C             0038*  
046C2C             0039*  ; disable/enable the programmable reload timer
046C2C             0040*  PRT_EN_0:     equ %00000000 ;
046C2C             0041*  PRT_EN_1:     equ %00000001 ;
046C2C             0042*  
046C2C             0043*  ; Table 37. Timer Input Source Select Register
046C2C             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
046C2C             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
046C2C             0046*  ;   00: System clock / CLK_DIV
046C2C             0047*  ;   01: RTC / CLK_DIV
046C2C             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
046C2C             0049*  ;   10: GPIO port B pin 1.
046C2C             0050*  ;   11: GPIO port B pin 1.
046C2C             0051*  TMR_ISS:   equ 92h ; register address
046C2C             0052*  
046C2C             0053*  ; Table 51. Real-Time Clock Control Register
046C2C             0054*  RTC_CTRL: equ EDh ; register address
046C2C             0055*  
046C2C             0056*  ; alarm interrupt disable/enable
046C2C             0057*  RTC_ALARM_0:    equ %00000000
046C2C             0058*  RTC_ALARM_1:    equ %10000000
046C2C             0059*  
046C2C             0060*  ; interrupt on alarm disable/enable
046C2C             0061*  RTC_INT_ENT_0:  equ %00000000
046C2C             0062*  RTC_INT_ENT_1:  equ %01000000
046C2C             0063*  
046C2C             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
046C2C             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
046C2C             0066*  
046C2C             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
046C2C             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
046C2C             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
046C2C             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
046C2C             0071*  
046C2C             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
046C2C             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
046C2C             0074*  
046C2C             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
046C2C             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
046C2C             0077*  
046C2C             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
046C2C             0079*                                  ; RTC counter is enabled.
046C2C             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
046C2C             0081*                                  ; RTC counter is disabled.
046C2C             0082*  
046C2C             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
046C2C             0084*  
046C2C             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
046C2C             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
046C2C 00 00 00    0087*  prt_reload: dl 0x000000
046C2F             0088*  
046C2F             0089*  ; returns: a = 0 if running on hardware,1 if running on emulator
046C2F             0090*  ;          de = number PRT interrupts during test interval
046C2F             0091*  prt_calibrate:
046C2F CD 20 5A 04 0092*      call vdu_vblank
046C33             0093*  ; set a MOS timer
046C33 21 78 00 00 0094*      ld hl,120*1 ; 1 second
046C37 FD 21 8A 6D 0095*      ld iy,tmr_test
       04          
046C3C CD 68 6D 04 0096*      call tmr_set
046C40             0097*  ; set a PRT timer
046C40             0098*      ; ld hl,prt_reload_hardware
046C40             0099*      ; ld hl,prt_reload_emulator
046C40 21 05 2D 00 0100*      ld hl,prt_reload_emulator + prt_reload_hardware / 2
046C44 22 2C 6C 04 0101*      ld (prt_reload),hl
046C48 CD A3 6C 04 0102*      call prt_set
046C4C             0103*  @loop:
046C4C             0104*  ; check time remaining on MOS timer
046C4C CD 76 6D 04 0105*      call tmr_get
046C50 CA 5A 6C 04 0106*      jp z,@done ; time expired,so quit
046C54 FA 5A 6C 04 0107*      jp m,@done ; time past expiration (negative),so quit
046C58 18 F2       0108*      jr @loop
046C5A             0109*  @done:
046C5A ED 5B F1 6C 0110*      ld de,(prt_irq_counter)
       04          
046C5F 01 0C 2D 00 0111*      ld bc,prt_reload_hardware ; default value for running on hardware
046C63 ED 43 2C 6C 0112*      ld (prt_reload),bc
       04          
046C68 21 64 00 00 0113*      ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
046C6C AF          0114*      xor a ; clear carry,zero is default value for running on hardware
046C6D 32 22 6E 04 0115*      ld (is_emulator),a
046C71 ED 52       0116*      sbc hl,de
046C73 21 3A 6E 04 0117*      ld hl,on_hardware ; default message for running on hardware
046C77 CA 2F 6C 04 0118*      jp z,prt_calibrate ; zero result is indeterminate so we try again
046C7B F8          0119*      ret m ; negative result means we're on hardware
046C7C 3C          0120*      inc a ; we're on emulator
046C7D 32 22 6E 04 0121*      ld (is_emulator),a
046C81 01 FF 2C 00 0122*      ld bc,prt_reload_emulator
046C85 ED 43 2C 6C 0123*      ld (prt_reload),bc
       04          
046C8A 21 23 6E 04 0124*      ld hl,on_emulator
046C8E C9          0125*      ret
046C8F             0126*  
046C8F 43 61 6C 69 0127*  calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
046CA3             0128*  
046CA3             0129*  ; set PRT timer
046CA3             0130*  prt_set:
046CA3 21 00 00 00 0131*      ld hl,0
046CA7 22 F1 6C 04 0132*      ld (prt_irq_counter),hl
046CAB 2A 2C 6C 04 0133*      ld hl,(prt_reload)
046CAF ED 29 84    0134*      out0 ($84),l
046CB2 ED 21 85    0135*  	out0 ($85),h
046CB5             0136*  ; disable timer
046CB5 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
046CB7 ED 39 83    0138*  	out0 ($83),a
046CBA             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
046CBA 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
046CBC ED 39 83    0141*  	out0 ($83),a
046CBF C9          0142*      ret
046CC0             0143*  
046CC0             0144*  ; ===============================================
046CC0             0145*  ; PRT Timer Interrupt Handling
046CC0             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
046CC0             0147*  ; -----------------------------------------------
046CC0             0148*  prt_irq_init:
046CC0             0149*      ; set up interrupt vector table 2
046CC0 21 00 00 00 0150*  	ld hl,0
046CC4 3A 0C 01 00 0151*  	ld a,($10c)
046CC8 6F          0152*  	ld l,a
046CC9 3A 0D 01 00 0153*  	ld a,($10d)
046CCD 67          0154*  	ld h,a
046CCE             0155*  
046CCE             0156*  	; skip over CALL ($c3)
046CCE 23          0157*  	inc hl
046CCF             0158*  	; load address of jump into vector table 2 (in ram)
046CCF ED 27       0159*  	ld hl,(hl)
046CD1             0160*  
046CD1             0161*  	; write CALL prt_irq_handler to vector table 2
046CD1 3E C3       0162*  	ld a,$c3
046CD3 77          0163*  	ld (hl),a
046CD4 23          0164*  	inc hl
046CD5 11 DC 6C 04 0165*  	ld de,prt_irq_handler
046CD9 ED 1F       0166*  	ld (hl),de
046CDB             0167*  
046CDB C9          0168*      ret
046CDC             0169*  
046CDC             0170*  prt_irq_handler:
046CDC F3          0171*  	di
046CDD F5          0172*  	push af
046CDE E5          0173*      push hl
046CDF ED 38 83    0174*  	in0 a,($83)
046CE2 2A F1 6C 04 0175*  	ld hl,(prt_irq_counter)
046CE6 23          0176*  	inc hl
046CE7 22 F1 6C 04 0177*  	ld (prt_irq_counter),hl
046CEB E1          0178*      pop hl
046CEC F1          0179*  	pop af
046CED FB          0180*  	ei
046CEE 5B ED 4D    0181*  	reti.l
046CF1             0182*  
046CF1             0183*  prt_irq_counter:
046CF1 00 00 00    0184*  	.dl 0
046CF4             0185*  prt_irq_counter_saved:
046CF4 00 00 00    0186*      .dl 0
046CF7             0187*  
046CF7             0188*  prt_loop_reset:
046CF7 E5          0189*      push hl
046CF8 21 00 00 00 0190*  	ld hl,0
046CFC 22 F1 6C 04 0191*  	ld (prt_irq_counter),hl
046D00 22 62 6D 04 0192*      ld (prt_loop_counter),hl
046D04 22 65 6D 04 0193*      ld (prt_loops),hl
046D08 CD A3 6C 04 0194*      call prt_set
046D0C E1          0195*      pop hl
046D0D C9          0196*      ret
046D0E             0197*  
046D0E             0198*  prt_loop_start:
046D0E E5          0199*      push hl
046D0F 21 00 00 00 0200*  	ld hl,0
046D13 22 F1 6C 04 0201*  	ld (prt_irq_counter),hl
046D17 E1          0202*      pop hl
046D18 C9          0203*      ret
046D19             0204*  
046D19             0205*  prt_loop_stop:
046D19 E5          0206*      push hl
046D1A D5          0207*      push de
046D1B 2A F1 6C 04 0208*      ld hl,(prt_irq_counter)
046D1F ED 5B 62 6D 0209*      ld de,(prt_loop_counter)
       04          
046D24 19          0210*      add hl,de
046D25 22 62 6D 04 0211*      ld (prt_loop_counter),hl
046D29 21 00 00 00 0212*      ld hl,0
046D2D 22 F1 6C 04 0213*      ld (prt_irq_counter),hl
046D31 2A 65 6D 04 0214*      ld hl,(prt_loops)
046D35 23          0215*      inc hl
046D36 22 65 6D 04 0216*      ld (prt_loops),hl
046D3A D1          0217*      pop de
046D3B E1          0218*      pop hl
046D3C C9          0219*      ret
046D3D             0220*  
046D3D             0221*  ; inputs: bc = y,x text coordinates to print
046D3D             0222*  prt_loop_print:
046D3D F5          0223*      push af
046D3E E5          0224*      push hl
046D3F C5          0225*      push bc
046D40 D5          0226*      push de
046D41 DD E5       0227*      push ix
046D43 FD E5       0228*      push iy
046D45 CD 03 59 04 0229*      call vdu_move_cursor
046D49             0230*  
046D49 2A 62 6D 04 0231*      ld hl,(prt_loop_counter)
046D4D CD BC 53 04 0232*      call printDec
046D51             0233*  
046D51 2A 65 6D 04 0234*      ld hl,(prt_loops)
046D55 CD BC 53 04 0235*      call printDec
046D59             0236*  
046D59 FD E1       0237*      pop iy
046D5B DD E1       0238*      pop ix
046D5D D1          0239*      pop de
046D5E C1          0240*      pop bc
046D5F E1          0241*      pop hl
046D60 F1          0242*      pop af
046D61 C9          0243*      ret
046D62             0244*  
046D62             0245*  prt_loop_counter:
046D62 00 00 00    0246*      .dl 0
046D65             0247*  prt_loops:
046D65 00 00 00    0248*      .dl 0
046D68             0249*  
046D68             0250*  ; ===============================================
046D68             0251*  ; Timer functions
046D68             0252*  ; -----------------------------------------------
046D68             0253*  ; set a countdown timer
046D68             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046D68             0255*  ; returns: hl = current time
046D68             0256*  tmr_set:
046D68 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
046D6B             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
046D6B 3E 08       0001*M 			LD	A, function
046D6D 5B CF       0002*M 			RST.LIL	08h
046D6F DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
046D72 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
046D75 C9          0261*      ret
046D76             0262*  
046D76             0263*  ; gets time remaining on a countdown timer
046D76             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046D76             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
046D76             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
046D76             0267*  tmr_get:
046D76             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
046D76 3E 08       0001*M 			LD	A, function
046D78 5B CF       0002*M 			RST.LIL	08h
046D7A DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
046D7D FD 27 00    0270*      ld hl,(iy+0)            ; get start time
046D80 AF          0271*      xor a                   ; clear carry
046D81 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
046D83 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
046D86 AF          0274*      xor a                   ; clear carry
046D87 ED 5A       0275*      adc hl,de               ; hl = time remaining
046D89             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
046D89 C9          0277*      ret
046D8A             0278*  
046D8A             0279*  tmr_test: ds 6 ; example of a buffer to hold timer data
046D90             0280*  
046D90 00 00 00    0281*  timestamp_now: dl 0
046D93 00 00 00    0282*  timestamp_old: dl 0
046D96 00 00 00    0283*  timestamp_chg: dl 0
046D99             0284*  
046D99             0285*  ; update the global timestamp from the system clock
046D99             0286*  ; inputs: none
046D99             0287*  ; returns: hl = time elapsed in 1/120ths of a second
046D99             0288*  ;          de = current time
046D99             0289*  ;          ix = pointer to syvars table
046D99             0290*  ; destroys: af,hl,de,ix
046D99             0291*  timestamp_tick:
046D99 ED 5B 90 6D 0292*      ld de,(timestamp_now)   ; get previous time
       04          
046D9E ED 53 93 6D 0293*      ld (timestamp_old),de   ; save previous time
       04          
046DA3             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
046DA3 3E 08       0001*M 			LD	A, function
046DA5 5B CF       0002*M 			RST.LIL	08h
046DA7 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
046DAA 22 90 6D 04 0296*      ld (timestamp_now),hl   ; save current time
046DAE AF          0297*      xor a                   ; clear carry
046DAF ED 52       0298*      sbc hl,de               ; hl = time elapsed
046DB1 22 96 6D 04 0299*      ld (timestamp_chg),hl   ; save elapsed time
046DB5 C9          0300*      ret
046DB6             0301*  
046DB6             0302*  ; set a countdown timer
046DB6             0303*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046DB6             0304*  ; requires: timestamp_tick to be called at least once before this function
046DB6             0305*  ; returns: hl = current time
046DB6             0306*  ; destroys: hl
046DB6             0307*  timestamp_tmr_set:
046DB6 FD 2F 03    0308*      ld (iy+3),hl            ; set time remaining
046DB9 2A 90 6D 04 0309*      ld hl,(timestamp_now)   ; get current timestamp
046DBD FD 2F 00    0310*      ld (iy+0),hl            ; set start time
046DC0 C9          0311*      ret
046DC1             0312*  
046DC1             0313*  ; gets time remaining on a countdown timer following the global timestamp
046DC1             0314*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046DC1             0315*  ; requires: timestamp_tick to be called at least once before this function
046DC1             0316*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
046DC1             0317*  ;          sign flags: pos = time not expired,zero or neg = time expired
046DC1             0318*  ; destroys: af,hl,de
046DC1             0319*  timestamp_tmr_get:
046DC1 ED 5B 90 6D 0320*      ld de,(timestamp_now)   ; get current timestamp
       04          
046DC6 FD 27 00    0321*      ld hl,(iy+0)            ; get start time
046DC9 AF          0322*      xor a                   ; clear carry
046DCA ED 52       0323*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
046DCC FD 17 03    0324*      ld de,(iy+3)            ; get timer set value
046DCF AF          0325*      xor a                   ; clear carry
046DD0 ED 5A       0326*      adc hl,de               ; hl = time remaining
046DD2             0327*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
046DD2 C9          0328*      ret
046DD3             0329*  
046DD3             0330*  ; set a stopwatch
046DD3             0331*  ; returns: hl = start time
046DD3             0332*  ; destroys: hl,ix
046DD3             0333*  stopwatch_set:
046DD3             0334*      MOSCALL mos_sysvars     ; ix points to syvars table
046DD3 3E 08       0001*M 			LD	A, function
046DD5 5B CF       0002*M 			RST.LIL	08h
046DD7 DD 27 00    0335*      ld hl,(ix+sysvar_time)  ; get current time
046DDA 22 EF 6D 04 0336*      ld (stopwatch_started),hl            ; set start time
046DDE C9          0337*      ret
046DDF             0338*  
046DDF             0339*  ; gets time elapsed on a stopwatch
046DDF             0340*  ; returns: hl = time elapsed in 1/120ths of a second
046DDF             0341*  ; destroys: af,hl,de,ix
046DDF             0342*  stopwatch_get:
046DDF             0343*      MOSCALL mos_sysvars     ; ix points to syvars table
046DDF 3E 08       0001*M 			LD	A, function
046DE1 5B CF       0002*M 			RST.LIL	08h
046DE3 DD 27 00    0344*      ld hl,(ix+sysvar_time)  ; get current time
046DE6 ED 5B EF 6D 0345*      ld de,(stopwatch_started)            ; get start time
       04          
046DEB AF          0346*      xor a                   ; clear carry
046DEC ED 52       0347*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
046DEE C9          0348*      ret
046DEF             0349*  
046DEF             0350*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
046DF2             0351*  
046DF2             0352*  ; ------------------
046DF2             0353*  ; delay routine
046DF2             0354*  ; Author: Richard Turrnidge
046DF2             0355*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
046DF2             0356*  ; routine waits a fixed time,then returns
046DF2             0357*  ; arrive with A =  the delay byte. One bit to be set only.
046DF2             0358*  ; eg. ld A,00000100b
046DF2             0359*  
046DF2             0360*  multiPurposeDelay:
046DF2 F5          0361*      push af
046DF3 C5          0362*      push bc
046DF4 DD E5       0363*      push ix
046DF6 47          0364*      ld b,a
046DF7 3E 08       0365*      ld a,$08
046DF9 5B CF       0366*      RST.LIL	08h                 ; get IX pointer to sysvars
046DFB             0367*  
046DFB             0368*  waitLoop:
046DFB             0369*  
046DFB DD 7E 00    0370*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
046DFE             0371*  
046DFE             0372*                                  ;   we check if bit set is same as last time we checked.
046DFE             0373*                                  ;   bit 0 - don't use
046DFE             0374*                                  ;   bit 1 - changes 64 times per second
046DFE             0375*                                  ;   bit 2 - changes 32 times per second
046DFE             0376*                                  ;   bit 3 - changes 16 times per second
046DFE             0377*  
046DFE             0378*                                  ;   bit 4 - changes 8 times per second
046DFE             0379*                                  ;   bit 5 - changes 4 times per second
046DFE             0380*                                  ;   bit 6 - changes 2 times per second
046DFE             0381*                                  ;   bit 7 - changes 1 times per second
046DFE A0          0382*      and b
046DFF 4F          0383*      ld c,a
046E00 3A 11 6E 04 0384*      ld a,(oldTimeStamp)
046E04 B9          0385*      cp c                        ; is A same as last value?
046E05 28 F4       0386*      jr z,waitLoop              ; loop here if it is
046E07 79          0387*      ld a,c
046E08 32 11 6E 04 0388*      ld (oldTimeStamp),a        ; set new value
046E0C             0389*  
046E0C DD E1       0390*      pop ix
046E0E C1          0391*      pop bc
046E0F F1          0392*      pop af
046E10 C9          0393*      ret
046E11             0394*  
046E11 00          0395*  oldTimeStamp:   .db 00h
046E12             0069   
046E12 48 65 6C 6C 0070   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
046E22 00          0071   is_emulator: defb 0
046E23 52 75 6E 6E 0072   on_emulator: defb "Running on emulator.\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 2E 
       0D 0A 00    
046E3A 52 75 6E 6E 0073   on_hardware: defb "Running on hardware.\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 2E 
       0D 0A 00    
046E51             0074   
046E51             0075   init:
046E51             0076   ; ; set fonts
046E51             0077   ; 	ld hl,font_nurples
046E51             0078   ; 	ld b,144 ; loop counter for 96 chars
046E51             0079   ; 	ld a,32 ; first char to define (space)
046E51             0080   ; @loop:
046E51             0081   ; 	push bc
046E51             0082   ; 	push hl
046E51             0083   ; 	push af
046E51             0084   ; 	call vdu_define_character
046E51             0085   ; 	pop af
046E51             0086   ; 	inc a
046E51             0087   ; 	pop hl
046E51             0088   ; 	ld de,8
046E51             0089   ; 	add hl,de
046E51             0090   ; 	pop bc
046E51             0091   ; 	djnz @loop
046E51             0092   
046E51             0093   ; set up the display
046E51 3E 08       0094       ld a,8
046E53 CD 53 58 04 0095       call vdu_set_screen_mode
046E57 AF          0096       xor a
046E58 CD 82 59 04 0097       call vdu_set_scaling
046E5C 01 20 00 00 0098   	ld bc,32
046E60 11 10 00 00 0099   	ld de,16
046E64 CD E3 58 04 0100   	call vdu_set_gfx_origin
046E68             0101   
046E68             0102   	; call vdu_init ; grab a bunch of sysvars and stuff ; TODO: DEPRECATE
046E68 CD 12 5A 04 0103   	call cursor_off
046E6C             0104   
046E6C             0105   ; ; TESTING SOME MATHS
046E6C             0106   ; 	ld bc,0x00A000 ; 160
046E6C             0107   ; 	ld de,0x007800 ; 120
046E6C             0108   ; 	ld ix,0x011F80 ; 287.5
046E6C             0109   ; 	ld iy,0xFF9B2A ; -100.836
046E6C             0110   ; 	;  hl=0x00FF00 255
046E6C             0111   ; 	call distance168
046E6C             0112   ; 	call dumpRegistersHex
046E6C             0113   ; 	halt
046E6C             0114   ; ; END TESTING SOME MATHS
046E6C             0115   
046E6C             0116   ; ; print a hello message
046E6C             0117   ; 	ld hl,hello_world
046E6C             0118   ; 	call printString
046E6C             0119   
046E6C             0120   ; load the bitmaps
046E6C CD 60 00 04 0121   	call bmp2_init
046E70             0122   
046E70             0123   ; initialize the first level
046E70 AF          0124   	xor a
046E71 32 DD 68 04 0125   	ld (cur_level),a
046E75 CD 65 69 04 0126   	call init_level
046E79             0127   
046E79             0128   ; set gfx viewport to scrolling window
046E79 01 00 00 00 0129   	ld bc,0
046E7D 11 00 00 00 0130   	ld de,0
046E81 DD 21 FF 00 0131   	ld ix,255
       00          
046E86 FD 21 DF 00 0132   	ld iy,239-16
       00          
046E8B CD 89 58 04 0133   	call vdu_set_gfx_viewport
046E8F             0134   
046E8F             0135   ; initialize sprites
046E8F CD CD 5C 04 0136   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
046E93 AF          0137   	xor a
046E94             0138   @sprite_loop:
046E94 F5          0139   	push af
046E95 CD A1 5B 04 0140   	call vdu_sprite_select
046E99 21 00 01 00 0141   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
046E9D CD EE 5C 04 0142   	call vdu_sprite_add_buff
046EA1 F1          0143   	pop af
046EA2 3C          0144   	inc a
046EA3 FE 05       0145   	cp table_max_records+1 ; tack on sprites for player and laser
046EA5 20 ED       0146   	jr nz,@sprite_loop
046EA7 3C          0147   	inc a
046EA8 CD D5 5B 04 0148   	call vdu_sprite_activate
046EAC             0149   
046EAC             0150   ; define player sprite
046EAC 3E 10       0151   	ld a,16
046EAE CD A1 5B 04 0152   	call vdu_sprite_select
046EB2 CD B4 5B 04 0153   	call vdu_sprite_clear_frames
046EB6 21 34 01 00 0154   	ld hl,BUF_SHIP_0L
046EBA 01 03 00 00 0155   	ld bc,3 ; three bitmaps for player ship
046EBE             0156   @sprite_player_loop:
046EBE C5          0157   	push bc
046EBF E5          0158   	push hl
046EC0 CD EE 5C 04 0159   	call vdu_sprite_add_buff
046EC4 E1          0160   	pop hl
046EC5 23          0161   	inc hl
046EC6 C1          0162   	pop bc
046EC7 10 F5       0163   	djnz @sprite_player_loop
046EC9 CD 17 5C 04 0164   	call vdu_sprite_show
046ECD             0165   
046ECD             0166   ; initialize player
046ECD CD 07 68 04 0167   	call player_init
046ED1             0168   
046ED1             0169   ; spawn an enemy sprite
046ED1 06 04       0170   	ld b,table_max_records
046ED3             0171   @spawn_enemy_loop:
046ED3 C5          0172   	push bc
046ED4 CD BA 6A 04 0173   	call enemy_init_from_landing_pad
046ED8 C1          0174   	pop bc
046ED9 10 F8       0175   	djnz @spawn_enemy_loop
046EDB             0176   
046EDB C9          0177   	ret
046EDC             0178   
046EDC             0179   ; new_game:
046EDC             0180   ; ; ###### INITIALIZE GAME #######
046EDC             0181   ; ; clear the screen
046EDC             0182   ;     ld a,3
046EDC             0183   ;     out (81h),a
046EDC             0184   
046EDC             0185   ; ; reset the sprite table
046EDC             0186   ;     xor a
046EDC             0187   ;     ld (table_active_sprites),a
046EDC             0188   ;     ld hl,table_limit
046EDC             0189   ;     ld (table_base),hl
046EDC             0190   ;     ld (table_pointer),hl
046EDC             0191   
046EDC             0192   ; ; draw a starfield over the entire screen
046EDC             0193   ;     ld b,#50 ; first row of visible screen
046EDC             0194   ; new_game_draw_stars_loop:
046EDC             0195   ;     push bc
046EDC             0196   ;     call draw_stars
046EDC             0197   ;     pop bc
046EDC             0198   ;     ld a,#10
046EDC             0199   ;     add a,b
046EDC             0200   ;     ld b,a
046EDC             0201   ;     jr nz,new_game_draw_stars_loop
046EDC             0202   
046EDC             0203   ; ; ; print a welcome message
046EDC             0204   ; ;     ld de,msg_welcome
046EDC             0205   ; ;     ld hl,#581C
046EDC             0206   ; ;     ld c,218 ; a bright pastel purple d677e3
046EDC             0207   ; ;     call print_string
046EDC             0208   
046EDC             0209   ; ; push all that to frame buffer
046EDC             0210   ;     ld a,#01 ; send video to frame buffer
046EDC             0211   ;     out (81h),a
046EDC             0212   
046EDC             0213   ; ; reset score, lives, shields
046EDC             0214   ;     xor a
046EDC             0215   ;     ld hl,player_score
046EDC             0216   ;     ld (hl),a ; player_score 0
046EDC             0217   ;     inc hl
046EDC             0218   ;     ld (hl),a ; player_score 1
046EDC             0219   ;     inc hl
046EDC             0220   ;     ld (hl),a ; player_score 3
046EDC             0221   ;     inc hl
046EDC             0222   ;     ld a,16
046EDC             0223   ;     ld (hl),a ; player_shields
046EDC             0224   ;     inc hl
046EDC             0225   ;     ld (hl),a ; player_max_shields
046EDC             0226   ;     inc hl
046EDC             0227   ;     ld a,3
046EDC             0228   ;     ld (hl),a ; player_ships
046EDC             0229   ;     inc hl
046EDC             0230   
046EDC             0231   ; ; initialize first level
046EDC             0232   ;     ld a,1 ; levels are zero-based, so this will wrap around
046EDC             0233   ;     ld (cur_level),a
046EDC             0234   ;     ld a,3 ; set max enemy sprites to easy street
046EDC             0235   ;     ; ld a,64 ; DEBUG: BRING IT
046EDC             0236   ;     ld (max_enemy_sprites),a
046EDC             0237   ;     call dt_next_level
046EDC             0238   ;     call dt
046EDC             0239   
046EDC             0240   ; ; spawn our intrepid hero
046EDC             0241   ;     call player_init
046EDC             0242   
046EDC             0243   ; ; #### BEGIN GAME VARIABLES ####
046EDC             0244   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
046EDC             0245   speed_player: equ 0x000300 ; 3 pixels per frame
046EDC             0246   
046EDC             0247   main:
046EDC             0248   ; move the background down one pixel
046EDC 3E 02       0249   	ld a,2 ; current gfx viewport
046EDE 2E 02       0250   	ld l,2 ; direction=down
046EE0 26 01       0251   	ld h,1 ; speed=1 px
046EE2 CD EB 59 04 0252   	call vdu_scroll_down
046EE6             0253   
046EE6             0254   ; scroll tiles
046EE6 CD EA 68 04 0255   	call tiles_plot
046EEA             0256   
046EEA             0257   ; get player input and update sprite position
046EEA CD 44 68 04 0258   	call player_input
046EEE             0259   
046EEE             0260   ; move enemies
046EEE CD CC 69 04 0261   	call move_enemies
046EF2             0262   
046EF2             0263   ; wait for the next vblank mitigate flicker and for loop timing
046EF2 CD 20 5A 04 0264   	call vdu_vblank
046EF6             0265   
046EF6             0266   ; poll keyboard
046EF6 3E 08       0267       ld a, $08                           ; code to send to MOS
046EF8 5B CF       0268       rst.lil $08                         ; get IX pointer to System Variables
046EFA             0269   
046EFA DD 7E 05    0270       ld a, (ix + $05)                    ; get ASCII code of key pressed
046EFD FE 1B       0271       cp 27                               ; check if 27 (ascii code for ESC)
046EFF CA 07 6F 04 0272       jp z, main_end                     ; if pressed, jump to exit
046F03             0273   
046F03 C3 DC 6E 04 0274       jp main
046F07             0275   
046F07             0276   main_end:
046F07 CD 04 5A 04 0277       call cursor_on
046F0B C9          0278   	ret
046F0C             0279   
046F0C             0280   
046F0C             0281   ; ; #### BEGIN GAME MAIN LOOP ####
046F0C             0282   ; main_loop:
046F0C             0283   ; ; ; debug: start execution counter
046F0C             0284   ; ;     ld a,1
046F0C             0285   ; ;     out (#e0),a ; start counting instructions
046F0C             0286   
046F0C             0287   ; ; refresh background from frame buffer
046F0C             0288   ;     ld a,#02
046F0C             0289   ;     out (81h),a
046F0C             0290   ;     call move_background ; now move it
046F0C             0291   ;     ld a,#01
046F0C             0292   ;     out (81h),a ; save it back to buffer
046F0C             0293   ; ; do all the things
046F0C             0294   ;     call move_enemies
046F0C             0295   ;     call player_move
046F0C             0296   ;     call laser_control
046F0C             0297   ;     call print_score
046F0C             0298   ;     call draw_shields
046F0C             0299   ;     call draw_lives
046F0C             0300   ; ; ; debug: stop execution counter and print results
046F0C             0301   ; ;     ld a,0
046F0C             0302   ; ;     out (#e0),a ; stop counting instructions
046F0C             0303   
046F0C             0304   ; ; ; debug: start execution counter
046F0C             0305   ; ;     ld a,1
046F0C             0306   ; ;     out (#e0),a ; start counting instructions
046F0C             0307   
046F0C             0308   ;     call vdu_vblank
046F0C             0309   ; ; ; debug: stop execution counter and print results
046F0C             0310   ; ;     ld a,0
046F0C             0311   ; ;     out (#e0),a ; stop counting instructions
046F0C             0312   
046F0C             0313   ;     jr main_loop
046F0C             0314   ; #### END GAME MAIN LOOP ####
046F0C             0315   
046F0C             0316   ; draws the player's shields level
046F0C             0317   ; draw_shields:
046F0C             0318   ; TODO: Agonize this routine
046F0C             0319   ; ; prep the loop to draw the bars
046F0C             0320   ;     ld a,(player_shields) ; snag shields
046F0C             0321   ;     and a
046F0C             0322   ;     ret z ; don't draw if zero shields
046F0C             0323   ; ; set loop counter and drawing position
046F0C             0324   ;     ld b,a ; loop counter
046F0C             0325   ;     ld hl,#5300+48+12
046F0C             0326   ; ; set color based on bars remaining
046F0C             0327   ;     ld c,103 ; bright green 28fe0a
046F0C             0328   ;     cp 9
046F0C             0329   ;     jp p,draw_shields_loop
046F0C             0330   ;     ld c,74 ; bright yellow eafe5b
046F0C             0331   ;     cp 3
046F0C             0332   ;     jp p,draw_shields_loop
046F0C             0333   ;     ld c,28 ; bright red fe0a0a
046F0C             0334   ; draw_shields_loop:
046F0C             0335   ;     push bc ; yup,outta
046F0C             0336   ;     push hl ; registers again
046F0C             0337   ;     ; ld a,#A8 ; ▀,168
046F0C             0338   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
046F0C             0339   ;     ; call draw_char
046F0C             0340   ;     call draw_num ; we nuked draw_char for the time being
046F0C             0341   ;     pop hl
046F0C             0342   ;     ld a,8
046F0C             0343   ;     add a,l
046F0C             0344   ;     ld l,a
046F0C             0345   ;     pop bc
046F0C             0346   ;     djnz draw_shields_loop
046F0C             0347       ; ret
046F0C             0348   
046F0C             0349   ; prints the player's score
046F0C             0350   ; print_score:
046F0C             0351   ; TODO: Agonize this
046F0C             0352   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
046F0C             0353   ;     ld c,42 ; dark orange b74400
046F0C             0354   ;     ld hl,#5200+1+8+6*6
046F0C             0355   ;     ld a,3 ; print 6 bdc digits
046F0C             0356   ;     ld de,player_score
046F0C             0357   ;     call print_num
046F0C             0358   
046F0C             0359   ;     ld c,58 ; golden yellow fec10a
046F0C             0360   ;     ld hl,#5100+8+6*6
046F0C             0361   ;     ld a,3 ; print 6 bdc digits
046F0C             0362   ;     ld de,player_score
046F0C             0363   ;     call print_num
046F0C             0364       ; ret
046F0C             0365   
046F0C             0366   ; draw_lives:
046F0C             0367   ;     ld hl,player_small ; make small yellow ship the active sprite
046F0C             0368   ;     ld (sprite_base_bufferId),hl
046F0C             0369   ;     ; ld a,#80 ; northern orientation
046F0C             0370   ;     ; ld (sprite_orientation),a
046F0C             0371   ;     ld hl,0 ; north
046F0C             0372   ;     ld (sprite_heading),hl
046F0C             0373   ;     xor a
046F0C             0374   ;     ld (sprite_animation),a
046F0C             0375   ;     ld a,#56 ; top of visible screen
046F0C             0376   ;     ld (sprite_y+1),a
046F0C             0377   ;     call vdu_bmp_select
046F0C             0378   ;     ld a,(player_ships)
046F0C             0379   ;     dec a ; we draw one fewer ships than lives
046F0C             0380   ;     ret z ; nothing to draw here, move along
046F0C             0381   ;     ld b,a ; loop counter
046F0C             0382   ;     ld a,256-16 ; initial x position
046F0C             0383   ; draw_lives_loop:
046F0C             0384   ;     ld (sprite_x+1),a
046F0C             0385   ;     push af
046F0C             0386   ;     push bc
046F0C             0387   ;     call vdu_bmp_draw
046F0C             0388   ;     pop bc
046F0C             0389   ;     pop af
046F0C             0390   ;     sub 10
046F0C             0391   ;     djnz draw_lives_loop
046F0C             0392   ;     ret
