PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "src/asm/macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 9F 6E 04 0030   	call	init			; Initialization code
040050 CD 2A 6F 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "src/asm/images2.inc" ; deprecated in favor of images.inc, images_sprites.inc, images_ui.inc
040060             0001*  ; Bitmap indices:
040060             0002*  BUF_0TILE_EMPTY: equ $0100
040060             0003*  BUF_1TILE_CROSS: equ $0101
040060             0004*  BUF_2TILE_HORIZ: equ $0102
040060             0005*  BUF_3TILE_VERT: equ $0103
040060             0006*  BUF_4TILE_SQUARE: equ $0104
040060             0007*  BUF_5TILE_CIRCLE: equ $0105
040060             0008*  BUF_6TILE_PAD: equ $0106
040060             0009*  BUF_7TILE_TURRET: equ $0107
040060             0010*  BUF_CIRCLE: equ $0108
040060             0011*  BUF_CRATER: equ $0109
040060             0012*  BUF_EXPLOSION_A: equ $010A
040060             0013*  BUF_EXPLOSION_B: equ $010B
040060             0014*  BUF_EXPLOSION_C: equ $010C
040060             0015*  BUF_EXPLOSION_D: equ $010D
040060             0016*  BUF_EXPLOSION_E: equ $010E
040060             0017*  BUF_FIREBALL_A: equ $010F
040060             0018*  BUF_FIREBALL_B: equ $0110
040060             0019*  BUF_LASER_A: equ $0111
040060             0020*  BUF_LASER_B: equ $0112
040060             0021*  BUF_PAD: equ $0113
040060             0022*  BUF_SEEKER_000: equ $0114
040060             0023*  BUF_SEEKER_001: equ $0115
040060             0024*  BUF_SEEKER_002: equ $0116
040060             0025*  BUF_SEEKER_003: equ $0117
040060             0026*  BUF_SEEKER_004: equ $0118
040060             0027*  BUF_SEEKER_005: equ $0119
040060             0028*  BUF_SEEKER_006: equ $011A
040060             0029*  BUF_SEEKER_007: equ $011B
040060             0030*  BUF_SEEKER_008: equ $011C
040060             0031*  BUF_SEEKER_009: equ $011D
040060             0032*  BUF_SEEKER_010: equ $011E
040060             0033*  BUF_SEEKER_011: equ $011F
040060             0034*  BUF_SEEKER_012: equ $0120
040060             0035*  BUF_SEEKER_013: equ $0121
040060             0036*  BUF_SEEKER_014: equ $0122
040060             0037*  BUF_SEEKER_015: equ $0123
040060             0038*  BUF_SEEKER_016: equ $0124
040060             0039*  BUF_SEEKER_017: equ $0125
040060             0040*  BUF_SEEKER_018: equ $0126
040060             0041*  BUF_SEEKER_019: equ $0127
040060             0042*  BUF_SEEKER_020: equ $0128
040060             0043*  BUF_SEEKER_021: equ $0129
040060             0044*  BUF_SEEKER_022: equ $012A
040060             0045*  BUF_SEEKER_023: equ $012B
040060             0046*  BUF_SEEKER_024: equ $012C
040060             0047*  BUF_SEEKER_025: equ $012D
040060             0048*  BUF_SEEKER_026: equ $012E
040060             0049*  BUF_SEEKER_027: equ $012F
040060             0050*  BUF_SEEKER_028: equ $0130
040060             0051*  BUF_SEEKER_029: equ $0131
040060             0052*  BUF_SEEKER_030: equ $0132
040060             0053*  BUF_SEEKER_031: equ $0133
040060             0054*  BUF_SHIP_0L: equ $0134
040060             0055*  BUF_SHIP_1C: equ $0135
040060             0056*  BUF_SHIP_2R: equ $0136
040060             0057*  BUF_SHIP_SMALL: equ $0137
040060             0058*  BUF_STAR: equ $0138
040060             0059*  BUF_TURRET: equ $0139
040060             0060*  BUF_TURRET_ROT: equ $013A
040060             0061*  
040060             0062*  ; import .rgba bitmap files and load them into VDP buffers
040060             0063*  bmp2_init:
040060 21 6B 00 04 0064*  	ld hl, @cmd
040064 01 76 3C 00 0065*  	ld bc, @end-@cmd
040068 5B DF       0066*  	rst.lil $18
04006A C9          0067*  	ret
04006B             0068*  @cmd:
04006B             0069*  	LOADBMPBUFFER2 BUF_0TILE_EMPTY,16,16,"src/rgba2/0tile_empty.rgba2"
04006B             0001*M 
04006B             0002*M     ; Clear buffer
04006B 17 00 A0    0003*M     db 23,0,0xA0
04006E 00 01       0004*M     dw bufferId
040070 02          0005*M     db 2
040071             0006*M 
040071 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040074 00 01       0008*M     dw bufferId
040076             0009*M 
040076             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040076 17 00 A0    0011*M     db 23,0,0xA0
040079 00 01       0012*M     dw bufferId
04007B 00          0013*M     db 0
04007C 00 01       0014*M 	dw width * height ; length of data in bytes
04007E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04017E             0016*M 
04017E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04017E 17 1B 21    0018*M     db 23,27,0x21
040181 10 00       0019*M     dw width ; in pixels
040183 10 00       0020*M     dw height ; in pixels
040185 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040186             0070*  	LOADBMPBUFFER2 BUF_1TILE_CROSS,16,16,"src/rgba2/1tile_cross.rgba2"
040186             0001*M 
040186             0002*M     ; Clear buffer
040186 17 00 A0    0003*M     db 23,0,0xA0
040189 01 01       0004*M     dw bufferId
04018B 02          0005*M     db 2
04018C             0006*M 
04018C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04018F 01 01       0008*M     dw bufferId
040191             0009*M 
040191             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040191 17 00 A0    0011*M     db 23,0,0xA0
040194 01 01       0012*M     dw bufferId
040196 00          0013*M     db 0
040197 00 01       0014*M 	dw width * height ; length of data in bytes
040199 00 00 D0 F5 0015*M     incbin file ; bitmap data
       FA FF FF FF 
       FF FF FF EA 
       F5 D0 00 00 
       00 00 D0 F5 
       FA EA FF FF 
       FF FF EA EA 
       F5 D0 00 00 
       D0 D0 D0 F5 
       FA FF FF FF 
       FF FF EA EA 
       F5 D0 D0 D0 
       F5 F5 F5 F5 
       FB FA EA EA 
       EA EA EA E5 
       F5 F5 F5 F5 
       D1 E5 E5 D0 
       FA FB E5 FA 
       FA FA FA FA 
       C0 D0 D0 D0 
       E1 E1 D0 D0 
       FA D1 D0 D1 
       D0 D0 D0 EA 
       D1 D1 D1 D1 
       FA FF E5 E5 
       E5 D0 F8 FD 
       FE F8 D0 E5 
       D1 E5 E5 E5 
       FA FF FA E5 
       E5 D0 F8 FD 
       FE F8 D0 FA 
       E5 E5 E5 E5 
       E5 FB FA E5 
       E5 D0 F8 FD 
       FE F8 E1 FA 
       E5 E5 E5 E5 
       FA FA FA E5 
       E5 D0 F8 FD 
       FD F8 D0 FA 
       E5 E5 E5 E5 
       E5 E5 E5 E5 
       E5 D0 F8 F8 
       F8 F8 D0 FA 
       D1 D1 D1 D1 
       E1 E1 E1 E1 
       D1 D0 D0 D0 
       D0 D0 D0 E5 
       D0 D1 D0 D0 
       F5 F5 F5 F5 
       E5 D1 E1 E5 
       E5 E5 E5 E5 
       F5 F5 F5 F5 
       D0 D0 D0 F5 
       E5 E5 E5 E5 
       E6 E5 E5 E5 
       F5 D0 D0 D0 
       00 00 D0 F5 
       E5 E6 D6 E6 
       D7 E6 E6 E5 
       F5 D0 00 00 
       00 00 D0 F5 
       E5 E6 E6 D6 
       D6 D6 E6 E5 
       F5 D0 00 00 
040299             0016*M 
040299             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040299 17 1B 21    0018*M     db 23,27,0x21
04029C 10 00       0019*M     dw width ; in pixels
04029E 10 00       0020*M     dw height ; in pixels
0402A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0402A1             0071*  	LOADBMPBUFFER2 BUF_2TILE_HORIZ,16,16,"src/rgba2/2tile_horiz.rgba2"
0402A1             0001*M 
0402A1             0002*M     ; Clear buffer
0402A1 17 00 A0    0003*M     db 23,0,0xA0
0402A4 02 01       0004*M     dw bufferId
0402A6 02          0005*M     db 2
0402A7             0006*M 
0402A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0402AA 02 01       0008*M     dw bufferId
0402AC             0009*M 
0402AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0402AC 17 00 A0    0011*M     db 23,0,0xA0
0402AF 02 01       0012*M     dw bufferId
0402B1 00          0013*M     db 0
0402B2 00 01       0014*M 	dw width * height ; length of data in bytes
0402B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF F8 
       F8 F8 F8 EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF FF 
       EA EA FA FA 
       F8 F8 EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FA E5 
       F8 F8 EA EA 
       D0 E6 E6 D1 
       D1 D1 D1 EA 
       EA F8 F5 F5 
       EA F8 EA D0 
       C0 D1 D1 D1 
       D1 D2 D1 D0 
       D0 EA F5 E5 
       EA EA F8 E5 
       E5 E6 E6 E6 
       E6 E6 D1 F8 
       E5 EA E5 E5 
       EA E5 D1 D1 
       D1 D1 D1 D1 
       D1 D1 C0 D1 
       EA D1 EA D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0403B4             0016*M 
0403B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0403B4 17 1B 21    0018*M     db 23,27,0x21
0403B7 10 00       0019*M     dw width ; in pixels
0403B9 10 00       0020*M     dw height ; in pixels
0403BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0403BC             0072*  	LOADBMPBUFFER2 BUF_3TILE_VERT,16,16,"src/rgba2/3tile_vert.rgba2"
0403BC             0001*M 
0403BC             0002*M     ; Clear buffer
0403BC 17 00 A0    0003*M     db 23,0,0xA0
0403BF 03 01       0004*M     dw bufferId
0403C1 02          0005*M     db 2
0403C2             0006*M 
0403C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0403C5 03 01       0008*M     dw bufferId
0403C7             0009*M 
0403C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0403C7 17 00 A0    0011*M     db 23,0,0xA0
0403CA 03 01       0012*M     dw bufferId
0403CC 00          0013*M     db 0
0403CD 00 01       0014*M 	dw width * height ; length of data in bytes
0403CF 00 00 D0 F5 0015*M     incbin file ; bitmap data
       D0 D0 D0 D0 
       E5 E5 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 E5 E5 
       E5 F8 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E5 E5 
       FA F8 FD F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E1 E5 
       E5 E5 FA F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 D0 D1 
       E6 E6 FA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D1 D1 D1 
       FB EA FB D1 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 EA C0 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E1 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 C0 EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 F8 F8 
       FA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       EA EA F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 E5 F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
0404CF             0016*M 
0404CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0404CF 17 1B 21    0018*M     db 23,27,0x21
0404D2 10 00       0019*M     dw width ; in pixels
0404D4 10 00       0020*M     dw height ; in pixels
0404D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0404D7             0073*  	LOADBMPBUFFER2 BUF_4TILE_SQUARE,16,16,"src/rgba2/4tile_square.rgba2"
0404D7             0001*M 
0404D7             0002*M     ; Clear buffer
0404D7 17 00 A0    0003*M     db 23,0,0xA0
0404DA 04 01       0004*M     dw bufferId
0404DC 02          0005*M     db 2
0404DD             0006*M 
0404DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0404E0 04 01       0008*M     dw bufferId
0404E2             0009*M 
0404E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0404E2 17 00 A0    0011*M     db 23,0,0xA0
0404E5 04 01       0012*M     dw bufferId
0404E7 00          0013*M     db 0
0404E8 00 01       0014*M 	dw width * height ; length of data in bytes
0404EA D0 D1 E5 D1 0015*M     incbin file ; bitmap data
       E5 E5 D0 D5 
       D0 D0 D0 D0 
       D0 D5 D0 D1 
       D5 EA EA EA 
       EA E5 E5 E5 
       E5 E5 E5 D5 
       D1 FF E9 D5 
       D0 EA EA D5 
       D5 D5 D1 D5 
       D4 D4 FE FE 
       D1 EA E5 D5 
       D0 C0 D1 D1 
       D2 D2 E6 E9 
       FE FE FE FE 
       C0 C0 C0 D1 
       D0 D1 D1 D2 
       D2 D2 E6 D4 
       E9 E9 FE FE 
       D1 D0 D0 D0 
       D0 D1 D2 D2 
       D2 D2 D5 C0 
       D1 D1 D4 E9 
       D1 C0 E5 D0 
       D0 D1 C0 D5 
       D5 D5 E6 E6 
       E6 E6 D1 E5 
       E5 C0 E5 E5 
       D0 D1 D1 E9 
       FE D5 D1 D2 
       D2 D1 D1 E9 
       E9 C0 D1 D0 
       E5 D1 C0 D0 
       E5 D0 D1 D2 
       D2 D1 D1 E5 
       E5 C0 EA D0 
       E5 E5 C0 C0 
       D5 C1 D5 D1 
       D1 C1 D1 D0 
       D4 D5 EA D0 
       E5 E5 D5 D2 
       D2 D2 D0 D0 
       D5 D5 D5 E9 
       E9 C0 EA E5 
       E5 E5 D5 D2 
       D2 D2 EA E9 
       FA FA D4 E6 
       E5 D5 E5 D1 
       D0 EA D5 D2 
       D1 C1 D5 E5 
       E9 E9 D0 E5 
       D0 E5 E5 E5 
       D0 D4 E9 D4 
       C0 C0 D5 C0 
       D0 D0 C0 D0 
       D0 EA EA D0 
       D0 D4 D4 D5 
       C0 D0 D5 C0 
       C0 C0 D0 C0 
       D0 D0 D0 D0 
       D0 D0 D0 C0 
       C0 D0 D0 D0 
       D5 D0 D0 C0 
       D0 D5 D0 D0 
0405EA             0016*M 
0405EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0405EA 17 1B 21    0018*M     db 23,27,0x21
0405ED 10 00       0019*M     dw width ; in pixels
0405EF 10 00       0020*M     dw height ; in pixels
0405F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0405F2             0074*  	LOADBMPBUFFER2 BUF_5TILE_CIRCLE,16,16,"src/rgba2/5tile_circle.rgba2"
0405F2             0001*M 
0405F2             0002*M     ; Clear buffer
0405F2 17 00 A0    0003*M     db 23,0,0xA0
0405F5 05 01       0004*M     dw bufferId
0405F7 02          0005*M     db 2
0405F8             0006*M 
0405F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0405FB 05 01       0008*M     dw bufferId
0405FD             0009*M 
0405FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0405FD 17 00 A0    0011*M     db 23,0,0xA0
040600 05 01       0012*M     dw bufferId
040602 00          0013*M     db 0
040603 00 01       0014*M 	dw width * height ; length of data in bytes
040605 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 D0 D0 D1 
       EA D1 D1 D0 
       D0 00 00 00 
       00 00 D0 D0 
       D0 D1 D1 EA 
       FB EA D1 D1 
       D0 D0 00 00 
       00 D0 D0 D1 
       D1 D0 D0 D1 
       D1 EA D1 E5 
       EA D0 D0 00 
       00 D0 E1 D1 
       D0 D0 CA EA 
       EA D7 EA E6 
       D1 D1 D0 00 
       D0 D1 E1 FA 
       D1 CA EF FF 
       FF EF D7 D0 
       D1 D1 D1 D0 
       D0 D0 D0 E5 
       FB EA EF FF 
       FF EF EA D0 
       E5 D0 D0 D0 
       D0 E1 D0 EA 
       EA EF EF EF 
       EF EF EA E5 
       EA D0 D0 D0 
       D0 D0 D0 D1 
       EA F8 EA EA 
       EA EA F8 D0 
       EA D0 D1 D0 
       D0 D0 D1 D1 
       E5 EA F8 F8 
       F8 F8 E5 E1 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D1 E5 E5 E1 
       E1 E1 E1 D0 
       D0 D1 D0 D0 
       00 D0 D0 D0 
       D0 D0 C0 D0 
       D0 C0 D0 D0 
       D0 C0 D0 00 
       00 D0 D0 D0 
       C0 C0 EA E6 
       E6 D1 C0 C0 
       D0 D0 D0 00 
       00 00 D0 D0 
       C0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 D0 00 00 
       00 00 00 D0 
       D0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040705             0016*M 
040705             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040705 17 1B 21    0018*M     db 23,27,0x21
040708 10 00       0019*M     dw width ; in pixels
04070A 10 00       0020*M     dw height ; in pixels
04070C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04070D             0075*  	LOADBMPBUFFER2 BUF_6TILE_PAD,16,16,"src/rgba2/6tile_pad.rgba2"
04070D             0001*M 
04070D             0002*M     ; Clear buffer
04070D 17 00 A0    0003*M     db 23,0,0xA0
040710 06 01       0004*M     dw bufferId
040712 02          0005*M     db 2
040713             0006*M 
040713 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040716 06 01       0008*M     dw bufferId
040718             0009*M 
040718             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040718 17 00 A0    0011*M     db 23,0,0xA0
04071B 06 01       0012*M     dw bufferId
04071D 00          0013*M     db 0
04071E 00 01       0014*M 	dw width * height ; length of data in bytes
040720 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
040820             0016*M 
040820             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040820 17 1B 21    0018*M     db 23,27,0x21
040823 10 00       0019*M     dw width ; in pixels
040825 10 00       0020*M     dw height ; in pixels
040827 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040828             0076*  	LOADBMPBUFFER2 BUF_7TILE_TURRET,16,16,"src/rgba2/7tile_turret.rgba2"
040828             0001*M 
040828             0002*M     ; Clear buffer
040828 17 00 A0    0003*M     db 23,0,0xA0
04082B 07 01       0004*M     dw bufferId
04082D 02          0005*M     db 2
04082E             0006*M 
04082E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040831 07 01       0008*M     dw bufferId
040833             0009*M 
040833             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040833 17 00 A0    0011*M     db 23,0,0xA0
040836 07 01       0012*M     dw bufferId
040838 00          0013*M     db 0
040839 00 01       0014*M 	dw width * height ; length of data in bytes
04083B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
04093B             0016*M 
04093B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04093B 17 1B 21    0018*M     db 23,27,0x21
04093E 10 00       0019*M     dw width ; in pixels
040940 10 00       0020*M     dw height ; in pixels
040942 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040943             0077*  	LOADBMPBUFFER2 BUF_CIRCLE,16,16,"src/rgba2/circle.rgba2"
040943             0001*M 
040943             0002*M     ; Clear buffer
040943 17 00 A0    0003*M     db 23,0,0xA0
040946 08 01       0004*M     dw bufferId
040948 02          0005*M     db 2
040949             0006*M 
040949 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04094C 08 01       0008*M     dw bufferId
04094E             0009*M 
04094E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04094E 17 00 A0    0011*M     db 23,0,0xA0
040951 08 01       0012*M     dw bufferId
040953 00          0013*M     db 0
040954 00 01       0014*M 	dw width * height ; length of data in bytes
040956 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040A56             0016*M 
040A56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040A56 17 1B 21    0018*M     db 23,27,0x21
040A59 10 00       0019*M     dw width ; in pixels
040A5B 10 00       0020*M     dw height ; in pixels
040A5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040A5E             0078*  	LOADBMPBUFFER2 BUF_CRATER,16,16,"src/rgba2/crater.rgba2"
040A5E             0001*M 
040A5E             0002*M     ; Clear buffer
040A5E 17 00 A0    0003*M     db 23,0,0xA0
040A61 09 01       0004*M     dw bufferId
040A63 02          0005*M     db 2
040A64             0006*M 
040A64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040A67 09 01       0008*M     dw bufferId
040A69             0009*M 
040A69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A69 17 00 A0    0011*M     db 23,0,0xA0
040A6C 09 01       0012*M     dw bufferId
040A6E 00          0013*M     db 0
040A6F 00 01       0014*M 	dw width * height ; length of data in bytes
040A71 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E2 C0 F2 
       C0 D1 E2 00 
       00 00 00 00 
       00 00 D2 D5 
       C0 D2 C0 C6 
       D1 C6 D1 C1 
       C0 E2 00 00 
       00 F2 EA D5 
       DF C0 D1 D2 
       DF D2 D1 C1 
       C0 EA C0 00 
       00 F2 D5 C0 
       C0 C0 CB D1 
       D6 DF D5 C0 
       C0 C0 D5 00 
       F2 D5 C0 C6 
       C0 CB D1 D6 
       D6 D7 D6 C0 
       D5 C1 C0 C0 
       D5 C0 C0 D5 
       C1 D1 C1 D6 
       C2 D7 C2 C1 
       C0 CB C1 C1 
       C1 C6 C0 C1 
       DF C2 D6 D7 
       D7 DB D6 CB 
       C1 D6 D6 D5 
       C0 C0 C0 D5 
       F7 D6 D7 DB 
       EB EF D7 D6 
       D6 CB C1 C1 
       C1 D6 C0 C1 
       D6 EB EB FF 
       CB FF FF EB 
       D6 C1 C1 D5 
       EA D5 C0 DF 
       C2 EA EA FF 
       FF FF EA C0 
       D6 D2 D5 C0 
       00 FA C2 D5 
       D5 C1 C0 CB 
       EA C0 D6 C1 
       C1 D5 E2 00 
       00 F2 FA C1 
       D5 D6 D5 C2 
       C0 D2 D2 D5 
       D6 C1 D5 00 
       00 00 FA F2 
       EB D6 C0 C0 
       C1 D5 D6 D6 
       EA D5 00 00 
       00 00 00 00 
       00 FA F6 F2 
       FA F6 F6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71             0016*M 
040B71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040B71 17 1B 21    0018*M     db 23,27,0x21
040B74 10 00       0019*M     dw width ; in pixels
040B76 10 00       0020*M     dw height ; in pixels
040B78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040B79             0079*  	LOADBMPBUFFER2 BUF_EXPLOSION_A,16,16,"src/rgba2/explosion_a.rgba2"
040B79             0001*M 
040B79             0002*M     ; Clear buffer
040B79 17 00 A0    0003*M     db 23,0,0xA0
040B7C 0A 01       0004*M     dw bufferId
040B7E 02          0005*M     db 2
040B7F             0006*M 
040B7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040B82 0A 01       0008*M     dw bufferId
040B84             0009*M 
040B84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B84 17 00 A0    0011*M     db 23,0,0xA0
040B87 0A 01       0012*M     dw bufferId
040B89 00          0013*M     db 0
040B8A 00 01       0014*M 	dw width * height ; length of data in bytes
040B8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 EF 
       EF EF C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C8C             0016*M 
040C8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040C8C 17 1B 21    0018*M     db 23,27,0x21
040C8F 10 00       0019*M     dw width ; in pixels
040C91 10 00       0020*M     dw height ; in pixels
040C93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040C94             0080*  	LOADBMPBUFFER2 BUF_EXPLOSION_B,16,16,"src/rgba2/explosion_b.rgba2"
040C94             0001*M 
040C94             0002*M     ; Clear buffer
040C94 17 00 A0    0003*M     db 23,0,0xA0
040C97 0B 01       0004*M     dw bufferId
040C99 02          0005*M     db 2
040C9A             0006*M 
040C9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040C9D 0B 01       0008*M     dw bufferId
040C9F             0009*M 
040C9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040C9F 17 00 A0    0011*M     db 23,0,0xA0
040CA2 0B 01       0012*M     dw bufferId
040CA4 00          0013*M     db 0
040CA5 00 01       0014*M 	dw width * height ; length of data in bytes
040CA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 00 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 00 C7 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040DA7             0016*M 
040DA7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040DA7 17 1B 21    0018*M     db 23,27,0x21
040DAA 10 00       0019*M     dw width ; in pixels
040DAC 10 00       0020*M     dw height ; in pixels
040DAE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040DAF             0081*  	LOADBMPBUFFER2 BUF_EXPLOSION_C,16,16,"src/rgba2/explosion_c.rgba2"
040DAF             0001*M 
040DAF             0002*M     ; Clear buffer
040DAF 17 00 A0    0003*M     db 23,0,0xA0
040DB2 0C 01       0004*M     dw bufferId
040DB4 02          0005*M     db 2
040DB5             0006*M 
040DB5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040DB8 0C 01       0008*M     dw bufferId
040DBA             0009*M 
040DBA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040DBA 17 00 A0    0011*M     db 23,0,0xA0
040DBD 0C 01       0012*M     dw bufferId
040DBF 00          0013*M     db 0
040DC0 00 01       0014*M 	dw width * height ; length of data in bytes
040DC2 00 C7 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 C6 
       C7 C7 C6 00 
       00 00 00 00 
       C7 C7 EF EF 
       EF EF C7 C6 
       C7 C7 C6 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C6 C6 00 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 EF 
       EF EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       00 C6 C6 C6 
       C6 EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 C7 EF 
       C7 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 00 C7 
       C7 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 C6 C6 C6 
       C6 C7 EF EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040EC2             0016*M 
040EC2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040EC2 17 1B 21    0018*M     db 23,27,0x21
040EC5 10 00       0019*M     dw width ; in pixels
040EC7 10 00       0020*M     dw height ; in pixels
040EC9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040ECA             0082*  	LOADBMPBUFFER2 BUF_EXPLOSION_D,16,16,"src/rgba2/explosion_d.rgba2"
040ECA             0001*M 
040ECA             0002*M     ; Clear buffer
040ECA 17 00 A0    0003*M     db 23,0,0xA0
040ECD 0D 01       0004*M     dw bufferId
040ECF 02          0005*M     db 2
040ED0             0006*M 
040ED0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040ED3 0D 01       0008*M     dw bufferId
040ED5             0009*M 
040ED5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040ED5 17 00 A0    0011*M     db 23,0,0xA0
040ED8 0D 01       0012*M     dw bufferId
040EDA 00          0013*M     db 0
040EDB 00 01       0014*M 	dw width * height ; length of data in bytes
040EDD 00 C7 C7 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C7 C7 00 
       00 00 C6 C6 
       C6 C6 00 C6 
       00 00 00 00 
       00 00 00 00 
       C6 C6 C7 C7 
       C7 C7 C6 C6 
       C6 C6 00 00 
       00 00 00 C6 
       C7 C7 EF EF 
       EF EF EF EF 
       C6 C6 00 C6 
       00 00 C6 C7 
       EF EF EF EF 
       EF EF EF C6 
       C7 C6 00 00 
       00 00 C6 C7 
       EF EF EF 00 
       00 EF EF EF 
       C7 C6 C6 00 
       00 C6 C7 EF 
       EF EF 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       00 C6 C7 EF 
       EF 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       00 C7 C7 C7 
       C7 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       C7 C6 C7 EF 
       EF C7 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       C6 00 C6 C7 
       EF C7 EF 00 
       00 EF EF EF 
       C7 C6 00 00 
       C6 00 C6 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 C6 00 00 
       C6 00 00 C6 
       C7 C7 EF EF 
       EF EF C7 C7 
       C6 00 00 00 
       00 C6 C6 C6 
       C7 C6 C7 C7 
       C7 C7 C6 C6 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FDD             0016*M 
040FDD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040FDD 17 1B 21    0018*M     db 23,27,0x21
040FE0 10 00       0019*M     dw width ; in pixels
040FE2 10 00       0020*M     dw height ; in pixels
040FE4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040FE5             0083*  	LOADBMPBUFFER2 BUF_EXPLOSION_E,16,16,"src/rgba2/explosion_e.rgba2"
040FE5             0001*M 
040FE5             0002*M     ; Clear buffer
040FE5 17 00 A0    0003*M     db 23,0,0xA0
040FE8 0E 01       0004*M     dw bufferId
040FEA 02          0005*M     db 2
040FEB             0006*M 
040FEB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040FEE 0E 01       0008*M     dw bufferId
040FF0             0009*M 
040FF0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040FF0 17 00 A0    0011*M     db 23,0,0xA0
040FF3 0E 01       0012*M     dw bufferId
040FF5 00          0013*M     db 0
040FF6 00 01       0014*M 	dw width * height ; length of data in bytes
040FF8 00 00 00 C6 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 C6 C7 C7 
       C7 C7 C7 C6 
       00 00 00 00 
       00 00 C6 C6 
       C7 C7 00 00 
       00 00 00 00 
       C7 00 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0410F8             0016*M 
0410F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0410F8 17 1B 21    0018*M     db 23,27,0x21
0410FB 10 00       0019*M     dw width ; in pixels
0410FD 10 00       0020*M     dw height ; in pixels
0410FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041100             0084*  	LOADBMPBUFFER2 BUF_FIREBALL_A,7,7,"src/rgba2/fireball_a.rgba2"
041100             0001*M 
041100             0002*M     ; Clear buffer
041100 17 00 A0    0003*M     db 23,0,0xA0
041103 0F 01       0004*M     dw bufferId
041105 02          0005*M     db 2
041106             0006*M 
041106 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041109 0F 01       0008*M     dw bufferId
04110B             0009*M 
04110B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04110B 17 00 A0    0011*M     db 23,0,0xA0
04110E 0F 01       0012*M     dw bufferId
041110 00          0013*M     db 0
041111 31 00       0014*M 	dw width * height ; length of data in bytes
041113 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 D2 CB 
       D1 00 D2 CB 
       D6 D7 DB D7 
       D2 D7 D2 D6 
       DB D2 D2 D2 
       D2 D2 D6 D6 
       D6 C3 D1 00 
       D1 C3 D2 CB 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041144             0016*M 
041144             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041144 17 1B 21    0018*M     db 23,27,0x21
041147 07 00       0019*M     dw width ; in pixels
041149 07 00       0020*M     dw height ; in pixels
04114B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04114C             0085*  	LOADBMPBUFFER2 BUF_FIREBALL_B,7,7,"src/rgba2/fireball_b.rgba2"
04114C             0001*M 
04114C             0002*M     ; Clear buffer
04114C 17 00 A0    0003*M     db 23,0,0xA0
04114F 10 01       0004*M     dw bufferId
041151 02          0005*M     db 2
041152             0006*M 
041152 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041155 10 01       0008*M     dw bufferId
041157             0009*M 
041157             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041157 17 00 A0    0011*M     db 23,0,0xA0
04115A 10 01       0012*M     dw bufferId
04115C 00          0013*M     db 0
04115D 31 00       0014*M 	dw width * height ; length of data in bytes
04115F 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 DF CB 
       D1 00 D2 D2 
       C7 C3 D7 D2 
       D1 D7 C3 DF 
       CB CB C3 D2 
       D2 D2 C7 CB 
       C7 C3 D1 00 
       D1 C3 C3 D2 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041190             0016*M 
041190             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041190 17 1B 21    0018*M     db 23,27,0x21
041193 07 00       0019*M     dw width ; in pixels
041195 07 00       0020*M     dw height ; in pixels
041197 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041198             0086*  	LOADBMPBUFFER2 BUF_LASER_A,5,13,"src/rgba2/laser_a.rgba2"
041198             0001*M 
041198             0002*M     ; Clear buffer
041198 17 00 A0    0003*M     db 23,0,0xA0
04119B 11 01       0004*M     dw bufferId
04119D 02          0005*M     db 2
04119E             0006*M 
04119E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411A1 11 01       0008*M     dw bufferId
0411A3             0009*M 
0411A3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411A3 17 00 A0    0011*M     db 23,0,0xA0
0411A6 11 01       0012*M     dw bufferId
0411A8 00          0013*M     db 0
0411A9 41 00       0014*M 	dw width * height ; length of data in bytes
0411AB 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 E5 
       FF E5 00 00 
       00 FF E5 00 
       00 00 FF E5 
       00 00 00 FA 
       00 00 00 00 
       E5 00 00 00 
       00 E5 00 00 
       00 00 00 00 
       00          
0411EC             0016*M 
0411EC             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0411EC 17 1B 21    0018*M     db 23,27,0x21
0411EF 05 00       0019*M     dw width ; in pixels
0411F1 0D 00       0020*M     dw height ; in pixels
0411F3 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0411F4             0087*  	LOADBMPBUFFER2 BUF_LASER_B,5,13,"src/rgba2/laser_b.rgba2"
0411F4             0001*M 
0411F4             0002*M     ; Clear buffer
0411F4 17 00 A0    0003*M     db 23,0,0xA0
0411F7 12 01       0004*M     dw bufferId
0411F9 02          0005*M     db 2
0411FA             0006*M 
0411FA 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411FD 12 01       0008*M     dw bufferId
0411FF             0009*M 
0411FF             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411FF 17 00 A0    0011*M     db 23,0,0xA0
041202 12 01       0012*M     dw bufferId
041204 00          0013*M     db 0
041205 41 00       0014*M 	dw width * height ; length of data in bytes
041207 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 FA 
       FF E5 00 00 
       E5 E5 00 00 
       00 00 E5 00 
       00 00 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E5 00 
       00          
041248             0016*M 
041248             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041248 17 1B 21    0018*M     db 23,27,0x21
04124B 05 00       0019*M     dw width ; in pixels
04124D 0D 00       0020*M     dw height ; in pixels
04124F 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041250             0088*  	LOADBMPBUFFER2 BUF_PAD,16,16,"src/rgba2/pad.rgba2"
041250             0001*M 
041250             0002*M     ; Clear buffer
041250 17 00 A0    0003*M     db 23,0,0xA0
041253 13 01       0004*M     dw bufferId
041255 02          0005*M     db 2
041256             0006*M 
041256 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041259 13 01       0008*M     dw bufferId
04125B             0009*M 
04125B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04125B 17 00 A0    0011*M     db 23,0,0xA0
04125E 13 01       0012*M     dw bufferId
041260 00          0013*M     db 0
041261 00 01       0014*M 	dw width * height ; length of data in bytes
041263 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
041363             0016*M 
041363             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041363 17 1B 21    0018*M     db 23,27,0x21
041366 10 00       0019*M     dw width ; in pixels
041368 10 00       0020*M     dw height ; in pixels
04136A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04136B             0089*  	LOADBMPBUFFER2 BUF_SEEKER_000,16,16,"src/rgba2/seeker_000.rgba2"
04136B             0001*M 
04136B             0002*M     ; Clear buffer
04136B 17 00 A0    0003*M     db 23,0,0xA0
04136E 14 01       0004*M     dw bufferId
041370 02          0005*M     db 2
041371             0006*M 
041371 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041374 14 01       0008*M     dw bufferId
041376             0009*M 
041376             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041376 17 00 A0    0011*M     db 23,0,0xA0
041379 14 01       0012*M     dw bufferId
04137B 00          0013*M     db 0
04137C 00 01       0014*M 	dw width * height ; length of data in bytes
04137E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA F5 
       E1 E5 00 00 
       00 00 00 00 
       00 FA 00 00 
       EA 00 FF FF 
       EE EA 00 EA 
       00 00 EA 00 
       F6 E2 E5 00 
       E1 F6 FB FF 
       EB E5 E2 E1 
       00 E5 E1 E2 
       F6 E1 F6 E2 
       E1 EB FB FA 
       F6 E6 D7 E1 
       F7 F6 E1 E1 
       F5 E1 E1 00 
       F6 EA FA F5 
       F5 E5 D5 F6 
       00 E1 E1 E1 
       00 E1 E1 E2 
       E1 F6 F8 FC 
       F8 F4 E1 E1 
       E2 E1 E1 00 
       00 E1 00 00 
       E1 E1 FC FE 
       FD F8 E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 FD FE 
       FD F9 D0 E1 
       00 00 E1 00 
       00 FA 00 00 
       E1 E1 F5 FD 
       F9 E1 D0 E1 
       00 00 EA 00 
       EF DB DB 00 
       E5 E1 E2 F5 
       F5 D1 D0 E5 
       00 DB DB DB 
       00 DF 00 00 
       00 E1 E2 F5 
       E1 D1 D0 00 
       00 00 DF 00 
       EF DB DB 00 
       00 E1 E2 00 
       00 D1 D0 00 
       00 DB DB DB 
       00 EB 00 00 
       00 E2 FB 00 
       00 E6 D1 00 
       00 00 D7 00 
       00 C3 00 00 
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
04147E             0016*M 
04147E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04147E 17 1B 21    0018*M     db 23,27,0x21
041481 10 00       0019*M     dw width ; in pixels
041483 10 00       0020*M     dw height ; in pixels
041485 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041486             0090*  	LOADBMPBUFFER2 BUF_SEEKER_001,16,16,"src/rgba2/seeker_001.rgba2"
041486             0001*M 
041486             0002*M     ; Clear buffer
041486 17 00 A0    0003*M     db 23,0,0xA0
041489 15 01       0004*M     dw bufferId
04148B 02          0005*M     db 2
04148C             0006*M 
04148C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04148F 15 01       0008*M     dw bufferId
041491             0009*M 
041491             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041491 17 00 A0    0011*M     db 23,0,0xA0
041494 15 01       0012*M     dw bufferId
041496 00          0013*M     db 0
041497 00 01       0014*M 	dw width * height ; length of data in bytes
041499 00 FA 00 00 0015*M     incbin file ; bitmap data
       00 00 FA 00 
       F5 F5 E0 00 
       00 00 00 00 
       00 00 FA 00 
       EA 00 00 FF 
       F5 E5 D0 00 
       00 00 00 00 
       00 E6 FA 00 
       00 EA 00 FA 
       F5 E0 E5 E5 
       00 00 00 00 
       00 F2 E1 E5 
       00 E6 F6 FF 
       FF EA E5 00 
       EA 00 00 00 
       00 E1 E1 E2 
       E1 E2 FB FB 
       FF EA E5 E2 
       EA 00 FF EA 
       F5 E4 E1 E1 
       F1 E6 EB FB 
       FA E6 E6 E2 
       E1 E9 E5 E6 
       00 E0 E1 E2 
       E1 F6 FA F9 
       F5 E5 D6 E2 
       F6 F6 E1 E1 
       D0 E0 00 E2 
       E1 E5 F8 FC 
       F8 F4 E5 E5 
       F2 E1 E1 E1 
       F5 E5 00 E0 
       E1 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E0 
       EB EB 00 E1 
       E0 E5 FD FE 
       FD E4 D1 E1 
       00 E0 E1 00 
       DF DB DB E5 
       E5 E1 F5 FD 
       E5 D0 D0 E0 
       00 E0 E0 00 
       DF DF 00 FF 
       E4 E2 F6 F5 
       E1 D0 E5 E1 
       00 F5 F5 00 
       DB DB D6 00 
       E0 E2 E1 E1 
       D1 D0 E5 F0 
       EB DB DB 00 
       E7 00 00 E1 
       E2 E7 00 D1 
       D1 D0 00 00 
       00 DF DB 00 
       C3 00 00 F2 
       F3 FF 00 E6 
       E6 C0 00 DB 
       DB DB EB 00 
       00 00 00 00 
       00 00 E6 00 
       E2 E2 00 00 
       D7 DB DB 00 
041599             0016*M 
041599             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041599 17 1B 21    0018*M     db 23,27,0x21
04159C 10 00       0019*M     dw width ; in pixels
04159E 10 00       0020*M     dw height ; in pixels
0415A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0415A1             0091*  	LOADBMPBUFFER2 BUF_SEEKER_002,16,16,"src/rgba2/seeker_002.rgba2"
0415A1             0001*M 
0415A1             0002*M     ; Clear buffer
0415A1 17 00 A0    0003*M     db 23,0,0xA0
0415A4 16 01       0004*M     dw bufferId
0415A6 02          0005*M     db 2
0415A7             0006*M 
0415A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0415AA 16 01       0008*M     dw bufferId
0415AC             0009*M 
0415AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415AC 17 00 A0    0011*M     db 23,0,0xA0
0415AF 16 01       0012*M     dw bufferId
0415B1 00          0013*M     db 0
0415B2 00 01       0014*M 	dw width * height ; length of data in bytes
0415B4 00 00 00 FE 0015*M     incbin file ; bitmap data
       00 FA 00 00 
       00 E1 F5 00 
       00 00 00 00 
       00 00 F6 FA 
       FF 00 FA 00 
       FF F1 F5 E0 
       00 00 00 00 
       00 00 E2 E1 
       E5 00 EA 00 
       FA F5 E0 E1 
       00 D0 00 00 
       00 F5 E1 E1 
       E6 E1 E2 F6 
       FF FA E5 E5 
       E5 00 00 00 
       00 E1 E0 E1 
       E2 E1 E7 FB 
       FF FF EA D5 
       00 EA E5 00 
       00 E0 E1 E2 
       E2 F6 EB FB 
       FA FA E5 E2 
       E6 EA 00 FA 
       00 E0 E0 F3 
       E1 E5 F9 F9 
       F5 E5 E6 E2 
       E1 F7 E5 EA 
       FA F5 00 E4 
       E1 E1 F8 FC 
       F8 F4 E5 E6 
       F6 F6 E5 E1 
       DB EB 00 E0 
       E0 E5 FD FE 
       FD F4 E1 E5 
       E2 E1 E1 E1 
       DF DB 00 E5 
       E1 E5 FE FE 
       FD E4 E1 E1 
       E2 E1 E0 E1 
       DB F1 00 E5 
       E1 E2 F9 F9 
       E5 D0 E1 E4 
       00 E0 E1 00 
       DB DB 00 E0 
       E2 F2 F5 E1 
       D1 D0 E0 00 
       00 E0 E0 00 
       00 00 E1 E1 
       E2 E1 E0 D1 
       D0 E5 E5 00 
       EA E5 00 00 
       00 00 F2 F7 
       FB 00 D2 D1 
       D0 00 F0 EB 
       DB DA 00 00 
       00 00 00 F2 
       00 00 E6 E5 
       D0 00 E7 DF 
       DF DB 00 00 
       00 00 00 00 
       00 00 00 E2 
       D1 00 EB DB 
       DB E7 00 00 
0416B4             0016*M 
0416B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0416B4 17 1B 21    0018*M     db 23,27,0x21
0416B7 10 00       0019*M     dw width ; in pixels
0416B9 10 00       0020*M     dw height ; in pixels
0416BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0416BC             0092*  	LOADBMPBUFFER2 BUF_SEEKER_003,16,16,"src/rgba2/seeker_003.rgba2"
0416BC             0001*M 
0416BC             0002*M     ; Clear buffer
0416BC 17 00 A0    0003*M     db 23,0,0xA0
0416BF 17 01       0004*M     dw bufferId
0416C1 02          0005*M     db 2
0416C2             0006*M 
0416C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0416C5 17 01       0008*M     dw bufferId
0416C7             0009*M 
0416C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0416C7 17 00 A0    0011*M     db 23,0,0xA0
0416CA 17 01       0012*M     dw bufferId
0416CC 00          0013*M     db 0
0416CD 00 01       0014*M 	dw width * height ; length of data in bytes
0416CF 00 00 00 F7 0015*M     incbin file ; bitmap data
       FA FF 00 F5 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 F6 
       E2 E5 00 EA 
       00 FF 00 F5 
       F5 00 00 00 
       00 00 F5 E1 
       E1 E5 00 FA 
       00 FA F5 F5 
       E0 00 00 00 
       00 00 E0 E1 
       E1 E2 E1 E2 
       F6 FF F5 E0 
       E5 00 00 00 
       00 E0 E1 E1 
       E2 F1 E6 EB 
       FB FF FF EA 
       E5 00 00 00 
       00 E1 E0 00 
       E2 E1 E6 FB 
       FB FA EA E5 
       00 FE 00 F5 
       EB FA 00 00 
       E1 E1 F9 F9 
       F5 F5 E6 E2 
       E2 EA 00 00 
       CB DB 00 E0 
       E1 E1 FC FC 
       F8 E5 E6 D6 
       E1 D1 C4 EA 
       DF E7 F0 E5 
       E0 F9 FE FE 
       F8 F4 E5 F6 
       F6 F6 F5 E5 
       DB D6 FF E5 
       E1 F5 FD FD 
       FD E4 E1 E1 
       E1 E1 E1 E1 
       C6 00 E0 E1 
       E2 F6 F9 E5 
       E4 D0 E1 E2 
       E1 E1 E0 E1 
       00 E2 E1 E2 
       E2 F5 E1 D1 
       D0 E0 E1 00 
       E0 E1 E0 00 
       00 F3 F7 FB 
       00 E0 D1 D1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 00 00 FF 
       00 E6 D1 D0 
       E5 F0 DB EA 
       E5 00 00 00 
       00 00 00 F7 
       00 E6 D1 D0 
       00 00 DB DA 
       DB 00 00 00 
       00 00 00 00 
       00 F3 E2 00 
       DB DB DF DF 
       EB 00 00 00 
0417CF             0016*M 
0417CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0417CF 17 1B 21    0018*M     db 23,27,0x21
0417D2 10 00       0019*M     dw width ; in pixels
0417D4 10 00       0020*M     dw height ; in pixels
0417D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0417D7             0093*  	LOADBMPBUFFER2 BUF_SEEKER_004,16,16,"src/rgba2/seeker_004.rgba2"
0417D7             0001*M 
0417D7             0002*M     ; Clear buffer
0417D7 17 00 A0    0003*M     db 23,0,0xA0
0417DA 18 01       0004*M     dw bufferId
0417DC 02          0005*M     db 2
0417DD             0006*M 
0417DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0417E0 18 01       0008*M     dw bufferId
0417E2             0009*M 
0417E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0417E2 17 00 A0    0011*M     db 23,0,0xA0
0417E5 18 01       0012*M     dw bufferId
0417E7 00          0013*M     db 0
0417E8 00 01       0014*M 	dw width * height ; length of data in bytes
0417EA 00 00 00 00 0015*M     incbin file ; bitmap data
       F6 E2 FA 00 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 E1 E5 00 
       EA 00 00 00 
       F5 00 00 00 
       00 00 00 E0 
       E1 F1 E6 D0 
       EA 00 FA F6 
       F5 F5 00 00 
       00 00 E0 E1 
       E1 E1 E2 E1 
       E2 FB FF F5 
       F1 E0 E0 00 
       EF F5 E0 E0 
       E2 E2 F6 EA 
       FB FB FF EA 
       E0 E5 00 00 
       DB EB F0 00 
       D4 E1 F6 FA 
       FB FB FF EE 
       EA E5 00 00 
       DF DB 00 E1 
       E1 E1 F5 F8 
       F5 F5 EA E5 
       D1 00 00 00 
       DB 00 F0 E5 
       E0 E5 FC FD 
       F8 E5 E6 E7 
       E2 EA EA EA 
       EB 00 E5 E5 
       E1 F9 FE FE 
       F8 F4 E5 E2 
       E1 D0 00 00 
       00 00 E0 E1 
       E2 F9 FD FD 
       F8 E4 E1 F6 
       F6 F6 E5 EA 
       00 E1 F2 E2 
       F5 F5 E5 E5 
       D4 E1 E1 E2 
       E1 E1 E1 E1 
       F3 F7 FB E3 
       E4 E1 D1 D0 
       D0 E1 E4 E2 
       E1 E1 E1 E1 
       00 00 FF 00 
       D2 D1 D1 D5 
       E5 E1 00 E1 
       E1 E0 E0 00 
       00 00 E6 EA 
       E6 D1 D0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 00 00 
       E2 C0 00 00 
       00 DB EA F5 
       00 00 00 00 
       00 00 00 00 
       F3 00 00 EB 
       DB DF DB DB 
       00 00 00 00 
0418EA             0016*M 
0418EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0418EA 17 1B 21    0018*M     db 23,27,0x21
0418ED 10 00       0019*M     dw width ; in pixels
0418EF 10 00       0020*M     dw height ; in pixels
0418F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0418F2             0094*  	LOADBMPBUFFER2 BUF_SEEKER_005,16,16,"src/rgba2/seeker_005.rgba2"
0418F2             0001*M 
0418F2             0002*M     ; Clear buffer
0418F2 17 00 A0    0003*M     db 23,0,0xA0
0418F5 19 01       0004*M     dw bufferId
0418F7 02          0005*M     db 2
0418F8             0006*M 
0418F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0418FB 19 01       0008*M     dw bufferId
0418FD             0009*M 
0418FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418FD 17 00 A0    0011*M     db 23,0,0xA0
041900 19 01       0012*M     dw bufferId
041902 00          0013*M     db 0
041903 00 01       0014*M 	dw width * height ; length of data in bytes
041905 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 E2 E6 
       FA 00 F5 00 
       00 00 00 00 
       00 00 00 00 
       E1 E1 E1 F6 
       C8 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E1 E2 
       D1 EA EA 00 
       00 00 00 00 
       FF EF F5 E0 
       E1 E2 E2 E1 
       E1 E2 00 FA 
       F5 F5 F5 00 
       DF DA EA 00 
       00 E2 E1 F6 
       EB FB FB FF 
       E0 F5 E0 00 
       DF DB DB 00 
       E1 E1 E1 FA 
       FB FB FF FF 
       E5 E1 00 00 
       DB 00 F0 E5 
       E0 E1 F4 F8 
       F9 F6 FA EA 
       EA E5 E6 E5 
       DB 00 E5 E5 
       E1 E9 FD FD 
       F8 F5 E5 E5 
       E1 00 00 00 
       00 E0 E0 E1 
       E2 F9 FE FE 
       F8 F4 E6 D7 
       E2 FA EA F5 
       F2 E2 E2 E2 
       F6 F9 FD FD 
       F8 E0 E5 E2 
       E1 00 00 00 
       F3 FB F7 E4 
       F5 E1 E1 E4 
       E4 E1 E1 F6 
       F7 E6 E5 EA 
       00 00 00 00 
       D1 D1 D0 D0 
       E0 E1 E2 E1 
       E1 E1 E1 E6 
       00 E6 EA E6 
       D1 D0 D5 E5 
       E0 00 00 E0 
       E1 E1 E1 E2 
       00 00 00 E6 
       D0 D0 FF F0 
       00 00 E0 E1 
       E0 E1 00 00 
       00 00 00 F2 
       D1 00 D6 E7 
       DB E6 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 DB DB DF 
       CB EA 00 00 
       00 00 00 00 
041A05             0016*M 
041A05             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041A05 17 1B 21    0018*M     db 23,27,0x21
041A08 10 00       0019*M     dw width ; in pixels
041A0A 10 00       0020*M     dw height ; in pixels
041A0C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041A0D             0095*  	LOADBMPBUFFER2 BUF_SEEKER_006,16,16,"src/rgba2/seeker_006.rgba2"
041A0D             0001*M 
041A0D             0002*M     ; Clear buffer
041A0D 17 00 A0    0003*M     db 23,0,0xA0
041A10 1A 01       0004*M     dw bufferId
041A12 02          0005*M     db 2
041A13             0006*M 
041A13 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041A16 1A 01       0008*M     dw bufferId
041A18             0009*M 
041A18             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041A18 17 00 A0    0011*M     db 23,0,0xA0
041A1B 1A 01       0012*M     dw bufferId
041A1D 00          0013*M     db 0
041A1E 00 01       0014*M 	dw width * height ; length of data in bytes
041A20 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 F5 E1 
       E2 FA FF 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       FF EF EB F5 
       E0 E1 E1 E1 
       E2 D1 EA EA 
       00 F5 00 00 
       DF DF DB FA 
       00 00 E2 F2 
       E1 E1 E6 00 
       FA 00 00 00 
       DB DF EB 00 
       00 D4 E1 E1 
       F6 E7 F6 FF 
       FA F5 F5 00 
       DB E7 F0 E5 
       E0 E1 E1 F6 
       FA FB FB FF 
       FA E0 F5 E0 
       00 00 00 E5 
       E1 E5 F8 F8 
       F9 FA FA FF 
       EA E0 E0 D0 
       E2 E1 E0 E1 
       E1 F9 FE FD 
       FC F5 F6 EA 
       EA E5 FA 00 
       F3 F7 E2 E2 
       F6 FD FE FE 
       F8 F4 E6 E6 
       E1 00 00 00 
       00 FF E3 E5 
       F5 F5 F9 FD 
       F4 E4 D6 E2 
       E2 EA EA 00 
       00 00 00 D0 
       E1 D1 E0 D4 
       E1 E1 F6 E1 
       E1 00 00 EA 
       00 00 E6 D1 
       D1 D0 D0 D0 
       E1 E1 E2 FB 
       F6 E5 FE 00 
       00 F3 E6 D0 
       D0 E5 E5 E0 
       E0 F3 E1 E1 
       E1 E1 EA FA 
       00 00 E2 D0 
       00 00 00 00 
       00 E1 E0 E0 
       E1 E1 E2 00 
       00 00 00 00 
       DB F1 DB DA 
       E5 E0 E1 E0 
       E1 00 00 00 
       00 00 00 00 
       DB DB DF DA 
       FA 00 00 00 
       00 00 00 00 
041B20             0016*M 
041B20             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041B20 17 1B 21    0018*M     db 23,27,0x21
041B23 10 00       0019*M     dw width ; in pixels
041B25 10 00       0020*M     dw height ; in pixels
041B27 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041B28             0096*  	LOADBMPBUFFER2 BUF_SEEKER_007,16,16,"src/rgba2/seeker_007.rgba2"
041B28             0001*M 
041B28             0002*M     ; Clear buffer
041B28 17 00 A0    0003*M     db 23,0,0xA0
041B2B 1B 01       0004*M     dw bufferId
041B2D 02          0005*M     db 2
041B2E             0006*M 
041B2E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041B31 1B 01       0008*M     dw bufferId
041B33             0009*M 
041B33             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041B33 17 00 A0    0011*M     db 23,0,0xA0
041B36 1B 01       0012*M     dw bufferId
041B38 00          0013*M     db 0
041B39 00 01       0014*M 	dw width * height ; length of data in bytes
041B3B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 E5 
       F5 E2 E6 FE 
       00 00 00 00 
       EF EF EF EF 
       F5 E0 E0 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       EB DB DF DB 
       FA E0 E1 E1 
       E1 E2 E9 00 
       00 00 00 00 
       EB DB 00 EB 
       00 00 00 E2 
       F6 E1 E1 EA 
       EA 00 00 00 
       00 DB 00 F0 
       E1 E0 E5 E1 
       F6 E6 E6 E2 
       00 FA 00 00 
       00 00 00 E5 
       E5 E0 E1 E5 
       FA EB FB FA 
       FA FA E0 F5 
       F2 E1 E0 E1 
       E1 E5 FD F8 
       F8 FA FB FF 
       FA E0 F5 F5 
       F7 FB E2 E2 
       F2 F9 FE FE 
       FC F5 FA FF 
       EE E1 E0 E0 
       00 FB E2 E5 
       F5 FD FD FD 
       F8 E5 E5 EA 
       EA E5 FF 00 
       E6 00 00 E1 
       E1 E5 F9 F8 
       F4 E5 D6 E2 
       E2 00 00 E5 
       00 EA D5 D1 
       D1 D0 D0 E4 
       E1 E5 E2 E1 
       E6 EA 00 00 
       00 E2 D1 D0 
       D0 E5 E0 E1 
       E1 E1 F6 E6 
       00 00 E6 00 
       00 F2 D0 00 
       FF E5 E1 E0 
       E2 E2 E1 F6 
       E5 00 00 00 
       00 00 00 D6 
       00 DB 00 00 
       00 E0 E1 E1 
       E1 FA EA 00 
       00 00 00 DB 
       DF DB EA E5 
       E0 E1 E0 E1 
       E1 E2 00 EA 
       00 C3 D7 DB 
       DF DB EA F4 
       E0 00 E0 00 
       00 00 00 00 
041C3B             0016*M 
041C3B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041C3B 17 1B 21    0018*M     db 23,27,0x21
041C3E 10 00       0019*M     dw width ; in pixels
041C40 10 00       0020*M     dw height ; in pixels
041C42 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041C43             0097*  	LOADBMPBUFFER2 BUF_SEEKER_008,16,16,"src/rgba2/seeker_008.rgba2"
041C43             0001*M 
041C43             0002*M     ; Clear buffer
041C43 17 00 A0    0003*M     db 23,0,0xA0
041C46 1C 01       0004*M     dw bufferId
041C48 02          0005*M     db 2
041C49             0006*M 
041C49 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041C4C 1C 01       0008*M     dw bufferId
041C4E             0009*M 
041C4E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041C4E 17 00 A0    0011*M     db 23,0,0xA0
041C51 1C 01       0012*M     dw bufferId
041C53 00          0013*M     db 0
041C54 00 01       0014*M 	dw width * height ; length of data in bytes
041C56 00 00 EF 00 0015*M     incbin file ; bitmap data
       EF 00 00 00 
       00 F5 F6 F6 
       00 00 00 00 
       C3 EB DB DF 
       DB FA E1 E1 
       E1 E1 E1 E2 
       FA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 E2 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       F3 E2 E1 E1 
       E1 E1 E1 E1 
       F6 EA EB F6 
       00 00 00 00 
       00 FB E2 E2 
       E2 F5 FD FC 
       F8 FA FB FB 
       FF FA 00 00 
       00 00 00 F5 
       F5 FD FE FE 
       FC F5 FA FF 
       FF F5 F5 F5 
       00 00 00 E1 
       F5 F9 FD FD 
       F8 F5 F6 EB 
       EE E1 E1 E1 
       00 E6 D1 D1 
       D1 E1 F9 F8 
       F4 E5 E6 E5 
       EA E5 00 00 
       F3 D1 D0 D0 
       D0 D0 D0 E1 
       E1 D5 D7 E2 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 F7 00 
       00 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       C3 D7 DB DF 
       DB EA E1 E1 
       E1 E1 E1 E1 
       EA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       00 E1 E1 E2 
       00 00 00 00 
041D56             0016*M 
041D56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041D56 17 1B 21    0018*M     db 23,27,0x21
041D59 10 00       0019*M     dw width ; in pixels
041D5B 10 00       0020*M     dw height ; in pixels
041D5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041D5E             0098*  	LOADBMPBUFFER2 BUF_SEEKER_009,16,16,"src/rgba2/seeker_009.rgba2"
041D5E             0001*M 
041D5E             0002*M     ; Clear buffer
041D5E 17 00 A0    0003*M     db 23,0,0xA0
041D61 1D 01       0004*M     dw bufferId
041D63 02          0005*M     db 2
041D64             0006*M 
041D64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041D67 1D 01       0008*M     dw bufferId
041D69             0009*M 
041D69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D69 17 00 A0    0011*M     db 23,0,0xA0
041D6C 1D 01       0012*M     dw bufferId
041D6E 00          0013*M     db 0
041D6F 00 01       0014*M 	dw width * height ; length of data in bytes
041D71 00 C3 E7 DB 0015*M     incbin file ; bitmap data
       DF DF EB F5 
       D0 00 F5 00 
       00 00 00 00 
       00 00 00 DB 
       DF DB EB E5 
       E0 E0 E4 E1 
       F2 E6 00 FA 
       00 00 00 D6 
       00 DB 00 00 
       00 E1 E1 E1 
       E1 FA FA 00 
       00 F2 E1 00 
       FF E5 E1 E0 
       E2 E2 E1 E2 
       E5 00 00 00 
       00 F3 E2 E0 
       E4 E5 E0 E1 
       E1 E1 F1 E1 
       00 00 EA 00 
       00 FF E7 E2 
       E2 E1 E5 E1 
       E5 F6 E6 E2 
       E6 EA 00 00 
       E6 00 00 E1 
       F6 F5 FD FD 
       F8 FA EB FB 
       F6 00 00 FA 
       00 E6 D1 E1 
       F5 FD FE FE 
       FC F9 FB FB 
       FF FA FF 00 
       E2 E6 D1 D1 
       E1 E5 FD FD 
       F8 F5 FA FF 
       FF F5 F5 F5 
       E2 C0 D0 D0 
       D0 D0 E4 F4 
       F4 E5 E6 EA 
       EA E0 E5 F5 
       00 00 00 E5 
       E5 D0 D1 E1 
       E5 D6 E6 E5 
       E5 E5 D0 E0 
       00 DB 00 F0 
       E1 E0 E1 E1 
       E5 E2 E2 E2 
       00 E5 00 00 
       D7 DB 00 EB 
       00 00 00 E2 
       F2 F6 E1 EA 
       EA 00 00 00 
       DB DB DF DB 
       F5 E0 E0 E1 
       E1 F6 E9 00 
       00 00 00 00 
       DB EB DB DB 
       F5 E0 E1 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E6 EA 
       00 00 00 00 
041E71             0016*M 
041E71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041E71 17 1B 21    0018*M     db 23,27,0x21
041E74 10 00       0019*M     dw width ; in pixels
041E76 10 00       0020*M     dw height ; in pixels
041E78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041E79             0099*  	LOADBMPBUFFER2 BUF_SEEKER_010,16,16,"src/rgba2/seeker_010.rgba2"
041E79             0001*M 
041E79             0002*M     ; Clear buffer
041E79 17 00 A0    0003*M     db 23,0,0xA0
041E7C 1E 01       0004*M     dw bufferId
041E7E 02          0005*M     db 2
041E7F             0006*M 
041E7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041E82 1E 01       0008*M     dw bufferId
041E84             0009*M 
041E84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E84 17 00 A0    0011*M     db 23,0,0xA0
041E87 1E 01       0012*M     dw bufferId
041E89 00          0013*M     db 0
041E8A 00 01       0014*M 	dw width * height ; length of data in bytes
041E8C 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB F1 DB EB 
       F5 E0 E0 E1 
       F5 00 00 00 
       00 00 F2 E1 
       00 00 00 00 
       00 E0 E1 E0 
       E1 E2 F6 00 
       00 F2 F7 E1 
       E0 E5 E5 E0 
       E4 F3 E2 E1 
       E1 E1 FA FE 
       00 00 FB E2 
       E2 E1 E1 E0 
       E1 E1 E2 E2 
       E6 E5 FF 00 
       00 00 00 E1 
       F2 E2 E5 E5 
       E1 E5 F6 E1 
       E1 00 00 FA 
       00 E6 D2 E0 
       F5 F9 FE FD 
       F8 F9 EB E7 
       E2 EA FA 00 
       E2 E5 D1 D1 
       E1 F9 FE FE 
       FC F9 FB FB 
       F6 00 00 00 
       D1 D0 D0 D0 
       D1 E5 FD FD 
       F8 F5 FA FF 
       FF FA FF 00 
       00 00 00 E5 
       D0 D0 E4 F4 
       F4 E5 FA FF 
       FA F5 F1 E1 
       EB E7 F0 E5 
       E0 E1 E1 E1 
       E5 E6 E5 EA 
       E5 E0 F5 F5 
       DB DF EB 00 
       00 E4 E1 E5 
       E6 E2 E2 D5 
       E5 E1 E0 00 
       DB DF DB EA 
       00 00 E2 E2 
       F6 E1 E6 00 
       E5 00 00 00 
       E7 DB DA E5 
       E0 E0 E1 E1 
       F6 F7 EA EA 
       00 D0 00 00 
       00 00 00 00 
       E0 E1 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 E1 E1 
       E1 EA FA 00 
       00 00 00 00 
041F8C             0016*M 
041F8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041F8C 17 1B 21    0018*M     db 23,27,0x21
041F8F 10 00       0019*M     dw width ; in pixels
041F91 10 00       0020*M     dw height ; in pixels
041F93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041F94             0100*  	LOADBMPBUFFER2 BUF_SEEKER_011,16,16,"src/rgba2/seeker_011.rgba2"
041F94             0001*M 
041F94             0002*M     ; Clear buffer
041F94 17 00 A0    0003*M     db 23,0,0xA0
041F97 1F 01       0004*M     dw bufferId
041F99 02          0005*M     db 2
041F9A             0006*M 
041F9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041F9D 1F 01       0008*M     dw bufferId
041F9F             0009*M 
041F9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F9F 17 00 A0    0011*M     db 23,0,0xA0
041FA2 1F 01       0012*M     dw bufferId
041FA4 00          0013*M     db 0
041FA5 00 01       0014*M 	dw width * height ; length of data in bytes
041FA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 C6 DB DF 
       CB EB 00 00 
       00 00 00 00 
       00 00 00 F3 
       E2 00 D6 E7 
       DB FA E1 E0 
       00 00 00 00 
       00 00 00 F7 
       E1 E0 FF F0 
       00 00 E0 E1 
       E0 F5 00 00 
       00 F7 FF FB 
       E2 E1 E5 E5 
       E0 00 00 E1 
       E1 E1 F6 F7 
       00 00 00 00 
       E2 E2 E1 E0 
       E1 E1 E2 E2 
       E1 E1 E2 FA 
       F3 E6 E6 E0 
       F5 F6 F5 F9 
       E1 E1 E1 F1 
       E2 E5 E5 FF 
       E2 D1 D1 D1 
       E1 F9 FD FE 
       FC F9 E6 E6 
       E1 00 00 00 
       00 D0 D0 D1 
       D1 E5 FD FE 
       FC F9 FB EB 
       E2 FA EA F5 
       DB 00 E5 E5 
       D0 E4 FD F8 
       F8 F5 FB FB 
       F6 00 00 00 
       DB 00 F0 E5 
       E0 D0 E4 F4 
       E5 F5 FA FF 
       FF FA FF FA 
       DF DB DB 00 
       E1 E1 E1 E5 
       E6 E6 EA FF 
       F5 F5 00 00 
       DF DA EA 00 
       00 E2 E1 F6 
       D6 E2 E5 EA 
       E0 F5 F5 00 
       EB DB E5 E0 
       E0 E1 E1 F6 
       E1 E2 00 E5 
       E5 E0 F5 00 
       00 00 00 E0 
       E1 E1 E1 F6 
       D1 EA FE 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E1 F5 
       C4 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E5 
       EA 00 F5 00 
       00 00 00 00 
0420A7             0016*M 
0420A7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0420A7 17 1B 21    0018*M     db 23,27,0x21
0420AA 10 00       0019*M     dw width ; in pixels
0420AC 10 00       0020*M     dw height ; in pixels
0420AE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0420AF             0101*  	LOADBMPBUFFER2 BUF_SEEKER_012,16,16,"src/rgba2/seeker_012.rgba2"
0420AF             0001*M 
0420AF             0002*M     ; Clear buffer
0420AF 17 00 A0    0003*M     db 23,0,0xA0
0420B2 20 01       0004*M     dw bufferId
0420B4 02          0005*M     db 2
0420B5             0006*M 
0420B5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0420B8 20 01       0008*M     dw bufferId
0420BA             0009*M 
0420BA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420BA 17 00 A0    0011*M     db 23,0,0xA0
0420BD 20 01       0012*M     dw bufferId
0420BF 00          0013*M     db 0
0420C0 00 01       0014*M 	dw width * height ; length of data in bytes
0420C2 00 00 00 00 0015*M     incbin file ; bitmap data
       F3 00 00 EB 
       DB DF DB EF 
       00 00 00 00 
       00 00 00 00 
       F7 E1 00 00 
       00 DB EB F5 
       00 00 00 00 
       00 00 E6 FF 
       FB F2 E0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 EA 00 
       E3 E2 E1 E5 
       E5 E1 00 E0 
       E1 E0 F5 00 
       F3 E2 E6 D2 
       E4 F5 E2 E1 
       E0 E1 D4 E2 
       E1 E1 E1 F6 
       00 C0 D1 D1 
       E1 F5 F9 F9 
       E5 E1 E1 E2 
       E1 F1 E1 E2 
       00 00 D0 D1 
       D1 E5 FD FE 
       FC F5 F6 F6 
       E2 E6 E5 FA 
       EB 00 E5 D5 
       D0 E5 FD FE 
       FD F8 FA EA 
       E1 D0 00 00 
       DB 00 F0 E5 
       D0 D4 F8 F8 
       F8 F5 FB FB 
       E2 EA EA FA 
       DF DB 00 E1 
       E1 E1 E4 F4 
       E5 F5 FB FB 
       FB 00 00 00 
       DB EA F0 00 
       E4 E1 E1 E5 
       E6 EA FF FF 
       FF FA 00 00 
       DB F5 E0 E1 
       E2 E2 F6 E2 
       E7 E5 EE EA 
       F5 F6 00 00 
       00 00 E0 E1 
       E1 E1 F6 E1 
       E2 D1 EA E0 
       F1 F5 F5 00 
       00 00 00 E0 
       E1 E1 F6 D0 
       EA 00 E5 E5 
       E0 F5 00 00 
       00 00 00 E0 
       E1 E1 E5 00 
       EA 00 00 00 
       E0 00 00 00 
       00 00 00 00 
       E1 E1 EA 00 
       EA 00 00 00 
       00 00 00 00 
0421C2             0016*M 
0421C2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0421C2 17 1B 21    0018*M     db 23,27,0x21
0421C5 10 00       0019*M     dw width ; in pixels
0421C7 10 00       0020*M     dw height ; in pixels
0421C9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0421CA             0102*  	LOADBMPBUFFER2 BUF_SEEKER_013,16,16,"src/rgba2/seeker_013.rgba2"
0421CA             0001*M 
0421CA             0002*M     ; Clear buffer
0421CA 17 00 A0    0003*M     db 23,0,0xA0
0421CD 21 01       0004*M     dw bufferId
0421CF 02          0005*M     db 2
0421D0             0006*M 
0421D0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0421D3 21 01       0008*M     dw bufferId
0421D5             0009*M 
0421D5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0421D5 17 00 A0    0011*M     db 23,0,0xA0
0421D8 21 01       0012*M     dw bufferId
0421DA 00          0013*M     db 0
0421DB 00 01       0014*M 	dw width * height ; length of data in bytes
0421DD 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F3 F2 00 
       DB DB DF DF 
       FF 00 00 00 
       00 00 00 E6 
       00 FB E2 E0 
       00 00 DB DA 
       EF 00 00 00 
       00 00 00 EA 
       00 F7 E2 E0 
       E5 F0 DB EA 
       F5 00 00 00 
       00 F2 E6 E6 
       00 E4 E2 E1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 D1 D0 D1 
       D1 F5 F6 E2 
       E1 E0 E1 00 
       E1 E1 E1 00 
       DB 00 D0 D0 
       D1 E1 F9 F9 
       E9 E1 E1 E2 
       E2 E1 E1 F5 
       DB D6 FF D5 
       D0 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E2 
       DF E7 F0 E5 
       D0 E4 FD FE 
       FD F8 FA F6 
       E1 E2 F6 E6 
       CB DB 00 E0 
       E0 E4 F8 F8 
       F8 F9 FB EB 
       E1 D1 C8 FA 
       EA E6 00 00 
       E1 E1 E0 F4 
       F5 F6 FB FB 
       E2 EA 00 00 
       00 E1 E0 00 
       E2 E1 E5 E6 
       E5 FA FF FB 
       00 EA 00 F5 
       00 E0 E1 E0 
       E1 F6 E2 D7 
       E5 EA FF FF 
       FA 00 00 00 
       00 00 E0 E1 
       E1 F7 E1 E2 
       E1 EA E5 E0 
       F5 00 00 00 
       00 00 E1 E1 
       E1 E6 00 FA 
       00 E5 E1 F5 
       F5 00 00 00 
       00 00 00 E1 
       E1 E5 00 EA 
       00 E6 00 E0 
       F5 00 00 00 
       00 00 00 E2 
       E6 EA 00 F5 
       00 E5 00 00 
       00 00 00 00 
0422DD             0016*M 
0422DD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0422DD 17 1B 21    0018*M     db 23,27,0x21
0422E0 10 00       0019*M     dw width ; in pixels
0422E2 10 00       0020*M     dw height ; in pixels
0422E4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0422E5             0103*  	LOADBMPBUFFER2 BUF_SEEKER_014,16,16,"src/rgba2/seeker_014.rgba2"
0422E5             0001*M 
0422E5             0002*M     ; Clear buffer
0422E5 17 00 A0    0003*M     db 23,0,0xA0
0422E8 22 01       0004*M     dw bufferId
0422EA 02          0005*M     db 2
0422EB             0006*M 
0422EB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0422EE 22 01       0008*M     dw bufferId
0422F0             0009*M 
0422F0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0422F0 17 00 A0    0011*M     db 23,0,0xA0
0422F3 22 01       0012*M     dw bufferId
0422F5 00          0013*M     db 0
0422F6 00 01       0014*M 	dw width * height ; length of data in bytes
0422F8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F3 
       E2 00 DB DB 
       DF FF 00 00 
       00 00 00 F3 
       00 00 FF F7 
       E1 00 E7 DF 
       DF EF 00 00 
       00 00 E2 E6 
       E6 00 E3 E2 
       E0 00 F0 EB 
       DB EB 00 00 
       00 00 D0 D0 
       D1 D0 E5 E2 
       E1 E5 E5 00 
       FA F5 00 00 
       DB DB 00 D0 
       D1 E1 F5 F6 
       E1 E1 E0 00 
       00 E0 E0 00 
       DB F1 00 E5 
       D0 D1 F5 FD 
       F9 E5 E1 D4 
       00 E1 E0 00 
       DF DB 00 E5 
       D0 E0 F9 FE 
       FE F8 E1 E1 
       E2 E1 E0 F5 
       DA DA 00 E0 
       D0 D4 FD FE 
       FD F8 F6 E1 
       F2 E1 E1 E1 
       FA E5 00 E0 
       E1 E1 F4 F8 
       FC F9 FA F6 
       E1 E2 E5 E2 
       00 E0 E1 F3 
       E1 E1 E4 F4 
       F5 FA FB E7 
       E1 D1 E5 FA 
       00 E1 E0 E1 
       E2 F6 D6 E6 
       F6 FA FB F6 
       E6 EA 00 FF 
       00 E0 E0 E1 
       FB E1 E2 E6 
       EA FF FF FF 
       00 EA E5 00 
       00 E1 E1 E1 
       F6 E1 E2 E1 
       EA EA FA FA 
       FA 00 00 00 
       00 00 E1 E1 
       E5 00 EA 00 
       E5 E0 E0 F5 
       00 F5 00 00 
       00 00 E2 EA 
       FE 00 EA 00 
       FA E0 F5 F5 
       00 00 00 00 
       00 00 00 FA 
       00 EA 00 00 
       00 D0 E0 00 
       00 00 00 00 
0423F8             0016*M 
0423F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0423F8 17 1B 21    0018*M     db 23,27,0x21
0423FB 10 00       0019*M     dw width ; in pixels
0423FD 10 00       0020*M     dw height ; in pixels
0423FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042400             0104*  	LOADBMPBUFFER2 BUF_SEEKER_015,16,16,"src/rgba2/seeker_015.rgba2"
042400             0001*M 
042400             0002*M     ; Clear buffer
042400 17 00 A0    0003*M     db 23,0,0xA0
042403 23 01       0004*M     dw bufferId
042405 02          0005*M     db 2
042406             0006*M 
042406 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042409 23 01       0008*M     dw bufferId
04240B             0009*M 
04240B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04240B 17 00 A0    0011*M     db 23,0,0xA0
04240E 23 01       0012*M     dw bufferId
042410 00          0013*M     db 0
042411 00 01       0014*M 	dw width * height ; length of data in bytes
042413 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E6 00 
       F7 F2 00 00 
       EB EB EF 00 
       C3 00 00 F2 
       E2 EA 00 FB 
       FB E1 00 DB 
       DB DB EF 00 
       D7 00 00 D0 
       D1 D5 00 E2 
       E2 E0 00 00 
       00 DF EF 00 
       DB DB D6 00 
       D0 D1 E1 E5 
       E2 E1 E5 F0 
       EB DB EF 00 
       DF DF 00 FF 
       D0 D1 E1 F5 
       F2 E1 E5 E1 
       00 FA F5 00 
       DB DB DB E5 
       E5 D0 E5 FD 
       F9 E5 E0 E0 
       00 E0 E0 00 
       EA EA 00 E1 
       E0 D0 F9 FD 
       FE FD E1 E5 
       00 E1 E0 00 
       F4 E5 00 E0 
       E1 E4 F8 FD 
       FE F8 E5 E1 
       E2 E1 E1 E5 
       E0 E0 00 E2 
       E1 E1 F4 F8 
       FC F8 FA F6 
       F6 E1 E1 F5 
       00 E1 E0 E2 
       E1 E5 E5 E5 
       F5 FA EB E6 
       E1 E2 E1 E2 
       E0 E0 E1 E1 
       F6 E2 D6 E5 
       FA FB FB E6 
       E1 E9 E5 E6 
       00 E1 E1 F6 
       E6 E1 E2 EA 
       FF FF FA E2 
       EA 00 FF FE 
       00 E1 E1 E5 
       00 E6 E2 EA 
       EE FA FA 00 
       EA 00 00 00 
       00 E2 FA 00 
       00 EA 00 E5 
       E1 E0 FA FA 
       00 00 00 00 
       00 00 EA 00 
       E6 00 00 FF 
       E0 F5 E0 00 
       00 00 00 00 
       00 EA 00 00 
       00 00 E5 00 
       E0 F5 F5 00 
       00 00 00 00 
042513             0016*M 
042513             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042513 17 1B 21    0018*M     db 23,27,0x21
042516 10 00       0019*M     dw width ; in pixels
042518 10 00       0020*M     dw height ; in pixels
04251A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04251B             0105*  	LOADBMPBUFFER2 BUF_SEEKER_016,16,16,"src/rgba2/seeker_016.rgba2"
04251B             0001*M 
04251B             0002*M     ; Clear buffer
04251B 17 00 A0    0003*M     db 23,0,0xA0
04251E 24 01       0004*M     dw bufferId
042520 02          0005*M     db 2
042521             0006*M 
042521 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042524 24 01       0008*M     dw bufferId
042526             0009*M 
042526             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042526 17 00 A0    0011*M     db 23,0,0xA0
042529 24 01       0012*M     dw bufferId
04252B 00          0013*M     db 0
04252C 00 01       0014*M 	dw width * height ; length of data in bytes
04252E 00 C3 00 00 0015*M     incbin file ; bitmap data
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
       00 D7 00 00 
       00 D1 E6 00 
       00 FB E2 00 
       00 00 EB 00 
       DB DB DB 00 
       00 D0 D1 00 
       00 E2 E1 00 
       00 DB DB EF 
       00 DF 00 00 
       00 D0 D1 E1 
       F5 E2 E1 00 
       00 00 DF 00 
       DB DB DB 00 
       E5 D0 D1 F5 
       F5 E2 E1 E5 
       00 DB DB EF 
       00 EA 00 00 
       E1 D0 E1 F9 
       FD F5 E1 E1 
       00 00 FA 00 
       00 E1 00 00 
       E1 D0 F9 FD 
       FE FD E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 F8 FD 
       FE FC E1 E1 
       00 00 E1 00 
       00 E1 E1 E2 
       E1 E1 F4 F8 
       FC F8 F6 E1 
       E2 E1 E1 00 
       E1 E1 E1 00 
       F6 D5 E5 F5 
       F5 FA EA F6 
       00 E1 E1 F5 
       E1 E1 F6 F7 
       E1 D7 E6 F6 
       FA FB EB E1 
       E2 F6 E1 F6 
       E2 E1 E5 00 
       E1 E2 E5 EB 
       FF FB F6 E1 
       00 E5 E2 F6 
       00 EA 00 00 
       EA 00 EA EE 
       FF FF 00 EA 
       00 00 FA 00 
       00 00 00 00 
       00 00 E5 E1 
       F5 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
04262E             0016*M 
04262E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04262E 17 1B 21    0018*M     db 23,27,0x21
042631 10 00       0019*M     dw width ; in pixels
042633 10 00       0020*M     dw height ; in pixels
042635 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042636             0106*  	LOADBMPBUFFER2 BUF_SEEKER_017,16,16,"src/rgba2/seeker_017.rgba2"
042636             0001*M 
042636             0002*M     ; Clear buffer
042636 17 00 A0    0003*M     db 23,0,0xA0
042639 25 01       0004*M     dw bufferId
04263B 02          0005*M     db 2
04263C             0006*M 
04263C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04263F 25 01       0008*M     dw bufferId
042641             0009*M 
042641             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042641 17 00 A0    0011*M     db 23,0,0xA0
042644 25 01       0012*M     dw bufferId
042646 00          0013*M     db 0
042647 00 01       0014*M 	dw width * height ; length of data in bytes
042649 00 DB DB D7 0015*M     incbin file ; bitmap data
       00 00 E2 E2 
       00 E6 00 00 
       00 00 00 00 
       00 EB DB DB 
       DB 00 C0 E6 
       E6 00 FF F3 
       F2 00 00 C3 
       00 DB DF 00 
       00 00 D0 D1 
       D1 00 E7 E2 
       E1 00 00 E7 
       00 DB DB EB 
       F0 E5 D0 D1 
       E1 E1 E2 E0 
       00 D6 DB DB 
       00 F5 F5 00 
       E1 E5 D0 E1 
       F5 F6 E2 E4 
       FF 00 DF DF 
       00 E0 E0 00 
       E0 D0 D0 E5 
       FD F5 E1 E5 
       E5 DB DB DF 
       00 E1 E0 00 
       E1 D1 E4 FD 
       FE FD E5 E0 
       E1 00 EB EB 
       E0 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 E1 
       E0 00 E5 F5 
       E1 E1 E1 F2 
       E5 E5 F4 F8 
       FC F8 E5 E1 
       E2 00 E0 D0 
       E1 E1 F6 F6 
       E2 D6 E5 F5 
       F9 FA F6 E1 
       E2 E1 E0 00 
       E6 E5 E9 E1 
       E2 E6 E6 FA 
       FB EB E6 F1 
       E1 E1 E4 F5 
       EA FF 00 EA 
       E2 E5 EA FF 
       FB FB E2 E1 
       E2 E1 E1 00 
       00 00 00 EA 
       00 E5 EA FF 
       FF F6 E6 00 
       E5 E1 F2 00 
       00 00 00 00 
       E5 E5 E0 F5 
       FA 00 EA 00 
       00 FA E6 00 
       00 00 00 00 
       00 D0 E5 F5 
       FF 00 00 EA 
       00 FA 00 00 
       00 00 00 00 
       00 E0 F5 F5 
       00 FA 00 00 
       00 00 FA 00 
042749             0016*M 
042749             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042749 17 1B 21    0018*M     db 23,27,0x21
04274C 10 00       0019*M     dw width ; in pixels
04274E 10 00       0020*M     dw height ; in pixels
042750 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042751             0107*  	LOADBMPBUFFER2 BUF_SEEKER_018,16,16,"src/rgba2/seeker_018.rgba2"
042751             0001*M 
042751             0002*M     ; Clear buffer
042751 17 00 A0    0003*M     db 23,0,0xA0
042754 26 01       0004*M     dw bufferId
042756 02          0005*M     db 2
042757             0006*M 
042757 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04275A 26 01       0008*M     dw bufferId
04275C             0009*M 
04275C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04275C 17 00 A0    0011*M     db 23,0,0xA0
04275F 26 01       0012*M     dw bufferId
042761 00          0013*M     db 0
042762 00 01       0014*M 	dw width * height ; length of data in bytes
042764 00 00 E7 DB 0015*M     incbin file ; bitmap data
       DB EB 00 D1 
       E2 00 00 00 
       00 00 00 00 
       00 00 DB DF 
       DF E7 00 D0 
       E5 E6 00 00 
       F2 00 00 00 
       00 00 DA DB 
       EB F0 00 D0 
       D1 D2 00 FB 
       F7 F2 00 00 
       00 00 E5 EA 
       00 E5 E5 D0 
       D1 E0 E1 E2 
       E1 E1 00 00 
       00 E0 E0 00 
       00 E0 D0 D1 
       E1 F5 F2 E2 
       E0 00 DB DB 
       00 E1 E0 00 
       E4 E1 D0 E5 
       F9 F9 E2 E1 
       E5 00 F1 DB 
       E1 E0 E1 E2 
       E1 E1 E4 FD 
       FE FE E5 E1 
       E5 00 DB DF 
       E1 E1 E1 E2 
       E5 E1 F4 FD 
       FE FD E5 E0 
       E0 00 EB DB 
       E1 E5 F6 F6 
       E6 E5 F4 F8 
       FC F8 E1 E1 
       E4 00 F5 FA 
       EA E5 F7 E1 
       E2 E6 E5 F5 
       F9 F9 E5 E1 
       F3 E0 E0 00 
       FA 00 EA E6 
       E2 E5 FA FA 
       FB EB F6 E2 
       E2 E1 E0 00 
       00 E5 EA 00 
       D5 EA FF FF 
       FB E7 E1 E2 
       E1 E0 E1 00 
       00 00 00 E5 
       E5 E5 FA FF 
       F6 E2 E1 E6 
       E1 E1 F5 00 
       00 00 D0 00 
       E1 E0 F5 FA 
       00 EA 00 E5 
       E1 E2 00 00 
       00 00 00 00 
       E0 F5 F1 FF 
       00 FA 00 FF 
       FA F6 00 00 
       00 00 00 00 
       00 F5 E1 00 
       00 00 FA 00 
       FE 00 00 00 
042864             0016*M 
042864             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042864 17 1B 21    0018*M     db 23,27,0x21
042867 10 00       0019*M     dw width ; in pixels
042869 10 00       0020*M     dw height ; in pixels
04286B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04286C             0108*  	LOADBMPBUFFER2 BUF_SEEKER_019,16,16,"src/rgba2/seeker_019.rgba2"
04286C             0001*M 
04286C             0002*M     ; Clear buffer
04286C 17 00 A0    0003*M     db 23,0,0xA0
04286F 27 01       0004*M     dw bufferId
042871 02          0005*M     db 2
042872             0006*M 
042872 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042875 27 01       0008*M     dw bufferId
042877             0009*M 
042877             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042877 17 00 A0    0011*M     db 23,0,0xA0
04287A 27 01       0012*M     dw bufferId
04287C 00          0013*M     db 0
04287D 00 01       0014*M 	dw width * height ; length of data in bytes
04287F 00 00 00 EB 0015*M     incbin file ; bitmap data
       DF DF DB DB 
       00 E2 F3 00 
       00 00 00 00 
       00 00 00 DB 
       DA DB 00 00 
       D0 D1 E6 00 
       F7 00 00 00 
       00 00 00 E5 
       EA DB F0 E5 
       D0 D1 E6 00 
       FF 00 00 00 
       00 00 E0 E0 
       00 00 E5 E5 
       D1 D1 E0 00 
       FB F7 F3 00 
       00 E0 E1 E0 
       00 E1 E0 D0 
       D1 E1 F5 E2 
       E2 E1 E2 00 
       E1 E0 E1 E1 
       E2 E1 D0 E4 
       E5 F9 F6 E2 
       E1 E0 00 C6 
       E1 E1 E1 E1 
       E1 E1 E4 FD 
       FD FD F5 E1 
       E5 FF D6 DB 
       E5 F5 F6 F6 
       F6 E5 F4 F8 
       FE FE F9 E0 
       E5 F0 E7 DF 
       EA C4 D1 E1 
       D6 E6 E5 F8 
       FC FC E1 E1 
       E0 00 DB CB 
       00 00 EA E2 
       E2 E6 F5 F5 
       F9 F9 E1 E1 
       00 00 FA EB 
       F5 00 FE 00 
       E5 EA FA FB 
       FB E6 E1 E2 
       00 E0 E1 00 
       00 00 00 E5 
       EA FF FF FB 
       EB E6 F1 E2 
       E1 E1 E0 00 
       00 00 00 E5 
       E0 F5 FF F6 
       E2 E1 E2 E1 
       E1 E0 00 00 
       00 00 00 E0 
       F5 F5 FA 00 
       FA 00 E5 E1 
       E1 F5 00 00 
       00 00 00 F5 
       F5 00 FF 00 
       EA 00 E5 E2 
       F6 00 00 00 
       00 00 00 00 
       00 00 FA 00 
       F5 00 FF FA 
       F7 00 00 00 
04297F             0016*M 
04297F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04297F 17 1B 21    0018*M     db 23,27,0x21
042982 10 00       0019*M     dw width ; in pixels
042984 10 00       0020*M     dw height ; in pixels
042986 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042987             0109*  	LOADBMPBUFFER2 BUF_SEEKER_020,16,16,"src/rgba2/seeker_020.rgba2"
042987             0001*M 
042987             0002*M     ; Clear buffer
042987 17 00 A0    0003*M     db 23,0,0xA0
04298A 28 01       0004*M     dw bufferId
04298C 02          0005*M     db 2
04298D             0006*M 
04298D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042990 28 01       0008*M     dw bufferId
042992             0009*M 
042992             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042992 17 00 A0    0011*M     db 23,0,0xA0
042995 28 01       0012*M     dw bufferId
042997 00          0013*M     db 0
042998 00 01       0014*M 	dw width * height ; length of data in bytes
04299A 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
       00 00 00 00 
       F5 EA DB 00 
       00 00 C0 E2 
       00 00 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 D0 D1 E6 
       EA E6 00 00 
       00 E0 E0 E1 
       E1 00 E1 E5 
       D5 D1 D1 D2 
       00 FF 00 00 
       E1 E1 E1 E1 
       E2 E4 E1 D0 
       D0 D1 E1 E4 
       E3 FB F7 F3 
       E1 E1 E1 E1 
       E2 E1 E1 D4 
       E5 E5 F5 F5 
       E2 F2 E1 00 
       EA E5 F6 F6 
       F6 E1 E4 F8 
       FD FD F9 E2 
       E1 E0 00 00 
       00 00 D0 E1 
       E2 E5 F4 F8 
       FE FE F9 E1 
       E5 E5 00 EB 
       EA EA EA E2 
       E7 E6 E5 F8 
       FD FC E5 E0 
       E5 F0 00 DB 
       00 00 00 D1 
       E5 EA F5 F5 
       F8 F5 E1 E1 
       E1 00 DB DF 
       00 00 E5 EA 
       EE FF FB FB 
       FA F6 E1 D4 
       00 F0 EB DB 
       00 00 E5 E0 
       EA FF FB FB 
       EA F6 E2 E2 
       E0 E0 F5 EF 
       00 E0 E0 F1 
       F5 FF FB E2 
       E1 E2 E1 E1 
       E1 E0 00 00 
       00 00 F5 F5 
       F6 FA 00 EA 
       D0 E6 F1 E1 
       E0 00 00 00 
       00 00 00 F5 
       00 00 00 EA 
       00 E5 E1 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       00 FA E2 F6 
       00 00 00 00 
042A9A             0016*M 
042A9A             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042A9A 17 1B 21    0018*M     db 23,27,0x21
042A9D 10 00       0019*M     dw width ; in pixels
042A9F 10 00       0020*M     dw height ; in pixels
042AA1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042AA2             0110*  	LOADBMPBUFFER2 BUF_SEEKER_021,16,16,"src/rgba2/seeker_021.rgba2"
042AA2             0001*M 
042AA2             0002*M     ; Clear buffer
042AA2 17 00 A0    0003*M     db 23,0,0xA0
042AA5 29 01       0004*M     dw bufferId
042AA7 02          0005*M     db 2
042AA8             0006*M 
042AA8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042AAB 29 01       0008*M     dw bufferId
042AAD             0009*M 
042AAD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042AAD 17 00 A0    0011*M     db 23,0,0xA0
042AB0 29 01       0012*M     dw bufferId
042AB2 00          0013*M     db 0
042AB3 00 01       0014*M 	dw width * height ; length of data in bytes
042AB5 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 EA CB 
       DF DB DB 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E6 DB 
       E7 D6 00 D1 
       F2 00 00 00 
       00 00 E1 E0 
       E1 E0 00 00 
       F0 FF D0 D0 
       E6 00 00 00 
       E2 E1 E1 E1 
       E0 00 00 E0 
       E5 D5 D0 D1 
       E6 EA E6 00 
       E6 E1 E1 E1 
       E1 E2 E1 E0 
       D0 D0 D1 D1 
       00 00 00 00 
       EA E5 E6 F7 
       F6 E1 E1 E4 
       E4 E1 E1 F5 
       E4 F7 FB F3 
       00 00 00 E1 
       E2 E5 E0 F8 
       FD FD F9 F6 
       E2 E2 E2 F2 
       F5 EA FA E2 
       D7 E6 F4 F8 
       FE FE F9 E2 
       E1 E0 E0 00 
       00 00 00 E1 
       E5 E5 F5 F8 
       FD FD E9 E1 
       E5 E5 00 DB 
       E5 E6 E5 EA 
       EA FA F6 F9 
       F8 F4 E1 E0 
       E5 F0 00 DB 
       00 00 E1 E5 
       FF FF FB FB 
       FA E1 E1 E1 
       00 DB DB DF 
       00 E0 F5 E0 
       FF FB FB EB 
       F6 E1 E2 00 
       00 EA DA DF 
       00 F5 F5 F5 
       FA 00 E2 E1 
       E1 E2 E2 E1 
       E0 F5 EF FF 
       00 00 00 00 
       00 EA EA D1 
       E2 E1 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 C8 
       F6 E1 E1 E1 
       00 00 00 00 
       00 00 00 00 
       00 F5 00 FA 
       E6 E2 F5 00 
       00 00 00 00 
042BB5             0016*M 
042BB5             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042BB5 17 1B 21    0018*M     db 23,27,0x21
042BB8 10 00       0019*M     dw width ; in pixels
042BBA 10 00       0020*M     dw height ; in pixels
042BBC 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042BBD             0111*  	LOADBMPBUFFER2 BUF_SEEKER_022,16,16,"src/rgba2/seeker_022.rgba2"
042BBD             0001*M 
042BBD             0002*M     ; Clear buffer
042BBD 17 00 A0    0003*M     db 23,0,0xA0
042BC0 2A 01       0004*M     dw bufferId
042BC2 02          0005*M     db 2
042BC3             0006*M 
042BC3 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042BC6 2A 01       0008*M     dw bufferId
042BC8             0009*M 
042BC8             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042BC8 17 00 A0    0011*M     db 23,0,0xA0
042BCB 2A 01       0012*M     dw bufferId
042BCD 00          0013*M     db 0
042BCE 00 01       0014*M 	dw width * height ; length of data in bytes
042BD0 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 FA 
       DA DF DB DB 
       00 00 00 00 
       00 00 00 E1 
       E0 E1 E0 E5 
       DA DB F1 DB 
       00 00 00 00 
       00 E2 E1 E1 
       E0 E0 E1 00 
       00 00 00 00 
       D0 E2 00 00 
       FA EA E1 E1 
       E1 E1 F3 E0 
       E0 E5 E5 D0 
       D0 E6 F3 00 
       00 FE E5 F6 
       FB E2 E1 E1 
       D0 D0 D0 D1 
       D1 E6 00 00 
       EA 00 00 E1 
       E1 F6 E1 E1 
       D4 E0 D1 E1 
       D0 00 00 00 
       00 EA EA E2 
       E2 D6 E4 F4 
       FD F9 F5 F5 
       E5 E3 FF 00 
       00 00 00 E1 
       E6 E6 F4 F8 
       FE FE FD F6 
       E2 E2 F7 F3 
       00 FA E5 EA 
       EA F6 F5 FC 
       FD FE F9 E1 
       E1 E0 E1 E2 
       D0 E0 E0 EA 
       FF FA FA F9 
       F8 F8 E5 E1 
       E5 00 00 00 
       E0 F5 E0 FA 
       FF FB FB FA 
       F6 E1 E1 E0 
       E5 F0 E7 DB 
       00 F5 F5 FA 
       FF F6 E7 F6 
       E1 E1 D4 00 
       00 EB DF DB 
       00 00 00 FA 
       00 E6 E1 E1 
       F2 E2 00 00 
       FA DB DF DF 
       00 00 F5 00 
       EA EA D1 E2 
       E1 E1 E1 E0 
       F5 EB EF FF 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FF FA E2 
       E1 F5 00 00 
       00 00 00 00 
042CD0             0016*M 
042CD0             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042CD0 17 1B 21    0018*M     db 23,27,0x21
042CD3 10 00       0019*M     dw width ; in pixels
042CD5 10 00       0020*M     dw height ; in pixels
042CD7 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042CD8             0112*  	LOADBMPBUFFER2 BUF_SEEKER_023,16,16,"src/rgba2/seeker_023.rgba2"
042CD8             0001*M 
042CD8             0002*M     ; Clear buffer
042CD8 17 00 A0    0003*M     db 23,0,0xA0
042CDB 2B 01       0004*M     dw bufferId
042CDD 02          0005*M     db 2
042CDE             0006*M 
042CDE 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042CE1 2B 01       0008*M     dw bufferId
042CE3             0009*M 
042CE3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042CE3 17 00 A0    0011*M     db 23,0,0xA0
042CE6 2B 01       0012*M     dw bufferId
042CE8 00          0013*M     db 0
042CE9 00 01       0014*M 	dw width * height ; length of data in bytes
042CEB 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 00 E0 
       F4 EA DB DF 
       DB D7 C3 00 
       EA 00 E2 E1 
       E1 E0 E1 E0 
       E5 EA DB DF 
       DB 00 00 00 
       00 EA FA E1 
       E1 E1 E0 00 
       00 00 DB 00 
       D6 00 00 00 
       00 00 00 E5 
       F6 E1 E2 E2 
       E0 E1 E5 FF 
       00 D0 F2 00 
       00 E6 00 00 
       E6 F6 E1 E1 
       E1 E0 E5 D0 
       D0 D1 E2 00 
       00 00 EA E6 
       E1 E2 E5 E1 
       E4 D0 D0 D1 
       D1 D5 EA 00 
       E5 00 00 E2 
       E2 D6 E5 F4 
       F8 F9 E5 E1 
       E1 00 00 E6 
       00 FF E5 EA 
       EA E5 E5 F8 
       FD FD FD F5 
       E5 E2 FB 00 
       E0 E0 E1 EE 
       FF FA F5 FC 
       FE FE F9 F2 
       E2 E2 FB F7 
       F5 F5 E0 FA 
       FF FB FA F8 
       F8 FD E5 E1 
       E1 E0 E1 F2 
       F5 E0 FA FA 
       FA FB EB FA 
       E5 E1 E0 E5 
       E5 00 00 00 
       00 00 FA 00 
       E2 E6 E6 F6 
       E1 E5 E0 E1 
       F0 00 DB 00 
       00 00 00 EA 
       EA E1 E1 F6 
       E2 00 00 00 
       EB 00 DB EB 
       00 00 00 00 
       00 E9 E2 E1 
       E1 E1 E0 FA 
       DB DF DB EB 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E0 E0 F5 
       EF EF EF EF 
       00 00 00 00 
       FE E6 E2 F5 
       E5 00 00 00 
       00 00 00 00 
042DEB             0016*M 
042DEB             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042DEB 17 1B 21    0018*M     db 23,27,0x21
042DEE 10 00       0019*M     dw width ; in pixels
042DF0 10 00       0020*M     dw height ; in pixels
042DF2 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042DF3             0113*  	LOADBMPBUFFER2 BUF_SEEKER_024,16,16,"src/rgba2/seeker_024.rgba2"
042DF3             0001*M 
042DF3             0002*M     ; Clear buffer
042DF3 17 00 A0    0003*M     db 23,0,0xA0
042DF6 2C 01       0004*M     dw bufferId
042DF8 02          0005*M     db 2
042DF9             0006*M 
042DF9 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042DFC 2C 01       0008*M     dw bufferId
042DFE             0009*M 
042DFE             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042DFE 17 00 A0    0011*M     db 23,0,0xA0
042E01 2C 01       0012*M     dw bufferId
042E03 00          0013*M     db 0
042E04 00 01       0014*M 	dw width * height ; length of data in bytes
042E06 00 00 00 00 0015*M     incbin file ; bitmap data
       E2 E1 E1 00 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 EA 
       E1 E1 E1 E1 
       E1 E1 EA DB 
       DF DB D7 C3 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 00 
       00 F7 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       E2 D7 D5 E1 
       E1 D0 D0 D0 
       D0 D0 D1 F3 
       00 00 E5 EA 
       E5 E6 E5 F4 
       F8 F9 E1 D1 
       D1 D1 E6 00 
       E1 E1 E1 EE 
       EB F6 F5 F8 
       FD FD F9 F5 
       E1 00 00 00 
       F5 F5 F5 FF 
       FF FA F5 FC 
       FE FE FD F5 
       F5 00 00 00 
       00 00 FA FF 
       FB FB FA F8 
       FC FD F5 E2 
       E2 E2 FB 00 
       00 00 00 00 
       F6 EB EA F6 
       E1 E1 E1 E1 
       E1 E1 E2 F3 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 E2 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FA 
       E2 E1 E1 E1 
       E1 E1 FA DB 
       DF DB EB C3 
       00 00 00 00 
       F6 F6 F5 00 
       00 00 00 EF 
       00 EF 00 00 
042F06             0016*M 
042F06             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042F06 17 1B 21    0018*M     db 23,27,0x21
042F09 10 00       0019*M     dw width ; in pixels
042F0B 10 00       0020*M     dw height ; in pixels
042F0D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042F0E             0114*  	LOADBMPBUFFER2 BUF_SEEKER_025,16,16,"src/rgba2/seeker_025.rgba2"
042F0E             0001*M 
042F0E             0002*M     ; Clear buffer
042F0E 17 00 A0    0003*M     db 23,0,0xA0
042F11 2D 01       0004*M     dw bufferId
042F13 02          0005*M     db 2
042F14             0006*M 
042F14 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042F17 2D 01       0008*M     dw bufferId
042F19             0009*M 
042F19             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042F19 17 00 A0    0011*M     db 23,0,0xA0
042F1C 2D 01       0012*M     dw bufferId
042F1E 00          0013*M     db 0
042F1F 00 01       0014*M 	dw width * height ; length of data in bytes
042F21 00 00 00 00 0015*M     incbin file ; bitmap data
       EA E6 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E1 E0 F5 
       DB DB EB DB 
       00 00 00 00 
       00 E9 F6 E1 
       E1 E0 E0 F5 
       DB DF DB DB 
       00 00 00 EA 
       EA E1 F6 F2 
       E2 00 00 00 
       EB 00 DB D7 
       00 00 E5 00 
       E2 E2 E2 E5 
       E1 E1 E0 E1 
       F0 00 DB 00 
       E0 D0 E5 E5 
       E5 E6 D6 E5 
       E1 D1 D0 E5 
       E5 00 00 00 
       F5 E5 E0 EA 
       EA E6 E5 F4 
       F4 E4 D0 D0 
       D0 D0 C0 E2 
       F5 F5 F5 FF 
       FF FA F5 F8 
       FD FD E5 E1 
       D1 D1 E6 E2 
       00 FF FA FF 
       FB FB F9 FC 
       FE FE FD F5 
       E1 D1 E6 00 
       FA 00 00 F6 
       FB EB FA F8 
       FD FD F5 F6 
       E1 00 00 E6 
       00 00 EA E6 
       E2 E6 F6 E5 
       E1 E5 E1 E2 
       E2 E7 FF 00 
       00 EA 00 00 
       E1 F1 E1 E1 
       E1 E0 E5 E4 
       E0 E2 F3 00 
       00 00 00 E5 
       E2 E1 E2 E2 
       E0 E1 E5 FF 
       00 E1 F2 00 
       00 FA FA E1 
       E1 E1 E1 00 
       00 00 DB 00 
       D6 00 00 00 
       FA 00 E6 F2 
       E1 E4 E0 E0 
       E5 EB DB DF 
       DB 00 00 00 
       00 00 00 00 
       00 F5 00 D0 
       F5 EB DF DF 
       DB E7 C3 00 
043021             0016*M 
043021             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043021 17 1B 21    0018*M     db 23,27,0x21
043024 10 00       0019*M     dw width ; in pixels
043026 10 00       0020*M     dw height ; in pixels
043028 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043029             0115*  	LOADBMPBUFFER2 BUF_SEEKER_026,16,16,"src/rgba2/seeker_026.rgba2"
043029             0001*M 
043029             0002*M     ; Clear buffer
043029 17 00 A0    0003*M     db 23,0,0xA0
04302C 2E 01       0004*M     dw bufferId
04302E 02          0005*M     db 2
04302F             0006*M 
04302F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043032 2E 01       0008*M     dw bufferId
043034             0009*M 
043034             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043034 17 00 A0    0011*M     db 23,0,0xA0
043037 2E 01       0012*M     dw bufferId
043039 00          0013*M     db 0
04303A 00 01       0014*M 	dw width * height ; length of data in bytes
04303C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 FA EA E1 
       E1 E1 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E1 E0 
       00 00 00 00 
       00 00 D0 00 
       EA EA F7 F6 
       E1 E1 E0 E0 
       E5 DA DB E7 
       00 00 00 E5 
       00 E6 E1 F6 
       E2 E2 00 00 
       EA DB DF DB 
       00 E0 E1 E5 
       D5 E2 E2 E6 
       E5 E1 E4 00 
       00 EB DF DB 
       F5 F5 E0 E5 
       EA E5 E6 E5 
       E1 E1 E1 E0 
       E5 F0 E7 EB 
       E1 F1 F5 FA 
       FF FA E5 F4 
       F4 E4 D0 D0 
       E5 00 00 00 
       00 FF FA FF 
       FF FA F5 F8 
       FD FD E5 D1 
       D0 D0 D0 D1 
       00 00 00 F6 
       FB FB F9 FC 
       FE FE F9 E1 
       D1 D1 E5 E2 
       00 FA EA E2 
       E7 EB F9 F8 
       FD FE F9 F5 
       E0 D2 E6 00 
       FA 00 00 E1 
       E1 F6 E5 E1 
       E5 E5 E2 F2 
       E1 00 00 00 
       00 FF E5 E6 
       E2 E2 E1 E1 
       E0 E1 E1 E2 
       E2 FB 00 00 
       FE FA E1 E1 
       E1 E2 F3 E4 
       E0 E5 E5 E0 
       E1 F7 F2 00 
       00 F6 E2 E1 
       E0 E1 E0 00 
       00 00 00 00 
       E1 F2 00 00 
       00 00 00 F5 
       E1 E0 E0 F5 
       EB DB F1 DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       DB DF DB DB 
       00 00 00 00 
04313C             0016*M 
04313C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04313C 17 1B 21    0018*M     db 23,27,0x21
04313F 10 00       0019*M     dw width ; in pixels
043141 10 00       0020*M     dw height ; in pixels
043143 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043144             0116*  	LOADBMPBUFFER2 BUF_SEEKER_027,16,16,"src/rgba2/seeker_027.rgba2"
043144             0001*M 
043144             0002*M     ; Clear buffer
043144 17 00 A0    0003*M     db 23,0,0xA0
043147 2F 01       0004*M     dw bufferId
043149 02          0005*M     db 2
04314A             0006*M 
04314A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04314D 2F 01       0008*M     dw bufferId
04314F             0009*M 
04314F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04314F 17 00 A0    0011*M     db 23,0,0xA0
043152 2F 01       0012*M     dw bufferId
043154 00          0013*M     db 0
043155 00 01       0014*M 	dw width * height ; length of data in bytes
043157 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 00 EA 
       E5 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C4 
       F5 E1 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FE EA D1 
       F6 E1 E1 E1 
       E0 00 00 00 
       00 F5 E0 E5 
       E5 00 E2 E1 
       F6 E1 E1 E0 
       E0 E5 DB EB 
       00 F5 F5 E0 
       EA E5 E2 D6 
       F6 E1 E2 00 
       00 EA DA DF 
       00 00 F5 F5 
       FF EA E6 E6 
       E5 E1 E1 E1 
       00 DB DB DF 
       FA FF FA FF 
       FF FA F5 E5 
       F4 E4 D0 E0 
       E5 F0 00 DB 
       00 00 00 F6 
       FB FB F5 F8 
       F8 FD E4 D0 
       E5 E5 00 DB 
       F5 EA FA E2 
       EB FB F9 FC 
       FE FD E5 D1 
       D1 D0 D0 00 
       00 00 00 E1 
       E6 E6 F9 FC 
       FE FD F9 E1 
       D1 D1 D1 E2 
       FF E5 E5 E2 
       F1 E1 E1 E1 
       F9 F5 F6 F5 
       E0 E6 E6 F3 
       FA E2 E1 E1 
       E2 E2 E1 E1 
       E0 E1 E2 E2 
       00 00 00 00 
       F7 F6 E1 E1 
       E1 00 00 E0 
       E5 E5 E1 E2 
       FB FF F7 00 
       00 00 F5 E0 
       E1 E0 00 00 
       F0 FF E0 E1 
       F7 00 00 00 
       00 00 00 00 
       E0 E1 FA DB 
       E7 D6 00 E2 
       F3 00 00 00 
       00 00 00 00 
       00 00 EB CB 
       DF DB C6 00 
       00 00 00 00 
043257             0016*M 
043257             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043257 17 1B 21    0018*M     db 23,27,0x21
04325A 10 00       0019*M     dw width ; in pixels
04325C 10 00       0020*M     dw height ; in pixels
04325E 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04325F             0117*  	LOADBMPBUFFER2 BUF_SEEKER_028,16,16,"src/rgba2/seeker_028.rgba2"
04325F             0001*M 
04325F             0002*M     ; Clear buffer
04325F 17 00 A0    0003*M     db 23,0,0xA0
043262 30 01       0004*M     dw bufferId
043264 02          0005*M     db 2
043265             0006*M 
043265 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043268 30 01       0008*M     dw bufferId
04326A             0009*M 
04326A             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04326A 17 00 A0    0011*M     db 23,0,0xA0
04326D 30 01       0012*M     dw bufferId
04326F 00          0013*M     db 0
043270 00 01       0014*M 	dw width * height ; length of data in bytes
043272 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 EA 
       00 EA E1 E1 
       00 00 00 00 
       00 00 00 E0 
       00 00 00 EA 
       00 E5 E1 E1 
       E0 00 00 00 
       00 00 F5 E0 
       E5 E5 00 EA 
       D0 F6 E1 E1 
       E0 00 00 00 
       00 F5 F5 F1 
       E0 EA D1 E2 
       E1 F6 E1 E1 
       E1 E0 00 00 
       00 00 F6 F5 
       EA EE E5 E7 
       E2 F6 E2 E2 
       E1 E0 F5 DB 
       00 00 FA FF 
       FF FF EA E6 
       E5 E1 E1 E4 
       00 F0 EA DB 
       00 00 00 FB 
       FB FB F5 E5 
       F4 E4 E1 E1 
       E1 00 DB DF 
       FA EA EA E2 
       FB FB F5 F8 
       F8 F8 D4 D0 
       E5 F0 00 DB 
       00 00 D0 E1 
       EA FA F8 FD 
       FE FD E5 D0 
       D5 E5 00 EB 
       FA E5 E6 E2 
       F6 F6 F5 FC 
       FE FD E5 D1 
       D1 D0 00 00 
       E2 E1 F1 E1 
       E2 E1 E1 E5 
       F9 F9 F5 E1 
       D1 D1 C0 00 
       F6 E1 E1 E1 
       E2 D4 E1 E0 
       E1 E2 F5 E4 
       D2 E6 E2 F3 
       00 F5 E0 E1 
       E0 00 E1 E5 
       E5 E1 E2 E3 
       00 EA 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 E0 F2 FB 
       FF E6 00 00 
       00 00 00 00 
       F5 EB DB 00 
       00 00 E1 F7 
       00 00 00 00 
       00 00 00 00 
       EF DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
043372             0016*M 
043372             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043372 17 1B 21    0018*M     db 23,27,0x21
043375 10 00       0019*M     dw width ; in pixels
043377 10 00       0020*M     dw height ; in pixels
043379 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04337A             0118*  	LOADBMPBUFFER2 BUF_SEEKER_029,16,16,"src/rgba2/seeker_029.rgba2"
04337A             0001*M 
04337A             0002*M     ; Clear buffer
04337A 17 00 A0    0003*M     db 23,0,0xA0
04337D 31 01       0004*M     dw bufferId
04337F 02          0005*M     db 2
043380             0006*M 
043380 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043383 31 01       0008*M     dw bufferId
043385             0009*M 
043385             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043385 17 00 A0    0011*M     db 23,0,0xA0
043388 31 01       0012*M     dw bufferId
04338A 00          0013*M     db 0
04338B 00 01       0014*M 	dw width * height ; length of data in bytes
04338D 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E5 00 
       F5 00 EA E6 
       E2 00 00 00 
       00 00 00 F5 
       E0 00 E6 00 
       EA 00 E5 E1 
       E1 00 00 00 
       00 00 00 F5 
       F5 E1 E5 00 
       FA 00 E6 E1 
       E1 E1 00 00 
       00 00 00 F5 
       E0 E5 EA E1 
       E2 E1 F7 E1 
       E1 E0 00 00 
       00 00 00 FA 
       FF FF EA E5 
       D7 E2 F6 E1 
       E0 E1 E0 00 
       F5 00 EA 00 
       FB FF FA E5 
       E6 E5 E1 E2 
       00 E0 E1 00 
       00 00 EA E2 
       FB FB F6 F5 
       F4 E0 E1 E1 
       00 00 E6 EA 
       FA C8 D1 E1 
       EB FB F9 F8 
       F8 F8 E4 E0 
       E0 00 DB CB 
       E6 F6 E2 E1 
       F6 FA F8 FD 
       FE FD E4 D0 
       E5 F0 E7 DF 
       E2 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 D0 
       D5 FF D6 DB 
       F5 E1 E1 E2 
       E2 E1 E1 E9 
       F9 F9 E1 D1 
       D0 D0 00 DB 
       00 E1 E1 E1 
       00 E1 E0 E1 
       E2 F6 F5 D1 
       D1 D0 D1 00 
       00 00 E0 E0 
       00 00 E5 E5 
       E1 E2 E4 00 
       E6 E6 F2 00 
       00 00 00 F5 
       EA DB F0 E5 
       E0 E2 F7 00 
       EA 00 00 00 
       00 00 00 EF 
       DA DB 00 00 
       E0 E2 FB 00 
       E6 00 00 00 
       00 00 00 FF 
       DF DF DB DB 
       00 F2 F3 00 
       00 00 00 00 
04348D             0016*M 
04348D             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04348D 17 1B 21    0018*M     db 23,27,0x21
043490 10 00       0019*M     dw width ; in pixels
043492 10 00       0020*M     dw height ; in pixels
043494 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043495             0119*  	LOADBMPBUFFER2 BUF_SEEKER_030,16,16,"src/rgba2/seeker_030.rgba2"
043495             0001*M 
043495             0002*M     ; Clear buffer
043495 17 00 A0    0003*M     db 23,0,0xA0
043498 32 01       0004*M     dw bufferId
04349A 02          0005*M     db 2
04349B             0006*M 
04349B 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04349E 32 01       0008*M     dw bufferId
0434A0             0009*M 
0434A0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0434A0 17 00 A0    0011*M     db 23,0,0xA0
0434A3 32 01       0012*M     dw bufferId
0434A5 00          0013*M     db 0
0434A6 00 01       0014*M 	dw width * height ; length of data in bytes
0434A8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 D0 00 
       00 00 EA 00 
       FA 00 00 00 
       00 00 00 00 
       F5 F5 E0 FA 
       00 EA 00 FE 
       EA E2 00 00 
       00 00 F5 00 
       F5 E0 E0 E5 
       00 EA 00 E5 
       E1 E1 00 00 
       00 00 00 FA 
       FA FA EA EA 
       E1 E2 E1 F6 
       E1 E1 E1 00 
       00 E5 EA 00 
       FF FF FF EA 
       E6 E2 E1 FB 
       E1 E0 E0 00 
       FF 00 EA E6 
       F6 FB FA F6 
       E6 D6 F6 E2 
       E1 E0 E1 00 
       FA E5 D1 E1 
       E7 FB FA F5 
       F4 E4 E1 E1 
       F3 E1 E0 00 
       E2 E5 E2 E1 
       F6 FA F9 FC 
       F8 F4 E1 E1 
       E0 00 E5 FA 
       E1 E1 E1 F2 
       E1 F6 F8 FD 
       FE FD D4 D0 
       E0 00 DA DA 
       F5 E0 E1 E2 
       E1 E1 F8 FE 
       FE F9 E0 D0 
       E5 00 DB DF 
       00 E0 E1 00 
       D4 E1 E5 F9 
       FD F5 D1 D0 
       E5 00 F1 DB 
       00 E0 E0 00 
       00 E0 E1 E1 
       F6 F5 E1 D1 
       D0 00 DB DB 
       00 00 F5 FA 
       00 E5 E5 E1 
       E2 E5 D0 D1 
       D0 D0 00 00 
       00 00 EB DB 
       EB F0 00 E0 
       E2 E3 00 E6 
       E6 E2 00 00 
       00 00 EF DF 
       DF E7 00 E1 
       F7 FF 00 00 
       F3 00 00 00 
       00 00 FF DF 
       DB DB 00 E2 
       F3 00 00 00 
       00 00 00 00 
0435A8             0016*M 
0435A8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0435A8 17 1B 21    0018*M     db 23,27,0x21
0435AB 10 00       0019*M     dw width ; in pixels
0435AD 10 00       0020*M     dw height ; in pixels
0435AF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0435B0             0120*  	LOADBMPBUFFER2 BUF_SEEKER_031,16,16,"src/rgba2/seeker_031.rgba2"
0435B0             0001*M 
0435B0             0002*M     ; Clear buffer
0435B0 17 00 A0    0003*M     db 23,0,0xA0
0435B3 33 01       0004*M     dw bufferId
0435B5 02          0005*M     db 2
0435B6             0006*M 
0435B6 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0435B9 33 01       0008*M     dw bufferId
0435BB             0009*M 
0435BB             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0435BB 17 00 A0    0011*M     db 23,0,0xA0
0435BE 33 01       0012*M     dw bufferId
0435C0 00          0013*M     db 0
0435C1 00 01       0014*M 	dw width * height ; length of data in bytes
0435C3 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 F5 E0 
       00 E5 00 00 
       00 00 EA 00 
       00 00 00 00 
       00 E0 F5 E0 
       FF 00 00 E6 
       00 EA 00 00 
       00 00 00 00 
       FA FA E0 E1 
       E5 00 EA 00 
       00 FA E2 00 
       00 00 00 EA 
       00 FA FA EE 
       EA E2 E6 00 
       E5 E1 E1 00 
       FE FF 00 EA 
       E2 FA FF FF 
       EA E2 E1 E6 
       F6 E1 E1 00 
       E6 E5 E9 E1 
       E6 FB FB FA 
       E5 D6 E2 F6 
       E1 E1 E0 E0 
       E2 E1 E2 E1 
       E6 EB FA F5 
       E5 E5 E5 E1 
       E2 E0 E1 00 
       F5 E1 E1 F6 
       F6 FA F8 FC 
       F8 F4 E1 E1 
       E2 00 E0 E0 
       E5 E1 E1 E2 
       E1 E5 F8 FE 
       FD F8 E4 E1 
       E0 00 E5 F4 
       00 E0 E1 00 
       E5 E1 FD FE 
       FD F9 D0 E0 
       E1 00 EA EA 
       00 E0 E0 00 
       E0 E0 E5 F9 
       FD E5 D0 E5 
       E5 DB DB DB 
       00 F5 FA 00 
       E1 E5 E1 F2 
       F5 E1 D1 D0 
       FF 00 DF DF 
       00 EF DB EB 
       F0 E5 E1 E2 
       E5 E1 D1 D0 
       00 D6 DB DB 
       00 EF DF 00 
       00 00 E0 E2 
       E2 00 D5 D1 
       D0 00 00 D7 
       00 EF DB DB 
       DB 00 E1 FB 
       FB 00 EA E2 
       F2 00 00 C3 
       00 EF EB EB 
       00 00 F2 F7 
       00 E6 00 00 
       00 00 00 00 
0436C3             0016*M 
0436C3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0436C3 17 1B 21    0018*M     db 23,27,0x21
0436C6 10 00       0019*M     dw width ; in pixels
0436C8 10 00       0020*M     dw height ; in pixels
0436CA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0436CB             0121*  	LOADBMPBUFFER2 BUF_SHIP_0L,16,16,"src/rgba2/ship_0l.rgba2"
0436CB             0001*M 
0436CB             0002*M     ; Clear buffer
0436CB 17 00 A0    0003*M     db 23,0,0xA0
0436CE 34 01       0004*M     dw bufferId
0436D0 02          0005*M     db 2
0436D1             0006*M 
0436D1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0436D4 34 01       0008*M     dw bufferId
0436D6             0009*M 
0436D6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0436D6 17 00 A0    0011*M     db 23,0,0xA0
0436D9 34 01       0012*M     dw bufferId
0436DB 00          0013*M     db 0
0436DC 00 01       0014*M 	dw width * height ; length of data in bytes
0436DE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 C6 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 CA 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C6 CA 
       CB C7 DB 00 
       00 00 00 00 
       00 00 C7 00 
       C7 CA C6 CA 
       CB C7 CB DB 
       00 00 C7 00 
       00 00 C7 00 
       CA CA C6 CA 
       CB C7 CB CB 
       DB 00 C7 00 
       00 00 C7 C7 
       CA C6 C6 CA 
       CB C7 C7 CB 
       CB DB C7 00 
       00 00 C7 CA 
       C6 C6 C6 CA 
       CB C7 C7 C7 
       CB CB C7 00 
       00 00 C7 CA 
       C6 CA C6 CA 
       CB C7 CB C7 
       C7 CB C7 00 
       00 00 C7 CA 
       C7 C7 C6 CA 
       CB C7 DB DB 
       C7 CB C7 00 
       00 00 C7 00 
       00 00 C6 00 
       00 C7 00 00 
       DB CB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB DB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
0437DE             0016*M 
0437DE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0437DE 17 1B 21    0018*M     db 23,27,0x21
0437E1 10 00       0019*M     dw width ; in pixels
0437E3 10 00       0020*M     dw height ; in pixels
0437E5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0437E6             0122*  	LOADBMPBUFFER2 BUF_SHIP_1C,16,16,"src/rgba2/ship_1c.rgba2"
0437E6             0001*M 
0437E6             0002*M     ; Clear buffer
0437E6 17 00 A0    0003*M     db 23,0,0xA0
0437E9 35 01       0004*M     dw bufferId
0437EB 02          0005*M     db 2
0437EC             0006*M 
0437EC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0437EF 35 01       0008*M     dw bufferId
0437F1             0009*M 
0437F1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0437F1 17 00 A0    0011*M     db 23,0,0xA0
0437F4 35 01       0012*M     dw bufferId
0437F6 00          0013*M     db 0
0437F7 00 01       0014*M 	dw width * height ; length of data in bytes
0437F9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C7 DB 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C7 CB DB 
       00 00 C7 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C7 CB CB 
       DB 00 C7 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C7 C7 CB 
       CB DB C7 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C7 C7 C7 
       CB CB C7 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C7 CB C7 
       C7 CB C7 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C7 DB DB 
       C7 CB C7 00 
       00 DB DB DB 
       00 00 DB 00 
       00 C7 00 00 
       DB DB C7 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438F9             0016*M 
0438F9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0438F9 17 1B 21    0018*M     db 23,27,0x21
0438FC 10 00       0019*M     dw width ; in pixels
0438FE 10 00       0020*M     dw height ; in pixels
043900 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043901             0123*  	LOADBMPBUFFER2 BUF_SHIP_2R,16,16,"src/rgba2/ship_2r.rgba2"
043901             0001*M 
043901             0002*M     ; Clear buffer
043901 17 00 A0    0003*M     db 23,0,0xA0
043904 36 01       0004*M     dw bufferId
043906 02          0005*M     db 2
043907             0006*M 
043907 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04390A 36 01       0008*M     dw bufferId
04390C             0009*M 
04390C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04390C 17 00 A0    0011*M     db 23,0,0xA0
04390F 36 01       0012*M     dw bufferId
043911 00          0013*M     db 0
043912 00 01       0014*M 	dw width * height ; length of data in bytes
043914 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C6 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C6 C7 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C6 CA C7 
       00 C6 00 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C6 CA CA 
       00 C6 00 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C6 C6 CA 
       C7 C6 00 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C6 C6 C6 
       CA C6 00 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C6 CA C6 
       CA C6 00 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C6 C7 C7 
       CA C6 00 00 
       00 DB CB DB 
       00 00 DB 00 
       00 C6 00 00 
       00 C6 00 00 
       00 DB DB DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A14             0016*M 
043A14             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A14 17 1B 21    0018*M     db 23,27,0x21
043A17 10 00       0019*M     dw width ; in pixels
043A19 10 00       0020*M     dw height ; in pixels
043A1B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A1C             0124*  	LOADBMPBUFFER2 BUF_SHIP_SMALL,8,8,"src/rgba2/ship_small.rgba2"
043A1C             0001*M 
043A1C             0002*M     ; Clear buffer
043A1C 17 00 A0    0003*M     db 23,0,0xA0
043A1F 37 01       0004*M     dw bufferId
043A21 02          0005*M     db 2
043A22             0006*M 
043A22 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A25 37 01       0008*M     dw bufferId
043A27             0009*M 
043A27             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A27 17 00 A0    0011*M     db 23,0,0xA0
043A2A 37 01       0012*M     dw bufferId
043A2C 00          0013*M     db 0
043A2D 40 00       0014*M 	dw width * height ; length of data in bytes
043A2F 00 00 00 CB 0015*M     incbin file ; bitmap data
       CA 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       CB 00 00 CB 
       CA 00 00 CA 
       CB 00 CB C7 
       C6 CB 00 CA 
       CB CB C7 CB 
       CA C6 CB CA 
       CB C7 CB CB 
       CA CB C6 CA 
       CB 00 00 00 
       00 00 00 CA 
043A6F             0016*M 
043A6F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A6F 17 1B 21    0018*M     db 23,27,0x21
043A72 08 00       0019*M     dw width ; in pixels
043A74 08 00       0020*M     dw height ; in pixels
043A76 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A77             0125*  	LOADBMPBUFFER2 BUF_STAR,5,5,"src/rgba2/star.rgba2"
043A77             0001*M 
043A77             0002*M     ; Clear buffer
043A77 17 00 A0    0003*M     db 23,0,0xA0
043A7A 38 01       0004*M     dw bufferId
043A7C 02          0005*M     db 2
043A7D             0006*M 
043A7D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A80 38 01       0008*M     dw bufferId
043A82             0009*M 
043A82             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A82 17 00 A0    0011*M     db 23,0,0xA0
043A85 38 01       0012*M     dw bufferId
043A87 00          0013*M     db 0
043A88 19 00       0014*M 	dw width * height ; length of data in bytes
043A8A 00 00 D1 00 0015*M     incbin file ; bitmap data
       00 00 00 E6 
       00 00 D1 E6 
       FF E6 D1 00 
       00 E6 00 00 
       00 00 D1 00 
       00          
043AA3             0016*M 
043AA3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043AA3 17 1B 21    0018*M     db 23,27,0x21
043AA6 05 00       0019*M     dw width ; in pixels
043AA8 05 00       0020*M     dw height ; in pixels
043AAA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043AAB             0126*  	LOADBMPBUFFER2 BUF_TURRET,16,16,"src/rgba2/turret.rgba2"
043AAB             0001*M 
043AAB             0002*M     ; Clear buffer
043AAB 17 00 A0    0003*M     db 23,0,0xA0
043AAE 39 01       0004*M     dw bufferId
043AB0 02          0005*M     db 2
043AB1             0006*M 
043AB1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043AB4 39 01       0008*M     dw bufferId
043AB6             0009*M 
043AB6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043AB6 17 00 A0    0011*M     db 23,0,0xA0
043AB9 39 01       0012*M     dw bufferId
043ABB 00          0013*M     db 0
043ABC 00 01       0014*M 	dw width * height ; length of data in bytes
043ABE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043BBE             0016*M 
043BBE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043BBE 17 1B 21    0018*M     db 23,27,0x21
043BC1 10 00       0019*M     dw width ; in pixels
043BC3 10 00       0020*M     dw height ; in pixels
043BC5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043BC6             0127*  	LOADBMPBUFFER2 BUF_TURRET_ROT,16,16,"src/rgba2/turret_rot.rgba2"
043BC6             0001*M 
043BC6             0002*M     ; Clear buffer
043BC6 17 00 A0    0003*M     db 23,0,0xA0
043BC9 3A 01       0004*M     dw bufferId
043BCB 02          0005*M     db 2
043BCC             0006*M 
043BCC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043BCF 3A 01       0008*M     dw bufferId
043BD1             0009*M 
043BD1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043BD1 17 00 A0    0011*M     db 23,0,0xA0
043BD4 3A 01       0012*M     dw bufferId
043BD6 00          0013*M     db 0
043BD7 00 01       0014*M 	dw width * height ; length of data in bytes
043BD9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 DF DF 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 DF DF 
       DF D0 F5 C3 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 DF 
       DF DF C3 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 D0 
       DF C3 DF D0 
       F5 C3 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 DF DF DF 
       C3 F5 F5 F5 
       C3 F5 F5 D0 
       D0 F5 F5 C3 
       F5 D0 DF C3 
       DF D0 F5 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 C3 DF 
       DF DF D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 F5 
       F5 C3 F5 D0 
       DF DF DF C3 
       D0 D0 D0 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       D0 DF C3 FA 
       E5 E5 D0 D0 
       00 D0 F5 F5 
       F5 F5 F5 C3 
       D0 C3 FA FA 
       FA E5 D0 00 
       00 D0 F5 F5 
       F5 F5 C3 F5 
       D0 D0 E5 FA 
       E5 E5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       D0 D0 E5 E5 
       E5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 D0 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043CD9             0016*M 
043CD9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043CD9 17 1B 21    0018*M     db 23,27,0x21
043CDC 10 00       0019*M     dw width ; in pixels
043CDE 10 00       0020*M     dw height ; in pixels
043CE0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043CE1             0128*  @end:
043CE1             0048   	include "src/asm/fonts.inc"
043CE1             0001*  font_nurples:
043CE1 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
043CE9 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
043CF1 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
043CF9 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
043D01 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
043D09 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
043D11 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
043D19 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
043D21 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
043D29 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
043D31 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
043D39 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
043D41 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
043D49 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
043D51 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
043D59 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
043D61 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
043D69 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
043D71 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
043D79 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
043D81 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
043D89 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
043D91 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
043D99 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
043DA1 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
043DA9 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
043DB1 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
043DB9 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
043DC1 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
043DC9 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
043DD1 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
043DD9 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
043DE1 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
043DE9 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
043DF1 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
043DF9 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
043E01 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
043E09 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
043E11 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
043E19 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
043E21 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
043E29 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
043E31 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
043E39 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
043E41 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
043E49 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
043E51 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
043E59 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
043E61 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
043E69 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
043E71 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
043E79 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
043E81 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
043E89 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
043E91 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
043E99 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
043EA1 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
043EA9 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
043EB1 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
043EB9 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
043EC1 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
043EC9 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
043ED1 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
043ED9 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
043EE1 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
043EE9 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
043EF1 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
043EF9 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
043F01 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
043F09 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
043F11 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
043F19 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
043F21 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
043F29 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
043F31 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
043F39 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
043F41 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
043F49 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
043F51 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
043F59 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
043F61 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
043F69 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
043F71 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
043F79 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
043F81 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
043F89 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
043F91 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
043F99 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
043FA1 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
043FA9 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
043FB1 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
043FB9 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
043FC1 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
043FC9 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
043FD1 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
043FD9 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
043FE1 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ;  #80 128
       00 00 00 00 
043FE9 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ;  #81 129
       20 20 20 20 
043FF1 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ;  #82 130
       20 20 20 20 
043FF9 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ;  #83 131
       20 20 20 20 
044001 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ;  #84 132
       00 00 00 00 
044009 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ;  #85 133
       00 00 00 00 
044011 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ;  #86 134
       20 20 20 20 
044019 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ;  #87 135
       20 20 20 20 
044021 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ;  #88 136
       20 20 20 20 
044029 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ;  #89 137
       00 00 00 00 
044031 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ;  #8A 138
       20 20 20 20 
044039 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ;  #8B 139
       FC 00 00 00 
044041 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ;  #8C 140
       50 50 50 50 
044049 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ;  #8D 141
       3C 20 20 20 
044051 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ;  #8E 142
       50 50 50 50 
044059 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ;  #8F 143
       5C 50 50 50 
044061 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ;  #90 144
       E0 20 20 20 
044069 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ;  #91 145
       50 50 50 50 
044071 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ;  #92 146
       D0 50 50 50 
044079 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ;  #93 147
       3C 00 00 00 
044081 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ;  #94 148
       00 00 00 00 
044089 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ;  #95 149
       7C 00 00 00 
044091 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ;  #96 150
       E0 00 00 00 
044099 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ;  #97 151
       00 00 00 00 
0440A1 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ;  #98 152
       F0 00 00 00 
0440A9 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ;  #99 153
       3C 20 20 20 
0440B1 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ;  #9A 154
       50 50 50 50 
0440B9 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ;  #9B 155
       5C 50 50 50 
0440C1 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ;  #9C 156
       E0 20 20 20 
0440C9 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ;  #9D 157
       50 50 50 50 
0440D1 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ;  #9E 158
       D0 50 50 50 
0440D9 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ;  #9F 159
       FC 20 20 20 
0440E1 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ;  #A0 160
       50 50 50 50 
0440E9 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ;  #A1 161
       DC 50 50 50 
0440F1 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ;  #A2 162
       FC 00 00 00 
0440F9 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ;  #A3 163
       00 00 00 00 
044101 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ;  #A4 164
       FC 00 00 00 
044109 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ;  #A5 165
       FC 20 20 20 
044111 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ;  #A6 166
       50 50 50 50 
044119 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ;  #A7 167
       DC 50 50 50 
044121 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ;  #A8 168
       00 00 00 00 
044129 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ;  #A9 169
       00 00 FC FC 
044131 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ;  #AA 170
       FC FC FC FC 
044139 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ;  #AB 171
       C0 C0 C0 C0 
044141 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ;  #AC 172
       0C 0C 0C 0C 
044149 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ;  #AD 173
       A8 00 A8 00 
044151 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ;  #AE 174
       A8 54 A8 54 
044159 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ;  #AF 175
       54 FC 54 FC 
044161             0049   	include "src/asm/levels.inc"
044161 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
044162 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044172 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
044182 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044192 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441A2 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
0441B2 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0441C2 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441D2 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
0441E2 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
0441F2 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044202 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
044212 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
044222 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
044232 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
044242 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044252 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
044262 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
044272 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044282 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044292 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
0442A2 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
0442B2 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
0442C2 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
0442D2 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0442E2 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
0442F2 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044302 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044312 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044322 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044332 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044342 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
044352 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044362 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044372 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044382 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044392 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0443A2 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443B2 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443C2 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0443D2 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0443E2 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0443F2 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044402 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044412 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044422 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044432 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044442 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044452 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044462 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044472 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044482 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044492 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0444A2 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0444B2 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0444C2 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444D2 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444E2 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0444F2 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044502 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044512 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044522 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044532 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044542 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044552 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044562 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044572 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
044582 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044592 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0445A2 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0445B2 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
0445C2 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
0445D2 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
0445E2 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0445F2 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044602 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044612 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044622 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044632 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044642 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044652 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044662 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044672 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044682 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044692 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0446A2 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446B2 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446C2 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0446D2 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
0446E2 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
0446F2 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044702 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044712 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044722 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
044732 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
044742 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
044752 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
044762 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044772 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044782 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
044792 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447A2 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447B2 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447C2 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447D2 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447E2 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447F2 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044802 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044812 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044822 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044832 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044842 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044852 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
044862 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044872 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044882 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044892 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
0448A2 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
0448B2 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0448C2 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448D2 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448E2 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0448F2 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
044902 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
044912 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044922 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044932 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044942 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044952 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044962 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044972 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044982 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
044992 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
0449A2 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0449B2 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449C2 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449D2 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449E2 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449F2 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A02 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044A12 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
044A22 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
044A32 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044A42 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A52 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A62 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044A72 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
044A82 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
044A92 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
044AA2 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AB2 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AC2 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044AD2 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
044AE2 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
044AF2 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044B02 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B12 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B22 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044B32 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B42 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B52 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
044B62 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
044B72 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
044B82 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
044B92 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BA2 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BB2 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
044BC2 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
044BD2 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
044BE2 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
044BF2 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C02 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C12 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C22 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C32 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C42 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C52 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C62 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C72 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C82 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C92 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CA2 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CB2 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044CC2 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CD2 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CE2 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044CF2 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D02 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D12 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044D22 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D32 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D42 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044D52 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D62 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D72 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044D82 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044D92 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044DA2 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044DB2 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DC2 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DD2 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044DE2 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044DF2 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044E02 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044E12 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E22 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E32 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
044E42 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E52 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E62 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044E72 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E82 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E92 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
044EA2 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
044EB2 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
044EC2 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
044ED2 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
044EE2 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
044EF2 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
044F02 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
044F12 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F22 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F32 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044F42 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F52 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F62 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
044F72 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F82 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F92 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044FA2 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FB2 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FC2 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044FD2 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FE2 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FF2 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
045002 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045012 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045022 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
045032 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045042 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045052 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
045062 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045072 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045082 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
045092 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450A2 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450B2 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0450C2 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450D2 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450E2 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0450F2 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045102 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045112 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
045122 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
045132 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
045142 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
045152 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045162             0258*  
045162             0259*  
045162 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
045163 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045173 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045183 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045193 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451A3 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451B3 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451C3 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451D3 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451E3 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451F3 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045203 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045213 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045223 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045233 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045243 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045253 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045263             0277*  
045263             0050   	include "src/asm/sprites.inc"
045263             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
045263             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
045263             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
045263             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
045263             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
045263             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
045263             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
045263             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
045263             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
045263             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
045263             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
045263             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045263             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045263             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
045263             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
045263             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
045263             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
045263             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
045263             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
045263             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
045263             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
045263             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
045263             0023*  
045263             0024*  ; ###### SPRITE TABLE VARIABLES ######
045263             0025*  ; maximum number of sprites
045263             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
045263             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
045263             0028*  
045263             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
045263             0030*  table_base:
045263 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0452FB             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0452FB             0033*  
0452FB             0034*  ; pointer to top address of current record, initialized to table_base
0452FB 63 52 04    0035*  table_pointer: dl table_base
0452FE             0036*  ; how many active sprites
0452FE 00          0037*  table_active_sprites: db 0x00
0452FF             0038*  ; flag indicating collision with screen edge
0452FF             0039*  ; uses orientation codes to specify which edge(s)
0452FF 00          0040*  sprite_screen_edge: db #00
045300             0041*  ; next sprite id to use
045300 00          0042*  sprite_next_id: db 0
045301             0043*  
045301             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
045301             0045*  ; integer coordinates are all that are needed for collision calculations
045301 00          0046*  collision_x: db 0x00
045302 00          0047*  collision_y: db 0x00
045303 00          0048*  collision_dim_x: db 0x00
045304 00          0049*  collision_dim_y: db 0x00
045305             0050*  
045305             0051*  ; scratch variables
045305 00          0052*  x: db 0x00 ; 8-bit signed integer
045306 00          0053*  y: db 0x00 ; 8-bit signed integer
045307 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
04530A 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04530D 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
045310 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
045313 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
045316 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
045319             0060*  
045319             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
045319 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04531C 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04531F 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
045322             0065*  
045322             0066*  ; gets the next available sprite id
045322             0067*  ; inputs; none
045322             0068*  ; returns: if new sprite available, a = sprite id,
045322             0069*  ;           ix pointing to new sprite vars, carry set
045322             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
045322             0071*  ; destroys: a,b,hl,ix
045322             0072*  ; affects: bumps table_active_sprites by one
045322             0073*  table_get_next_id:
045322 DD 21 63 52 0074*      ld ix,table_base
       04          
045327 11 26 00 00 0075*      ld de,table_bytes_per_record
04532B 06 04       0076*      ld b,table_max_records
04532D             0077*  @loop:
04532D DD 7E 01    0078*      ld a,(ix+sprite_type)
045330 A7          0079*      and a
045331 28 06       0080*      jr z,@found
045333 DD 19       0081*      add ix,de
045335 10 F6       0082*      djnz @loop
045337             0083*  @notfound:
045337 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
045338 C9          0085*      ret
045339             0086*  @found:
045339             0087*  ; bump number of active sprites
045339 21 FE 52 04 0088*      ld hl,table_active_sprites
04533D 34          0089*      inc (hl)
04533E             0090*  ; return sprite id
04533E 3E 04       0091*      ld a,table_max_records
045340 90          0092*      sub b
045341 32 00 53 04 0093*      ld (sprite_next_id),a
045345 37          0094*      scf ; sets carry flag indicating we found a free sprite
045346 C9          0095*      ret ; done
045347             0096*  
045347             0097*  ; deactivate the sprite with the given id
045347             0098*  ; inputs: a = sprite id
045347             0099*  ; outputs: nothing
045347             0100*  ; destroys: a,ix,de
045347             0101*  ; affects: decrements table_active_sprites by one
045347             0102*  table_deactivate_sprite:
045347 F5          0103*      push af ; save sprite id bc we need it later
045348 CD 09 5C 04 0104*      call vdu_sprite_select
04534C CD 8D 5C 04 0105*      call vdu_sprite_hide
045350 F1          0106*      pop af ; restore sprite id
045351 11 00 00 00 0107*      ld de,0 ; clear deu
045355 57          0108*      ld d,a
045356 1E 26       0109*      ld e,table_bytes_per_record
045358 ED 5C       0110*      mlt de
04535A DD 21 63 52 0111*      ld ix,table_base
       04          
04535F DD 19       0112*      add ix,de
045361 AF          0113*      xor a
045362 DD 77 01    0114*      ld (ix+sprite_type),a
045365 DD 21 FE 52 0115*      ld ix,table_active_sprites
       04          
04536A DD 35 00    0116*      dec (ix)
04536D C9          0117*      ret
04536E             0051   ; API includes
04536E             0052       include "src/asm/mos_api.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04536E             0002*  ; Title:	AGON MOS - API for user projects
04536E             0003*  ; Author:	Dean Belfield
04536E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04536E             0005*  ;			Added MOS error codes for return in HL
04536E             0006*  ; Created:	03/08/2022
04536E             0007*  ; Last Updated:	10/08/2023
04536E             0008*  ;
04536E             0009*  ; Modinfo:
04536E             0010*  ; 05/08/2022:	Added mos_feof
04536E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04536E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04536E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04536E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04536E             0015*  ; 13/10/2022:	Added mos_oscli
04536E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04536E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04536E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04536E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04536E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04536E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04536E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04536E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04536E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04536E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04536E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04536E             0027*  ; 03/08/2023:	Added mos_setkbvector
04536E             0028*  ; 10/08/2023:	Added mos_getkbmap
04536E             0029*  
04536E             0030*  ; VDP control (VDU 23, 0, n)
04536E             0031*  ;
04536E             0032*  vdp_gp:				EQU 80h
04536E             0033*  vdp_keycode:		EQU 81h
04536E             0034*  vdp_cursor:			EQU	82h
04536E             0035*  vdp_scrchar:		EQU	83h
04536E             0036*  vdp_scrpixel:		EQU	84h
04536E             0037*  vdp_audio:			EQU	85h
04536E             0038*  vdp_mode:			EQU	86h
04536E             0039*  vdp_rtc:			EQU	87h
04536E             0040*  vdp_keystate:		EQU	88h
04536E             0041*  vdp_logicalcoords:	EQU	C0h
04536E             0042*  vdp_terminalmode:	EQU	FFh
04536E             0043*  
04536E             0044*  ; MOS high level functions
04536E             0045*  ;
04536E             0046*  mos_getkey:			EQU	00h
04536E             0047*  mos_load:			EQU	01h
04536E             0048*  mos_save:			EQU	02h
04536E             0049*  mos_cd:				EQU	03h
04536E             0050*  mos_dir:			EQU	04h
04536E             0051*  mos_del:			EQU	05h
04536E             0052*  mos_ren:			EQU	06h
04536E             0053*  mos_mkdir:			EQU	07h
04536E             0054*  mos_sysvars:		EQU	08h
04536E             0055*  mos_editline:		EQU	09h
04536E             0056*  mos_fopen:			EQU	0Ah
04536E             0057*  mos_fclose:			EQU	0Bh
04536E             0058*  mos_fgetc:			EQU	0Ch
04536E             0059*  mos_fputc:			EQU	0Dh
04536E             0060*  mos_feof:			EQU	0Eh
04536E             0061*  mos_getError:		EQU	0Fh
04536E             0062*  mos_oscli:			EQU	10h
04536E             0063*  mos_copy:			EQU	11h
04536E             0064*  mos_getrtc:			EQU	12h
04536E             0065*  mos_setrtc:			EQU	13h
04536E             0066*  mos_setintvector:	EQU	14h
04536E             0067*  mos_uopen:			EQU	15h
04536E             0068*  mos_uclose:			EQU	16h
04536E             0069*  mos_ugetc:			EQU	17h
04536E             0070*  mos_uputc:			EQU	18h
04536E             0071*  mos_getfil:			EQU	19h
04536E             0072*  mos_fread:			EQU	1Ah
04536E             0073*  mos_fwrite:			EQU	1Bh
04536E             0074*  mos_flseek:			EQU	1Ch
04536E             0075*  mos_setkbvector:	EQU	1Dh
04536E             0076*  mos_getkbmap:		EQU	1Eh
04536E             0077*  
04536E             0078*  ; MOS program exit codes
04536E             0079*  ;
04536E             0080*  EXIT_OK:				EQU  0;	"OK",
04536E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04536E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04536E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04536E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04536E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04536E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04536E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04536E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04536E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04536E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04536E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04536E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04536E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04536E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04536E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04536E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04536E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04536E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04536E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04536E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04536E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04536E             0102*  ; FatFS file access functions
04536E             0103*  ;
04536E             0104*  ffs_fopen:			EQU	80h
04536E             0105*  ffs_fclose:			EQU	81h
04536E             0106*  ffs_fread:			EQU	82h
04536E             0107*  ffs_fwrite:			EQU	83h
04536E             0108*  ffs_flseek:			EQU	84h
04536E             0109*  ffs_ftruncate:		EQU	85h
04536E             0110*  ffs_fsync:			EQU	86h
04536E             0111*  ffs_fforward:		EQU	87h
04536E             0112*  ffs_fexpand:		EQU	88h
04536E             0113*  ffs_fgets:			EQU	89h
04536E             0114*  ffs_fputc:			EQU	8Ah
04536E             0115*  ffs_fputs:			EQU	8Bh
04536E             0116*  ffs_fprintf:		EQU	8Ch
04536E             0117*  ffs_ftell:			EQU	8Dh
04536E             0118*  ffs_feof:			EQU	8Eh
04536E             0119*  ffs_fsize:			EQU	8Fh
04536E             0120*  ffs_ferror:			EQU	90h
04536E             0121*  
04536E             0122*  ; FatFS directory access functions
04536E             0123*  ;
04536E             0124*  ffs_dopen:			EQU	91h
04536E             0125*  ffs_dclose:			EQU	92h
04536E             0126*  ffs_dread:			EQU	93h
04536E             0127*  ffs_dfindfirst:		EQU	94h
04536E             0128*  ffs_dfindnext:		EQU	95h
04536E             0129*  
04536E             0130*  ; FatFS file and directory management functions
04536E             0131*  ;
04536E             0132*  ffs_stat:			EQU	96h
04536E             0133*  ffs_unlink:			EQU	97h
04536E             0134*  ffs_rename:			EQU	98h
04536E             0135*  ffs_chmod:			EQU	99h
04536E             0136*  ffs_utime:			EQU	9Ah
04536E             0137*  ffs_mkdir:			EQU	9Bh
04536E             0138*  ffs_chdir:			EQU	9Ch
04536E             0139*  ffs_chdrive:		EQU	9Dh
04536E             0140*  ffs_getcwd:			EQU	9Eh
04536E             0141*  
04536E             0142*  ; FatFS volume management and system configuration functions
04536E             0143*  ;
04536E             0144*  ffs_mount:			EQU	9Fh
04536E             0145*  ffs_mkfs:			EQU	A0h
04536E             0146*  ffs_fdisk:			EQU	A1h
04536E             0147*  ffs_getfree:		EQU	A2h
04536E             0148*  ffs_getlabel:		EQU	A3h
04536E             0149*  ffs_setlabel:		EQU	A4h
04536E             0150*  ffs_setcp:			EQU	A5h
04536E             0151*  
04536E             0152*  ; File access modes
04536E             0153*  ;
04536E             0154*  fa_read:			EQU	01h
04536E             0155*  fa_write:			EQU	02h
04536E             0156*  fa_open_existing:	EQU	00h
04536E             0157*  fa_create_new:		EQU	04h
04536E             0158*  fa_create_always:	EQU	08h
04536E             0159*  fa_open_always:		EQU	10h
04536E             0160*  fa_open_append:		EQU	30h
04536E             0161*  
04536E             0162*  ; System variable indexes for api_sysvars
04536E             0163*  ; Index into _sysvars in globals.inc
04536E             0164*  ;
04536E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04536E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04536E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04536E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04536E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04536E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04536E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04536E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04536E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04536E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04536E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04536E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04536E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04536E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04536E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04536E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04536E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04536E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04536E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04536E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04536E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04536E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04536E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04536E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04536E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04536E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04536E             0191*  
04536E             0192*  ; Flags for the VPD protocol
04536E             0193*  ;
04536E             0194*  vdp_pflag_cursor:		EQU	00000001b
04536E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04536E             0196*  vdp_pflag_point:		EQU	00000100b
04536E             0197*  vdp_pflag_audio:		EQU	00001000b
04536E             0198*  vdp_pflag_mode:			EQU	00010000b
04536E             0199*  vdp_pflag_rtc:			EQU	00100000b
04536E             0200*  
04536E             0201*  ;
04536E             0202*  ; FatFS structures
04536E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04536E             0204*  ;
04536E             0205*  ; Object ID and allocation information (FFOBJID)
04536E             0206*  ;
04536E             0207*  ; Indexes into FFOBJID structure
04536E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04536E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04536E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04536E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04536E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04536E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04536E             0214*  ;
04536E             0215*  ; File object structure (FIL)
04536E             0216*  ;
04536E             0217*  ; Indexes into FIL structure
04536E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04536E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04536E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04536E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04536E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04536E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04536E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04536E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04536E             0226*  ;
04536E             0227*  ; Directory object structure (DIR)
04536E             0228*  ; Indexes into DIR structure
04536E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04536E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04536E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04536E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04536E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04536E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04536E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04536E             0236*  ;
04536E             0237*  ; File information structure (FILINFO)
04536E             0238*  ;
04536E             0239*  ; Indexes into FILINFO structure
04536E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04536E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04536E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04536E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04536E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04536E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04536E             0246*  ;
04536E             0247*  ; Macro for calling the API
04536E             0248*  ; Parameters:
04536E             0249*  ; - function: One of the function numbers listed above
04536E             0250*  ;
04536E             0251*  	MACRO	MOSCALL	function
04536E             0252*  			LD	A, function
04536E             0253*  			RST.LIL	08h
04536E             0254*  	ENDMACRO
04536E             0053       include "src/asm/functions.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04536E             0002*  ; Print a zero-terminated string
04536E             0003*  ; HL: Pointer to string
04536E             0004*  printString:
04536E C5          0005*  	PUSH	BC
04536F 01 00 00 00 0006*  	LD		BC,0
045373 3E 00       0007*  	LD 	 	A,0
045375 5B DF       0008*  	RST.LIL 18h
045377 C1          0009*  	POP		BC
045378 C9          0010*  	RET
045379             0011*  ; print a VDU sequence
045379             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
045379             0013*  sendVDUsequence:
045379 C5          0014*  	PUSH	BC
04537A 01 00 00 00 0015*  	LD		BC, 0
04537E 4E          0016*  	LD		C, (HL)
04537F 5B DF       0017*  	RST.LIL	18h
045381 C1          0018*  	POP		BC
045382 C9          0019*  	RET
045383             0020*  ; Print Newline sequence to VDP
045383             0021*  printNewLine:
045383 3E 0D       0022*  	LD	A, '\r'
045385 5B D7       0023*  	RST.LIL 10h
045387 3E 0A       0024*  	LD	A, '\n'
045389 5B D7       0025*  	RST.LIL 10h
04538B C9          0026*  	RET
04538C             0027*  ; Print a 24-bit HEX number
04538C             0028*  ; HLU: Number to print
04538C             0029*  printHex24:
04538C E5          0030*  	PUSH	HL
04538D 21 02 00 00 0031*  	LD		HL, 2
045391 39          0032*  	ADD		HL, SP
045392 7E          0033*  	LD		A, (HL)
045393 E1          0034*  	POP		HL
045394 CD 9E 53 04 0035*  	CALL	printHex8
045398             0036*  ; Print a 16-bit HEX number
045398             0037*  ; HL: Number to print
045398             0038*  printHex16:
045398 7C          0039*  	LD		A,H
045399 CD 9E 53 04 0040*  	CALL	printHex8
04539D 7D          0041*  	LD		A,L
04539E             0042*  ; Print an 8-bit HEX number
04539E             0043*  ; A: Number to print
04539E             0044*  printHex8:
04539E 4F          0045*  	LD		C,A
04539F 1F          0046*  	RRA
0453A0 1F          0047*  	RRA
0453A1 1F          0048*  	RRA
0453A2 1F          0049*  	RRA
0453A3 CD A8 53 04 0050*  	CALL	@F
0453A7 79          0051*  	LD		A,C
0453A8             0052*  @@:
0453A8 E6 0F       0053*  	AND		0Fh
0453AA C6 90       0054*  	ADD		A,90h
0453AC 27          0055*  	DAA
0453AD CE 40       0056*  	ADC		A,40h
0453AF 27          0057*  	DAA
0453B0 5B D7       0058*  	RST.LIL	10h
0453B2 C9          0059*  	RET
0453B3             0060*  
0453B3             0061*  ; Print a 0x HEX prefix
0453B3             0062*  DisplayHexPrefix:
0453B3 3E 30       0063*  	LD	A, '0'
0453B5 5B D7       0064*  	RST.LIL 10h
0453B7 3E 78       0065*  	LD	A, 'x'
0453B9 5B D7       0066*  	RST.LIL 10h
0453BB C9          0067*  	RET
0453BC             0068*  
0453BC             0069*  
0453BC             0070*  ; Prints the right justified decimal value in HL without leading zeroes
0453BC             0071*  ; HL : Value to print
0453BC             0072*  printDec:
0453BC 11 E0 53 04 0073*  	LD	 DE, _printDecBuffer
0453C0 CD E9 53 04 0074*  	CALL Num2String
0453C4             0075*  ; BEGIN MY CODE
0453C4             0076*  ; replace leading zeroes with spaces
0453C4 21 E0 53 04 0077*      LD	 HL, _printDecBuffer
0453C8 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0453CA             0079*  @loop:
0453CA 7E          0080*      LD	 A, (HL)
0453CB FE 30       0081*      CP	 '0'
0453CD C2 DB 53 04 0082*      JP	 NZ, @done
0453D1 3E 20       0083*      LD   A, ' '
0453D3 77          0084*      LD	 (HL), A
0453D4 23          0085*      INC	 HL
0453D5 CD 99 57 04 0086*      CALL vdu_cursor_forward
0453D9 10 EF       0087*      DJNZ @loop
0453DB             0088*  @done:
0453DB             0089*  ; END MY CODE
0453DB             0090*  	; LD	 HL, _printDecBuffer
0453DB CD 6E 53 04 0091*  	CALL printString
0453DF C9          0092*  	RET
0453E0 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0453E9             0094*  
0453E9             0095*  ; This routine converts the value from HL into it's ASCII representation,
0453E9             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0453E9             0097*  ; so it will allways be 8 characters length
0453E9             0098*  ; HL : Value to convert to string
0453E9             0099*  ; DE : pointer to buffer, at least 8 byte + 0
0453E9             0100*  Num2String:
0453E9 01 80 69 67 0101*  	LD	 BC,-10000000
0453ED CD 20 54 04 0102*  	CALL OneDigit
0453F1 01 C0 BD F0 0103*  	LD	 BC,-1000000
0453F5 CD 20 54 04 0104*  	CALL OneDigit
0453F9 01 60 79 FE 0105*  	LD	 BC,-100000
0453FD CD 20 54 04 0106*  	CALL OneDigit
045401 01 F0 D8 FF 0107*  	LD   BC,-10000
045405 CD 20 54 04 0108*  	CALL OneDigit
045409 01 18 FC FF 0109*  	LD   BC,-1000
04540D CD 20 54 04 0110*  	CALL OneDigit
045411 01 9C FF FF 0111*  	LD   BC,-100
045415 CD 20 54 04 0112*  	CALL OneDigit
045419 0E F6       0113*  	LD   C,-10
04541B CD 20 54 04 0114*  	CALL OneDigit
04541F 48          0115*  	LD   C,B
045420             0116*  OneDigit:
045420 3E 2F       0117*  	LD   A,'0'-1
045422             0118*  DivideMe:
045422 3C          0119*  	INC  A
045423 09          0120*  	ADD  HL,BC
045424 38 FC       0121*  	JR   C,DivideMe
045426 ED 42       0122*  	SBC  HL,BC
045428 12          0123*  	LD   (DE),A
045429 13          0124*  	INC  DE
04542A C9          0125*  	RET
04542B             0126*  
04542B             0127*  
04542B             0128*  ; #### new functions added by Brandon R. Gates ####
04542B             0129*  
04542B             0130*  ; print the binary representation of the 8-bit value in a
04542B             0131*  ; destroys a, hl, bc
04542B             0132*  printBin8:
04542B 06 08       0133*      ld b,8      ; loop counter for 8 bits
04542D 21 48 54 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
045431             0135*                  ; (which will be the high bit of the value in a)
045431             0136*  @loop:
045431 07          0137*      rlca ; put the next highest bit into carry
045432 38 04       0138*      jr c,@one
045434 36 30       0139*      ld (hl),'0'
045436 18 02       0140*      jr @next_bit
045438             0141*  @one:
045438 36 31       0142*      ld (hl),'1'
04543A             0143*  @next_bit:
04543A 23          0144*      inc hl
04543B 10 F4       0145*      djnz @loop
04543D             0146*  ; print it
04543D 21 48 54 04 0147*  	ld hl,@cmd
045441 01 08 00 00 0148*  	ld bc,@end-@cmd
045445 5B DF       0149*  	rst.lil $18
045447 C9          0150*  	ret
045448             0151*  @cmd: ds 8 ; eight bytes for eight bits
045450             0152*  @end:
045450             0153*  
045450             0154*  ; print the binary representation of the 8-bit value in a
045450             0155*  ; in reverse order (lsb first)
045450             0156*  ; destroys a, hl, bc
045450             0157*  printBin8Rev:
045450 06 08       0158*      ld b,8      ; loop counter for 8 bits
045452 21 6D 54 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
045456             0160*                  ; (which will be the high bit of the value in a)
045456             0161*  @loop:
045456 0F          0162*      rrca ; put the next lowest bit into carry
045457 38 04       0163*      jr c,@one
045459 36 30       0164*      ld (hl),'0'
04545B 18 02       0165*      jr @next_bit
04545D             0166*  @one:
04545D 36 31       0167*      ld (hl),'1'
04545F             0168*  @next_bit:
04545F 23          0169*      inc hl
045460 10 F4       0170*      djnz @loop
045462             0171*  ; print it
045462 21 6D 54 04 0172*  	ld hl,@cmd
045466 01 08 00 00 0173*  	ld bc,@end-@cmd
04546A 5B DF       0174*  	rst.lil $18
04546C C9          0175*  	ret
04546D             0176*  @cmd: ds 8 ; eight bytes for eight bits
045475             0177*  @end:
045475             0178*  
045475             0179*  ; print registers to screen in hexidecimal format
045475             0180*  ; inputs: none
045475             0181*  ; outputs: values of every register printed to screen
045475             0182*  ;    values of each register in global scratch memory
045475             0183*  ; destroys: nothing
045475             0184*  stepRegistersHex:
045475             0185*  ; store everything in scratch
045475 22 74 56 04 0186*      ld (uhl),hl
045479 ED 43 77 56 0187*      ld (ubc),bc
       04          
04547E ED 53 7A 56 0188*      ld (ude),de
       04          
045483 DD 22 7D 56 0189*      ld (uix),ix
       04          
045488 FD 22 80 56 0190*      ld (uiy),iy
       04          
04548D F5          0191*      push af ; fml
04548E E1          0192*      pop hl  ; thanks, zilog
04548F 22 71 56 04 0193*      ld (uaf),hl
045493 F5          0194*      push af ; dammit
045494             0195*  
045494             0196*  ; home the cursor
045494 CD 67 57 04 0197*      call vdu_home_cursor
045498             0198*  
045498             0199*  ; print each register
045498 21 FD 55 04 0200*      ld hl,str_afu
04549C CD 6E 53 04 0201*      call printString
0454A0 2A 71 56 04 0202*      ld hl,(uaf)
0454A4 CD 8C 53 04 0203*      call printHex24
0454A8 CD 83 53 04 0204*      call printNewLine
0454AC             0205*  
0454AC 21 01 56 04 0206*      ld hl,str_hlu
0454B0 CD 6E 53 04 0207*      call printString
0454B4 2A 74 56 04 0208*      ld hl,(uhl)
0454B8 CD 8C 53 04 0209*      call printHex24
0454BC CD 83 53 04 0210*      call printNewLine
0454C0             0211*  
0454C0 21 05 56 04 0212*      ld hl,str_bcu
0454C4 CD 6E 53 04 0213*      call printString
0454C8 2A 77 56 04 0214*      ld hl,(ubc)
0454CC CD 8C 53 04 0215*      call printHex24
0454D0 CD 83 53 04 0216*      call printNewLine
0454D4             0217*  
0454D4 21 09 56 04 0218*      ld hl,str_deu
0454D8 CD 6E 53 04 0219*      call printString
0454DC 2A 7A 56 04 0220*      ld hl,(ude)
0454E0 CD 8C 53 04 0221*      call printHex24
0454E4 CD 83 53 04 0222*      call printNewLine
0454E8             0223*  
0454E8 21 0D 56 04 0224*      ld hl,str_ixu
0454EC CD 6E 53 04 0225*      call printString
0454F0 2A 7D 56 04 0226*      ld hl,(uix)
0454F4 CD 8C 53 04 0227*      call printHex24
0454F8 CD 83 53 04 0228*      call printNewLine
0454FC             0229*  
0454FC 21 11 56 04 0230*      ld hl,str_iyu
045500 CD 6E 53 04 0231*      call printString
045504 2A 80 56 04 0232*      ld hl,(uiy)
045508 CD 8C 53 04 0233*      call printHex24
04550C CD 83 53 04 0234*      call printNewLine
045510             0235*  
045510             0236*      ; call vdu_vblank
045510             0237*  
045510 CD 83 53 04 0238*      call printNewLine
045514             0239*  
045514             0240*  ; check for right shift key and quit if pressed
045514             0241*  	MOSCALL mos_getkbmap
045514 3E 1E       0001*M 			LD	A, function
045516 5B CF       0002*M 			RST.LIL	08h
045518             0242*  @stayhere:
045518             0243*  ; 7 RightShift
045518 DD CB 00 76 0244*      bit 6,(ix+0)
04551C 20 02       0245*      jr nz,@RightShift
04551E 18 F8       0246*      jr @stayhere
045520             0247*  @RightShift:
045520 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
045524 3E 80       0249*      ld a,%10000000
045526 CD 40 6E 04 0250*      call multiPurposeDelay
04552A             0251*  
04552A             0252*  ; restore everything
04552A 2A 74 56 04 0253*      ld hl, (uhl)
04552E ED 4B 77 56 0254*      ld bc, (ubc)
       04          
045533 ED 5B 7A 56 0255*      ld de, (ude)
       04          
045538 DD 2A 7D 56 0256*      ld ix, (uix)
       04          
04553D FD 2A 80 56 0257*      ld iy, (uiy)
       04          
045542 F1          0258*      pop af
045543             0259*  ; all done
045543 C9          0260*      ret
045544             0261*  
045544             0262*  ; print registers to screen in hexidecimal format
045544             0263*  ; inputs: none
045544             0264*  ; outputs: values of every register printed to screen
045544             0265*  ;    values of each register in global scratch memory
045544             0266*  ; destroys: nothing
045544             0267*  dumpRegistersHex:
045544             0268*  ; store everything in scratch
045544 22 74 56 04 0269*      ld (uhl),hl
045548 ED 43 77 56 0270*      ld (ubc),bc
       04          
04554D ED 53 7A 56 0271*      ld (ude),de
       04          
045552 DD 22 7D 56 0272*      ld (uix),ix
       04          
045557 FD 22 80 56 0273*      ld (uiy),iy
       04          
04555C F5          0274*      push af ; fml
04555D E1          0275*      pop hl  ; thanks, zilog
04555E 22 71 56 04 0276*      ld (uaf),hl
045562 F5          0277*      push af ; dammit
045563             0278*  
045563             0279*  ; home the cursor
045563 CD 67 57 04 0280*      call vdu_home_cursor
045567             0281*  
045567             0282*  ; print each register
045567 21 FD 55 04 0283*      ld hl,str_afu
04556B CD 6E 53 04 0284*      call printString
04556F 2A 71 56 04 0285*      ld hl,(uaf)
045573 CD 8C 53 04 0286*      call printHex24
045577 CD 83 53 04 0287*      call printNewLine
04557B             0288*  
04557B 21 01 56 04 0289*      ld hl,str_hlu
04557F CD 6E 53 04 0290*      call printString
045583 2A 74 56 04 0291*      ld hl,(uhl)
045587 CD 8C 53 04 0292*      call printHex24
04558B CD 83 53 04 0293*      call printNewLine
04558F             0294*  
04558F 21 05 56 04 0295*      ld hl,str_bcu
045593 CD 6E 53 04 0296*      call printString
045597 2A 77 56 04 0297*      ld hl,(ubc)
04559B CD 8C 53 04 0298*      call printHex24
04559F CD 83 53 04 0299*      call printNewLine
0455A3             0300*  
0455A3 21 09 56 04 0301*      ld hl,str_deu
0455A7 CD 6E 53 04 0302*      call printString
0455AB 2A 7A 56 04 0303*      ld hl,(ude)
0455AF CD 8C 53 04 0304*      call printHex24
0455B3 CD 83 53 04 0305*      call printNewLine
0455B7             0306*  
0455B7 21 0D 56 04 0307*      ld hl,str_ixu
0455BB CD 6E 53 04 0308*      call printString
0455BF 2A 7D 56 04 0309*      ld hl,(uix)
0455C3 CD 8C 53 04 0310*      call printHex24
0455C7 CD 83 53 04 0311*      call printNewLine
0455CB             0312*  
0455CB 21 11 56 04 0313*      ld hl,str_iyu
0455CF CD 6E 53 04 0314*      call printString
0455D3 2A 80 56 04 0315*      ld hl,(uiy)
0455D7 CD 8C 53 04 0316*      call printHex24
0455DB CD 83 53 04 0317*      call printNewLine
0455DF             0318*  
0455DF             0319*      ; call vdu_vblank
0455DF             0320*  
0455DF CD 83 53 04 0321*      call printNewLine
0455E3             0322*  ; restore everything
0455E3 2A 74 56 04 0323*      ld hl, (uhl)
0455E7 ED 4B 77 56 0324*      ld bc, (ubc)
       04          
0455EC ED 5B 7A 56 0325*      ld de, (ude)
       04          
0455F1 DD 2A 7D 56 0326*      ld ix, (uix)
       04          
0455F6 FD 2A 80 56 0327*      ld iy, (uiy)
       04          
0455FB F1          0328*      pop af
0455FC             0329*  ; all done
0455FC C9          0330*      ret
0455FD             0331*  
0455FD 61 66 3D 00 0332*  str_afu: db "af=",0
045601 68 6C 3D 00 0333*  str_hlu: db "hl=",0
045605 62 63 3D 00 0334*  str_bcu: db "bc=",0
045609 64 65 3D 00 0335*  str_deu: db "de=",0
04560D 69 78 3D 00 0336*  str_ixu: db "ix=",0
045611 69 79 3D 00 0337*  str_iyu: db "iy=",0
045615             0338*  
045615             0339*  ; print udeuhl to screen in hexidecimal format
045615             0340*  ; inputs: none
045615             0341*  ; outputs: concatenated hexidecimal udeuhl
045615             0342*  ; destroys: nothing
045615             0343*  dumpUDEUHLHex:
045615             0344*  ; store everything in scratch
045615 22 74 56 04 0345*      ld (uhl),hl
045619 ED 43 77 56 0346*      ld (ubc),bc
       04          
04561E ED 53 7A 56 0347*      ld (ude),de
       04          
045623 DD 22 7D 56 0348*      ld (uix),ix
       04          
045628 FD 22 80 56 0349*      ld (uiy),iy
       04          
04562D F5          0350*      push af
04562E             0351*  
04562E             0352*  ; print each register
04562E             0353*  
04562E 21 68 56 04 0354*      ld hl,str_udeuhl
045632 CD 6E 53 04 0355*      call printString
045636 2A 7A 56 04 0356*      ld hl,(ude)
04563A CD 8C 53 04 0357*      call printHex24
04563E 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
045640 5B D7       0359*  	rst.lil 10h
045642 2A 74 56 04 0360*      ld hl,(uhl)
045646 CD 8C 53 04 0361*      call printHex24
04564A CD 83 53 04 0362*      call printNewLine
04564E             0363*  
04564E             0364*  ; restore everything
04564E 2A 74 56 04 0365*      ld hl, (uhl)
045652 ED 4B 77 56 0366*      ld bc, (ubc)
       04          
045657 ED 5B 7A 56 0367*      ld de, (ude)
       04          
04565C DD 2A 7D 56 0368*      ld ix, (uix)
       04          
045661 FD 2A 80 56 0369*      ld iy, (uiy)
       04          
045666 F1          0370*      pop af
045667             0371*  ; all done
045667 C9          0372*      ret
045668             0373*  
045668 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
045671             0375*  
045671             0376*  ; global scratch memory for registers
045671 00 00 00    0377*  uaf: dl 0
045674 00 00 00    0378*  uhl: dl 0
045677 00 00 00    0379*  ubc: dl 0
04567A 00 00 00    0380*  ude: dl 0
04567D 00 00 00    0381*  uix: dl 0
045680 00 00 00    0382*  uiy: dl 0
045683 00 00 00    0383*  usp: dl 0
045686 00 00 00    0384*  upc: dl 0
045689             0385*  
045689             0386*  ; inputs: whatever is in the flags register
045689             0387*  ; outputs: binary representation of flags
045689             0388*  ;          with a header so we know which is what
045689             0389*  ; destroys: nothing
045689             0390*  ; preserves: everything
045689             0391*  dumpFlags:
045689             0392*  ; first we curse zilog for not giving direct access to flags
045689 F5          0393*      push af ; this is so we can send it back unharmed
04568A F5          0394*      push af ; this is so we can pop it to hl
04568B             0395*  ; store everything in scratch
04568B 22 74 56 04 0396*      ld (uhl),hl
04568F ED 43 77 56 0397*      ld (ubc),bc
       04          
045694 ED 53 7A 56 0398*      ld (ude),de
       04          
045699 DD 22 7D 56 0399*      ld (uix),ix
       04          
04569E FD 22 80 56 0400*      ld (uiy),iy
       04          
0456A3             0401*  ; next we print the header
0456A3 21 CF 56 04 0402*      ld hl,@header
0456A7 CD 6E 53 04 0403*      call printString
0456AB E1          0404*      pop hl ; flags are now in l
0456AC 7D          0405*      ld a,l ; flags are now in a
0456AD CD 2B 54 04 0406*      call printBin8
0456B1 CD 83 53 04 0407*  	call printNewLine
0456B5             0408*  ; restore everything
0456B5 2A 74 56 04 0409*      ld hl, (uhl)
0456B9 ED 4B 77 56 0410*      ld bc, (ubc)
       04          
0456BE ED 5B 7A 56 0411*      ld de, (ude)
       04          
0456C3 DD 2A 7D 56 0412*      ld ix, (uix)
       04          
0456C8 FD 2A 80 56 0413*      ld iy, (uiy)
       04          
0456CD F1          0414*      pop af ; send her home the way she came
0456CE C9          0415*      ret
0456CF             0416*  ; Bit 7 (S): Sign flag
0456CF             0417*  ; Bit 6 (Z): Zero flag
0456CF             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0456CF             0419*  ; Bit 4 (H): Half Carry flag
0456CF             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0456CF             0421*  ; Bit 2 (PV): Parity/Overflow flag
0456CF             0422*  ; Bit 1 (N): Subtract flag
0456CF             0423*  ; Bit 0 (C): Carry flag
0456CF 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0456DA             0425*  
0456DA             0426*  ; set all the bits in the flag register
0456DA             0427*  ; more of an academic exercise than anything useful
0456DA             0428*  ; inputs; none
0456DA             0429*  ; outputs; a=0,f=255
0456DA             0430*  ; destroys: flags, hl
0456DA             0431*  ; preserves: a, because why not
0456DA             0432*  setAllFlags:
0456DA 21 FF 00 00 0433*      ld hl,255
0456DE 67          0434*      ld h,a ; four cycles to preserve a is cheap
0456DF E5          0435*      push hl
0456E0 F1          0436*      pop af
0456E1 C9          0437*      ret
0456E2             0438*  
0456E2             0439*  ; reset all the bits in the flag register
0456E2             0440*  ; unlike its inverse counterpart, this may actually be useful
0456E2             0441*  ; inputs; none
0456E2             0442*  ; outputs; a=0,f=0
0456E2             0443*  ; destroys: flags, hl
0456E2             0444*  ; preserves: a, because why not
0456E2             0445*  resetAllFlags:
0456E2 21 00 00 00 0446*      ld hl,0
0456E6 67          0447*      ld h,a ; four cycles to preserve a is cheap
0456E7 E5          0448*      push hl
0456E8 F1          0449*      pop af
0456E9 C9          0450*      ret
0456EA             0451*  
0456EA             0452*  ; wait until user presses a key
0456EA             0453*  ; inputs: none
0456EA             0454*  ; outputs: none
0456EA             0455*  ; destroys: af,ix
0456EA             0456*  waitKeypress:
0456EA             0457*      MOSCALL mos_sysvars
0456EA 3E 08       0001*M 			LD	A, function
0456EC 5B CF       0002*M 			RST.LIL	08h
0456EE AF          0458*      xor a ; zero out any prior keypresses
0456EF DD 77 05    0459*      ld (ix+sysvar_keyascii),a
0456F2             0460*  @loop:
0456F2 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
0456F5 A7          0462*      and a
0456F6 C0          0463*      ret nz
0456F7 18 F9       0464*      jr @loop
0456F9             0465*  
0456F9             0466*  
0456F9             0467*  ; print bytes from an address to the screen in hexidecimal format
0456F9             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0456F9             0469*  ; outputs: values of each byte printed to screen separated by spaces
0456F9             0470*  ; destroys: nothing
0456F9             0471*  dumpMemoryHex:
0456F9             0472*  ; save all registers to the stack
0456F9 F5          0473*      push af
0456FA C5          0474*      push bc
0456FB D5          0475*      push de
0456FC E5          0476*      push hl
0456FD DD E5       0477*      push ix
0456FF FD E5       0478*      push iy
045701             0479*  
045701             0480*  ; set b to be our loop counter
045701 47          0481*      ld b,a
045702             0482*  @loop:
045702             0483*  ; print the byte
045702 7E          0484*      ld a,(hl)
045703 CD 9E 53 04 0485*      call printHex8
045707             0486*  ; print a space
045707 3E 20       0487*      ld a,' '
045709 5B D7       0488*      rst.lil 10h
04570B 23          0489*      inc hl
04570C 10 F4       0490*      djnz @loop
04570E CD 83 53 04 0491*      call printNewLine
045712             0492*  
045712             0493*  ; restore everything
045712 FD E1       0494*      pop iy
045714 DD E1       0495*      pop ix
045716 E1          0496*      pop hl
045717 D1          0497*      pop de
045718 C1          0498*      pop bc
045719 F1          0499*      pop af
04571A             0500*  ; all done
04571A C9          0501*      ret
04571B             0502*  
04571B             0503*  
04571B             0504*  ; print bytes from an address to the screen in binary format
04571B             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04571B             0506*  ; outputs: values of each byte printed to screen separated by spaces
04571B             0507*  ; destroys: nothing
04571B             0508*  dumpMemoryBin:
04571B             0509*  ; save all registers to the stack
04571B F5          0510*      push af
04571C C5          0511*      push bc
04571D D5          0512*      push de
04571E E5          0513*      push hl
04571F DD E5       0514*      push ix
045721 FD E5       0515*      push iy
045723             0516*  
045723             0517*  ; set b to be our loop counter
045723 47          0518*      ld b,a
045724             0519*  @loop:
045724             0520*  ; print the byte
045724 7E          0521*      ld a,(hl)
045725 E5          0522*      push hl
045726 C5          0523*      push bc
045727 CD 2B 54 04 0524*      call printBin8
04572B C1          0525*      pop bc
04572C             0526*  ; print a space
04572C 3E 20       0527*      ld a,' '
04572E 5B D7       0528*      rst.lil 10h
045730 E1          0529*      pop hl
045731 23          0530*      inc hl
045732 10 F0       0531*      djnz @loop
045734 CD 83 53 04 0532*      call printNewLine
045738             0533*  
045738             0534*  ; restore everything
045738 FD E1       0535*      pop iy
04573A DD E1       0536*      pop ix
04573C E1          0537*      pop hl
04573D D1          0538*      pop de
04573E C1          0539*      pop bc
04573F F1          0540*      pop af
045740             0541*  ; all done
045740 C9          0542*      ret
045741             0543*  
045741             0544*  ; print bytes from an address to the screen in binary format
045741             0545*  ; with the bits of each byte in reverse order (lsb first)
045741             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
045741             0547*  ; outputs: values of each byte printed to screen separated by spaces
045741             0548*  ; destroys: nothing
045741             0549*  dumpMemoryBinRev:
045741             0550*  ; save all registers to the stack
045741 F5          0551*      push af
045742 C5          0552*      push bc
045743 D5          0553*      push de
045744 E5          0554*      push hl
045745 DD E5       0555*      push ix
045747 FD E5       0556*      push iy
045749             0557*  
045749             0558*  ; set b to be our loop counter
045749 47          0559*      ld b,a
04574A             0560*  @loop:
04574A             0561*  ; print the byte
04574A 7E          0562*      ld a,(hl)
04574B E5          0563*      push hl
04574C C5          0564*      push bc
04574D CD 50 54 04 0565*      call printBin8Rev
045751 C1          0566*      pop bc
045752             0567*  ; print a space
045752 3E 20       0568*      ld a,' '
045754 5B D7       0569*      rst.lil 10h
045756 E1          0570*      pop hl
045757 23          0571*      inc hl
045758 10 F0       0572*      djnz @loop
04575A CD 83 53 04 0573*      call printNewLine
04575E             0574*  
04575E             0575*  ; restore everything
04575E FD E1       0576*      pop iy
045760 DD E1       0577*      pop ix
045762 E1          0578*      pop hl
045763 D1          0579*      pop de
045764 C1          0580*      pop bc
045765 F1          0581*      pop af
045766             0582*  ; all done
045766 C9          0583*      ret
045767             0054       include "src/asm/vdu.inc"
045767             0001*  
045767             0002*  ; VDU 30: Home cursor
045767             0003*  vdu_home_cursor:
045767 3E 1E       0004*      ld a,30
045769 5B D7       0005*  	rst.lil $10
04576B C9          0006*  	ret
04576C             0007*  
04576C             0008*  vdu_cursor_on:
04576C 21 77 57 04 0009*  	ld hl,@cmd
045770 01 03 00 00 0010*  	ld bc,@end-@cmd
045774 5B DF       0011*  	rst.lil $18
045776 C9          0012*  	ret
045777             0013*  @cmd:
045777 17 01 01    0014*  	db 23,1,1
04577A             0015*  @end:
04577A             0016*  
04577A             0017*  vdu_cursor_off:
04577A 21 85 57 04 0018*  	ld hl,@cmd
04577E 01 03 00 00 0019*  	ld bc,@end-@cmd
045782 5B DF       0020*  	rst.lil $18
045784 C9          0021*  	ret
045785             0022*  @cmd:
045785 17 01 00    0023*  	db 23,1,0
045788             0024*  @end:
045788             0025*  
045788             0026*  ; VDU 5: Write text at graphics cursor
045788             0027*  ; inputs: a is the character to write to the screen
045788             0028*  ; prerequisites: the graphics cursor at the intended position on screen
045788             0029*  ; outputs: see the name of the function
045788             0030*  ; destroys: a, hl, bc
045788             0031*  vdu_char_to_gfx_cursor:
045788 32 98 57 04 0032*  	ld (@arg),a
04578C 21 97 57 04 0033*  	ld hl,@cmd
045790 01 02 00 00 0034*  	ld bc,@end-@cmd
045794 5B DF       0035*  	rst.lil $18
045796 C9          0036*  	ret
045797 05          0037*  @cmd: db 5
045798 00          0038*  @arg: db 0
045799             0039*  @end:
045799             0040*  ; VDU 9: Move cursor forward one character
045799             0041*  vdu_cursor_forward:
045799 3E 09       0042*      ld a,9
04579B 5B D7       0043*  	rst.lil $10
04579D C9          0044*  	ret
04579E             0045*  
04579E             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04579E             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
04579E             0048*  vdu_move_cursor:
04579E ED 43 AF 57 0049*      ld (@x0),bc
       04          
0457A3 21 AE 57 04 0050*  	ld hl,@cmd
0457A7 01 03 00 00 0051*  	ld bc,@end-@cmd
0457AB 5B DF       0052*  	rst.lil $18
0457AD C9          0053*  	ret
0457AE 1F          0054*  @cmd: 	db 31
0457AF 00          0055*  @x0:	db 0
0457B0 00          0056*  @y0: 	db 0
0457B1 00          0057*  @end: 	db 0 ; padding
0457B2             0058*  
0457B2             0059*  ; VDU 12: Clear text area (CLS)
0457B2             0060*  vdu_cls:
0457B2 3E 0C       0061*      ld a,12
0457B4 5B D7       0062*  	rst.lil $10
0457B6 C9          0063*  	ret
0457B7             0064*  
0457B7             0065*  vdu_flip:
0457B7 21 C2 57 04 0066*  	ld hl,@cmd
0457BB 01 03 00 00 0067*  	ld bc,@end-@cmd
0457BF 5B DF       0068*  	rst.lil $18
0457C1 C9          0069*  	ret
0457C2 17 00 C3    0070*  @cmd: db 23,0,0xC3
0457C5             0071*  @end:
0457C5             0072*  
0457C5             0073*  ; VDU 16: Clear graphics area (CLG)
0457C5             0074*  vdu_clg:
0457C5 3E 10       0075*      ld a,16
0457C7 5B D7       0076*  	rst.lil $10
0457C9 C9          0077*  	ret
0457CA             0078*  
0457CA             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0457CA             0080*  ; VDU 23, 7: Scrolling
0457CA             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0457CA             0082*  ; inputs: a, extent; l, direction; h; speed
0457CA             0083*  vdu_scroll_down:
0457CA 32 DF 57 04 0084*  	ld (@extent),a
0457CE 22 E0 57 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0457D2 21 DD 57 04 0086*  	ld hl,@cmd
0457D6 01 05 00 00 0087*  	ld bc,@end-@cmd
0457DA 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
0457DC C9          0089*  	ret
0457DD 17 07       0090*  @cmd:       db 23,7
0457DF 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0457E0 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0457E1 00          0093*  @speed:     db 0x00 ; pixels
0457E2 00          0094*  @end:		db 0x00 ; padding
0457E3             0095*  
0457E3             0096*  ; COLOUR MODES
0457E3             0097*  ; Mode	Effect
0457E3             0098*  ; 0	Set on-screen pixel to target colour value
0457E3             0099*  ; 1	OR value with the on-screen pixel
0457E3             0100*  ; 2	AND value with the on-screen pixel
0457E3             0101*  ; 3	XOR value with the on-screen pixel
0457E3             0102*  ; 4	Invert the on-screen pixel
0457E3             0103*  ; 5	No operation
0457E3             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0457E3             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0457E3             0106*  
0457E3             0107*  ; VDU 17, colour: Define text colour (COLOUR)
0457E3             0108*  vdu_colour_text:
0457E3 32 F3 57 04 0109*  	ld (@arg),a
0457E7 21 F2 57 04 0110*  	ld hl,@cmd
0457EB 01 02 00 00 0111*  	ld bc,@end-@cmd
0457EF 5B DF       0112*  	rst.lil $18
0457F1 C9          0113*  	ret
0457F2 11          0114*  @cmd: db 17
0457F3 00          0115*  @arg: db 0
0457F4             0116*  @end:
0457F4             0117*  
0457F4             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0457F4             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0457F4             0120*  vdu_gcol:
0457F4 32 09 58 04 0121*  	ld (@mode),a
0457F8 79          0122*      ld a,c
0457F9 32 0A 58 04 0123*      ld (@col),a
0457FD 21 08 58 04 0124*  	ld hl,@cmd
045801 01 03 00 00 0125*  	ld bc,@end-@cmd
045805 5B DF       0126*  	rst.lil $18
045807 C9          0127*  	ret
045808 12          0128*  @cmd:  db 18
045809 00          0129*  @mode: db 0
04580A 00          0130*  @col:  db 0
04580B             0131*  @end:
04580B             0132*  
04580B             0133*  
04580B             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
04580B             0135*  ; MIND THE LITTLE-ENDIANESS
04580B             0136*  ; inputs: c=left,b=bottom,e=right,d=top
04580B             0137*  ; outputs; nothing
04580B             0138*  ; destroys: a might make it out alive
04580B             0139*  vdu_set_txt_viewport:
04580B ED 43 21 58 0140*      ld (@lb),bc
       04          
045810 ED 53 23 58 0141*  	ld (@rt),de
       04          
045815 21 20 58 04 0142*  	ld hl,@cmd
045819 01 05 00 00 0143*  	ld bc,@end-@cmd
04581D 5B DF       0144*  	rst.lil $18
04581F C9          0145*  	ret
045820 1C          0146*  @cmd:   db 28 ; set text viewport command
045821 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
045823 00 00       0148*  @rt: 	dw 0x0000 ; set by de
045825 00          0149*  @end:   db 0x00	  ; padding
045826             0150*  
045826             0151*  ; Wait for VBLANK interrupt
045826             0152*  vdu_vblank:
045826 DD E5       0153*      PUSH 	IX
045828             0154*  	MOSCALL	mos_sysvars
045828 3E 08       0001*M 			LD	A, function
04582A 5B CF       0002*M 			RST.LIL	08h
04582C DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
04582F             0156*  @wait:
04582F DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
045832 28 FB       0158*      JR	Z, @wait
045834 DD E1       0159*      POP	IX
045836 C9          0160*      RET
045837             0161*  
045837             0162*  ; VDU 29, x; y;: Set graphics origin
045837             0163*  ; This command sets the graphics origin.
045837             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
045837             0165*  ; inputs: bc=x0,de=y0
045837             0166*  ; outputs; nothing
045837             0167*  ; destroys: a might make it out alive
045837             0168*  vdu_set_gfx_origin:
045837 ED 43 4D 58 0169*      ld (@x0),bc
       04          
04583C ED 53 4F 58 0170*      ld (@y0),de
       04          
045841 21 4C 58 04 0171*      ld hl,@cmd
045845 01 05 00 00 0172*      ld bc,@end-@cmd
045849 5B DF       0173*      rst.lil $18
04584B C9          0174*      ret
04584C 1D          0175*  @cmd:   db 29 ; set graphics origin command
04584D 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
04584F 00 00       0177*  @y0: 	dw 0x0000 ; set by de
045851 00          0178*  @end:   db 0x00	  ; padding
045852             0179*  
045852             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
045852             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
045852             0182*  ; 	because we have turned off logical screen scaling
045852             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
045852             0184*  ; outputs; nothing
045852             0185*  ; destroys: a might make it out alive
045852             0186*  vdu_set_gfx_viewport:
045852 ED 43 72 58 0187*      ld (@x0),bc
       04          
045857 FD 22 74 58 0188*      ld (@y1),iy
       04          
04585C DD 22 76 58 0189*  	ld (@x1),ix
       04          
045861 ED 53 78 58 0190*  	ld (@y0),de
       04          
045866 21 71 58 04 0191*  	ld hl,@cmd
04586A 01 09 00 00 0192*  	ld bc,@end-@cmd
04586E 5B DF       0193*  	rst.lil $18
045870 C9          0194*  	ret
045871 18          0195*  @cmd:   db 24 ; set graphics viewport command
045872 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
045874 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
045876 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
045878 00 00       0199*  @y0: 	dw 0x0000 ; set by de
04587A 00          0200*  @end:   db 0x00	  ; padding
04587B             0201*  
04587B             0202*  ; SCREEN MODES
04587B             0203*  ; ===============================
04587B             0204*  ; Mode  Horz  Vert  Cols  Refresh
04587B             0205*  ; ---   ----  ----  ----  -------
04587B             0206*  ; 11    320   240   2     60hz
04587B             0207*  ; 139   320   240   2     60hz
04587B             0208*  ; 23    512   384   2     60hz
04587B             0209*  ; 151   512   384   2     60hz
04587B             0210*  ; 6     640   240   2     60hz
04587B             0211*  ; 134   640   240   2     60hz
04587B             0212*  ; 2     640   480   2     60hz
04587B             0213*  ; 130   640   480   2     60hz
04587B             0214*  ; 17    800   600   2     60hz
04587B             0215*  ; 145   800   600   2     60hz
04587B             0216*  ; 18    1024  768   2     60hz
04587B             0217*  ; 146   1024  768   2     60hz
04587B             0218*  ; ---   ----  ----  ----  -------
04587B             0219*  ; 10    320   240   4     60hz
04587B             0220*  ; 138   320   240   4     60hz
04587B             0221*  ; 22    512   384   4     60hz
04587B             0222*  ; 150   512   384   4     60hz
04587B             0223*  ; 5     640   240   4     60hz
04587B             0224*  ; 133   640   240   4     60hz
04587B             0225*  ; 1     640   480   4     60hz
04587B             0226*  ; 129   640   480   4     60hz
04587B             0227*  ; 16    800   600   4     60hz
04587B             0228*  ; 19    1024  768   4     60hz
04587B             0229*  ; ---   ----  ----  ----  -------
04587B             0230*  ; 9     320   240   16    60hz
04587B             0231*  ; 137   320   240   16    60hz
04587B             0232*  ; 21    512   384   16    60hz
04587B             0233*  ; 149   512   384   16    60hz
04587B             0234*  ; 4     640   240   16    60hz
04587B             0235*  ; 132   640   240   16    60hz
04587B             0236*  ; 0     640   480   16    60hz
04587B             0237*  ; 7     n/a   n/a   16    60hz
04587B             0238*  ; ---   ----  ----  ----  -------
04587B             0239*  ; 8     320   240   64    60hz
04587B             0240*  ; 136   320   240   64    60hz
04587B             0241*  ; 20    512   384   64    60hz
04587B             0242*  ; 3     640   240   64    60hz
04587B             0243*  ; ---   ----  ----  ----  -------
04587B             0244*  vdu_set_screen_mode:
04587B 32 8B 58 04 0245*  	ld (@arg),a
04587F 21 8A 58 04 0246*  	ld hl,@cmd
045883 01 02 00 00 0247*  	ld bc,@end-@cmd
045887 5B DF       0248*  	rst.lil $18
045889 C9          0249*  	ret
04588A 16          0250*  @cmd: db 22 ; set screen mode
04588B 00          0251*  @arg: db 0  ; screen mode parameter
04588C             0252*  @end:
04588C             0253*  
04588C             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04588C             0255*  ; inputs: a is scaling mode, 1=on, 0=off
04588C             0256*  ; note: default setting on boot is scaling ON
04588C             0257*  vdu_set_scaling:
04588C 32 9E 58 04 0258*  	ld (@arg),a
045890 21 9B 58 04 0259*  	ld hl,@cmd
045894 01 04 00 00 0260*  	ld bc,@end-@cmd
045898 5B DF       0261*  	rst.lil $18
04589A C9          0262*  	ret
04589B 17 00 C0    0263*  @cmd: db 23,0,0xC0
04589E 00          0264*  @arg: db 0  ; scaling on/off
04589F             0265*  @end:
04589F             0266*  
04589F             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04589F             0268*  ; inputs: hl=bufferId
04589F             0269*  vdu_buff_select:
04589F 22 B1 58 04 0270*  	ld (@bufferId),hl
0458A3 21 AE 58 04 0271*  	ld hl,@cmd
0458A7 01 05 00 00 0272*  	ld bc,@end-@cmd
0458AB 5B DF       0273*  	rst.lil $18
0458AD C9          0274*  	ret
0458AE 17 1B 20    0275*  @cmd: db 23,27,0x20
0458B1 00 00       0276*  @bufferId: dw 0x0000
0458B3 00          0277*  @end: db 0x00 ; padding
0458B4             0278*  
0458B4             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0458B4             0280*  ; inputs: a=format; bc=width; de=height
0458B4             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0458B4             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0458B4             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0458B4             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0458B4             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0458B4             0286*  ; 3 	Reserved for internal use by VDP (native format)
0458B4             0287*  vdu_bmp_create:
0458B4 ED 43 D0 58 0288*      ld (@width),bc
       04          
0458B9 ED 53 D2 58 0289*      ld (@height),de
       04          
0458BE 32 D4 58 04 0290*      ld (@fmt),a
0458C2 21 CD 58 04 0291*  	ld hl,@cmd
0458C6 01 08 00 00 0292*  	ld bc,@end-@cmd
0458CA 5B DF       0293*  	rst.lil $18
0458CC C9          0294*  	ret
0458CD 17 1B 21    0295*  @cmd:       db 23,27,0x21
0458D0 00 00       0296*  @width:     dw 0x0000
0458D2 00 00       0297*  @height:    dw 0x0000
0458D4 00          0298*  @fmt:       db 0x00
0458D5             0299*  @end:
0458D5             0300*  
0458D5             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0458D5             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0458D5             0303*  vdu_load_img_rgba2_to_8:
0458D5             0304*  ; backup the target buffer id and image dimensions
0458D5 E5          0305*      push hl
0458D6 D5          0306*      push de
0458D7 C5          0307*      push bc
0458D8             0308*  ; load the rgba2 image to working buffer 65534
0458D8 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
0458DC CD DF 59 04 0310*  	call vdu_load_buffer_from_file
0458E0             0311*  ; restore the image dimensions and target buffer id
0458E0 C1          0312*      pop bc
0458E1 D1          0313*      pop de
0458E2 E1          0314*      pop hl
0458E3             0315*  ; fall through to vdu_rgba2_to_8
0458E3             0316*  
0458E3             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0458E3             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0458E3             0319*  ; the "expand bitmap" command is:
0458E3             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0458E3             0321*  ; and then to reverse the byte order to fix endian-ness:
0458E3             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0458E3             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0458E3             0324*  ; VDU 23,27,&20,targetBufferID%;
0458E3             0325*  ; VDU 23,27,&21,width%;height%;0
0458E3             0326*  ; -------------------------------------------------------------------
0458E3             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0458E3             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0458E3             0329*  vdu_rgba2_to_8:
0458E3             0330*  ; load the image dimensions and buffer id parameters
0458E3 ED 43 3F 59 0331*      ld (@width),bc
       04          
0458E8 ED 53 41 59 0332*      ld (@height),de
       04          
0458ED 22 24 59 04 0333*      ld (@bufferId0),hl
0458F1 22 31 59 04 0334*      ld (@bufferId2),hl
0458F5 22 3A 59 04 0335*      ld (@bufferId1),hl
0458F9             0336*  ; clean up bytes that got stomped on by the ID loads
0458F9 3E 48       0337*      ld a,0x48
0458FB 32 26 59 04 0338*      ld (@bufferId0+2),a
0458FF 3E 17       0339*      ld a,23
045901 32 3C 59 04 0340*      ld (@bufferId1+2),a
045905 3E 18       0341*      ld a,24
045907 32 33 59 04 0342*      ld (@bufferId2+2),a
04590B AF          0343*      xor a
04590C 32 43 59 04 0344*      ld (@height+2),a
045910             0345*  ; send the vdu command strings
045910 21 1B 59 04 0346*      ld hl,@beg
045914 01 29 00 00 0347*      ld bc,@end-@beg
045918 5B DF       0348*      rst.lil $18
04591A C9          0349*      ret
04591B             0350*  @beg:
04591B             0351*  ; Command 14: Consolidate blocks in a buffer
04591B             0352*  ; VDU 23, 0, &A0, bufferId; 14
04591B 17 00 A0    0353*      db 23,0,0xA0
04591E FE FF       0354*      dw 65534 ; workingBufferId
045920 0E          0355*      db 14 ; consolidate blocks
045921             0356*  ; the "expand bitmap" command is:
045921             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
045921 17 00 A0    0358*      db 23,0,0xA0
045924 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
045926 48          0360*      db 0x48 ; given as decimal command 72 in the docs
045927 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
045928 FE FF       0362*      dw 65534 ; sourceBufferId
04592A 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04592E             0364*  ; reverse the byte order to fix endian-ness:
04592E             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
04592E             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04592E             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04592E 17 00 A0    0368*      db 23,0,0xA0
045931 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
045933 18          0370*      db 24 ; reverse byte order
045934 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
045935 04 00       0372*      dw 4 ; size (4 bytes)
045937             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
045937             0374*  ; VDU 23,27,&20,targetBufferID%;
045937 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
04593A 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
04593C             0377*  ; VDU 23,27,&21,width%;height%;0
04593C 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
04593F 00 00       0379*  @width: dw 0x0000
045941 00 00       0380*  @height: dw 0x0000
045943 00          0381*      db 0x00 ; rgba8888 format
045944             0382*  @end:
045944             0383*  
045944             0384*  ; scratch variables
045944 00 00 00    0385*  bufferId0: dl 0x000000
045947 00 00 00    0386*  bufferId1: dl 0x000000
04594A             0387*  
04594A             0388*  ; load a vdu buffer from local memory
04594A             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04594A             0390*  vdu_load_buffer:
04594A ED 43 73 59 0391*      ld (@length),bc
       04          
04594F D5          0392*      push de ; save data pointer
045950             0393*  ; send the vdu command string
045950 7D          0394*      ld a,l
045951 32 70 59 04 0395*      ld (@bufferId),a
045955 7C          0396*      ld a,h
045956 32 71 59 04 0397*      ld (@bufferId+1),a
04595A 21 6D 59 04 0398*      ld hl,@cmd
04595E 01 08 00 00 0399*      ld bc,@end-@cmd
045962 5B DF       0400*      rst.lil $18
045964             0401*  ; send the buffer data
045964 E1          0402*      pop hl ; pointer to data
045965 ED 4B 73 59 0403*      ld bc,(@length)
       04          
04596A 5B DF       0404*      rst.lil $18 ; send it
04596C C9          0405*      ret
04596D             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04596D 17 00 A0    0407*  @cmd:       db 23,0,0xA0
045970 00 00       0408*  @bufferId:	dw 0x0000
045972 00          0409*  		    db 0 ; load buffer
045973 00 00       0410*  @length:	dw 0x0000
045975 00          0411*  @end: db 0 ; padding
045976             0412*  
045976             0413*  ; clear a buffer
045976             0414*  ; inputs: hl = bufferId
045976             0415*  vdu_clear_buffer:
045976 7D          0416*      ld a,l
045977 32 8E 59 04 0417*      ld (@bufferId),a
04597B 7C          0418*      ld a,h
04597C 32 8F 59 04 0419*      ld (@bufferId+1),a
045980 21 8B 59 04 0420*      ld hl,@cmd
045984 01 06 00 00 0421*      ld bc,@end-@cmd
045988 5B DF       0422*      rst.lil $18
04598A C9          0423*      ret
04598B 17 00 A0    0424*  @cmd:       db 23,0,0xA0
04598E 00 00       0425*  @bufferId:	dw 0x0000
045990 02          0426*  		    db 2 ; clear buffer
045991             0427*  @end:
045991             0428*  
045991             0429*  vdu_clear_all_buffers:
045991             0430*  ; clear all buffers
045991 21 9C 59 04 0431*      ld hl,@beg
045995 01 06 00 00 0432*      ld bc,@end-@beg
045999 5B DF       0433*      rst.lil $18
04599B C9          0434*      ret
04599C 17 00 A0    0435*  @beg: db 23,0,$A0
04599F FF FF       0436*        dw -1 ; clear all buffers
0459A1 02          0437*        db 2  ; command 2: clear a buffer
0459A2             0438*  @end:
0459A2             0439*  
0459A2             0440*  ; Command 14: Consolidate blocks in a buffer
0459A2             0441*  vdu_consolidate_buffer:
0459A2             0442*  ; set parameters for vdu call
0459A2 7D          0443*      ld a,l
0459A3 32 BA 59 04 0444*      ld (@bufferId),a
0459A7 7C          0445*      ld a,h
0459A8 32 BB 59 04 0446*      ld (@bufferId+1),a
0459AC 21 B7 59 04 0447*      ld hl,@beg
0459B0 01 06 00 00 0448*      ld bc,@end-@beg
0459B4 5B DF       0449*      rst.lil $18
0459B6 C9          0450*      ret
0459B7             0451*  ; VDU 23, 0, &A0, bufferId; 14
0459B7 17 00 A0    0452*  @beg: db 23,0,0xA0
0459BA 00 00       0453*  @bufferId: dw 0x0000
0459BC 0E          0454*             db 14
0459BD             0455*  @end:
0459BD             0456*  
0459BD             0457*  ; load an image file to a buffer and make it a bitmap
0459BD             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0459BD             0459*  vdu_load_img:
0459BD             0460*  ; back up image type and dimension parameters
0459BD 22 44 59 04 0461*      ld (bufferId0),hl
0459C1 F5          0462*      push af
0459C2 C5          0463*  	push bc
0459C3 D5          0464*  	push de
0459C4             0465*  ; load the image
0459C4 CD DF 59 04 0466*  	call vdu_load_buffer_from_file
0459C8             0467*  ; now make it a bitmap
0459C8 2A 44 59 04 0468*      ld hl,(bufferId0)
0459CC CD A2 59 04 0469*      call vdu_consolidate_buffer
0459D0 2A 44 59 04 0470*      ld hl,(bufferId0)
0459D4 CD 9F 58 04 0471*      call vdu_buff_select
0459D8 D1          0472*  	pop de ; image height
0459D9 C1          0473*  	pop bc ; image width
0459DA F1          0474*  	pop af ; image type
0459DB C3 B4 58 04 0475*  	jp vdu_bmp_create ; will return to caller from there
0459DF             0476*  
0459DF             0477*  ; inputs: hl = bufferId; iy = pointer to filename
0459DF             0478*  vdu_load_buffer_from_file:
0459DF 22 44 59 04 0479*      ld (bufferId0),hl
0459E3             0480*  
0459E3             0481*  ; clear target buffer
0459E3 CD 76 59 04 0482*      call vdu_clear_buffer
0459E7             0483*  
0459E7             0484*  ; open the file in read mode
0459E7             0485*  ; Open a file
0459E7             0486*  ; HLU: Filename
0459E7             0487*  ;   C: Mode
0459E7             0488*  ; Returns:
0459E7             0489*  ;   A: Filehandle, or 0 if couldn't open
0459E7 FD E5       0490*  	push iy ; pointer to filename
0459E9 E1          0491*  	pop hl
0459EA 0E 01       0492*  	ld c,fa_read
0459EC             0493*      MOSCALL mos_fopen
0459EC 3E 0A       0001*M 			LD	A, function
0459EE 5B CF       0002*M 			RST.LIL	08h
0459F0 32 2B 5A 04 0494*      ld (@filehandle),a
0459F4             0495*  
0459F4             0496*  @read_file:
0459F4             0497*  ; Read a block of data from a file
0459F4             0498*  ;   C: Filehandle
0459F4             0499*  ; HLU: Pointer to where to write the data to
0459F4             0500*  ; DEU: Number of bytes to read
0459F4             0501*  ; Returns:
0459F4             0502*  ; DEU: Number of bytes read
0459F4 3A 2B 5A 04 0503*      ld a,(@filehandle)
0459F8 4F          0504*      ld c,a
0459F9 21 00 E0 B7 0505*      ld hl,filedata
0459FD 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
045A01             0507*      MOSCALL mos_fread
045A01 3E 1A       0001*M 			LD	A, function
045A03 5B CF       0002*M 			RST.LIL	08h
045A05             0508*  
045A05             0509*  ; ; DEBUG: print chunk size
045A05             0510*  ;     push de
045A05             0511*  ;     pop hl
045A05             0512*  ;     call printDec
045A05             0513*  ;     call printNewLine
045A05             0514*  
045A05             0515*  ; test de for zero bytes read
045A05 21 00 00 00 0516*      ld hl,0
045A09 AF          0517*      xor a ; clear carry
045A0A ED 52       0518*      sbc hl,de
045A0C CA 22 5A 04 0519*      jp z,@close_file
045A10             0520*  
045A10             0521*  ; load a vdu buffer from local memory
045A10             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
045A10 2A 44 59 04 0523*      ld hl,(bufferId0)
045A14 D5          0524*      push de ; chunksize
045A15 C1          0525*      pop bc
045A16 11 00 E0 B7 0526*      ld de,filedata
045A1A CD 4A 59 04 0527*      call vdu_load_buffer
045A1E             0528*  
045A1E             0529*  ; ; print progress breadcrumbs
045A1E             0530*  ;     ld a,'.'
045A1E             0531*  ;     rst.lil 10h
045A1E             0532*  
045A1E             0533*  ; read the next block
045A1E C3 F4 59 04 0534*      jp @read_file
045A22             0535*  
045A22             0536*  ; close the file
045A22             0537*  @close_file:
045A22 3A 2B 5A 04 0538*      ld a,(@filehandle)
045A26             0539*      MOSCALL mos_fclose
045A26 3E 0B       0001*M 			LD	A, function
045A28 5B CF       0002*M 			RST.LIL	08h
045A2A C9          0540*      ret ; vdu_load_buffer_from_file
045A2B             0541*  
045A2B 00          0542*  @filehandle: db 0 ; file handle
045A2C 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
045A2F             0544*  
045A2F 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
045A32             0546*  
045A32             0547*  ; File information structure (FILINFO)
045A32             0548*  @filinfo:
045A32 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
045A36 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
045A38 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
045A3A 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
045A3B 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
045A48 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045B48             0055       include "src/asm/vdu_buff.inc"
045B48             0001*  ; VDP Buffered Commands API
045B48             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
045B48             0003*  
045B48             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045B48             0005*  ; This command is used to store a data block (a sequence of bytes)
045B48             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
045B48             0007*  ; It could be a sequence of VDU commands which can be executed
045B48             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
045B48             0009*  ; When used for a sequence of VDU commands, this effectively
045B48             0010*  ; allows for functions or stored procedures to be created.
045B48             0011*  
045B48             0012*  ; This is the most common command to use to send data to the VDP.
045B48             0013*  ; Typically you will call command 2 first to ensure that the
045B48             0014*  ; buffer is empty, and then make a series of calls to this command
045B48             0015*  ; to send data to the buffer.
045B48             0016*  
045B48             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
045B48             0018*  ; write to. Writing to the same buffer ID multiple times will add
045B48             0019*  ; new blocks to that buffer. This allows a buffer to be built up
045B48             0020*  ; over time, essentially allowing for a command to be sent across
045B48             0021*  ; to the VDP in multiple separate packets.
045B48             0022*  
045B48             0023*  ; Whilst the length of an individual block added using this command
045B48             0024*  ; is restricted to 65535 bytes (as the largest value that can be
045B48             0025*  ; sent in a 16-bit number) the total size of a buffer is not
045B48             0026*  ; restricted to this size, as multiple blocks can be added to a
045B48             0027*  ; buffer. Given how long it takes to send data to the VDP it is
045B48             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
045B48             0029*  ; data or less at a time.
045B48             0030*  
045B48             0031*  ; As writing to a single buffer ID is cumulative with this command,
045B48             0032*  ; care should be taken to ensure that the buffer is cleared out
045B48             0033*  ; before writing to it.
045B48             0034*  
045B48             0035*  ; When building up a complex sequence of commands it is often
045B48             0036*  ; advisable to use multiple blocks within a buffer. Typically
045B48             0037*  ; this is easier to code, as otherwise working out exactly how
045B48             0038*  ; many bytes long a command sequence is can be can be onerously
045B48             0039*  ; difficult. It is also easier to modify a command sequences that
045B48             0040*  ; are broken up into multiple blocks.
045B48             0041*  
045B48             0042*  ; As mentioned above it is advisable to send large pieces of data,
045B48             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
045B48             0044*  ; each packet of data sent to a buffer, the user can then perform
045B48             0045*  ; other operations, such as updating the screen to indicate
045B48             0046*  ; progress. This allows for long-running operations to be performed
045B48             0047*  ; without blocking the screen, and larger amounts of data to be
045B48             0048*  ; transferred over to the VDP than may otherwise be practical given
045B48             0049*  ; the limitations of the eZ80.
045B48             0050*  
045B48             0051*  ; If a buffer ID of 65535 is used then this command will be
045B48             0052*  ; ignored, and the data discarded. This is because this buffer ID
045B48             0053*  ; is reserved for special functions.
045B48             0054*  
045B48             0055*  ; Using buffers for bitmaps
045B48             0056*  
045B48             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
045B48             0058*  ; they cannot be used if they are spread over multiple blocks.
045B48             0059*  ; To use a bitmap its data must be in a single contiguous block,
045B48             0060*  ; and this is achieved by using the consolidate command &0E.
045B48             0061*  
045B48             0062*  ; Once you have a block that is ready to be used for a bitmap,
045B48             0063*  ; the buffer must be selected, and then a bitmap created for that
045B48             0064*  ; buffer using the bitmap and sprites API. This is done with the
045B48             0065*  ; following commands:
045B48             0066*  
045B48             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
045B48             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
045B48             0069*  
045B48             0070*  ; Until the create bitmap call has been made the buffer cannot
045B48             0071*  ; be used as a bitmap. That is because the system needs to
045B48             0072*  ; understand the dimensions of the bitmap, as well as the format
045B48             0073*  ; of the data. Usually this only needs to be done once. The format
045B48             0074*  ; is given as an 8-bit value, with the following values supported:
045B48             0075*  ; Value 	Type 	Description
045B48             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
045B48             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
045B48             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
045B48             0079*  
045B48             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
045B48             0081*  ; and these are automatically stored in buffers numbered 64000-64255
045B48             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
045B48             0083*  ; simply a matter of adding 64000. All bitmaps created with that
045B48             0084*  ; API will be RGBA8888 format.
045B48             0085*  
045B48             0086*  ; There is one other additional call added to the bitmap and
045B48             0087*  ; sprites API, which allows for bitmaps referenced with a
045B48             0088*  ; buffer ID to be added to sprites. This is done with the
045B48             0089*  ; following command:
045B48             0090*  
045B48             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
045B48             0092*  
045B48             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
045B48             0094*  
045B48             0095*  ; It should be noted that it is possible to modify the buffer
045B48             0096*  ; that a bitmap is stored in using the adjust buffer contents
045B48             0097*  ; and reverse contents commands (5 and 24 respectively). This
045B48             0098*  ; can allow you to do things such as changing colours in a bitmap,
045B48             0099*  ; or flipping an image horizontally or vertically. This will even
045B48             0100*  ; work on bitmaps that are being used inside sprites.
045B48             0101*  
045B48             0102*  ; Using commands targetting a buffer that create new blocks,
045B48             0103*  ; such as consolidate or split, will invalidate the bitmap
045B48             0104*  ; and remove it from use.
045B48             0105*  
045B48             0106*  ; Using buffers for sound samples
045B48             0107*  
045B48             0108*  ; Much like with bitmaps, it is advisable to send samples over
045B48             0109*  ; to the VDP in multiple blocks for the same reasons.
045B48             0110*  
045B48             0111*  ; In contrast to bitmaps, the sound system can play back samples
045B48             0112*  ; that are spread over multiple blocks, so there is no need to
045B48             0113*  ; consolidate buffers. As a result of this, the sample playback
045B48             0114*  ; system is also more tolerant of modifications being made to
045B48             0115*  ; the buffer after a sample has been created from it, even if
045B48             0116*  ; the sample is currently playing. It should be noted that
045B48             0117*  ; splitting a buffer may result in unexpected behaviour if
045B48             0118*  ; the sample is currently playing, such as skipping to other
045B48             0119*  ; parts of the sample.
045B48             0120*  
045B48             0121*  ; Once you have a buffer that contains block(s) that are ready
045B48             0122*  ; to be used for a sound sample, the following command must be
045B48             0123*  ; used to indicate that a sample should be created from that buffer:
045B48             0124*  
045B48             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
045B48             0126*  
045B48             0127*  ; The format parameter is an 8-bit value that indicates the
045B48             0128*  ; format of the sample data. The following values are supported:
045B48             0129*  ; Value 	Description
045B48             0130*  ; 0 	8-bit signed, 16KHz
045B48             0131*  ; 1 	8-bit unsigned, 16KHz
045B48             0132*  
045B48             0133*  ; Once a sample has been created in this way, the sample can
045B48             0134*  ; be selected for use on a channel using the following command:
045B48             0135*  
045B48             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
045B48             0137*  
045B48             0138*  ; Samples uploaded using the existing load sample command
045B48             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
045B48             0140*  ; are also stored in buffers automatically. A sample number using this system is in
045B48             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
045B48             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
045B48             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
045B48             0144*  ; buffer 64257, and so on.
045B48             0145*  ; Command 1: Call a buffer
045B48             0146*  
045B48             0147*  ; VDU 23, 0 &A0, bufferId; 1
045B48             0148*  
045B48             0149*  ; This command will attempt to execute all of the commands
045B48             0150*  ; stored in the buffer with the given ID. If the buffer does
045B48             0151*  ; not exist, or is empty, then this command will do nothing.
045B48             0152*  
045B48             0153*  ; Essentially, this command passes the contents of the buffer
045B48             0154*  ; to the VDPs VDU command processor system, and executes them
045B48             0155*  ; as if they were sent directly to the VDP.
045B48             0156*  
045B48             0157*  ; As noted against command 0, it is possible to build up a
045B48             0158*  ; buffer over time by sending across multiple commands to write
045B48             0159*  ; to the same buffer ID. When calling a buffer with multiple
045B48             0160*  ; blocks, the blocks are executed in order.
045B48             0161*  
045B48             0162*  ; Care should be taken when using this command within a buffer,
045B48             0163*  ; as it is possible to create an infinite loop. For instance,
045B48             0164*  ; if a buffer contains a command to call itself, then this will
045B48             0165*  ; result in an infinite loop. This will cause the VDP to hang,
045B48             0166*  ; and the only way to recover from this is to reset the VDP.
045B48             0167*  
045B48             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
045B48             0169*  ; to be executed. This can be useful for creating loops within
045B48             0170*  ; a buffer. It will be ignored if used outside of a buffered
045B48             0171*  ; command sequence.
045B48             0172*  
045B48             0173*  ; Command 2: Clear a buffer
045B48             0174*  ; VDU 23, 0 &A0, bufferId; 2
045B48             0175*  
045B48             0176*  ; This command will clear the buffer with the given ID. If
045B48             0177*  ; the buffer does not exist then this command will do nothing.
045B48             0178*  
045B48             0179*  ; Please note that this clears out all of the blocks sent to
045B48             0180*  ; a buffer via command 0, not just the last one. i.e. if you
045B48             0181*  ; have built up a buffer over time by sending multiple commands
045B48             0182*  ; to write to the same buffer ID, this command will clear out
045B48             0183*  ; all of those commands.
045B48             0184*  
045B48             0185*  ; Calling this command with a bufferId value of -1 (65535) will
045B48             0186*  ; clear out all buffers.
045B48             0187*  
045B48             0188*  ; Command 3: Create a writeable buffer
045B48             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
045B48             0190*  ; This command will create a new writeable buffer with the given
045B48             0191*  ; ID. If a buffer with the given ID already exists then this
045B48             0192*  ; command will do nothing. This command is primarily intended
045B48             0193*  ; for use to create a buffer that can be used to capture output
045B48             0194*  ; using the set output stream command (see below), or to store
045B48             0195*  ; data that can be used for other commands.
045B48             0196*  
045B48             0197*  ; It is generally quite rare that you will want to use this
045B48             0198*  ; command. Typically you will instead want to use command 0
045B48             0199*  ; to write data to a buffer. It is not necessary to use this
045B48             0200*  ; command before using command 0, and indeed doing so will
045B48             0201*  ; lead to errors as you will end up with two blocks in the
045B48             0202*  ; buffer, the first of which will be empty. If you do wish
045B48             0203*  ; to use this command to create a buffer for data and then
045B48             0204*  ; write to it, you would need to use operation 2 of command 5,
045B48             0205*  ; the set operation in the buffer adjust command, to set a
045B48             0206*  ; sequence of bytes in the buffer to the data you want to write.
045B48             0207*  ; This is not recommended, as it is much easier to just use
045B48             0208*  ; command 0 to write a data block to a buffer.
045B48             0209*  
045B48             0210*  ; This new buffer will be a single empty single block upon
045B48             0211*  ; creation, containing zeros.
045B48             0212*  
045B48             0213*  ; The length parameter is a 16-bit integer that specifies
045B48             0214*  ; the maximum size of the buffer. This is the maximum number
045B48             0215*  ; of bytes that can be stored in the buffer. If the buffer
045B48             0216*  ; is full then no more data can be written to it, and subsequent
045B48             0217*  ; writes will be ignored.
045B48             0218*  
045B48             0219*  ; After creating a buffer with this command it is possible to
045B48             0220*  ; use command 0 to write further blocks to the buffer, however
045B48             0221*  ; this is probably not advisable.
045B48             0222*  
045B48             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
045B48             0224*  ; values have special meanings for writable buffers. See command 4.
045B48             0225*  
045B48             0226*  ; Command 4: Set output stream to a buffer
045B48             0227*  ; VDU 23, 0 &A0, bufferId; 4
045B48             0228*  
045B48             0229*  ; Sets then current output stream to the buffer with the given ID.
045B48             0230*  ; With two exceptions, noted below, this needs to be a writable
045B48             0231*  ; buffer created with command 3. If the buffer does not exist,
045B48             0232*  ; or the first block within the buffer is not writable, then
045B48             0233*  ; this command will do nothing.
045B48             0234*  
045B48             0235*  ; Following this command, any subsequent VDU commands that send
045B48             0236*  ; response packets will have those packets written to the specified
045B48             0237*  ; output buffer. This allows the user to capture the response
045B48             0238*  ; packets from a command sent to the VDP.
045B48             0239*  
045B48             0240*  ; By default, the output stream (for the main VDU command processor)
045B48             0241*  ; is the communications channel from the VDP to MOS running on the
045B48             0242*  ; eZ80.
045B48             0243*  
045B48             0244*  ; Passing a buffer ID of -1 (65535) to this command will
045B48             0245*  ; remove/detach the output buffer. From that point onwards,
045B48             0246*  ; any subsequent VDU commands that send response packets will
045B48             0247*  ; have those responses discarded/ignored.
045B48             0248*  
045B48             0249*  ; Passing a buffer ID of 0 to this command will set the output
045B48             0250*  ; buffer back to its original value for the current command stream.
045B48             0251*  ; Typically that will be the communications channel from the VDP to
045B48             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
045B48             0253*  ; call has been made.
045B48             0254*  
045B48             0255*  ; When used inside a buffered command sequence, this command will
045B48             0256*  ; only affect the output stream for that sequence of commands, and
045B48             0257*  ; any other buffered command sequences that are called from within
045B48             0258*  ; that sequence. Once the buffered command sequence has completed,
045B48             0259*  ; the output stream will effectively be reset to its original value.
045B48             0260*  
045B48             0261*  ; It is strongly recommended to only use this command from within a
045B48             0262*  ; buffered command sequence. Whilst it is possible to use this
045B48             0263*  ; command from within a normal VDU command sequence, it is not
045B48             0264*  ; recommended as it may cause unexpected behaviour. If you do use
045B48             0265*  ; it in that context, it is very important to remember to restore
045B48             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
045B48             0267*  ; future, this command may be disabled from being used outside of
045B48             0268*  ; a buffered command sequence.)
045B48             0269*  
045B48             0270*  ; At present, writable buffers can only be written to until the end
045B48             0271*  ; of the buffer has been reached; once that happens no more data
045B48             0272*  ; will be written to the buffer. It is not currently possible to
045B48             0273*  ; rewind an output stream. It is therefore advisable to ensure
045B48             0274*  ; that the buffer is large enough to capture all of the data that
045B48             0275*  ; is expected to be written to it. The only current way to rewind
045B48             0276*  ; an output stream would be to clear the buffer and create a new
045B48             0277*  ; one, and then call set output stream again with the newly created
045B48             0278*  ; buffer.
045B48             0279*  
045B48             0280*  ; Command 5: Adjust buffer contents
045B48             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
045B48             0282*  
045B48             0283*  ; This command will adjust the contents of a buffer, at a given
045B48             0284*  ; offset. The exact nature of the adjustment will depend on the
045B48             0285*  ; operation used.
045B48             0286*  
045B48             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
045B48             0288*  ; the contents of the current buffer. This will only work if this
045B48             0289*  ; command is used within a buffered command sequence, otherwise the
045B48             0290*  ; command will not do anything.
045B48             0291*  
045B48             0292*  ; The basic set of adjustment operations are as follows:
045B48             0293*  ; Operation 	Description
045B48             0294*  ; 0 	NOT
045B48             0295*  ; 1 	Negate
045B48             0296*  ; 2 	Set value
045B48             0297*  ; 3 	Add
045B48             0298*  ; 4 	Add with carry
045B48             0299*  ; 5 	AND
045B48             0300*  ; 6 	OR
045B48             0301*  ; 7 	XOR
045B48             0302*  
045B48             0303*  ; All of these operations will modify a byte found at the given
045B48             0304*  ; offset in the buffer. The only exception to that is the Add with
045B48             0305*  ; carry operation, which will also store the carry value in the
045B48             0306*  ; byte at the next offset. With the exception of NOT and Negate,
045B48             0307*  ; each command requires an operand value to be specified.
045B48             0308*  
045B48             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
045B48             0310*  ; need to use the NOT operation, and so the following command would
045B48             0311*  ; be used:
045B48             0312*  
045B48             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
045B48             0314*  
045B48             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
045B48             0316*  ; to use the Add operation, and so the following command would be
045B48             0317*  ; used:
045B48             0318*  
045B48             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
045B48             0320*  
045B48             0321*  ; When using add with carry, the carry value is stored in the byte
045B48             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
045B48             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
045B48             0324*  ; you would need to use the Add with carry operation, and so the
045B48             0325*  ; following command would be used:
045B48             0326*  
045B48             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
045B48             0328*  
045B48             0329*  ; Advanced operations
045B48             0330*  
045B48             0331*  ; Whilst these operations are useful, they are not particularly
045B48             0332*  ; powerful as they only operate one one byte at a time, with a
045B48             0333*  ; fixed operand value, and potentially cannot reach all bytes in
045B48             0334*  ; a buffer. To address this, the API supports a number of advanced
045B48             0335*  ; operations.
045B48             0336*  
045B48             0337*  ; The operation value used is an 8-bit value that can have bits
045B48             0338*  ; set to modify the behaviour of the operation. The following bits
045B48             0339*  ; are defined:
045B48             0340*  ; Bit 	Description
045B48             0341*  ; &10 	Use advanced offsets
045B48             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B48             0343*  ; &40 	Multiple target values should be adjusted
045B48             0344*  ; &80 	Multiple operand values should be used
045B48             0345*  
045B48             0346*  ; These bits can be combined together to modify the behaviour of
045B48             0347*  ; the operation.
045B48             0348*  
045B48             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
045B48             0350*  ; offset one byte at a time. When either of the multiple variants
045B48             0351*  ; are used, a 16-bit count must be provided to indicate how many
045B48             0352*  ; bytes should be altered.
045B48             0353*  
045B48             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
045B48             0355*  ; order, which can allow for buffers that are larger than 64kb
045B48             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
045B48             0357*  ; the 16-bit value immediately following the offset is used as a
045B48             0358*  ; block index number, and the remaining 23-bits of the offset value
045B48             0359*  ; are used as an offset within that block. When the advanced
045B48             0360*  ; offset mode bit has been set then all offsets associated with
045B48             0361*  ; this command must be sent as advanced offsets.
045B48             0362*  
045B48             0363*  ; The buffer-fetched value mode allows for the operand value to
045B48             0364*  ; be fetched from a buffer. The operand sent as part of the
045B48             0365*  ; command in this case is a pair of 16-bit values giving the
045B48             0366*  ; buffer ID and offset to indicate where the actual operand value
045B48             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
045B48             0368*  ; be interpretted as meaning this buffer, and thus can only be
045B48             0369*  ; used inside a buffered command sequence. If the advanced offset
045B48             0370*  ; mode is used, then the operand value is an advanced offset value.
045B48             0371*  
045B48             0372*  ; The multiple target values mode allows for multiple bytes to
045B48             0373*  ; be adjusted at once. When this mode is used, the count value
045B48             0374*  ; must be provided to indicate how many bytes should be adjusted.
045B48             0375*  ; Unless the multiple operand values mode is also used, the
045B48             0376*  ; operand value is used for all bytes adjusted.
045B48             0377*  
045B48             0378*  ; The multiple operand values mode allows for multiple operand
045B48             0379*  ; values to be used. When this mode is used, the count value must
045B48             0380*  ; be provided to indicate how many operand values should be used.
045B48             0381*  ; This can allow, for instance, to add together several bytes in a
045B48             0382*  ; buffer. When this mode is used in conjunction with the multiple
045B48             0383*  ; target values mode, the number of operand values must match the
045B48             0384*  ; number of target values, and the operation happens one byte at a
045B48             0385*  ; time.
045B48             0386*  
045B48             0387*  ; Some examples of advanced operations are as follows:
045B48             0388*  
045B48             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
045B48             0390*  
045B48             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
045B48             0392*  
045B48             0393*  ; This uses operation 0 (NOT) with the multiple target values
045B48             0394*  ; modifier (&40).
045B48             0395*  
045B48             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
045B48             0397*  
045B48             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
045B48             0399*  
045B48             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
045B48             0401*  
045B48             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
045B48             0403*  
045B48             0404*  ; This is using operation 2 (Set) with the advanced offsets
045B48             0405*  ; modifier (&10). As BBC BASIC doesnt natively understand how
045B48             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
045B48             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
045B48             0408*  ; in little-endian order. As the top bit of the offset is set, this
045B48             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
045B48             0410*  ; Finally the value to write is sent, 42.
045B48             0411*  
045B48             0412*  ; An operation like this could be used to set the position as part
045B48             0413*  ; of a draw command.
045B48             0414*  
045B48             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
045B48             0416*  ; values 1, 2, 3, 4, 5:
045B48             0417*  
045B48             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
045B48             0419*  ; offset 12 (set it to 0)
045B48             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
045B48             0421*  
045B48             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
045B48             0423*  ; 7 bytes in buffer 4 starting at offset 42:
045B48             0424*  
045B48             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
045B48             0426*  
045B48             0427*  ; As we are working on a little-endian system, integers longer
045B48             0428*  ; than one byte are sent with their least significant byte first.
045B48             0429*  ; This means that the add with carry operation can be used to add
045B48             0430*  ; together integers of any size, so long as they are the same size.
045B48             0431*  ; To do this, both the multiple target values and multiple
045B48             0432*  ; operand values modes must be used.
045B48             0433*  
045B48             0434*  ; The following commands will add together a 16-bit, 24-bit,
045B48             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
045B48             0436*  ; in buffer 3 starting at offset 12, and all using the operand
045B48             0437*  ; value of 42:
045B48             0438*  
045B48             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
045B48             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
045B48             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
045B48             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
045B48             0443*  
045B48             0444*  ; Take note of how the operand value is padded out with zeros
045B48             0445*  ; to match the size of the target value. 42; is used as a base
045B48             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
045B48             0447*  ; 16-bits to pad it out to the required size. The carry value
045B48             0448*  ; will be stored at the next offset in the target buffer after
045B48             0449*  ; the complete target value. So for a 16-bit value, the carry
045B48             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
045B48             0451*  ; at offset 15, and so on.
045B48             0452*  
045B48             0453*  ; Command 6: Conditionally call a buffer
045B48             0454*  
045B48             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
045B48             0456*  
045B48             0457*  ; This command will conditionally call a buffer if the condition
045B48             0458*  ; operation passes. This command works in a similar manner to the
045B48             0459*  ; Adjust buffer contents command.
045B48             0460*  
045B48             0461*  ; With this command a buffer ID of 65535 (-1) is always
045B48             0462*  ; interpretted as current buffer, and so can only be used
045B48             0463*  ; within a buffered command sequence. If used outside of a
045B48             0464*  ; buffered command sequence then this command will do nothing.
045B48             0465*  
045B48             0466*  ; The basic set of condition operations are as follows:
045B48             0467*  ; Operation 	Description
045B48             0468*  ; 0 	Exists (value is non-zero)
045B48             0469*  ; 1 	Not exists (value is zero)
045B48             0470*  ; 2 	Equal
045B48             0471*  ; 3 	Not equal
045B48             0472*  ; 4 	Less than
045B48             0473*  ; 5 	Greater than
045B48             0474*  ; 6 	Less than or equal
045B48             0475*  ; 7 	Greater than or equal
045B48             0476*  ; 8 	AND
045B48             0477*  ; 9 	OR
045B48             0478*  
045B48             0479*  ; The value that is being checked is fetched from the specified
045B48             0480*  ; check buffer ID and offset. With the exception of Exists and
045B48             0481*  ; Not exists, each command requires an operand value to be
045B48             0482*  ; specified to check against.
045B48             0483*  
045B48             0484*  ; The operation value used is an 8-bit value that can have bits
045B48             0485*  ; set to modify the behaviour of the operation. The following bits
045B48             0486*  ; are defined:
045B48             0487*  ; Bit value 	Description
045B48             0488*  ; &10 	Use advanced offsets
045B48             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B48             0490*  
045B48             0491*  ; These modifiers can be combined together to modify the behaviour
045B48             0492*  ; of the operation.
045B48             0493*  
045B48             0494*  ; At this time, unlike with the adjust command, multiple target
045B48             0495*  ; values and multiple operand values are not supported. All
045B48             0496*  ; comparisons are therefore only conducted on single 8-bit values.
045B48             0497*  ; (If comparisons of 16-bit values are required, multiple calls
045B48             0498*  ; can be combined.) Support for them may be added in the future.
045B48             0499*  
045B48             0500*  ; The AND and OR operations are logical operations, and so the
045B48             0501*  ; operand value is used as a boolean value. Any non-zero value is
045B48             0502*  ; considered to be true, and zero is considered to be false. These
045B48             0503*  ; operations therefore are most useful when used with buffer-fetched
045B48             0504*  ; operand values (operations &28, &29, &38 and &39).
045B48             0505*  
045B48             0506*  ; Some examples of condition operations are as follows:
045B48             0507*  
045B48             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
045B48             0509*  ; (is non-zero):
045B48             0510*  
045B48             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B48             0512*  
045B48             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
045B48             0514*  ; exist (is zero):
045B48             0515*  
045B48             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B48             0517*  
045B48             0518*  ; Combining the above two examples is effectively equivalent to
045B48             0519*  ; if the value exists, call buffer 7, otherwise call buffer 8:
045B48             0520*  
045B48             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B48             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B48             0523*  
045B48             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
045B48             0525*  
045B48             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
045B48             0527*  
045B48             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
045B48             0529*  ; the value in buffer 2 at offset 8:
045B48             0530*  
045B48             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
045B48             0532*  
045B48             0533*  ; Command 7: Jump to a buffer
045B48             0534*  
045B48             0535*  ; VDU 23, 0, &A0, bufferId; 7
045B48             0536*  
045B48             0537*  ; This command will jump to the buffer with the given ID. If
045B48             0538*  ; the buffer does not exist, or is empty, then this command will
045B48             0539*  ; do nothing.
045B48             0540*  
045B48             0541*  ; This essentially works the same as the call command (command 1),
045B48             0542*  ;  except that it does not return to the caller. This command is
045B48             0543*  ;  therefore useful for creating loops.
045B48             0544*  
045B48             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
045B48             0546*  ; treated as a jump to end of current buffer. This will return
045B48             0547*  ; execution to the caller, and can be useful for exiting a loop.
045B48             0548*  
045B48             0549*  ; ## Command 8: Conditional Jump to a buffer
045B48             0550*  
045B48             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
045B48             0552*  
045B48             0553*  ; This command operates in a similar manner to the Conditionally
045B48             0554*  ; call a buffer command (command 6), except that it will jump to
045B48             0555*  ; the buffer if the condition operation passes.
045B48             0556*  
045B48             0557*  ; As with the Jump to a buffer command (command 7), a jump to
045B48             0558*  ; buffer 65535 is treated as a jump to end of current buffer.
045B48             0559*  ; Command 9: Jump to an offset in a buffer
045B48             0560*  
045B48             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
045B48             0562*  
045B48             0563*  ; This command will jump to the given offset in the buffer with the
045B48             0564*  ; given ID. If the buffer does not exist, or is empty, then this
045B48             0565*  ; command will do nothing.
045B48             0566*  
045B48             0567*  ; The offset in this command is always an advanced offset, given
045B48             0568*  ; as a 24-bit value in little-endian order. As with other uses of
045B48             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
045B48             0570*  ; offset value, a block number must also be provided.
045B48             0571*  
045B48             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
045B48             0573*  ; meaning jump within current buffer. This can be useful for
045B48             0574*  ; creating loops within a buffer, or when building up command
045B48             0575*  ; sequences that may be copied across multiple buffers.
045B48             0576*  
045B48             0577*  ; Jumping to an offset that is beyond the end of the buffer is
045B48             0578*  ; equivalent to jumping to the end of the buffer.
045B48             0579*  ; Command 10: Conditional jump to an offset in a buffer
045B48             0580*  
045B48             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
045B48             0582*  
045B48             0583*  ; A conditional jump with an offset works in a similar manner to
045B48             0584*  ; the Conditional call a buffer command (command 6), except that
045B48             0585*  ; it will jump to the given offset in the buffer if the condition
045B48             0586*  ; operation passes.
045B48             0587*  
045B48             0588*  ; As with the Jump to an offset in a buffer command (command 9),
045B48             0589*  ; the offset in this command is always an advanced offset, given
045B48             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
045B48             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
045B48             0592*  ; treated as meaning jump within current buffer.
045B48             0593*  ; Command 11: Call buffer with an offset
045B48             0594*  
045B48             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
045B48             0596*  
045B48             0597*  ; Works just like Call a buffer (command 1), except that it also
045B48             0598*  ; accepts an advanced offset.
045B48             0599*  
045B48             0600*  ; Command 12: Conditional call buffer with an offset
045B48             0601*  
045B48             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
045B48             0603*  
045B48             0604*  ; Works just like the Conditional call a buffer command
045B48             0605*  ; (command 6), except that it also accepts an advanced offset.
045B48             0606*  
045B48             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
045B48             0608*  
045B48             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
045B48             0610*  
045B48             0611*  ; This command will copy the contents of multiple buffers into a
045B48             0612*  ; single buffer. The buffers to copy from are specified as a list
045B48             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
045B48             0614*  ; buffers are copied in the order they are specified.
045B48             0615*  
045B48             0616*  ; This is a block-wise copy, so the blocks from the source buffers
045B48             0617*  ; are copied into the target buffer. The blocks are copied in the
045B48             0618*  ; order they are found in the source buffers.
045B48             0619*  
045B48             0620*  ; The target buffer will be overwritten with the contents of the
045B48             0621*  ; source buffers. This will not be done however until after all the
045B48             0622*  ; data has been gathered and copied. The target buffer can therefore
045B48             0623*  ; included in the list of the source buffers.
045B48             0624*  
045B48             0625*  ; If a source buffer that does not exist is specified, or a source
045B48             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
045B48             0627*  
045B48             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
045B48             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
045B48             0630*  ; copied multiple times into the target buffer.
045B48             0631*  
045B48             0632*  ; If there is insufficient memory available on the VDP to complete
045B48             0633*  ; this command then it will fail, and the target buffer will be
045B48             0634*  ; left unchanged.
045B48             0635*  
045B48             0636*  
045B48             0637*  ; Command 14: Consolidate blocks in a buffer
045B48             0638*  
045B48             0639*  ; VDU 23, 0, &A0, bufferId; 14
045B48             0640*  
045B48             0641*  ; Takes all the blocks in a buffer and consolidates them into a
045B48             0642*  ; single block. This is useful for bitmaps, as it allows for a
045B48             0643*  ; bitmap to be built up over time in multiple blocks, and then
045B48             0644*  ; consolidated into a single block for use as a bitmap.
045B48             0645*  
045B48             0646*  ; If there is insufficient memory available on the VDP to complete
045B48             0647*  ; this command then it will fail, and the buffer will be left
045B48             0648*  ; unchanged.
045B48             0649*  
045B48             0650*  ; Command 15: Split a buffer into multiple blocks
045B48             0651*  
045B48             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
045B48             0653*  
045B48             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
045B48             0655*  ; is a 16-bit integer that specifies the target size of each block.
045B48             0656*  ; If the source data is not a multiple of the block size then the
045B48             0657*  ; last block will be smaller than the specified block size.
045B48             0658*  
045B48             0659*  ; If this command is used on a buffer that is already split into
045B48             0660*  ; multiple blocks, then the blocks will be consolidated first,
045B48             0661*  ; and then re-split into the new block size.
045B48             0662*  
045B48             0663*  ; If there is insufficient memory available on the VDP to complete
045B48             0664*  ; this command then it will fail, and the buffer will be left
045B48             0665*  ; unchanged.
045B48             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
045B48             0667*  ; multiple buffers
045B48             0668*  
045B48             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B48             0670*  
045B48             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
045B48             0672*  ; then spreads the resultant blocks across the target buffers.
045B48             0673*  ; The target buffers are specified as a list of buffer IDs,
045B48             0674*  ; terminated by a buffer ID of -1 (65535).
045B48             0675*  
045B48             0676*  ; The blocks are spread across the target buffers in the order
045B48             0677*  ; they are specified, and the spread will loop around the buffers
045B48             0678*  ; until all the blocks have been distributed. The target buffers
045B48             0679*  ; will be cleared out before the blocks are spread across them.
045B48             0680*  
045B48             0681*  ; What this means is that if the source buffer is, lets say,
045B48             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
045B48             0683*  ; then we will end up with 10 blocks. If we then spread those
045B48             0684*  ; blocks across 3 target buffers, then the first buffer will
045B48             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
045B48             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
045B48             0687*  ; blocks 3, 6 and 9.
045B48             0688*  
045B48             0689*  ; This command attempts to ensure that, in the event of
045B48             0690*  ; insufficient memory being available on the VDP to complete
045B48             0691*  ; the command, it will leave the targets as they were before
045B48             0692*  ; the command was executed. However this may not always be
045B48             0693*  ; possible. The first step of this command is to consolidate
045B48             0694*  ; the source buffer into a single block, and this may fail from
045B48             0695*  ; insufficient memory. If that happens then all the buffers will
045B48             0696*  ; be left as they were. After this however the target buffers
045B48             0697*  ; will be cleared. If there is insufficient memory to successfully
045B48             0698*  ; split the buffer into multiple blocks then the call will exit,
045B48             0699*  ; and the target buffers will be left empty.
045B48             0700*  ; Command 17: Split a buffer and spread across blocks, starting
045B48             0701*  ; at target buffer ID
045B48             0702*  
045B48             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
045B48             0704*  
045B48             0705*  ; As per the above two commands, this will split a buffer into
045B48             0706*  ; multiple blocks. It will then spread the blocks across buffers
045B48             0707*  ; starting at the target buffer ID, incrementing the target buffer
045B48             0708*  ; ID until all the blocks have been distributed.
045B48             0709*  
045B48             0710*  ; Target blocks will be cleared before a block is stored in them.
045B48             0711*  ; Each target will contain a single block. The exception to this
045B48             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
045B48             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
045B48             0714*  ; will be placed into buffer 65534.
045B48             0715*  
045B48             0716*  ; With this command if there is insufficient memory available on
045B48             0717*  ; the VDP to complete the command then it will fail, and the target
045B48             0718*  ; buffers will be left unchanged.
045B48             0719*  
045B48             0720*  ; Command 18: Split a buffer into blocks by width
045B48             0721*  
045B48             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
045B48             0723*  
045B48             0724*  ; This command splits a buffer into a given number of blocks by
045B48             0725*  ; first of all splitting the buffer into blocks of a given width
045B48             0726*  ; (number of bytes), and then consolidating those blocks into the
045B48             0727*  ; given number of blocks.
045B48             0728*  
045B48             0729*  ; This is useful for splitting a bitmap into a number of separate
045B48             0730*  ; columns, which can then be manipulated individually. This can be
045B48             0731*  ; useful for dealing with sprite sheets.
045B48             0732*  ; Command 19: Split by width into blocks and spread across target
045B48             0733*  ; buffers
045B48             0734*  
045B48             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B48             0736*  
045B48             0737*  ; This command essentially operates the same as command 18, but the
045B48             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
045B48             0739*  
045B48             0740*  ; Command 20: Split by width into blocks and spread across blocks
045B48             0741*  ; starting at target buffer ID
045B48             0742*  
045B48             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
045B48             0744*  
045B48             0745*  ; This command essentially operates the same as command 18, but
045B48             0746*  ; the generated blocks are spread across blocks starting at the
045B48             0747*  ; target buffer ID, as per command 17.
045B48             0748*  
045B48             0749*  ; Command 21: Spread blocks from a buffer across multiple target
045B48             0750*  ; buffers
045B48             0751*  
045B48             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
045B48             0753*  
045B48             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
045B48             0755*  ; The target buffers are specified as a list of buffer IDs,
045B48             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
045B48             0757*  ; across the target buffers in the order they are specified, and
045B48             0758*  ; the spread will loop around the buffers until all the blocks have
045B48             0759*  ; been distributed.
045B48             0760*  
045B48             0761*  ; It should be noted that this command does not copy the blocks,
045B48             0762*  ; and nor does it move them. Unless the source buffer has been
045B48             0763*  ; included in the list of targets, it will remain completely
045B48             0764*  ; intact. The blocks distributed across the target buffers will
045B48             0765*  ; point to the same memory as the blocks in the source buffer.
045B48             0766*  ; Operations to modify data in the source buffer will also modify
045B48             0767*  ; the data in the target buffers. Clearing the source buffer
045B48             0768*  ; however will not clear the target buffers.
045B48             0769*  
045B48             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
045B48             0771*  ; at target buffer ID
045B48             0772*  
045B48             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
045B48             0774*  
045B48             0775*  ; Spreads the blocks from a buffer across blocks starting at
045B48             0776*  ; the target buffer ID.
045B48             0777*  
045B48             0778*  ; This essentially works the same as command 21, and the same
045B48             0779*  ; notes about copying and moving blocks apply. Blocks are spread
045B48             0780*  ; in the same manner as commands 17 and 20.
045B48             0781*  
045B48             0782*  ; Command 23: Reverse the order of blocks in a buffer
045B48             0783*  
045B48             0784*  ; VDU 23, 0, &A0, bufferId; 23
045B48             0785*  
045B48             0786*  ; Reverses the order of the blocks in a buffer.
045B48             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
045B48             0788*  
045B48             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045B48             0790*  
045B48             0791*  ; Reverses the order of the data within the blocks of a buffer.
045B48             0792*  ; The options parameter is an 8-bit value that can have bits set
045B48             0793*  ; to modify the behaviour of the operation. The following bits
045B48             0794*  ; are defined:
045B48             0795*  ; Bit value 	Description
045B48             0796*  ; 1 	Values are 16-bits in size
045B48             0797*  ; 2 	Values are 32-bits in size
045B48             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
045B48             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
045B48             0800*  ; 8 	Reverse blocks
045B48             0801*  
045B48             0802*  ; These modifiers can be combined together to modify the behaviour
045B48             0803*  ; of the operation.
045B48             0804*  
045B48             0805*  ; If no value size is set in the options (i.e. the value of the
045B48             0806*  ; bottom two bits of the options is zero) then the value size is
045B48             0807*  ; assumed to be 8-bits.
045B48             0808*  
045B48             0809*  ; It is probably easiest to understand what this operation is
045B48             0810*  ; capable of by going through some examples of how it can be used
045B48             0811*  ; to manipulate bitmaps. The VDP supports two different formats
045B48             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
045B48             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
045B48             0814*  ; pixel.
045B48             0815*  
045B48             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
045B48             0817*  ; degrees, which can be done by just reversing the order of
045B48             0818*  ; bytes in the buffer:
045B48             0819*  
045B48             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
045B48             0821*  
045B48             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
045B48             0823*  ; little more complex, as each pixel is made up of 4 bytes.
045B48             0824*  ; However with this command it is still a simple operation, as
045B48             0825*  ; we can just reverse the order of the 32-bit values that make
045B48             0826*  ; up the bitmap by using an options value of 2:
045B48             0827*  
045B48             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
045B48             0829*  
045B48             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
045B48             0831*  ; the order of rows of pixels. To do this we can set a custom
045B48             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
045B48             0833*  ; bitmap we can just set a custom value size to our bitmap width:
045B48             0834*  
045B48             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
045B48             0836*  
045B48             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
045B48             0838*  ; our width by 4:
045B48             0839*  
045B48             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
045B48             0841*  
045B48             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
045B48             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
045B48             0844*  ; just set a custom chunk size to our bitmap width:
045B48             0845*  
045B48             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
045B48             0847*  
045B48             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
045B48             0849*  ; 32-bit values as well as a custom chunk size:
045B48             0850*  
045B48             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
045B48             0852*  
045B48             0853*  ; Command 25: Copy blocks from multiple buffers by reference
045B48             0854*  
045B48             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
045B48             0856*  
045B48             0857*  ; This command is essentially a version of command 13 that copies
045B48             0858*  ; blocks by reference rather than by value. The parameters for
045B48             0859*  ; this command are the same as for command 13, and the same rules
045B48             0860*  ; apply.
045B48             0861*  
045B48             0862*  ; If the target buffer is included in the list of source buffers
045B48             0863*  ; then it will be skipped to prevent a reference loop.
045B48             0864*  
045B48             0865*  ; Copying by reference means that the blocks in the target buffer
045B48             0866*  ; will point to the same memory as the blocks in the source
045B48             0867*  ; buffers. Operations to modify data blocks in the source buffers
045B48             0868*  ; will therefore also modify those blocks in the target buffer.
045B48             0869*  ; Clearing the source buffers will not clear the target buffer -
045B48             0870*  ; it will still point to the original data blocks. Data blocks
045B48             0871*  ; are only freed from memory when no buffers are left with any
045B48             0872*  ; references to them.
045B48             0873*  
045B48             0874*  ; Buffers that get consolidated become new blocks, so will lose
045B48             0875*  ; their links to the original blocks, thus after a consolidate
045B48             0876*  ; operation modifications to the original blocks will no longer be
045B48             0877*  ; reflected in the consolidated buffer.
045B48             0878*  
045B48             0879*  ; This command is useful to construct a single buffer from multiple
045B48             0880*  ; sources without the copy overhead, which can be costly. For
045B48             0881*  ; example, this can be useful for constructing a bitmap from
045B48             0882*  ; multiple constituent parts before consolidating it into a
045B48             0883*  ; single block. In such an example, using command 13 instead
045B48             0884*  ; would first make a copy of the contents of the source buffers,
045B48             0885*  ; and then consolidate them into a single block. Using this
045B48             0886*  ; command does not make that first copy, and so would be faster.
045B48             0887*  
045B48             0888*  ; This command is also useful for creating multiple buffers that
045B48             0889*  ; all point to the same data.
045B48             0890*  
045B48             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
045B48             0892*  
045B48             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
045B48             0056       include "src/asm/vdu_plot.inc"
045B48             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045B48             0002*  ; PLOT code 	(Decimal) 	Effect
045B48             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
045B48             0004*  plot_sl_both: equ 0x00
045B48             0005*  
045B48             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
045B48             0007*  plot_sl_first: equ 0x08
045B48             0008*  
045B48             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
045B48             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
045B48             0011*  
045B48             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
045B48             0013*  plot_sl_last: equ 0x20
045B48             0014*  
045B48             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
045B48             0016*  plot_sl_none: equ 0x28
045B48             0017*  
045B48             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
045B48             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
045B48             0020*  
045B48             0021*  ; &40-&47 	64-71 	Point plot
045B48             0022*  plot_pt: equ 0x40
045B48             0023*  
045B48             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
045B48             0025*  plot_lf_lr_non_bg: equ 0x48
045B48             0026*  
045B48             0027*  ; &50-&57 	80-87 	Triangle fill
045B48             0028*  plot_tf: equ 0x50
045B48             0029*  
045B48             0030*  ; &58-&5F 	88-95 	Line fill right to background 
045B48             0031*  plot_lf_r_bg: equ 0x58
045B48             0032*  
045B48             0033*  ; &60-&67 	96-103 	Rectangle fill
045B48             0034*  plot_rf: equ 0x60
045B48             0035*  
045B48             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
045B48             0037*  plot_lf_lr_fg: equ 0x60
045B48             0038*  
045B48             0039*  ; &70-&77 	112-119 	Parallelogram fill
045B48             0040*  plot_pf: equ 0x70
045B48             0041*  
045B48             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
045B48             0043*  plot_lf_r_non_fg: equ 0x78
045B48             0044*  
045B48             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
045B48             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
045B48             0047*  
045B48             0048*  ; &90-&97 	144-151 	Circle outline
045B48             0049*  plot_co: equ 0x90
045B48             0050*  
045B48             0051*  ; &98-&9F 	152-159 	Circle fill
045B48             0052*  plot_cf: equ 0x98
045B48             0053*  
045B48             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
045B48             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
045B48             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
045B48             0057*  
045B48             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
045B48             0059*  plot_rcm: equ 0xB8
045B48             0060*  
045B48             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
045B48             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
045B48             0063*  ; &D0-&D7 	208-215 	Not defined
045B48             0064*  ; &D8-&DF 	216-223 	Not defined
045B48             0065*  ; &E0-&E7 	224-231 	Not defined
045B48             0066*  
045B48             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
045B48             0068*  plot_bmp: equ 0xE8
045B48             0069*  
045B48             0070*  ; &F0-&F7 	240-247 	Not defined
045B48             0071*  ; &F8-&FF 	248-255 	Not defined
045B48             0072*  
045B48             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
045B48             0074*  ; Agon Console8 VDP 2.2.0
045B48             0075*  
045B48             0076*  ; Within each group of eight plot codes, the effects are as follows:
045B48             0077*  ; Plot code 	Effect
045B48             0078*  ; 0 	Move relative
045B48             0079*  mv_rel: equ 0
045B48             0080*  
045B48             0081*  ; 1 	Plot relative in current foreground colour
045B48             0082*  dr_rel_fg: equ 1
045B48             0083*  
045B48             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
045B48             0085*  ; 3 	Plot relative in current background colour
045B48             0086*  dr_rel_bg: equ 3
045B48             0087*  
045B48             0088*  ; 4 	Move absolute
045B48             0089*  mv_abs: equ 4
045B48             0090*  
045B48             0091*  ; 5 	Plot absolute in current foreground colour
045B48             0092*  dr_abs_fg: equ 5
045B48             0093*  
045B48             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
045B48             0095*  ; 7 	Plot absolute in current background colour
045B48             0096*  dr_abs_bg: equ 7
045B48             0097*  
045B48             0098*  ; Codes 0-3 use the position data provided as part of the command
045B48             0099*  ; as a relative position, adding the position given to the current
045B48             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
045B48             0101*  ; as part of the command as an absolute position, setting the current
045B48             0102*  ; graphical cursor position to the position given.
045B48             0103*  
045B48             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
045B48             0105*  ; current pixel colour. These operations cannot currently be supported
045B48             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
045B48             0107*  ; supported. Support for these codes may be added in a future version
045B48             0108*  ; of the VDP firmware.
045B48             0109*  
045B48             0110*  ; 16 colour palette constants
045B48             0111*  c_black: equ 0
045B48             0112*  c_red_dk: equ 1
045B48             0113*  c_green_dk: equ 2
045B48             0114*  c_yellow_dk: equ 3
045B48             0115*  c_blue_dk: equ 4
045B48             0116*  c_magenta_dk: equ 5
045B48             0117*  c_cyan_dk: equ 6
045B48             0118*  c_grey: equ 7
045B48             0119*  c_grey_dk: equ 8
045B48             0120*  c_red: equ 9
045B48             0121*  c_green: equ 10
045B48             0122*  c_yellow: equ 11
045B48             0123*  c_blue: equ 12
045B48             0124*  c_magenta: equ 13
045B48             0125*  c_cyan: equ 14
045B48             0126*  c_white: equ 15
045B48             0127*  
045B48             0128*  ; VDU 25, mode, x; y;: PLOT command
045B48             0129*  ; inputs: a=mode, bc=x0, de=y0
045B48             0130*  vdu_plot:
045B48 32 62 5B 04 0131*      ld (@mode),a
045B4C ED 43 63 5B 0132*      ld (@x0),bc
       04          
045B51 ED 53 65 5B 0133*      ld (@y0),de
       04          
045B56 21 61 5B 04 0134*  	ld hl,@cmd
045B5A 01 06 00 00 0135*  	ld bc,@end-@cmd
045B5E 5B DF       0136*  	rst.lil $18
045B60 C9          0137*  	ret
045B61 19          0138*  @cmd:   db 25
045B62 00          0139*  @mode:  db 0
045B63 00 00       0140*  @x0: 	dw 0
045B65 00 00       0141*  @y0: 	dw 0
045B67 00          0142*  @end:   db 0 ; extra byte to soak up deu
045B68             0143*  
045B68             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045B68             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
045B68             0146*  ; VDU 25, mode, x; y;: PLOT command
045B68             0147*  ; inputs: bc=x0, de=y0
045B68             0148*  ; prerequisites: vdu_buff_select
045B68             0149*  vdu_plot_bmp:
045B68 ED 43 7F 5B 0150*      ld (@x0),bc
       04          
045B6D ED 53 81 5B 0151*      ld (@y0),de
       04          
045B72 21 7D 5B 04 0152*  	ld hl,@cmd
045B76 01 06 00 00 0153*  	ld bc,@end-@cmd
045B7A 5B DF       0154*  	rst.lil $18
045B7C C9          0155*  	ret
045B7D 19          0156*  @cmd:   db 25
045B7E ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045B7F 00 00       0158*  @x0: 	dw 0x0000
045B81 00 00       0159*  @y0: 	dw 0x0000
045B83 00          0160*  @end:   db 0x00 ; padding
045B84             0161*  
045B84             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045B84             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
045B84             0164*  ; VDU 25, mode, x; y;: PLOT command
045B84             0165*  ; inputs: bc=x0, de=y0
045B84             0166*  ; USING 16.8 FIXED POINT COORDINATES
045B84             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045B84             0168*  ;   the fractional portiion of the inputs are truncated
045B84             0169*  ;   leaving only the 16-bit integer portion
045B84             0170*  ; prerequisites: vdu_buff_select
045B84             0171*  vdu_plot_bmp168:
045B84             0172*  ; populate in the reverse of normal to keep the
045B84             0173*  ; inputs from stomping on each other
045B84 ED 53 A2 5B 0174*      ld (@y0-1),de
       04          
045B89 ED 43 A0 5B 0175*      ld (@x0-1),bc
       04          
045B8E 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
045B90 32 A0 5B 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
045B94 21 9F 5B 04 0178*  	ld hl,@cmd
045B98 01 06 00 00 0179*  	ld bc,@end-@cmd
045B9C 5B DF       0180*  	rst.lil $18
045B9E C9          0181*  	ret
045B9F 19          0182*  @cmd:   db 25
045BA0 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045BA1 00 00       0184*  @x0: 	dw 0x0000
045BA3 00 00       0185*  @y0: 	dw 0x0000
045BA5             0186*  @end:  ; no padding required b/c we shifted de right
045BA5             0187*  
045BA5             0188*  ; draw a filled rectangle
045BA5             0189*  vdu_plot_rf:
045BA5 ED 43 CC 5B 0190*      ld (@x0),bc
       04          
045BAA ED 53 CE 5B 0191*      ld (@y0),de
       04          
045BAF DD 22 D2 5B 0192*      ld (@x1),ix
       04          
045BB4 FD 22 D4 5B 0193*      ld (@y1),iy
       04          
045BB9 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
045BBB 32 D0 5B 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045BBF 21 CA 5B 04 0196*  	ld hl,@cmd0
045BC3 01 0C 00 00 0197*  	ld bc,@end-@cmd0
045BC7 5B DF       0198*  	rst.lil $18
045BC9 C9          0199*      ret
045BCA 19          0200*  @cmd0:  db 25 ; plot
045BCB 04          0201*  @arg0:  db plot_sl_both+mv_abs
045BCC 00 00       0202*  @x0:    dw 0x0000
045BCE 00 00       0203*  @y0:    dw 0x0000
045BD0 19          0204*  @cmd1:  db 25 ; plot
045BD1 65          0205*  @arg1:  db plot_rf+dr_abs_fg
045BD2 00 00       0206*  @x1:    dw 0x0000
045BD4 00 00       0207*  @y1:    dw 0x0000
045BD6 00          0208*  @end:   db 0x00 ; padding
045BD7             0209*  
045BD7             0210*  ; draw a filled circle
045BD7             0211*  vdu_plot_cf:
045BD7 ED 43 FE 5B 0212*      ld (@x0),bc
       04          
045BDC ED 53 00 5C 0213*      ld (@y0),de
       04          
045BE1 DD 22 04 5C 0214*      ld (@x1),ix
       04          
045BE6 FD 22 06 5C 0215*      ld (@y1),iy
       04          
045BEB 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
045BED 32 02 5C 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045BF1 21 FC 5B 04 0218*  	ld hl,@cmd0
045BF5 01 0C 00 00 0219*  	ld bc,@end-@cmd0
045BF9 5B DF       0220*  	rst.lil $18
045BFB C9          0221*      ret
045BFC 19          0222*  @cmd0:  db 25 ; plot
045BFD 04          0223*  @arg0:  db plot_sl_both+mv_abs
045BFE 00 00       0224*  @x0:    dw 0x0000
045C00 00 00       0225*  @y0:    dw 0x0000
045C02 19          0226*  @cmd1:  db 25 ; plot
045C03 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
045C04 00 00       0228*  @x1:    dw 0x0000
045C06 00 00       0229*  @y1:    dw 0x0000
045C08 00          0230*  @end:   db 0x00 ; padding
045C09             0057   	include "src/asm/vdu_sprites.inc"
045C09             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
045C09             0002*  ; the VDP can support up to 256 sprites. They must be defined
045C09             0003*  ; contiguously, and so the first sprite is sprite 0.
045C09             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
045C09             0005*  ; Once a selection of sprites have been defined, you can activate
045C09             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
045C09             0007*  ; of sprites to activate. This will activate the first n sprites,
045C09             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
045C09             0009*  
045C09             0010*  ; A single sprite can have multiple "frames", referring to
045C09             0011*  ; different bitmaps.
045C09             0012*  ; (These bitmaps do not need to be the same size.)
045C09             0013*  ; This allows a sprite to include an animation sequence,
045C09             0014*  ; which can be stepped through one frame at a time, or picked
045C09             0015*  ; in any order.
045C09             0016*  
045C09             0017*  ; Any format of bitmap can be used as a sprite frame. It should
045C09             0018*  ; be noted however that "native" format bitmaps are not
045C09             0019*  ; recommended for use as sprite frames, as they cannot get
045C09             0020*  ; erased from the screen. (As noted above, the "native" bitmap
045C09             0021*  ; format is not really intended for general use.) This is part
045C09             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
045C09             0023*  ; screen are now stored in RGBA2222 format.
045C09             0024*  
045C09             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
045C09             0026*  ; and then later shown again.
045C09             0027*  
045C09             0028*  ; Moving sprites around the screen is done by changing the
045C09             0029*  ; position of the sprite. This can be done either by setting
045C09             0030*  ; the absolute position of the sprite, or by moving the sprite
045C09             0031*  ; by a given number of pixels. (Sprites are positioned using
045C09             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
045C09             0033*  ; In the current sprite system, sprites will not update their
045C09             0034*  ; position on-screen until either another drawing operation is
045C09             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
045C09             0036*  
045C09             0037*  ; VDU 23, 27, 4, n: Select sprite n
045C09             0038*  ; inputs: a is the 8-bit sprite id
045C09             0039*  vdu_sprite_select:
045C09 32 1B 5C 04 0040*      ld (@sprite),a
045C0D 21 18 5C 04 0041*      ld hl,@cmd
045C11 01 04 00 00 0042*      ld bc,@end-@cmd
045C15 5B DF       0043*      rst.lil $18
045C17 C9          0044*      ret
045C18 17 1B 04    0045*  @cmd:    db 23,27,4
045C1B 00          0046*  @sprite: db 0x00
045C1C             0047*  @end:
045C1C             0048*  
045C1C             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
045C1C             0050*  ; inputs: none
045C1C             0051*  ; prerequisites: vdu_sprite_select
045C1C             0052*  vdu_sprite_clear_frames:
045C1C 21 27 5C 04 0053*      ld hl,@cmd
045C20 01 03 00 00 0054*      ld bc,@end-@cmd
045C24 5B DF       0055*      rst.lil $18
045C26 C9          0056*      ret
045C27 17 1B 05    0057*  @cmd: db 23,27,5
045C2A             0058*  @end:
045C2A             0059*  
045C2A             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045C2A             0061*  ; inputs: a is the 8-bit bitmap number
045C2A             0062*  ; prerequisites: vdu_sprite_select
045C2A             0063*  vdu_sprite_add_bmp:
045C2A 32 3C 5C 04 0064*      ld (@bmp),a
045C2E 21 39 5C 04 0065*      ld hl,@cmd
045C32 01 04 00 00 0066*      ld bc,@end-@cmd
045C36 5B DF       0067*      rst.lil $18
045C38 C9          0068*      ret
045C39 17 1B 06    0069*  @cmd: db 23,27,6
045C3C 00          0070*  @bmp: db 0x00
045C3D             0071*  @end:
045C3D             0072*  
045C3D             0073*  ; VDU 23, 27, 7, n: Activate n sprites
045C3D             0074*  ; inputs: a is the number of sprites to activate
045C3D             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
045C3D             0076*  vdu_sprite_activate:
045C3D 32 4F 5C 04 0077*      ld (@num),a
045C41 21 4C 5C 04 0078*      ld hl,@cmd
045C45 01 04 00 00 0079*      ld bc,@end-@cmd
045C49 5B DF       0080*      rst.lil $18
045C4B C9          0081*      ret
045C4C 17 1B 07    0082*  @cmd: db 23,27,7
045C4F 00          0083*  @num: db 0x00
045C50             0084*  @end:
045C50             0085*  
045C50             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
045C50             0087*  ; inputs: none
045C50             0088*  ; prerequisites: vdu_sprite_select
045C50             0089*  vdu_sprite_next_frame:
045C50 21 5B 5C 04 0090*      ld hl,@cmd
045C54 01 03 00 00 0091*      ld bc,@end-@cmd
045C58 5B DF       0092*      rst.lil $18
045C5A C9          0093*      ret
045C5B 17 1B 08    0094*  @cmd: db 23,27,8
045C5E             0095*  @end:
045C5E             0096*  
045C5E             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
045C5E             0098*  ; inputs: none
045C5E             0099*  ; prerequisites: vdu_sprite_select
045C5E             0100*  vdu_sprite_prev_frame:
045C5E 21 69 5C 04 0101*      ld hl,@cmd
045C62 01 03 00 00 0102*      ld bc,@end-@cmd
045C66 5B DF       0103*      rst.lil $18
045C68 C9          0104*      ret
045C69 17 1B 09    0105*  @cmd: db 23,27,9
045C6C             0106*  @end:
045C6C             0107*  
045C6C             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045C6C             0109*  ; inputs: a is frame number to select
045C6C             0110*  ; prerequisites: vdu_sprite_select
045C6C             0111*  vdu_sprite_select_frame:
045C6C 32 7E 5C 04 0112*      ld (@frame),a
045C70 21 7B 5C 04 0113*      ld hl,@cmd
045C74 01 04 00 00 0114*      ld bc,@end-@cmd
045C78 5B DF       0115*      rst.lil $18
045C7A C9          0116*      ret
045C7B 17 1B 0A    0117*  @cmd:    db 23,27,10
045C7E 00          0118*  @frame:  db 0x00
045C7F             0119*  @end:
045C7F             0120*  
045C7F             0121*  ; VDU 23, 27, 11: Show current sprite
045C7F             0122*  ; inputs: none
045C7F             0123*  ; prerequisites: vdu_sprite_select
045C7F             0124*  vdu_sprite_show:
045C7F 21 8A 5C 04 0125*      ld hl,@cmd
045C83 01 03 00 00 0126*      ld bc,@end-@cmd
045C87 5B DF       0127*      rst.lil $18
045C89 C9          0128*      ret
045C8A 17 1B 0B    0129*  @cmd: db 23,27,11
045C8D             0130*  @end:
045C8D             0131*  
045C8D             0132*  ; VDU 23, 27, 12: Hide current sprite
045C8D             0133*  ; inputs: none
045C8D             0134*  ; prerequisites: vdu_sprite_select
045C8D             0135*  vdu_sprite_hide:
045C8D 21 98 5C 04 0136*      ld hl,@cmd
045C91 01 03 00 00 0137*      ld bc,@end-@cmd
045C95 5B DF       0138*      rst.lil $18
045C97 C9          0139*      ret
045C98 17 1B 0C    0140*  @cmd: db 23,27,12
045C9B             0141*  @end:
045C9B             0142*  
045C9B             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045C9B             0144*  ; inputs: bc is x coordinate, de is y coordinate
045C9B             0145*  ; prerequisites: vdu_sprite_select
045C9B             0146*  vdu_sprite_move_abs:
045C9B ED 43 B3 5C 0147*      ld (@xpos),bc
       04          
045CA0 ED 53 B5 5C 0148*      ld (@ypos),de
       04          
045CA5 21 B0 5C 04 0149*      ld hl,@cmd
045CA9 01 07 00 00 0150*      ld bc,@end-@cmd
045CAD 5B DF       0151*      rst.lil $18
045CAF C9          0152*      ret
045CB0 17 1B 0D    0153*  @cmd:  db 23,27,13
045CB3 00 00       0154*  @xpos: dw 0x0000
045CB5 00 00       0155*  @ypos: dw 0x0000
045CB7 00          0156*  @end:  db 0x00 ; padding
045CB8             0157*  
045CB8             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045CB8             0159*  ; inputs: bc is x coordinate, de is y coordinate
045CB8             0160*  ; prerequisites: vdu_sprite_select
045CB8             0161*  vdu_sprite_move_rel:
045CB8 ED 43 D0 5C 0162*      ld (@dx),bc
       04          
045CBD ED 53 D2 5C 0163*      ld (@dy),de
       04          
045CC2 21 CD 5C 04 0164*      ld hl,@cmd
045CC6 01 07 00 00 0165*      ld bc,@end-@cmd
045CCA 5B DF       0166*      rst.lil $18
045CCC C9          0167*      ret
045CCD 17 1B 0E    0168*  @cmd: db 23,27,14
045CD0 00 00       0169*  @dx:  dw 0x0000
045CD2 00 00       0170*  @dy:  dw 0x0000
045CD4 00          0171*  @end: db 0x00 ; padding
045CD5             0172*  
045CD5             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045CD5             0174*  ; USING 16.8 FIXED POINT COORDINATES
045CD5             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045CD5             0176*  ;   the fractional portiion of the inputs are truncated
045CD5             0177*  ;   leaving only the 16-bit integer portion
045CD5             0178*  ; prerequisites: vdu_sprite_select
045CD5             0179*  vdu_sprite_move_abs168:
045CD5             0180*  ; populate in the reverse of normal to keep the
045CD5             0181*  ; inputs from stomping on each other
045CD5 ED 53 F4 5C 0182*      ld (@ypos-1),de
       04          
045CDA ED 43 F2 5C 0183*      ld (@xpos-1),bc
       04          
045CDF 3E 0D       0184*      ld a,13       ; restore the final byte of the command
045CE1 32 F2 5C 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
045CE5 21 F0 5C 04 0186*      ld hl,@cmd
045CE9 01 07 00 00 0187*      ld bc,@end-@cmd
045CED 5B DF       0188*      rst.lil $18
045CEF C9          0189*      ret
045CF0 17 1B 0D    0190*  @cmd:  db 23,27,13
045CF3 00 00       0191*  @xpos: dw 0x0000
045CF5 00 00       0192*  @ypos: dw 0x0000
045CF7             0193*  @end:  ; no padding required b/c we shifted de right
045CF7             0194*  
045CF7             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045CF7             0196*  ; USING 16.8 FIXED POINT COORDINATES
045CF7             0197*  ; inputs: ub.c is dx, ud.e is dy
045CF7             0198*  ;   the fractional portiion of the inputs are truncated
045CF7             0199*  ;   leaving only the 16-bit integer portion
045CF7             0200*  ; prerequisites: vdu_sprite_select
045CF7             0201*  vdu_sprite_move_rel168:
045CF7             0202*  ; populate in the reverse of normal to keep the
045CF7             0203*  ; inputs from stomping on each other
045CF7 ED 53 16 5D 0204*      ld (@dy-1),de
       04          
045CFC ED 43 14 5D 0205*      ld (@dx-1),bc
       04          
045D01 3E 0E       0206*      ld a,14       ; restore the final byte of the command
045D03 32 14 5D 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
045D07 21 12 5D 04 0208*      ld hl,@cmd
045D0B 01 07 00 00 0209*      ld bc,@end-@cmd
045D0F 5B DF       0210*      rst.lil $18
045D11 C9          0211*      ret
045D12 17 1B 0E    0212*  @cmd:  db 23,27,14
045D15 00 00       0213*  @dx: dw 0x0000
045D17 00 00       0214*  @dy: dw 0x0000
045D19             0215*  @end:  ; no padding required b/c we shifted de right
045D19             0216*  
045D19             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
045D19             0218*  ; inputs: none
045D19             0219*  vdu_sprite_update:
045D19 21 24 5D 04 0220*      ld hl,@cmd
045D1D 01 03 00 00 0221*      ld bc,@end-@cmd
045D21 5B DF       0222*      rst.lil $18
045D23 C9          0223*      ret
045D24 17 1B 0F    0224*  @cmd: db 23,27,15
045D27             0225*  @end:
045D27             0226*  
045D27             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045D27             0228*  ; inputs: none
045D27             0229*  vdu_sprite_bmp_reset:
045D27 21 32 5D 04 0230*      ld hl,@cmd
045D2B 01 03 00 00 0231*      ld bc,@end-@cmd
045D2F 5B DF       0232*      rst.lil $18
045D31 C9          0233*      ret
045D32 17 1B 10    0234*  @cmd: db 23,27,16
045D35             0235*  @end:
045D35             0236*  
045D35             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045D35             0238*  ; inputs: none
045D35             0239*  vdu_sprite_reset:
045D35 21 40 5D 04 0240*      ld hl,@cmd
045D39 01 03 00 00 0241*      ld bc,@end-@cmd
045D3D 5B DF       0242*      rst.lil $18
045D3F C9          0243*      ret
045D40 17 1B 11    0244*  @cmd: db 23,27,17
045D43             0245*  @end:
045D43             0246*  
045D43             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045D43             0248*  ; inputs: a is the GCOL paint mode
045D43             0249*  ; prerequisites: vdu_sprite_select
045D43             0250*  vdu_sprite_set_gcol:
045D43 32 55 5D 04 0251*      ld (@mode),a
045D47 21 52 5D 04 0252*      ld hl,@cmd
045D4B 01 04 00 00 0253*      ld bc,@end-@cmd
045D4F 5B DF       0254*      rst.lil $18
045D51 C9          0255*      ret
045D52 17 1B 12    0256*  @cmd:  db 23,27,18
045D55 00          0257*  @mode: db 0x00
045D56             0258*  @end:
045D56             0259*  
045D56             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045D56             0261*  ; inputs: hl=bufferId
045D56             0262*  ; prerequisites: vdu_sprite_select
045D56             0263*  vdu_sprite_add_buff:
045D56 22 68 5D 04 0264*      ld (@bufferId),hl
045D5A 21 65 5D 04 0265*      ld hl,@cmd
045D5E 01 05 00 00 0266*      ld bc,@end-@cmd
045D62 5B DF       0267*      rst.lil $18
045D64 C9          0268*      ret
045D65 17 1B 26    0269*  @cmd:      db 23,27,0x26
045D68 00 00       0270*  @bufferId: dw 0x0000
045D6A 00          0271*  @end:      db 0x00 ; padding
045D6B             0058   	include "src/asm/div_168_signed.inc"
045D6B             0001*  ; 24-bit integer and 16.8 fixed point division routines
045D6B             0002*  ; by Brandon R. Gates (BeeGee747)
045D6B             0003*  ; have undergone cursory testing and seem to be generating
045D6B             0004*  ; correct results (assuming no overflows) but seem very inefficient,
045D6B             0005*  ; so they have been published for review and improvement
045D6B             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
045D6B             0007*  ;
045D6B             0008*  ; ---------------------------------------------------------
045D6B             0009*  ; BEGIN DIVISION ROUTINES
045D6B             0010*  ; ---------------------------------------------------------
045D6B             0011*  ;
045D6B             0012*  ; perform signed division of 16.8 fixed place values
045D6B             0013*  ; with an signed 16.8 fixed place result
045D6B             0014*  ; inputs: ub.c is dividend,ud.e is divisor
045D6B             0015*  ; outputs: uh.l is quotient
045D6B             0016*  ; destroys: a,bc
045D6B             0017*  ; note: uses carry flag to test for sign of operands and result
045D6B             0018*  ;       which can be confusing and should perhaps be changed
045D6B             0019*  ; note2: helper functions abs_hlu and neg_hlu have been modified
045D6B             0020*  ;       to return accurate flags according to the origional signs
045D6B             0021*  ;       (or zero) of this function's inputs
045D6B             0022*  sdiv168:
045D6B             0023*  ; make everything positive and save signs
045D6B C5          0024*      push bc         ; get bc to hl
045D6C E1          0025*      pop hl          ; for the next call
045D6D CD 12 5E 04 0026*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
045D71 CA A4 5D 04 0027*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045D75 F5          0028*      push af         ; save sign of bc
045D76 E5          0029*      push hl         ; now put abs(hl)
045D77 C1          0030*      pop bc          ; back into bc = abs(bc)
045D78 EB          0031*      ex de,hl        ; now we do de same way
045D79 CD 12 5E 04 0032*      call abs_hlu
045D7D CA A6 5D 04 0033*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
045D81 EB          0034*      ex de,hl        ; hl back to de = abs(de)
045D82             0035*  ; determine sign of result
045D82 F2 8D 5D 04 0036*      jp p,@de_pos    ; sign positive,de is positive
045D86 F1          0037*      pop af          ; get back sign of bc
045D87 FA 96 5D 04 0038*      jp m,@result_pos  ; bc and de negative, result is positive
045D8B 18 05       0039*      jr @result_neg
045D8D             0040*  @de_pos:
045D8D F1          0041*      pop af          ; get back sign of bc
045D8E F2 96 5D 04 0042*      jp p,@result_pos   ; bc and de are both positive so result is positive
045D92             0043*                      ; fall through to result_neg
045D92             0044*  @result_neg:
045D92 AF          0045*      xor a           ; zero a and clear carry
045D93 3D          0046*      dec a           ; set sign flag to negative
045D94 18 02       0047*      jr @do_div
045D96             0048*  @result_pos:
045D96 AF          0049*      xor a           ; zero a and clear carry
045D97 3C          0050*      inc a           ; set sign flag to negative
045D98             0051*                      ; fall through to do_div
045D98             0052*  @do_div:
045D98 F5          0053*      push af         ; save sign of result
045D99 CD A9 5D 04 0054*      call udiv168
045D9D F1          0055*      pop af          ; get back sign of result
045D9E F0          0056*      ret p           ; result is positive so nothing to do
045D9F CD 22 5E 04 0057*      call neg_hlu    ; result is negative so negate it
045DA3 C9          0058*      ret
045DA4             0059*  @is_zero:           ; result is zero
045DA4 AF          0060*      xor a           ; sets zero flag, which we want,
045DA5             0061*                      ; sets pv flag which we might not (zero is parity even)
045DA5             0062*                      ; resets all others which is okay
045DA5 C9          0063*      ret
045DA6             0064*  @div_by_zero:       ; result is undefined, which isn't defined in binary
045DA6             0065*                      ; so we'll just return zero until i can think of something better
045DA6 F1          0066*      pop af          ; dummy pop
045DA7 AF          0067*      xor a           ; sets zero flag, which is ok,
045DA8             0068*                      ; sets pv flag which could be interpreted as overflow, which is good
045DA8             0069*                      ; resets all others which is okay
045DA8 C9          0070*      ret
045DA9             0071*  
045DA9             0072*  ; ; perform unsigned division of 16.8 fixed place values
045DA9             0073*  ; ; with an unsigned 16.8 fixed place result
045DA9             0074*  ; ; inputs: ub.c is dividend,ud.e is divisor
045DA9             0075*  ; ; outputs: uh.l is quotient
045DA9             0076*  ; ; destroys: a,bc
045DA9             0077*  ; udiv168:
045DA9             0078*  ; ; get the 16-bit integer part of the quotient
045DA9             0079*  ;     ; call div_24
045DA9             0080*  ;     call udiv24
045DA9             0081*  ;     ; call dumpRegistersHex
045DA9             0082*  ; ; load quotient to upper three bytes of output
045DA9             0083*  ;     ld (div168_out+1),bc
045DA9             0084*  ; ; TODO: THIS MAY BE BUGGED
045DA9             0085*  ; ; check remainder for zero, and if it is
045DA9             0086*  ; ; we can skip calculating the fractional part
045DA9             0087*  ;     add hl,de
045DA9             0088*  ;     or a
045DA9             0089*  ;     sbc hl,de
045DA9             0090*  ;     jr nz,@div256
045DA9             0091*  ;     xor a
045DA9             0092*  ;     jr @write_frac
045DA9             0093*  ; ; END TODO
045DA9             0094*  ; @div256:
045DA9             0095*  ; ; divide divisor by 256
045DA9             0096*  ;     push hl ; save remainder
045DA9             0097*  ; ; TODO: it feels like this could be more efficient
045DA9             0098*  ;     ld (ude),de
045DA9             0099*  ;     ld a,d
045DA9             0100*  ;     ld (ude),a
045DA9             0101*  ;     ld a,(ude+2)
045DA9             0102*  ;     ld (ude+1),a
045DA9             0103*  ;     xor a
045DA9             0104*  ;     ld (ude+2),a
045DA9             0105*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
045DA9             0106*  ; ; TODO: THIS MAY BE BUGGED
045DA9             0107*  ; ; now we check the shifted divisor for zero, and if it is
045DA9             0108*  ; ; we again set the fractional part to zero
045DA9             0109*  ;     add hl,de
045DA9             0110*  ;     or a
045DA9             0111*  ;     sbc hl,de
045DA9             0112*  ;     ex de,hl ; now de is where it's supposed to be
045DA9             0113*  ;     pop hl ; get remainder back
045DA9             0114*  ; ; TODO: THIS MAY BE BUGGED
045DA9             0115*  ;     jr nz,@div_frac
045DA9             0116*  ;     xor a
045DA9             0117*  ;     jr @write_frac
045DA9             0118*  ; ; END TODO
045DA9             0119*  ; ; now divide the remainder by the shifted divisor
045DA9             0120*  ; @div_frac:
045DA9             0121*  ;     push hl ; my kingdom for ld bc,hl
045DA9             0122*  ;     pop bc  ; or even ex bc,hl
045DA9             0123*  ;     ; call div_24
045DA9             0124*  ;     call udiv24
045DA9             0125*  ; ; load low byte of quotient to low byte of output
045DA9             0126*  ;     ld a,c
045DA9             0127*  ; @write_frac:
045DA9             0128*  ;     ld (div168_out),a
045DA9             0129*  ; ; load hl with return value
045DA9             0130*  ;     ld hl,(div168_out)
045DA9             0131*  ; ; load a with any overflow
045DA9             0132*  ;     ld a,(div168_out+3)
045DA9             0133*  ;     ret ; uh.l is the 16.8 result
045DA9             0134*  ; div168_out: ds 4 ; the extra byte is for overflow
045DA9             0135*  
045DA9             0136*  ; perform unsigned division of fixed place values
045DA9             0137*  ; with an unsigned 16.8 fixed place result
045DA9             0138*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
045DA9             0139*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
045DA9             0140*  ; destroys: a,bc
045DA9             0141*  udiv168:
045DA9             0142*  ; shift dividend left 8 bits
045DA9 ED 43 78 56 0143*      ld (ubc+1),bc
       04          
045DAE AF          0144*      xor a
045DAF 32 77 56 04 0145*      ld (ubc),a
045DB3 ED 4B 77 56 0146*      ld bc,(ubc)
       04          
045DB8 CD 3F 5E 04 0147*      call udiv24
045DBC             0148*  ; flip-flop outptuts to satisfy downstream consumers
045DBC             0149*  ; TODO: this is a hack and should be fixed
045DBC             0150*  ; (so says copilot ... but it's not wrong)
045DBC E5          0151*      push hl
045DBD C5          0152*      push bc
045DBE E1          0153*      pop hl
045DBF C1          0154*      pop bc
045DC0 C9          0155*      ret
045DC1             0156*  
045DC1             0157*  ; this is an adaptation of Div16 extended to 24 bits
045DC1             0158*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
045DC1             0159*  ; it works by shifting each byte of the dividend left into carry 8 times
045DC1             0160*  ; and adding the dividend into hl if the carry is set
045DC1             0161*  ; thus hl accumulates a remainder depending on the result of each iteration
045DC1             0162*  ; ---------------------------------------------------------
045DC1             0163*  ; Divide 24-bit unsigned values
045DC1             0164*  ;   with 24-bit unsigned result
045DC1             0165*  ;   and 24-bit remainder
045DC1             0166*  ; In: Divide ubc by ude
045DC1             0167*  ; Out: ubc = result, uhl = remainder
045DC1             0168*  ; Destroys: a,hl,bc
045DC1             0169*  div_24:
045DC1 21 00 00 00 0170*      ld hl,0     ; Clear accumulator for remainder
045DC5             0171*  ; put dividend in scratch so we can get at all its bytes
045DC5 ED 43 77 56 0172*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
045DCA 3A 79 56 04 0173*      ld a,(ubc+2); grab the upper byte of the dividend
045DCE 06 08       0174*      ld b,8      ; loop counter for 8 bits in a byte
045DD0             0175*  @loop0:
045DD0 17          0176*      rla         ; shift the next bit of dividend into the carry flag
045DD1 ED 6A       0177*      adc hl,hl   ; shift the remainder left one bit and add carry if any
045DD3 ED 52       0178*      sbc hl,de   ; subtract divisor from remainder
045DD5 30 01       0179*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
045DD7             0180*                  ; meaning remainder is divisible by divisor
045DD7 19          0181*      add hl,de   ; otherwise add divisor back to remainder
045DD8             0182*                  ; reversing the previous subtraction
045DD8             0183*  @noadd0:
045DD8 10 F6       0184*      djnz @loop0 ; repeat for all 8 bits
045DDA 17          0185*      rla         ; now we shift a left one more time
045DDB 2F          0186*      cpl         ; then flip its bits for some reason
045DDC 32 79 56 04 0187*      ld (ubc+2),a; magically this is the upper byte of the quotient
045DE0 3A 78 56 04 0188*      ld a,(ubc+1); now we pick up the middle byte of the dividend
045DE4 06 08       0189*      ld b,8      ; set up the next loop and do it all again ...
045DE6             0190*  @loop1:
045DE6 17          0191*      rla
045DE7 ED 6A       0192*      adc hl,hl
045DE9 ED 52       0193*      sbc hl,de
045DEB 30 01       0194*      jr nc,@noadd1
045DED 19          0195*      add hl,de
045DEE             0196*  @noadd1:
045DEE 10 F6       0197*      djnz @loop1
045DF0 17          0198*      rla
045DF1 2F          0199*      cpl
045DF2 32 78 56 04 0200*      ld (ubc+1),a ; writing the middle byte of quotient
045DF6 3A 77 56 04 0201*      ld a,(ubc)
045DFA 06 08       0202*      ld b,8
045DFC             0203*  @loop2:          ; compute low byte of quotient
045DFC 17          0204*      rla
045DFD ED 6A       0205*      adc hl,hl
045DFF ED 52       0206*      sbc hl,de
045E01 30 01       0207*      jr nc,@noadd2
045E03 19          0208*      add hl,de
045E04             0209*  @noadd2:
045E04 10 F6       0210*      djnz @loop2
045E06 17          0211*      rla
045E07 2F          0212*      cpl
045E08 32 77 56 04 0213*      ld (ubc),a  ; ... write low byte of quotient
045E0C ED 4B 77 56 0214*      ld bc,(ubc) ; load quotient into bc for return
       04          
045E11 C9          0215*      ret         ; hl already contains remainder so we're done
045E12             0216*  
045E12             0217*  ; ---------------------------------------------------------
045E12             0218*  ; BEGIN HELPER ROUTINES
045E12             0219*  ; ---------------------------------------------------------
045E12             0220*  ;
045E12             0221*  ; absolute value of hlu
045E12             0222*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
045E12             0223*  ;         s1,z0,pv0,n1,c0 if hlu was negative
045E12             0224*  ;         s0,z1,pv0,n1,c0 if hlu was zero
045E12             0225*  ;         s0,z0,pv0,n1,c0 if hlu was positive
045E12             0226*  ; destroys: a
045E12             0227*  abs_hlu:
045E12 19          0228*      add hl,de
045E13 B7          0229*      or a
045E14 ED 52       0230*      sbc hl,de
045E16 FA 1B 5E 04 0231*      jp m,@is_neg
045E1A C9          0232*      ret         ; hlu is positive or zero so we're done
045E1B             0233*  @is_neg:
045E1B F5          0234*      push af     ; otherwise, save current flags for return
045E1C CD 22 5E 04 0235*      call neg_hlu ; negate hlu
045E20 F1          0236*      pop af      ; get back flags
045E21 C9          0237*      ret
045E22             0238*  
045E22             0239*  ; flip the sign of hlu
045E22             0240*  ; inputs: hlu
045E22             0241*  ; returns: 0-hlu, flags set appropriately for the result:
045E22             0242*  ;         s1,z0,pv0,n1,c1 if result is negative
045E22             0243*  ;         s0,z1,pv0,n1,c0 if result is zero
045E22             0244*  ;         s0,z0,pv0,n1,c1 if result is positive
045E22             0245*  ; destroys a
045E22             0246*  neg_hlu:
045E22 D5          0247*      push de     ; save de
045E23 EB          0248*      ex de,hl    ; put hl into de
045E24 21 00 00 00 0249*      ld hl,0     ; clear hl
045E28 AF          0250*      xor a       ; clear carry
045E29 ED 52       0251*      sbc hl,de   ; 0-hlu = -hlu
045E2B D1          0252*      pop de      ; get de back
045E2C C9          0253*      ret         ; easy peasy
045E2D             0254*  
045E2D             0255*  ; -----------------------------------------------------------------------
045E2D             0256*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
045E2D             0257*  ;------------------------------------------------------------------------
045E2D             0258*  ;  arith24.asm
045E2D             0259*  ;  24-bit ez80 arithmetic routines
045E2D             0260*  ;  Copyright (c) Shawn Sijnstra 2024
045E2D             0261*  ;  MIT license
045E2D             0262*  ;
045E2D             0263*  ;  This library was created as a tool to help make ez80
045E2D             0264*  ;  24-bit native assembly routines for simple mathematical problems
045E2D             0265*  ;  more widely available.
045E2D             0266*  ;
045E2D             0267*  ;------------------------------------------------------------------------
045E2D             0268*  
045E2D             0269*  ;------------------------------------------------------------------------
045E2D             0270*  ; umul24:	HLU = BCU*DEU (unsigned)
045E2D             0271*  ; Preserves AF, BCU, DEU
045E2D             0272*  ; Uses a fast multiply routine.
045E2D             0273*  ;------------------------------------------------------------------------
045E2D             0274*  ; modified to take BCU as multiplier instead of HLU
045E2D             0275*  umul24:
045E2D             0276*  	; push	DE
045E2D             0277*  	; push	BC
045E2D             0278*  	; push	AF
045E2D             0279*  	; push	HL
045E2D             0280*  	; pop		BC
045E2D 3E 18       0281*      ld	 	a,24 ; No. of bits to process
045E2F 21 00 00 00 0282*      ld	 	hl,0 ; Result
045E33             0283*  umul24_lp:
045E33 29          0284*  	add	hl,hl
045E34 EB          0285*  	ex	de,hl
045E35 29          0286*  	add	hl,hl
045E36 EB          0287*  	ex	de,hl
045E37 30 01       0288*  	jr	nc,umul24_nc
045E39 09          0289*  	add	hl,bc
045E3A             0290*  umul24_nc:
045E3A 3D          0291*  	dec	a
045E3B 20 F6       0292*  	jr	nz,umul24_lp
045E3D 0B          0293*      dec bc ; debug
045E3E             0294*  	; pop	af
045E3E             0295*  	; pop	bc
045E3E             0296*  	; pop	de
045E3E C9          0297*  	ret
045E3F             0298*  
045E3F             0299*  
045E3F             0300*  ;------------------------------------------------------------------------
045E3F             0301*  ; udiv24
045E3F             0302*  ; Unsigned 24-bit division
045E3F             0303*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
045E3F             0304*  ;
045E3F             0305*  ; Uses AF BC DE HL
045E3F             0306*  ; Uses Restoring Division algorithm
045E3F             0307*  ;------------------------------------------------------------------------
045E3F             0308*  ; modified to take BCU as dividend instead of HLU
045E3F             0309*  ; and give BCU as quotient instead of DEU
045E3F             0310*  ; -----------------------------------------------------------------------
045E3F             0311*  udiv24:
045E3F             0312*  	; push	hl
045E3F             0313*  	; pop		bc	;move dividend to BCU
045E3F 21 00 00 00 0314*  	ld		hl,0	;result
045E43 A7          0315*  	and		a
045E44 ED 52       0316*  	sbc		hl,de	;test for div by 0
045E46 C8          0317*  	ret		z		;it's zero, carry flag is clear
045E47 19          0318*  	add		hl,de	;HL is 0 again
045E48 3E 18       0319*  	ld		a,24	;number of loops through.
045E4A             0320*  udiv1:
045E4A C5          0321*  	push	bc	;complicated way of doing this because of lack of access to top bits
045E4B E3          0322*  	ex		(sp),hl
045E4C 37          0323*  	scf
045E4D ED 6A       0324*  	adc	hl,hl
045E4F E3          0325*  	ex	(sp),hl
045E50 C1          0326*  	pop	bc		;we now have bc = (bc * 2) + 1
045E51             0327*  
045E51 ED 6A       0328*  	adc	hl,hl
045E53 A7          0329*  	and	a		;is this the bug
045E54 ED 52       0330*  	sbc	hl,de
045E56 30 02       0331*  	jr	nc,udiv2
045E58 19          0332*  	add	hl,de
045E59             0333*  ;	dec	c
045E59 0B          0334*  	dec	bc
045E5A             0335*  udiv2:
045E5A 3D          0336*  	dec	a
045E5B 20 ED       0337*  	jr	nz,udiv1
045E5D 37          0338*  	scf		;flag used for div0 error
045E5E             0339*  	; push	bc
045E5E             0340*  	; pop		de	;remainder
045E5E C9          0341*  	ret
045E5F             0342*  
045E5F             0343*  
045E5F             0344*  
045E5F             0345*  ;------------------------------------------------------------------------
045E5F             0346*  ; neg24
045E5F             0347*  ; Returns: HLU = 0-HLU
045E5F             0348*  ; preserves all other registers
045E5F             0349*  ;------------------------------------------------------------------------
045E5F             0350*  neg24:
045E5F D5          0351*  	push	de
045E60 EB          0352*  	ex		de,hl
045E61 21 00 00 00 0353*  	ld		hl,0
045E65 B7          0354*  	or		a
045E66 ED 52       0355*  	sbc		hl,de
045E68 D1          0356*  	pop		de
045E69 C9          0357*  	ret
045E6A             0358*  
045E6A             0359*  ;------------------------------------------------------------------------
045E6A             0360*  ; or_hlu_deu: 24 bit bitwise OR
045E6A             0361*  ; Returns: hlu = hlu OR deu
045E6A             0362*  ; preserves all other registers
045E6A             0363*  ;------------------------------------------------------------------------
045E6A             0364*  or_hlu_deu:
045E6A 22 26 5F 04 0365*  	ld	(bitbuf1),hl
045E6E ED 53 29 5F 0366*  	ld	(bitbuf2),de
       04          
045E73 D5          0367*  	push	de	;preserve DEU
045E74 C5          0368*  	push	bc	;preserve BCU
045E75 06 03       0369*  	ld		b,3
045E77 21 26 5F 04 0370*  	ld	hl,bitbuf1
045E7B 11 26 5F 04 0371*  	ld	de,bitbuf1
045E7F             0372*  orloop_24:
045E7F 1A          0373*  	ld	a,(de)
045E80 B6          0374*  	or	(hl)
045E81 12          0375*  	ld	(de),a
045E82 13          0376*  	inc	de
045E83 23          0377*  	inc	hl
045E84 10 F9       0378*  	djnz	orloop_24
045E86 2A 29 5F 04 0379*  	ld	hl,(bitbuf2)
045E8A C1          0380*  	pop		bc	;restore BC
045E8B D1          0381*  	pop		de	;restore DE
045E8C             0382*  
045E8C             0383*  ;------------------------------------------------------------------------
045E8C             0384*  ; and_hlu_deu: 24 bit bitwise AND
045E8C             0385*  ; Returns: hlu = hlu AND deu
045E8C             0386*  ; preserves all other registers
045E8C             0387*  ;------------------------------------------------------------------------
045E8C             0388*  and_hlu_deu:
045E8C 22 26 5F 04 0389*  	ld	(bitbuf1),hl
045E90 ED 53 29 5F 0390*  	ld	(bitbuf2),de
       04          
045E95 D5          0391*  	push	de	;preserve DEU
045E96 C5          0392*  	push	bc	;preserve BCU
045E97 06 03       0393*  	ld		b,3
045E99 21 26 5F 04 0394*  	ld	hl,bitbuf1
045E9D 11 26 5F 04 0395*  	ld	de,bitbuf1
045EA1             0396*  andloop_24:
045EA1 1A          0397*  	ld	a,(de)
045EA2 A6          0398*  	and	(hl)
045EA3 12          0399*  	ld	(de),a
045EA4 13          0400*  	inc	de
045EA5 23          0401*  	inc	hl
045EA6 10 F9       0402*  	djnz	andloop_24
045EA8 2A 29 5F 04 0403*  	ld	hl,(bitbuf2)
045EAC C1          0404*  	pop		bc	;restore BC
045EAD D1          0405*  	pop		de	;restore DE
045EAE             0406*  
045EAE             0407*  ;------------------------------------------------------------------------
045EAE             0408*  ; xor_hlu_deu: 24 bit bitwise XOR
045EAE             0409*  ; Returns: hlu = hlu XOR deu
045EAE             0410*  ; preserves all other registers
045EAE             0411*  ;------------------------------------------------------------------------
045EAE             0412*  xor_hlu_deu:
045EAE 22 26 5F 04 0413*  	ld	(bitbuf1),hl
045EB2 ED 53 29 5F 0414*  	ld	(bitbuf2),de
       04          
045EB7 D5          0415*  	push	de	;preserve DEU
045EB8 C5          0416*  	push	bc	;preserve BCU
045EB9 06 03       0417*  	ld		b,3
045EBB 21 26 5F 04 0418*  	ld	hl,bitbuf1
045EBF 11 26 5F 04 0419*  	ld	de,bitbuf1
045EC3             0420*  xorloop_24:
045EC3 1A          0421*  	ld	a,(de)
045EC4 AE          0422*  	xor	(hl)
045EC5 12          0423*  	ld	(de),a
045EC6 13          0424*  	inc	de
045EC7 23          0425*  	inc	hl
045EC8 10 F9       0426*  	djnz	xorloop_24
045ECA 2A 29 5F 04 0427*  	ld	hl,(bitbuf2)
045ECE C1          0428*  	pop		bc	;restore BC
045ECF D1          0429*  	pop		de	;restore DE
045ED0             0430*  
045ED0             0431*  ;------------------------------------------------------------------------
045ED0             0432*  ; shl_hlu: 24 bit shift left hlu by deu positions
045ED0             0433*  ; Returns: hlu = hlu << deu
045ED0             0434*  ;		   de = 0
045ED0             0435*  ; NOTE: only considers deu up to 16 bits.
045ED0             0436*  ; preserves all other registers
045ED0             0437*  ;------------------------------------------------------------------------
045ED0             0438*  shl_hlu:
045ED0 7A          0439*  	ld		a,d		;up to 16 bit.
045ED1 B3          0440*  	or		e
045ED2 C8          0441*  	ret		z		;we're done
045ED3 29          0442*  	add		hl,hl	;shift HLU left
045ED4 1B          0443*  	dec		de
045ED5 18 F9       0444*  	jr		shl_hlu
045ED7             0445*  
045ED7             0446*  ;------------------------------------------------------------------------
045ED7             0447*  ; shr_hlu: 24 bit shift right hlu by deu positions
045ED7             0448*  ; Returns: hlu = hlu >> deu
045ED7             0449*  ;		   de = 0
045ED7             0450*  ; NOTE: only considers deu up to 16 bits.
045ED7             0451*  ; preserves all other registers
045ED7             0452*  ;------------------------------------------------------------------------
045ED7             0453*  shr_hlu:
045ED7 22 26 5F 04 0454*  	ld		(bitbuf1),hl
045EDB 21 28 5F 04 0455*  	ld		hl,bitbuf1+2
045EDF             0456*  shr_loop:
045EDF 7A          0457*  	ld		a,d		;up to 16 bit.
045EE0 B3          0458*  	or		e
045EE1 28 0D       0459*  	jr		z,shr_done		;we're done
045EE3             0460*  ;carry is clear from or instruction
045EE3 CB 1E       0461*  	rr		(hl)
045EE5 2B          0462*  	dec		hl
045EE6 CB 1E       0463*  	rr		(hl)
045EE8 2B          0464*  	dec		hl
045EE9 CB 1E       0465*  	rr		(hl)
045EEB 23          0466*  	inc		hl
045EEC 23          0467*  	inc		hl
045EED 1B          0468*  	dec		de
045EEE 18 EF       0469*  	jr		shr_loop
045EF0             0470*  shr_done:
045EF0 2A 26 5F 04 0471*  	ld		hl,(bitbuf1)	;collect result
045EF4 C9          0472*  	ret
045EF5             0473*  
045EF5             0474*  ;------------------------------------------------------------------------
045EF5             0475*  ; divide hlu by 2, inspired by above
045EF5             0476*  ;------------------------------------------------------------------------
045EF5             0477*  hlu_div2:
045EF5 22 26 5F 04 0478*  	ld		(bitbuf1),hl
045EF9 21 28 5F 04 0479*  	ld		hl,bitbuf1+2
045EFD CB 1E       0480*  	rr		(hl)
045EFF 2B          0481*  	dec		hl
045F00 CB 1E       0482*  	rr		(hl)
045F02 2B          0483*  	dec		hl
045F03 CB 1E       0484*  	rr		(hl)
045F05 23          0485*  	inc		hl
045F06 23          0486*  	inc		hl
045F07 2A 26 5F 04 0487*      ld hl,(bitbuf1)
045F0B C9          0488*      ret
045F0C             0489*  
045F0C             0490*  ; this is my little hack to divide by 16
045F0C             0491*  hlu_div16:
045F0C AF          0492*      xor a
045F0D 29          0493*      add hl,hl
045F0E 17          0494*      rla
045F0F 29          0495*      add hl,hl
045F10 17          0496*      rla
045F11 29          0497*      add hl,hl
045F12 17          0498*      rla
045F13 29          0499*      add hl,hl
045F14 17          0500*      rla
045F15 22 22 5F 04 0501*      ld (@scratch),hl
045F19 32 25 5F 04 0502*      ld (@scratch+3),a
045F1D 2A 23 5F 04 0503*      ld hl,(@scratch+1)
045F21 C9          0504*      ret
045F22             0505*  @scratch: ds 4
045F26             0506*  
045F26             0507*  ;------------------------------------------------------------------------
045F26             0508*  ; Scratch area for calculations
045F26             0509*  ;------------------------------------------------------------------------
045F26 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
045F29 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
045F2C             0512*  
045F2C             0513*  
045F2C             0514*  ; -----------------------------------------------------------------------
045F2C             0515*  ; EEMES TUTORIALS
045F2C             0516*  ; -----------------------------------------------------------------------
045F2C             0517*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
045F2C             0518*  ; DEHL=BC*DE
045F2C             0519*  Mul16:
045F2C 21 00 00 00 0520*      ld hl,0
045F30 3E 10       0521*      ld a,16
045F32             0522*  Mul16Loop:
045F32 29          0523*      add hl,hl
045F33 CB 13       0524*      rl e
045F35 CB 12       0525*      rl d
045F37 D2 41 5F 04 0526*      jp nc,NoMul16
045F3B 09          0527*      add hl,bc
045F3C D2 41 5F 04 0528*      jp nc,NoMul16
045F40 13          0529*      inc de
045F41             0530*  NoMul16:
045F41 3D          0531*      dec a
045F42 C2 32 5F 04 0532*      jp nz,Mul16Loop
045F46 C9          0533*      ret
045F47             0534*  
045F47             0535*  ; DEUHLU=BCU*DEU
045F47             0536*  umul2448:
045F47 21 00 00 00 0537*      ld hl,0
045F4B 3E 18       0538*      ld a,24
045F4D             0539*  umul2448Loop:
045F4D 29          0540*      add hl,hl
045F4E EB          0541*      ex de,hl
045F4F ED 6A       0542*      adc hl,hl
045F51 EB          0543*      ex de,hl
045F52 D2 5C 5F 04 0544*      jp nc,Noumul2448
045F56 09          0545*      add hl,bc
045F57 D2 5C 5F 04 0546*      jp nc,Noumul2448
045F5B 13          0547*      inc de
045F5C             0548*  Noumul2448:
045F5C 3D          0549*      dec a
045F5D C2 4D 5F 04 0550*      jp nz,umul2448Loop
045F61 C9          0551*      ret
045F62             0552*  
045F62             0553*  umul168:
045F62 CD 47 5F 04 0554*      call umul2448
045F66             0555*  
045F66             0556*      ; call dumpUDEUHLHex
045F66             0557*  
045F66             0558*  ; UDEU.HL is the 32.16 fixed result
045F66             0559*  ; we want UH.L to be the 16.8 fixed result
045F66             0560*  ; so we divide by 256 by shiftng down a byte
045F66             0561*  ; easiest way is to write deu and hlu to scratch
045F66 ED 53 7B 5F 0562*      ld (umul168out+3),de
       04          
045F6B 22 78 5F 04 0563*      ld (umul168out),hl
045F6F             0564*  ; then load hlu from scratch shfited forward a byte
045F6F 2A 79 5F 04 0565*      ld hl,(umul168out+1)
045F73 3A 7D 5F 04 0566*      ld a,(umul168out+5) ; send a back with any overflow
045F77 C9          0567*      ret
045F78             0568*  umul168out: ds 6
045F7E             0569*  
045F7E             0570*  ; perform signed multiplication of 16.8 fixed place values
045F7E             0571*  ; with an signed 16.8 fixed place result
045F7E             0572*  ; inputs: ub.c and ud.e are the operands
045F7E             0573*  ; outputs: uh.l is the product
045F7E             0574*  ; destroys: a,bc
045F7E             0575*  ; TODO: make flags appropriate to the sign of the result
045F7E             0576*  smul168:
045F7E             0577*  ; make everything positive and save signs
045F7E C5          0578*      push bc         ; get bc to hl
045F7F E1          0579*      pop hl          ; for the next call
045F80 CD 12 5E 04 0580*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
045F84             0581*  
045F84             0582*      ; call dumpFlags ; passes
045F84             0583*  
045F84 CA B7 5F 04 0584*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045F88 F5          0585*      push af         ; save sign of bc
045F89 E5          0586*      push hl         ; now put abs(hl)
045F8A C1          0587*      pop bc          ; back into bc = abs(bc)
045F8B EB          0588*      ex de,hl        ; now we do de same way
045F8C CD 12 5E 04 0589*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
045F90             0590*  
045F90             0591*      ; call dumpFlags ; passes
045F90             0592*  
045F90 CA B7 5F 04 0593*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
045F94 EB          0594*      ex de,hl        ; hl back to de = abs(de)
045F95             0595*  ; determine sign of result
045F95 F2 A0 5F 04 0596*      jp p,@de_pos    ; sign positive,de is positive
045F99             0597*  
045F99             0598*      ; call dumpFlags ; correctly doesnt make it here
045F99             0599*  
045F99 F1          0600*      pop af          ; get back sign of bc
045F9A             0601*  
045F9A             0602*      ; call dumpFlags ; correctly doesn't make it here
045F9A             0603*  
045F9A FA A9 5F 04 0604*      jp m,@result_pos  ; bc and de negative, result is positive
045F9E             0605*  
045F9E             0606*      ; call dumpFlags  ; corectly doesn't make it here
045F9E             0607*  
045F9E 18 05       0608*      jr @result_neg
045FA0             0609*  @de_pos:
045FA0 F1          0610*      pop af          ; get back sign of bc
045FA1             0611*  
045FA1             0612*      ; call dumpFlags  ; passes
045FA1             0613*  
045FA1 F2 A9 5F 04 0614*      jp p,@result_pos   ; bc and de are both positive so result is positive
045FA5             0615*  
045FA5             0616*      ; call dumpFlags ; correctly makes it here
045FA5             0617*  
045FA5             0618*                      ; fall through to result_neg
045FA5             0619*  @result_neg:
045FA5 AF          0620*      xor a           ; zero a and clear carry
045FA6 3D          0621*      dec a           ; set sign flag to negative
045FA7             0622*  
045FA7             0623*      ; call dumpFlags ; passes
045FA7             0624*  
045FA7 18 02       0625*      jr @do_mul
045FA9             0626*  @result_pos:
045FA9 AF          0627*      xor a           ; zero a and clear carry
045FAA 3C          0628*      inc a           ; set sign flag to positive
045FAB             0629*                      ; fall through to do_mul
045FAB             0630*  
045FAB             0631*      ; call dumpFlags ; correctly doesn't make it here
045FAB             0632*  
045FAB             0633*  @do_mul:
045FAB F5          0634*      push af         ; save sign of result
045FAC CD 62 5F 04 0635*      call umul168
045FB0 F1          0636*      pop af          ; get back sign of result
045FB1             0637*  
045FB1             0638*      ; call dumpFlags ; passes
045FB1             0639*  
045FB1 F0          0640*      ret p           ; result is positive so nothing to do
045FB2             0641*  
045FB2             0642*      ; call dumpRegistersHex ; passes
045FB2             0643*  
045FB2 CD 22 5E 04 0644*      call neg_hlu    ; result is negative so negate it
045FB6             0645*  
045FB6             0646*      ; call dumpRegistersHex ; passes
045FB6 C9          0647*      ret
045FB7             0648*  @is_zero:           ; result is zero
045FB7 AF          0649*      xor a           ; sets zero flag, which we want,
045FB8             0650*                      ; sets pv flag which we might not (zero is parity even)
045FB8             0651*                      ; resets all others which is okay
045FB8 C9          0652*      ret
045FB9             0059   	include "src/asm/maths24.inc"
045FB9             0001*  ; http://www.z80.info/pseudo-random.txt
045FB9             0002*  rand_8:
045FB9 C5          0003*      push bc
045FBA 3A CD 5F 04 0004*      ld a,(r_seed)
045FBE 4F          0005*      ld c,a
045FBF             0006*  
045FBF 0F          0007*      rrca ; multiply by 32
045FC0 0F          0008*      rrca
045FC1 0F          0009*      rrca
045FC2 EE 1F       0010*      xor 0x1f
045FC4             0011*  
045FC4 81          0012*      add a,c
045FC5 DE FF       0013*      sbc a,255 ; carry
045FC7             0014*  
045FC7 32 CD 5F 04 0015*      ld (r_seed),a
045FCB C1          0016*      pop bc
045FCC C9          0017*      ret
045FCD 50          0018*  r_seed: defb $50
045FCE             0019*  
045FCE             0020*  ; tests the sign of 24-bit register hlu
045FCE             0021*  ; returns: a in [-1,0,1]
045FCE             0022*  ;   sign and zero flags as expected
045FCE             0023*  ;   hl is untouched
045FCE             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
045FCE             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
045FCE             0026*  get_sign_hlu:
045FCE             0027*      ; Load the upper byte of HLU into A
045FCE E5          0028*      push hl
045FCF DD 21 00 00 0029*      ld ix,0
       00          
045FD4 DD 39       0030*      add ix,sp
045FD6 DD 7E 02    0031*      ld a,(ix+2)
045FD9 E1          0032*      pop hl
045FDA             0033*  
045FDA B5          0034*      or l                ; OR with the low byte to check if HL is zero
045FDB C8          0035*      ret z               ; Return if HL is zero
045FDC             0036*  
045FDC 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
045FDE CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
045FE0 C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
045FE1             0040*  
045FE1 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
045FE3 A7          0042*      and a               ; Reset the zero flag
045FE4 C9          0043*      ret                 ; Return with A set to 1
045FE5             0044*  
045FE5             0045*  ; 16.8 fixed inputs / outputs
045FE5             0046*  ; takes: uh.l as angle in degrees 256
045FE5             0047*  ;        ud.e as radius
045FE5             0048*  ; returns ub.c as dx, ud.e as dy
045FE5             0049*  ;        displacements from origin (0,0)
045FE5             0050*  ; destroys: everything except indexes
045FE5             0051*  polar_to_cartesian:
045FE5             0052*  ; back up input parameters
045FE5 22 74 56 04 0053*      ld (uhl),hl
045FE9 ED 53 7A 56 0054*      ld (ude),de
       04          
045FEE             0055*  ; compute dx = sin(uh.l) * ud.e
045FEE CD 1D 60 04 0056*      call sin168
045FF2 E5          0057*      push hl
045FF3 C1          0058*      pop bc ; ub.c = sin(uh.l)
045FF4 ED 5B 7A 56 0059*  	ld de,(ude) ; get radius back
       04          
045FF9 CD 7E 5F 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
045FFD E5          0061*      push hl ; store dx for output
045FFE             0062*  ; compute dy = -cos(uh.l) * ud.e
045FFE 2A 74 56 04 0063*      ld hl,(uhl)
046002 CD 18 60 04 0064*      call cos168
046006 CD 22 5E 04 0065*  	call neg_hlu ; invert dy for screen coords convention
04600A E5          0066*      push hl
04600B C1          0067*      pop bc ; ub.c = -cos(uh.l)
04600C ED 5B 7A 56 0068*      ld de,(ude) ; get radius back
       04          
046011 CD 7E 5F 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
046015 EB          0070*      ex de,hl    ; de = dy for output
046016 C1          0071*      pop bc      ; bc = dx for output
046017             0072*  ; and out
046017 C9          0073*      ret
046018             0074*  
046018             0075*  ; fixed 16.8 routine
046018             0076*  ; cos(uh.l) --> uh.l
046018             0077*  ; destroys: de
046018             0078*  cos168:
046018             0079*  ; for cos we simply increment the angle by 90 degrees
046018             0080*  ; or 0x004000 in 16.8 degrees256
046018             0081*  ; which makes it a sin problem
046018 11 00 40 00 0082*      ld de,0x004000
04601C 19          0083*      add hl,de ; modulo 256 happens below
04601D             0084*  ; fall through to sin168
04601D             0085*  ; ---------------------
04601D             0086*  ; fixed 16.8 routine
04601D             0087*  ; sin(uh.l) --> uh.l
04601D             0088*  ; destroys: de
04601D             0089*  sin168:
04601D             0090*  ; h contains the integer portion of our angle
04601D             0091*  ; we multiply it by three to get our lookup table index
04601D 2E 03       0092*      ld l,3
04601F ED 6C       0093*      mlt hl ; gosh that is handy
046021 11 00 00 00 0094*      ld de,0 ; clear deu
046025 54          0095*      ld d,h ; copy hl to de
046026 5D          0096*      ld e,l ; de contains our index
046027 21 2E 62 04 0097*      ld hl,sin_lut_168 ; grab the lut address
04602B 19          0098*      add hl,de ; bump hl by the index
04602C ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
04602E C9          0100*      ret ; and out
04602F             0101*  
04602F             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04602F             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04602F             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
04602F             0105*  ;         also populates scratch locations dx168 and dy168
04602F             0106*  ; destroys: a,hl,bc,de
04602F             0107*  dxy168:
04602F             0108*  ; compute dx = x1-x0
04602F AF          0109*      xor a ; clear carry
046030 DD E5       0110*      push ix ; move ix to hl via the stack
046032 E1          0111*      pop hl ; hl = x1
046033 ED 42       0112*      sbc hl,bc ; hl = dx
046035 22 8A 60 04 0113*      ld (dx168),hl ; dx to scratch
046039             0114*  ; compute dy = y1-y0
046039 AF          0115*      xor a ; clear carry
04603A FD E5       0116*      push iy ; move iy to hl via the stack
04603C E1          0117*      pop hl ; hl = y1
04603D ED 52       0118*      sbc hl,de ; hl = dy
04603F 22 90 60 04 0119*      ld (dy168),hl ; dy to scratch
046043             0120*  ; populate output registers and return
046043 EB          0121*      ex de,hl        ; ud.e = dy
046044 ED 4B 8A 60 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
046049 C9          0123*      ret
04604A             0124*  
04604A             0125*  ; compute the euclidian distance between two cartesian coordinates
04604A             0126*  ; using the formula d = sqrt(dx^2+dy^2
04604A             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04604A             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04604A             0129*  ; output; uh.l is the 16.8 fixed format distance
04604A             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
04604A             0131*  ; destroys: a,hl,bc,de
04604A             0132*  distance168:
04604A             0133*  ; compute dx = x1-x0
04604A AF          0134*      xor a ; clear carry
04604B DD E5       0135*      push ix ; move ix to hl via the stack
04604D E1          0136*      pop hl ; hl = x1
04604E ED 42       0137*      sbc hl,bc ; hl = dx
046050 22 8A 60 04 0138*      ld (dx168),hl ; dx to scratch
046054             0139*  ; ; test dx for overflow
046054             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
046054             0141*  ; 	ex de,hl
046054             0142*  ; 	sbc hl,de ; test for overflow
046054             0143*  ; 	push af ; carry indicates overflow
046054             0144*  ; compute dy = y1-y0
046054 AF          0145*      xor a ; clear carry
046055 FD E5       0146*      push iy ; move iy to hl via the stack
046057 E1          0147*      pop hl ; hl = y1
046058 ED 52       0148*      sbc hl,de ; hl = dy
04605A 22 90 60 04 0149*      ld (dy168),hl ; dy to scratch
04605E             0150*  ; ; test dy for overflow
04605E             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
04605E             0152*  ; 	ex de,hl
04605E             0153*  ; 	sbc hl,de ; test for overflow
04605E             0154*  ; 	push af ; carry indicates overflow
04605E             0155*  ; compute dy^2
04605E 2A 90 60 04 0156*  	ld hl,(dy168)
046062 CD 12 5E 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
046066             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046066 E5          0159*      push hl ; load hl/2 to bc via the stack
046067 C1          0160*      pop bc ; bc = dy/2
046068 EB          0161*      ex de,hl ; de = dy/2
046069 CD 62 5F 04 0162*      call umul168 ; uh.l = dy^2/2
04606D E5          0163*      push hl ; dy^2/2 to the stack
04606E             0164*  ; compute dx^2
04606E 2A 8A 60 04 0165*      ld hl,(dx168) ; get back dx
046072 CD 12 5E 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
046076             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046076 E5          0168*      push hl ; load hl/2 to bc via the stack
046077 C1          0169*      pop bc ; bc = dx/2
046078 EB          0170*      ex de,hl ; de = dx/2
046079 CD 62 5F 04 0171*      call umul168 ; uh.l = dx^2/2
04607D             0172*  ; commpute dy^2+dx^2
04607D D1          0173*      pop de ; get back dx^2/2
04607E 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
04607F             0175*  ; compute sqrt(dx^2/2+dy^2/2)
04607F CD 43 61 04 0176*      call sqrt168 ; uh.l = distance/2
046083             0177*      ; add hl,hl ; hl = distance
046083             0178*  ; ; check for overflow
046083             0179*  ; 	pop af ; get back the overflow flags
046083             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
046083             0181*  ; 	ld b,a ; save the overflow flag
046083             0182*  ; 	pop af ; get back the overflow flags
046083             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
046083             0184*  ; 	add a,b ; if a != 0 then we had overflow
046083             0185*  ;     ret z ; no overflow we're done
046083             0186*  ; @overflow:
046083             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
046083 C9          0188*  	ret
046084             0189*  @scratch: ds 6
04608A             0190*  dx168: ds 6
046090             0191*  dy168: ds 6
046096             0192*  
046096             0193*  ; atan2(ub.c,ud.e) --> uh.l
046096             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046096             0195*  ;   whether inputs are integers or fractional doesn't matter
046096             0196*  ;   so long as the sign bit of the upper byte is correct
046096             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
046096             0198*  ; angles are COMPASS HEADINGS based on
046096             0199*  ; screen coordinate conventions,where the y axis is flipped
046096             0200*  ; #E0 315      0       45 #20
046096             0201*  ;        -x,-y | +x,-y
046096             0202*  ; #C0 270------+------ 90 #40
046096             0203*  ;        -x,+y | +x,+y
046096             0204*  ; #A0 225   180 #80   135 #60
046096             0205*  atan2_168game:
046096             0206*  ; get signs and make everything positive
046096             0207*  ; get abs(x) and store its original sign
046096 C5          0208*      push bc
046097 E1          0209*      pop hl
046098 CD 12 5E 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
04609C E5          0211*      push hl ; store abs(x)
04609D C1          0212*      pop bc ; bc = abs(x)
04609E F5          0213*      push af ; store sign of x
04609F             0214*  ; get abs(y) and store its original sign
04609F EB          0215*      ex de,hl ; hl = y
0460A0 CD 12 5E 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
0460A4 EB          0217*      ex de,hl ; de = abs(y)
0460A5 F5          0218*      push af ; store sign of y
0460A6             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0460A6             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
0460A6 AF          0221*      xor a ; clear the carry flag
0460A7 D5          0222*      push de
0460A8 E1          0223*      pop hl
0460A9 ED 42       0224*      sbc hl,bc
0460AB F5          0225*      push af ; save sign of de - bc
0460AC F2 B5 60 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
0460B0             0227*  ; otherwise we swap bc and de
0460B0 C5          0228*      push bc
0460B1 E1          0229*      pop hl
0460B2 EB          0230*      ex de,hl
0460B3 E5          0231*      push hl
0460B4 C1          0232*      pop bc
0460B5             0233*  @1:
0460B5             0234*  ; now we're ready to snag our preliminary result
0460B5 CD 23 61 04 0235*      call atan_168game ; uh.l comes back with prelim result
0460B9             0236*  ; now we adjust uh.l based on sign of de - bc
0460B9 F1          0237*      pop af
0460BA F2 C6 60 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
0460BE EB          0239*      ex de,hl
0460BF 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
0460C3 AF          0241*      xor a ; clear the carry flag
0460C4 ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
0460C6             0243*      ; ld de,0 ; prep to clear hlu
0460C6             0244*      ; ld d,h
0460C6             0245*      ; ld e,l
0460C6             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0460C6             0247*      ; fall through
0460C6             0248*  @2:
0460C6             0249*  ; now the fun part of adjusting the result
0460C6             0250*  ; based on which quadrant (x,y) is in
0460C6             0251*  ; #E0 315      0       45 #20
0460C6             0252*  ;        -x,-y | +x,-y
0460C6             0253*  ; #C0 270------+------ 90 #40
0460C6             0254*  ;        -x,+y | +x,+y
0460C6             0255*  ; #A0 225   180 #80   135 #60
0460C6 F1          0256*      pop af ; sign of y
0460C7 CA 04 61 04 0257*      jp z,@y_zero
0460CB F2 E4 60 04 0258*      jp p,@y_pos
0460CF             0259*  ; y neg,check x
0460CF F1          0260*      pop af ; sign of x
0460D0 CA DE 60 04 0261*      jp z,@y_neg_x_zero
0460D4 F2 E3 60 04 0262*      jp p,@y_neg_x_pos
0460D8             0263*  ; y neg,x neg
0460D8             0264*  ; angle is 270-360
0460D8             0265*  ; negating the intermediate does the trick
0460D8 CD 22 5E 04 0266*      call neg_hlu
0460DC 18 31       0267*      jr @zero_hlu
0460DE             0268*  
0460DE             0269*  @y_neg_x_zero:
0460DE             0270*  ; y neg,x zero
0460DE             0271*  ; angle is 0
0460DE 21 00 00 00 0272*      ld hl,0
0460E2 C9          0273*      ret
0460E3             0274*  @y_neg_x_pos:
0460E3             0275*  ; y neg,x pos
0460E3             0276*  ; angle is 0 to 90
0460E3             0277*  ; so we're good
0460E3 C9          0278*      ret
0460E4             0279*  
0460E4             0280*  @y_pos:
0460E4 F1          0281*      pop af ; sign of x
0460E5 CA F4 60 04 0282*      jp z,@y_pos_x_zero
0460E9 F2 F9 60 04 0283*      jp p,@y_pos_x_pos
0460ED             0284*  ; y pos,x neg
0460ED             0285*  ; angle is 180-270
0460ED             0286*  ; so we add 180 to intermediate
0460ED 11 00 80 00 0287*      ld de,0x008000
0460F1 19          0288*      add hl,de
0460F2 18 1B       0289*      jr @zero_hlu
0460F4             0290*  @y_pos_x_zero:
0460F4             0291*  ; y pos,x zero
0460F4             0292*  ; angle is 180
0460F4 21 00 80 00 0293*      ld hl,0x008000
0460F8 C9          0294*      ret
0460F9             0295*  @y_pos_x_pos:
0460F9             0296*  ; y pos,x pos
0460F9             0297*  ; angle is 90-180
0460F9             0298*  ; neg the intermediate and add 180 degrees
0460F9 CD 22 5E 04 0299*      call neg_hlu
0460FD 11 00 80 00 0300*      ld de,0x008000
046101 19          0301*      add hl,de
046102 18 0B       0302*      jr @zero_hlu
046104             0303*  
046104             0304*  @y_zero:
046104 F1          0305*      pop af ; sign of x
046105 FA 0A 61 04 0306*      jp m,@y_zero_x_neg
046109             0307*  ; y zero,x pos
046109             0308*  ; angle is 90,nothing to do
046109 C9          0309*      ret
04610A             0310*  @y_zero_x_neg:
04610A             0311*  ; y zero ,x neg
04610A             0312*  ; angle is 270
04610A 21 00 C0 00 0313*      ld hl,0x00C000
04610E C9          0314*      ret
04610F             0315*  @zero_hlu:
04610F AF          0316*      xor a
046110 22 1D 61 04 0317*      ld (@scratch),hl
046114 32 1F 61 04 0318*      ld (@scratch+2),a
046118 2A 1D 61 04 0319*      ld hl,(@scratch)
04611C C9          0320*      ret
04611D             0321*  @scratch: ds 6
046123             0322*  
046123             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046123             0324*  ; output: uh.l is the 16.8 fixed format angle
046123             0325*  ; destroys: a,hl,bc,de
046123             0326*  ; the following note was written by github copilot:
046123             0327*  ; note: this routine is a bit of a hack
046123             0328*  ;      but it works
046123             0329*  ;      and it's fast
046123             0330*  ;      and it's small
046123             0331*  ;      and it's accurate
046123             0332*  ;      and it's easy to understand
046123             0333*  ;      and it's easy to modify
046123             0334*  ;      and it's easy to use
046123             0335*  ;      and it's easy to remember
046123             0336*  ;      and it's easy to love
046123             0337*  ;      and it's easy to hate
046123             0338*  ;      and it's easy to ignore
046123             0339*  ;      and it's easy to forget
046123             0340*  ;      and it's easy to remember
046123             0341*  ;      and it's easy to forget
046123             0342*  ;      and it's easy to remember
046123             0343*  ;      (ok the bot is stuck in a loop)
046123             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
046123             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
046123             0346*  atan_168game:
046123             0347*  ; because we use compass headings instead of geometric angles
046123             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
046123             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
046123 CD A9 5D 04 0350*  	call udiv168 ; uh.l = dx/dy
046127             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
046127             0352*  ; ; test uh.l for 0
046127             0353*  ;     add hl,de
046127             0354*  ;     or a
046127             0355*  ;     sbc hl,de
046127             0356*  ;     jr z,@is_zero
046127             0357*  ; ; test uh.l for 1
046127             0358*  ;     xor a ; clear carry
046127             0359*  ;     ex de,hl
046127             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
046127             0361*  ;     sbc hl,de
046127             0362*  ;     jr z,@is_45
046127             0363*  ; ; END TODO
046127             0364*  
046127             0365*  ; no special cases so we move on
046127             0366*  ; l contains the fractional portion of tan(uh.l)
046127             0367*  ; we multiply it by three to get our lookup table index
046127 26 03       0368*      ld h,3
046129 ED 6C       0369*      mlt hl ; gosh that is handy
04612B 11 00 00 00 0370*      ld de,0 ; clear deu
04612F 54          0371*      ld d,h ; copy hl to de
046130 5D          0372*      ld e,l ; de contains our index
046131 21 2E 65 04 0373*      ld hl,atan_lut_168 ; grab the lut address
046135 19          0374*      add hl,de ; bump hl by the index
046136 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
046138 C9          0376*      ret ; and out
046139             0377*  @is_45:
046139 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
04613D C9          0379*      ret
04613E             0380*  ; for the case tan(0)
04613E             0381*  @is_zero:
04613E 21 00 00 00 0382*      ld hl,0x000000
046142 C9          0383*      ret
046143             0384*  
046143             0385*  ; Expects  ADL mode
046143             0386*  ; Inputs:  UH.L
046143             0387*  ; Outputs: UH.L is the 16.8 square root
046143             0388*  ;          UD.E is the difference inputHL-DE^2
046143             0389*  ;          c flag reset
046143             0390*  sqrt168:
046143 CD 4D 61 04 0391*      call sqrt24
046147 EB          0392*      ex de,hl
046148 29          0393*      add hl,hl
046149 29          0394*      add hl,hl
04614A 29          0395*      add hl,hl
04614B 29          0396*      add hl,hl
04614C C9          0397*      ret
04614D             0398*  
04614D             0399*  ; Expects  ADL mode
04614D             0400*  ; Inputs:  HL
04614D             0401*  ; Outputs: DE is the integer square root
04614D             0402*  ;          HL is the difference inputHL-DE^2
04614D             0403*  ;          c flag reset
04614D             0404*  sqrt24:
04614D AF          0405*      xor a
04614E 45          0406*      ld b,l
04614F C5          0407*      push bc
046150 47          0408*      ld b,a
046151 57          0409*      ld d,a
046152 4F          0410*      ld c,a
046153 6F          0411*      ld l,a
046154 5F          0412*      ld e,a
046155             0413*  
046155             0414*      ;Iteration 1
046155 29          0415*      add hl,hl
046156 CB 11       0416*      rl c
046158 29          0417*      add hl,hl
046159 CB 11       0418*      rl c
04615B 91          0419*      sub c
04615C 30 04       0420*      jr nc,$+6
04615E 1C          0421*      inc e
04615F 1C          0422*      inc e
046160 2F          0423*      cpl
046161 4F          0424*      ld c,a
046162             0425*  
046162             0426*      ;Iteration 2
046162 29          0427*      add hl,hl
046163 CB 11       0428*      rl c
046165 29          0429*      add hl,hl
046166 CB 11       0430*      rl c
046168 CB 13       0431*      rl e
04616A 7B          0432*      ld a,e
04616B 91          0433*      sub c
04616C 30 04       0434*      jr nc,$+6
04616E 1C          0435*      inc e
04616F 1C          0436*      inc e
046170 2F          0437*      cpl
046171 4F          0438*      ld c,a
046172             0439*  
046172             0440*      ;Iteration 3
046172 29          0441*      add hl,hl
046173 CB 11       0442*      rl c
046175 29          0443*      add hl,hl
046176 CB 11       0444*      rl c
046178 CB 13       0445*      rl e
04617A 7B          0446*      ld a,e
04617B 91          0447*      sub c
04617C 30 04       0448*      jr nc,$+6
04617E 1C          0449*      inc e
04617F 1C          0450*      inc e
046180 2F          0451*      cpl
046181 4F          0452*      ld c,a
046182             0453*  
046182             0454*      ;Iteration 4
046182 29          0455*      add hl,hl
046183 CB 11       0456*      rl c
046185 29          0457*      add hl,hl
046186 CB 11       0458*      rl c
046188 CB 13       0459*      rl e
04618A 7B          0460*      ld a,e
04618B 91          0461*      sub c
04618C 30 04       0462*      jr nc,$+6
04618E 1C          0463*      inc e
04618F 1C          0464*      inc e
046190 2F          0465*      cpl
046191 4F          0466*      ld c,a
046192             0467*  
046192             0468*      ;Iteration 5
046192 29          0469*      add hl,hl
046193 CB 11       0470*      rl c
046195 29          0471*      add hl,hl
046196 CB 11       0472*      rl c
046198 CB 13       0473*      rl e
04619A 7B          0474*      ld a,e
04619B 91          0475*      sub c
04619C 30 04       0476*      jr nc,$+6
04619E 1C          0477*      inc e
04619F 1C          0478*      inc e
0461A0 2F          0479*      cpl
0461A1 4F          0480*      ld c,a
0461A2             0481*  
0461A2             0482*      ;Iteration 6
0461A2 29          0483*      add hl,hl
0461A3 CB 11       0484*      rl c
0461A5 29          0485*      add hl,hl
0461A6 CB 11       0486*      rl c
0461A8 CB 13       0487*      rl e
0461AA 7B          0488*      ld a,e
0461AB 91          0489*      sub c
0461AC 30 04       0490*      jr nc,$+6
0461AE 1C          0491*      inc e
0461AF 1C          0492*      inc e
0461B0 2F          0493*      cpl
0461B1 4F          0494*      ld c,a
0461B2             0495*  
0461B2             0496*      ;Iteration 7
0461B2 29          0497*      add hl,hl
0461B3 CB 11       0498*      rl c
0461B5 29          0499*      add hl,hl
0461B6 CB 11       0500*      rl c
0461B8 CB 10       0501*      rl b
0461BA EB          0502*      ex de,hl
0461BB 29          0503*      add hl,hl
0461BC E5          0504*      push hl
0461BD ED 42       0505*      sbc hl,bc
0461BF 30 06       0506*      jr nc,$+8
0461C1 7C          0507*      ld a,h
0461C2 2F          0508*      cpl
0461C3 47          0509*      ld b,a
0461C4 7D          0510*      ld a,l
0461C5 2F          0511*      cpl
0461C6 4F          0512*      ld c,a
0461C7 E1          0513*      pop hl
0461C8 30 02       0514*      jr nc,$+4
0461CA 23          0515*      inc hl
0461CB 23          0516*      inc hl
0461CC EB          0517*      ex de,hl
0461CD             0518*  
0461CD             0519*      ;Iteration 8
0461CD 29          0520*      add hl,hl
0461CE 69          0521*      ld l,c
0461CF 60          0522*      ld h,b
0461D0 ED 6A       0523*      adc hl,hl
0461D2 ED 6A       0524*      adc hl,hl
0461D4 EB          0525*      ex de,hl
0461D5 29          0526*      add hl,hl
0461D6 ED 52       0527*      sbc hl,de
0461D8 19          0528*      add hl,de
0461D9 EB          0529*      ex de,hl
0461DA 30 04       0530*      jr nc,$+6
0461DC ED 52       0531*      sbc hl,de
0461DE 13          0532*      inc de
0461DF 13          0533*      inc de
0461E0             0534*  
0461E0             0535*      ;Iteration 9
0461E0 F1          0536*      pop af
0461E1 17          0537*      rla
0461E2 ED 6A       0538*      adc hl,hl
0461E4 17          0539*      rla
0461E5 ED 6A       0540*      adc hl,hl
0461E7 EB          0541*      ex de,hl
0461E8 29          0542*      add hl,hl
0461E9 ED 52       0543*      sbc hl,de
0461EB 19          0544*      add hl,de
0461EC EB          0545*      ex de,hl
0461ED 30 04       0546*      jr nc,$+6
0461EF ED 52       0547*      sbc hl,de
0461F1 13          0548*      inc de
0461F2 13          0549*      inc de
0461F3             0550*  
0461F3             0551*      ;Iteration 10
0461F3 17          0552*      rla
0461F4 ED 6A       0553*      adc hl,hl
0461F6 17          0554*      rla
0461F7 ED 6A       0555*      adc hl,hl
0461F9 EB          0556*      ex de,hl
0461FA 29          0557*      add hl,hl
0461FB ED 52       0558*      sbc hl,de
0461FD 19          0559*      add hl,de
0461FE EB          0560*      ex de,hl
0461FF 30 04       0561*      jr nc,$+6
046201 ED 52       0562*      sbc hl,de
046203 13          0563*      inc de
046204 13          0564*      inc de
046205             0565*  
046205             0566*      ;Iteration 11
046205 17          0567*      rla
046206 ED 6A       0568*      adc hl,hl
046208 17          0569*      rla
046209 ED 6A       0570*      adc hl,hl
04620B EB          0571*      ex de,hl
04620C 29          0572*      add hl,hl
04620D ED 52       0573*      sbc hl,de
04620F 19          0574*      add hl,de
046210 EB          0575*      ex de,hl
046211 30 04       0576*      jr nc,$+6
046213 ED 52       0577*      sbc hl,de
046215 13          0578*      inc de
046216 13          0579*      inc de
046217             0580*  
046217             0581*      ;Iteration 11
046217 17          0582*      rla
046218 ED 6A       0583*      adc hl,hl
04621A 17          0584*      rla
04621B ED 6A       0585*      adc hl,hl
04621D EB          0586*      ex de,hl
04621E 29          0587*      add hl,hl
04621F ED 52       0588*      sbc hl,de
046221 19          0589*      add hl,de
046222 EB          0590*      ex de,hl
046223 30 04       0591*      jr nc,$+6
046225 ED 52       0592*      sbc hl,de
046227 13          0593*      inc de
046228 13          0594*      inc de
046229             0595*  
046229 CB 1A       0596*      rr d
04622B CB 1B       0597*      rr e
04622D C9          0598*      ret
04622E             0599*  
04622E             0600*  sin_lut_168:
04622E 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
046231 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
046234 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
046237 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
04623A 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
04623D 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
046240 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
046243 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
046246 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
046249 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
04624C 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
04624F 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
046252 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
046255 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
046258 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
04625B 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
04625E 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
046261 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
046264 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
046267 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
04626A 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
04626D 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
046270 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
046273 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
046276 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
046279 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
04627C 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
04627F 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
046282 A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
046285 A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
046288 AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
04628B B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
04628E B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
046291 B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
046294 BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
046297 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
04629A C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
04629D C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
0462A0 CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
0462A3 D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
0462A6 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
0462A9 D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
0462AC DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
0462AF DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
0462B2 E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
0462B5 E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
0462B8 E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
0462BB EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
0462BE EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
0462C1 EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
0462C4 F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
0462C7 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
0462CA F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
0462CD F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
0462D0 F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
0462D3 F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
0462D6 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
0462D9 FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
0462DC FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
0462DF FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
0462E2 FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
0462E5 FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
0462E8 FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
0462EB FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
0462EE 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
0462F1 FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
0462F4 FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
0462F7 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
0462FA FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
0462FD FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
046300 FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
046303 FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
046306 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
046309 F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
04630C F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
04630F F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
046312 F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
046315 F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
046318 F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
04631B EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
04631E EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
046321 EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
046324 E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
046327 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
04632A E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
04632D DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
046330 DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
046333 D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
046336 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
046339 D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
04633C CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
04633F C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
046342 C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
046345 C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
046348 BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
04634B B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
04634E B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
046351 B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
046354 AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
046357 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
04635A A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
04635D 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
046360 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
046363 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
046366 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
046369 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
04636C 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
04636F 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
046372 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
046375 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
046378 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
04637B 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
04637E 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
046381 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
046384 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
046387 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
04638A 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
04638D 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
046390 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
046393 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
046396 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
046399 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
04639C 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
04639F 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
0463A2 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
0463A5 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
0463A8 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
0463AB 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
0463AE 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
0463B1 FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
0463B4 F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0463B7 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
0463BA E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0463BD E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0463C0 DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
0463C3 D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0463C6 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
0463C9 C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0463CC C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0463CF BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0463D2 B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0463D5 B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0463D8 AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0463DB A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0463DE 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
0463E1 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
0463E4 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
0463E7 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
0463EA 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
0463ED 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
0463F0 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
0463F3 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
0463F6 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
0463F9 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
0463FC 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0463FF 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
046402 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
046405 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
046408 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04640B 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
04640E 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
046411 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
046414 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
046417 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04641A 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
04641D 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
046420 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
046423 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
046426 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
046429 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
04642C 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
04642F 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
046432 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
046435 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
046438 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04643B 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
04643E 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
046441 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
046444 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
046447 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04644A 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
04644D 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
046450 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
046453 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
046456 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
046459 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
04645C 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
04645F 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
046462 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
046465 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
046468 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04646B 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
04646E 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
046471 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
046474 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
046477 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04647A 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04647D 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
046480 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
046483 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
046486 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
046489 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04648C 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
04648F 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
046492 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
046495 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
046498 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04649B 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
04649E 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0464A1 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0464A4 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0464A7 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0464AA 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0464AD 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0464B0 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0464B3 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0464B6 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0464B9 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0464BC 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0464BF 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0464C2 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0464C5 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0464C8 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0464CB 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0464CE 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0464D1 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0464D4 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0464D7 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0464DA 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0464DD 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0464E0 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0464E3 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0464E6 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0464E9 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0464EC 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0464EF 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0464F2 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0464F5 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0464F8 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0464FB 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0464FE 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
046501 A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
046504 AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
046507 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04650A B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
04650D BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
046510 C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
046513 C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
046516 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
046519 D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04651C DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
04651F E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
046522 E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
046525 EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
046528 F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
04652B FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
04652E             0857*  
04652E             0858*  atan_lut_168:
04652E 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
046531 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
046534 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
046537 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
04653A A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
04653D CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
046540 F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
046543 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
046546 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
046549 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
04654C 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
04654F BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
046552 E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
046555 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
046558 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
04655B 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
04655E 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
046561 B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
046564 DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
046567 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
04656A 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
04656D 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
046570 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
046573 A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
046576 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
046579 F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
04657C 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
04657F 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
046582 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
046585 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
046588 C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
04658B E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
04658E 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
046591 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
046594 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
046597 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
04659A B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
04659D D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
0465A0 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
0465A3 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
0465A6 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
0465A9 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
0465AC A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
0465AF C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
0465B2 EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
0465B5 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
0465B8 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
0465BB 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
0465BE 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
0465C1 B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
0465C4 DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
0465C7 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
0465CA 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
0465CD 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
0465D0 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
0465D3 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
0465D6 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
0465D9 ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
0465DC 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
0465DF 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
0465E2 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
0465E5 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
0465E8 AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
0465EB D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
0465EE FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
0465F1 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
0465F4 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
0465F7 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
0465FA 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
0465FD BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
046600 E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
046603 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
046606 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
046609 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
04660C 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
04660F 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
046612 C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
046615 E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
046618 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
04661B 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
04661E 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
046621 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
046624 A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
046627 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
04662A EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
04662D 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
046630 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
046633 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
046636 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
046639 A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
04663C C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
04663F EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
046642 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
046645 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
046648 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
04664B 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
04664E 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
046651 C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
046654 E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
046657 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
04665A 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
04665D 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
046660 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
046663 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
046666 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
046669 DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
04666C FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
04666F 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
046672 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
046675 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
046678 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
04667B AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
04667E CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
046681 EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
046684 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
046687 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
04668A 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
04668D 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
046690 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
046693 BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
046696 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
046699 FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
04669C 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
04669F 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
0466A2 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
0466A5 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
0466A8 A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
0466AB C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
0466AE E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
0466B1 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
0466B4 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
0466B7 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
0466BA 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
0466BD 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
0466C0 A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
0466C3 C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
0466C6 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
0466C9 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
0466CC 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
0466CF 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
0466D2 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
0466D5 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
0466D8 A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
0466DB C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
0466DE E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
0466E1 FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
0466E4 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
0466E7 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
0466EA 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
0466ED 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
0466F0 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
0466F3 B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
0466F6 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
0466F9 F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
0466FC 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
0466FF 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
046702 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
046705 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
046708 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
04670B A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
04670E C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
046711 DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
046714 FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
046717 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
04671A 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
04671D 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
046720 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
046723 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
046726 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
046729 C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
04672C E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
04672F FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
046732 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
046735 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
046738 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
04673B 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
04673E 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
046741 A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
046744 C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
046747 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
04674A F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
04674D 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
046750 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
046753 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
046756 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
046759 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
04675C 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
04675F B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
046762 CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
046765 E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
046768 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
04676B 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
04676E 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
046771 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
046774 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
046777 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
04677A 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
04677D B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
046780 D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
046783 EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
046786 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
046789 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
04678C 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
04678F 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
046792 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
046795 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
046798 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
04679B B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
04679E CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
0467A1 E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
0467A4 FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
0467A7 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
0467AA 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
0467AD 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
0467B0 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
0467B3 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
0467B6 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
0467B9 A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
0467BC BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
0467BF D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
0467C2 EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
0467C5 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
0467C8 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
0467CB 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
0467CE 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
0467D1 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
0467D4 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
0467D7 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
0467DA A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
0467DD BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
0467E0 D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
0467E3 E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
0467E6 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
0467E9 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
0467EC 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
0467EF 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
0467F2 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
0467F5 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
0467F8 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
0467FB 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
0467FE AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
046801 C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
046804 DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
046807 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
04680A 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
04680D 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
046810 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
046813 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
046816 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
046819 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
04681C 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
04681F 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
046822 AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
046825 C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
046828 D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
04682B EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
04682E 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
046831             0060   ; App-specific includes
046831             0061   	include "src/asm/player.inc"
046831             0001*  ; ######## GAME STATE VARIABLES #######
046831             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
046831 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
046834             0004*  ; player current shields,binary
046834             0005*  ; when < 0 player splodes
046834             0006*  ; restores to player_max_shields when new ship spawns
046834 10          0007*  player_shields: db 16 ; binary
046835             0008*  ; max player shields,binary
046835             0009*  ; can increase with power-ups (todo)
046835 10          0010*  player_max_shields: db 16 ; binary
046836             0011*  ; when reaches zero,game ends
046836             0012*  ; can increase based on TODO
046836 03          0013*  player_ships: db 0x03 ; binary
046837             0014*  
046837             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
046837             0016*  ; uses the same offsets from its table base as the main sprite table:
046837             0017*  player_start_variables: ; label marking beginning of table
046837 04          0018*  player_id:               db table_max_records
046838 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
046839 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
04683C 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
04683F 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046840 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046841 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046842 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046845 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046848 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04684B 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04684E 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
046851 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046854 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
046857 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
046858 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
046859 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
04685A 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
04685B 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
04685C 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
04685D             0038*  player_end_variables: ; for when we want to traverse this table in reverse
04685D             0039*  
04685D             0040*  ; set initial player position
04685D             0041*  ; inputs: none,everything is hardcoded
04685D             0042*  ; outputs: player_x/y set to bottom-left corner of screen
04685D             0043*  ; destroys: a
04685D             0044*  player_init:
04685D 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
04685F CD 09 5C 04 0046*  	call vdu_sprite_select
046863 CD 1C 5C 04 0047*      call vdu_sprite_clear_frames
046867 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
04686B CD 56 5D 04 0049*      call vdu_sprite_add_buff
04686F 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
046873 CD 56 5D 04 0051*      call vdu_sprite_add_buff
046877 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
04687B CD 56 5D 04 0053*      call vdu_sprite_add_buff
04687F 01 00 00 00 0054*      ld bc,0
046883 ED 43 42 68 0055*      ld (player_x),bc
       04          
046888 11 00 DF 00 0056*      ld de,0x00DF00
04688C ED 53 45 68 0057*      ld (player_y),de
       04          
046891 CD D5 5C 04 0058*      call vdu_sprite_move_abs168
046895 CD 7F 5C 04 0059*      call vdu_sprite_show
046899 C9          0060*      ret
04689A             0061*  
04689A             0062*  ; process player keyboard input, set player bitmap
04689A             0063*  ; velocities and draw player bitmap at updated coordinates
04689A             0064*  ; Inputs: player_x/y set at desired position
04689A             0065*  ; Returns: player bitmap drawn at updated position
04689A             0066*  ; Destroys: probably everything except maybe iy
04689A             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04689A             0068*  ; TODO: requires sprite implementation
04689A             0069*  player_input:
04689A             0070*  ; reset player component velocities to zero as the default
04689A 21 00 00 00 0071*  	ld hl,0
04689E 22 48 68 04 0072*  	ld (player_xvel),hl
0468A2 22 4B 68 04 0073*  	ld (player_yvel),hl
0468A6             0074*  ; make ship the active sprite
0468A6 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
0468A8 CD 09 5C 04 0076*      call vdu_sprite_select
0468AC             0077*  ; check for keypresses and branch accordingly
0468AC             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0468AC             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0468AC 3E 1E       0001*M 			LD	A, function
0468AE 5B CF       0002*M 			RST.LIL	08h
0468B0             0080*  ; we test all four arrow keys and add/subract velocities accordingly
0468B0             0081*  ; this handles the case where two opposing movement keys
0468B0             0082*  ; are down simultaneously (velocities will net to zero)
0468B0             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
0468B0             0084*  ; it also allows movement and action keys to be detected simultaneously
0468B0             0085*  ; so we can walk and chew gum at the same time
0468B0 3E 01       0086*      ld a,1 ; set ship's default animation to center
0468B2             0087*          ; if left and right are both down a will net to
0468B2             0088*  
0468B2             0089*  @left:
0468B2 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
0468B6 28 0E       0091*      jr z,@right
0468B8 2A 48 68 04 0092*      ld hl,(player_xvel)
0468BC 01 00 FD FF 0093*      ld bc,-speed_player
0468C0 09          0094*      add hl,bc
0468C1 22 48 68 04 0095*      ld (player_xvel),hl
0468C5 3D          0096*      dec a ; set ship's animation to left
0468C6             0097*  @right:
0468C6 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
0468CA 28 0E       0099*  	jr z,@up
0468CC 2A 48 68 04 0100*      ld hl,(player_xvel)
0468D0 01 00 03 00 0101*      ld bc,speed_player
0468D4 09          0102*      add hl,bc
0468D5 22 48 68 04 0103*      ld (player_xvel),hl
0468D9 3C          0104*      inc a ; set ship's animation to right
0468DA             0105*  @up:
0468DA DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
0468DE 28 0D       0107*  	jr z,@down
0468E0 2A 4B 68 04 0108*      ld hl,(player_yvel)
0468E4 01 00 FD FF 0109*      ld bc,-speed_player
0468E8 09          0110*      add hl,bc
0468E9 22 4B 68 04 0111*      ld (player_yvel),hl
0468ED             0112*  @down:
0468ED DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
0468F1 28 0D       0114*  	jr z,@done_keyboard
0468F3 2A 4B 68 04 0115*      ld hl,(player_yvel)
0468F7 01 00 03 00 0116*      ld bc,speed_player
0468FB 09          0117*      add hl,bc
0468FC 22 4B 68 04 0118*      ld (player_yvel),hl
046900             0119*  @done_keyboard:
046900             0120*  ; move player sprite according to velocities set by keypresses
046900 2A 48 68 04 0121*      ld hl,(player_xvel)
046904             0122*  ; compute new x position
046904 ED 5B 42 68 0123*      ld de,(player_x)
       04          
046909 19          0124*      add hl,de ; hl = player_x + player_xvel
04690A             0125*      ; check for horizontal screen edge collisions
04690A             0126*      ; and adjust coordinate as necessary
04690A             0127*  ; TODO: make this work using 24-bit registers
04690A             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
04690A             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
04690A             0130*      ; ld a,8 ; set x to leftmost allowable position
04690A             0131*  ; @check_right:
04690A             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
04690A             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
04690A             0134*  ;     ld a,248 ; set x to rightmost allowable position
04690A             0135*  @x_ok:
04690A             0136*  ; save the updated drawing coordinate
04690A 22 42 68 04 0137*      ld (player_x),hl
04690E             0138*  ;compute new y position
04690E 2A 45 68 04 0139*      ld hl,(player_y)
046912 ED 5B 4B 68 0140*      ld de,(player_yvel)
       04          
046917 19          0141*      add hl,de ; hl = player_y + player_yvel
046918             0142*  ; TODO: make this work using 24-bit registers
046918             0143*  ;     ; check for vertical screen edge collisions
046918             0144*  ;     ; and adjust coordinate as necessary
046918             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
046918             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
046918             0147*  ;     ld a,8 ; set y to topmost allowable position
046918             0148*  ; @check_top:
046918             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
046918             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
046918             0151*  ;     ld a,232 ; set y to bottommost allowable position
046918             0152*  @y_ok:
046918 22 45 68 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
04691C             0154*  ; a should land here loaded with the correct frame
04691C CD 6C 5C 04 0155*      call vdu_sprite_select_frame
046920             0156*  ; draw player at updated position
046920 ED 4B 42 68 0157*      ld bc,(player_x)
       04          
046925 ED 5B 45 68 0158*  	ld de,(player_y)
       04          
04692A             0159*  
04692A             0160*      ; call dumpRegistersHex
04692A             0161*  
04692A CD D5 5C 04 0162*  	call vdu_sprite_move_abs168
04692E             0163*  
04692E             0164*  ; end player_input
04692E C9          0165*  	ret
04692F             0166*  
04692F             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
04692F             0168*  ; ; INSTEAD OF FRACTIONAL
04692F             0169*  ; ; ----------------------------------------------------------------
04692F             0170*  ; ; process player keyboard input, set player bitmap
04692F             0171*  ; ; velocities and draw player bitmap at updated coordinates
04692F             0172*  ; ; Inputs: player_x/y set at desired position
04692F             0173*  ; ; Returns: player bitmap drawn at updated position
04692F             0174*  ; ; Destroys: probably everything except maybe iy
04692F             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04692F             0176*  ; ; TODO: requires sprite implementation
04692F             0177*  ; player_input:
04692F             0178*  ; ; reset player component velocities to zero as the default
04692F             0179*  ; 	ld hl,0
04692F             0180*  ; 	ld (player_xvel),hl
04692F             0181*  ; 	ld (player_yvel),hl
04692F             0182*  ; ; check for keypresses and branch accordingly
04692F             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04692F             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04692F             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
04692F             0186*  ; ; this handles the case where two opposing movement keys
04692F             0187*  ; ; are down simultaneously (velocities will net to zero)
04692F             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
04692F             0189*  ; ; it also allows movement and action keys to be detected simultaneously
04692F             0190*  ; ; so we can walk and chew gum at the same time
04692F             0191*  ; @left:
04692F             0192*  ;     bit 1,(ix+3) ; keycode 26
04692F             0193*  ;     jr z,@right
04692F             0194*  ;     ld hl,(player_xvel)
04692F             0195*  ;     ld bc,-3
04692F             0196*  ;     add hl,bc
04692F             0197*  ;     ld (player_xvel),hl
04692F             0198*  ; @right:
04692F             0199*  ;     bit 1,(ix+15) ; keycode 122
04692F             0200*  ; 	jr z,@up
04692F             0201*  ;     ld hl,(player_xvel)
04692F             0202*  ;     ld bc,3
04692F             0203*  ;     add hl,bc
04692F             0204*  ;     ld (player_xvel),hl
04692F             0205*  ; @up:
04692F             0206*  ;     bit 1,(ix+7) ; keycode 58
04692F             0207*  ; 	jr z,@down
04692F             0208*  ;     ld hl,(player_yvel)
04692F             0209*  ;     ld bc,-3
04692F             0210*  ;     add hl,bc
04692F             0211*  ;     ld (player_yvel),hl
04692F             0212*  ; @down:
04692F             0213*  ;     bit 1,(ix+5) ; keycode 42
04692F             0214*  ; 	jr z,@done_keyboard
04692F             0215*  ;     ld hl,(player_yvel)
04692F             0216*  ;     ld bc,3
04692F             0217*  ;     add hl,bc
04692F             0218*  ;     ld (player_yvel),hl
04692F             0219*  ; @done_keyboard:
04692F             0220*  ; ; move player sprite according to velocities set by keypresses
04692F             0221*  ;     ld hl,(player_xvel)
04692F             0222*  ; ; compute new x position
04692F             0223*  ;     ld de,(player_x)
04692F             0224*  ;     add hl,de ; hl = player_x + player_xvel
04692F             0225*  ;     ; check for horizontal screen edge collisions
04692F             0226*  ;     ; and adjust coordinate as necessary
04692F             0227*  ; ; TODO: make this work using 24-bit registers
04692F             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
04692F             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
04692F             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
04692F             0231*  ; ; @check_right:
04692F             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
04692F             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
04692F             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
04692F             0235*  ; @x_ok:
04692F             0236*  ;     ; save the updated drawing coordinate
04692F             0237*  ;     ld (player_x),hl
04692F             0238*  ; ;compute new y position
04692F             0239*  ;     ld hl,(player_y)
04692F             0240*  ;     ld de,(player_yvel)
04692F             0241*  ;     add hl,de ; hl = player_y + player_yvel
04692F             0242*  ; ; TODO: make this work using 24-bit registers
04692F             0243*  ; ;     ; check for vertical screen edge collisions
04692F             0244*  ; ;     ; and adjust coordinate as necessary
04692F             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
04692F             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
04692F             0247*  ; ;     ld a,8 ; set y to topmost allowable position
04692F             0248*  ; ; @check_top:
04692F             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
04692F             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
04692F             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
04692F             0252*  ; @y_ok:
04692F             0253*  ;     ld (player_y),hl
04692F             0254*  ; ; draw player at updated position
04692F             0255*  ;     ld a,table_max_records ; this is always player spriteId
04692F             0256*  ;     call vdu_sprite_select
04692F             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
04692F             0258*  ;     call get_sign_hlu ; to set the proper animation
04692F             0259*  ;     add a,1 ; ...
04692F             0260*  ;     call vdu_sprite_select_frame
04692F             0261*  ;     ld bc,(player_x)
04692F             0262*  ; 	ld de,(player_y)
04692F             0263*  ; 	call vdu_sprite_move_abs
04692F             0264*  ; ; end player_input
04692F             0265*  ; 	ret
04692F             0266*  
04692F             0267*  
04692F             0268*  ; ###################################################################
04692F             0269*  ; TODO: the below is all stuff from the original code we need to port
04692F             0270*  ; ###################################################################
04692F             0271*  
04692F             0272*  ; kill_player:
04692F             0273*  ; ; set player status to dead
04692F             0274*  ;     xor a; sets all player flags to zero
04692F             0275*  ;     ld (player_collisions),a
04692F             0276*  ; ; deduct a ship from the inventory
04692F             0277*  ;     ld a,(player_ships)
04692F             0278*  ;     dec a
04692F             0279*  ;     ld (player_ships),a
04692F             0280*  ; ; are we out of ships?
04692F             0281*  ;     jp z,game_over
04692F             0282*  ; ; wait a few ticks
04692F             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
04692F             0284*  ;     ld (player_move_timer),a
04692F             0285*  ; kill_player_loop:
04692F             0286*  ;     call vdu_vblank
04692F             0287*  ;     ld a,(player_move_timer)
04692F             0288*  ;     dec a
04692F             0289*  ;     ld (player_move_timer),a
04692F             0290*  ;     jr nz,kill_player_loop
04692F             0291*  ;     call player_init ; player respawn if timer zero
04692F             0292*  ;     ret ; and out
04692F             0293*  
04692F             0294*  
04692F             0295*  ; player_move:
04692F             0296*  ; ; begin setting player to active sprite
04692F             0297*  ;     ld hl,player
04692F             0298*  ;     ld (sprite_base_bufferId),hl
04692F             0299*  ;     ld hl,0 ; north
04692F             0300*  ;     ld (sprite_heading),hl
04692F             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
04692F             0302*  ;     ld (sprite_animation),a
04692F             0303*  ;     ; we set position here for the time being as a default
04692F             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
04692F             0305*  ;     ld hl,(player_x)
04692F             0306*  ;     ld (sprite_x),hl
04692F             0307*  ;     ld hl,(player_y)
04692F             0308*  ;     ld (sprite_y),hl
04692F             0309*  ; ; did we just die?
04692F             0310*  ;     ld a,(player_collisions)
04692F             0311*  ;     and %00000010 ; zero flag will be set if not dead
04692F             0312*  ;     jr z,player_not_dead
04692F             0313*  ; ; yes we died
04692F             0314*  ;     call kill_player
04692F             0315*  ;     ret ; done
04692F             0316*  ; ; yay we didn't die
04692F             0317*  ; player_not_dead:
04692F             0318*  ; ; set player movements to zero by default
04692F             0319*  ;     ld hl,0
04692F             0320*  ;     ld (player_xvel),hl
04692F             0321*  ;     ld (player_yvel),hl
04692F             0322*  ; ; do we move it?
04692F             0323*  ;     in a,(#82) ; keyboard
04692F             0324*  ;     or a ; if zero,don't move
04692F             0325*  ;     jr z,player_draw
04692F             0326*  ; ; move it
04692F             0327*  ;     call player_move_calc
04692F             0328*  ; player_draw:
04692F             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04692F             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04692F             0331*  ; player_move_done:
04692F             0332*  ;     ; write updated x,y coordinates back to player table
04692F             0333*  ;     ld hl,(sprite_x)
04692F             0334*  ;     ld (player_x),hl
04692F             0335*  ;     ld hl,(sprite_y)
04692F             0336*  ;     ld (player_y),hl
04692F             0337*  ;     ret
04692F             0062   	include "src/asm/tiles.inc"
04692F             0001*  ; ######### TILES #########
04692F             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
04692F             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
04692F 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
046932 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
046933             0006*                          ; initialize to zero for a maximum of 256 rows in a level
046933 00          0007*  cur_level: db 0
046934             0008*  num_levels: equ 2 ; number of levels,duh
046934             0009*  
046934             0010*  ; lookup table for level definitions
046934 61 41 04 62 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       51 04       
04693A             0012*  
04693A             0013*  ; tiles_bufferId: dl 0
04693A 00 00 00    0014*  tiles_x_plot: dl 0
04693D F1 FF FF    0015*  tiles_y_plot: dl -15
046940             0016*  
046940             0017*  
046940             0018*  tiles_plot:
046940             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
046940             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
046940             0021*  ; ;       but don't want
046940             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
046940             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
046940             0024*  ; 	ld bc,0 ; leftmost x-coord
046940             0025*  ; 	ld de,0 ; topmost y-coord
046940             0026*  ; 	ld ix,255 ; rightmost x-coord
046940             0027*  ; 	ld iy,1 ; bottommost y-coord
046940             0028*  ; 	call vdu_set_gfx_viewport
046940             0029*  
046940 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
046944 22 3A 69 04 0031*      ld (tiles_x_plot),hl
046948 2A 2F 69 04 0032*      ld hl,(tiles_row_defs)
04694C 06 10       0033*  	ld b,16 ; loop counter
04694E             0034*  @loop:
04694E C5          0035*  	push bc ; save the loop counter
04694F             0036*  ; read the tile defintion for the current column
04694F 7E          0037*      ld a,(hl) ; a has tile definition
046950 E5          0038*      push hl  ; save pointer to tile definition
046951 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
046955 6F          0040*      ld l,a ; l is tile defintion
046956 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
046958 CD 9F 58 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
04695C             0043*  
04695C             0044*  ; plot the active bitmap
04695C ED 4B 3A 69 0045*      ld bc,(tiles_x_plot)
       04          
046961 ED 5B 3D 69 0046*      ld de,(tiles_y_plot)
       04          
046966 CD 68 5B 04 0047*      call vdu_plot_bmp
04696A             0048*  
04696A             0049*  ; bump x-coords the width of one tile and save it
04696A 2A 3A 69 04 0050*      ld hl,(tiles_x_plot)
04696E 01 10 00 00 0051*      ld bc,16
046972 09          0052*      add hl,bc
046973 22 3A 69 04 0053*      ld (tiles_x_plot),hl
046977             0054*  
046977             0055*  ; prepare to loop to next column
046977 E1          0056*      pop hl ; get back pointer to tile def
046978 23          0057*      inc hl ; bump it to the next column
046979 C1          0058*  	pop bc ; snag our loop counter
04697A 10 D2       0059*      djnz @loop
04697C             0060*  
04697C             0061*  ; increment tiles plotting y-coordinate
04697C             0062*  ; when it hits zero, we go to next row of tiles in the map
04697C             0063*  ; (we use ix b/c we want to preserve hl for the next step)
04697C DD 21 3D 69 0064*  	ld ix,tiles_y_plot
       04          
046981 DD 34 00    0065*  	inc (ix)
046984 C0          0066*  	ret nz
046985             0067*  
046985             0068*  ; time to bump tiles_row_defs to next row
046985             0069*  ; (hl was already there at the end of the loop)
046985 22 2F 69 04 0070*      ld (tiles_row_defs),hl
046989             0071*  
046989             0072*  ; reset coords to plot next row of tiles
046989 21 00 00 00 0073*      ld hl,0
04698D 22 3A 69 04 0074*      ld (tiles_x_plot),hl
046991 21 F1 FF FF 0075*      ld hl,-15
046995 22 3D 69 04 0076*      ld (tiles_y_plot),hl
046999             0077*  
046999             0078*  ; decrement tiles row counter
046999 21 32 69 04 0079*      ld hl,tiles_row
04699D 35          0080*      dec (hl)
04699E C0          0081*      ret nz
04699F             0082*  
04699F             0083*  ; queue up next level
04699F 3A 33 69 04 0084*      ld a,(cur_level)
0469A3 FE 01       0085*      cp num_levels-1
0469A5 20 02       0086*      jr nz,@inc_level
0469A7 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
0469A9             0088*  
0469A9             0089*  @inc_level:
0469A9 3C          0090*      inc a
0469AA 32 33 69 04 0091*      ld (cur_level),a
0469AE             0092*  
0469AE             0093*  ; increase the number of enemy sprites
0469AE 3A F5 69 04 0094*      ld a,(max_enemy_sprites)
0469B2 3C          0095*      inc a
0469B3 FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
0469B5 28 04       0097*      jr z,init_level
0469B7 32 F5 69 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
0469BB             0099*  ; fall through to init_level
0469BB             0100*  
0469BB             0101*  init_level:
0469BB             0102*  ; look up address of level's tile defintion
0469BB 21 34 69 04 0103*      ld hl,tiles_levels
0469BF 3A 33 69 04 0104*      ld a,(cur_level)
0469C3 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
0469C7 57          0106*      ld d,a
0469C8 1E 03       0107*      ld e,3
0469CA ED 5C       0108*      mlt de
0469CC 19          0109*      add hl,de
0469CD ED 37       0110*      ld ix,(hl)
0469CF DD 22 2F 69 0111*      ld (tiles_row_defs),ix
       04          
0469D4             0112*  
0469D4             0113*  ; set tiles_row counter
0469D4 DD 7E 00    0114*      ld a,(ix)
0469D7 32 32 69 04 0115*      ld (tiles_row),a
0469DB DD 23       0116*      inc ix ; now ix points first element of first row tile def
0469DD DD 22 2F 69 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
0469E2 C9          0118*      ret
0469E3             0119*  
0469E3             0120*  
0469E3             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
0469E3             0122*  ; dt_is_active:
0469E3             0123*  ; ; a lands here containing a tile index in the low nibble
0469E3             0124*  ; ; we test the values for the tiles which are active
0469E3             0125*  ;     cp #07
0469E3             0126*  ;     call z,ld_act_landing_pad
0469E3             0127*  ;     cp #08
0469E3             0128*  ;     call z,ld_act_laser_turret
0469E3             0129*  ;     ; fall through
0469E3             0130*  ;     ret
0469E3             0131*  
0469E3             0132*  ; ; some tiles become active sprites,so we load those here
0469E3             0133*  ; ; sprite_x/y have already been loaded
0469E3             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
0469E3             0135*  ; ; we don't want sprite drawn to background like other tiles
0469E3             0136*  ; ; so this routine only adds them to the sprite table
0469E3             0137*  ; dt_ld_act:
0469E3             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
0469E3             0139*  ;     ld (sprite_y+1),a ; just the integer part
0469E3             0140*  ;     ld (sprite_base_bufferId),hl
0469E3             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0469E3             0142*  ;     call table_add_record
0469E3             0143*  ;     call sprite_variables_from_stack
0469E3             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
0469E3             0145*  ;     ret ; and back
0469E3             0146*  
0469E3             0147*  ; ld_act_landing_pad:
0469E3             0148*  ;     call sprite_variables_to_stack
0469E3             0149*  
0469E3             0150*  ;     ld hl,move_landing_pad
0469E3             0151*  ;     ld (sprite_move_program),hl
0469E3             0152*  
0469E3             0153*  ;     xor a
0469E3             0154*  ;     ld (sprite_animation),a ; animation 0
0469E3             0155*  
0469E3             0156*  ;     call rand_8     ; snag a random number
0469E3             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0469E3             0158*  ;     add a,64 ; range is now 64-127
0469E3             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0469E3             0160*  
0469E3             0161*  ;     ld a,%10 ; collides with laser but not player
0469E3             0162*  ;     ld (iy+sprite_collisions),a
0469E3             0163*  
0469E3             0164*  ;     ld a,#05 ; BCD
0469E3             0165*  ;     ld (sprite_points),a
0469E3             0166*  ;     ld a,0 ; binary
0469E3             0167*  ;     ld (sprite_shield_damage),a
0469E3             0168*  
0469E3             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
0469E3             0170*  ;     jr dt_ld_act
0469E3             0171*  
0469E3             0172*  ; ld_act_laser_turret:
0469E3             0173*  ;     call sprite_variables_to_stack
0469E3             0174*  
0469E3             0175*  ;     ld hl,move_laser_turret
0469E3             0176*  ;     ld (sprite_move_program),hl
0469E3             0177*  
0469E3             0178*  ;     xor a
0469E3             0179*  ;     ld (sprite_animation),a
0469E3             0180*  ;     ld (sprite_move_step),a
0469E3             0181*  
0469E3             0182*  ;     call rand_8     ; snag a random number
0469E3             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0469E3             0184*  ;     add a,64 ; range is now 64-127
0469E3             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0469E3             0186*  
0469E3             0187*  ;     ld a,%10 ; collides with laser but not player
0469E3             0188*  ;     ld (iy+sprite_collisions),a
0469E3             0189*  
0469E3             0190*  ;     ld a,#10 ; BCD
0469E3             0191*  ;     ld (sprite_points),a
0469E3             0192*  ;     ld a,0 ; binary
0469E3             0193*  ;     ld (sprite_shield_damage),a
0469E3             0194*  
0469E3             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
0469E3             0196*  ;     jp dt_ld_act
0469E3             0197*  
0469E3             0198*  
0469E3             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
0469E3             0200*  ; deletes sprites from table when they wrap around to top of screen
0469E3             0201*  move_active_tiles:
0469E3             0202*  ; get current position
0469E3 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
0469E7 3C          0204*      inc a
0469E8             0205*  ; are we at the bottom of the screen?
0469E8 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
0469EA             0207*  ; otherwise kill sprite
0469EA 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
0469EC FD 77 08    0209*      ld (iy+sprite_collisions),a
0469EF C9          0210*      ret ; debug
0469F0             0211*  move_active_tiles_draw_sprite:
0469F0 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
0469F4             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0469F4             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
0469F4 C9          0215*      ret ; and done
0469F5             0063   	include "src/asm/enemies.inc"
0469F5 10          0001*  max_enemy_sprites: db 16
0469F6             0002*  
0469F6             0003*  ; sprite_type
0469F6             0004*  enemy_dead: equ 0
0469F6             0005*  enemy_small: equ 1
0469F6             0006*  enemy_medium: equ 2
0469F6             0007*  enemy_large: equ 3
0469F6             0008*  landing_pad: equ 4
0469F6             0009*  laser_turret: equ 5
0469F6             0010*  fireballs: equ 6
0469F6             0011*  explosion: equ 7
0469F6             0012*  
0469F6             0013*  
0469F6             0014*  respawn_countdown:
0469F6 2A 17 6A 04 0015*      ld hl,(respawn_timer)
0469FA 2B          0016*      dec hl
0469FB 22 17 6A 04 0017*      ld (respawn_timer),hl
0469FF             0018*  ; check hl for zero
0469FF 19          0019*      add hl,de
046A00 B7          0020*      or a
046A01 ED 52       0021*      sbc hl,de
046A03 C0          0022*      ret nz
046A04 06 04       0023*      ld b,table_max_records
046A06             0024*  @respawn_loop:
046A06 C5          0025*      push bc
046A07 CD 08 6B 04 0026*      call enemy_init_from_landing_pad
046A0B C1          0027*      pop bc
046A0C 10 F8       0028*      djnz @respawn_loop
046A0E 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
046A12 22 17 6A 04 0030*      ld (respawn_timer),hl
046A16 C9          0031*      ret
046A17 3C 00 00    0032*  respawn_timer: dl 1*60
046A1A             0033*  
046A1A             0034*  move_enemies:
046A1A             0035*  ; are there any active enemies or explosions?
046A1A 21 00 00 00 0036*      ld hl,0
046A1E 3A FE 52 04 0037*      ld a,(table_active_sprites)
046A22 6F          0038*      ld l,a
046A23             0039*      ; call dumpRegistersHex
046A23 A7          0040*      and a ; will be zero if no alive enemies or explosions
046A24             0041*      ; ret z ; so nothing to do but go back
046A24             0042*      ; ld hl,(respawn_timer)
046A24             0043*      ; call dumpRegistersHex
046A24 20 05       0044*      jr nz,move_enemies_do
046A26 CD F6 69 04 0045*      call respawn_countdown
046A2A C9          0046*      ret
046A2B             0047*  move_enemies_do:
046A2B             0048*  ; initialize pointers and loop counter
046A2B FD 21 63 52 0049*      ld iy,table_base ; set iy to first record in table
       04          
046A30 06 04       0050*      ld b,table_max_records ; loop counter
046A32             0051*  move_enemies_loop:
046A32 FD 22 FB 52 0052*      ld (table_pointer),iy ; update table pointer
       04          
046A37 C5          0053*      push bc ; backup loop counter
046A38             0054*  ; check sprite_type to see if sprite is active
046A38 FD 7E 01    0055*      ld a,(iy+sprite_type)
046A3B A7          0056*      and a ; if zero, sprite is dead
046A3C 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
046A3E             0058*  ; otherwise we prepare to move the sprite
046A3E FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
046A41 CD 09 5C 04 0060*      call vdu_sprite_select ; select sprite
046A45 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
046A48 E9          0062*      jp (hl)  ; ... and jump to it
046A49             0063*  ; we always jp back here from behavior subroutines
046A49             0064*  move_enemies_loop_return:
046A49 FD 2A FB 52 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
046A4E             0066*  ; now we check results of all the moves
046A4E FD 7E 08    0067*      ld a,(iy+sprite_collisions)
046A51 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
046A53 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
046A56 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
046A58 CD 47 53 04 0071*      call table_deactivate_sprite ; otherwise we ded
046A5C AF          0072*      xor a ; zero a so that we can ...
046A5D FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
046A60 18 0A       0074*      jr move_enemies_next_record ; and to the next record
046A62             0075*  move_enemies_draw_sprite:
046A62             0076*  ; if we got here sprite will have already been activated
046A62             0077*  ; so all we need to do is set its coordinates and draw it
046A62 FD 07 0B    0078*      ld bc,(iy+sprite_x)
046A65 FD 17 0E    0079*      ld de,(iy+sprite_y)
046A68 CD D5 5C 04 0080*      call vdu_sprite_move_abs168
046A6C             0081*  ; fall through to next record
046A6C             0082*  move_enemies_next_record:
046A6C 11 26 00 00 0083*      ld de,table_bytes_per_record
046A70 FD 19       0084*      add iy,de ; point to next record
046A72 AF          0085*      xor a ; clears carry flag
046A73 32 FF 52 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
046A77 C1          0087*      pop bc ; get back our loop counter
046A78 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
046A7A C9          0089*      ret ; and we're out
046A7B             0090*  
046A7B             0091*  en_nav_zigzag_start:
046A7B FD 2A FB 52 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046A80 CD B9 5F 04 0093*      call rand_8
046A84 E6 3F       0094*      and %00111111 ; limit it to 64
046A86 CB DF       0095*      set 3,a ; make sure it's at least 8
046A88 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
046A8B             0097*      ; fall through to en_nav_zigzag
046A8B             0098*  en_nav_zigzag:
046A8B FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
046A8E 3D          0100*      dec a
046A8F FD 77 22    0101*      ld (iy+sprite_move_timer),a
046A92 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
046A94             0103*      ; otherwise flip direction and restart timer
046A94 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
046A97 EE 01       0105*      xor %1 ; flips bit one
046A99 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
046A9C 20 09       0107*      jr nz,en_nav_zigzag_right
046A9E             0108*  ;otherwise zag left
046A9E 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
046AA2 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
046AA5 18 D4       0111*      jr en_nav_zigzag_start
046AA7             0112*  en_nav_zigzag_right:
046AA7 21 00 60 00 0113*      ld hl,0x006000; southeast heading
046AAB FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
046AAE 18 CB       0115*      jr en_nav_zigzag_start
046AB0             0116*  en_nav_zigzag_no_switch:
046AB0             0117*      ; ld a,(sprite_orientation)
046AB0 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
046AB3 18 13       0119*      jr en_nav_computevelocities
046AB5             0120*  
046AB5             0121*  ; contains the logic for how to move the enemy
046AB5             0122*  ; and then does the moving
046AB5             0123*  ; inputs: a fully-populated active sprite table
046AB5             0124*  ;         player position variables
046AB5             0125*  ; destroys: everything except index registers
046AB5             0126*  ; outputs: moving enemies
046AB5             0127*  en_nav:
046AB5             0128*  ; set velocity and orientation by player's relative location
046AB5             0129*  ; move enemies y-axis
046AB5             0130*  ; where is player relative to us?
046AB5 CD 8B 6B 04 0131*      call orientation_to_player
046AB9             0132*  ;    h.l 16.8 fixed angle256 to player
046AB9             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046AB9             0134*  ; is player above or below us?
046AB9 ED 53 7A 56 0135*      ld (ude),de ; dy
       04          
046ABE 3A 7C 56 04 0136*      ld a,(ude+2) ; deu
046AC2 17          0137*      rla ; shift sign bit into carry
046AC3 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
046AC5             0139*  ; player is even or above,so home in on current heading
046AC5 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
046AC8             0141*  
046AC8             0142*  ; we land here from zig-zag program so as not to
046AC8             0143*  ; redundantly save orientation and heading
046AC8             0144*  en_nav_computevelocities:
046AC8             0145*  ; set x/y component velocities based on bearing to player
046AC8 FD 2A FB 52 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046ACD E5          0147*      push hl ; we need it back to set rotation frame
046ACE FD 17 17    0148*      ld de,(iy+sprite_vel)
046AD1 CD E5 5F 04 0149*      call polar_to_cartesian
046AD5 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
046AD8 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
046ADB             0152*  ; change the animation frame to match heading
046ADB             0153*  ; by dividng the heading by 8
046ADB E1          0154*      pop hl ; get back Heading
046ADC 7C          0155*      ld a,h
046ADD CB 3F       0156*      srl a
046ADF CB 3F       0157*      srl a
046AE1 CB 3F       0158*      srl a
046AE3 CD 6C 5C 04 0159*      call vdu_sprite_select_frame
046AE7             0160*  ; update sprite position
046AE7             0161*  move_enemy_sprite:
046AE7 FD 27 0B    0162*      ld hl,(iy+sprite_x)
046AEA FD 17 11    0163*      ld de,(iy+sprite_xvel)
046AED 19          0164*      add hl,de
046AEE FD 2F 0B    0165*      ld (iy+sprite_x),hl
046AF1             0166*  
046AF1 FD 27 0E    0167*      ld hl,(iy+sprite_y)
046AF4 FD 17 14    0168*      ld de,(iy+sprite_yvel)
046AF7 19          0169*      add hl,de
046AF8 FD 2F 0E    0170*      ld (iy+sprite_y),hl
046AFB C9          0171*      ret
046AFC             0172*  
046AFC             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
046AFC             0174*  ; move_enemy_sprite:
046AFC             0175*  ; ; x-axis movement first
046AFC             0176*  ;     ld hl,(iy+sprite_x)
046AFC             0177*  ;     push hl ; save pre-move position
046AFC             0178*  ;     pop bc ; to detect screen edge collision
046AFC             0179*  ;     ld de,(iy+sprite_xvel)
046AFC             0180*  ;     add hl,de ;compute new x position
046AFC             0181*  ;     ld (iy+sprite_x),hl ; store it
046AFC             0182*  ;     and a ; clear the carry flag
046AFC             0183*  ;     sbc hl,bc ; test which direction was our movement
046AFC             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
046AFC             0185*  ;     jp p,@move_right ; sign positive means moved right
046AFC             0186*  ; @move_left: ; otherwise we moved left
046AFC             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
046AFC             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
046AFC             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
046AFC             0190*  ;     ld a,#20 ; west
046AFC             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AFC             0192*  ;     jr @move_y
046AFC             0193*  ; @move_right:
046AFC             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
046AFC             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046AFC             0196*  ;     ld l,0x00
046AFC             0197*  ;     ld a,(iy+sprite_dim_x)
046AFC             0198*  ;     ld h,a
046AFC             0199*  ;     ld a,0x00
046AFC             0200*  ;     sub h
046AFC             0201*  ;     ld h,a
046AFC             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
046AFC             0203*  ;     ld a,0x02 ; east
046AFC             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AFC             0205*  ; @move_y:
046AFC             0206*  ;     ld hl,(iy+sprite_y)
046AFC             0207*  ;     ld b,h ; save pre-move position
046AFC             0208*  ;     ld c,l ; to detect screen edge collision
046AFC             0209*  ;     ld de,(iy+sprite_yvel)
046AFC             0210*  ;     add hl,de ;compute new y position
046AFC             0211*  ;     ld (iy+sprite_y),hl ; store it
046AFC             0212*  ;     and a ; clear the carry flag
046AFC             0213*  ;     sbc hl,bc ; test which direction was our movement
046AFC             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
046AFC             0215*  ;     jp p,@move_dn ; sign positive means moved down
046AFC             0216*  ; @move_up:
046AFC             0217*  ;     add hl,bc ; get back new y position
046AFC             0218*  ;     ld de,0x5000 ; top edge of visible screen
046AFC             0219*  ;     and a ; clear the carry flag
046AFC             0220*  ;     sbc hl,de
046AFC             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
046AFC             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
046AFC             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
046AFC             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046AFC             0225*  ;     or 0x80 ; north
046AFC             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AFC             0227*  ;     jr @move_ret
046AFC             0228*  ; @move_dn:
046AFC             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
046AFC             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046AFC             0231*  ;     ld l,0x00
046AFC             0232*  ;     ld a,(iy+sprite_dim_y)
046AFC             0233*  ;     ld h,a
046AFC             0234*  ;     ld a,0x00
046AFC             0235*  ;     sub h
046AFC             0236*  ;     ld h,a
046AFC             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
046AFC             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046AFC             0239*  ;     or 0x08 ; south
046AFC             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046AFC             0241*  ; @move_ret:
046AFC             0242*  ;     ret
046AFC             0243*  
046AFC             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
046AFC             0245*  ; ; each sprite in the table must have one of these defined
046AFC             0246*  ; ; but they need not be unique to a particular sprite
046AFC             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
046AFC             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
046AFC             0249*  ; ; but they can call anything they want between those two endpoints
046AFC             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
046AFC             0251*  
046AFC             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
046AFC             0253*  ;     jp move_enemies_loop_return
046AFC             0254*  
046AFC             0255*  ; move_explosion:
046AFC             0256*  ;     call animate_explosion
046AFC             0257*  ;     jp move_enemies_loop_return
046AFC             0258*  
046AFC             0259*  move_enemy_small:
046AFC CD B5 6A 04 0260*      call en_nav
046B00 CD 27 6C 04 0261*      call check_collisions
046B04 C3 49 6A 04 0262*      jp move_enemies_loop_return
046B08             0263*  
046B08             0264*  ; move_enemy_medium:
046B08             0265*  ;     call en_nav
046B08             0266*  ;     call check_collisions
046B08             0267*  ;     jp move_enemies_loop_return
046B08             0268*  
046B08             0269*  ; move_enemy_large:
046B08             0270*  ;     call en_nav
046B08             0271*  ;     call check_collisions
046B08             0272*  ;     jp move_enemies_loop_return
046B08             0273*  
046B08             0274*  ; move_landing_pad:
046B08             0275*  ;     call move_active_tiles
046B08             0276*  ;     call check_collisions
046B08             0277*  ; ; is it time to launch an enemy?
046B08             0278*  ;     ld hl,sprite_move_timer
046B08             0279*  ;     dec (hl)
046B08             0280*  ;     jp nz,move_enemies_loop_return
046B08             0281*  ;     call enemy_init_from_landing_pad
046B08             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
046B08             0283*  ;     call rand_8     ; snag a random number
046B08             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046B08             0285*  ;     add a,64 ; range is now 64-127
046B08             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
046B08             0287*  ;     jp move_enemies_loop_return
046B08             0288*  
046B08             0289*  enemy_init_from_landing_pad:
046B08             0290*  ; get next available spriteId
046B08 CD 22 53 04 0291*      call table_get_next_id
046B0C D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
046B0D             0293*  ; ix comes back with the pointer to the new sprite variables
046B0D DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
046B0F             0295*  ; a comes back with the spriteId of the new sprite
046B0F 32 65 6B 04 0296*      ld (@id),a
046B13             0297*  ; initialize the new sprite
046B13 CD 09 5C 04 0298*      call vdu_sprite_select
046B17 CD 1C 5C 04 0299*      call vdu_sprite_clear_frames
046B1B 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
046B1F 06 20       0301*      ld b,32
046B21             0302*  @load_frames:
046B21 C5          0303*      push bc
046B22 E5          0304*      push hl
046B23 CD 56 5D 04 0305*      call vdu_sprite_add_buff
046B27 E1          0306*      pop hl
046B28 23          0307*      inc hl
046B29 C1          0308*      pop bc
046B2A 10 F5       0309*      djnz @load_frames
046B2C             0310*  ; copy coordinates of active sprite to new sprite
046B2C FD 2A FB 52 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046B31             0312*      ; ld hl,(iy+sprite_x)
046B31             0313*  	; ld hl,0x008000 ; debug
046B31             0314*  
046B31 CD B9 5F 04 0315*      call rand_8
046B35 21 00 00 00 0316*      ld hl,0
046B39 67          0317*      ld h,a
046B3A             0318*  
046B3A 22 70 6B 04 0319*      ld (@x),hl
046B3E             0320*      ; ld hl,(iy+sprite_y)
046B3E             0321*      ; ld hl,0x002000 ; debug
046B3E             0322*  
046B3E CD B9 5F 04 0323*      call rand_8
046B42 21 00 00 00 0324*      ld hl,0
046B46 67          0325*      ld h,a
046B47             0326*  
046B47 22 73 6B 04 0327*      ld (@y),hl
046B4B CD B9 5F 04 0328*      call rand_8
046B4F E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
046B51 32 88 6B 04 0330*      ld (@move_step),a
046B55             0331*  ; now copy to the table
046B55 21 65 6B 04 0332*      ld hl,@id ; address to copy from
046B59 D1          0333*      pop de ; address to copy to (was ix)
046B5A 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
046B5E ED B0       0335*      ldir ; copy the records from local scratch to sprite table
046B60             0336*  ; finally, make the new sprite visible
046B60 CD 7F 5C 04 0337*      call vdu_sprite_show
046B64 C9          0338*      ret
046B65 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
046B66 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
046B67 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
046B6A FC 6A 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
046B6D 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
046B6E 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
046B6F 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
046B70 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
046B73 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046B76 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046B79 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046B7C 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
046B7F 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046B82 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
046B85 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
046B86 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
046B87 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
046B88 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
046B89 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
046B8A 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
046B8B             0359*  
046B8B             0360*  ; move_laser_turret:
046B8B             0361*  ; ; compute orientation to player
046B8B             0362*  ;     call orientation_to_player
046B8B             0363*  ; ; h.l 8.8 fixed angle256 to player
046B8B             0364*  ; ; bc and de as signed 16-bit integers
046B8B             0365*  ; ; representing delta-x/y *to* target respectively
046B8B             0366*  ;     ld (Bearing_t),hl
046B8B             0367*  ;     ld hl,0x0400
046B8B             0368*  ;     ld (Vp),hl
046B8B             0369*  ;     call targeting_computer
046B8B             0370*  ;     ld (sprite_heading),hl ; store bearing to player
046B8B             0371*  ; ; is it time to launch a fireball?
046B8B             0372*  ;     ld hl,sprite_move_timer
046B8B             0373*  ;     dec (hl)
046B8B             0374*  ;     jp nz,move_laser_turret_boilerplate
046B8B             0375*  ;     call fireballs_init
046B8B             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
046B8B             0377*  ;     call rand_8     ; snag a random number
046B8B             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046B8B             0379*  ;     add a,64 ; range is now 64-127
046B8B             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
046B8B             0381*  ; move_laser_turret_boilerplate:
046B8B             0382*  ;     call move_active_tiles
046B8B             0383*  ;     call check_collisions
046B8B             0384*  ;     jp move_enemies_loop_return
046B8B             0385*  
046B8B             0386*  ; fireballs_init:
046B8B             0387*  ;     call sprite_variables_to_stack
046B8B             0388*  
046B8B             0389*  ;     ld hl,fireballs
046B8B             0390*  ;     ld (sprite_base_bufferId),hl
046B8B             0391*  
046B8B             0392*  ;     ld hl,move_fireballs
046B8B             0393*  ;     ld (sprite_move_program),hl
046B8B             0394*  
046B8B             0395*  ;     ld a,%11 ; collides with laser and player
046B8B             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
046B8B             0397*  ;     ld (iy+sprite_collisions),a
046B8B             0398*  
046B8B             0399*  ;     ld hl,(Vp)
046B8B             0400*  ;     ld (sprite_vel),hl
046B8B             0401*  ;     ld hl,(Vp_x)
046B8B             0402*  ;     ld (sprite_xvel),hl
046B8B             0403*  ;     ld hl,(Vp_y)
046B8B             0404*  ;     inc h ; account for ground movement
046B8B             0405*  ;     ld (sprite_yvel),hl
046B8B             0406*  
046B8B             0407*  ;     xor a ; zero a
046B8B             0408*  ;     ld (sprite_animation),a
046B8B             0409*  ;     ld (sprite_move_step),a
046B8B             0410*  ;     ld (sprite_move_timer),a
046B8B             0411*  
046B8B             0412*  ;     ld a,6 ; 1/10th of a second timer
046B8B             0413*  ;     ld (sprite_animation_timer),a
046B8B             0414*  
046B8B             0415*  ;     ld a,0x00 ; BCD
046B8B             0416*  ;     ld (sprite_points),a
046B8B             0417*  ;     ld a,1 ; binary
046B8B             0418*  ;     ld (sprite_shield_damage),a
046B8B             0419*  
046B8B             0420*  ;     call table_add_record ; plops that on the sprite stack for later
046B8B             0421*  ;     call sprite_variables_from_stack ; come back to where we started
046B8B             0422*  ;     ret
046B8B             0423*  
046B8B             0424*  ; move_fireballs:
046B8B             0425*  ;     call move_enemy_sprite ; move sprite
046B8B             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
046B8B             0427*  ;     and a ; if zero we're still within screen bounds
046B8B             0428*  ;     jr z,move_fireballs_alive
046B8B             0429*  ; ; otherwise kill sprite
046B8B             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
046B8B             0431*  ;     ld (iy+sprite_collisions),a
046B8B             0432*  ;     jp move_enemies_loop_return
046B8B             0433*  ; move_fireballs_alive:
046B8B             0434*  ;     ld a,(sprite_animation_timer)
046B8B             0435*  ;     dec a
046B8B             0436*  ;     ld (sprite_animation_timer),a
046B8B             0437*  ;     jr nz,move_fireballs_draw
046B8B             0438*  ;     ld a,(sprite_animation)
046B8B             0439*  ;     xor %1
046B8B             0440*  ;     ld (sprite_animation),a
046B8B             0441*  ;     ld a,6 ; 1/10th of a second timer
046B8B             0442*  ;     ld (sprite_animation_timer),a
046B8B             0443*  ;     ; fall through
046B8B             0444*  
046B8B             0445*  ; move_fireballs_draw:
046B8B             0446*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
046B8B             0447*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
046B8B             0448*  ;     call check_collisions
046B8B             0449*  ;     jp move_enemies_loop_return
046B8B             0450*  
046B8B             0451*  ; compute orientation to player
046B8B             0452*  ; based on relative positions
046B8B             0453*  ; returns: h.l 16.8 fixed angle256 to player
046B8B             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046B8B             0455*  ;    representing delta-x/y *to* target respectively
046B8B             0456*  orientation_to_player:
046B8B FD 2A FB 52 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046B90 FD E5       0458*      push iy ; so we can send it back intact
046B92 FD 07 0B    0459*      ld bc,(iy+sprite_x)
046B95 FD 17 0E    0460*      ld de,(iy+sprite_y)
046B98 DD 2A 42 68 0461*      ld ix,(player_x)
       04          
046B9D FD 2A 45 68 0462*      ld iy,(player_y)
       04          
046BA2 CD 2F 60 04 0463*      call dxy168
046BA6 CD 96 60 04 0464*      call atan2_168game
046BAA ED 4B 8A 60 0465*      ld bc,(dx168)
       04          
046BAF ED 5B 90 60 0466*      ld de,(dy168)
       04          
046BB4 FD E1       0467*      pop iy ; restore table pointer
046BB6 C9          0468*      ret
046BB7             0469*  
046BB7             0470*  
046BB7             0471*  ; targeting_computer scratch variables
046BB7 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
046BB9 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
046BBB 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
046BBD 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
046BBF 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
046BC1 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
046BC3 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
046BC5 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
046BC7             0480*  
046BC7             0481*  
046BC7             0482*  ; ; Inputs:   see scratch variables
046BC7             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
046BC7             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
046BC7             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
046BC7             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
046BC7             0487*  ; targeting_computer:
046BC7             0488*  ; ; compute target velocity from x,y component velocities
046BC7             0489*  ;     ld bc,(player_xvel)
046BC7             0490*  ;     ld de,(player_yvel)
046BC7             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
046BC7             0492*  
046BC7             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
046BC7             0494*  ;     ld (Heading_t),bc
046BC7             0495*  ;     ld (Vt),de
046BC7             0496*  
046BC7             0497*  ; ; compute Heading_t-Bearing_t
046BC7             0498*  ;     ld h,b
046BC7             0499*  ;     ld l,c
046BC7             0500*  ;     ld bc,(Bearing_t)
046BC7             0501*  ;     and a ; clear carry
046BC7             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
046BC7             0503*  
046BC7             0504*  ; ; compute sin(Heading_t-Bearing_t)
046BC7             0505*  ;     ld b,h
046BC7             0506*  ;     ld c,l
046BC7             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
046BC7             0508*  
046BC7             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
046BC7             0510*  ;     ex de,hl
046BC7             0511*  ;     ld bc,(Vt)
046BC7             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
046BC7             0513*  
046BC7             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
046BC7             0515*  ;     ld b,h
046BC7             0516*  ;     ld c,l
046BC7             0517*  ;     ld de,(Vp)
046BC7             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
046BC7             0519*  ; ; answer is in radians, convert to degrees256
046BC7             0520*  ;     ex de,hl
046BC7             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
046BC7             0522*  ;     call BC_Mul_DE_88
046BC7             0523*  
046BC7             0524*  ; ; add lead angle to target bearing
046BC7             0525*  ;     ld de,(Bearing_t)
046BC7             0526*  ;     add hl,de ; h.l=lead angle+target bearing
046BC7             0527*  ;     push hl
046BC7             0528*  
046BC7             0529*  ; ; compute component projectile velocities
046BC7             0530*  ;     ld b,h
046BC7             0531*  ;     ld c,l
046BC7             0532*  ;     ld de,(Vp)
046BC7             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
046BC7             0534*  
046BC7             0535*  ;     ld (Vp_x),bc
046BC7             0536*  ;     ld (Vp_y),de
046BC7             0537*  ;     pop hl ; h.l=lead angle+target bearing
046BC7             0538*  ;     ret
046BC7             0539*  
046BC7             0540*  ; this routine vanquishes the enemy sprite
046BC7             0541*  ; and replaces it with an animated explosion
046BC7             0542*  ; we jump here instead of call because
046BC7             0543*  ; we want to return to differing locations in the loop
046BC7             0544*  ; depending on whether we're still sploding
046BC7             0545*  ; destroys: everything except index registers
046BC7             0546*  ; returns: an incandescent ball of debris and gas
046BC7             0547*  kill_nurple:
046BC7             0548*  ; ; tally up points
046BC7             0549*  ;     ld bc,0
046BC7             0550*  ;     ld a,(sprite_points)
046BC7             0551*  ;     ld e,a
046BC7             0552*  ;     ld d,0
046BC7             0553*  ;     ld hl,add_bcd_arg2
046BC7             0554*  ;     call set_bcd
046BC7             0555*  ;     ld hl,player_score
046BC7             0556*  ;     ld de,add_bcd_arg2
046BC7             0557*  ;     ld a,3 ; number of bytes to add
046BC7             0558*  ;     call add_bcd
046BC7             0559*  ; ; initialize explosion
046BC7             0560*  ; init_explosion:
046BC7             0561*  ;     ld hl,explosion
046BC7             0562*  ;     ld (sprite_base_bufferId),hl
046BC7             0563*  ;     ld hl,move_explosion
046BC7             0564*  ;     ld (sprite_move_program),hl
046BC7             0565*  ;     ld a,%00000000 ; collides with nothing
046BC7             0566*  ;     ld (iy+sprite_collisions),a
046BC7             0567*  ;     ld hl,0 ; north
046BC7             0568*  ;     ld (sprite_heading),hl
046BC7             0569*  ;     ld a,0x04 ; will decrement to 03
046BC7             0570*  ;     ld (sprite_animation),a
046BC7             0571*  ;     ld a,0x07 ; 7/60th of a second timer
046BC7             0572*  ;     ld (sprite_animation_timer),a
046BC7             0573*  ;     xor a
046BC7             0574*  ;     ld (sprite_move_timer),a
046BC7             0575*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
046BC7             0576*  ; ; fall through to next_explosion
046BC7             0577*  ; next_explosion:
046BC7             0578*  ;     ld a,(sprite_animation)
046BC7             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
046BC7             0580*  ;     jp m,done_explosion
046BC7             0581*  ;     ld (sprite_animation),a
046BC7             0582*  ;     ld a,0x7 ; 7/60th of a second timer
046BC7             0583*  ;     ld (sprite_animation_timer),a
046BC7             0584*  ; ; fall through to animate_explosion
046BC7             0585*  ; animate_explosion:
046BC7             0586*  ;     ld hl,sprite_y+1
046BC7             0587*  ;     inc (hl) ; move explosion down 1 pixel
046BC7             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
046BC7             0589*  ;     ld hl,sprite_animation_timer
046BC7             0590*  ;     dec (hl) ; if timer is zero,we do next animation
046BC7             0591*  ;     jr z,next_explosion
046BC7             0592*  ;     ;otherwise we fall through to draw the current one
046BC7             0593*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
046BC7             0594*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
046BC7             0595*  ;     ret ; now we go back to caller
046BC7             0596*  ; done_explosion:
046BC7 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
046BC9 FD 2A FB 52 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
046BCE FD 77 08    0599*      ld (iy+sprite_collisions),a
046BD1 C9          0600*      ret ; now we go back to caller
046BD2             0601*  
046BD2             0602*  ; game_over:
046BD2             0603*  ;     jp new_game
046BD2             0604*  
046BD2             0605*  ; it's presumed we've already checked that laser is alive
046BD2             0606*  collision_enemy_with_laser:
046BD2 DD 2A 5F 6C 0607*      ld ix,(laser_x)
       04          
046BD7 FD 2A 62 6C 0608*      ld iy,(laser_y)
       04          
046BDC 3A 5D 6C 04 0609*      ld a,(laser_dim_x)
046BE0 CB 2F       0610*      sra a ; divide by 2
046BE2 F5          0611*      push af ; we need this later
046BE3             0612*      ; ld de,0
046BE3             0613*      ; ld d,a
046BE3             0614*      ; add ix,de
046BE3             0615*      ; add iy,de
046BE3 18 11       0616*      jr collision_enemy
046BE5             0617*  
046BE5             0618*  ; it's presumed we've already checked that player is alive
046BE5             0619*  collision_enemy_with_player:
046BE5 DD 2A 42 68 0620*      ld ix,(player_x)
       04          
046BEA FD 2A 45 68 0621*      ld iy,(player_y)
       04          
046BEF 3A 40 68 04 0622*      ld a,(player_dim_x)
046BF3             0623*  
046BF3             0624*      ; call dumpRegistersHex
046BF3             0625*  
046BF3 CB 2F       0626*      sra a ; divide by 2
046BF5 F5          0627*      push af ; we need this later
046BF6             0628*      ; ld de,0
046BF6             0629*      ; ld d,a
046BF6             0630*      ; add ix,de
046BF6             0631*      ; add iy,de
046BF6             0632*      ; fall through to collision_enemy
046BF6             0633*  
046BF6             0634*  ; compute the distance between the two sprites' centers
046BF6             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
046BF6             0636*  collision_enemy:
046BF6             0637*  ; back up iy because we need it as the sprite table pointer
046BF6 FD E5       0638*      push iy
046BF8 FD 2A FB 52 0639*      ld iy,(table_pointer)
       04          
046BFD FD 27 0B    0640*      ld hl,(iy+sprite_x)
046C00 FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
046C03 CB 2F       0642*      sra a
046C05 F5          0643*      push af ; we need this later
046C06             0644*      ; ld de,0
046C06             0645*      ; ld d,a
046C06             0646*      ; add hl,de
046C06 E5          0647*      push hl
046C07 C1          0648*      pop bc ; bc = x0
046C08 FD 27 0E    0649*      ld hl,(iy+sprite_y)
046C0B FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
046C0E             0651*      ; sra a
046C0E             0652*      ; ld de,0
046C0E             0653*      ; ld d,a
046C0E             0654*      ; add hl,de
046C0E EB          0655*      ex de,hl ; de = y0
046C0F F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
046C10 FD E1       0657*      pop iy
046C12 F5          0658*      push af
046C13             0659*  
046C13             0660*      ; call dumpRegistersHex
046C13             0661*  
046C13 CD 4A 60 04 0662*      call distance168
046C17             0663*      ; CALL dumpRegistersHex
046C17             0664*  ; ; subtract sum of radii from distance between centers
046C17             0665*  ;     ld de,0
046C17             0666*  ;     pop af ; radius of enemy sprite
046C17             0667*  ;     ld e,a
046C17             0668*  ;     pop af ; radius of player or laser sprite
046C17             0669*  ;     add a,e
046C17             0670*  ;     ld e,a
046C17             0671*  ;     and a ; clear carry
046C17             0672*  ;     sbc hl,de
046C17             0673*  ;     jr c,collision_enemy_is
046C17             0674*  ;     xor a
046C17             0675*  ;     ret
046C17             0676*  ; temp fix TODO: remove this
046C17 F1          0677*      pop af
046C18 F1          0678*      pop af
046C19 11 00 10 00 0679*      ld de,16*256
046C1D A7          0680*      and a
046C1E ED 52       0681*      sbc hl,de
046C20 38 02       0682*      jr c,collision_enemy_is
046C22 AF          0683*      xor a
046C23             0684*      ; call dumpRegistersHex
046C23 C9          0685*      ret
046C24             0686*  collision_enemy_is:
046C24 AF          0687*      xor a
046C25 3C          0688*      inc a
046C26             0689*      ; call dumpRegistersHex
046C26 C9          0690*      ret
046C27             0691*  
046C27             0692*  ; ; looks up what enemy sprite collides with
046C27             0693*  ; ; detects collisions
046C27             0694*  ; ; and sets things to sploding accordingly
046C27             0695*  ; check_collisions:
046C27             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
046C27             0697*  ;     and a ; if this is zero,
046C27             0698*  ;     ret z ; there's nothing to do
046C27             0699*  ;     and %01 ; do we collide with player?
046C27             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
046C27             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
046C27             0702*  ;     and a ; was there a collision?
046C27             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
046C27             0704*  ; ; yes collision with player
046C27             0705*  ;     ; deduct shield damage
046C27             0706*  ;     ld hl,sprite_shield_damage
046C27             0707*  ;     ld a,(player_shields)
046C27             0708*  ;     sub (hl)
046C27             0709*  ;     ld (player_shields),a
046C27             0710*  ; ; if shields >= 0,player survives
046C27             0711*  ;     jp p,check_collisions_kill_nurple
046C27             0712*  ; ; otherwise update player status so it will die
046C27             0713*  ;     ld a,(player_collisions)
046C27             0714*  ;     or %10 ; sets bit 1,meaning player just died
046C27             0715*  ;     ld (player_collisions),a
046C27             0716*  ;     ; fall through
046C27             0717*  ; check_collisions_kill_nurple:
046C27             0718*  ; ; kill enemy and replace with explosion
046C27             0719*  ;     call kill_nurple
046C27             0720*  ;     ret ; and out
046C27             0721*  
046C27             0722*  check_collisions:
046C27 CD E5 6B 04 0723*      call collision_enemy_with_player ; did we hit the player?
046C2B A7          0724*      and a ; was there a collision?
046C2C C8          0725*      ret z ; if not,we're done
046C2D CD C7 6B 04 0726*      call kill_nurple ; otherwise kill enemy
046C31 C9          0727*      ret
046C32             0728*  
046C32             0729*  ; did we hit the laser?
046C32             0730*  move_enemies_laser:
046C32 FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
046C35 E6 02       0732*      and %10 ; do we even collide with laser?
046C37 C8          0733*      ret z ; if not,we're out
046C38 3A 5C 6C 04 0734*      ld a,(laser_collisions) ; is laser alive?
046C3C E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
046C3E C8          0736*      ret z ; so we're out
046C3F CD D2 6B 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
046C43 A7          0738*      and a ; was there a collision?
046C44 C8          0739*      ret z ; if not,we're done
046C45             0740*  ; otherwise we mark laser for termination and kill enemy
046C45             0741*  ; update laser status so it will die
046C45 3A 5C 6C 04 0742*      ld a,(laser_collisions)
046C49 F6 02       0743*      or %10 ; bit 1 set means laser just died
046C4B 32 5C 6C 04 0744*      ld (laser_collisions),a
046C4F CD C7 6B 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
046C53 C9          0746*      ret ; we're outta' here
046C54             0064   	include "src/asm/laser.inc"
046C54             0001*  ; ##### LASER SPRITE PARAMETERS #####
046C54             0002*  ; uses the same offsets from its table base as the main sprite table:
046C54             0003*  laser_start_variables: ; label marking beginning of table
046C54 05          0004*  laser_id:               db table_max_records+1
046C55 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
046C56 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
046C59 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
046C5C 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046C5D 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046C5E 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046C5F 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046C62 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046C65 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046C68 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046C6B 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
046C6E 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046C71 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
046C74 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
046C75 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
046C76 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
046C77 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
046C78 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
046C79 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
046C7A             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
046C7A             0025*  
046C7A             0026*  ; laser_control:
046C7A             0027*  ; ; is laser already active?
046C7A             0028*  ;     ld a,(laser_collisions)
046C7A             0029*  ;     and %00000001 ; bit zero is lit if laser is active
046C7A             0030*  ;     jr nz,laser_move ; move laser if not zero
046C7A             0031*  ; ; otherwise check if laser fired
046C7A             0032*  ;     in a,(#82) ; keyboard
046C7A             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
046C7A             0034*  ;     ret z ; go back if laser not fired
046C7A             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
046C7A             0036*  ; ; set laser status to active (set bit 0)
046C7A             0037*  ;     ld a,%1
046C7A             0038*  ;     ld (laser_collisions),a
046C7A             0039*  ; ; initialize laser position
046C7A             0040*  ;     ld a,(player_x+1) ; we only need the integer part
046C7A             0041*  ;     ; add a,6 ; horizontal center with player sprite
046C7A             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
046C7A             0043*  ;     ld a,(player_y+1) ; we only need the integer part
046C7A             0044*  ;     add a,-6 ; set laser y a few pixels above player
046C7A             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
046C7A             0046*  ;     ; fall through to laser_move
046C7A             0047*  
046C7A             0048*  ; laser_move:
046C7A             0049*  ; ; begin setting laser to active sprite
046C7A             0050*  ;     ld hl,lasers
046C7A             0051*  ;     ld (sprite_base_bufferId),hl
046C7A             0052*  ;     ld hl,0 ; north
046C7A             0053*  ;     ld (sprite_heading),hl
046C7A             0054*  ;     xor a ; laser has no animations yet :-(
046C7A             0055*  ;     ld (sprite_animation),a
046C7A             0056*  ;     ; we set position here for the time being as a default
046C7A             0057*  ;     ; in case the laser is flagged for deletion
046C7A             0058*  ;     ; load sprite_x with laser x position (we do y further down)
046C7A             0059*  ;     ld hl,(laser_x)
046C7A             0060*  ;     ld (sprite_x),hl
046C7A             0061*  ; ; did laser just die?
046C7A             0062*  ;     ld a,(laser_collisions)
046C7A             0063*  ;     bit 1,a ; z if laser didn't just die
046C7A             0064*  ;     jr z,laser_not_dead_yet
046C7A             0065*  ; ; yes laser died
046C7A             0066*  ;     call kill_laser
046C7A             0067*  ;     ret ; done
046C7A             0068*  ; laser_not_dead_yet:
046C7A             0069*  ; ; draw it
046C7A             0070*  ; ; update laser y position
046C7A             0071*  ;     ld hl,(laser_y) ; grab laser y position
046C7A             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
046C7A             0073*  ;     add hl,de ; add y velocity to y pos
046C7A             0074*  ;     ld (sprite_y),hl ; update laser y position
046C7A             0075*  ;     ld (laser_y),hl ; update laser y position
046C7A             0076*  ; ; are we at top of screen?
046C7A             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
046C7A             0078*  ;     sub h ; no carry if above threshold
046C7A             0079*  ;     jr c,finally_draw_the_frikken_laser
046C7A             0080*  ;     ; if at top of screen,laser dies
046C7A             0081*  ;     call kill_laser
046C7A             0082*  ;     ret
046C7A             0083*  ; ; otherwise,finally draw the frikken laser
046C7A             0084*  ; finally_draw_the_frikken_laser:
046C7A             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
046C7A             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
046C7A             0087*  ; ; all done
046C7A             0088*  ;     ret
046C7A             0089*  
046C7A             0090*  ; kill_laser:
046C7A             0091*  ; ; update status to inactive
046C7A             0092*  ;     xor a ; zero out a
046C7A             0093*  ;     ld (laser_collisions),a
046C7A             0094*  ;     ret
046C7A             0065   	include "src/asm/timer.inc"
046C7A             0001*  ; Table 32. Timer Control Registers
046C7A             0002*  ; this constant is the base address of the timer control registers
046C7A             0003*  ; each timer takes three bytes:
046C7A             0004*  ;   0: control register
046C7A             0005*  ;   1: low byte of timer reset value
046C7A             0006*  ;   2: high byte of timer reset value
046C7A             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
046C7A             0008*  ; which correctly force the high and upper bytes of the address bus to zero
046C7A             0009*  TMR_CTL:     equ 80h
046C7A             0010*  
046C7A             0011*  ; Timer Control Register Bit Definitions
046C7A             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
046C7A             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
046C7A             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
046C7A             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
046C7A             0016*                              ; the TMRx_CTL register is read.
046C7A             0017*  
046C7A             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
046C7A             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
046C7A             0020*  
046C7A             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
046C7A             0022*                              ;  0,and counting stops when the end-of-count value is reached.
046C7A             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
046C7A             0024*                              ; written to the counter when the end-of-count value is reached.
046C7A             0025*  
046C7A             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
046C7A             0027*  CLK_DIV_256:  equ %00001100 ;
046C7A             0028*  CLK_DIV_64:   equ %00001000 ;
046C7A             0029*  CLK_DIV_16:   equ %00000100 ;
046C7A             0030*  CLK_DIV_4:    equ %00000000 ;
046C7A             0031*  
046C7A             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
046C7A             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
046C7A             0034*                              ; When a 1 is written to this bit,the values in the reload registers
046C7A             0035*                              ;  are loaded into the downcounter when the timer restarts. The
046C7A             0036*                              ; programmer must ensure that this bit is set to 1 each time
046C7A             0037*                              ; SINGLE-PASS mode is used.
046C7A             0038*  
046C7A             0039*  ; disable/enable the programmable reload timer
046C7A             0040*  PRT_EN_0:     equ %00000000 ;
046C7A             0041*  PRT_EN_1:     equ %00000001 ;
046C7A             0042*  
046C7A             0043*  ; Table 37. Timer Input Source Select Register
046C7A             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
046C7A             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
046C7A             0046*  ;   00: System clock / CLK_DIV
046C7A             0047*  ;   01: RTC / CLK_DIV
046C7A             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
046C7A             0049*  ;   10: GPIO port B pin 1.
046C7A             0050*  ;   11: GPIO port B pin 1.
046C7A             0051*  TMR_ISS:   equ 92h ; register address
046C7A             0052*  
046C7A             0053*  ; Table 51. Real-Time Clock Control Register
046C7A             0054*  RTC_CTRL: equ EDh ; register address
046C7A             0055*  
046C7A             0056*  ; alarm interrupt disable/enable
046C7A             0057*  RTC_ALARM_0:    equ %00000000
046C7A             0058*  RTC_ALARM_1:    equ %10000000
046C7A             0059*  
046C7A             0060*  ; interrupt on alarm disable/enable
046C7A             0061*  RTC_INT_ENT_0:  equ %00000000
046C7A             0062*  RTC_INT_ENT_1:  equ %01000000
046C7A             0063*  
046C7A             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
046C7A             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
046C7A             0066*  
046C7A             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
046C7A             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
046C7A             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
046C7A             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
046C7A             0071*  
046C7A             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
046C7A             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
046C7A             0074*  
046C7A             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
046C7A             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
046C7A             0077*  
046C7A             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
046C7A             0079*                                  ; RTC counter is enabled.
046C7A             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
046C7A             0081*                                  ; RTC counter is disabled.
046C7A             0082*  
046C7A             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
046C7A             0084*  
046C7A             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
046C7A             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
046C7A 00 00 00    0087*  prt_reload: dl 0x000000
046C7D             0088*  
046C7D             0089*  ; returns: a = 0 if running on hardware,1 if running on emulator
046C7D             0090*  ;          de = number PRT interrupts during test interval
046C7D             0091*  prt_calibrate:
046C7D CD 26 58 04 0092*      call vdu_vblank
046C81             0093*  ; set a MOS timer
046C81 21 78 00 00 0094*      ld hl,120*1 ; 1 second
046C85 FD 21 D8 6D 0095*      ld iy,tmr_test
       04          
046C8A CD B6 6D 04 0096*      call tmr_set
046C8E             0097*  ; set a PRT timer
046C8E             0098*      ; ld hl,prt_reload_hardware
046C8E             0099*      ; ld hl,prt_reload_emulator
046C8E 21 05 2D 00 0100*      ld hl,prt_reload_emulator + prt_reload_hardware / 2
046C92 22 7A 6C 04 0101*      ld (prt_reload),hl
046C96 CD F1 6C 04 0102*      call prt_set
046C9A             0103*  @loop:
046C9A             0104*  ; check time remaining on MOS timer
046C9A CD C4 6D 04 0105*      call tmr_get
046C9E CA A8 6C 04 0106*      jp z,@done ; time expired,so quit
046CA2 FA A8 6C 04 0107*      jp m,@done ; time past expiration (negative),so quit
046CA6 18 F2       0108*      jr @loop
046CA8             0109*  @done:
046CA8 ED 5B 3F 6D 0110*      ld de,(prt_irq_counter)
       04          
046CAD 01 0C 2D 00 0111*      ld bc,prt_reload_hardware ; default value for running on hardware
046CB1 ED 43 7A 6C 0112*      ld (prt_reload),bc
       04          
046CB6 21 64 00 00 0113*      ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
046CBA AF          0114*      xor a ; clear carry,zero is default value for running on hardware
046CBB 32 70 6E 04 0115*      ld (is_emulator),a
046CBF ED 52       0116*      sbc hl,de
046CC1 21 88 6E 04 0117*      ld hl,on_hardware ; default message for running on hardware
046CC5 CA 7D 6C 04 0118*      jp z,prt_calibrate ; zero result is indeterminate so we try again
046CC9 F8          0119*      ret m ; negative result means we're on hardware
046CCA 3C          0120*      inc a ; we're on emulator
046CCB 32 70 6E 04 0121*      ld (is_emulator),a
046CCF 01 FF 2C 00 0122*      ld bc,prt_reload_emulator
046CD3 ED 43 7A 6C 0123*      ld (prt_reload),bc
       04          
046CD8 21 71 6E 04 0124*      ld hl,on_emulator
046CDC C9          0125*      ret
046CDD             0126*  
046CDD 43 61 6C 69 0127*  calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
046CF1             0128*  
046CF1             0129*  ; set PRT timer
046CF1             0130*  prt_set:
046CF1 21 00 00 00 0131*      ld hl,0
046CF5 22 3F 6D 04 0132*      ld (prt_irq_counter),hl
046CF9 2A 7A 6C 04 0133*      ld hl,(prt_reload)
046CFD ED 29 84    0134*      out0 ($84),l
046D00 ED 21 85    0135*  	out0 ($85),h
046D03             0136*  ; disable timer
046D03 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
046D05 ED 39 83    0138*  	out0 ($83),a
046D08             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
046D08 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
046D0A ED 39 83    0141*  	out0 ($83),a
046D0D C9          0142*      ret
046D0E             0143*  
046D0E             0144*  ; ===============================================
046D0E             0145*  ; PRT Timer Interrupt Handling
046D0E             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
046D0E             0147*  ; -----------------------------------------------
046D0E             0148*  prt_irq_init:
046D0E             0149*      ; set up interrupt vector table 2
046D0E 21 00 00 00 0150*  	ld hl,0
046D12 3A 0C 01 00 0151*  	ld a,($10c)
046D16 6F          0152*  	ld l,a
046D17 3A 0D 01 00 0153*  	ld a,($10d)
046D1B 67          0154*  	ld h,a
046D1C             0155*  
046D1C             0156*  	; skip over CALL ($c3)
046D1C 23          0157*  	inc hl
046D1D             0158*  	; load address of jump into vector table 2 (in ram)
046D1D ED 27       0159*  	ld hl,(hl)
046D1F             0160*  
046D1F             0161*  	; write CALL prt_irq_handler to vector table 2
046D1F 3E C3       0162*  	ld a,$c3
046D21 77          0163*  	ld (hl),a
046D22 23          0164*  	inc hl
046D23 11 2A 6D 04 0165*  	ld de,prt_irq_handler
046D27 ED 1F       0166*  	ld (hl),de
046D29             0167*  
046D29 C9          0168*      ret
046D2A             0169*  
046D2A             0170*  prt_irq_handler:
046D2A F3          0171*  	di
046D2B F5          0172*  	push af
046D2C E5          0173*      push hl
046D2D ED 38 83    0174*  	in0 a,($83)
046D30 2A 3F 6D 04 0175*  	ld hl,(prt_irq_counter)
046D34 23          0176*  	inc hl
046D35 22 3F 6D 04 0177*  	ld (prt_irq_counter),hl
046D39 E1          0178*      pop hl
046D3A F1          0179*  	pop af
046D3B FB          0180*  	ei
046D3C 5B ED 4D    0181*  	reti.l
046D3F             0182*  
046D3F             0183*  prt_irq_counter:
046D3F 00 00 00    0184*  	.dl 0
046D42             0185*  prt_irq_counter_saved:
046D42 00 00 00    0186*      .dl 0
046D45             0187*  
046D45             0188*  prt_loop_reset:
046D45 E5          0189*      push hl
046D46 21 00 00 00 0190*  	ld hl,0
046D4A 22 3F 6D 04 0191*  	ld (prt_irq_counter),hl
046D4E 22 B0 6D 04 0192*      ld (prt_loop_counter),hl
046D52 22 B3 6D 04 0193*      ld (prt_loops),hl
046D56 CD F1 6C 04 0194*      call prt_set
046D5A E1          0195*      pop hl
046D5B C9          0196*      ret
046D5C             0197*  
046D5C             0198*  prt_loop_start:
046D5C E5          0199*      push hl
046D5D 21 00 00 00 0200*  	ld hl,0
046D61 22 3F 6D 04 0201*  	ld (prt_irq_counter),hl
046D65 E1          0202*      pop hl
046D66 C9          0203*      ret
046D67             0204*  
046D67             0205*  prt_loop_stop:
046D67 E5          0206*      push hl
046D68 D5          0207*      push de
046D69 2A 3F 6D 04 0208*      ld hl,(prt_irq_counter)
046D6D ED 5B B0 6D 0209*      ld de,(prt_loop_counter)
       04          
046D72 19          0210*      add hl,de
046D73 22 B0 6D 04 0211*      ld (prt_loop_counter),hl
046D77 21 00 00 00 0212*      ld hl,0
046D7B 22 3F 6D 04 0213*      ld (prt_irq_counter),hl
046D7F 2A B3 6D 04 0214*      ld hl,(prt_loops)
046D83 23          0215*      inc hl
046D84 22 B3 6D 04 0216*      ld (prt_loops),hl
046D88 D1          0217*      pop de
046D89 E1          0218*      pop hl
046D8A C9          0219*      ret
046D8B             0220*  
046D8B             0221*  ; inputs: bc = y,x text coordinates to print
046D8B             0222*  prt_loop_print:
046D8B F5          0223*      push af
046D8C E5          0224*      push hl
046D8D C5          0225*      push bc
046D8E D5          0226*      push de
046D8F DD E5       0227*      push ix
046D91 FD E5       0228*      push iy
046D93 CD 9E 57 04 0229*      call vdu_move_cursor
046D97             0230*  
046D97 2A B0 6D 04 0231*      ld hl,(prt_loop_counter)
046D9B CD BC 53 04 0232*      call printDec
046D9F             0233*  
046D9F 2A B3 6D 04 0234*      ld hl,(prt_loops)
046DA3 CD BC 53 04 0235*      call printDec
046DA7             0236*  
046DA7 FD E1       0237*      pop iy
046DA9 DD E1       0238*      pop ix
046DAB D1          0239*      pop de
046DAC C1          0240*      pop bc
046DAD E1          0241*      pop hl
046DAE F1          0242*      pop af
046DAF C9          0243*      ret
046DB0             0244*  
046DB0             0245*  prt_loop_counter:
046DB0 00 00 00    0246*      .dl 0
046DB3             0247*  prt_loops:
046DB3 00 00 00    0248*      .dl 0
046DB6             0249*  
046DB6             0250*  ; ===============================================
046DB6             0251*  ; Timer functions
046DB6             0252*  ; -----------------------------------------------
046DB6             0253*  ; set a countdown timer
046DB6             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046DB6             0255*  ; returns: hl = current time
046DB6             0256*  tmr_set:
046DB6 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
046DB9             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
046DB9 3E 08       0001*M 			LD	A, function
046DBB 5B CF       0002*M 			RST.LIL	08h
046DBD DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
046DC0 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
046DC3 C9          0261*      ret
046DC4             0262*  
046DC4             0263*  ; gets time remaining on a countdown timer
046DC4             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046DC4             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
046DC4             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
046DC4             0267*  tmr_get:
046DC4             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
046DC4 3E 08       0001*M 			LD	A, function
046DC6 5B CF       0002*M 			RST.LIL	08h
046DC8 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
046DCB FD 27 00    0270*      ld hl,(iy+0)            ; get start time
046DCE AF          0271*      xor a                   ; clear carry
046DCF ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
046DD1 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
046DD4 AF          0274*      xor a                   ; clear carry
046DD5 ED 5A       0275*      adc hl,de               ; hl = time remaining
046DD7             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
046DD7 C9          0277*      ret
046DD8             0278*  
046DD8             0279*  tmr_test: ds 6 ; example of a buffer to hold timer data
046DDE             0280*  
046DDE 00 00 00    0281*  timestamp_now: dl 0
046DE1 00 00 00    0282*  timestamp_old: dl 0
046DE4 00 00 00    0283*  timestamp_chg: dl 0
046DE7             0284*  
046DE7             0285*  ; update the global timestamp from the system clock
046DE7             0286*  ; inputs: none
046DE7             0287*  ; returns: hl = time elapsed in 1/120ths of a second
046DE7             0288*  ;          de = current time
046DE7             0289*  ;          ix = pointer to syvars table
046DE7             0290*  ; destroys: af,hl,de,ix
046DE7             0291*  timestamp_tick:
046DE7 ED 5B DE 6D 0292*      ld de,(timestamp_now)   ; get previous time
       04          
046DEC ED 53 E1 6D 0293*      ld (timestamp_old),de   ; save previous time
       04          
046DF1             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
046DF1 3E 08       0001*M 			LD	A, function
046DF3 5B CF       0002*M 			RST.LIL	08h
046DF5 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
046DF8 22 DE 6D 04 0296*      ld (timestamp_now),hl   ; save current time
046DFC AF          0297*      xor a                   ; clear carry
046DFD ED 52       0298*      sbc hl,de               ; hl = time elapsed
046DFF 22 E4 6D 04 0299*      ld (timestamp_chg),hl   ; save elapsed time
046E03 C9          0300*      ret
046E04             0301*  
046E04             0302*  ; set a countdown timer
046E04             0303*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046E04             0304*  ; requires: timestamp_tick to be called at least once before this function
046E04             0305*  ; returns: hl = current time
046E04             0306*  ; destroys: hl
046E04             0307*  timestamp_tmr_set:
046E04 FD 2F 03    0308*      ld (iy+3),hl            ; set time remaining
046E07 2A DE 6D 04 0309*      ld hl,(timestamp_now)   ; get current timestamp
046E0B FD 2F 00    0310*      ld (iy+0),hl            ; set start time
046E0E C9          0311*      ret
046E0F             0312*  
046E0F             0313*  ; gets time remaining on a countdown timer following the global timestamp
046E0F             0314*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046E0F             0315*  ; requires: timestamp_tick to be called at least once before this function
046E0F             0316*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
046E0F             0317*  ;          sign flags: pos = time not expired,zero or neg = time expired
046E0F             0318*  ; destroys: af,hl,de
046E0F             0319*  timestamp_tmr_get:
046E0F ED 5B DE 6D 0320*      ld de,(timestamp_now)   ; get current timestamp
       04          
046E14 FD 27 00    0321*      ld hl,(iy+0)            ; get start time
046E17 AF          0322*      xor a                   ; clear carry
046E18 ED 52       0323*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
046E1A FD 17 03    0324*      ld de,(iy+3)            ; get timer set value
046E1D AF          0325*      xor a                   ; clear carry
046E1E ED 5A       0326*      adc hl,de               ; hl = time remaining
046E20             0327*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
046E20 C9          0328*      ret
046E21             0329*  
046E21             0330*  ; set a stopwatch
046E21             0331*  ; returns: hl = start time
046E21             0332*  ; destroys: hl,ix
046E21             0333*  stopwatch_set:
046E21             0334*      MOSCALL mos_sysvars     ; ix points to syvars table
046E21 3E 08       0001*M 			LD	A, function
046E23 5B CF       0002*M 			RST.LIL	08h
046E25 DD 27 00    0335*      ld hl,(ix+sysvar_time)  ; get current time
046E28 22 3D 6E 04 0336*      ld (stopwatch_started),hl            ; set start time
046E2C C9          0337*      ret
046E2D             0338*  
046E2D             0339*  ; gets time elapsed on a stopwatch
046E2D             0340*  ; returns: hl = time elapsed in 1/120ths of a second
046E2D             0341*  ; destroys: af,hl,de,ix
046E2D             0342*  stopwatch_get:
046E2D             0343*      MOSCALL mos_sysvars     ; ix points to syvars table
046E2D 3E 08       0001*M 			LD	A, function
046E2F 5B CF       0002*M 			RST.LIL	08h
046E31 DD 27 00    0344*      ld hl,(ix+sysvar_time)  ; get current time
046E34 ED 5B 3D 6E 0345*      ld de,(stopwatch_started)            ; get start time
       04          
046E39 AF          0346*      xor a                   ; clear carry
046E3A ED 52       0347*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
046E3C C9          0348*      ret
046E3D             0349*  
046E3D             0350*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
046E40             0351*  
046E40             0352*  ; ------------------
046E40             0353*  ; delay routine
046E40             0354*  ; Author: Richard Turrnidge
046E40             0355*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
046E40             0356*  ; routine waits a fixed time,then returns
046E40             0357*  ; arrive with A =  the delay byte. One bit to be set only.
046E40             0358*  ; eg. ld A,00000100b
046E40             0359*  
046E40             0360*  multiPurposeDelay:
046E40 F5          0361*      push af
046E41 C5          0362*      push bc
046E42 DD E5       0363*      push ix
046E44 47          0364*      ld b,a
046E45 3E 08       0365*      ld a,$08
046E47 5B CF       0366*      RST.LIL	08h                 ; get IX pointer to sysvars
046E49             0367*  
046E49             0368*  waitLoop:
046E49             0369*  
046E49 DD 7E 00    0370*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
046E4C             0371*  
046E4C             0372*                                  ;   we check if bit set is same as last time we checked.
046E4C             0373*                                  ;   bit 0 - don't use
046E4C             0374*                                  ;   bit 1 - changes 64 times per second
046E4C             0375*                                  ;   bit 2 - changes 32 times per second
046E4C             0376*                                  ;   bit 3 - changes 16 times per second
046E4C             0377*  
046E4C             0378*                                  ;   bit 4 - changes 8 times per second
046E4C             0379*                                  ;   bit 5 - changes 4 times per second
046E4C             0380*                                  ;   bit 6 - changes 2 times per second
046E4C             0381*                                  ;   bit 7 - changes 1 times per second
046E4C A0          0382*      and b
046E4D 4F          0383*      ld c,a
046E4E 3A 5F 6E 04 0384*      ld a,(oldTimeStamp)
046E52 B9          0385*      cp c                        ; is A same as last value?
046E53 28 F4       0386*      jr z,waitLoop              ; loop here if it is
046E55 79          0387*      ld a,c
046E56 32 5F 6E 04 0388*      ld (oldTimeStamp),a        ; set new value
046E5A             0389*  
046E5A DD E1       0390*      pop ix
046E5C C1          0391*      pop bc
046E5D F1          0392*      pop af
046E5E C9          0393*      ret
046E5F             0394*  
046E5F 00          0395*  oldTimeStamp:   .db 00h
046E60             0066   
046E60             0067   ; new includes
046E60             0068   	; include "src/asm/images.inc"
046E60             0069   	; include "src/asm/images_sprites.inc"
046E60             0070   	; include "src/asm/images_ui.inc"
046E60             0071   	include "src/asm/files.inc"
046E60             0001*  ; load to onboard 8k sram
046E60             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
046E60             0072   
046E60 48 65 6C 6C 0073   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
046E70 00          0074   is_emulator: defb 0
046E71 52 75 6E 6E 0075   on_emulator: defb "Running on emulator.\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 2E 
       0D 0A 00    
046E88 52 75 6E 6E 0076   on_hardware: defb "Running on hardware.\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 2E 
       0D 0A 00    
046E9F             0077   
046E9F             0078   init:
046E9F             0079   ; ; set fonts
046E9F             0080   ; 	ld hl,font_nurples
046E9F             0081   ; 	ld b,144 ; loop counter for 96 chars
046E9F             0082   ; 	ld a,32 ; first char to define (space)
046E9F             0083   ; @loop:
046E9F             0084   ; 	push bc
046E9F             0085   ; 	push hl
046E9F             0086   ; 	push af
046E9F             0087   ; 	call vdu_define_character
046E9F             0088   ; 	pop af
046E9F             0089   ; 	inc a
046E9F             0090   ; 	pop hl
046E9F             0091   ; 	ld de,8
046E9F             0092   ; 	add hl,de
046E9F             0093   ; 	pop bc
046E9F             0094   ; 	djnz @loop
046E9F             0095   
046E9F             0096   ; set up the display
046E9F 3E 08       0097       ld a,8
046EA1 CD 7B 58 04 0098       call vdu_set_screen_mode
046EA5 AF          0099       xor a
046EA6 CD 8C 58 04 0100       call vdu_set_scaling
046EAA 01 20 00 00 0101   	ld bc,32
046EAE 11 10 00 00 0102   	ld de,16
046EB2 CD 37 58 04 0103   	call vdu_set_gfx_origin
046EB6             0104   
046EB6             0105   	; call vdu_init ; grab a bunch of sysvars and stuff ; TODO: DEPRECATE
046EB6 CD 7A 57 04 0106   	call vdu_cursor_off
046EBA             0107   
046EBA             0108   ; ; TESTING SOME MATHS
046EBA             0109   ; 	ld bc,0x00A000 ; 160
046EBA             0110   ; 	ld de,0x007800 ; 120
046EBA             0111   ; 	ld ix,0x011F80 ; 287.5
046EBA             0112   ; 	ld iy,0xFF9B2A ; -100.836
046EBA             0113   ; 	;  hl=0x00FF00 255
046EBA             0114   ; 	call distance168
046EBA             0115   ; 	call dumpRegistersHex
046EBA             0116   ; 	halt
046EBA             0117   ; ; END TESTING SOME MATHS
046EBA             0118   
046EBA             0119   ; ; print a hello message
046EBA             0120   ; 	ld hl,hello_world
046EBA             0121   ; 	call printString
046EBA             0122   
046EBA             0123   ; load the bitmaps
046EBA CD 60 00 04 0124   	call bmp2_init
046EBE             0125   
046EBE             0126   ; initialize the first level
046EBE AF          0127   	xor a
046EBF 32 33 69 04 0128   	ld (cur_level),a
046EC3 CD BB 69 04 0129   	call init_level
046EC7             0130   
046EC7             0131   ; set gfx viewport to scrolling window
046EC7 01 00 00 00 0132   	ld bc,0
046ECB 11 00 00 00 0133   	ld de,0
046ECF DD 21 FF 00 0134   	ld ix,255
       00          
046ED4 FD 21 DF 00 0135   	ld iy,239-16
       00          
046ED9 CD 52 58 04 0136   	call vdu_set_gfx_viewport
046EDD             0137   
046EDD             0138   ; initialize sprites
046EDD CD 35 5D 04 0139   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
046EE1 AF          0140   	xor a
046EE2             0141   @sprite_loop:
046EE2 F5          0142   	push af
046EE3 CD 09 5C 04 0143   	call vdu_sprite_select
046EE7 21 00 01 00 0144   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
046EEB CD 56 5D 04 0145   	call vdu_sprite_add_buff
046EEF F1          0146   	pop af
046EF0 3C          0147   	inc a
046EF1 FE 05       0148   	cp table_max_records+1 ; tack on sprites for player and laser
046EF3 20 ED       0149   	jr nz,@sprite_loop
046EF5 3C          0150   	inc a
046EF6 CD 3D 5C 04 0151   	call vdu_sprite_activate
046EFA             0152   
046EFA             0153   ; define player sprite
046EFA 3E 10       0154   	ld a,16
046EFC CD 09 5C 04 0155   	call vdu_sprite_select
046F00 CD 1C 5C 04 0156   	call vdu_sprite_clear_frames
046F04 21 34 01 00 0157   	ld hl,BUF_SHIP_0L
046F08 01 03 00 00 0158   	ld bc,3 ; three bitmaps for player ship
046F0C             0159   @sprite_player_loop:
046F0C C5          0160   	push bc
046F0D E5          0161   	push hl
046F0E CD 56 5D 04 0162   	call vdu_sprite_add_buff
046F12 E1          0163   	pop hl
046F13 23          0164   	inc hl
046F14 C1          0165   	pop bc
046F15 10 F5       0166   	djnz @sprite_player_loop
046F17 CD 7F 5C 04 0167   	call vdu_sprite_show
046F1B             0168   
046F1B             0169   ; initialize player
046F1B CD 5D 68 04 0170   	call player_init
046F1F             0171   
046F1F             0172   ; spawn an enemy sprite
046F1F 06 04       0173   	ld b,table_max_records
046F21             0174   @spawn_enemy_loop:
046F21 C5          0175   	push bc
046F22 CD 08 6B 04 0176   	call enemy_init_from_landing_pad
046F26 C1          0177   	pop bc
046F27 10 F8       0178   	djnz @spawn_enemy_loop
046F29             0179   
046F29 C9          0180   	ret
046F2A             0181   
046F2A             0182   ; new_game:
046F2A             0183   ; ; ###### INITIALIZE GAME #######
046F2A             0184   ; ; clear the screen
046F2A             0185   ;     ld a,3
046F2A             0186   ;     out (81h),a
046F2A             0187   
046F2A             0188   ; ; reset the sprite table
046F2A             0189   ;     xor a
046F2A             0190   ;     ld (table_active_sprites),a
046F2A             0191   ;     ld hl,table_limit
046F2A             0192   ;     ld (table_base),hl
046F2A             0193   ;     ld (table_pointer),hl
046F2A             0194   
046F2A             0195   ; ; draw a starfield over the entire screen
046F2A             0196   ;     ld b,#50 ; first row of visible screen
046F2A             0197   ; new_game_draw_stars_loop:
046F2A             0198   ;     push bc
046F2A             0199   ;     call draw_stars
046F2A             0200   ;     pop bc
046F2A             0201   ;     ld a,#10
046F2A             0202   ;     add a,b
046F2A             0203   ;     ld b,a
046F2A             0204   ;     jr nz,new_game_draw_stars_loop
046F2A             0205   
046F2A             0206   ; ; ; print a welcome message
046F2A             0207   ; ;     ld de,msg_welcome
046F2A             0208   ; ;     ld hl,#581C
046F2A             0209   ; ;     ld c,218 ; a bright pastel purple d677e3
046F2A             0210   ; ;     call print_string
046F2A             0211   
046F2A             0212   ; ; push all that to frame buffer
046F2A             0213   ;     ld a,#01 ; send video to frame buffer
046F2A             0214   ;     out (81h),a
046F2A             0215   
046F2A             0216   ; ; reset score, lives, shields
046F2A             0217   ;     xor a
046F2A             0218   ;     ld hl,player_score
046F2A             0219   ;     ld (hl),a ; player_score 0
046F2A             0220   ;     inc hl
046F2A             0221   ;     ld (hl),a ; player_score 1
046F2A             0222   ;     inc hl
046F2A             0223   ;     ld (hl),a ; player_score 3
046F2A             0224   ;     inc hl
046F2A             0225   ;     ld a,16
046F2A             0226   ;     ld (hl),a ; player_shields
046F2A             0227   ;     inc hl
046F2A             0228   ;     ld (hl),a ; player_max_shields
046F2A             0229   ;     inc hl
046F2A             0230   ;     ld a,3
046F2A             0231   ;     ld (hl),a ; player_ships
046F2A             0232   ;     inc hl
046F2A             0233   
046F2A             0234   ; ; initialize first level
046F2A             0235   ;     ld a,1 ; levels are zero-based, so this will wrap around
046F2A             0236   ;     ld (cur_level),a
046F2A             0237   ;     ld a,3 ; set max enemy sprites to easy street
046F2A             0238   ;     ; ld a,64 ; DEBUG: BRING IT
046F2A             0239   ;     ld (max_enemy_sprites),a
046F2A             0240   ;     call dt_next_level
046F2A             0241   ;     call dt
046F2A             0242   
046F2A             0243   ; ; spawn our intrepid hero
046F2A             0244   ;     call player_init
046F2A             0245   
046F2A             0246   ; ; #### BEGIN GAME VARIABLES ####
046F2A             0247   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
046F2A             0248   speed_player: equ 0x000300 ; 3 pixels per frame
046F2A             0249   
046F2A             0250   main:
046F2A             0251   ; move the background down one pixel
046F2A 3E 02       0252   	ld a,2 ; current gfx viewport
046F2C 2E 02       0253   	ld l,2 ; direction=down
046F2E 26 01       0254   	ld h,1 ; speed=1 px
046F30 CD CA 57 04 0255   	call vdu_scroll_down
046F34             0256   
046F34             0257   ; scroll tiles
046F34 CD 40 69 04 0258   	call tiles_plot
046F38             0259   
046F38             0260   ; get player input and update sprite position
046F38 CD 9A 68 04 0261   	call player_input
046F3C             0262   
046F3C             0263   ; move enemies
046F3C CD 1A 6A 04 0264   	call move_enemies
046F40             0265   
046F40             0266   ; wait for the next vblank mitigate flicker and for loop timing
046F40 CD 26 58 04 0267   	call vdu_vblank
046F44             0268   
046F44             0269   ; poll keyboard
046F44 3E 08       0270       ld a, $08                           ; code to send to MOS
046F46 5B CF       0271       rst.lil $08                         ; get IX pointer to System Variables
046F48             0272   
046F48 DD 7E 05    0273       ld a, (ix + $05)                    ; get ASCII code of key pressed
046F4B FE 1B       0274       cp 27                               ; check if 27 (ascii code for ESC)
046F4D CA 55 6F 04 0275       jp z, main_end                     ; if pressed, jump to exit
046F51             0276   
046F51 C3 2A 6F 04 0277       jp main
046F55             0278   
046F55             0279   main_end:
046F55 CD 6C 57 04 0280       call vdu_cursor_on
046F59 C9          0281   	ret
046F5A             0282   
046F5A             0283   
046F5A             0284   ; ; #### BEGIN GAME MAIN LOOP ####
046F5A             0285   ; main_loop:
046F5A             0286   ; ; ; debug: start execution counter
046F5A             0287   ; ;     ld a,1
046F5A             0288   ; ;     out (#e0),a ; start counting instructions
046F5A             0289   
046F5A             0290   ; ; refresh background from frame buffer
046F5A             0291   ;     ld a,#02
046F5A             0292   ;     out (81h),a
046F5A             0293   ;     call move_background ; now move it
046F5A             0294   ;     ld a,#01
046F5A             0295   ;     out (81h),a ; save it back to buffer
046F5A             0296   ; ; do all the things
046F5A             0297   ;     call move_enemies
046F5A             0298   ;     call player_move
046F5A             0299   ;     call laser_control
046F5A             0300   ;     call print_score
046F5A             0301   ;     call draw_shields
046F5A             0302   ;     call draw_lives
046F5A             0303   ; ; ; debug: stop execution counter and print results
046F5A             0304   ; ;     ld a,0
046F5A             0305   ; ;     out (#e0),a ; stop counting instructions
046F5A             0306   
046F5A             0307   ; ; ; debug: start execution counter
046F5A             0308   ; ;     ld a,1
046F5A             0309   ; ;     out (#e0),a ; start counting instructions
046F5A             0310   
046F5A             0311   ;     call vdu_vblank
046F5A             0312   ; ; ; debug: stop execution counter and print results
046F5A             0313   ; ;     ld a,0
046F5A             0314   ; ;     out (#e0),a ; stop counting instructions
046F5A             0315   
046F5A             0316   ;     jr main_loop
046F5A             0317   ; #### END GAME MAIN LOOP ####
046F5A             0318   
046F5A             0319   ; draws the player's shields level
046F5A             0320   ; draw_shields:
046F5A             0321   ; TODO: Agonize this routine
046F5A             0322   ; ; prep the loop to draw the bars
046F5A             0323   ;     ld a,(player_shields) ; snag shields
046F5A             0324   ;     and a
046F5A             0325   ;     ret z ; don't draw if zero shields
046F5A             0326   ; ; set loop counter and drawing position
046F5A             0327   ;     ld b,a ; loop counter
046F5A             0328   ;     ld hl,#5300+48+12
046F5A             0329   ; ; set color based on bars remaining
046F5A             0330   ;     ld c,103 ; bright green 28fe0a
046F5A             0331   ;     cp 9
046F5A             0332   ;     jp p,draw_shields_loop
046F5A             0333   ;     ld c,74 ; bright yellow eafe5b
046F5A             0334   ;     cp 3
046F5A             0335   ;     jp p,draw_shields_loop
046F5A             0336   ;     ld c,28 ; bright red fe0a0a
046F5A             0337   ; draw_shields_loop:
046F5A             0338   ;     push bc ; yup,outta
046F5A             0339   ;     push hl ; registers again
046F5A             0340   ;     ; ld a,#A8 ; ,168
046F5A             0341   ;     ld a,10 ; ,168 ; we renumber because we don't use the full charset
046F5A             0342   ;     ; call draw_char
046F5A             0343   ;     call draw_num ; we nuked draw_char for the time being
046F5A             0344   ;     pop hl
046F5A             0345   ;     ld a,8
046F5A             0346   ;     add a,l
046F5A             0347   ;     ld l,a
046F5A             0348   ;     pop bc
046F5A             0349   ;     djnz draw_shields_loop
046F5A             0350       ; ret
046F5A             0351   
046F5A             0352   ; prints the player's score
046F5A             0353   ; print_score:
046F5A             0354   ; TODO: Agonize this
046F5A             0355   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
046F5A             0356   ;     ld c,42 ; dark orange b74400
046F5A             0357   ;     ld hl,#5200+1+8+6*6
046F5A             0358   ;     ld a,3 ; print 6 bdc digits
046F5A             0359   ;     ld de,player_score
046F5A             0360   ;     call print_num
046F5A             0361   
046F5A             0362   ;     ld c,58 ; golden yellow fec10a
046F5A             0363   ;     ld hl,#5100+8+6*6
046F5A             0364   ;     ld a,3 ; print 6 bdc digits
046F5A             0365   ;     ld de,player_score
046F5A             0366   ;     call print_num
046F5A             0367       ; ret
046F5A             0368   
046F5A             0369   ; draw_lives:
046F5A             0370   ;     ld hl,player_small ; make small yellow ship the active sprite
046F5A             0371   ;     ld (sprite_base_bufferId),hl
046F5A             0372   ;     ; ld a,#80 ; northern orientation
046F5A             0373   ;     ; ld (sprite_orientation),a
046F5A             0374   ;     ld hl,0 ; north
046F5A             0375   ;     ld (sprite_heading),hl
046F5A             0376   ;     xor a
046F5A             0377   ;     ld (sprite_animation),a
046F5A             0378   ;     ld a,#56 ; top of visible screen
046F5A             0379   ;     ld (sprite_y+1),a
046F5A             0380   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
046F5A             0381   ;     ld a,(player_ships)
046F5A             0382   ;     dec a ; we draw one fewer ships than lives
046F5A             0383   ;     ret z ; nothing to draw here, move along
046F5A             0384   ;     ld b,a ; loop counter
046F5A             0385   ;     ld a,256-16 ; initial x position
046F5A             0386   ; draw_lives_loop:
046F5A             0387   ;     ld (sprite_x+1),a
046F5A             0388   ;     push af
046F5A             0389   ;     push bc
046F5A             0390   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
046F5A             0391   ;     pop bc
046F5A             0392   ;     pop af
046F5A             0393   ;     sub 10
046F5A             0394   ;     djnz draw_lives_loop
046F5A             0395   ;     ret
