PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD A2 1B 04 0016        call main
040050             0017    
040050             0018    exit:
040050 FD E1       0019        pop iy
040052 DD E1       0020        pop ix
040054 D1          0021        pop de
040055 C1          0022        pop bc
040056 F1          0023        pop af
040057 21 00 00 00 0024        ld hl,0
04005B             0025    
04005B C9          0026        ret
04005C             0027    
04005C             0028    ; API INCLUDES
04005C             0029        include "mos_api.inc"
04005C             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04005C             0002*   ; Title:	AGON MOS - API for user projects
04005C             0003*   ; Author:	Dean Belfield
04005C             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
04005C             0005*   ;			Added MOS error codes for return in HL
04005C             0006*   ; Created:	03/08/2022
04005C             0007*   ; Last Updated:	10/08/2023
04005C             0008*   ;
04005C             0009*   ; Modinfo:
04005C             0010*   ; 05/08/2022:	Added mos_feof
04005C             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
04005C             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04005C             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04005C             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
04005C             0015*   ; 13/10/2022:	Added mos_oscli
04005C             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04005C             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
04005C             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04005C             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04005C             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04005C             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
04005C             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04005C             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04005C             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04005C             0025*   ; 19/05/2023:	Added sysvar_scrMode
04005C             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
04005C             0027*   ; 03/08/2023:	Added mos_setkbvector
04005C             0028*   ; 10/08/2023:	Added mos_getkbmap
04005C             0029*   
04005C             0030*   ; VDP control (VDU 23, 0, n)
04005C             0031*   ;
04005C             0032*   vdp_gp:				EQU 80h
04005C             0033*   vdp_keycode:		EQU 81h
04005C             0034*   vdp_cursor:			EQU	82h
04005C             0035*   vdp_scrchar:		EQU	83h
04005C             0036*   vdp_scrpixel:		EQU	84h
04005C             0037*   vdp_audio:			EQU	85h
04005C             0038*   vdp_mode:			EQU	86h
04005C             0039*   vdp_rtc:			EQU	87h
04005C             0040*   vdp_keystate:		EQU	88h
04005C             0041*   vdp_logicalcoords:	EQU	C0h
04005C             0042*   vdp_terminalmode:	EQU	FFh
04005C             0043*   
04005C             0044*   ; MOS high level functions
04005C             0045*   ;
04005C             0046*   mos_getkey:			EQU	00h
04005C             0047*   mos_load:			EQU	01h
04005C             0048*   mos_save:			EQU	02h
04005C             0049*   mos_cd:				EQU	03h
04005C             0050*   mos_dir:			EQU	04h
04005C             0051*   mos_del:			EQU	05h
04005C             0052*   mos_ren:			EQU	06h
04005C             0053*   mos_mkdir:			EQU	07h
04005C             0054*   mos_sysvars:		EQU	08h
04005C             0055*   mos_editline:		EQU	09h
04005C             0056*   mos_fopen:			EQU	0Ah
04005C             0057*   mos_fclose:			EQU	0Bh
04005C             0058*   mos_fgetc:			EQU	0Ch
04005C             0059*   mos_fputc:			EQU	0Dh
04005C             0060*   mos_feof:			EQU	0Eh
04005C             0061*   mos_getError:		EQU	0Fh
04005C             0062*   mos_oscli:			EQU	10h
04005C             0063*   mos_copy:			EQU	11h
04005C             0064*   mos_getrtc:			EQU	12h
04005C             0065*   mos_setrtc:			EQU	13h
04005C             0066*   mos_setintvector:	EQU	14h
04005C             0067*   mos_uopen:			EQU	15h
04005C             0068*   mos_uclose:			EQU	16h
04005C             0069*   mos_ugetc:			EQU	17h
04005C             0070*   mos_uputc:			EQU	18h
04005C             0071*   mos_getfil:			EQU	19h
04005C             0072*   mos_fread:			EQU	1Ah
04005C             0073*   mos_fwrite:			EQU	1Bh
04005C             0074*   mos_flseek:			EQU	1Ch
04005C             0075*   mos_setkbvector:	EQU	1Dh
04005C             0076*   mos_getkbmap:		EQU	1Eh
04005C             0077*   
04005C             0078*   ; MOS program exit codes
04005C             0079*   ;
04005C             0080*   EXIT_OK:				EQU  0;	"OK",
04005C             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04005C             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04005C             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04005C             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04005C             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04005C             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04005C             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04005C             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04005C             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04005C             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04005C             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04005C             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04005C             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04005C             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04005C             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04005C             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04005C             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04005C             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04005C             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04005C             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04005C             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04005C             0102*   ; FatFS file access functions
04005C             0103*   ;
04005C             0104*   ffs_fopen:			EQU	80h
04005C             0105*   ffs_fclose:			EQU	81h
04005C             0106*   ffs_fread:			EQU	82h
04005C             0107*   ffs_fwrite:			EQU	83h
04005C             0108*   ffs_flseek:			EQU	84h
04005C             0109*   ffs_ftruncate:		EQU	85h
04005C             0110*   ffs_fsync:			EQU	86h
04005C             0111*   ffs_fforward:		EQU	87h
04005C             0112*   ffs_fexpand:		EQU	88h
04005C             0113*   ffs_fgets:			EQU	89h
04005C             0114*   ffs_fputc:			EQU	8Ah
04005C             0115*   ffs_fputs:			EQU	8Bh
04005C             0116*   ffs_fprintf:		EQU	8Ch
04005C             0117*   ffs_ftell:			EQU	8Dh
04005C             0118*   ffs_feof:			EQU	8Eh
04005C             0119*   ffs_fsize:			EQU	8Fh
04005C             0120*   ffs_ferror:			EQU	90h
04005C             0121*   
04005C             0122*   ; FatFS directory access functions
04005C             0123*   ;
04005C             0124*   ffs_dopen:			EQU	91h
04005C             0125*   ffs_dclose:			EQU	92h
04005C             0126*   ffs_dread:			EQU	93h
04005C             0127*   ffs_dfindfirst:		EQU	94h
04005C             0128*   ffs_dfindnext:		EQU	95h
04005C             0129*   
04005C             0130*   ; FatFS file and directory management functions
04005C             0131*   ;
04005C             0132*   ffs_stat:			EQU	96h
04005C             0133*   ffs_unlink:			EQU	97h
04005C             0134*   ffs_rename:			EQU	98h
04005C             0135*   ffs_chmod:			EQU	99h
04005C             0136*   ffs_utime:			EQU	9Ah
04005C             0137*   ffs_mkdir:			EQU	9Bh
04005C             0138*   ffs_chdir:			EQU	9Ch
04005C             0139*   ffs_chdrive:		EQU	9Dh
04005C             0140*   ffs_getcwd:			EQU	9Eh
04005C             0141*   
04005C             0142*   ; FatFS volume management and system configuration functions
04005C             0143*   ;
04005C             0144*   ffs_mount:			EQU	9Fh
04005C             0145*   ffs_mkfs:			EQU	A0h
04005C             0146*   ffs_fdisk:			EQU	A1h
04005C             0147*   ffs_getfree:		EQU	A2h
04005C             0148*   ffs_getlabel:		EQU	A3h
04005C             0149*   ffs_setlabel:		EQU	A4h
04005C             0150*   ffs_setcp:			EQU	A5h
04005C             0151*   
04005C             0152*   ; File access modes
04005C             0153*   ;
04005C             0154*   fa_read:			EQU	01h
04005C             0155*   fa_write:			EQU	02h
04005C             0156*   fa_open_existing:	EQU	00h
04005C             0157*   fa_create_new:		EQU	04h
04005C             0158*   fa_create_always:	EQU	08h
04005C             0159*   fa_open_always:		EQU	10h
04005C             0160*   fa_open_append:		EQU	30h
04005C             0161*   
04005C             0162*   ; System variable indexes for api_sysvars
04005C             0163*   ; Index into _sysvars in globals.inc
04005C             0164*   ;
04005C             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04005C             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04005C             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04005C             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04005C             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04005C             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04005C             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04005C             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04005C             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04005C             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04005C             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04005C             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04005C             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04005C             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04005C             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04005C             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04005C             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04005C             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04005C             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04005C             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04005C             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04005C             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04005C             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04005C             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04005C             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
04005C             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04005C             0191*   
04005C             0192*   ; Flags for the VPD protocol
04005C             0193*   ;
04005C             0194*   vdp_pflag_cursor:		EQU	00000001b
04005C             0195*   vdp_pflag_scrchar:		EQU	00000010b
04005C             0196*   vdp_pflag_point:		EQU	00000100b
04005C             0197*   vdp_pflag_audio:		EQU	00001000b
04005C             0198*   vdp_pflag_mode:			EQU	00010000b
04005C             0199*   vdp_pflag_rtc:			EQU	00100000b
04005C             0200*   
04005C             0201*   ;
04005C             0202*   ; FatFS structures
04005C             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04005C             0204*   ;
04005C             0205*   ; Object ID and allocation information (FFOBJID)
04005C             0206*   ;
04005C             0207*   ; Indexes into FFOBJID structure
04005C             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04005C             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04005C             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
04005C             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04005C             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04005C             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04005C             0214*   ;
04005C             0215*   ; File object structure (FIL)
04005C             0216*   ;
04005C             0217*   ; Indexes into FIL structure
04005C             0218*   fil_obj:		EQU 0	; 15: Object identifier
04005C             0219*   fil_flag:		EQU	15 	;  1: File status flags
04005C             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
04005C             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04005C             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04005C             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04005C             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04005C             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04005C             0226*   ;
04005C             0227*   ; Directory object structure (DIR)
04005C             0228*   ; Indexes into DIR structure
04005C             0229*   dir_obj:		EQU  0	; 15: Object identifier
04005C             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
04005C             0231*   dir_clust:		EQU	19	;  4: Current cluster
04005C             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04005C             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04005C             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04005C             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04005C             0236*   ;
04005C             0237*   ; File information structure (FILINFO)
04005C             0238*   ;
04005C             0239*   ; Indexes into FILINFO structure
04005C             0240*   filinfo_fsize:		EQU 0	;   4: File size
04005C             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
04005C             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
04005C             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
04005C             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
04005C             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
04005C             0246*   ;
04005C             0247*   ; Macro for calling the API
04005C             0248*   ; Parameters:
04005C             0249*   ; - function: One of the function numbers listed above
04005C             0250*   ;
04005C             0251*   	MACRO	MOSCALL	function
04005C             0252*   			LD	A, function
04005C             0253*   			RST.LIL	08h
04005C             0254*   	ENDMACRO
04005C             0030        include "macros.inc"
04005C             0001*   
04005C             0002*   ; test the sign of HL
04005C             0003*   ; inputs: HL obviously
04005C             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04005C             0005*   ; destroys: flags
04005C             0006*       MACRO SIGN_HLU
04005C             0007*       add hl,de ; 1 cycle
04005C             0008*       or a ; clear flags ; 1 cycle
04005C             0009*       sbc hl,de ; 2 cycles
04005C             0010*       ; 4 cycles total
04005C             0011*       ENDMACRO
04005C             0012*   
04005C             0013*   ; put the value in A into HLU
04005C             0014*   ; affects: HLU
04005C             0015*   ; destroys: nothing
04005C             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
04005C             0017*       MACRO A_TO_HLU
04005C             0018*       xor a ; 1 cycle
04005C             0019*       ld ($+8+1),hl ; 7 cycles
04005C             0020*       ld ($+4+3),a ; 5 cycles
04005C             0021*       ld hl,0x000000 ; 4 cycles
04005C             0022*       ; 17 cycles total
04005C             0023*       ENDMACRO
04005C             0024*   
04005C             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
04005C             0026*   ; one cycle less but burns flags
04005C             0027*       MACRO A_TO_HLU_ALT
04005C             0028*       push hl ; 4 cycles
04005C             0029*       ld hl,2 ; 4 cycles
04005C             0030*       add hl,sp ; 1 cycle
04005C             0031*       ld (hl),a ; 2 cycles
04005C             0032*       pop hl ; 4 cycles
04005C             0033*       ; 15 cycles total
04005C             0034*       ENDMACRO
04005C             0035*   
04005C             0036*       MACRO hlu_mul256
04005C             0037*       add hl,hl ; * 2
04005C             0038*       add hl,hl ; * 4
04005C             0039*       add hl,hl ; * 8
04005C             0040*       add hl,hl ; * 16
04005C             0041*       add hl,hl ; * 32
04005C             0042*       add hl,hl ; * 64
04005C             0043*       add hl,hl ; * 128
04005C             0044*       add hl,hl ; * 256
04005C             0045*       ENDMACRO
04005C             0046*   
04005C             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
04005C             0048*       MACRO SRL_UHL
04005C             0049*       dec sp ; 1 cycle
04005C             0050*       push hl ; 4 cycles
04005C             0051*       inc sp ; 1 cycle
04005C             0052*       pop hl ; 4 cycles
04005C             0053*       inc hl ; 1 cycle
04005C             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04005C             0055*       ; 13 cycles total
04005C             0056*       ENDMACRO
04005C             0057*   
04005C             0058*       MACRO printChar char
04005C             0059*       LD A, char
04005C             0060*       RST.LIL 10h
04005C             0061*       ENDMACRO
04005C             0062*   
04005C             0063*   ; Simulated call to subroutine at HL
04005C             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0065*   ; outputs: whatever the subroutine does, including HL and BC
04005C             0066*   ; destroys: only what the subroutine does, but always BC
04005C             0067*       MACRO CALL_HL
04005C             0068*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0069*       push bc ; which constitutes the return address
04005C             0070*       jp (hl) ; Jump to the address in HL
04005C             0071*       ENDMACRO
04005C             0072*   
04005C             0073*   ; Simulated call to subroutine at IX
04005C             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0075*   ; outputs: whatever the subroutine does, including IX and BC
04005C             0076*   ; destroys: only what the subroutine does, but always BC
04005C             0077*       MACRO CALL_IX
04005C             0078*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0079*       push bc ; which constitutes the return address
04005C             0080*       jp (ix) ; Jump to the address in IX
04005C             0081*       ENDMACRO
04005C             0082*   
04005C             0083*   ; Simulated call to soubroutinte at IY
04005C             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0085*   ; outputs: whatever the subroutine does, including IY and BC
04005C             0086*   ; destroys: only what the subroutine does, but always BC
04005C             0087*       MACRO CALL_IY
04005C             0088*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0089*       push bc ; which constitutes the return address
04005C             0090*       jp (iy) ; Jump to the address in IY
04005C             0091*       ENDMACRO
04005C             0092*   
04005C             0093*   ; put the value in HLU into A
04005C             0094*   ; destroys: af
04005C             0095*       MACRO HLU_TO_A
04005C             0096*       dec sp ; 1 cycle
04005C             0097*       push hl ; 4 cycles
04005C             0098*       inc sp ; 1 cycle
04005C             0099*       pop af ; 4 cycles
04005C             0100*       ; 10 cycles total
04005C             0101*       ENDMACRO
04005C             0102*   
04005C             0103*       MACRO PUSH_ALL
04005C             0104*       ex af,af'
04005C             0105*       exx
04005C             0106*       push af
04005C             0107*       push hl
04005C             0108*       push bc
04005C             0109*       push de
04005C             0110*   
04005C             0111*       ex af,af'
04005C             0112*       exx
04005C             0113*       push af
04005C             0114*       push hl
04005C             0115*       push bc
04005C             0116*       push de
04005C             0117*       push ix
04005C             0118*       push iy
04005C             0119*       ENDMACRO
04005C             0120*   
04005C             0121*       MACRO POP_ALL
04005C             0122*       pop iy
04005C             0123*       pop ix
04005C             0124*       pop de
04005C             0125*       pop bc
04005C             0126*       pop hl
04005C             0127*       pop af
04005C             0128*       ex af,af'
04005C             0129*       exx
04005C             0130*   
04005C             0131*       pop de
04005C             0132*       pop bc
04005C             0133*       pop hl
04005C             0134*       pop af
04005C             0135*       ex af,af'
04005C             0136*       exx
04005C             0137*       ENDMACRO
04005C             0031        include "functions.inc"
04005C             0001*   ; Print a zero-terminated string inline with code, e.g.:
04005C             0002*   ;
04005C             0003*   ;    call printInline
04005C             0004*   ;    ASCIZ "Hello, world!\r\n"
04005C             0005*   ;
04005C             0006*   ; Destroys: HL,AF
04005C             0007*   printInline:
04005C E1          0008*       pop hl ; get the return address = pointer to start of string
04005D CD 63 00 04 0009*       call printString ; HL advances to end of string
040061 E5          0010*       push hl ; restore the return address = pointer to end of string
040062 C9          0011*       ret
040063             0012*   
040063             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040063             0014*   ; Print a zero-terminated string
040063             0015*   ; HL: Pointer to string
040063             0016*   printString:
040063 C5          0017*       PUSH BC
040064 01 00 00 00 0018*       LD BC,0
040068 3E 00       0019*       LD A,0
04006A 5B DF       0020*       RST.LIL 18h
04006C C1          0021*       POP BC
04006D C9          0022*       RET
04006E             0023*   ; print a VDU sequence
04006E             0024*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
04006E             0025*   sendVDUsequence:
04006E C5          0026*       PUSH BC
04006F 01 00 00 00 0027*       LD BC, 0
040073 4E          0028*       LD C, (HL)
040074 5B DF       0029*       RST.LIL 18h
040076 C1          0030*       POP BC
040077 C9          0031*       RET
040078             0032*   ; Print Newline sequence to VDP
040078             0033*   ; destroys bc
040078             0034*   printNewLine:
040078 F5          0035*       push af ; for some reason rst.lil 10h sets carry flag
040079 3E 0D       0036*       LD A, '\r'
04007B 5B D7       0037*       RST.LIL 10h
04007D 3E 0A       0038*       LD A, '\n'
04007F 5B D7       0039*       RST.LIL 10h
040081 F1          0040*       pop af
040082 C9          0041*       RET
040083             0042*   
040083             0043*   ; print a zero-terminated string at a graphics coordinate
040083             0044*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040083             0045*   printStringGfx:
040083 E5          0046*       push hl ; preserve string pointer
040084             0047*   ; move graphics cursor to x,y location
040084 3E 44       0048*       ld a,plot_pt+mv_abs
040086 CD 0D 18 04 0049*       call vdu_plot
04008A             0050*   ; print string
04008A E1          0051*       pop hl ; restore string pointer
04008B             0052*   @print_loop:
04008B 7E          0053*       ld a,(hl)
04008C B7          0054*       or a ; check for end of string
04008D C8          0055*       ret z ; if zero, we're done
04008E 08          0056*       ex af,af' ; preserve character
04008F 3E 05       0057*       ld a,5 ; VDU 5 char to gfx cursor
040091 5B D7       0058*       rst.lil 10h ; send it
040093 08          0059*       ex af,af' ; restore character
040094 5B D7       0060*       rst.lil 10h ; print character
040096 23          0061*       inc hl
040097 C3 8B 00 04 0062*       jp @print_loop
04009B C9          0063*       ret
04009C             0064*   ; end printStringGfx
04009C             0065*   
04009C             0066*   ; Print a 24-bit HEX number
04009C             0067*   ; HLU: Number to print
04009C             0068*   printHex24:
04009C             0069*       HLU_TO_A
04009C 3B          0001*M1     dec sp ; 1 cycle
04009D E5          0002*M1     push hl ; 4 cycles
04009E 33          0003*M1     inc sp ; 1 cycle
04009F F1          0004*M1     pop af ; 4 cycles
0400A0             0005*M1     ; 10 cycles total
0400A0 CD AA 00 04 0070*       CALL printHex8
0400A4             0071*   ; Print a 16-bit HEX number
0400A4             0072*   ; HL: Number to print
0400A4             0073*   printHex16:
0400A4 7C          0074*       LD A,H
0400A5 CD AA 00 04 0075*       CALL printHex8
0400A9 7D          0076*       LD A,L
0400AA             0077*   ; Print an 8-bit HEX number
0400AA             0078*   ; A: Number to print
0400AA             0079*   printHex8:
0400AA 4F          0080*       LD C,A
0400AB 1F          0081*       RRA
0400AC 1F          0082*       RRA
0400AD 1F          0083*       RRA
0400AE 1F          0084*       RRA
0400AF CD B4 00 04 0085*       CALL @F
0400B3 79          0086*       LD A,C
0400B4             0087*   @@:
0400B4 E6 0F       0088*       AND 0Fh
0400B6 C6 90       0089*       ADD A,90h
0400B8 27          0090*       DAA
0400B9 CE 40       0091*       ADC A,40h
0400BB 27          0092*       DAA
0400BC 5B D7       0093*       RST.LIL 10h
0400BE C9          0094*       RET
0400BF             0095*   
0400BF             0096*   ; Print a 0x HEX prefix
0400BF             0097*   DisplayHexPrefix:
0400BF 3E 30       0098*       LD A, '0'
0400C1 5B D7       0099*       RST.LIL 10h
0400C3 3E 78       0100*       LD A, 'x'
0400C5 5B D7       0101*       RST.LIL 10h
0400C7 C9          0102*       RET
0400C8             0103*   
0400C8             0104*       MACRO printDecBC
0400C8             0105*       push hl
0400C8             0106*       push bc
0400C8             0107*       pop hl
0400C8             0108*       call printDec
0400C8             0109*       pop hl
0400C8             0110*       ENDMACRO
0400C8             0111*   
0400C8             0112*       MACRO printDecDE
0400C8             0113*       push hl
0400C8             0114*       push de
0400C8             0115*       pop hl
0400C8             0116*       call printDec
0400C8             0117*       pop hl
0400C8             0118*       ENDMACRO
0400C8             0119*   
0400C8             0120*       MACRO printDecHL
0400C8             0121*       call printDec
0400C8             0122*       ENDMACRO
0400C8             0123*   
0400C8             0124*       MACRO printDecIX
0400C8             0125*       push hl
0400C8             0126*       push ix
0400C8             0127*       pop hl
0400C8             0128*       call printDec
0400C8             0129*       pop hl
0400C8             0130*       ENDMACRO
0400C8             0131*   
0400C8             0132*       MACRO printDecIY
0400C8             0133*       push hl
0400C8             0134*       push iy
0400C8             0135*       pop hl
0400C8             0136*       call printDec
0400C8             0137*       pop hl
0400C8             0138*       ENDMACRO
0400C8             0139*   
0400C8             0140*   
0400C8             0141*   ; Prints the right justified decimal value in HL without leading zeroes
0400C8             0142*   ; HL : Value to print
0400C8             0143*   ; preserves all registers and flags
0400C8             0144*   printDec:
0400C8             0145*   ; BEGIN MY CODE
0400C8             0146*   ; back up all the things
0400C8 F5          0147*       push af
0400C9 C5          0148*       push bc
0400CA D5          0149*       push de
0400CB E5          0150*       push hl
0400CC             0151*   ; END MY CODE
0400CC 11 F4 00 04 0152*       LD DE, _printDecBuffer
0400D0 CD 04 01 04 0153*       CALL u24_to_ascii
0400D4             0154*   ; BEGIN MY CODE
0400D4             0155*   ; replace leading zeroes with spaces
0400D4 21 F4 00 04 0156*       LD HL, _printDecBuffer
0400D8 06 07       0157*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DA             0158*   @loop:
0400DA 7E          0159*       LD A, (HL)
0400DB FE 30       0160*       CP '0'
0400DD C2 E7 00 04 0161*       JP NZ, @done
0400E1 3E 20       0162*       LD A, ' '
0400E3 77          0163*       LD (HL), A
0400E4 23          0164*       INC HL
0400E5             0165*       ; CALL vdu_cursor_forward
0400E5 10 F3       0166*       DJNZ @loop
0400E7             0167*   @done:
0400E7             0168*   ; END MY CODE
0400E7 21 F4 00 04 0169*       LD HL, _printDecBuffer
0400EB CD 63 00 04 0170*       CALL printString
0400EF             0171*   ; BEGIN MY CODE
0400EF             0172*   ; restore all the things
0400EF E1          0173*       pop hl
0400F0 D1          0174*       pop de
0400F1 C1          0175*       pop bc
0400F2 F1          0176*       pop af
0400F3             0177*   ; END MY CODE
0400F3 C9          0178*       RET
0400F4 00 00 00 00 0179*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040104             0180*   
040104             0181*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040104             0182*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040104             0183*   ; so it will allways be 8 characters length
040104             0184*   ; HL : Value to convert to string
040104             0185*   ; DE : pointer to buffer, at least 8 byte + 0
040104             0186*   u24_to_ascii:
040104 01 80 69 67 0187*       LD BC,-10000000
040108 CD 3B 01 04 0188*       CALL @one_digit
04010C 01 C0 BD F0 0189*       LD BC,-1000000
040110 CD 3B 01 04 0190*       CALL @one_digit
040114 01 60 79 FE 0191*       LD BC,-100000
040118 CD 3B 01 04 0192*       CALL @one_digit
04011C 01 F0 D8 FF 0193*       LD BC,-10000
040120 CD 3B 01 04 0194*       CALL @one_digit
040124 01 18 FC FF 0195*       LD BC,-1000
040128 CD 3B 01 04 0196*       CALL @one_digit
04012C 01 9C FF FF 0197*       LD BC,-100
040130 CD 3B 01 04 0198*       CALL @one_digit
040134 0E F6       0199*       LD C,-10
040136 CD 3B 01 04 0200*       CALL @one_digit
04013A 48          0201*       LD C,B
04013B             0202*   @one_digit:
04013B 3E 2F       0203*       LD A,'0'-1
04013D             0204*   @divide_me:
04013D 3C          0205*       INC A
04013E 09          0206*       ADD HL,BC
04013F 38 FC       0207*       JR C,@divide_me
040141 ED 42       0208*       SBC HL,BC
040143 12          0209*       LD (DE),A
040144 13          0210*       INC DE
040145 C9          0211*       RET
040146             0212*   
040146             0213*   print_u24:
040146 D5          0214*       push de
040147 E5          0215*       push hl
040148 11 F4 00 04 0216*       ld de,_printDecBuffer
04014C CD 04 01 04 0217*       call u24_to_ascii
040150 21 F4 00 04 0218*       ld hl,_printDecBuffer
040154 CD 63 00 04 0219*       call printString
040158 3E 20       0220*       ld a,' '
04015A 5B D7       0221*       rst.lil 10h
04015C E1          0222*       pop hl
04015D D1          0223*       pop de
04015E C9          0224*       ret
04015F             0225*   
04015F             0226*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04015F             0227*   ; HL : Value to convert to string (integer part in H, fractional part in L)
04015F             0228*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04015F             0229*   u168_to_ascii:
04015F             0230*   ; add a leading space to make room for sign flag if needed
04015F 3E 20       0231*       ld a,' '
040161 12          0232*       ld (de),a
040162 13          0233*       inc de
040163             0234*   ; Convert integer part
040163 E5          0235*       push hl ; Save HL (we’ll need the fractional part later)
040164             0236*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040164             0237*       SRL_UHL ; Shift to get integer portion in HL
040164 3B          0001*M1     dec sp ; 1 cycle
040165 E5          0002*M1     push hl ; 4 cycles
040166 33          0003*M1     inc sp ; 1 cycle
040167 E1          0004*M1     pop hl ; 4 cycles
040168 23          0005*M1     inc hl ; 1 cycle
040169 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016B             0007*M1     ; 13 cycles total
04016B 01 F0 D8 FF 0238*       ld bc, -10000
04016F CD 92 01 04 0239*       call @one_int
040173 01 18 FC FF 0240*       ld bc, -1000
040177 CD 92 01 04 0241*       call @one_int
04017B 01 9C FF FF 0242*       ld bc, -100
04017F CD 92 01 04 0243*       call @one_int
040183 0E F6       0244*       ld c, -10
040185 CD 92 01 04 0245*       call @one_int
040189 48          0246*       ld c, b
04018A CD 92 01 04 0247*       call @one_int
04018E C3 9D 01 04 0248*       jp @frac ; Jump to fractional part conversion
040192             0249*   @one_int:
040192 3E 2F       0250*       ld a, '0' - 1 ; Start ASCII character at '0'
040194             0251*   @divide_me:
040194 3C          0252*       inc a
040195 09          0253*       add hl, bc ; Accumulate until overflow
040196 38 FC       0254*       jr c, @divide_me
040198 ED 42       0255*       sbc hl, bc ; Remove excess after overflow
04019A 12          0256*       ld (de), a ; Store ASCII digit
04019B 13          0257*       inc de
04019C C9          0258*       ret
04019D             0259*   ; Convert fractional part
04019D             0260*   @frac:
04019D 3E 2E       0261*       ld a, '.' ; Decimal point
04019F 12          0262*       ld (de), a
0401A0 13          0263*       inc de
0401A1 E1          0264*       pop hl ; Restore HL with original fraction
0401A2 06 03       0265*       ld b, 3 ; Loop counter for 3 fractional digits
0401A4             0266*   @frac_loop:
0401A4 26 0A       0267*       ld h, 10 ; Load multiplier for fractional part
0401A6 ED 6C       0268*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401A8 3E 30       0269*       ld a, '0'
0401AA 84          0270*       add a, h ; Convert integer part to ASCII
0401AB 12          0271*       ld (de), a
0401AC 13          0272*       inc de
0401AD 10 F5       0273*       djnz @frac_loop ; Repeat for each fractional digit
0401AF             0274*   ; Add null terminator
0401AF AF          0275*       xor a ; Null terminator
0401B0 12          0276*       ld (de), a
0401B1 C9          0277*       ret
0401B2             0278*   
0401B2             0279*   print_u168:
0401B2 D5          0280*       push de
0401B3 E5          0281*       push hl
0401B4 11 F4 00 04 0282*       ld de,_printDecBuffer
0401B8 CD 5F 01 04 0283*       call u168_to_ascii
0401BC 21 F4 00 04 0284*       ld hl,_printDecBuffer
0401C0 CD 63 00 04 0285*       call printString
0401C4 E1          0286*       pop hl
0401C5 D1          0287*       pop de
0401C6 C9          0288*       ret
0401C7             0289*   
0401C7             0290*   ; signed version of u168_to_ascii
0401C7             0291*   s168_to_ascii:
0401C7 D5          0292*       push de ; save starting address of buffer
0401C8 CD 6C 04 04 0293*       call hlu_abs
0401CC F5          0294*       push af ; save sign flag
0401CD CD 5F 01 04 0295*       call u168_to_ascii
0401D1 F1          0296*       pop af ; restore sign flag
0401D2 D1          0297*       pop de ; restore starting address of buffer
0401D3 F0          0298*       ret p ; hlu was positive so nothing to do
0401D4 3E 2D       0299*       ld a,'-'
0401D6 12          0300*       ld (de),a
0401D7 C9          0301*       ret
0401D8             0302*   
0401D8             0303*   print_s168:
0401D8 D5          0304*       push de
0401D9 E5          0305*       push hl
0401DA 11 F4 00 04 0306*       ld de,_printDecBuffer
0401DE CD C7 01 04 0307*       call s168_to_ascii
0401E2 21 F4 00 04 0308*       ld hl,_printDecBuffer
0401E6 CD 63 00 04 0309*       call printString
0401EA E1          0310*       pop hl
0401EB D1          0311*       pop de
0401EC C9          0312*       ret
0401ED             0313*   
0401ED             0314*   print_s168_hl:
0401ED F5          0315*       push af
0401EE E5          0316*       push hl
0401EF CD D8 01 04 0317*       call print_s168
0401F3 3E 20       0318*       ld a,' '
0401F5 5B D7       0319*       rst.lil 10h
0401F7 E1          0320*       pop hl
0401F8 F1          0321*       pop af
0401F9 C9          0322*       ret
0401FA             0323*   
0401FA             0324*   print_s168_bc:
0401FA F5          0325*       push af
0401FB C5          0326*       push bc
0401FC E5          0327*       push hl
0401FD C5          0328*       push bc
0401FE E1          0329*       pop hl
0401FF CD D8 01 04 0330*       call print_s168
040203 3E 20       0331*       ld a,' '
040205 5B D7       0332*       rst.lil 10h
040207 E1          0333*       pop hl
040208 C1          0334*       pop bc
040209 F1          0335*       pop af
04020A C9          0336*       ret
04020B             0337*   
04020B             0338*   print_s168_de:
04020B F5          0339*       push af
04020C D5          0340*       push de
04020D E5          0341*       push hl
04020E EB          0342*       ex de,hl
04020F CD D8 01 04 0343*       call print_s168
040213 3E 20       0344*       ld a,' '
040215 5B D7       0345*       rst.lil 10h
040217 E1          0346*       pop hl
040218 D1          0347*       pop de
040219 F1          0348*       pop af
04021A C9          0349*       ret
04021B             0350*   
04021B             0351*   print_s168_hl_bc_de:
04021B F5          0352*       push af
04021C C5          0353*       push bc
04021D D5          0354*       push de
04021E E5          0355*       push hl
04021F CD D8 01 04 0356*       call print_s168
040223 3E 20       0357*       ld a,' '
040225 5B D7       0358*       rst.lil 10h
040227 C5          0359*       push bc
040228 E1          0360*       pop hl
040229 CD D8 01 04 0361*       call print_s168
04022D 3E 20       0362*       ld a,' '
04022F 5B D7       0363*       rst.lil 10h
040231 EB          0364*       ex de,hl
040232 CD D8 01 04 0365*       call print_s168
040236 3E 20       0366*       ld a,' '
040238 5B D7       0367*       rst.lil 10h
04023A E1          0368*       pop hl
04023B D1          0369*       pop de
04023C C1          0370*       pop bc
04023D F1          0371*       pop af
04023E C9          0372*       ret
04023F             0373*   
04023F             0374*   print_s168_bc_de:
04023F F5          0375*       push af
040240 C5          0376*       push bc
040241 D5          0377*       push de
040242 C5          0378*       push bc
040243 E1          0379*       pop hl
040244 CD D8 01 04 0380*       call print_s168
040248 3E 20       0381*       ld a,' '
04024A 5B D7       0382*       rst.lil 10h
04024C EB          0383*       ex de,hl
04024D CD D8 01 04 0384*       call print_s168
040251 3E 20       0385*       ld a,' '
040253 5B D7       0386*       rst.lil 10h
040255 E1          0387*       pop hl
040256 D1          0388*       pop de
040257 C1          0389*       pop bc
040258 F1          0390*       pop af
040259 C9          0391*       ret
04025A             0392*   
04025A             0393*   print_s168_a:
04025A F5          0394*       push af
04025B C5          0395*       push bc
04025C E5          0396*       push hl
04025D 21 00 00 00 0397*       ld hl,0
040261 6F          0398*       ld l,a
040262 CD ED 01 04 0399*       call print_s168_hl
040266 E1          0400*       pop hl
040267 C1          0401*       pop bc
040268 F1          0402*       pop af
040269 C9          0403*       ret
04026A             0404*   
04026A             0405*   ; #### new functions added by Brandon R. Gates ####
04026A             0406*   
04026A             0407*   ; print the binary representation of the 8-bit value in a
04026A             0408*   ; destroys a, hl, bc
04026A             0409*   printBin8:
04026A 06 08       0410*       ld b,8 ; loop counter for 8 bits
04026C 21 87 02 04 0411*       ld hl,@cmd ; set hl to the low byte of the output string
040270             0412*       ; (which will be the high bit of the value in a)
040270             0413*   @loop:
040270 07          0414*       rlca ; put the next highest bit into carry
040271 38 04       0415*       jr c,@one
040273 36 30       0416*       ld (hl),'0'
040275 18 02       0417*       jr @next_bit
040277             0418*   @one:
040277 36 31       0419*       ld (hl),'1'
040279             0420*   @next_bit:
040279 23          0421*       inc hl
04027A 10 F4       0422*       djnz @loop
04027C             0423*   ; print it
04027C 21 87 02 04 0424*       ld hl,@cmd
040280 01 08 00 00 0425*       ld bc,@end-@cmd
040284 5B DF       0426*       rst.lil $18
040286 C9          0427*       ret
040287             0428*   @cmd: ds 8 ; eight bytes for eight bits
04028F             0429*   @end:
04028F             0430*   
04028F             0431*   ; print the binary representation of the 8-bit value in a
04028F             0432*   ; in reverse order (lsb first)
04028F             0433*   ; destroys a, hl, bc
04028F             0434*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
04028F 06 08       0435*       ld b,8 ; loop counter for 8 bits
040291 21 AC 02 04 0436*       ld hl,@cmd ; set hl to the low byte of the output string
040295             0437*       ; (which will be the high bit of the value in a)
040295             0438*   @loop:
040295 0F          0439*       rrca ; put the next lowest bit into carry
040296 38 04       0440*       jr c,@one
040298 36 30       0441*       ld (hl),'0'
04029A 18 02       0442*       jr @next_bit
04029C             0443*   @one:
04029C 36 31       0444*       ld (hl),'1'
04029E             0445*   @next_bit:
04029E 23          0446*       inc hl
04029F 10 F4       0447*       djnz @loop
0402A1             0448*   ; print it
0402A1 21 AC 02 04 0449*       ld hl,@cmd
0402A5 01 08 00 00 0450*       ld bc,@end-@cmd
0402A9 5B DF       0451*       rst.lil $18
0402AB C9          0452*       ret
0402AC             0453*   @cmd: ds 8 ; eight bytes for eight bits
0402B4             0454*   @end:
0402B4             0455*   
       FF FF FF FF 
       FF FF FF FF 
0402B4 20 61 66 3D 0456*   str_afu: db " af=",0
       00          
0402B9 20 68 6C 3D 0457*   str_hlu: db " hl=",0
       00          
0402BE 20 62 63 3D 0458*   str_bcu: db " bc=",0
       00          
0402C3 20 64 65 3D 0459*   str_deu: db " de=",0
       00          
0402C8 20 69 78 3D 0460*   str_ixu: db " ix=",0
       00          
0402CD 20 69 79 3D 0461*   str_iyu: db " iy=",0
       00          
0402D2             0462*   
0402D2             0463*   ; print udeuhl to screen in hexidecimal format
0402D2             0464*   ; inputs: none
0402D2             0465*   ; outputs: concatenated hexidecimal udeuhl
0402D2             0466*   ; destroys: nothing
0402D2             0467*   dumpUDEUHLHex:
0402D2             0468*   ; store everything in scratch
0402D2 22 31 03 04 0469*       ld (uhl),hl
0402D6 ED 43 34 03 0470*       ld (ubc),bc
       04          
0402DB ED 53 37 03 0471*       ld (ude),de
       04          
0402E0 DD 22 3A 03 0472*       ld (uix),ix
       04          
0402E5 FD 22 3D 03 0473*       ld (uiy),iy
       04          
0402EA F5          0474*       push af
0402EB             0475*   
0402EB             0476*   ; print each register
0402EB             0477*   
0402EB 21 25 03 04 0478*       ld hl,str_udeuhl
0402EF CD 63 00 04 0479*       call printString
0402F3 2A 37 03 04 0480*       ld hl,(ude)
0402F7 CD 9C 00 04 0481*       call printHex24
0402FB 3E 2E       0482*       ld a,'.' ; print a dot to separate the values
0402FD 5B D7       0483*       rst.lil 10h
0402FF 2A 31 03 04 0484*       ld hl,(uhl)
040303 CD 9C 00 04 0485*       call printHex24
040307 CD 78 00 04 0486*       call printNewLine
04030B             0487*   
04030B             0488*   ; restore everything
04030B 2A 31 03 04 0489*       ld hl, (uhl)
04030F ED 4B 34 03 0490*       ld bc, (ubc)
       04          
040314 ED 5B 37 03 0491*       ld de, (ude)
       04          
040319 DD 2A 3A 03 0492*       ld ix, (uix)
       04          
04031E FD 2A 3D 03 0493*       ld iy, (uiy)
       04          
040323 F1          0494*       pop af
040324             0495*   ; all done
040324 C9          0496*       ret
040325             0497*   
040325 75 64 65 2E 0498*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04032E             0499*   
04032E             0500*   ; global scratch memory for registers
04032E 00 00 00    0501*   uaf: dl 0
040331 00 00 00    0502*   uhl: dl 0
040334 00 00 00    0503*   ubc: dl 0
040337 00 00 00    0504*   ude: dl 0
04033A 00 00 00    0505*   uix: dl 0
04033D 00 00 00    0506*   uiy: dl 0
040340 00 00 00    0507*   usp: dl 0
040343 00 00 00    0508*   upc: dl 0
040346             0509*   
040346             0510*   
040346             0511*   ; set all the bits in the flag register
040346             0512*   ; more of an academic exercise than anything useful
040346             0513*   ; inputs; none
040346             0514*   ; outputs; a=0,f=255
040346             0515*   ; destroys: flags, hl
040346             0516*   ; preserves: a, because why not
040346             0517*   setAllFlags:
040346 21 FF 00 00 0518*       ld hl,255
04034A 67          0519*       ld h,a ; four cycles to preserve a is cheap
04034B E5          0520*       push hl
04034C F1          0521*       pop af
04034D C9          0522*       ret
04034E             0523*   
04034E             0524*   ; reset all the bits in the flag register
04034E             0525*   ; unlike its inverse counterpart, this may actually be useful
04034E             0526*   ; inputs; none
04034E             0527*   ; outputs; a=0,f=0
04034E             0528*   ; destroys: flags, hl
04034E             0529*   ; preserves: a, because why not
04034E             0530*   resetAllFlags:
04034E 21 00 00 00 0531*       ld hl,0
040352 67          0532*       ld h,a ; four cycles to preserve a is cheap
040353 E5          0533*       push hl
040354 F1          0534*       pop af
040355 C9          0535*       ret
040356             0536*   
040356             0537*   ; wait until user presses a key
040356             0538*   ; inputs: none
040356             0539*   ; outputs: ascii code of key pressed in a
040356             0540*   ; destroys: af,ix
040356             0541*   waitKeypress:
040356             0542*       MOSCALL mos_getkey
040356 3E 00       0001*M1 			LD	A, function
040358 5B CF       0002*M1 			RST.LIL	08h
04035A C9          0543*       ret
04035B             0544*   
04035B             0545*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035B             0546*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035B             0547*   ; outputs: memory block is cleared
04035B             0548*   ; destroys: hl, de
04035B             0549*   clear_mem:
04035B 0B          0550*       dec bc ; we do this because we will increment de before writing the first byte
04035C 77          0551*       ld (hl),a
04035D E5          0552*       push hl
04035E D1          0553*       pop de
04035F 13          0554*       inc de ; target address
040360 ED B0       0555*       ldir
040362 C9          0556*       ret
040363             0032        include "arith24.inc"
040363             0001*   ;------------------------------------------------------------------------
040363             0002*   ;  arith24.asm
040363             0003*   ;  24-bit ez80 arithmetic routines
040363             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040363             0005*   ;  MIT license
040363             0006*   ;
040363             0007*   ;  This library was created as a tool to help make ez80
040363             0008*   ;  24-bit native assembly routines for simple mathematical problems
040363             0009*   ;  more widely available.
040363             0010*   ;
040363             0011*   ;------------------------------------------------------------------------
040363             0012*   
040363             0013*   ;------------------------------------------------------------------------
040363             0014*   ; umul24:	HL = HL*DE (unsigned)
040363             0015*   ; Preserves AF, BC, DE
040363             0016*   ; Uses a fast multiply routine.
040363             0017*   ;------------------------------------------------------------------------
040363             0018*   umul24:
040363 D5          0019*   	push	DE
040364 C5          0020*   	push	BC
040365 F5          0021*   	push	AF
040366 E5          0022*   	push	HL
040367 C1          0023*   	pop		BC
040368 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036A 21 00 00 00 0025*       ld	 	hl, 0 ; Result
04036E             0026*   umul24_lp:
04036E 29          0027*   	add	hl,hl
04036F EB          0028*   	ex	de,hl
040370 29          0029*   	add	hl,hl
040371 EB          0030*   	ex	de,hl
040372 30 01       0031*   	jr	nc,umul24_nc
040374 09          0032*   	add	hl,bc
040375             0033*   umul24_nc:
040375 3D          0034*   	dec	a
040376 20 F6       0035*   	jr	nz,umul24_lp
040378 F1          0036*   	pop	af
040379 C1          0037*   	pop	bc
04037A D1          0038*   	pop	de
04037B C9          0039*   	ret
04037C             0040*   
04037C             0041*   
04037C             0042*   ;------------------------------------------------------------------------
04037C             0043*   ; udiv24
04037C             0044*   ; Unsigned 24-bit division
04037C             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04037C             0046*   ;
04037C             0047*   ; Uses AF BC DE HL
04037C             0048*   ; Uses Restoring Division algorithm
04037C             0049*   ;------------------------------------------------------------------------
04037C             0050*   
04037C             0051*   udiv24:
04037C E5          0052*   	push	hl
04037D C1          0053*   	pop		bc	;move dividend to BCU
04037E 21 00 00 00 0054*   	ld		hl,0	;result
040382 A7          0055*   	and		a
040383 ED 52       0056*   	sbc		hl,de	;test for div by 0
040385 C8          0057*   	ret		z		;it's zero, carry flag is clear
040386 19          0058*   	add		hl,de	;HL is 0 again
040387 3E 18       0059*   	ld		a,24	;number of loops through.
040389             0060*   udiv1:
040389 C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038A E3          0062*   	ex		(sp),hl
04038B 37          0063*   	scf
04038C ED 6A       0064*   	adc	hl,hl
04038E E3          0065*   	ex	(sp),hl
04038F C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040390             0067*   
040390 ED 6A       0068*   	adc	hl,hl
040392 A7          0069*   	and	a		;is this the bug
040393 ED 52       0070*   	sbc	hl,de
040395 30 02       0071*   	jr	nc,udiv2
040397 19          0072*   	add	hl,de
040398             0073*   ;	dec	c
040398 0B          0074*   	dec	bc
040399             0075*   udiv2:
040399 3D          0076*   	dec	a
04039A 20 ED       0077*   	jr	nz,udiv1
04039C 37          0078*   	scf		;flag used for div0 error
04039D C5          0079*   	push	bc
04039E D1          0080*   	pop		de	;remainder
04039F C9          0081*   	ret
0403A0             0082*   
0403A0             0083*   
0403A0             0084*   
0403A0             0085*   ;------------------------------------------------------------------------
0403A0             0086*   ; neg24
0403A0             0087*   ; Returns: HLU = 0-HLU
0403A0             0088*   ; preserves all other registers
0403A0             0089*   ;------------------------------------------------------------------------
0403A0             0090*   neg24:
0403A0 D5          0091*   	push	de
0403A1 EB          0092*   	ex		de,hl
0403A2 21 00 00 00 0093*   	ld		hl,0
0403A6 B7          0094*   	or		a
0403A7 ED 52       0095*   	sbc		hl,de
0403A9 D1          0096*   	pop		de
0403AA C9          0097*   	ret
0403AB             0098*   
0403AB             0099*   ;------------------------------------------------------------------------
0403AB             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AB             0101*   ; Returns: hlu = hlu OR deu
0403AB             0102*   ; preserves all other registers
0403AB             0103*   ;------------------------------------------------------------------------
0403AB             0104*   or_hlu_deu:
0403AB 22 34 04 04 0105*   	ld	(bitbuf1),hl
0403AF ED 53 37 04 0106*   	ld	(bitbuf2),de
       04          
0403B4 D5          0107*   	push	de	;preserve DEU
0403B5 C5          0108*   	push	bc	;preserve BCU
0403B6 06 03       0109*   	ld		b,3
0403B8 21 34 04 04 0110*   	ld	hl,bitbuf1
0403BC 11 34 04 04 0111*   	ld	de,bitbuf1
0403C0             0112*   orloop_24:
0403C0 1A          0113*   	ld	a,(de)
0403C1 B6          0114*   	or	(hl)
0403C2 12          0115*   	ld	(de),a
0403C3 13          0116*   	inc	de
0403C4 23          0117*   	inc	hl
0403C5 10 F9       0118*   	djnz	orloop_24
0403C7 2A 37 04 04 0119*   	ld	hl,(bitbuf2)
0403CB C1          0120*   	pop		bc	;restore BC
0403CC D1          0121*   	pop		de	;restore DE
0403CD             0122*   
0403CD             0123*   ;------------------------------------------------------------------------
0403CD             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403CD             0125*   ; Returns: hlu = hlu AND deu
0403CD             0126*   ; preserves all other registers
0403CD             0127*   ;------------------------------------------------------------------------
0403CD             0128*   and_hlu_deu:
0403CD 22 34 04 04 0129*   	ld	(bitbuf1),hl
0403D1 ED 53 37 04 0130*   	ld	(bitbuf2),de
       04          
0403D6 D5          0131*   	push	de	;preserve DEU
0403D7 C5          0132*   	push	bc	;preserve BCU
0403D8 06 03       0133*   	ld		b,3
0403DA 21 34 04 04 0134*   	ld	hl,bitbuf1
0403DE 11 34 04 04 0135*   	ld	de,bitbuf1
0403E2             0136*   andloop_24:
0403E2 1A          0137*   	ld	a,(de)
0403E3 A6          0138*   	and	(hl)
0403E4 12          0139*   	ld	(de),a
0403E5 13          0140*   	inc	de
0403E6 23          0141*   	inc	hl
0403E7 10 F9       0142*   	djnz	andloop_24
0403E9 2A 37 04 04 0143*   	ld	hl,(bitbuf2)
0403ED C1          0144*   	pop		bc	;restore BC
0403EE D1          0145*   	pop		de	;restore DE
0403EF             0146*   
0403EF             0147*   ;------------------------------------------------------------------------
0403EF             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403EF             0149*   ; Returns: hlu = hlu XOR deu
0403EF             0150*   ; preserves all other registers
0403EF             0151*   ;------------------------------------------------------------------------
0403EF             0152*   xor_hlu_deu:
0403EF 22 34 04 04 0153*   	ld	(bitbuf1),hl
0403F3 ED 53 37 04 0154*   	ld	(bitbuf2),de
       04          
0403F8 D5          0155*   	push	de	;preserve DEU
0403F9 C5          0156*   	push	bc	;preserve BCU
0403FA 06 03       0157*   	ld		b,3
0403FC 21 34 04 04 0158*   	ld	hl,bitbuf1
040400 11 34 04 04 0159*   	ld	de,bitbuf1
040404             0160*   xorloop_24:
040404 1A          0161*   	ld	a,(de)
040405 AE          0162*   	xor	(hl)
040406 12          0163*   	ld	(de),a
040407 13          0164*   	inc	de
040408 23          0165*   	inc	hl
040409 10 F9       0166*   	djnz	xorloop_24
04040B 2A 37 04 04 0167*   	ld	hl,(bitbuf2)
04040F C1          0168*   	pop		bc	;restore BC
040410 D1          0169*   	pop		de	;restore DE
040411             0170*   
040411             0171*   ;------------------------------------------------------------------------
040411             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040411             0173*   ; Returns: hlu = hlu << a
040411             0174*   ;		   a = 0
040411             0175*   ; NOTE: only considers a up to 16 bits.
040411             0176*   ; preserves all other registers
040411             0177*   ; modified by Brandon R. Gates to use a instead of de
040411             0178*   ;------------------------------------------------------------------------
040411             0179*   shl_hlu:
040411 B7          0180*   	or a
040412 C8          0181*   	ret		z		;we're done
040413 29          0182*   	add		hl,hl	;shift HLU left
040414 3D          0183*   	dec a
040415 18 FA       0184*   	jr		shl_hlu
040417             0185*   
040417             0186*   ;------------------------------------------------------------------------
040417             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
040417             0188*   ; Returns: hlu = hlu >> a
040417             0189*   ;		   a = 0
040417             0190*   ; NOTE: only considers a up to 16 bits.
040417             0191*   ; preserves all other registers
040417             0192*   ; modified by Brandon R. Gates to use a instead of de
040417             0193*   ;------------------------------------------------------------------------
040417             0194*   shr_hlu:
040417 22 34 04 04 0195*   	ld		(bitbuf1),hl
04041B 21 36 04 04 0196*   	ld		hl,bitbuf1+2
04041F             0197*   @shr_loop:
04041F B7          0198*   	or a
040420 28 0D       0199*   	jr		z,@shr_done		;we're done
040422             0200*   ;carry is clear from or instruction
040422 CB 1E       0201*   	rr		(hl)
040424 2B          0202*   	dec		hl
040425 CB 1E       0203*   	rr		(hl)
040427 2B          0204*   	dec		hl
040428 CB 1E       0205*   	rr		(hl)
04042A 23          0206*   	inc		hl
04042B 23          0207*   	inc		hl
04042C 3D          0208*   	dec a
04042D 18 F0       0209*   	jr		@shr_loop
04042F             0210*   @shr_done:
04042F 2A 34 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040433 C9          0212*   	ret
040434             0213*   
040434             0214*   ;------------------------------------------------------------------------
040434             0215*   ; Scratch area for calculations
040434             0216*   ;------------------------------------------------------------------------
040434 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
040437 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043A             0219*   
04043A             0220*   ; -----------------------------------------------------------------------
04043A             0221*   ; Functions added by Brandon R. Gates
04043A             0222*   ; -----------------------------------------------------------------------
04043A             0223*   
04043A             0224*   ;------------------------------------------------------------------------
04043A             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043A             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043A             0227*   ;              HLU = HLU >> LSB(A)
04043A             0228*   ; Returns: HLU = HLU >> LSB(A)
04043A             0229*   ; Destroys: af
04043A             0230*   ;------------------------------------------------------------------------
04043A             0231*   shr_hlu_log2a:
04043A B7          0232*   	or a    ; check for zero
04043B C8          0233*   	ret z   ; nothing to shift so we're done
04043C C5          0234*   	push 	bc ; preserve
04043D 06 00       0235*   	ld		b,0 ; clear b
04043F             0236*   @find_bit:
04043F 0F          0237*   	rrca ; bit 0 to carry
040440 DA 49 04 04 0238*   	jp c,@found_bit
040444 04          0239*   	inc b ; next bit
040445 C3 3F 04 04 0240*   	jp @find_bit
040449             0241*   @found_bit:
040449 78          0242*   	ld a,b
04044A CD 17 04 04 0243*   	call shr_hlu
04044E C1          0244*   	pop 	bc ; restore
04044F C9          0245*   	ret
040450             0246*   ; end shr_hlu_log2a
040450             0247*   
040450             0248*   ;------------------------------------------------------------------------
040450             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040450             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040450             0251*   ;                HLU = HLU << LSB(A)
040450             0252*   ; Returns: HLU = HLU << LSB(A)
040450             0253*   ; Destroys: af
040450             0254*   ;------------------------------------------------------------------------
040450             0255*   shl_hlu_log2a:
040450 B7          0256*   	or a    ; check for zero
040451 C8          0257*   	ret z   ; nothing to shift so we're done
040452 C5          0258*   	push 	bc ; preserve
040453 06 00       0259*   	ld		b,0 ; clear b
040455             0260*   @find_bit:
040455 0F          0261*   	rrca ; bit 0 to carry
040456 DA 5F 04 04 0262*   	jp c,@found_bit
04045A 04          0263*   	inc b ; next bit
04045B C3 55 04 04 0264*   	jp @find_bit
04045F             0265*   @found_bit:
04045F 78          0266*   	ld a,b
040460 CD 11 04 04 0267*   	call shl_hlu
040464 C1          0268*   	pop 	bc ; restore
040465 C9          0269*   	ret
040466             0270*   ; end shl_hlu_log2a
040466             0033        include "maths.inc"
040466             0001*   ;------------------------------------------------------------------------
040466             0002*   ; Scratch area for calculations
040466             0003*   ;------------------------------------------------------------------------
040466 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
040469 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
04046C             0006*   
04046C             0007*   ; absolute value of hlu
04046C             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
04046C             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
04046C             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
04046C             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
04046C             0012*   ; destroys: a
04046C             0013*   hlu_abs:
04046C 19          0014*       add hl,de
04046D B7          0015*       or a
04046E ED 52       0016*       sbc hl,de
040470 FA 75 04 04 0017*       jp m,@is_neg
040474 C9          0018*       ret ; hlu is positive or zero so we're done
040475             0019*   @is_neg:
040475 F5          0020*       push af ; otherwise, save current flags for return
040476 CD 7C 04 04 0021*       call neg_hlu ; negate hlu
04047A F1          0022*       pop af ; get back flags
04047B C9          0023*       ret
04047C             0024*   
04047C             0025*   ; flip the sign of hlu
04047C             0026*   ; inputs: hlu
04047C             0027*   ; returns: 0-hlu, flags set appropriately for the result:
04047C             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
04047C             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
04047C             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
04047C             0031*   ; destroys a
04047C             0032*   neg_hlu:
04047C D5          0033*       push de ; save de
04047D EB          0034*       ex de,hl ; put hl into de
04047E 21 00 00 00 0035*       ld hl,0 ; clear hl
040482 AF          0036*       xor a ; clear carry
040483 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040485 D1          0038*       pop de ; get de back
040486 C9          0039*       ret ; easy peasy
040487             0040*   
040487             0041*   ;------------------------------------------------------------------------
040487             0042*   ; divide hlu by 2, inspired by above
040487             0043*   ;------------------------------------------------------------------------
040487             0044*   hlu_div2:
040487 22 66 04 04 0045*       ld (scratch1),hl
04048B 21 68 04 04 0046*       ld hl,scratch1+2
04048F CB 1E       0047*       rr (hl)
040491 2B          0048*       dec hl
040492 CB 1E       0049*       rr (hl)
040494 2B          0050*       dec hl
040495 CB 1E       0051*       rr (hl)
040497 23          0052*       inc hl
040498 23          0053*       inc hl
040499 2A 66 04 04 0054*       ld hl,(scratch1)
04049D C9          0055*       ret
04049E             0056*   
04049E             0057*   ; this is my little hack to divide by 16
04049E             0058*   hlu_div16:
04049E AF          0059*       xor a
04049F 29          0060*       add hl,hl
0404A0 17          0061*       rla
0404A1 29          0062*       add hl,hl
0404A2 17          0063*       rla
0404A3 29          0064*       add hl,hl
0404A4 17          0065*       rla
0404A5 29          0066*       add hl,hl
0404A6 17          0067*       rla
0404A7 22 B4 04 04 0068*       ld (@scratch),hl
0404AB 32 B7 04 04 0069*       ld (@scratch+3),a
0404AF 2A B5 04 04 0070*       ld hl,(@scratch+1)
0404B3 C9          0071*       ret
0404B4             0072*   @scratch: ds 4
0404B8             0073*   
0404B8             0074*   ; hlu signed division by 256
0404B8             0075*   ; returns: hlu / 256
0404B8             0076*   ; destroys: af
0404B8             0077*   hlu_sdiv256:
       FF FF FF FF 
0404B8 AF          0078*       xor a ; assume hl is positive
0404B9 22 CF 04 04 0079*       ld (@buffer),hl
0404BD             0080*       SIGN_HLU
0404BD 19          0001*M1     add hl,de ; 1 cycle
0404BE B7          0002*M1     or a ; clear flags ; 1 cycle
0404BF ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C1             0004*M1     ; 4 cycles total
0404C1 F2 C6 04 04 0081*       jp p,@hl_pos
0404C5 3D          0082*       dec a
0404C6             0083*   @hl_pos:
0404C6 32 D2 04 04 0084*       ld (@buffer+3),a
0404CA 2A D0 04 04 0085*       ld hl,(@buffer+1)
0404CE C9          0086*       ret
0404CF             0087*   @buffer: ds 4
0404D3             0088*   
0404D3             0089*   ; hlu 1 byte right shift, unsigned
0404D3             0090*   ; returns: hlu / 256, fractional portion in a
0404D3             0091*   ; destroys: af
0404D3             0092*   hlu_udiv256:
       FF FF FF FF 
0404D3 AF          0093*       xor a
0404D4 32 E5 04 04 0094*       ld (@buffer+3),a
0404D8 7D          0095*       ld a,l ; save the fractional portion
0404D9 22 E2 04 04 0096*       ld (@buffer),hl
0404DD 2A E3 04 04 0097*       ld hl,(@buffer+1)
0404E1 C9          0098*       ret
0404E2             0099*   @buffer: ds 4
0404E6             0100*   
       FF FF FF FF 
0404E6 00 00 00 00 0101*   add_bcd_arg1: db #00,#00,#00,#00
0404EA 00 00 00 00 0102*   add_bcd_arg2: db #00,#00,#00,#00
0404EE             0103*   
0404EE             0104*   ; set bcd values in a scratch memory address from registers bcde
0404EE             0105*   ; input: hl; scratch address,bcde; 8-place bcd number
0404EE             0106*   ; destroys ; hl
0404EE             0107*   set_bcd:
0404EE 73          0108*       ld (hl),e
0404EF 23          0109*       inc hl
0404F0 72          0110*       ld (hl),d
0404F1 23          0111*       inc hl
0404F2 71          0112*       ld (hl),c
0404F3 23          0113*       inc hl
0404F4 70          0114*       ld (hl),b
0404F5 C9          0115*       ret
0404F6             0116*   
0404F6             0117*   ; load bcd values from a scratch memory address to bcde
0404F6             0118*   ; input: hl; scratch address
0404F6             0119*   ; output: bcde; 8-place bcd number
0404F6             0120*   ; destroys: hl
0404F6             0121*   get_bcd:
0404F6 5E          0122*       ld e,(hl)
0404F7 23          0123*       inc hl
0404F8 56          0124*       ld d,(hl)
0404F9 23          0125*       inc hl
0404FA 4E          0126*       ld c,(hl)
0404FB 23          0127*       inc hl
0404FC 46          0128*       ld b,(hl)
0404FD C9          0129*       ret
0404FE             0130*   
0404FE             0131*   ; BCD addition
0404FE             0132*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0404FE             0133*   ;       a is the number of bytes holding each number (number of places/2)
0404FE             0134*   ; outputs: (hl) + (de) --> (hl)
0404FE             0135*   ; destroys: a,b,de,hl
0404FE             0136*   add_bcd:
0404FE 47          0137*       ld b,a ; loop counter
0404FF AF          0138*       xor a ; reset a, clear carry flag
040500             0139*   adcec:
040500 1A          0140*       ld a,(de) ; addend to acc
040501 8E          0141*       adc a,(hl) ; add (hl) to acc
040502 27          0142*       daa ; adjust result to bcd
040503 77          0143*       ld (hl),a ; store result
040504 23          0144*       inc hl ; advance memory pointers
040505 13          0145*       inc de
040506 10 F8       0146*       djnz adcec ; loop until b == 0
040508 C9          0147*       ret
040509             0148*   
040509             0149*   ; BCD subtraction
040509             0150*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040509             0151*   ;       a is the number of bytes holding each number (number of places/2)
040509             0152*   ; outputs: (hl) - (de) --> (hl)
040509             0153*   ; destroys: a,b,de,hl
040509             0154*   sub_bcd:
040509 47          0155*       ld b,a ; loop counter
04050A AF          0156*       xor a ; reset a,clear carry flag
04050B             0157*   subdec:
04050B 1A          0158*       ld a,(de) ; subtrahend to acc
04050C 9E          0159*       sbc a,(hl) ; subtract (hl) from acc
04050D 27          0160*       daa ; adjust result to bcd
04050E 77          0161*       ld (hl),a ; store result
04050F 23          0162*       inc hl ; advance memory pointers
040510 13          0163*       inc de
040511 10 F8       0164*       djnz subdec ; loop until b == 0
040513 C9          0165*       ret
040514             0166*   
040514             0167*   ; http://www.z80.info/pseudo-random.txt
040514             0168*   rand_8:
040514 C5          0169*       push bc
040515 3A 28 05 04 0170*       ld a,(r_seed)
040519 4F          0171*       ld c,a
04051A             0172*   
04051A 0F          0173*       rrca ; multiply by 32
04051B 0F          0174*       rrca
04051C 0F          0175*       rrca
04051D EE 1F       0176*       xor 0x1f
04051F             0177*   
04051F 81          0178*       add a,c
040520 DE FF       0179*       sbc a,255 ; carry
040522             0180*   
040522 32 28 05 04 0181*       ld (r_seed),a
040526 C1          0182*       pop bc
040527 C9          0183*       ret
040528 50          0184*   r_seed: defb $50
040529             0185*   
040529             0186*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
040529             0187*   prng24:
040529             0188*   ;;Expects ADL mode.
040529             0189*   ;;Output: HL
040529             0190*   ;;50cc
040529             0191*   ;;33 bytes
040529             0192*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
040529 ED 5B 4A 05 0193*       ld de,(seed1)
       04          
04052E B7          0194*       or a
04052F ED 62       0195*       sbc hl,hl
040531 19          0196*       add hl,de
040532 29          0197*       add hl,hl
040533 29          0198*       add hl,hl
040534 2C          0199*       inc l
040535 19          0200*       add hl,de
040536 22 4A 05 04 0201*       ld (seed1),hl
04053A 2A 4D 05 04 0202*       ld hl,(seed2)
04053E 29          0203*       add hl,hl
04053F 9F          0204*       sbc a,a
040540 E6 1B       0205*       and %00011011
040542 AD          0206*       xor l
040543 6F          0207*       ld l,a
040544 22 4D 05 04 0208*       ld (seed2),hl
040548 19          0209*       add hl,de
040549 C9          0210*       ret
04054A 00 00 00    0211*   seed1: dl 0
04054D 00 00 00    0212*   seed2: dl 0
040550             0034        include "files.inc"
040550             0001*   ; load to onboard 8k sram
040550             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
040550             0035        include "fixed168.inc"
040550             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040550             0002*   ; uses EZ80 MLT instruction for speed
040550             0003*   ; operation: UHL * A --> UHL
040550             0004*   ; destroys: AF, HL
040550             0005*   smul24x8:
040550             0006*   ; make hl positive and store sign flag
040550 CD 6C 04 04 0007*       call hlu_abs
040554 F5          0008*       push af
040555             0009*   ; do the division
040555 CD 60 05 04 0010*       call mul24x8 ; hl = product
040559             0011*   ; adjust sign of result
040559 F1          0012*       pop af ; sign de
04055A F0          0013*       ret p ; hl was positive, nothing to do
04055B CD 7C 04 04 0014*       call neg_hlu ; result is negative
04055F C9          0015*       ret
040560             0016*   
040560             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040560             0018*   ; uses EZ80 MLT instruction for speed
040560             0019*   ; operation: UHL * A --> AUHL
040560             0020*   ; destroys: AF, HL
040560             0021*   mul24x8:
040560 D5          0022*       push de ; preserve de
040561             0023*   ; low byte
040561 5D          0024*       ld e,l
040562 57          0025*       ld d,a
040563 ED 5C       0026*       mlt de
040565 6B          0027*       ld l,e ; product low byte
040566 08          0028*       ex af,af' ; save multiplier
040567 7A          0029*       ld a,d ; carry
040568 08          0030*       ex af,af' ; save carry, restore multiplier
040569             0031*   ; high byte
040569 5C          0032*       ld e,h
04056A 57          0033*       ld d,a
04056B ED 5C       0034*       mlt de
04056D 08          0035*       ex af,af' ; save multiplier, restore carry
04056E 83          0036*       add a,e ; add carry
04056F 67          0037*       ld h,a ; product middle byte
040570 7A          0038*       ld a,d ; carry
040571 08          0039*       ex af,af' ; save carry, restore multiplier
040572             0040*   ; upper byte
040572 22 8D 05 04 0041*       ld (@scratch),hl ; 7 cycles
040576 5F          0042*       ld e,a
040577 3A 8F 05 04 0043*       ld a,(@scratch+2)
04057B 57          0044*       ld d,a
04057C ED 5C       0045*       mlt de
04057E 08          0046*       ex af,af' ; restore carry
04057F 8B          0047*       adc a,e ; add carry
040580 32 8F 05 04 0048*       ld (@scratch+2),a ; 5 cycles
040584 2A 8D 05 04 0049*       ld hl,(@scratch) ; 7 cycles
040588             0050*   ; highest byte
040588 3E 00       0051*       ld a,0 ; preserve carry flag
04058A 8A          0052*       adc a,d ; product highest byte
04058B D1          0053*       pop de ; restore de
04058C C9          0054*       ret
04058D             0055*   @scratch: ds 3
040590             0056*   
       FF FF FF 
040590 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
040596             0058*   
040596             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040596             0060*   ; operation: UHL * UDE --> mul24out
040596             0061*   mul24:
040596 DD E5       0062*       push ix ; preserve
040598             0063*   ; point to output buffer and clear it
040598 DD 21 90 05 0064*       ld ix,mul24out
       04          
04059D C5          0065*       push bc
04059E 01 00 00 00 0066*       ld bc,0
0405A2 DD 0F 00    0067*       ld (ix),bc
0405A5 DD 0F 03    0068*       ld (ix+3),bc
0405A8 C1          0069*       pop bc
0405A9             0070*   ; STEP 1: UHL * E
0405A9 7B          0071*       ld a,e
0405AA E5          0072*       push hl
0405AB CD 60 05 04 0073*       call mul24x8
0405AF DD 2F 00    0074*       ld (ix+0),hl
0405B2 DD 77 03    0075*       ld (ix+3),a
0405B5             0076*   ; STEP 2: UHL * D
0405B5 E1          0077*       pop hl
0405B6 E5          0078*       push hl
0405B7 7A          0079*       ld a,d
0405B8 CD 60 05 04 0080*       call mul24x8
0405BC CD D5 05 04 0081*       call @accumulate
0405C0             0082*   ; STEP 3: UHL * DEU
0405C0 E1          0083*       pop hl
0405C1 ED 53 05 06 0084*       ld (@de),de
       04          
0405C6 3A 07 06 04 0085*       ld a,(@de+2)
0405CA CD 60 05 04 0086*       call mul24x8
0405CE CD D5 05 04 0087*       call @accumulate
0405D2             0088*   ; all done
0405D2 DD E1       0089*       pop ix ; restore
0405D4 C9          0090*       ret
0405D5             0091*   @accumulate:
0405D5 DD 23       0092*       inc ix
0405D7             0093*   ; highest byte of product to carry
0405D7 DD 77 03    0094*       ld (ix+3),a
0405DA             0095*   ; low byte of product
0405DA 7D          0096*       ld a,l
0405DB DD 86 00    0097*       add a,(ix+0)
0405DE DD 77 00    0098*       ld (ix+0),a
0405E1             0099*   ; high byte of product
0405E1 7C          0100*       ld a,h
0405E2 DD 8E 01    0101*       adc a,(ix+1)
0405E5 DD 77 01    0102*       ld (ix+1),a
0405E8             0103*   ; uppper byte of product
0405E8 22 02 06 04 0104*       ld (@hl),hl
0405EC 3A 04 06 04 0105*       ld a,(@hl+2)
0405F0 DD 8E 02    0106*       adc a,(ix+2)
0405F3 DD 77 02    0107*       ld (ix+2),a
0405F6             0108*   ; carry
0405F6 3E 00       0109*       ld a,0 ; preserve flags
0405F8 DD 8E 03    0110*       adc a,(ix+3)
0405FB DD 77 03    0111*       ld (ix+3),a
0405FE C9          0112*       ret
0405FF             0113*   
0405FF 00 00 00    0114*   @ix: dl 0
040602 00 00 00    0115*   @hl: dl 0
040605 00 00 00    0116*   @de: dl 0
040608             0117*   
040608             0118*   ; ; UHL * UDE --> UHL (unsigned)
040608             0119*   ; umul24:
040608             0120*   ;     call mul24
040608             0121*   ;     ld hl,(mul24out)
040608             0122*   ;     ret
040608             0123*   
040608             0124*   ; UH.L = UH.L*UD.E (unsigned)
040608             0125*   umul168:
040608 CD 96 05 04 0126*       call mul24
04060C 2A 91 05 04 0127*       ld hl,(mul24out+1)
040610 C9          0128*       ret
040611             0129*   
040611             0130*   ; UH.L * UD.E --> UH.L (signed)
040611             0131*   smul168:
040611             0132*   ; make everything positive and store sign flags
040611 CD 6C 04 04 0133*       call hlu_abs
040615 F5          0134*       push af
040616 EB          0135*       ex de,hl
040617 CD 6C 04 04 0136*       call hlu_abs
04061B EB          0137*       ex de,hl
04061C F5          0138*       push af
04061D             0139*   ; do the division
04061D CD 08 06 04 0140*       call umul168 ; hl = product
040621             0141*   ; adjust sign of result
040621 F1          0142*       pop af ; sign de
040622 FA 2D 06 04 0143*       jp m,@de_neg
040626 F1          0144*       pop af ; sign hl
040627 F0          0145*       ret p ; both positive, nothing to do
040628             0146*   @hl_neg:
040628 CD 7C 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
04062C C9          0148*       ret
04062D             0149*   @de_neg:
04062D F1          0150*       pop af
04062E F8          0151*       ret m ; both negative, nothing to do
04062F CD 7C 04 04 0152*       call neg_hlu ; result is negative
040633 C9          0153*       ret
040634             0154*   
040634             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040634             0156*   ; perform unsigned division of 16.8 fixed place values
040634             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040634             0158*   udiv168:
040634             0159*   ; back up divisor
040634 ED 53 6B 06 0160*       ld (@ude),de
       04          
040639             0161*   ; get the 16-bit integer part of the quotient
040639 CD 7C 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
04063D             0163*   ; load quotient to upper three bytes of output
04063D ED 53 72 06 0164*       ld (div168_out+1),de
       04          
040642             0165*   @div256:
040642             0166*   ; multiply remainder by 256
040642             0167*       hlu_mul256
040642 29          0001*M1     add hl,hl ; * 2
040643 29          0002*M1     add hl,hl ; * 4
040644 29          0003*M1     add hl,hl ; * 8
040645 29          0004*M1     add hl,hl ; * 16
040646 29          0005*M1     add hl,hl ; * 32
040647 29          0006*M1     add hl,hl ; * 64
040648 29          0007*M1     add hl,hl ; * 128
040649 29          0008*M1     add hl,hl ; * 256
04064A             0168*   ; skip fractional computation if remainder is zero
04064A             0169*       SIGN_HLU
04064A 19          0001*M1     add hl,de ; 1 cycle
04064B B7          0002*M1     or a ; clear flags ; 1 cycle
04064C ED 52       0003*M1     sbc hl,de ; 2 cycles
04064E             0004*M1     ; 4 cycles total
04064E 20 03       0170*       jr nz,@div_frac
040650 AF          0171*       xor a
040651 18 0A       0172*       jr @write_frac
040653             0173*   ; now divide the shifted remainder by the divisor
040653             0174*   @div_frac:
040653 ED 5B 6B 06 0175*       ld de,(@ude) ; get back divisor
       04          
040658 CD 7C 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
04065C             0177*   ; load low byte of quotient to low byte of output
04065C 7B          0178*       ld a,e
04065D             0179*   @write_frac:
04065D 32 71 06 04 0180*       ld (div168_out),a
040661             0181*   ; load de with return value
040661 ED 5B 71 06 0182*       ld de,(div168_out)
       04          
040666             0183*   ; load a with any overflow
040666 3A 74 06 04 0184*       ld a,(div168_out+3)
04066A C9          0185*       ret ; ud.e is the 16.8 result
04066B             0186*   @ude: ds 6
040671             0187*   div168_out: ds 4 ; the extra byte is for overflow
040675             0188*   
040675             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040675             0190*   ; perform signed division of 16.8 fixed place values
040675             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040675             0192*   sdiv168:
040675             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040675 CD 6C 04 04 0194*       call hlu_abs
040679 F5          0195*       push af
04067A EB          0196*       ex de,hl
04067B CD 6C 04 04 0197*       call hlu_abs
04067F EB          0198*       ex de,hl
040680 F5          0199*       push af
040681             0200*   ; do the division
040681 CD 34 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
040685             0202*   ; adjust sign of result
040685 F1          0203*       pop af ; sign de
040686 FA 93 06 04 0204*       jp m,@de_neg
04068A F1          0205*       pop af ; sign hl
04068B F0          0206*       ret p ; both positive, nothing to do
04068C             0207*   @hl_neg:
04068C EB          0208*       ex de,hl ; hl = quotient, de = remainder
04068D CD 7C 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040691 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040692 C9          0211*       ret
040693             0212*   @de_neg:
040693 F1          0213*       pop af
040694 F8          0214*       ret m ; both negative, nothing to do
040695 EB          0215*       ex de,hl ; hl = quotient, de = remainder
040696 CD 7C 04 04 0216*       call neg_hlu ; result is negative
04069A EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
04069B C9          0218*       ret
04069C             0219*   
04069C             0220*   ; convert signed angles from a 360 to 256 degree circle
04069C             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
04069C             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
04069C             0223*   ; destroys: TODO
04069C             0224*   deg_360_to_256:
04069C D5          0225*       push de ; preserve de
04069D             0226*   ; make angle positive and store sign flag
04069D CD 6C 04 04 0227*       call hlu_abs
0406A1 F5          0228*       push af
0406A2             0229*   ; multiply by coversion factor of 256/360
0406A2 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
0406A6 CD 08 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
0406AA             0232*   ; restore sign flag and adjust output accordingly
0406AA F1          0233*       pop af
0406AB F2 B3 06 04 0234*       jp p,@pos ; positive number
0406AF CD 7C 04 04 0235*       call neg_hlu
0406B3             0236*   @pos:
0406B3             0237*   ; restore de and return uh.l as the result
0406B3 D1          0238*       pop de
0406B4 C9          0239*       ret
0406B5             0240*   
0406B5             0241*   ; convert signed angles from a 256 to 360 degree circle
0406B5             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
0406B5             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
0406B5             0244*   ; destroys: TODO
0406B5             0245*   deg_256_to_360:
0406B5 D5          0246*       push de ; preserve de
0406B6             0247*   ; make angle positive and store sign flag
0406B6 CD 6C 04 04 0248*       call hlu_abs
0406BA F5          0249*       push af
0406BB             0250*   ; multiply by coversion factor of 360/256
0406BB 11 68 01 00 0251*       ld de,0x000168 ; 1.406
0406BF CD 08 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
0406C3             0253*   ; restore sign flag and adjust output accordingly
0406C3 F1          0254*       pop af
0406C4 F2 CC 06 04 0255*       jp p,@pos ; positive number
0406C8 CD 7C 04 04 0256*       call neg_hlu
0406CC             0257*   @pos:
0406CC             0258*   ; restore de and return uh.l as the result
0406CC D1          0259*       pop de
0406CD C9          0260*       ret
0406CE             0261*   
0406CE             0262*   ; fixed 16.8 routine
0406CE             0263*   ; cos(uh.l) --> uh.l
0406CE             0264*   ; destroys: f, hl
0406CE             0265*   cos168:
0406CE D5          0266*       push de ; preserve de
0406CF             0267*   ; for cos we simply increment the angle by 90 degrees
0406CF             0268*   ; or 0x004000 in 16.8 degrees256
0406CF             0269*   ; which makes it a sin problem
0406CF 11 00 40 00 0270*       ld de,0x004000
0406D3 19          0271*       add hl,de ; modulo 256 happens below
0406D4 D1          0272*       pop de ; restore de
0406D5             0273*   ; fall through to sin168
0406D5             0274*   
0406D5             0275*   ; ---------------------
0406D5             0276*   ; fixed 16.8 routine
0406D5             0277*   ; sin(uh.l) --> uh.l
0406D5             0278*   ; destroys: f, hl
0406D5             0279*   sin168:
0406D5 D5          0280*       push de
0406D6             0281*   ; handle negative angles appropriately
0406D6 CD 6C 04 04 0282*       call hlu_abs
0406DA F2 E3 06 04 0283*       jp p,@F
0406DE 11 00 00 FF 0284*       ld de,-256*256
0406E2 19          0285*       add hl,de
0406E3             0286*   @@:
0406E3 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
0406E5 ED 6C       0288*       mlt hl
0406E7 11 9B 09 04 0289*       ld de,sin_lut_168 ; grab the lut address
0406EB 19          0290*       add hl,de ; bump hl by the index
0406EC ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
0406EE D1          0292*       pop de
0406EF C9          0293*       ret
0406F0             0294*   
0406F0             0295*   ; 16.8 fixed inputs / outputs
0406F0             0296*   ; takes: uh.l as angle in degrees 256
0406F0             0297*   ;        ud.e as radius
0406F0             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0406F0             0299*   ;        displacements from origin (0,0)
0406F0             0300*   ; destroys: everything except indexes
0406F0             0301*   polar_to_cartesian:
0406F0             0302*   ; back up input parameters
0406F0 22 1F 07 04 0303*       ld (@angle), hl
0406F4 ED 53 22 07 0304*       ld (@radius), de
       04          
0406F9             0305*   ; compute dx = sin(uh.l) * ud.e
0406F9 CD D5 06 04 0306*       call sin168 ; uh.l = sin(uh.l)
0406FD ED 5B 22 07 0307*       ld de,(@radius)
       04          
040702 CD 11 06 04 0308*       call smul168 ; uh.l = dx
040706 E5          0309*       push hl
040707             0310*   ; compute dy = -cos(uh.l) * ud.e
040707 2A 1F 07 04 0311*       ld hl,(@angle)
04070B CD CE 06 04 0312*       call cos168 ; uh.l = cos(uh.l)
04070F ED 5B 22 07 0313*       ld de,(@radius)
       04          
040714 CD 11 06 04 0314*       call smul168 ; uh.l = dy
040718 CD 7C 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
04071C EB          0316*       ex de,hl ; de = dy for output
04071D C1          0317*       pop bc ; bc = dx for output
04071E             0318*   ; and out
04071E C9          0319*       ret
04071F             0320*   @angle: ds 3
040722             0321*   @radius: ds 3
040725             0322*   
040725             0323*   ; 16.8 fixed inputs / outputs
040725             0324*   ; inputs: ub.c as dx, ud.e as dy
040725             0325*   ;        displacements from origin (0,0)
040725             0326*   ; returns: uh.l as angle in degrees 256
040725             0327*   ;        ud.e as radius
040725             0328*   ; destroys: everything except indexes
040725             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040725 ED 43 7E 07 0330*       ld (dx168),bc ; dx argument for distance168
       04          
04072A ED 53 84 07 0331*       ld (dy168),de ; dy argument for distance168
       04          
04072F             0332*   ; compute radius
04072F CD 8A 07 04 0333*       call distance168 ; uh.l = radius
040733 E5          0334*       push hl ; save radius
040734             0335*   ; compute angle
040734 ED 4B 7E 07 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040739 ED 5B 84 07 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04073E CD EA 07 04 0338*       call atan2_168fast ; uh.l = angle
040742             0339*   ; return result
040742 D1          0340*       pop de ; de = radius (was hl)
040743 C9          0341*       ret
040744             0342*   ; end cartesian_to_polar
040744             0343*   
040744             0344*   ; 16.8 fixed inputs / outputs
040744             0345*   ; inputs: ub.c as dx, ud.e as dy
040744             0346*   ;        displacements from origin (0,0)
040744             0347*   ; returns: uh.l as angle in degrees 256
040744             0348*   ;        ud.e as radius
040744             0349*   ; destroys: everything except indexes
040744             0350*   ; note: uses distance168sm which is more accurate for small deltas
040744             0351*   cartesian_to_polar_sm:
040744 ED 43 7E 07 0352*       ld (dx168),bc ; dx argument for distance168
       04          
040749 ED 53 84 07 0353*       ld (dy168),de ; dy argument for distance168
       04          
04074E             0354*   ; compute radius
04074E CD C5 07 04 0355*       call distance168sm ; uh.l = radius
040752 E5          0356*       push hl ; save radius
040753             0357*   ; compute angle
040753 ED 4B 7E 07 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040758 ED 5B 84 07 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04075D CD EA 07 04 0360*       call atan2_168fast ; uh.l = angle
040761             0361*   ; return result
040761 D1          0362*       pop de ; de = radius (was hl)
040762 C9          0363*       ret
040763             0364*   ; end cartesian_to_polar
040763             0365*   
040763             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040763             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040763             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040763             0369*   ;         also populates scratch locations dx168 and dy168
040763             0370*   ; destroys: a,hl,bc,de
040763             0371*   dxy168:
040763             0372*   ; compute dx = x1-x0
040763 AF          0373*       xor a ; clear carry
040764 DD E5       0374*       push ix ; move ix to hl via the stack
040766 E1          0375*       pop hl ; hl = x1
040767 ED 42       0376*       sbc hl,bc ; hl = dx
040769 22 7E 07 04 0377*       ld (dx168),hl ; dx to scratch
04076D             0378*   ; compute dy = y1-y0
04076D AF          0379*       xor a ; clear carry
04076E FD E5       0380*       push iy ; move iy to hl via the stack
040770 E1          0381*       pop hl ; hl = y1
040771 ED 52       0382*       sbc hl,de ; hl = dy
040773 22 84 07 04 0383*       ld (dy168),hl ; dy to scratch
040777             0384*   ; populate output registers and return
040777 EB          0385*       ex de,hl ; ud.e = dy
040778 ED 4B 7E 07 0386*       ld bc,(dx168) ; ub.c = dx
       04          
04077D C9          0387*       ret
04077E 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040784 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
04078A             0390*   
04078A             0391*   ; compute the euclidian distance between two cartesian coordinates
04078A             0392*   ; using the formula d = sqrt(dx^2+dy^2)
04078A             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04078A             0394*   ; output; uh.l is the 16.8 fixed format distance
04078A             0395*   ;         also populates scratch locations dx168 and dy168
04078A             0396*   ; destroys: a,hl,bc,de
04078A             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
04078A             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
04078A             0399*   distance168:
04078A             0400*   ; compute dy^2
04078A 2A 84 07 04 0401*       ld hl,(dy168)
04078E CD 6C 04 04 0402*       call hlu_abs
040792             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040792             0404*       SRL_UHL ; make integer to avoid overflow
040792 3B          0001*M1     dec sp ; 1 cycle
040793 E5          0002*M1     push hl ; 4 cycles
040794 33          0003*M1     inc sp ; 1 cycle
040795 E1          0004*M1     pop hl ; 4 cycles
040796 23          0005*M1     inc hl ; 1 cycle
040797 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040799             0007*M1     ; 13 cycles total
040799 E5          0405*       push hl
04079A D1          0406*       pop de
04079B CD 63 03 04 0407*       call umul24 ; hl = dy^2
04079F E5          0408*       push hl ; save dy^2
0407A0             0409*   ; compute dx^2
0407A0 2A 7E 07 04 0410*       ld hl,(dx168)
0407A4 CD 6C 04 04 0411*       call hlu_abs
0407A8             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
0407A8             0413*       SRL_UHL ; make integer to avoid overflow
0407A8 3B          0001*M1     dec sp ; 1 cycle
0407A9 E5          0002*M1     push hl ; 4 cycles
0407AA 33          0003*M1     inc sp ; 1 cycle
0407AB E1          0004*M1     pop hl ; 4 cycles
0407AC 23          0005*M1     inc hl ; 1 cycle
0407AD 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0407AF             0007*M1     ; 13 cycles total
0407AF E5          0414*       push hl
0407B0 D1          0415*       pop de
0407B1 CD 63 03 04 0416*       call umul24 ; hl = dx^2
0407B5             0417*   ; add dx^2 and dy^2
0407B5 D1          0418*       pop de ; de = dy^2 (was hl)
0407B6 19          0419*       add hl,de ; hl = dx^2 + dy^2
0407B7             0420*   ; compute the square root
0407B7 CD B5 08 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407BB EB          0422*       ex de,hl ; hl = distance
0407BC             0423*       hlu_mul256 ; convert back to 16.8 fixed
0407BC 29          0001*M1     add hl,hl ; * 2
0407BD 29          0002*M1     add hl,hl ; * 4
0407BE 29          0003*M1     add hl,hl ; * 8
0407BF 29          0004*M1     add hl,hl ; * 16
0407C0 29          0005*M1     add hl,hl ; * 32
0407C1 29          0006*M1     add hl,hl ; * 64
0407C2 29          0007*M1     add hl,hl ; * 128
0407C3 29          0008*M1     add hl,hl ; * 256
0407C4 C9          0424*       ret
0407C5             0425*   
0407C5             0426*   ; compute the euclidian distance between two cartesian coordinates
0407C5             0427*   ; using the formula d = sqrt(dx^2+dy^2)
0407C5             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407C5             0429*   ; output; uh.l is the 16.8 fixed format distance
0407C5             0430*   ;         also populates scratch locations dx168 and dy168
0407C5             0431*   ; destroys: a,hl,bc,de
0407C5             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
0407C5             0433*   ;       making it more accurate for small deltas,
0407C5             0434*   ;       but will overflow if used for screen-sized deltas
0407C5             0435*   distance168sm:
0407C5             0436*   ; compute dy^2
0407C5 2A 84 07 04 0437*       ld hl,(dy168)
0407C9 CD 6C 04 04 0438*       call hlu_abs
0407CD E5          0439*       push hl
0407CE D1          0440*       pop de
0407CF CD 63 03 04 0441*       call umul24 ; hl = dy^2
0407D3 E5          0442*       push hl ; save dy^2
0407D4             0443*   ; compute dx^2
0407D4 2A 7E 07 04 0444*       ld hl,(dx168)
0407D8 CD 6C 04 04 0445*       call hlu_abs
0407DC E5          0446*       push hl
0407DD D1          0447*       pop de
0407DE CD 63 03 04 0448*       call umul24 ; hl = dx^2
0407E2             0449*   ; add dx^2 and dy^2
0407E2 D1          0450*       pop de ; de = dy^2 (was hl)
0407E3 19          0451*       add hl,de ; hl = dx^2 + dy^2
0407E4             0452*   ; compute the square root
0407E4 CD B5 08 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407E8 EB          0454*       ex de,hl ; hl = distance
0407E9 C9          0455*       ret
0407EA             0456*   
0407EA             0457*   ; atan2_(ub.c,ud.e) --> uh.l
0407EA             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0407EA             0459*   ;   whether inputs are integers or fractional doesn't matter
0407EA             0460*   ;   so long as the sign bit of the upper byte is correct
0407EA             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0407EA             0462*   ; angles are COMPASS HEADINGS based on
0407EA             0463*   ; screen coordinate conventions,where the y axis is flipped
0407EA             0464*   ; #E0 224      0       32 #20
0407EA             0465*   ;        -x,-y | +x,-y
0407EA             0466*   ; #C0 192------+------ 64 #40
0407EA             0467*   ;        -x,+y | +x,+y
0407EA             0468*   ; #A0 160   128 #80   96 #60
0407EA             0469*   atan2_168fast:
0407EA             0470*   ; get signs and make everything positive
0407EA             0471*   ; get abs(x) and store its original sign
0407EA C5          0472*       push bc
0407EB E1          0473*       pop hl
0407EC CD 6C 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
0407F0 E5          0475*       push hl ; store abs(x)
0407F1 C1          0476*       pop bc ; bc = abs(x)
0407F2 F5          0477*       push af ; store sign of x
0407F3             0478*   ; get abs(y) and store its original sign
0407F3 EB          0479*       ex de,hl ; hl = y
0407F4 CD 6C 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
0407F8 EB          0481*       ex de,hl ; de = abs(y)
0407F9 F5          0482*       push af ; store sign of y
0407FA             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0407FA             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
0407FA AF          0485*       xor a ; clear the carry flag
0407FB D5          0486*       push de
0407FC E1          0487*       pop hl
0407FD ED 42       0488*       sbc hl,bc
0407FF F5          0489*       push af ; save sign of de - bc
040800 F2 09 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040804             0491*   ; otherwise we swap bc and de
040804 C5          0492*       push bc
040805 E1          0493*       pop hl
040806 EB          0494*       ex de,hl
040807 E5          0495*       push hl
040808 C1          0496*       pop bc
040809             0497*   @1:
040809             0498*   ; now we're ready to snag our preliminary result
040809 C5          0499*       push bc
04080A E1          0500*       pop hl
04080B CD 79 08 04 0501*       call atan_168fast ; uh.l comes back with prelim result
04080F             0502*   ; now we adjust uh.l based on sign of de - bc
04080F F1          0503*       pop af
040810 F2 1C 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040814 EB          0505*       ex de,hl
040815 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
040819 AF          0507*       xor a ; clear the carry flag
04081A ED 52       0508*       sbc hl,de
04081C             0509*   @2:
04081C             0510*   ; adjust the result based on quadrant
04081C             0511*   ; #E0 224      0       32 #20
04081C             0512*   ;        -x,-y | +x,-y
04081C             0513*   ; #C0 192------+------ 64 #40
04081C             0514*   ;        -x,+y | +x,+y
04081C             0515*   ; #A0 160   128 #80   96 #60
04081C F1          0516*       pop af ; sign of y
04081D CA 5A 08 04 0517*       jp z,@y_zero
040821 F2 3A 08 04 0518*       jp p,@y_pos
040825             0519*   ; y neg,check x
040825 F1          0520*       pop af ; sign of x
040826 CA 34 08 04 0521*       jp z,@y_neg_x_zero
04082A F2 39 08 04 0522*       jp p,@y_neg_x_pos
04082E             0523*   ; y neg,x neg
04082E             0524*   ; angle is 128 to 256 (270 to 360)
04082E             0525*   ; negating the intermediate does the trick
04082E CD 7C 04 04 0526*       call neg_hlu
040832 18 31       0527*       jr @zero_hlu
040834             0528*   
040834             0529*   @y_neg_x_zero:
040834             0530*   ; y neg,x zero
040834             0531*   ; angle is 0
040834 21 00 00 00 0532*       ld hl,0
040838 C9          0533*       ret
040839             0534*   @y_neg_x_pos:
040839             0535*   ; y neg,x pos
040839             0536*   ; angle is 0 to 64 (0 to 90)
040839             0537*   ; so we're good
040839 C9          0538*       ret
04083A             0539*   
04083A             0540*   @y_pos:
04083A F1          0541*       pop af ; sign of x
04083B CA 4A 08 04 0542*       jp z,@y_pos_x_zero
04083F F2 4F 08 04 0543*       jp p,@y_pos_x_pos
040843             0544*   ; y pos,x neg
040843             0545*   ; angle is 128 to 192 (180-270)
040843             0546*   ; so we add 128 to intermediate
040843 11 00 80 00 0547*       ld de,128*256
040847 19          0548*       add hl,de
040848 18 1B       0549*       jr @zero_hlu
04084A             0550*   @y_pos_x_zero:
04084A             0551*   ; y pos,x zero
04084A             0552*   ; angle is 128 (180)
04084A 21 00 80 00 0553*       ld hl,128*256
04084E C9          0554*       ret
04084F             0555*   @y_pos_x_pos:
04084F             0556*   ; y pos,x pos
04084F             0557*   ; angle is 64 to 128 (90 to 180)
04084F             0558*   ; neg the intermediate and add 180 degrees
04084F CD 7C 04 04 0559*       call neg_hlu
040853 11 00 80 00 0560*       ld de,128*256
040857 19          0561*       add hl,de
040858 18 0B       0562*       jr @zero_hlu
04085A             0563*   
04085A             0564*   @y_zero:
04085A F1          0565*       pop af ; sign of x
04085B FA 60 08 04 0566*       jp m,@y_zero_x_neg
04085F             0567*   ; y zero,x pos
04085F             0568*   ; angle is 64 (90),nothing to do
04085F C9          0569*       ret
040860             0570*   @y_zero_x_neg:
040860             0571*   ; y zero ,x neg
040860             0572*   ; angle is 192 (270)
040860 21 00 C0 00 0573*       ld hl,192*256
040864 C9          0574*       ret
040865             0575*   @zero_hlu:
040865 AF          0576*       xor a
040866 22 73 08 04 0577*       ld (@scratch),hl
04086A 32 75 08 04 0578*       ld (@scratch+2),a
04086E 2A 73 08 04 0579*       ld hl,(@scratch)
040872 C9          0580*       ret
040873             0581*   @scratch: ds 6
040879             0582*   
040879             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040879             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040879             0585*   ; destroys: a,hl,bc,de
040879             0586*   ; note: only works for angles from 0 to 32 (45) degrees
040879             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040879             0588*   atan_168fast:
040879             0589*   ; because we use compass headings instead of geometric angles
040879             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040879             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040879 CD 34 06 04 0592*       call udiv168 ; ud.e = dx/dy
04087D EB          0593*       ex de,hl ; uh.l = dx/dy
04087E             0594*   ; test uh.l for 0
04087E 19          0595*       add hl,de
04087F B7          0596*       or a
040880 ED 52       0597*       sbc hl,de
040882 28 22       0598*       jr z,@is_zero
040884             0599*   ; test uh.l for 1
040884 AF          0600*       xor a ; clear carry
040885 EB          0601*       ex de,hl
040886 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
04088A ED 52       0603*       sbc hl,de
04088C 28 13       0604*       jr z,@is_45
04088E EB          0605*       ex de,hl
04088F             0606*   ; no special cases so we move on
04088F             0607*   ; l contains the fractional portion of tan(uh.l)
04088F             0608*   ; we multiply it by three to get our lookup table index
04088F 26 03       0609*       ld h,3
040891 ED 6C       0610*       mlt hl ; index into lut
040893 11 00 00 00 0611*       ld de,0 ; clear deu
040897 54          0612*       ld d,h ; copy hl to de
040898 5D          0613*       ld e,l ; de contains our index
040899 21 9E 0C 04 0614*       ld hl,atan_lut_168 ; grab the lut address
04089D 19          0615*       add hl,de ; bump hl by the index
04089E ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
0408A0 C9          0617*       ret ; and out
0408A1             0618*   @is_45:
0408A1 21 00 20 00 0619*       ld hl,32*256
0408A5 C9          0620*       ret
0408A6             0621*   ; for the case tan(0)
0408A6             0622*   @is_zero:
0408A6 21 00 00 00 0623*       ld hl,0*256
0408AA C9          0624*       ret
0408AB             0625*   
0408AB             0626*   ; Expects  ADL mode
0408AB             0627*   ; Inputs:  UH.L
0408AB             0628*   ; Outputs: UH.L is the 16.8 square root
0408AB             0629*   ;          UDE is the integer difference inputHL-DE^2
0408AB             0630*   sqrt168:
0408AB CD B5 08 04 0631*       call sqrt24
0408AF EB          0632*       ex de,hl
0408B0 29          0633*       add hl,hl
0408B1 29          0634*       add hl,hl
0408B2 29          0635*       add hl,hl
0408B3 29          0636*       add hl,hl
0408B4 C9          0637*       ret
0408B5             0638*   
0408B5             0639*   ; credit: xeda112358
0408B5             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0408B5             0641*   sqrt24:
0408B5             0642*   ; Expects ADL mode
0408B5             0643*   ; Inputs: HL
0408B5             0644*   ; Outputs: DE is the integer square root
0408B5             0645*   ;  HL is the difference inputHL-DE^2
0408B5             0646*   ;  c flag reset
0408B5 01 00 00 00 0647*       ld bc,0 ; clear bcu
0408B9 11 00 00 00 0648*       ld de,0 ; clear deu
0408BD AF          0649*       xor a
0408BE 45          0650*       ld b,l
0408BF C5          0651*       push bc
0408C0 47          0652*       ld b,a
0408C1 6F          0653*       ld l,a
0408C2             0654*   ; Iteration 1
0408C2 29          0655*       add hl,hl
0408C3 CB 11       0656*       rl c
0408C5 29          0657*       add hl,hl
0408C6 CB 11       0658*       rl c
0408C8 91          0659*       sub c
0408C9 30 04       0660*       jr nc,$+6
0408CB 1C          0661*       inc e
0408CC 1C          0662*       inc e
0408CD 2F          0663*       cpl
0408CE 4F          0664*       ld c,a
0408CF             0665*   ; Iteration 2
0408CF 29          0666*       add hl,hl
0408D0 CB 11       0667*       rl c
0408D2 29          0668*       add hl,hl
0408D3 CB 11       0669*       rl c
0408D5 CB 13       0670*       rl e
0408D7 7B          0671*       ld a,e
0408D8 91          0672*       sub c
0408D9 30 04       0673*       jr nc,$+6
0408DB 1C          0674*       inc e
0408DC 1C          0675*       inc e
0408DD 2F          0676*       cpl
0408DE 4F          0677*       ld c,a
0408DF             0678*   ; Iteration 3
0408DF 29          0679*       add hl,hl
0408E0 CB 11       0680*       rl c
0408E2 29          0681*       add hl,hl
0408E3 CB 11       0682*       rl c
0408E5 CB 13       0683*       rl e
0408E7 7B          0684*       ld a,e
0408E8 91          0685*       sub c
0408E9 30 04       0686*       jr nc,$+6
0408EB 1C          0687*       inc e
0408EC 1C          0688*       inc e
0408ED 2F          0689*       cpl
0408EE 4F          0690*       ld c,a
0408EF             0691*   ; Iteration 4
0408EF 29          0692*       add hl,hl
0408F0 CB 11       0693*       rl c
0408F2 29          0694*       add hl,hl
0408F3 CB 11       0695*       rl c
0408F5 CB 13       0696*       rl e
0408F7 7B          0697*       ld a,e
0408F8 91          0698*       sub c
0408F9 30 04       0699*       jr nc,$+6
0408FB 1C          0700*       inc e
0408FC 1C          0701*       inc e
0408FD 2F          0702*       cpl
0408FE 4F          0703*       ld c,a
0408FF             0704*   ; Iteration 5
0408FF 29          0705*       add hl,hl
040900 CB 11       0706*       rl c
040902 29          0707*       add hl,hl
040903 CB 11       0708*       rl c
040905 CB 13       0709*       rl e
040907 7B          0710*       ld a,e
040908 91          0711*       sub c
040909 30 04       0712*       jr nc,$+6
04090B 1C          0713*       inc e
04090C 1C          0714*       inc e
04090D 2F          0715*       cpl
04090E 4F          0716*       ld c,a
04090F             0717*   ; Iteration 6
04090F 29          0718*       add hl,hl
040910 CB 11       0719*       rl c
040912 29          0720*       add hl,hl
040913 CB 11       0721*       rl c
040915 CB 13       0722*       rl e
040917 7B          0723*       ld a,e
040918 91          0724*       sub c
040919 30 04       0725*       jr nc,$+6
04091B 1C          0726*       inc e
04091C 1C          0727*       inc e
04091D 2F          0728*       cpl
04091E 4F          0729*       ld c,a
04091F             0730*   ; Iteration 7
04091F 29          0731*       add hl,hl
040920 CB 11       0732*       rl c
040922 29          0733*       add hl,hl
040923 CB 11       0734*       rl c
040925 CB 10       0735*       rl b
040927 EB          0736*       ex de,hl
040928 29          0737*       add hl,hl
040929 E5          0738*       push hl
04092A ED 42       0739*       sbc hl,bc
04092C 30 06       0740*       jr nc,$+8
04092E 7C          0741*       ld a,h
04092F 2F          0742*       cpl
040930 47          0743*       ld b,a
040931 7D          0744*       ld a,l
040932 2F          0745*       cpl
040933 4F          0746*       ld c,a
040934 E1          0747*       pop hl
040935 30 02       0748*       jr nc,$+4
040937 23          0749*       inc hl
040938 23          0750*       inc hl
040939 EB          0751*       ex de,hl
04093A             0752*   ; Iteration 8
04093A 29          0753*       add hl,hl
04093B 69          0754*       ld l,c
04093C 60          0755*       ld h,b
04093D ED 6A       0756*       adc hl,hl
04093F ED 6A       0757*       adc hl,hl
040941 EB          0758*       ex de,hl
040942 29          0759*       add hl,hl
040943 ED 52       0760*       sbc hl,de
040945 19          0761*       add hl,de
040946 EB          0762*       ex de,hl
040947 30 04       0763*       jr nc,$+6
040949 ED 52       0764*       sbc hl,de
04094B 13          0765*       inc de
04094C 13          0766*       inc de
04094D             0767*   ; Iteration 9
04094D F1          0768*       pop af
04094E 17          0769*       rla
04094F ED 6A       0770*       adc hl,hl
040951 17          0771*       rla
040952 ED 6A       0772*       adc hl,hl
040954 EB          0773*       ex de,hl
040955 29          0774*       add hl,hl
040956 ED 52       0775*       sbc hl,de
040958 19          0776*       add hl,de
040959 EB          0777*       ex de,hl
04095A 30 04       0778*       jr nc,$+6
04095C ED 52       0779*       sbc hl,de
04095E 13          0780*       inc de
04095F 13          0781*       inc de
040960             0782*   ; Iteration 10
040960 17          0783*       rla
040961 ED 6A       0784*       adc hl,hl
040963 17          0785*       rla
040964 ED 6A       0786*       adc hl,hl
040966 EB          0787*       ex de,hl
040967 29          0788*       add hl,hl
040968 ED 52       0789*       sbc hl,de
04096A 19          0790*       add hl,de
04096B EB          0791*       ex de,hl
04096C 30 04       0792*       jr nc,$+6
04096E ED 52       0793*       sbc hl,de
040970 13          0794*       inc de
040971 13          0795*       inc de
040972             0796*   ; Iteration 11
040972 17          0797*       rla
040973 ED 6A       0798*       adc hl,hl
040975 17          0799*       rla
040976 ED 6A       0800*       adc hl,hl
040978 EB          0801*       ex de,hl
040979 29          0802*       add hl,hl
04097A ED 52       0803*       sbc hl,de
04097C 19          0804*       add hl,de
04097D EB          0805*       ex de,hl
04097E 30 04       0806*       jr nc,$+6
040980 ED 52       0807*       sbc hl,de
040982 13          0808*       inc de
040983 13          0809*       inc de
040984             0810*   ; Iteration 12
040984 17          0811*       rla
040985 ED 6A       0812*       adc hl,hl
040987 17          0813*       rla
040988 ED 6A       0814*       adc hl,hl
04098A EB          0815*       ex de,hl
04098B 29          0816*       add hl,hl
04098C ED 52       0817*       sbc hl,de
04098E 19          0818*       add hl,de
04098F EB          0819*       ex de,hl
040990 30 04       0820*       jr nc,$+6
040992 ED 52       0821*       sbc hl,de
040994 13          0822*       inc de
040995 13          0823*       inc de
040996 CB 1A       0824*       rr d
040998 CB 1B       0825*       rr e
04099A C9          0826*       ret
04099B             0827*   
04099B             0828*   sin_lut_168:
04099B 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
04099E 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
0409A1 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
0409A4 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
0409A7 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
0409AA 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
0409AD 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
0409B0 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
0409B3 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
0409B6 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
0409B9 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
0409BC 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
0409BF 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
0409C2 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
0409C5 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
0409C8 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
0409CB 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
0409CE 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
0409D1 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
0409D4 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
0409D7 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
0409DA 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
0409DD 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
0409E0 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
0409E3 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
0409E6 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
0409E9 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
0409EC 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
0409EF A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
0409F2 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
0409F5 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
0409F8 B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
0409FB B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
0409FE B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040A01 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040A04 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040A07 C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040A0A C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040A0D CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040A10 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040A13 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040A16 D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040A19 DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040A1C DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040A1F E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040A22 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040A25 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040A28 EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040A2B EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040A2E EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040A31 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040A34 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040A37 F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040A3A F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040A3D F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040A40 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040A43 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040A46 FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040A49 FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040A4C FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040A4F FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040A52 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040A55 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040A58 FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040A5B 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040A5E FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040A61 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040A64 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040A67 FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040A6A FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040A6D FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040A70 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040A73 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040A76 F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040A79 F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040A7C F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040A7F F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040A82 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040A85 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040A88 EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040A8B EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040A8E EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040A91 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040A94 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040A97 E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040A9A DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040A9D DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040AA0 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040AA3 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040AA6 D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040AA9 CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040AAC C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040AAF C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040AB2 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040AB5 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040AB8 B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040ABB B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040ABE B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040AC1 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040AC4 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040AC7 A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040ACA 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040ACD 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040AD0 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040AD3 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040AD6 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040AD9 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040ADC 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040ADF 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040AE2 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040AE5 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040AE8 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040AEB 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040AEE 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040AF1 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040AF4 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040AF7 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040AFA 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040AFD 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040B00 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040B03 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040B06 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040B09 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040B0C 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040B0F 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040B12 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040B15 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040B18 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040B1B 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040B1E FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040B21 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040B24 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040B27 E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040B2A E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040B2D DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040B30 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040B33 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040B36 C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040B39 C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040B3C BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040B3F B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040B42 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040B45 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040B48 A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040B4B 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040B4E 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040B51 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040B54 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040B57 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040B5A 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040B5D 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040B60 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040B63 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040B66 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040B69 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040B6C 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040B6F 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040B72 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040B75 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040B78 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040B7B 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040B7E 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040B81 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040B84 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040B87 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040B8A 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040B8D 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040B90 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040B93 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040B96 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040B99 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040B9C 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040B9F 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040BA2 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040BA5 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040BA8 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040BAB 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040BAE 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040BB1 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040BB4 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040BB7 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040BBA 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040BBD 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040BC0 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040BC3 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040BC6 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040BC9 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040BCC 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040BCF 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040BD2 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040BD5 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040BD8 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040BDB 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040BDE 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040BE1 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040BE4 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040BE7 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040BEA 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040BED 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040BF0 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040BF3 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040BF6 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040BF9 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040BFC 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040BFF 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C02 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C05 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C08 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C0B 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C0E 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C11 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C14 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C17 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040C1A 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040C1D 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040C20 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040C23 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040C26 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040C29 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040C2C 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040C2F 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040C32 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040C35 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040C38 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040C3B 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040C3E 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040C41 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040C44 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040C47 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040C4A 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040C4D 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040C50 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040C53 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040C56 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040C59 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040C5C 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040C5F 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040C62 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040C65 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040C68 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040C6B 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040C6E A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040C71 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040C74 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040C77 B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040C7A BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040C7D C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040C80 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040C83 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040C86 D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040C89 DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040C8C E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040C8F E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040C92 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040C95 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040C98 FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040C9B 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040C9E             1086*   
040C9E             1087*   atan_lut_168:
040C9E 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040CA1 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040CA4 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040CA7 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040CAA A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040CAD CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040CB0 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040CB3 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040CB6 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040CB9 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040CBC 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040CBF BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040CC2 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040CC5 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040CC8 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040CCB 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040CCE 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040CD1 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040CD4 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040CD7 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040CDA 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040CDD 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040CE0 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040CE3 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040CE6 CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040CE9 F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040CEC 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040CEF 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040CF2 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040CF5 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040CF8 C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040CFB E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040CFE 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040D01 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040D04 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040D07 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040D0A B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040D0D D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040D10 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040D13 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040D16 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040D19 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040D1C A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040D1F C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040D22 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040D25 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040D28 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040D2B 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040D2E 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040D31 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040D34 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040D37 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040D3A 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040D3D 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040D40 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040D43 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040D46 C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040D49 ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040D4C 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040D4F 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040D52 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040D55 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040D58 AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040D5B D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040D5E FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040D61 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040D64 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040D67 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040D6A 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040D6D BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040D70 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040D73 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040D76 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040D79 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040D7C 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040D7F 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040D82 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040D85 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040D88 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040D8B 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040D8E 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040D91 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040D94 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040D97 C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040D9A EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040D9D 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040DA0 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040DA3 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040DA6 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040DA9 A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040DAC C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040DAF EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040DB2 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040DB5 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040DB8 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040DBB 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040DBE 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040DC1 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040DC4 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040DC7 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040DCA 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040DCD 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040DD0 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040DD3 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040DD6 B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040DD9 DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040DDC FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040DDF 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040DE2 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040DE5 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040DE8 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040DEB AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040DEE CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040DF1 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040DF4 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040DF7 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040DFA 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040DFD 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040E00 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040E03 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040E06 DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040E09 FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040E0C 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040E0F 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040E12 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040E15 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040E18 A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040E1B C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040E1E E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040E21 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040E24 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040E27 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040E2A 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040E2D 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040E30 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040E33 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040E36 E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040E39 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040E3C 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040E3F 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040E42 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040E45 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040E48 A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040E4B C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040E4E E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040E51 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040E54 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040E57 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040E5A 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040E5D 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040E60 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040E63 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040E66 D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040E69 F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040E6C 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040E6F 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040E72 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040E75 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040E78 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040E7B A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040E7E C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040E81 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040E84 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040E87 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040E8A 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040E8D 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040E90 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040E93 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040E96 A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040E99 C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040E9C E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040E9F FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040EA2 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040EA5 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040EA8 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040EAB 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040EAE 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040EB1 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040EB4 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040EB7 DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040EBA F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040EBD 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040EC0 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040EC3 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040EC6 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040EC9 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040ECC 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040ECF B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040ED2 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040ED5 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040ED8 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040EDB 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040EDE 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040EE1 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040EE4 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040EE7 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040EEA 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040EED B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040EF0 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040EF3 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040EF6 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040EF9 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040EFC 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040EFF 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040F02 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040F05 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040F08 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040F0B B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040F0E CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040F11 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040F14 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040F17 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040F1A 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040F1D 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040F20 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040F23 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040F26 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040F29 A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040F2C BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040F2F D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040F32 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040F35 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040F38 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040F3B 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040F3E 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
040F41 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
040F44 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
040F47 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
040F4A A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
040F4D BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
040F50 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
040F53 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
040F56 FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
040F59 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
040F5C 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
040F5F 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
040F62 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
040F65 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
040F68 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
040F6B 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
040F6E AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
040F71 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
040F74 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
040F77 F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
040F7A 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
040F7D 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
040F80 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
040F83 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
040F86 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
040F89 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
040F8C 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
040F8F 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
040F92 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
040F95 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
040F98 D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
040F9B EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
040F9E 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
040FA1             0036        include "fonts.inc"
040FA1             0001*   fonts_load:
040FA1 DD 21 D2 0F 0002*       ld ix,font_list ; pointer to font list lookup
       04          
040FA6 06 0D       0003*       ld b,num_fonts ; loop counter
040FA8             0004*   
040FA8             0005*   @load_loop:
040FA8 C5          0006*       push bc ; save loop counter
040FA9             0007*   
040FA9             0008*   ; load font into a buffer
040FA9 DD 27 06    0009*       ld hl,(ix+font_list_bufferId)
040FAC DD 31 09    0010*       ld iy,(ix+font_list_filename)
040FAF CD 11 16 04 0011*       call vdu_load_buffer_from_file
040FB3             0012*   
040FB3             0013*   ; create font from buffer
040FB3 DD 27 06    0014*       ld hl,(ix+font_list_bufferId)
040FB6 DD 5E 00    0015*       ld e,(ix+font_list_width)
040FB9 DD 56 03    0016*       ld d,(ix+font_list_height)
040FBC 3E 00       0017*       ld a,0 ; flags
040FBE CD 94 17 04 0018*       call vdu_font_create
040FC2             0019*   
040FC2             0020*   ; select font
040FC2 DD 27 06    0021*       ld hl,(ix+font_list_bufferId)
040FC5 3E 01       0022*       ld a,1 ; flags
040FC7 CD 7A 17 04 0023*       call vdu_font_select
040FCB             0024*   
040FCB             0025*   ; ; debug print filename
040FCB             0026*   ;     call printNewLine
040FCB             0027*   ;     ld hl,(ix+font_list_filename)
040FCB             0028*   ;     call printString
040FCB             0029*   
040FCB             0030*   ; advance font_list pointer to next record
040FCB ED 32 0C    0031*       lea ix,ix+font_list_record_size
040FCE             0032*   
040FCE             0033*   ; restore loop counter
040FCE C1          0034*       pop bc
040FCF 10 D7       0035*       djnz @load_loop
040FD1             0036*   
040FD1             0037*   ; all done
040FD1 C9          0038*       ret
040FD2             0037        include "fonts_list.inc"
040FD2             0001*   ; Generated by asm_config_editor.py
040FD2             0002*   font_list_record_size: equ 12
040FD2             0003*   font_list_width: equ 0
040FD2             0004*   font_list_height: equ 3
040FD2             0005*   font_list_bufferId: equ 6
040FD2             0006*   font_list_filename: equ 9
040FD2             0007*   
040FD2             0008*   num_fonts: equ 13
040FD2             0009*   
040FD2             0010*   ; Index list:
040FD2             0011*   amiga_forever_8x8: equ 64000
040FD2             0012*   computer_pixel_7_8x12: equ 64001
040FD2             0013*   computer_pixel_7_8x16: equ 64002
040FD2             0014*   dopecre_8x8: equ 64003
040FD2             0015*   gamer_2_8x8: equ 64004
040FD2             0016*   Lat15_VGA8_8x8: equ 64005
040FD2             0017*   Lat2_VGA8_8x8: equ 64006
040FD2             0018*   Lat38_VGA8_8x8: equ 64007
040FD2             0019*   Lat7_VGA8_8x8: equ 64008
040FD2             0020*   planetary_contact_8x8: equ 64009
040FD2             0021*   Squarewave_Bold_8x12: equ 64010
040FD2             0022*   super_mario_bros_2_8x8: equ 64011
040FD2             0023*   wendy_neue_6x6: equ 64012
040FD2             0024*   
040FD2             0025*   font_list: ; width; height; bufferId; filename;:
040FD2 08 00 00 08 0026*   	dl 8, 8, 64000, fn_amiga_forever_8x8
       00 00 00 FA 
       00 6E 10 04 
040FDE 08 00 00 0C 0027*   	dl 8, 12, 64001, fn_computer_pixel_7_8x12
       00 00 01 FA 
       00 90 10 04 
040FEA 08 00 00 10 0028*   	dl 8, 16, 64002, fn_computer_pixel_7_8x16
       00 00 02 FA 
       00 B6 10 04 
040FF6 08 00 00 08 0029*   	dl 8, 8, 64003, fn_dopecre_8x8
       00 00 03 FA 
       00 DC 10 04 
041002 08 00 00 08 0030*   	dl 8, 8, 64004, fn_gamer_2_8x8
       00 00 04 FA 
       00 F8 10 04 
04100E 08 00 00 08 0031*   	dl 8, 8, 64005, fn_Lat15_VGA8_8x8
       00 00 05 FA 
       00 14 11 04 
04101A 08 00 00 08 0032*   	dl 8, 8, 64006, fn_Lat2_VGA8_8x8
       00 00 06 FA 
       00 33 11 04 
041026 08 00 00 08 0033*   	dl 8, 8, 64007, fn_Lat38_VGA8_8x8
       00 00 07 FA 
       00 51 11 04 
041032 08 00 00 08 0034*   	dl 8, 8, 64008, fn_Lat7_VGA8_8x8
       00 00 08 FA 
       00 70 11 04 
04103E 08 00 00 08 0035*   	dl 8, 8, 64009, fn_planetary_contact_8x8
       00 00 09 FA 
       00 8E 11 04 
04104A 08 00 00 0C 0036*   	dl 8, 12, 64010, fn_Squarewave_Bold_8x12
       00 00 0A FA 
       00 B4 11 04 
041056 08 00 00 08 0037*   	dl 8, 8, 64011, fn_super_mario_bros_2_8x8
       00 00 0B FA 
       00 D9 11 04 
041062 06 00 00 06 0038*   	dl 6, 6, 64012, fn_wendy_neue_6x6
       00 00 0C FA 
       00 00 12 04 
04106E             0039*   
04106E             0040*   ; files_list: ; filename:
04106E 2F 6D 6F 73 0041*   fn_amiga_forever_8x8: db "/mos/fonts/amiga_forever_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 61 
       6D 69 67 61 
       5F 66 6F 72 
       65 76 65 72 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
041090 2F 6D 6F 73 0042*   fn_computer_pixel_7_8x12: db "/mos/fonts/computer_pixel_7_8x12.font",0
       2F 66 6F 6E 
       74 73 2F 63 
       6F 6D 70 75 
       74 65 72 5F 
       70 69 78 65 
       6C 5F 37 5F 
       38 78 31 32 
       2E 66 6F 6E 
       74 00       
0410B6 2F 6D 6F 73 0043*   fn_computer_pixel_7_8x16: db "/mos/fonts/computer_pixel_7_8x16.font",0
       2F 66 6F 6E 
       74 73 2F 63 
       6F 6D 70 75 
       74 65 72 5F 
       70 69 78 65 
       6C 5F 37 5F 
       38 78 31 36 
       2E 66 6F 6E 
       74 00       
0410DC 2F 6D 6F 73 0044*   fn_dopecre_8x8: db "/mos/fonts/dopecre_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 64 
       6F 70 65 63 
       72 65 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
0410F8 2F 6D 6F 73 0045*   fn_gamer_2_8x8: db "/mos/fonts/gamer_2_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 67 
       61 6D 65 72 
       5F 32 5F 38 
       78 38 2E 66 
       6F 6E 74 00 
041114 2F 6D 6F 73 0046*   fn_Lat15_VGA8_8x8: db "/mos/fonts/Lat15-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 31 35 
       2D 56 47 41 
       38 5F 38 78 
       38 2E 66 6F 
       6E 74 00    
041133 2F 6D 6F 73 0047*   fn_Lat2_VGA8_8x8: db "/mos/fonts/Lat2-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 32 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
041151 2F 6D 6F 73 0048*   fn_Lat38_VGA8_8x8: db "/mos/fonts/Lat38-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 33 38 
       2D 56 47 41 
       38 5F 38 78 
       38 2E 66 6F 
       6E 74 00    
041170 2F 6D 6F 73 0049*   fn_Lat7_VGA8_8x8: db "/mos/fonts/Lat7-VGA8_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 4C 
       61 74 37 2D 
       56 47 41 38 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
04118E 2F 6D 6F 73 0050*   fn_planetary_contact_8x8: db "/mos/fonts/planetary_contact_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 70 
       6C 61 6E 65 
       74 61 72 79 
       5F 63 6F 6E 
       74 61 63 74 
       5F 38 78 38 
       2E 66 6F 6E 
       74 00       
0411B4 2F 6D 6F 73 0051*   fn_Squarewave_Bold_8x12: db "/mos/fonts/Squarewave_Bold_8x12.font",0
       2F 66 6F 6E 
       74 73 2F 53 
       71 75 61 72 
       65 77 61 76 
       65 5F 42 6F 
       6C 64 5F 38 
       78 31 32 2E 
       66 6F 6E 74 
       00          
0411D9 2F 6D 6F 73 0052*   fn_super_mario_bros_2_8x8: db "/mos/fonts/super_mario_bros_2_8x8.font",0
       2F 66 6F 6E 
       74 73 2F 73 
       75 70 65 72 
       5F 6D 61 72 
       69 6F 5F 62 
       72 6F 73 5F 
       32 5F 38 78 
       38 2E 66 6F 
       6E 74 00    
041200 2F 6D 6F 73 0053*   fn_wendy_neue_6x6: db "/mos/fonts/wendy_neue_6x6.font",0
       2F 66 6F 6E 
       74 73 2F 77 
       65 6E 64 79 
       5F 6E 65 75 
       65 5F 36 78 
       36 2E 66 6F 
       6E 74 00    
04121F             0038        include "timer.inc"
04121F             0001*   ; Table 32. Timer Control Registers
04121F             0002*   ; this constant is the base address of the timer control registers
04121F             0003*   ; each timer takes three bytes:
04121F             0004*   ;   0: control register
04121F             0005*   ;   1: low byte of timer reset value
04121F             0006*   ;   2: high byte of timer reset value
04121F             0007*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
04121F             0008*   ; which correctly force the high and upper bytes of the address bus to zero
04121F             0009*   TMR_CTL:     equ 80h
04121F             0010*   
04121F             0011*   ; Timer Control Register Bit Definitions
04121F             0012*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
04121F             0013*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
04121F             0014*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
04121F             0015*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
04121F             0016*                               ; the TMRx_CTL register is read.
04121F             0017*   
04121F             0018*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
04121F             0019*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
04121F             0020*   
04121F             0021*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
04121F             0022*                               ;  0,and counting stops when the end-of-count value is reached.
04121F             0023*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
04121F             0024*                               ; written to the counter when the end-of-count value is reached.
04121F             0025*   
04121F             0026*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
04121F             0027*   CLK_DIV_256:  equ %00001100 ;
04121F             0028*   CLK_DIV_64:   equ %00001000 ;
04121F             0029*   CLK_DIV_16:   equ %00000100 ;
04121F             0030*   CLK_DIV_4:    equ %00000000 ;
04121F             0031*   
04121F             0032*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
04121F             0033*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
04121F             0034*                               ; When a 1 is written to this bit,the values in the reload registers
04121F             0035*                               ;  are loaded into the downcounter when the timer restarts. The
04121F             0036*                               ; programmer must ensure that this bit is set to 1 each time
04121F             0037*                               ; SINGLE-PASS mode is used.
04121F             0038*   
04121F             0039*   ; disable/enable the programmable reload timer
04121F             0040*   PRT_EN_0:     equ %00000000 ;
04121F             0041*   PRT_EN_1:     equ %00000001 ;
04121F             0042*   
04121F             0043*   ; Table 37. Timer Input Source Select Register
04121F             0044*   ; Each of the 4 timers are allocated two bits of the 8-bit register
04121F             0045*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
04121F             0046*   ;   00: System clock / CLK_DIV
04121F             0047*   ;   01: RTC / CLK_DIV
04121F             0048*   ;   NOTE: these are the values given in the manual,but it may be a typo
04121F             0049*   ;   10: GPIO port B pin 1.
04121F             0050*   ;   11: GPIO port B pin 1.
04121F             0051*   TMR_ISS:   equ 92h ; register address
04121F             0052*   
04121F             0053*   ; Table 51. Real-Time Clock Control Register
04121F             0054*   RTC_CTRL: equ EDh ; register address
04121F             0055*   
04121F             0056*   ; alarm interrupt disable/enable
04121F             0057*   RTC_ALARM_0:    equ %00000000
04121F             0058*   RTC_ALARM_1:    equ %10000000
04121F             0059*   
04121F             0060*   ; interrupt on alarm disable/enable
04121F             0061*   RTC_INT_ENT_0:  equ %00000000
04121F             0062*   RTC_INT_ENT_1:  equ %01000000
04121F             0063*   
04121F             0064*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
04121F             0065*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
04121F             0066*   
04121F             0067*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
04121F             0068*                                   ; On-chip 32768 Hz oscillator is enabled.
04121F             0069*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
04121F             0070*                                   ; On-chip 32768 Hz oscillator is disabled.
04121F             0071*   
04121F             0072*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
04121F             0073*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
04121F             0074*   
04121F             0075*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
04121F             0076*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
04121F             0077*   
04121F             0078*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
04121F             0079*                                   ; RTC counter is enabled.
04121F             0080*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
04121F             0081*                                   ; RTC counter is disabled.
04121F             0082*   
04121F             0083*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
04121F             0084*   
04121F             0085*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
04121F             0086*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
04121F 00 00 00    0087*   prt_reload: dl 0x000000
041222             0088*   
041222             0089*   ; set PRT timer
041222             0090*   prt_set:
041222 21 00 00 00 0091*       ld hl,0
041226 22 70 12 04 0092*       ld (prt_irq_counter),hl
04122A 2A 1F 12 04 0093*       ld hl,(prt_reload)
04122E ED 29 84    0094*       out0 ($84),l
041231 ED 21 85    0095*   	out0 ($85),h
041234             0096*   ; disable timer
041234 3E 06       0097*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041236 ED 39 83    0098*   	out0 ($83),a
041239             0099*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041239 3E 57       0100*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04123B ED 39 83    0101*   	out0 ($83),a
04123E C9          0102*       ret
04123F             0103*   
04123F             0104*   ; ===============================================
04123F             0105*   ; PRT Timer Interrupt Handling
04123F             0106*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
04123F             0107*   ; -----------------------------------------------
04123F             0108*   prt_irq_init:
04123F             0109*       ; set up interrupt vector table 2
04123F 21 00 00 00 0110*   	ld hl,0
041243 3A 0C 01 00 0111*   	ld a,($10c)
041247 6F          0112*   	ld l,a
041248 3A 0D 01 00 0113*   	ld a,($10d)
04124C 67          0114*   	ld h,a
04124D             0115*   
04124D             0116*   	; skip over CALL ($c3)
04124D 23          0117*   	inc hl
04124E             0118*   	; load address of jump into vector table 2 (in ram)
04124E ED 27       0119*   	ld hl,(hl)
041250             0120*   
041250             0121*   	; write CALL prt_irq_handler to vector table 2
041250 3E C3       0122*   	ld a,$c3
041252 77          0123*   	ld (hl),a
041253 23          0124*   	inc hl
041254 11 5B 12 04 0125*   	ld de,prt_irq_handler
041258 ED 1F       0126*   	ld (hl),de
04125A             0127*   
04125A C9          0128*       ret
04125B             0129*   
04125B             0130*   prt_irq_handler:
04125B F3          0131*   	di
04125C F5          0132*   	push af
04125D E5          0133*       push hl
04125E ED 38 83    0134*   	in0 a,($83)
041261 2A 70 12 04 0135*   	ld hl,(prt_irq_counter)
041265 23          0136*   	inc hl
041266 22 70 12 04 0137*   	ld (prt_irq_counter),hl
04126A E1          0138*       pop hl
04126B F1          0139*   	pop af
04126C FB          0140*   	ei
04126D 5B ED 4D    0141*   	reti.l
041270             0142*   
041270             0143*   prt_irq_counter:
041270 00 00 00    0144*   	.dl 0
041273             0145*   prt_irq_counter_saved:
041273 00 00 00    0146*       .dl 0
041276             0147*   
041276             0148*   prt_loop_reset:
041276 E5          0149*       push hl
041277 21 00 00 00 0150*   	ld hl,0
04127B 22 70 12 04 0151*   	ld (prt_irq_counter),hl
04127F 22 E1 12 04 0152*       ld (prt_loop_counter),hl
041283 22 E4 12 04 0153*       ld (prt_loops),hl
041287 CD 22 12 04 0154*       call prt_set
04128B E1          0155*       pop hl
04128C C9          0156*       ret
04128D             0157*   
04128D             0158*   prt_loop_start:
04128D E5          0159*       push hl
04128E 21 00 00 00 0160*   	ld hl,0
041292 22 70 12 04 0161*   	ld (prt_irq_counter),hl
041296 E1          0162*       pop hl
041297 C9          0163*       ret
041298             0164*   
041298             0165*   prt_loop_stop:
041298 E5          0166*       push hl
041299 D5          0167*       push de
04129A 2A 70 12 04 0168*       ld hl,(prt_irq_counter)
04129E ED 5B E1 12 0169*       ld de,(prt_loop_counter)
       04          
0412A3 19          0170*       add hl,de
0412A4 22 E1 12 04 0171*       ld (prt_loop_counter),hl
0412A8 21 00 00 00 0172*       ld hl,0
0412AC 22 70 12 04 0173*       ld (prt_irq_counter),hl
0412B0 2A E4 12 04 0174*       ld hl,(prt_loops)
0412B4 23          0175*       inc hl
0412B5 22 E4 12 04 0176*       ld (prt_loops),hl
0412B9 D1          0177*       pop de
0412BA E1          0178*       pop hl
0412BB C9          0179*       ret
0412BC             0180*   
0412BC             0181*   ; inputs: bc = y,x text coordinates to print
0412BC             0182*   prt_loop_print:
0412BC F5          0183*       push af
0412BD E5          0184*       push hl
0412BE C5          0185*       push bc
0412BF D5          0186*       push de
0412C0 DD E5       0187*       push ix
0412C2 FD E5       0188*       push iy
0412C4 CD C8 13 04 0189*       call vdu_move_cursor
0412C8             0190*   
0412C8 2A E1 12 04 0191*       ld hl,(prt_loop_counter)
0412CC CD C8 00 04 0192*       call printDec
0412D0             0193*   
0412D0 2A E4 12 04 0194*       ld hl,(prt_loops)
0412D4 CD C8 00 04 0195*       call printDec
0412D8             0196*   
0412D8 FD E1       0197*       pop iy
0412DA DD E1       0198*       pop ix
0412DC D1          0199*       pop de
0412DD C1          0200*       pop bc
0412DE E1          0201*       pop hl
0412DF F1          0202*       pop af
0412E0 C9          0203*       ret
0412E1             0204*   
0412E1             0205*   prt_loop_counter:
0412E1 00 00 00    0206*       .dl 0
0412E4             0207*   prt_loops:
0412E4 00 00 00    0208*       .dl 0
0412E7             0209*   
0412E7             0210*   ; ===============================================
0412E7             0211*   ; Timer functions
0412E7             0212*   ; -----------------------------------------------
0412E7             0213*   ; set a countdown timer
0412E7             0214*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412E7             0215*   ; returns: hl = current time
0412E7             0216*   tmr_set:
0412E7 FD 2F 03    0217*       ld (iy+3),hl            ; set time remaining
0412EA             0218*       MOSCALL mos_sysvars     ; ix points to syvars table
0412EA 3E 08       0001*M1 			LD	A, function
0412EC 5B CF       0002*M1 			RST.LIL	08h
0412EE DD 27 00    0219*       ld hl,(ix+sysvar_time)  ; get current time
0412F1 FD 2F 00    0220*       ld (iy+0),hl            ; set start time
0412F4 C9          0221*       ret
0412F5             0222*   
0412F5             0223*   ; gets time remaining on a countdown timer
0412F5             0224*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412F5             0225*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412F5             0226*   ;          sign flags: pos = time not expired,zero or neg = time expired
0412F5             0227*   tmr_get:
0412F5             0228*       MOSCALL mos_sysvars     ; ix points to syvars table
0412F5 3E 08       0001*M1 			LD	A, function
0412F7 5B CF       0002*M1 			RST.LIL	08h
0412F9 DD 17 00    0229*       ld de,(ix+sysvar_time)  ; get current time
0412FC FD 27 00    0230*       ld hl,(iy+0)            ; get start time
0412FF AF          0231*       xor a                   ; clear carry
041300 ED 52       0232*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041302 FD 17 03    0233*       ld de,(iy+3)            ; get timer set value
041305 AF          0234*       xor a                   ; clear carry
041306 ED 5A       0235*       adc hl,de               ; hl = time remaining
041308             0236*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041308 C9          0237*       ret
041309             0238*   
041309             0239*   tmr_test: ds 6 ; example of a buffer to hold timer data
04130F             0240*   
       FF FF FF FF 
       FF FF 
04130F 00 00 00    0241*   timestamp_now: dl 0
041312 00 00 00    0242*   timestamp_old: dl 0
041315 00 00 00    0243*   timestamp_chg: dl 0
041318             0244*   
041318             0245*   ; update the global timestamp from the system clock
041318             0246*   ; inputs: none
041318             0247*   ; returns: hl = time elapsed in 1/120ths of a second
041318             0248*   ;          ix = pointer to syvars table
041318             0249*   ; destroys: af,hl,de,ix
041318             0250*   timestamp_tick:
041318 ED 5B 0F 13 0251*       ld de,(timestamp_now)   ; get previous time
       04          
04131D ED 53 12 13 0252*       ld (timestamp_old),de   ; save previous time
       04          
041322             0253*       MOSCALL mos_sysvars     ; ix points to syvars table
041322 3E 08       0001*M1 			LD	A, function
041324 5B CF       0002*M1 			RST.LIL	08h
041326 DD 27 00    0254*       ld hl,(ix+sysvar_time)  ; get current time
041329 22 0F 13 04 0255*       ld (timestamp_now),hl   ; save current time
04132D AF          0256*       xor a                   ; clear carry
04132E ED 52       0257*       sbc hl,de               ; hl = time elapsed
041330 22 15 13 04 0258*       ld (timestamp_chg),hl   ; save elapsed time
041334 C9          0259*       ret
041335             0260*   
041335             0261*   ; set a countdown timer
041335             0262*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041335             0263*   ; requires: timestamp_tick to be called at least once before this function
041335             0264*   ; returns: hl = current time
041335             0265*   ; destroys: hl
041335             0266*   timestamp_tmr_set:
041335 FD 2F 03    0267*       ld (iy+3),hl            ; set time remaining
041338 2A 0F 13 04 0268*       ld hl,(timestamp_now)   ; get current timestamp
04133C FD 2F 00    0269*       ld (iy+0),hl            ; set start time
04133F C9          0270*       ret
041340             0271*   
041340             0272*   ; gets time remaining on a countdown timer following the global timestamp
041340             0273*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041340             0274*   ; requires: timestamp_tick to be called at least once before this function
041340             0275*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041340             0276*   ;          sign flags: pos = time not expired,zero or neg = time expired
041340             0277*   ; destroys: af,hl,de
041340             0278*   timestamp_tmr_get:
041340 ED 5B 0F 13 0279*       ld de,(timestamp_now)   ; get current timestamp
       04          
041345 FD 27 00    0280*       ld hl,(iy+0)            ; get start time
041348 AF          0281*       xor a                   ; clear carry
041349 ED 52       0282*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04134B FD 17 03    0283*       ld de,(iy+3)            ; get timer set value
04134E AF          0284*       xor a                   ; clear carry
04134F ED 5A       0285*       adc hl,de               ; hl = time remaining
041351             0286*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041351 C9          0287*       ret
041352             0288*   
041352             0289*   ; set a stopwatch
041352             0290*   ; returns: hl = start time
041352             0291*   ; destroys: hl,ix
041352             0292*   stopwatch_set:
041352             0293*       MOSCALL mos_sysvars     ; ix points to syvars table
041352 3E 08       0001*M1 			LD	A, function
041354 5B CF       0002*M1 			RST.LIL	08h
041356 DD 27 00    0294*       ld hl,(ix+sysvar_time)  ; get current time
041359 22 6E 13 04 0295*       ld (stopwatch_started),hl            ; set start time
04135D C9          0296*       ret
04135E             0297*   
04135E             0298*   ; gets time elapsed on a stopwatch
04135E             0299*   ; returns: hl = time elapsed in 1/120ths of a second
04135E             0300*   ; destroys: af,hl,de,ix
04135E             0301*   stopwatch_get:
04135E             0302*       MOSCALL mos_sysvars     ; ix points to syvars table
04135E 3E 08       0001*M1 			LD	A, function
041360 5B CF       0002*M1 			RST.LIL	08h
041362 DD 27 00    0303*       ld hl,(ix+sysvar_time)  ; get current time
041365 ED 5B 6E 13 0304*       ld de,(stopwatch_started)            ; get start time
       04          
04136A AF          0305*       xor a                   ; clear carry
04136B ED 52       0306*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04136D C9          0307*       ret
04136E             0308*   
04136E             0309*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041371             0310*   
041371             0311*   ; ------------------
041371             0312*   ; delay routine
041371             0313*   ; Author: Richard Turrnidge
041371             0314*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041371             0315*   ; routine waits a fixed time,then returns
041371             0316*   ; arrive with A =  the delay byte. One bit to be set only.
041371             0317*   ; eg. ld A,00000100b
041371             0318*   
041371             0319*   multiPurposeDelay:
       FF FF FF 
041371 F5          0320*       push af
041372 C5          0321*       push bc
041373 DD E5       0322*       push ix
041375 47          0323*       ld b,a
041376 3E 08       0324*       ld a,$08
041378 5B CF       0325*       RST.LIL	08h                 ; get IX pointer to sysvars
04137A             0326*   
04137A             0327*   waitLoop:
04137A             0328*   
04137A DD 7E 00    0329*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04137D             0330*   
04137D             0331*                                   ;   we check if bit set is same as last time we checked.
04137D             0332*                                   ;   bit 0 - don't use
04137D             0333*                                   ;   bit 1 - changes 64 times per second
04137D             0334*                                   ;   bit 2 - changes 32 times per second
04137D             0335*                                   ;   bit 3 - changes 16 times per second
04137D             0336*   
04137D             0337*                                   ;   bit 4 - changes 8 times per second
04137D             0338*                                   ;   bit 5 - changes 4 times per second
04137D             0339*                                   ;   bit 6 - changes 2 times per second
04137D             0340*                                   ;   bit 7 - changes 1 times per second
04137D A0          0341*       and b
04137E 4F          0342*       ld c,a
04137F 3A 90 13 04 0343*       ld a,(oldTimeStamp)
041383 B9          0344*       cp c                        ; is A same as last value?
041384 28 F4       0345*       jr z,waitLoop              ; loop here if it is
041386 79          0346*       ld a,c
041387 32 90 13 04 0347*       ld (oldTimeStamp),a        ; set new value
04138B             0348*   
04138B DD E1       0349*       pop ix
04138D C1          0350*       pop bc
04138E F1          0351*       pop af
04138F C9          0352*       ret
041390             0353*   
041390 00          0354*   oldTimeStamp:   .db 00h
041391             0039        include "vdu.inc"
041391             0001*   ; VDU 30: Home cursor
041391             0002*   vdu_home_cursor:
041391 3E 1E       0003*       ld a,30
041393 5B D7       0004*   	rst.lil $10
041395 C9          0005*   	ret
041396             0006*   
041396             0007*   vdu_cursor_on:
041396 21 A1 13 04 0008*   	ld hl,@cmd
04139A 01 03 00 00 0009*   	ld bc,@end-@cmd
04139E 5B DF       0010*   	rst.lil $18
0413A0 C9          0011*   	ret
0413A1             0012*   @cmd:
0413A1 17 01 01    0013*   	db 23,1,1
0413A4             0014*   @end:
0413A4             0015*   
0413A4             0016*   vdu_cursor_off:
0413A4 21 AF 13 04 0017*   	ld hl,@cmd
0413A8 01 03 00 00 0018*   	ld bc,@end-@cmd
0413AC 5B DF       0019*   	rst.lil $18
0413AE C9          0020*   	ret
0413AF             0021*   @cmd:
0413AF 17 01 00    0022*   	db 23,1,0
0413B2             0023*   @end:
0413B2             0024*   
0413B2             0025*   ; VDU 5: Write text at graphics cursor
0413B2             0026*   ; inputs: a is the character to write to the screen
0413B2             0027*   ; prerequisites: the graphics cursor at the intended position on screen
0413B2             0028*   ; outputs: see the name of the function
0413B2             0029*   ; destroys: a, hl, bc
0413B2             0030*   vdu_char_to_gfx_cursor:
0413B2 32 C2 13 04 0031*   	ld (@arg),a
0413B6 21 C1 13 04 0032*   	ld hl,@cmd
0413BA 01 02 00 00 0033*   	ld bc,@end-@cmd
0413BE 5B DF       0034*   	rst.lil $18
0413C0 C9          0035*   	ret
0413C1 05          0036*   @cmd: db 5
0413C2 00          0037*   @arg: db 0
0413C3             0038*   @end:
0413C3             0039*   ; VDU 9: Move cursor forward one character
0413C3             0040*   vdu_cursor_forward:
0413C3 3E 09       0041*       ld a,9
0413C5 5B D7       0042*   	rst.lil $10
0413C7 C9          0043*   	ret
0413C8             0044*   
0413C8             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0413C8             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
0413C8             0047*   vdu_move_cursor:
0413C8 ED 43 D9 13 0048*       ld (@x0),bc
       04          
0413CD 21 D8 13 04 0049*   	ld hl,@cmd
0413D1 01 03 00 00 0050*   	ld bc,@end-@cmd
0413D5 5B DF       0051*   	rst.lil $18
0413D7 C9          0052*   	ret
0413D8 1F          0053*   @cmd: 	db 31
0413D9 00          0054*   @x0:	db 0
0413DA 00          0055*   @y0: 	db 0
0413DB 00          0056*   @end: 	db 0 ; padding
0413DC             0057*   
0413DC             0058*   ; VDU 12: Clear text area (CLS)
0413DC             0059*   vdu_cls:
0413DC 3E 0C       0060*       ld a,12
0413DE 5B D7       0061*   	rst.lil $10
0413E0 C9          0062*   	ret
0413E1             0063*   
0413E1             0064*   vdu_flip:
0413E1 21 EC 13 04 0065*   	ld hl,@cmd
0413E5 01 03 00 00 0066*   	ld bc,@end-@cmd
0413E9 5B DF       0067*   	rst.lil $18
0413EB C9          0068*   	ret
0413EC 17 00 C3    0069*   @cmd: db 23,0,0xC3
0413EF             0070*   @end:
0413EF             0071*   
0413EF             0072*   ; VDU 16: Clear graphics area (CLG)
0413EF             0073*   vdu_clg:
0413EF 3E 10       0074*       ld a,16
0413F1 5B D7       0075*   	rst.lil $10
0413F3 C9          0076*   	ret
0413F4             0077*   
0413F4             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0413F4             0079*   ; VDU 23, 7: Scrolling
0413F4             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0413F4             0081*   ; inputs: a, extent; l, direction; h; speed
0413F4             0082*   vdu_scroll_down:
0413F4 32 09 14 04 0083*   	ld (@extent),a
0413F8 22 0A 14 04 0084*   	ld (@dir),hl ; implicitly populates @speed
0413FC 21 07 14 04 0085*   	ld hl,@cmd
041400 01 05 00 00 0086*   	ld bc,@end-@cmd
041404 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
041406 C9          0088*   	ret
041407 17 07       0089*   @cmd:       db 23,7
041409 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
04140A 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04140B 00          0092*   @speed:     db 0x00 ; pixels
04140C 00          0093*   @end:		db 0x00 ; padding
04140D             0094*   
04140D             0095*   ; COLOUR MODES
04140D             0096*   ; Mode	Effect
04140D             0097*   ; 0	Set on-screen pixel to target colour value
04140D             0098*   ; 1	OR value with the on-screen pixel
04140D             0099*   ; 2	AND value with the on-screen pixel
04140D             0100*   ; 3	XOR value with the on-screen pixel
04140D             0101*   ; 4	Invert the on-screen pixel
04140D             0102*   ; 5	No operation
04140D             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
04140D             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
04140D             0105*   
04140D             0106*   ; VDU 17, colour: Define text colour (COLOUR)
04140D             0107*   vdu_colour_text:
04140D 32 1D 14 04 0108*   	ld (@arg),a
041411 21 1C 14 04 0109*   	ld hl,@cmd
041415 01 02 00 00 0110*   	ld bc,@end-@cmd
041419 5B DF       0111*   	rst.lil $18
04141B C9          0112*   	ret
04141C 11          0113*   @cmd: db 17
04141D 00          0114*   @arg: db 0
04141E             0115*   @end:
04141E             0116*   
04141E             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04141E             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
04141E             0119*   vdu_gcol:
04141E 32 33 14 04 0120*   	ld (@mode),a
041422 79          0121*       ld a,c
041423 32 34 14 04 0122*       ld (@col),a
041427 21 32 14 04 0123*   	ld hl,@cmd
04142B 01 03 00 00 0124*   	ld bc,@end-@cmd
04142F 5B DF       0125*   	rst.lil $18
041431 C9          0126*   	ret
041432 12          0127*   @cmd:  db 18
041433 00          0128*   @mode: db 0
041434 00          0129*   @col:  db 0
041435             0130*   @end:
041435             0131*   
041435             0132*   
041435             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
041435             0134*   ; MIND THE LITTLE-ENDIANESS
041435             0135*   ; inputs: c=left,b=bottom,e=right,d=top
041435             0136*   ; outputs; nothing
041435             0137*   ; destroys: a might make it out alive
041435             0138*   vdu_set_txt_viewport:
041435 ED 43 4B 14 0139*       ld (@lb),bc
       04          
04143A ED 53 4D 14 0140*   	ld (@rt),de
       04          
04143F 21 4A 14 04 0141*   	ld hl,@cmd
041443 01 05 00 00 0142*   	ld bc,@end-@cmd
041447 5B DF       0143*   	rst.lil $18
041449 C9          0144*   	ret
04144A 1C          0145*   @cmd:   db 28 ; set text viewport command
04144B 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
04144D 00 00       0147*   @rt: 	dw 0x0000 ; set by de
04144F 00          0148*   @end:   db 0x00	  ; padding
041450             0149*   
041450             0150*   ; Wait for VBLANK interrupt
041450             0151*   vdu_vblank:
041450 DD E5       0152*       PUSH 	IX
041452             0153*   	MOSCALL	mos_sysvars
041452 3E 08       0001*M1 			LD	A, function
041454 5B CF       0002*M1 			RST.LIL	08h
041456 DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
041459             0155*   @wait:
041459 DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
04145C 28 FB       0157*       JR	Z, @wait
04145E DD E1       0158*       POP	IX
041460 C9          0159*       RET
041461             0160*   
041461             0161*   ; VDU 29, x; y;: Set graphics origin
041461             0162*   ; This command sets the graphics origin.
041461             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
041461             0164*   ; inputs: bc=x0,de=y0
041461             0165*   ; outputs; nothing
041461             0166*   ; destroys: a might make it out alive
041461             0167*   vdu_set_gfx_origin:
041461 ED 43 77 14 0168*       ld (@x0),bc
       04          
041466 ED 53 79 14 0169*       ld (@y0),de
       04          
04146B 21 76 14 04 0170*       ld hl,@cmd
04146F 01 05 00 00 0171*       ld bc,@end-@cmd
041473 5B DF       0172*       rst.lil $18
041475 C9          0173*       ret
041476 1D          0174*   @cmd:   db 29 ; set graphics origin command
041477 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
041479 00 00       0176*   @y0: 	dw 0x0000 ; set by de
04147B 00          0177*   @end:   db 0x00	  ; padding
04147C             0178*   
04147C             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
04147C             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
04147C             0181*   ; 	because we have turned off logical screen scaling
04147C             0182*   ; NOTE: coordinates are relative to current gfx origin
04147C             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04147C             0184*   ; outputs; nothing
04147C             0185*   ; destroys: a might make it out alive
04147C             0186*   vdu_set_gfx_viewport:
04147C ED 43 9C 14 0187*       ld (@x0),bc
       04          
041481 FD 22 9E 14 0188*       ld (@y1),iy
       04          
041486 DD 22 A0 14 0189*   	ld (@x1),ix
       04          
04148B ED 53 A2 14 0190*   	ld (@y0),de
       04          
041490 21 9B 14 04 0191*   	ld hl,@cmd
041494 01 09 00 00 0192*   	ld bc,@end-@cmd
041498 5B DF       0193*   	rst.lil $18
04149A C9          0194*   	ret
04149B 18          0195*   @cmd:   db 24 ; set graphics viewport command
04149C 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
04149E 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
0414A0 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
0414A2 00 00       0199*   @y0: 	dw 0x0000 ; set by de
0414A4 00          0200*   @end:   db 0x00	  ; padding
0414A5             0201*   
0414A5             0202*   ; SCREEN MODES
0414A5             0203*   ; ===============================
0414A5             0204*   ; Mode  Horz  Vert  Cols  Refresh
0414A5             0205*   ; ---   ----  ----  ----  -------
0414A5             0206*   ; 11    320   240   2     60hz
0414A5             0207*   ; 139   320   240   2     60hz
0414A5             0208*   ; 23    512   384   2     60hz
0414A5             0209*   ; 151   512   384   2     60hz
0414A5             0210*   ; 6     640   240   2     60hz
0414A5             0211*   ; 134   640   240   2     60hz
0414A5             0212*   ; 2     640   480   2     60hz
0414A5             0213*   ; 130   640   480   2     60hz
0414A5             0214*   ; 17    800   600   2     60hz
0414A5             0215*   ; 145   800   600   2     60hz
0414A5             0216*   ; 18    1024  768   2     60hz
0414A5             0217*   ; 146   1024  768   2     60hz
0414A5             0218*   ; ---   ----  ----  ----  -------
0414A5             0219*   ; 10    320   240   4     60hz
0414A5             0220*   ; 138   320   240   4     60hz
0414A5             0221*   ; 22    512   384   4     60hz
0414A5             0222*   ; 150   512   384   4     60hz
0414A5             0223*   ; 5     640   240   4     60hz
0414A5             0224*   ; 133   640   240   4     60hz
0414A5             0225*   ; 1     640   480   4     60hz
0414A5             0226*   ; 129   640   480   4     60hz
0414A5             0227*   ; 16    800   600   4     60hz
0414A5             0228*   ; 19    1024  768   4     60hz
0414A5             0229*   ; ---   ----  ----  ----  -------
0414A5             0230*   ; 9     320   240   16    60hz
0414A5             0231*   ; 137   320   240   16    60hz
0414A5             0232*   ; 21    512   384   16    60hz
0414A5             0233*   ; 149   512   384   16    60hz
0414A5             0234*   ; 4     640   240   16    60hz
0414A5             0235*   ; 132   640   240   16    60hz
0414A5             0236*   ; 0     640   480   16    60hz
0414A5             0237*   ; 7     n/a   n/a   16    60hz
0414A5             0238*   ; ---   ----  ----  ----  -------
0414A5             0239*   ; 8     320   240   64    60hz
0414A5             0240*   ; 136   320   240   64    60hz
0414A5             0241*   ; 20    512   384   64    60hz
0414A5             0242*   ; 3     640   240   64    60hz
0414A5             0243*   ; ---   ----  ----  ----  -------
0414A5             0244*   vdu_set_screen_mode:
0414A5 32 B5 14 04 0245*   	ld (@arg),a
0414A9 21 B4 14 04 0246*   	ld hl,@cmd
0414AD 01 02 00 00 0247*   	ld bc,@end-@cmd
0414B1 5B DF       0248*   	rst.lil $18
0414B3 C9          0249*   	ret
0414B4 16          0250*   @cmd: db 22 ; set screen mode
0414B5 00          0251*   @arg: db 0  ; screen mode parameter
0414B6             0252*   @end:
0414B6             0253*   
0414B6             0254*   ; get the current screen mode
0414B6             0255*   ; inputs: none
0414B6             0256*   ; outputs: a=screen mode
0414B6             0257*   ; destroys: af, ix
0414B6             0258*   vdu_get_screen_mode:
0414B6             0259*       MOSCALL mos_sysvars
0414B6 3E 08       0001*M1 			LD	A, function
0414B8 5B CF       0002*M1 			RST.LIL	08h
0414BA DD 7E 27    0260*       ld a,(IX+sysvar_scrMode)
0414BD C9          0261*       ret
0414BE             0262*   ; end vdu_get_screen_mode
0414BE             0263*   
0414BE             0264*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0414BE             0265*   ; inputs: a is scaling mode, 1=on, 0=off
0414BE             0266*   ; note: default setting on boot is scaling ON
0414BE             0267*   vdu_set_scaling:
0414BE 32 D0 14 04 0268*   	ld (@arg),a
0414C2 21 CD 14 04 0269*   	ld hl,@cmd
0414C6 01 04 00 00 0270*   	ld bc,@end-@cmd
0414CA 5B DF       0271*   	rst.lil $18
0414CC C9          0272*   	ret
0414CD 17 00 C0    0273*   @cmd: db 23,0,0xC0
0414D0 00          0274*   @arg: db 0  ; scaling on/off
0414D1             0275*   @end:
0414D1             0276*   
0414D1             0277*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0414D1             0278*   ; inputs: hl=bufferId
0414D1             0279*   vdu_buff_select:
0414D1 22 E3 14 04 0280*   	ld (@bufferId),hl
0414D5 21 E0 14 04 0281*   	ld hl,@cmd
0414D9 01 05 00 00 0282*   	ld bc,@end-@cmd
0414DD 5B DF       0283*   	rst.lil $18
0414DF C9          0284*   	ret
0414E0 17 1B 20    0285*   @cmd: db 23,27,0x20
0414E3 00 00       0286*   @bufferId: dw 0x0000
0414E5 00          0287*   @end: db 0x00 ; padding
0414E6             0288*   
0414E6             0289*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0414E6             0290*   ; inputs: a=format; bc=width; de=height
0414E6             0291*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0414E6             0292*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0414E6             0293*   ; 0 	RGBA8888 (4-bytes per pixel)
0414E6             0294*   ; 1 	RGBA2222 (1-bytes per pixel)
0414E6             0295*   ; 2 	Mono/Mask (1-bit per pixel)
0414E6             0296*   ; 3 	Reserved for internal use by VDP (“native” format)
0414E6             0297*   vdu_bmp_create:
0414E6 ED 43 02 15 0298*       ld (@width),bc
       04          
0414EB ED 53 04 15 0299*       ld (@height),de
       04          
0414F0 32 06 15 04 0300*       ld (@fmt),a
0414F4 21 FF 14 04 0301*   	ld hl,@cmd
0414F8 01 08 00 00 0302*   	ld bc,@end-@cmd
0414FC 5B DF       0303*   	rst.lil $18
0414FE C9          0304*   	ret
0414FF 17 1B 21    0305*   @cmd:       db 23,27,0x21
041502 00 00       0306*   @width:     dw 0x0000
041504 00 00       0307*   @height:    dw 0x0000
041506 00          0308*   @fmt:       db 0x00
041507             0309*   @end:
041507             0310*   
041507             0311*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041507             0312*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041507             0313*   vdu_load_img_rgba2_to_8:
041507             0314*   ; backup the target buffer id and image dimensions
041507 E5          0315*       push hl
041508 D5          0316*       push de
041509 C5          0317*       push bc
04150A             0318*   ; load the rgba2 image to working buffer 65534
04150A 21 FE FF 00 0319*       ld hl,65534 ; temporary working buffer id
04150E CD 11 16 04 0320*   	call vdu_load_buffer_from_file
041512             0321*   ; restore the image dimensions and target buffer id
041512 C1          0322*       pop bc
041513 D1          0323*       pop de
041514 E1          0324*       pop hl
041515             0325*   ; fall through to vdu_rgba2_to_8
041515             0326*   
041515             0327*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041515             0328*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041515             0329*   ; the "expand bitmap" command is:
041515             0330*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041515             0331*   ; and then to reverse the byte order to fix endian-ness:
041515             0332*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041515             0333*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041515             0334*   ; VDU 23,27,&20,targetBufferID%;
041515             0335*   ; VDU 23,27,&21,width%;height%;0
041515             0336*   ; -------------------------------------------------------------------
041515             0337*   ; inputs: bc,de image width,height ; hl = targetBufferId
041515             0338*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041515             0339*   vdu_rgba2_to_8:
041515             0340*   ; load the image dimensions and buffer id parameters
041515 ED 43 71 15 0341*       ld (@width),bc
       04          
04151A ED 53 73 15 0342*       ld (@height),de
       04          
04151F 22 56 15 04 0343*       ld (@bufferId0),hl
041523 22 63 15 04 0344*       ld (@bufferId2),hl
041527 22 6C 15 04 0345*       ld (@bufferId1),hl
04152B             0346*   ; clean up bytes that got stomped on by the ID loads
04152B 3E 48       0347*       ld a,0x48
04152D 32 58 15 04 0348*       ld (@bufferId0+2),a
041531 3E 17       0349*       ld a,23
041533 32 6E 15 04 0350*       ld (@bufferId1+2),a
041537 3E 18       0351*       ld a,24
041539 32 65 15 04 0352*       ld (@bufferId2+2),a
04153D AF          0353*       xor a
04153E 32 75 15 04 0354*       ld (@height+2),a
041542             0355*   ; send the vdu command strings
041542 21 4D 15 04 0356*       ld hl,@beg
041546 01 29 00 00 0357*       ld bc,@end-@beg
04154A 5B DF       0358*       rst.lil $18
04154C C9          0359*       ret
04154D             0360*   @beg:
04154D             0361*   ; Command 14: Consolidate blocks in a buffer
04154D             0362*   ; VDU 23, 0, &A0, bufferId; 14
04154D 17 00 A0    0363*       db 23,0,0xA0
041550 FE FF       0364*       dw 65534 ; workingBufferId
041552 0E          0365*       db 14 ; consolidate blocks
041553             0366*   ; the "expand bitmap" command is:
041553             0367*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041553 17 00 A0    0368*       db 23,0,0xA0
041556 00 00       0369*   @bufferId0: dw 0x0000 ; targetBufferId
041558 48          0370*       db 0x48 ; given as decimal command 72 in the docs
041559 02          0371*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04155A FE FF       0372*       dw 65534 ; sourceBufferId
04155C 00 7F BF FF 0373*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041560             0374*   ; reverse the byte order to fix endian-ness:
041560             0375*   ; Command 24: Reverse the order of data of blocks within a buffer
041560             0376*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041560             0377*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041560 17 00 A0    0378*       db 23,0,0xA0
041563 00 00       0379*   @bufferId2:    dw 0x0000 ; targetBufferId
041565 18          0380*       db 24 ; reverse byte order
041566 04          0381*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041567 04 00       0382*       dw 4 ; size (4 bytes)
041569             0383*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041569             0384*   ; VDU 23,27,&20,targetBufferID%;
041569 17 1B 20    0385*       db 23,27,0x20 ; select bitmap
04156C 00 00       0386*   @bufferId1: dw 0x0000 ; targetBufferId
04156E             0387*   ; VDU 23,27,&21,width%;height%;0
04156E 17 1B 21    0388*       db 23,27,0x21 ; create bitmap from buffer
041571 00 00       0389*   @width: dw 0x0000
041573 00 00       0390*   @height: dw 0x0000
041575 00          0391*       db 0x00 ; rgba8888 format
041576             0392*   @end:
041576             0393*   
041576             0394*   ; scratch variables
041576 00 00 00    0395*   bufferId0: dl 0x000000
041579 00 00 00    0396*   bufferId1: dl 0x000000
04157C             0397*   
04157C             0398*   ; load a vdu buffer from local memory
04157C             0399*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04157C             0400*   vdu_load_buffer:
04157C ED 43 A5 15 0401*       ld (@length),bc
       04          
041581 D5          0402*       push de ; save data pointer
041582             0403*   ; send the vdu command string
041582 7D          0404*       ld a,l
041583 32 A2 15 04 0405*       ld (@bufferId),a
041587 7C          0406*       ld a,h
041588 32 A3 15 04 0407*       ld (@bufferId+1),a
04158C 21 9F 15 04 0408*       ld hl,@cmd
041590 01 08 00 00 0409*       ld bc,@end-@cmd
041594 5B DF       0410*       rst.lil $18
041596             0411*   ; send the buffer data
041596 E1          0412*       pop hl ; pointer to data
041597 ED 4B A5 15 0413*       ld bc,(@length)
       04          
04159C 5B DF       0414*       rst.lil $18 ; send it
04159E C9          0415*       ret
04159F             0416*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04159F 17 00 A0    0417*   @cmd:       db 23,0,0xA0
0415A2 00 00       0418*   @bufferId:	dw 0x0000
0415A4 00          0419*   		    db 0 ; load buffer
0415A5 00 00       0420*   @length:	dw 0x0000
0415A7 00          0421*   @end: db 0 ; padding
0415A8             0422*   
0415A8             0423*   ; clear a buffer
0415A8             0424*   ; inputs: hl = bufferId
0415A8             0425*   vdu_clear_buffer:
0415A8 7D          0426*       ld a,l
0415A9 32 C0 15 04 0427*       ld (@bufferId),a
0415AD 7C          0428*       ld a,h
0415AE 32 C1 15 04 0429*       ld (@bufferId+1),a
0415B2 21 BD 15 04 0430*       ld hl,@cmd
0415B6 01 06 00 00 0431*       ld bc,@end-@cmd
0415BA 5B DF       0432*       rst.lil $18
0415BC C9          0433*       ret
0415BD 17 00 A0    0434*   @cmd:       db 23,0,0xA0
0415C0 00 00       0435*   @bufferId:	dw 0x0000
0415C2 02          0436*   		    db 2 ; clear buffer
0415C3             0437*   @end:
0415C3             0438*   
0415C3             0439*   vdu_clear_all_buffers:
0415C3             0440*   ; clear all buffers
0415C3 21 CE 15 04 0441*       ld hl,@beg
0415C7 01 06 00 00 0442*       ld bc,@end-@beg
0415CB 5B DF       0443*       rst.lil $18
0415CD C9          0444*       ret
0415CE 17 00 A0    0445*   @beg: db 23,0,$A0
0415D1 FF FF       0446*         dw -1 ; clear all buffers
0415D3 02          0447*         db 2  ; command 2: clear a buffer
0415D4             0448*   @end:
0415D4             0449*   
0415D4             0450*   ; Command 14: Consolidate blocks in a buffer
0415D4             0451*   vdu_consolidate_buffer:
0415D4             0452*   ; set parameters for vdu call
0415D4 7D          0453*       ld a,l
0415D5 32 EC 15 04 0454*       ld (@bufferId),a
0415D9 7C          0455*       ld a,h
0415DA 32 ED 15 04 0456*       ld (@bufferId+1),a
0415DE 21 E9 15 04 0457*       ld hl,@beg
0415E2 01 06 00 00 0458*       ld bc,@end-@beg
0415E6 5B DF       0459*       rst.lil $18
0415E8 C9          0460*       ret
0415E9             0461*   ; VDU 23, 0, &A0, bufferId; 14
0415E9 17 00 A0    0462*   @beg: db 23,0,0xA0
0415EC 00 00       0463*   @bufferId: dw 0x0000
0415EE 0E          0464*              db 14
0415EF             0465*   @end:
0415EF             0466*   
0415EF             0467*   ; load an image file to a buffer and make it a bitmap
0415EF             0468*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0415EF             0469*   vdu_load_img:
0415EF             0470*   ; back up image type and dimension parameters
0415EF 22 76 15 04 0471*       ld (bufferId0),hl
0415F3 F5          0472*       push af
0415F4 C5          0473*   	push bc
0415F5 D5          0474*   	push de
0415F6             0475*   ; load the image
0415F6 CD 11 16 04 0476*   	call vdu_load_buffer_from_file
0415FA             0477*   ; now make it a bitmap
0415FA 2A 76 15 04 0478*       ld hl,(bufferId0)
0415FE CD D4 15 04 0479*       call vdu_consolidate_buffer
041602 2A 76 15 04 0480*       ld hl,(bufferId0)
041606 CD D1 14 04 0481*       call vdu_buff_select
04160A D1          0482*   	pop de ; image height
04160B C1          0483*   	pop bc ; image width
04160C F1          0484*   	pop af ; image type
04160D C3 E6 14 04 0485*   	jp vdu_bmp_create ; will return to caller from there
041611             0486*   
041611             0487*   ; inputs: hl = bufferId; iy = pointer to filename
041611             0488*   vdu_load_buffer_from_file:
041611 22 76 15 04 0489*       ld (bufferId0),hl
041615             0490*   
041615             0491*   ; clear target buffer
041615 CD A8 15 04 0492*       call vdu_clear_buffer
041619             0493*   
041619             0494*   ; open the file in read mode
041619             0495*   ; Open a file
041619             0496*   ; HLU: Filename
041619             0497*   ;   C: Mode
041619             0498*   ; Returns:
041619             0499*   ;   A: Filehandle, or 0 if couldn't open
041619 FD E5       0500*   	push iy ; pointer to filename
04161B E1          0501*   	pop hl
04161C 0E 01       0502*   	ld c,fa_read
04161E             0503*       MOSCALL mos_fopen
04161E 3E 0A       0001*M1 			LD	A, function
041620 5B CF       0002*M1 			RST.LIL	08h
041622 32 5D 16 04 0504*       ld (@filehandle),a
041626             0505*   
041626             0506*   @read_file:
041626             0507*   ; Read a block of data from a file
041626             0508*   ;   C: Filehandle
041626             0509*   ; HLU: Pointer to where to write the data to
041626             0510*   ; DEU: Number of bytes to read
041626             0511*   ; Returns:
041626             0512*   ; DEU: Number of bytes read
041626 3A 5D 16 04 0513*       ld a,(@filehandle)
04162A 4F          0514*       ld c,a
04162B 21 00 E0 B7 0515*       ld hl,filedata
04162F 11 00 20 00 0516*       ld de,8192 ; max we can read into onboard sram at one time
041633             0517*       MOSCALL mos_fread
041633 3E 1A       0001*M1 			LD	A, function
041635 5B CF       0002*M1 			RST.LIL	08h
041637             0518*   
041637             0519*   ; test de for zero bytes read
041637 21 00 00 00 0520*       ld hl,0
04163B AF          0521*       xor a ; clear carry
04163C ED 52       0522*       sbc hl,de
04163E CA 54 16 04 0523*       jp z,@close_file
041642             0524*   
041642             0525*   ; load a vdu buffer from local memory
041642             0526*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041642 2A 76 15 04 0527*       ld hl,(bufferId0)
041646 D5          0528*       push de ; chunksize
041647 C1          0529*       pop bc
041648 11 00 E0 B7 0530*       ld de,filedata
04164C CD 7C 15 04 0531*       call vdu_load_buffer
041650             0532*   
041650             0533*   ; read the next block
041650 C3 26 16 04 0534*       jp @read_file
041654             0535*   
041654             0536*   ; close the file
041654             0537*   @close_file:
041654 3A 5D 16 04 0538*       ld a,(@filehandle)
041658             0539*       MOSCALL mos_fclose
041658 3E 0B       0001*M1 			LD	A, function
04165A 5B CF       0002*M1 			RST.LIL	08h
04165C C9          0540*       ret ; vdu_load_buffer_from_file
04165D             0541*   
04165D 00          0542*   @filehandle: db 0 ; file handle
04165E 00 00 00    0543*   @fil: dl 0 ; pointer to FIL struct
041661             0544*   
041661 00 00 00    0545*   @chunkpointer: dl 0 ; pointer to current chunk
041664             0546*   
041664             0547*   ; File information structure (FILINFO)
041664             0548*   @filinfo:
041664 00 00 00 00 0549*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041668 00 00       0550*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04166A 00 00       0551*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04166C 00          0552*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04166D 00 00 00 00 0553*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04167A 00 00 00 00 0554*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04177A             0040        include "vdu_fonts.inc"
04177A             0001*   ; select font
04177A             0002*   ; inputs: hl = bufferId, a = font flags
04177A             0003*   ; Flags:
04177A             0004*   ; Bit	Description
04177A             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
04177A             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
04177A             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
04177A             0008*   ; 1-7	Reserved for future use
04177A             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
04177A             0010*   vdu_font_select:
04177A 22 91 17 04 0011*       ld (@bufferId),hl
04177E 32 93 17 04 0012*       ld (@flags),a
041782 21 8D 17 04 0013*       ld hl,@cmd
041786 01 07 00 00 0014*       ld bc,@end-@cmd
04178A 5B DF       0015*       rst.lil $18
04178C C9          0016*       ret
04178D 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
041791 00 00       0018*   @bufferId: dw 0x0000
041793 00          0019*   @flags: db 0x00
041794             0020*   @end:
041794             0021*   
041794             0022*   ; create font from buffer
041794             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041794             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041794             0025*   vdu_font_create:
041794 22 B9 17 04 0026*       ld (@bufferId),hl
041798 ED 53 BB 17 0027*       ld (@width),de ; also loads height
       04          
04179D 32 BE 17 04 0028*       ld (@flags),a
0417A1 7A          0029*       ld a,d ; height
0417A2 32 BD 17 04 0030*       ld (@ascent),a ; ascent = height
0417A6             0031*   ; consolidate buffer
0417A6 CD D4 15 04 0032*       call vdu_consolidate_buffer
0417AA             0033*   ; create font
0417AA 21 B5 17 04 0034*       ld hl,@cmd
0417AE 01 0A 00 00 0035*       ld bc,@end-@cmd
0417B2 5B DF       0036*       rst.lil $18
0417B4 C9          0037*       ret
0417B5 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
0417B9 00 00       0039*   @bufferId: dw 0x0000
0417BB 00          0040*   @width: db 0x00
0417BC 00          0041*   @height: db 0x00
0417BD 00          0042*   @ascent: db 0x00
0417BE 00          0043*   @flags: db 0x00
0417BF             0044*   @end:
0417BF             0045*   
0417BF             0046*   ; set or adjust font property
0417BF             0047*   ; inputs: hl = bufferId, a = field, de = value
0417BF             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
0417BF             0049*   vdu_font_property:
0417BF 22 DB 17 04 0050*       ld (@bufferId),hl
0417C3 32 DD 17 04 0051*       ld (@field),a
0417C7 ED 53 DE 17 0052*       ld (@value),de
       04          
0417CC 21 D7 17 04 0053*       ld hl,@cmd
0417D0 01 09 00 00 0054*       ld bc,@end-@cmd
0417D4 5B DF       0055*       rst.lil $18
0417D6 C9          0056*       ret
0417D7 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
0417DB 00 00       0058*   @bufferId: dw 0x0000
0417DD 00          0059*   @field: db 0x00
0417DE 00 00       0060*   @value: dw 0x0000
0417E0 00          0061*   @end: db 0x00 ; padding
0417E1             0062*   
0417E1             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
0417E1             0064*   
0417E1             0065*   ; Clear/Delete font
0417E1             0066*   ; inputs: hl = bufferId
0417E1             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
0417E1             0068*   vdu_font_clear:
0417E1 22 F4 17 04 0069*       ld (@bufferId),hl
0417E5 21 F0 17 04 0070*       ld hl,@cmd
0417E9 01 06 00 00 0071*       ld bc,@end-@cmd
0417ED 5B DF       0072*       rst.lil $18
0417EF C9          0073*       ret
0417F0 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
0417F4 00 00       0075*   @bufferId: dw 0x0000
0417F6 00          0076*   @end: db 0x00 ; padding
0417F7             0077*   
0417F7             0078*   ; Copy system font to buffer
0417F7             0079*   ; inputs: hl = bufferId
0417F7             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
0417F7             0081*   vdu_font_copy_system:
0417F7 22 0A 18 04 0082*       ld (@bufferId),hl
0417FB 21 06 18 04 0083*       ld hl,@cmd
0417FF 01 06 00 00 0084*       ld bc,@end-@cmd
041803 5B DF       0085*       rst.lil $18
041805 C9          0086*       ret
041806 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
04180A 00 00       0088*   @bufferId: dw 0x0000
04180C 00          0089*   @end: db 0x00 ; padding
04180D             0041        include "vdu_plot.inc"
04180D             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04180D             0002*   ; PLOT code 	(Decimal) 	Effect
04180D             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
04180D             0004*   plot_sl_both: equ 0x00
04180D             0005*   
04180D             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
04180D             0007*   plot_sl_first: equ 0x08
04180D             0008*   
04180D             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
04180D             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
04180D             0011*   
04180D             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
04180D             0013*   plot_sl_last: equ 0x20
04180D             0014*   
04180D             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
04180D             0016*   plot_sl_none: equ 0x28
04180D             0017*   
04180D             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
04180D             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
04180D             0020*   
04180D             0021*   ; &40-&47 	64-71 	Point plot
04180D             0022*   plot_pt: equ 0x40
04180D             0023*   
04180D             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
04180D             0025*   plot_lf_lr_non_bg: equ 0x48
04180D             0026*   
04180D             0027*   ; &50-&57 	80-87 	Triangle fill
04180D             0028*   plot_tf: equ 0x50
04180D             0029*   
04180D             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
04180D             0031*   plot_lf_r_bg: equ 0x58
04180D             0032*   
04180D             0033*   ; &60-&67 	96-103 	Rectangle fill
04180D             0034*   plot_rf: equ 0x60
04180D             0035*   
04180D             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
04180D             0037*   plot_lf_lr_fg: equ 0x60
04180D             0038*   
04180D             0039*   ; &70-&77 	112-119 	Parallelogram fill
04180D             0040*   plot_pf: equ 0x70
04180D             0041*   
04180D             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
04180D             0043*   plot_lf_r_non_fg: equ 0x78
04180D             0044*   
04180D             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
04180D             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
04180D             0047*   
04180D             0048*   ; &90-&97 	144-151 	Circle outline
04180D             0049*   plot_co: equ 0x90
04180D             0050*   
04180D             0051*   ; &98-&9F 	152-159 	Circle fill
04180D             0052*   plot_cf: equ 0x98
04180D             0053*   
04180D             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
04180D             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
04180D             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
04180D             0057*   
04180D             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
04180D             0059*   plot_rcm: equ 0xB8
04180D             0060*   
04180D             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
04180D             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
04180D             0063*   ; &D0-&D7 	208-215 	Not defined
04180D             0064*   ; &D8-&DF 	216-223 	Not defined
04180D             0065*   ; &E0-&E7 	224-231 	Not defined
04180D             0066*   
04180D             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
04180D             0068*   plot_bmp: equ 0xE8
04180D             0069*   
04180D             0070*   ; &F0-&F7 	240-247 	Not defined
04180D             0071*   ; &F8-&FF 	248-255 	Not defined
04180D             0072*   
04180D             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
04180D             0074*   ; Agon Console8 VDP 2.2.0
04180D             0075*   
04180D             0076*   ; Within each group of eight plot codes, the effects are as follows:
04180D             0077*   ; Plot code 	Effect
04180D             0078*   ; 0 	Move relative
04180D             0079*   mv_rel: equ 0
04180D             0080*   
04180D             0081*   ; 1 	Plot relative in current foreground colour
04180D             0082*   dr_rel_fg: equ 1
04180D             0083*   
04180D             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
04180D             0085*   ; 3 	Plot relative in current background colour
04180D             0086*   dr_rel_bg: equ 3
04180D             0087*   
04180D             0088*   ; 4 	Move absolute
04180D             0089*   mv_abs: equ 4
04180D             0090*   
04180D             0091*   ; 5 	Plot absolute in current foreground colour
04180D             0092*   dr_abs_fg: equ 5
04180D             0093*   
04180D             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
04180D             0095*   ; 7 	Plot absolute in current background colour
04180D             0096*   dr_abs_bg: equ 7
04180D             0097*   
04180D             0098*   ; Codes 0-3 use the position data provided as part of the command
04180D             0099*   ; as a relative position, adding the position given to the current
04180D             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
04180D             0101*   ; as part of the command as an absolute position, setting the current
04180D             0102*   ; graphical cursor position to the position given.
04180D             0103*   
04180D             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
04180D             0105*   ; current pixel colour. These operations cannot currently be supported
04180D             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
04180D             0107*   ; supported. Support for these codes may be added in a future version
04180D             0108*   ; of the VDP firmware.
04180D             0109*   
04180D             0110*   ; 16 colour palette constants
04180D             0111*   c_black: equ 0
04180D             0112*   c_red_dk: equ 1
04180D             0113*   c_green_dk: equ 2
04180D             0114*   c_yellow_dk: equ 3
04180D             0115*   c_blue_dk: equ 4
04180D             0116*   c_magenta_dk: equ 5
04180D             0117*   c_cyan_dk: equ 6
04180D             0118*   c_grey: equ 7
04180D             0119*   c_grey_dk: equ 8
04180D             0120*   c_red: equ 9
04180D             0121*   c_green: equ 10
04180D             0122*   c_yellow: equ 11
04180D             0123*   c_blue: equ 12
04180D             0124*   c_magenta: equ 13
04180D             0125*   c_cyan: equ 14
04180D             0126*   c_white: equ 15
04180D             0127*   
04180D             0128*   ; VDU 25, mode, x; y;: PLOT command
04180D             0129*   ; inputs: a=mode, bc=x0, de=y0
04180D             0130*   vdu_plot:
04180D 32 27 18 04 0131*       ld (@mode),a
041811 ED 43 28 18 0132*       ld (@x0),bc
       04          
041816 ED 53 2A 18 0133*       ld (@y0),de
       04          
04181B 21 26 18 04 0134*   	ld hl,@cmd
04181F 01 06 00 00 0135*   	ld bc,@end-@cmd
041823 5B DF       0136*   	rst.lil $18
041825 C9          0137*   	ret
041826 19          0138*   @cmd:   db 25
041827 00          0139*   @mode:  db 0
041828 00 00       0140*   @x0: 	dw 0
04182A 00 00       0141*   @y0: 	dw 0
04182C 00          0142*   @end:   db 0 ; extra byte to soak up deu
04182D             0143*   
04182D             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04182D             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
04182D             0146*   ; VDU 25, mode, x; y;: PLOT command
04182D             0147*   ; inputs: bc=x0, de=y0
04182D             0148*   ; prerequisites: vdu_buff_select
04182D             0149*   vdu_plot_bmp:
04182D ED 43 44 18 0150*       ld (@x0),bc
       04          
041832 ED 53 46 18 0151*       ld (@y0),de
       04          
041837 21 42 18 04 0152*   	ld hl,@cmd
04183B 01 06 00 00 0153*   	ld bc,@end-@cmd
04183F 5B DF       0154*   	rst.lil $18
041841 C9          0155*   	ret
041842 19          0156*   @cmd:   db 25
041843 ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041844 00 00       0158*   @x0: 	dw 0x0000
041846 00 00       0159*   @y0: 	dw 0x0000
041848 00          0160*   @end:   db 0x00 ; padding
041849             0161*   
041849             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041849             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
041849             0164*   ; VDU 25, mode, x; y;: PLOT command
041849             0165*   ; inputs: bc=x0, de=y0
041849             0166*   ; USING 16.8 FIXED POINT COORDINATES
041849             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041849             0168*   ;   the fractional portiion of the inputs are truncated
041849             0169*   ;   leaving only the 16-bit integer portion
041849             0170*   ; prerequisites: vdu_buff_select
041849             0171*   vdu_plot_bmp168:
041849             0172*   ; populate in the reverse of normal to keep the
041849             0173*   ; inputs from stomping on each other
041849 ED 53 67 18 0174*       ld (@y0-1),de
       04          
04184E ED 43 65 18 0175*       ld (@x0-1),bc
       04          
041853 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
041855 32 65 18 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041859 21 64 18 04 0178*   	ld hl,@cmd
04185D 01 06 00 00 0179*   	ld bc,@end-@cmd
041861 5B DF       0180*   	rst.lil $18
041863 C9          0181*   	ret
041864 19          0182*   @cmd:   db 25
041865 ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041866 00 00       0184*   @x0: 	dw 0x0000
041868 00 00       0185*   @y0: 	dw 0x0000
04186A             0186*   @end:  ; no padding required b/c we shifted de right
04186A             0187*   
04186A             0188*   ; draw a filled rectangle
04186A             0189*   vdu_plot_rf:
04186A ED 43 91 18 0190*       ld (@x0),bc
       04          
04186F ED 53 93 18 0191*       ld (@y0),de
       04          
041874 DD 22 97 18 0192*       ld (@x1),ix
       04          
041879 FD 22 99 18 0193*       ld (@y1),iy
       04          
04187E 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
041880 32 95 18 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041884 21 8F 18 04 0196*   	ld hl,@cmd0
041888 01 0C 00 00 0197*   	ld bc,@end-@cmd0
04188C 5B DF       0198*   	rst.lil $18
04188E C9          0199*       ret
04188F 19          0200*   @cmd0:  db 25 ; plot
041890 04          0201*   @arg0:  db plot_sl_both+mv_abs
041891 00 00       0202*   @x0:    dw 0x0000
041893 00 00       0203*   @y0:    dw 0x0000
041895 19          0204*   @cmd1:  db 25 ; plot
041896 65          0205*   @arg1:  db plot_rf+dr_abs_fg
041897 00 00       0206*   @x1:    dw 0x0000
041899 00 00       0207*   @y1:    dw 0x0000
04189B 00          0208*   @end:   db 0x00 ; padding
04189C             0209*   
04189C             0210*   ; draw a filled circle
04189C             0211*   vdu_plot_cf:
04189C ED 43 C3 18 0212*       ld (@x0),bc
       04          
0418A1 ED 53 C5 18 0213*       ld (@y0),de
       04          
0418A6 DD 22 C9 18 0214*       ld (@x1),ix
       04          
0418AB FD 22 CB 18 0215*       ld (@y1),iy
       04          
0418B0 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
0418B2 32 C7 18 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0418B6 21 C1 18 04 0218*   	ld hl,@cmd0
0418BA 01 0C 00 00 0219*   	ld bc,@end-@cmd0
0418BE 5B DF       0220*   	rst.lil $18
0418C0 C9          0221*       ret
0418C1 19          0222*   @cmd0:  db 25 ; plot
0418C2 04          0223*   @arg0:  db plot_sl_both+mv_abs
0418C3 00 00       0224*   @x0:    dw 0x0000
0418C5 00 00       0225*   @y0:    dw 0x0000
0418C7 19          0226*   @cmd1:  db 25 ; plot
0418C8 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
0418C9 00 00       0228*   @x1:    dw 0x0000
0418CB 00 00       0229*   @y1:    dw 0x0000
0418CD 00          0230*   @end:   db 0x00 ; padding
0418CE             0042        include "vdu_sound.inc"
0418CE             0001*   ; load a sound file to a buffer
0418CE             0002*   ; inputs: hl = bufferId ; ix = file size ; iy = pointer to filename
0418CE             0003*   vdu_load_sfx:
0418CE             0004*   ; back up input parameters
0418CE E5          0005*       push hl ; bufferId
0418CF             0006*   ; load the sound
0418CF CD 11 16 04 0007*       call vdu_load_buffer_from_file
0418D3             0008*   ; now make the buffer a sound sample
0418D3 E1          0009*       pop hl ; bufferId
0418D4 AF          0010*       xor a ; zero is the magic number for 8-bit signed PCM 16KHz
0418D5             0011*       ; push hl ; bufferId
0418D5 CD 11 1A 04 0012*       call vdu_buffer_to_sound
0418D9             0013*   ; ; play the loaded sound
0418D9             0014*   ;     ld c,0 ; channel
0418D9             0015*   ;     ld b,127 ; full volume
0418D9             0016*   ;     ld de,1000 ; 1 second duration
0418D9             0017*   ;     pop hl ; bufferId
0418D9             0018*   ;     call vdu_play_sample
0418D9 C9          0019*       ret
0418DA             0020*   
0418DA 00          0021*   last_channel: db 0
0418DB             0022*   max_channels: equ 3
0418DB             0023*   
0418DB             0024*   vdu_play_sfx:
0418DB 22 13 19 04 0025*       ld (@bufferId),hl
0418DF ED 43 1D 19 0026*       ld (@duration),bc
       04          
0418E4 3E 17       0027*       ld a,23
0418E6 32 15 19 04 0028*       ld (@bufferId+2),a
0418EA 3A DA 18 04 0029*       ld a,(last_channel)
0418EE 3C          0030*       inc a
0418EF             0031*       ; and 31 ; modulo 32
0418EF FE 03       0032*       cp max_channels
0418F1 C2 F6 18 04 0033*       jp nz,@load_channel
0418F5 AF          0034*       xor a
0418F6             0035*   @load_channel:
0418F6 32 DA 18 04 0036*       ld (last_channel),a
0418FA 32 10 19 04 0037*       ld (@channel0),a
0418FE 32 18 19 04 0038*       ld (@channel1),a
041902 21 0D 19 04 0039*       ld hl, @sample
041906 01 12 00 00 0040*       ld bc, @sample_end - @sample
04190A 5B DF       0041*       rst.lil $18
04190C C9          0042*       ret
04190D             0043*   @sample:
04190D             0044*   ; Command 4: Set waveform
04190D             0045*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04190D 17 00 85    0046*       .db 23,0,$85                        ; do sound
041910             0047*   @channel0:
041910 00 04 08    0048*       .db 0,4,8 ; channel, command, waveform
041913             0049*   @bufferId:
041913 00 00       0050*       .dw 0x0000
041915             0051*   ; Command 0: Play note
041915             0052*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041915 17 00 85    0053*       .db 23,0,$85                        ; do sound
041918             0054*   @channel1:
041918 00 00 7F    0055*       .db 0,0,127                ; channel, volume
04191B 00 00       0056*       .dw 0
04191D             0057*   @duration:                              ; freq (tuneable samples only)
04191D 00 00       0058*       .dw 0x0000                        ; duration
04191F             0059*   @sample_end:
04191F 00          0060*       .db 0x00 ; padding
041920             0061*   
041920             0062*   ; enable enough additional channels so that total enabled = max_channels
041920             0063*   ; inputs: max_channels set
041920             0064*   ; returns: nothing
041920             0065*   ; destroys: af, bc, hl
041920             0066*   vdu_enable_channels:
041920 3E 03       0067*       ld a,max_channels
041922 D6 03       0068*       sub 3 ; subtract number of default channels already enabled
041924 F2 2B 19 04 0069*       jp p,@loop
041928 C9          0070*       ret
041929 3E 03       0071*       ld a,3 ; first non-default channel
04192B             0072*   @loop:
04192B 32 46 19 04 0073*       ld (@channel),a
04192F 21 43 19 04 0074*       ld hl,@beg
041933 01 05 00 00 0075*       ld bc,@end-@beg
041937 F5          0076*       push af
041938 5B DF       0077*       rst.lil $18
04193A F1          0078*       pop af
04193B 3C          0079*       inc a
04193C FE 03       0080*       cp max_channels
04193E C2 2B 19 04 0081*       jp nz,@loop
041942 C9          0082*       ret
041943             0083*   @beg:
041943 17 00 85    0084*               db 23, 0, $85
041946 00          0085*   @channel:   db 0
041947 08          0086*               db 8 ; command 8: enable channel
041948             0087*   @end:
041948             0088*   
041948             0089*   ; disable all but the three default sound channels
041948             0090*   ; inputs: max_channels set
041948             0091*   ; outputs: none
041948             0092*   ; destroys: ah,hl,bc
041948             0093*   vdu_disable_channels:
041948 3E 03       0094*       ld a,max_channels
04194A D6 03       0095*       sub 3 ; subtract number of default channels already enabled
04194C F2 53 19 04 0096*       jp p,@loop
041950 C9          0097*       ret
041951 3E 03       0098*       ld a,3 ; first non-default channel
041953             0099*   @loop:
041953 32 6E 19 04 0100*       ld (@channel),a
041957 21 6B 19 04 0101*       ld hl,@beg
04195B 01 05 00 00 0102*       ld bc,@end-@beg
04195F F5          0103*       push af
041960 5B DF       0104*       rst.lil $18
041962 F1          0105*       pop af
041963 3C          0106*       inc a
041964 FE 03       0107*       cp max_channels
041966 C2 53 19 04 0108*       jp nz,@loop
04196A C9          0109*       ret
04196B             0110*   @beg:
04196B 17 00 85    0111*       db 23, 0, $85
04196E 00          0112*   @channel: db 0
04196F 09          0113*       db 9 ; command 9: disable channel
041970             0114*   @end:
041970             0115*   
041970             0116*   
041970             0117*   ; ############################################################
041970             0118*   ; VDU SOUND API
041970             0119*   ; ############################################################
041970             0120*   ; Command 0: Play note
041970             0121*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041970             0122*       MACRO PLAY_NOTE channel, volume, frequency, duration
041970             0123*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041970             0124*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041970             0125*       rst.lil $18
041970             0126*       jr @PLAY_NOTE_END
041970             0127*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041970             0128*                    db channel                  ; Channel, 0 (commented out)
041970             0129*                    db 0                        ; Play note command
041970             0130*                    db volume                   ; Volume
041970             0131*                    dw frequency                ; Frequency
041970             0132*                    dw duration                 ; Duration
041970             0133*   @PLAY_NOTE_END:
041970             0134*       ENDMACRO
041970             0135*   
041970             0136*       MACRO MUTE_CHANNEL channel
041970             0137*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041970             0138*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041970             0139*       rst.lil $18
041970             0140*       jr @MUTE_CHANNEL_END
041970             0141*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041970             0142*                      db channel                ; Channel, 0 (commented out)
041970             0143*                      db 2                      ; Set volume command
041970             0144*                      db 0                      ; Volume (mute)
041970             0145*   @MUTE_CHANNEL_END:
041970             0146*       ENDMACRO
041970             0147*   
041970             0148*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041970             0149*   vdu_play_note:
041970 79          0150*       ld a,c
041971 32 91 19 04 0151*       ld (@channel),a
041975 78          0152*       ld a,b
041976 32 93 19 04 0153*       ld (@volume),a
04197A 22 94 19 04 0154*       ld (@frequency),hl
04197E ED 53 96 19 0155*       ld (@duration),de
       04          
041983 21 8E 19 04 0156*       ld hl,@cmd
041987 01 0A 00 00 0157*       ld bc,@end-@cmd
04198B 5B DF       0158*       rst.lil $18
04198D C9          0159*       ret
04198E 17 00 85    0160*   @cmd:       db 23, 0, 0x85
041991 00          0161*   @channel:   db 0x00
041992 00          0162*               db 0x00 ; play note command
041993 00          0163*   @volume:    db 0x00
041994 00 00       0164*   @frequency: dw 0x0000
041996 00 00       0165*   @duration:  dw 0x0000
041998 00          0166*   @end:       db 0x00 ; padding
041999             0167*   
041999             0168*   ; Command 1: Status
041999             0169*   ; VDU 23, 0, &85, channel, 1
041999             0170*   ; inputs: a = channel
041999             0171*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041999             0172*   ; Bit 	Name 	Meaning
041999             0173*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041999             0174*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041999             0175*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041999             0176*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041999             0177*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041999             0178*   
041999             0179*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041999             0180*   vdu_channel_status:
041999 32 AB 19 04 0181*       ld (@channel),a
04199D 21 A8 19 04 0182*       ld hl,@cmd
0419A1 01 05 00 00 0183*       ld bc,@end-@cmd
0419A5 5B DF       0184*       rst.lil $18
0419A7 C9          0185*       ret
0419A8 17 00 85    0186*   @cmd:       db 23, 0, 0x85
0419AB 00          0187*   @channel:   db 0x00
0419AC 01          0188*               db 0x01 ; get channel status command
0419AD             0189*   @end:
0419AD             0190*   
0419AD             0191*   ; VDU 23, 0, &85, channel, 2, volume
0419AD             0192*   ; inputs: c = channel, b = volume
0419AD             0193*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
0419AD             0194*   
0419AD             0195*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
0419AD             0196*   
0419AD             0197*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
0419AD             0198*   vdu_channel_volume:
0419AD 79          0199*       ld a,c
0419AE 32 C5 19 04 0200*       ld (@channel),a
0419B2 78          0201*       ld a,b
0419B3 32 C7 19 04 0202*       ld (@volume),a
0419B7 21 C2 19 04 0203*       ld hl,@cmd
0419BB 01 06 00 00 0204*       ld bc,@end-@cmd
0419BF 5B DF       0205*       rst.lil $18
0419C1 C9          0206*       ret
0419C2 17 00 85    0207*   @cmd:       db 23, 0, 0x85
0419C5 00          0208*   @channel:   db 0x00
0419C6 02          0209*               db 0x02 ; set volume command
0419C7 00          0210*   @volume:    db 0x00
0419C8             0211*   @end:
0419C8             0212*   
0419C8             0213*   ; VDU 23, 0, &85, channel, 3, frequency;
0419C8             0214*   
0419C8             0215*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
0419C8             0216*   
0419C8             0217*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
0419C8             0218*   
0419C8             0219*   ; Returns 1 on success, 0 for failure.
0419C8             0220*   vdu_channel_frequency:
0419C8 79          0221*       ld a,c
0419C9 32 E0 19 04 0222*       ld (@channel),a
0419CD ED 53 E2 19 0223*       ld (@frequency),de
       04          
0419D2 21 DD 19 04 0224*       ld hl,@cmd
0419D6 01 07 00 00 0225*       ld bc,@end-@cmd
0419DA 5B DF       0226*       rst.lil $18
0419DC C9          0227*       ret
0419DD 17 00 85    0228*   @cmd:       db 23, 0, 0x85
0419E0 00          0229*   @channel:   db 0x00
0419E1 03          0230*               db 0x03 ; set frequency command
0419E2 00 00       0231*   @frequency: dw 0x0000
0419E4 00          0232*   @end:       db 0x00 ; padding
0419E5             0233*   
0419E5             0234*   
0419E5             0235*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0419E5             0236*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
0419E5             0237*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
0419E5             0238*   
0419E5             0239*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
0419E5             0240*   
0419E5             0241*   ; By default a channel is set to use waveform 0 (square wave).
0419E5             0242*   
0419E5             0243*   ; Valid waveform values are as follows:
0419E5             0244*   ; Value 	Waveform
0419E5             0245*   ; 0 	Square wave
0419E5             0246*   ; 1 	Triangle wave
0419E5             0247*   ; 2 	Sawtooth wave
0419E5             0248*   ; 3 	Sine wave
0419E5             0249*   ; 4 	Noise (simple white noise with no frequency support)
0419E5             0250*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
0419E5             0251*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
0419E5             0252*   
0419E5             0253*   vdu_channel_waveform:
0419E5 79          0254*       ld a,c
0419E6 32 0B 1A 04 0255*       ld (@channel),a
0419EA 78          0256*       ld a,b
0419EB 32 0D 1A 04 0257*       ld (@waveform),a
0419EF FE 08       0258*       cp 8 ; check if the waveform is a sample
0419F1 28 06       0259*       jr z, @sample
0419F3 01 06 00 00 0260*       ld bc,@bufferId-@cmd
0419F7 18 08       0261*       jr @sendToVdu
0419F9             0262*   @sample:
0419F9 22 0E 1A 04 0263*       ld (@bufferId),hl
0419FD 01 08 00 00 0264*       ld bc,@end-@cmd
041A01             0265*   @sendToVdu:
041A01 21 08 1A 04 0266*       ld hl,@cmd
041A05 5B DF       0267*       rst.lil $18
041A07 C9          0268*       ret
041A08 17 00 85    0269*   @cmd:       db 23, 0, 0x85
041A0B 00          0270*   @channel:   db 0x00
041A0C 04          0271*               db 0x04 ; set waveform command
041A0D 00          0272*   @waveform:  db 0x00
041A0E 00 00       0273*   @bufferId:  dw 0x0000
041A10 00          0274*   @end:       db 0x00 ; padding
041A11             0275*   
041A11             0276*   
041A11             0277*   
041A11             0278*   ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
041A11             0279*   ; inputs: hl = bufferId; a = format
041A11             0280*   ; The format parameter is an 8-bit value that indicates the format of the sample data. The following values are supported:
041A11             0281*   ; Value 	Description
041A11             0282*   ; 0 	8-bit signed, 16KHz
041A11             0283*   ; 1 	8-bit unsigned, 16KHz
041A11             0284*   vdu_buffer_to_sound:
041A11 22 2A 1A 04 0285*       ld (@bufferId),hl
041A15 32 2C 1A 04 0286*       ld (@format),a
041A19 21 24 1A 04 0287*       ld hl,@cmd
041A1D 01 09 00 00 0288*       ld bc,@end-@cmd
041A21 5B DF       0289*       rst.lil $18
041A23 C9          0290*       ret
041A24 17 00 85    0291*   @cmd:       db 23, 0, 0x85
041A27 00          0292*               db 0x00 ; a magic number that is always 0
041A28 05          0293*               db 0x05 ; buffer to sound command
041A29 02          0294*               db 0x02 ; a magic number that is always 2
041A2A 00 00       0295*   @bufferId:  dw 0x0000
041A2C 00          0296*   @format:    db 0x00
041A2D             0297*   @end:
041A2D             0298*   
041A2D             0299*   
041A2D             0300*   ; inputs: c = channel, b = volume, de = duration; hl = bufferId
041A2D             0301*   vdu_play_sample:
041A2D             0302*       ; populate input parameters
041A2D 79          0303*       ld a,c
041A2E 32 58 1A 04 0304*       ld (@channel0),a
041A32 32 60 1A 04 0305*       ld (@channel1),a
041A36 78          0306*       ld a,b
041A37 32 62 1A 04 0307*       ld (@volume),a
041A3B ED 53 63 1A 0308*       ld (@frequency),de
       04          
041A40 22 5B 1A 04 0309*       ld (@bufferId),hl
041A44             0310*       ; clean up byte that got stomped on by bufferId load from hl
041A44 3E 17       0311*       ld a,23
041A46 32 5D 1A 04 0312*       ld (@cmd1),a
041A4A             0313*       ; prep the vdu command string
041A4A 21 55 1A 04 0314*       ld hl, @cmd0
041A4E 01 12 00 00 0315*       ld bc, @end - @cmd0
041A52 5B DF       0316*       rst.lil $18
041A54 C9          0317*       ret
041A55 17 00 85    0318*   @cmd0:       db 23, 0, 0x85
041A58 00          0319*   @channel0:   db 0x00
041A59 04          0320*                db 0x04 ; set waveform command
041A5A 08          0321*   @waveform:   db 0x08 ; sample
041A5B 00 00       0322*   @bufferId:   dw 0x0000
041A5D 17 00 85    0323*   @cmd1:       db 23, 0, 0x85
041A60 00          0324*   @channel1:   db 0x00
041A61 00          0325*                db 0x00 ; play note command
041A62 00          0326*   @volume:     db 0x00
041A63 00 00       0327*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
041A65 00 00       0328*   @duration:   dw 0x0000 ; milliseconds
041A67 00          0329*   @end:        db 0x00 ; padding
041A68             0043        ; include "vdu_sprites.inc"
041A68             0044    
041A68             0045    ; APPLICATION INCLUDES
041A68             0046        include "music.inc"
041A68             0001*   ; This file is created by build_98_asm_sfx.py, do not edit it!
041A68             0002*   
041A68             0003*   SFX_num_buffers: equ 4
041A68             0004*   ; SFX buffer ids:
041A68             0005*   BUF_AFRICA: equ 0x3000
041A68             0006*   BUF_COME_UNDONE: equ 0x3001
041A68             0007*   BUF_EVERY_BREATH_YOU_TAKE: equ 0x3002
041A68             0008*   BUF_RHIANNON: equ 0x3003
041A68             0009*   
041A68             0010*   ; SFX buffer id reverse lookup:
041A68             0011*   SFX_buffer_id_lut:
041A68 00 30 00    0012*   	dl BUF_AFRICA
041A6B 01 30 00    0013*   	dl BUF_COME_UNDONE
041A6E 02 30 00    0014*   	dl BUF_EVERY_BREATH_YOU_TAKE
041A71 03 30 00    0015*   	dl BUF_RHIANNON
041A74             0016*   
041A74             0017*   ; SFX duration lookup:
041A74             0018*   SFX_duration_lut:
041A74 54 72 00    0019*   	dl 29268 ; AFRICA
041A77 54 72 00    0020*   	dl 29268 ; COME_UNDONE
041A7A 54 72 00    0021*   	dl 29268 ; EVERY_BREATH_YOU_TAKE
041A7D 54 72 00    0022*   	dl 29268 ; RHIANNON
041A80             0023*   
041A80             0024*   ; SFX load routines jump table:
041A80             0025*   SFX_load_routines_table:
041A80 8C 1A 04    0026*   	dl load_sfx_AFRICA
041A83 AF 1A 04    0027*   	dl load_sfx_COME_UNDONE
041A86 D2 1A 04    0028*   	dl load_sfx_EVERY_BREATH_YOU_TAKE
041A89 F5 1A 04    0029*   	dl load_sfx_RHIANNON
041A8C             0030*   
041A8C             0031*   ; Import sfx .raw files and load them into VDP buffers
041A8C             0032*   
041A8C             0033*   load_sfx_AFRICA:
041A8C 21 18 1B 04 0034*   	ld hl,FAFRICA
041A90 11 00 E0 B7 0035*   	ld de,filedata
041A94 01 00 00 01 0036*   	ld bc,65536
041A98 3E 01       0037*   	ld a,mos_load
041A9A 5B CF       0038*   	RST.LIL 08h
041A9C 21 00 30 00 0039*   	ld hl,BUF_AFRICA
041AA0 DD 21 10 80 0040*   	ld ix,491536
       07          
041AA5 FD 21 18 1B 0041*   	ld iy,FAFRICA
       04          
041AAA CD CE 18 04 0042*   	call vdu_load_sfx
041AAE C9          0043*   	ret
041AAF             0044*   
041AAF             0045*   load_sfx_COME_UNDONE:
041AAF 21 29 1B 04 0046*   	ld hl,FCOME_UNDONE
041AB3 11 00 E0 B7 0047*   	ld de,filedata
041AB7 01 00 00 01 0048*   	ld bc,65536
041ABB 3E 01       0049*   	ld a,mos_load
041ABD 5B CF       0050*   	RST.LIL 08h
041ABF 21 01 30 00 0051*   	ld hl,BUF_COME_UNDONE
041AC3 DD 21 10 80 0052*   	ld ix,491536
       07          
041AC8 FD 21 29 1B 0053*   	ld iy,FCOME_UNDONE
       04          
041ACD CD CE 18 04 0054*   	call vdu_load_sfx
041AD1 C9          0055*   	ret
041AD2             0056*   
041AD2             0057*   load_sfx_EVERY_BREATH_YOU_TAKE:
041AD2 21 3F 1B 04 0058*   	ld hl,FEVERY_BREATH_YOU_TAKE
041AD6 11 00 E0 B7 0059*   	ld de,filedata
041ADA 01 00 00 01 0060*   	ld bc,65536
041ADE 3E 01       0061*   	ld a,mos_load
041AE0 5B CF       0062*   	RST.LIL 08h
041AE2 21 02 30 00 0063*   	ld hl,BUF_EVERY_BREATH_YOU_TAKE
041AE6 DD 21 10 80 0064*   	ld ix,491536
       07          
041AEB FD 21 3F 1B 0065*   	ld iy,FEVERY_BREATH_YOU_TAKE
       04          
041AF0 CD CE 18 04 0066*   	call vdu_load_sfx
041AF4 C9          0067*   	ret
041AF5             0068*   
041AF5             0069*   load_sfx_RHIANNON:
041AF5 21 5F 1B 04 0070*   	ld hl,FRHIANNON
041AF9 11 00 E0 B7 0071*   	ld de,filedata
041AFD 01 00 00 01 0072*   	ld bc,65536
041B01 3E 01       0073*   	ld a,mos_load
041B03 5B CF       0074*   	RST.LIL 08h
041B05 21 03 30 00 0075*   	ld hl,BUF_RHIANNON
041B09 DD 21 10 80 0076*   	ld ix,491536
       07          
041B0E FD 21 5F 1B 0077*   	ld iy,FRHIANNON
       04          
041B13 CD CE 18 04 0078*   	call vdu_load_sfx
041B17 C9          0079*   	ret
041B18             0080*   
041B18             0081*   ; File name lookups:
041B18 6D 75 73 69 0082*   FAFRICA: db "music/AFRICA.raw",0
       63 2F 41 46 
       52 49 43 41 
       2E 72 61 77 
       00          
041B29 6D 75 73 69 0083*   FCOME_UNDONE: db "music/COME_UNDONE.raw",0
       63 2F 43 4F 
       4D 45 5F 55 
       4E 44 4F 4E 
       45 2E 72 61 
       77 00       
041B3F 6D 75 73 69 0084*   FEVERY_BREATH_YOU_TAKE: db "music/EVERY_BREATH_YOU_TAKE.raw",0
       63 2F 45 56 
       45 52 59 5F 
       42 52 45 41 
       54 48 5F 59 
       4F 55 5F 54 
       41 4B 45 2E 
       72 61 77 00 
041B5F 6D 75 73 69 0085*   FRHIANNON: db "music/RHIANNON.raw",0
       63 2F 52 48 
       49 41 4E 4E 
       4F 4E 2E 72 
       61 77 00    
041B72             0086*   
041B72             0087*   ; Play sfx routines
041B72             0088*   
041B72             0089*   sfx_play_africa:
041B72 21 00 30 00 0090*   	ld hl,BUF_AFRICA
041B76 01 54 72 00 0091*   	ld bc,29268
041B7A C3 DB 18 04 0092*   	jp vdu_play_sfx
041B7E             0093*   
041B7E             0094*   sfx_play_come_undone:
041B7E 21 01 30 00 0095*   	ld hl,BUF_COME_UNDONE
041B82 01 54 72 00 0096*   	ld bc,29268
041B86 C3 DB 18 04 0097*   	jp vdu_play_sfx
041B8A             0098*   
041B8A             0099*   sfx_play_every_breath_you_take:
041B8A 21 02 30 00 0100*   	ld hl,BUF_EVERY_BREATH_YOU_TAKE
041B8E 01 54 72 00 0101*   	ld bc,29268
041B92 C3 DB 18 04 0102*   	jp vdu_play_sfx
041B96             0103*   
041B96             0104*   sfx_play_rhiannon:
041B96 21 03 30 00 0105*   	ld hl,BUF_RHIANNON
041B9A 01 54 72 00 0106*   	ld bc,29268
041B9E C3 DB 18 04 0107*   	jp vdu_play_sfx
041BA2             0047        ; include "sfx.inc"
041BA2             0048    
041BA2             0049    ; --- MAIN PROGRAM FILE ---
041BA2             0050    main:
041BA2 CD 5C 00 04 0051        call printInline
041BA6 4C 6F 61 64 0052        asciz "Loading SFX...\r\n"
       69 6E 67 20 
       53 46 58 2E 
       2E 2E 0D 0A 
       00          
041BB7             0053        ; call load_sfx_AMBIENT_BEAT70
041BB7             0054        ; call load_sfx_SPACE_ADVENTURE
041BB7 CD AF 1A 04 0055        call load_sfx_COME_UNDONE
041BBB CD F5 1A 04 0056        call load_sfx_RHIANNON
041BBF CD 8C 1A 04 0057        call load_sfx_AFRICA
041BC3 CD D2 1A 04 0058        call load_sfx_EVERY_BREATH_YOU_TAKE
041BC7 CD 5C 00 04 0059        call printInline
041BCB 53 46 58 20 0060        asciz "SFX loaded.\r\n"
       6C 6F 61 64 
       65 64 2E 0D 
       0A 00       
041BD9             0061    
041BD9             0062    @loop:
041BD9 CD 56 03 04 0063        call waitKeypress
041BDD FE 1B       0064        cp '\e'
041BDF C8          0065        ret z
041BE0             0066        ; call sfx_play_ambient_beat70
041BE0             0067        ; call sfx_play_space_adventure
041BE0 FE 31       0068        cp '1'
041BE2 CC 7E 1B 04 0069        call z,sfx_play_come_undone
041BE6 FE 32       0070        cp '2'
041BE8 CC 96 1B 04 0071        call z,sfx_play_rhiannon
041BEC FE 33       0072        cp '3'
041BEE CC 72 1B 04 0073        call z,sfx_play_africa
041BF2 FE 34       0074        cp '4'
041BF4 CC 8A 1B 04 0075        call z,sfx_play_every_breath_you_take
041BF8 C3 D9 1B 04 0076        jp @loop
041BFC             0077    ; end main
041BFC             0078    
