PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0005   
040000             0006       MACRO PROGNAME
040000             0007       ASCIZ "fixed168"
040000             0008       ENDMACRO
040000             0009   
040000 C3 45 00 04 0010       jp start
040004             0011   
040004             0012   _exec_name:
040004             0013   	PROGNAME
040004 66 69 78 65 0001M      ASCIZ "fixed168"
       64 31 36 38 
       00          
04000D             0014   
04000D FF FF FF FF 0015       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040040 4D 4F 53    0016       db "MOS"
040043 00          0017       db 00h
040044 01          0018       db 01h
040045             0019   
040045             0020   start:
040045 F5          0021       push af
040046 C5          0022       push bc
040047 D5          0023       push de
040048 DD E5       0024       push ix
04004A FD E5       0025       push iy
04004C             0026   
04004C CD CF 0D 04 0027       call init
040050 CD D0 0D 04 0028       call main
040054             0029   
040054             0030   exit:
040054             0031   
040054 FD E1       0032       pop iy
040056 DD E1       0033       pop ix
040058 D1          0034       pop de
040059 C1          0035       pop bc
04005A F1          0036       pop af
04005B 21 00 00 00 0037       ld hl,0
04005F             0038   
04005F C9          0039       ret
040060             0040   
040060             0041   ; --- MAIN PROGRAM ---
040060             0042   ; APPLICATION INCLUDES
040060             0043       include "fixed168.inc"
040060             0001*  ; multiply HL by 256
040060             0002*  ; inputs: HL
040060             0003*  ; outputs: HL*256
040060             0004*  ; destroys: flags
040060             0005*      MACRO hlu_mul256
040060             0006*          add hl,hl ; * 2
040060             0007*          add hl,hl ; * 4
040060             0008*          add hl,hl ; * 8
040060             0009*          add hl,hl ; * 16
040060             0010*          add hl,hl ; * 32
040060             0011*          add hl,hl ; * 64
040060             0012*          add hl,hl ; * 128
040060             0013*          add hl,hl ; * 256
040060             0014*      ENDMACRO
040060             0015*  
040060             0016*  ; test the sign of HL
040060             0017*  ; inputs: HL obviously
040060             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0019*  ; destroys: flags
040060             0020*      MACRO sign_hlu
040060             0021*          add hl,de
040060             0022*          or a
040060             0023*          sbc hl,de
040060             0024*      ENDMACRO
040060             0025*  
040060             0026*  ; hlu signed division by 256
040060             0027*  ; returns: hlu / 256
040060             0028*  ; destroys: af
040060             0029*  hlu_sdiv256:
040060 AF          0030*      xor a ; assume hl is positive
040061 22 77 00 04 0031*      ld (@buffer),hl
040065             0032*      sign_hlu
040065 19          0001*M         add hl,de
040066 B7          0002*M         or a
040067 ED 52       0003*M         sbc hl,de
040069 F2 6E 00 04 0033*      jp p,@hl_pos
04006D 3D          0034*      dec a
04006E             0035*  @hl_pos:
04006E 32 7A 00 04 0036*      ld (@buffer+3),a
040072 2A 78 00 04 0037*      ld hl,(@buffer+1)
040076 C9          0038*      ret
040077             0039*  @buffer: ds 4
04007B             0040*  
04007B             0041*  ; hlu 1 byte right shift, unsigned
04007B             0042*  ; returns: hlu / 256, fractional portion in a
04007B             0043*  ; destroys: af
04007B             0044*  hlu_udiv256:
04007B AF          0045*  	xor a
04007C 32 8D 00 04 0046*  	ld (@buffer+3),a
040080 7D          0047*  	ld a,l ; save the fractional portion
040081 22 8A 00 04 0048*  	ld (@buffer),hl
040085 2A 8B 00 04 0049*  	ld hl,(@buffer+1)
040089 C9          0050*  	ret
04008A             0051*  @buffer: ds 4
04008E             0052*  
04008E             0053*  ; absolute value of hlu
04008E             0054*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
04008E             0055*  ;         s1,z0,pv0,n1,c0 if hlu was negative
04008E             0056*  ;         s0,z1,pv0,n1,c0 if hlu was zero
04008E             0057*  ;         s0,z0,pv0,n1,c0 if hlu was positive
04008E             0058*  ; destroys: a
04008E             0059*  hlu_abs:
04008E 19          0060*      add hl,de
04008F B7          0061*      or a
040090 ED 52       0062*      sbc hl,de
040092 FA 97 00 04 0063*      jp m,@is_neg
040096 C9          0064*      ret         ; hlu is positive or zero so we're done
040097             0065*  @is_neg:
040097 F5          0066*      push af     ; otherwise, save current flags for return
040098 CD 9E 00 04 0067*      call neg_hlu ; negate hlu
04009C F1          0068*      pop af      ; get back flags
04009D C9          0069*      ret
04009E             0070*  
04009E             0071*  ; flip the sign of hlu
04009E             0072*  ; inputs: hlu
04009E             0073*  ; returns: 0-hlu, flags set appropriately for the result:
04009E             0074*  ;         s1,z0,pv0,n1,c1 if result is negative
04009E             0075*  ;         s0,z1,pv0,n1,c0 if result is zero
04009E             0076*  ;         s0,z0,pv0,n1,c1 if result is positive
04009E             0077*  ; destroys a
04009E             0078*  neg_hlu:
04009E D5          0079*      push de     ; save de
04009F EB          0080*      ex de,hl    ; put hl into de
0400A0 21 00 00 00 0081*      ld hl,0     ; clear hl
0400A4 AF          0082*      xor a       ; clear carry
0400A5 ED 52       0083*      sbc hl,de   ; 0-hlu = -hlu
0400A7 D1          0084*      pop de      ; get de back
0400A8 C9          0085*      ret         ; easy peasy
0400A9             0086*  
0400A9             0087*      ; include "fixed24.inc"
0400A9             0088*  
0400A9             0089*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0400A9             0090*  ; uses EZ80 MLT instruction for speed
0400A9             0091*  ; operation: UHL * A --> UHL
0400A9             0092*  ; destroys: AF, HL
0400A9             0093*  smul24x8:
0400A9             0094*  ; make hl positive and store sign flag
0400A9 CD 8E 00 04 0095*  	call hlu_abs
0400AD F5          0096*  	push af
0400AE             0097*  ; do the division
0400AE CD B9 00 04 0098*      call mul24x8 ; hl = product
0400B2             0099*  ; adjust sign of result
0400B2 F1          0100*  	pop af ; sign de
0400B3 F0          0101*  	ret p ; hl was positive, nothing to do
0400B4 CD 9E 00 04 0102*  	call neg_hlu ; result is negative
0400B8 C9          0103*  	ret
0400B9             0104*  
0400B9             0105*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0400B9             0106*  ; uses EZ80 MLT instruction for speed
0400B9             0107*  ; operation: UHL * A --> AUHL
0400B9             0108*  ; destroys: AF, HL
0400B9             0109*  mul24x8:
0400B9 D5          0110*  	push de ; preserve de
0400BA             0111*  ; low byte
0400BA 5D          0112*  	ld e,l
0400BB 57          0113*  	ld d,a
0400BC ED 5C       0114*  	mlt de
0400BE 6B          0115*  	ld l,e ; product low byte
0400BF 08          0116*  	ex af,af' ; save multiplier
0400C0 7A          0117*  	ld a,d ; carry
0400C1 08          0118*  	ex af,af' ; save carry, restore multiplier
0400C2             0119*  ; high byte
0400C2 5C          0120*  	ld e,h
0400C3 57          0121*  	ld d,a
0400C4 ED 5C       0122*  	mlt de
0400C6 08          0123*  	ex af,af' ; save multiplier, restore carry
0400C7 83          0124*  	add a,e ; add carry
0400C8 67          0125*  	ld h,a ; product middle byte
0400C9 7A          0126*  	ld a,d ; carry
0400CA 08          0127*  	ex af,af' ; save carry, restore multiplier
0400CB             0128*  ; upper byte
0400CB 22 E6 00 04 0129*      ld (@scratch),hl ; 7 cycles
0400CF 5F          0130*  	ld e,a
0400D0 3A E8 00 04 0131*  	ld a,(@scratch+2)
0400D4 57          0132*  	ld d,a
0400D5 ED 5C       0133*  	mlt de
0400D7 08          0134*  	ex af,af' ; restore carry
0400D8 8B          0135*  	adc a,e ; add carry
0400D9 32 E8 00 04 0136*      ld (@scratch+2),a ; 5 cycles
0400DD 2A E6 00 04 0137*      ld hl,(@scratch) ; 7 cycles
0400E1             0138*  ; highest byte
0400E1 3E 00       0139*  	ld a,0 ; preserve carry flag
0400E3 8A          0140*  	adc a,d ; product highest byte
0400E4 D1          0141*  	pop de ; restore de
0400E5 C9          0142*  	ret
0400E6             0143*  @scratch: ds 3
0400E9             0144*  
0400E9 00 00 00 00 0145*  mul24out: blkb 6,0
       00 00       
0400EF             0146*  
0400EF             0147*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0400EF             0148*  ; operation: UHL * UDE --> mul24out
0400EF             0149*  mul24:
0400EF DD E5       0150*  	push ix ; preserve
0400F1             0151*  ; point to output buffer and clear it
0400F1 DD 21 E9 00 0152*  	ld ix,mul24out
       04          
0400F6 C5          0153*  	push bc
0400F7 01 00 00 00 0154*  	ld bc,0
0400FB DD 0F 00    0155*  	ld (ix),bc
0400FE DD 0F 03    0156*  	ld (ix+3),bc
040101 C1          0157*  	pop bc
040102             0158*  ; STEP 1: UHL * E
040102 7B          0159*  	ld a,e
040103 E5          0160*  	push hl
040104 CD B9 00 04 0161*  	call mul24x8
040108 DD 2F 00    0162*  	ld (ix+0),hl
04010B DD 77 03    0163*  	ld (ix+3),a
04010E             0164*  ; STEP 2: UHL * D
04010E E1          0165*  	pop hl
04010F E5          0166*  	push hl
040110 7A          0167*  	ld a,d
040111 CD B9 00 04 0168*  	call mul24x8
040115 CD 2E 01 04 0169*  	call @accumulate
040119             0170*  ; STEP 3: UHL * DEU
040119 E1          0171*  	pop hl
04011A ED 53 5E 01 0172*  	ld (@de),de
       04          
04011F 3A 60 01 04 0173*  	ld a,(@de+2)
040123 CD B9 00 04 0174*  	call mul24x8
040127 CD 2E 01 04 0175*  	call @accumulate
04012B             0176*  ; all done
04012B DD E1       0177*  	pop ix ; restore
04012D C9          0178*  	ret
04012E             0179*  @accumulate:
04012E DD 23       0180*  	inc ix
040130             0181*  ; highest byte of product to carry
040130 DD 77 03    0182*  	ld (ix+3),a
040133             0183*  ; low byte of product
040133 7D          0184*  	ld a,l
040134 DD 86 00    0185*  	add a,(ix+0)
040137 DD 77 00    0186*  	ld (ix+0),a
04013A             0187*  ; high byte of product
04013A 7C          0188*  	ld a,h
04013B DD 8E 01    0189*  	adc a,(ix+1)
04013E DD 77 01    0190*  	ld (ix+1),a
040141             0191*  ; uppper byte of product
040141 22 5B 01 04 0192*  	ld (@hl),hl
040145 3A 5D 01 04 0193*  	ld a,(@hl+2)
040149 DD 8E 02    0194*  	adc a,(ix+2)
04014C DD 77 02    0195*  	ld (ix+2),a
04014F             0196*  ; carry
04014F 3E 00       0197*  	ld a,0 ; preserve flags
040151 DD 8E 03    0198*  	adc a,(ix+3)
040154 DD 77 03    0199*  	ld (ix+3),a
040157 C9          0200*  	ret
040158             0201*  
040158 00 00 00    0202*  @ix: dl 0
04015B 00 00 00    0203*  @hl: dl 0
04015E 00 00 00    0204*  @de: dl 0
040161             0205*  
040161             0206*  ; UHL * UDE --> UHL (unsigned)
040161             0207*  umul24:
040161 CD EF 00 04 0208*  	call mul24
040165 2A E9 00 04 0209*  	ld hl,(mul24out)
040169 C9          0210*  	ret
04016A             0211*  
04016A             0212*  ; UH.L = UH.L*UD.E (unsigned)
04016A             0213*  umul168:
04016A CD EF 00 04 0214*  	call mul24
04016E 2A EA 00 04 0215*  	ld hl,(mul24out+1)
040172 C9          0216*  	ret
040173             0217*  
040173             0218*  ; UH.L * UD.E --> UH.L (signed)
040173             0219*  smul168:
040173             0220*  ; make everything positive and store sign flags
040173 CD 8E 00 04 0221*  	call hlu_abs
040177 F5          0222*  	push af
040178 EB          0223*  	ex de,hl
040179 CD 8E 00 04 0224*  	call hlu_abs
04017D EB          0225*  	ex de,hl
04017E F5          0226*  	push af
04017F             0227*  ; do the division
04017F CD 6A 01 04 0228*      call umul168 ; hl = product
040183             0229*  ; adjust sign of result
040183 F1          0230*  	pop af ; sign de
040184 FA 8F 01 04 0231*  	jp m,@de_neg
040188 F1          0232*  	pop af ; sign hl
040189 F0          0233*  	ret p ; both positive, nothing to do
04018A             0234*  @hl_neg:
04018A CD 9E 00 04 0235*      call neg_hlu ; de pos, hl neg, result is negative
04018E C9          0236*      ret
04018F             0237*  @de_neg:
04018F F1          0238*  	pop af
040190 F8          0239*  	ret m ; both negative, nothing to do
040191 CD 9E 00 04 0240*  	call neg_hlu ; result is negative
040195 C9          0241*  	ret
040196             0242*  
040196             0243*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040196             0244*  ; perform unsigned division of 16.8 fixed place values
040196             0245*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040196             0246*  udiv168:
040196             0247*  ; back up divisor
040196 ED 53 CD 01 0248*  	ld (@ude),de
       04          
04019B             0249*  ; get the 16-bit integer part of the quotient
04019B CD FE 01 04 0250*      call udiv24 ; de = quotient, hl = remainder
04019F             0251*  ; load quotient to upper three bytes of output
04019F ED 53 D4 01 0252*      ld (div168_out+1),de
       04          
0401A4             0253*  @div256:
0401A4             0254*  ; multiply remainder by 256
0401A4             0255*  	hlu_mul256
0401A4 29          0001*M         add hl,hl ; * 2
0401A5 29          0002*M         add hl,hl ; * 4
0401A6 29          0003*M         add hl,hl ; * 8
0401A7 29          0004*M         add hl,hl ; * 16
0401A8 29          0005*M         add hl,hl ; * 32
0401A9 29          0006*M         add hl,hl ; * 64
0401AA 29          0007*M         add hl,hl ; * 128
0401AB 29          0008*M         add hl,hl ; * 256
0401AC             0256*  ; skip fractional computation if remainder is zero
0401AC             0257*      sign_hlu
0401AC 19          0001*M         add hl,de
0401AD B7          0002*M         or a
0401AE ED 52       0003*M         sbc hl,de
0401B0 20 03       0258*      jr nz,@div_frac
0401B2 AF          0259*      xor a
0401B3 18 0A       0260*      jr @write_frac
0401B5             0261*  ; now divide the shifted remainder by the divisor
0401B5             0262*  @div_frac:
0401B5 ED 5B CD 01 0263*  	ld de,(@ude) ; get back divisor
       04          
0401BA CD FE 01 04 0264*      call udiv24 ; de = quotient, hl = remainder
0401BE             0265*  ; load low byte of quotient to low byte of output
0401BE 7B          0266*      ld a,e
0401BF             0267*  @write_frac:
0401BF 32 D3 01 04 0268*      ld (div168_out),a
0401C3             0269*  ; load de with return value
0401C3 ED 5B D3 01 0270*      ld de,(div168_out)
       04          
0401C8             0271*  ; load a with any overflow
0401C8 3A D6 01 04 0272*      ld a,(div168_out+3)
0401CC C9          0273*      ret ; ud.e is the 16.8 result
0401CD             0274*  @ude: ds 6
0401D3             0275*  div168_out: ds 4 ; the extra byte is for overflow
0401D7             0276*  
0401D7             0277*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0401D7             0278*  ; perform signed division of 16.8 fixed place values
0401D7             0279*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0401D7             0280*  sdiv168:
0401D7             0281*  ; make everything positive and store sign flags
0401D7 CD 8E 00 04 0282*  	call hlu_abs
0401DB F5          0283*  	push af
0401DC EB          0284*  	ex de,hl
0401DD CD 8E 00 04 0285*  	call hlu_abs
0401E1 EB          0286*  	ex de,hl
0401E2 F5          0287*  	push af
0401E3             0288*  ; do the division
0401E3 CD 96 01 04 0289*      call udiv168 ; de = quotient, hl = remainder
0401E7             0290*  ; adjust sign of result
0401E7 F1          0291*  	pop af ; sign de
0401E8 FA F5 01 04 0292*  	jp m,@de_neg
0401EC F1          0293*  	pop af ; sign hl
0401ED F0          0294*  	ret p ; both positive, nothing to do
0401EE             0295*  @hl_neg:
0401EE EB          0296*      ex de,hl ; hl = quotient, de = remainder
0401EF CD 9E 00 04 0297*      call neg_hlu ; de pos, hl neg, result is negative
0401F3 EB          0298*      ex de,hl ; de = negated quotient, hl = remainder
0401F4 C9          0299*      ret
0401F5             0300*  @de_neg:
0401F5 F1          0301*  	pop af
0401F6 F8          0302*  	ret m ; both negative, nothing to do
0401F7 EB          0303*      ex de,hl ; hl = quotient, de = remainder
0401F8 CD 9E 00 04 0304*  	call neg_hlu ; result is negative
0401FC EB          0305*      ex de,hl ; de = negated quotient, hl = remainder
0401FD C9          0306*  	ret
0401FE             0307*  
0401FE             0308*  ;------------------------------------------------------------------------
0401FE             0309*  ;  arith24.asm
0401FE             0310*  ;  24-bit ez80 arithmetic routines
0401FE             0311*  ;  Copyright (c) Shawn Sijnstra 2024
0401FE             0312*  ;  MIT license
0401FE             0313*  ;
0401FE             0314*  ;  This library was created as a tool to help make ez80
0401FE             0315*  ;  24-bit native assembly routines for simple mathematical problems
0401FE             0316*  ;  more widely available.
0401FE             0317*  ;
0401FE             0318*  ;------------------------------------------------------------------------
0401FE             0319*  ;
0401FE             0320*  ;------------------------------------------------------------------------
0401FE             0321*  ; udiv24
0401FE             0322*  ; Unsigned 24-bit division
0401FE             0323*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0401FE             0324*  ;
0401FE             0325*  ; Uses AF BC DE HL
0401FE             0326*  ; Uses Restoring Division algorithm
0401FE             0327*  ;------------------------------------------------------------------------
0401FE             0328*  
0401FE             0329*  udiv24:
0401FE E5          0330*  	push	hl
0401FF C1          0331*  	pop		bc	;move dividend to BCU
040200 21 00 00 00 0332*  	ld		hl,0	;result
040204 A7          0333*  	and		a
040205 ED 52       0334*  	sbc		hl,de	;test for div by 0
040207 C8          0335*  	ret		z		;it's zero, carry flag is clear
040208 19          0336*  	add		hl,de	;HL is 0 again
040209 3E 18       0337*  	ld		a,24	;number of loops through.
04020B             0338*  udiv1:
04020B C5          0339*  	push	bc	;complicated way of doing this because of lack of access to top bits
04020C E3          0340*  	ex		(sp),hl
04020D 37          0341*  	scf
04020E ED 6A       0342*  	adc	hl,hl
040210 E3          0343*  	ex	(sp),hl
040211 C1          0344*  	pop	bc		;we now have bc = (bc * 2) + 1
040212             0345*  
040212 ED 6A       0346*  	adc	hl,hl
040214 A7          0347*  	and	a		;is this the bug
040215 ED 52       0348*  	sbc	hl,de
040217 30 02       0349*  	jr	nc,udiv2
040219 19          0350*  	add	hl,de
04021A             0351*  ;	dec	c
04021A 0B          0352*  	dec	bc
04021B             0353*  udiv2:
04021B 3D          0354*  	dec	a
04021C 20 ED       0355*  	jr	nz,udiv1
04021E 37          0356*  	scf		;flag used for div0 error
04021F C5          0357*  	push	bc
040220 D1          0358*  	pop		de	;remainder
040221 C9          0359*  	ret
040222             0360*  
040222             0361*  ;------------------------------------------------------------------------
040222             0362*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
040222             0363*  ;------------------------------------------------------------------------
040222             0364*  
040222             0365*  
040222             0366*      ; include "trig24fast.inc"
040222             0367*  
040222             0368*  
040222             0369*  ; convert signed angles from a 360 to 256 degree circle
040222             0370*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040222             0371*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040222             0372*  ; destroys: TODO
040222             0373*  deg_360_to_256:
040222 D5          0374*  	push de ; preserve de
040223             0375*  ; make angle positive and store sign flag
040223 CD 8E 00 04 0376*  	call hlu_abs
040227 F5          0377*  	push af
040228             0378*  ; multiply by 256 first to keep precision
040228             0379*  	hlu_mul256 ; uh.l = uh.l * 256
040228 29          0001*M         add hl,hl ; * 2
040229 29          0002*M         add hl,hl ; * 4
04022A 29          0003*M         add hl,hl ; * 8
04022B 29          0004*M         add hl,hl ; * 16
04022C 29          0005*M         add hl,hl ; * 32
04022D 29          0006*M         add hl,hl ; * 64
04022E 29          0007*M         add hl,hl ; * 128
04022F 29          0008*M         add hl,hl ; * 256
040230             0380*  ; divide uh.l by 360
040230 11 68 01 00 0381*  	ld de,360
040234 CD FE 01 04 0382*  	call udiv24 ; ud.e = degrees / 360
040238 EB          0383*  	ex de,hl    ; uh.l = degrees / 360
040239             0384*  ; restore sign flag and adjust output accordingly
040239 F1          0385*  	pop af
04023A F2 42 02 04 0386*  	jp p,@pos ; positive number
04023E CD 9E 00 04 0387*  	call neg_hlu
040242             0388*  @pos:
040242             0389*  ; restore de and return uh.l as the result
040242 D1          0390*  	pop de
040243 C9          0391*  	ret
040244             0392*  
040244             0393*  ; fixed 16.8 routine
040244             0394*  ; cos(uh.l) --> uh.l
040244             0395*  ; destroys: f, hl
040244             0396*  cos168:
040244 D5          0397*      push de ; preserve de
040245             0398*  ; for cos we simply increment the angle by 90 degrees
040245             0399*  ; or 0x004000 in 16.8 degrees256
040245             0400*  ; which makes it a sin problem
040245 11 00 40 00 0401*      ld de,0x004000
040249 19          0402*      add hl,de ; modulo 256 happens below
04024A D1          0403*      pop de ; restore de
04024B             0404*  ; fall through to sin168
04024B             0405*  
04024B             0406*  ; ---------------------
04024B             0407*  ; fixed 16.8 routine
04024B             0408*  ; sin(uh.l) --> uh.l
04024B             0409*  ; destroys: f, hl
04024B             0410*  sin168:
04024B D5          0411*  	push de
04024C             0412*  ; handle negative angles appropriately
04024C CD 8E 00 04 0413*  	call hlu_abs
040250 F2 59 02 04 0414*  	jp p,@F
040254 11 00 00 FF 0415*  	ld de,-256*256
040258 19          0416*  	add hl,de
040259             0417*  @@:
040259 2E 03       0418*  	ld l,3 ; multiply by 3 to get our lookup index
04025B ED 6C       0419*      mlt hl
04025D 11 D0 04 04 0420*      ld de,sin_lut_168 ; grab the lut address
040261 19          0421*      add hl,de ; bump hl by the index
040262 ED 27       0422*      ld hl,(hl) ; don't try this on a z80!
040264 D1          0423*      pop de
040265 C9          0424*      ret
040266             0425*  
040266             0426*  ; 16.8 fixed inputs / outputs
040266             0427*  ; takes: uh.l as angle in degrees 256
040266             0428*  ;        ud.e as radius
040266             0429*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040266             0430*  ;        displacements from origin (0,0)
040266             0431*  ; destroys: everything except indexes
040266             0432*  polar_to_cartesian:
040266             0433*  ; back up input parameters
040266 22 95 02 04 0434*      ld (@angle), hl
04026A ED 53 98 02 0435*      ld (@radius), de
       04          
04026F             0436*  ; compute dx = sin(uh.l) * ud.e
04026F CD 4B 02 04 0437*      call sin168 ; uh.l = sin(uh.l)
040273 ED 5B 98 02 0438*  	ld de,(@radius)
       04          
040278 CD 73 01 04 0439*  	call smul168 ; uh.l = dx
04027C E5          0440*      push hl
04027D             0441*  ; compute dy = -cos(uh.l) * ud.e
04027D 2A 95 02 04 0442*      ld hl,(@angle)
040281 CD 44 02 04 0443*      call cos168 ; uh.l = cos(uh.l)
040285 ED 5B 98 02 0444*      ld de,(@radius)
       04          
04028A CD 73 01 04 0445*      call smul168    ; uh.l = dy
04028E CD 9E 00 04 0446*      call neg_hlu ; invert dy for screen coords convention
040292 EB          0447*      ex de,hl       ; de = dy for output
040293 C1          0448*      pop bc          ; bc = dx for output
040294             0449*  ; and out
040294 C9          0450*      ret
040295             0451*  @angle: ds 3
040298             0452*  @radius: ds 3
04029B             0453*  
04029B             0454*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04029B             0455*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04029B             0456*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
04029B             0457*  ;         also populates scratch locations dx168 and dy168
04029B             0458*  ; destroys: a,hl,bc,de
04029B             0459*  dxy168:
04029B             0460*  ; compute dx = x1-x0
04029B AF          0461*      xor a ; clear carry
04029C DD E5       0462*      push ix ; move ix to hl via the stack
04029E E1          0463*      pop hl ; hl = x1
04029F ED 42       0464*      sbc hl,bc ; hl = dx
0402A1 22 B6 02 04 0465*      ld (dx168),hl ; dx to scratch
0402A5             0466*  ; compute dy = y1-y0
0402A5 AF          0467*      xor a ; clear carry
0402A6 FD E5       0468*      push iy ; move iy to hl via the stack
0402A8 E1          0469*      pop hl ; hl = y1
0402A9 ED 52       0470*      sbc hl,de ; hl = dy
0402AB 22 BC 02 04 0471*      ld (dy168),hl ; dy to scratch
0402AF             0472*  ; populate output registers and return
0402AF EB          0473*      ex de,hl        ; ud.e = dy
0402B0 ED 4B B6 02 0474*      ld bc,(dx168)   ; ub.c = dx
       04          
0402B5 C9          0475*      ret
0402B6 00 00 00 00 0476*  dx168: blkb 6,0
       00 00       
0402BC 00 00 00 00 0477*  dy168: blkb 6,0
       00 00       
0402C2             0478*  
0402C2             0479*  ; compute the euclidian distance between two cartesian coordinates
0402C2             0480*  ; using the formula d = sqrt(dx^2+dy^2)
0402C2             0481*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0402C2             0482*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0402C2             0483*  ; output; uh.l is the 16.8 fixed format distance
0402C2             0484*  ;         also populates scratch locations dx168 and dy168
0402C2             0485*  ; destroys: a,hl,bc,de
0402C2             0486*  distance168:
0402C2 CD 9B 02 04 0487*  	call dxy168 ; ub.c = dx, ud.e = dy
0402C6             0488*  ; compute dy^2
0402C6 EB          0489*  	ex de,hl
0402C7 CD 8E 00 04 0490*  	call hlu_abs
0402CB CD 7B 00 04 0491*  	call hlu_udiv256 ; make integer to avoid overflow for dy >= 256
0402CF E5          0492*  	push hl
0402D0 D1          0493*  	pop de
0402D1 CD 61 01 04 0494*  	call umul24 ; hl = dy^2
0402D5 E5          0495*  	push hl ; save dy^2
0402D6             0496*  ; compute dx^2
0402D6 2A B6 02 04 0497*  	ld hl,(dx168)
0402DA CD 8E 00 04 0498*  	call hlu_abs
0402DE CD 7B 00 04 0499*  	call hlu_udiv256 ; make integer to avoid overflow for dx >= 256
0402E2 E5          0500*  	push hl
0402E3 D1          0501*  	pop de
0402E4 CD 61 01 04 0502*  	call umul24 ; hl = dx^2
0402E8             0503*  ; add dx^2 and dy^2
0402E8 D1          0504*  	pop de ; de = dy^2 (was hl)
0402E9 19          0505*  	add hl,de ; hl = dx^2 + dy^2
0402EA             0506*  	; hlu_mul256 ; multiply by 256 to get 16.8 fixed format
0402EA             0507*  	; hlu_mul256 ; multiply by 256 to get 16.8 fixed format
0402EA             0508*  ; compute the square root
0402EA             0509*  	; call sqrt168
0402EA CD BB 03 04 0510*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0402EE EB          0511*  	ex de,hl ; return value in hl
0402EF C9          0512*  	ret
0402F0             0513*  
0402F0             0514*  ; atan2_(ub.c,ud.e) --> uh.l
0402F0             0515*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0402F0             0516*  ;   whether inputs are integers or fractional doesn't matter
0402F0             0517*  ;   so long as the sign bit of the upper byte is correct
0402F0             0518*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0402F0             0519*  ; angles are COMPASS HEADINGS based on
0402F0             0520*  ; screen coordinate conventions,where the y axis is flipped
0402F0             0521*  ; #E0 315      0       45 #20
0402F0             0522*  ;        -x,-y | +x,-y
0402F0             0523*  ; #C0 270------+------ 90 #40
0402F0             0524*  ;        -x,+y | +x,+y
0402F0             0525*  ; #A0 225   180 #80   135 #60
0402F0             0526*  atan2_168fast:
0402F0             0527*  ; get signs and make everything positive
0402F0             0528*  ; get abs(x) and store its original sign
0402F0 C5          0529*      push bc
0402F1 E1          0530*      pop hl
0402F2 CD 8E 00 04 0531*      call hlu_abs ; if x was negative this also sets the sign flag
0402F6 E5          0532*      push hl ; store abs(x)
0402F7 C1          0533*      pop bc ; bc = abs(x)
0402F8 F5          0534*      push af ; store sign of x
0402F9             0535*  ; get abs(y) and store its original sign
0402F9 EB          0536*      ex de,hl ; hl = y
0402FA CD 8E 00 04 0537*      call hlu_abs ; if y was negative this also sets the sign flag
0402FE EB          0538*      ex de,hl ; de = abs(y)
0402FF F5          0539*      push af ; store sign of y
040300             0540*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040300             0541*  ; this ensures that our lookup value is between 0 and 1 inclusive
040300 AF          0542*      xor a ; clear the carry flag
040301 D5          0543*      push de
040302 E1          0544*      pop hl
040303 ED 42       0545*      sbc hl,bc
040305 F5          0546*      push af ; save sign of de - bc
040306 F2 0F 03 04 0547*      jp p,@1 ; bc <= de, so we skip ahead
04030A             0548*  ; otherwise we swap bc and de
04030A C5          0549*      push bc
04030B E1          0550*      pop hl
04030C EB          0551*      ex de,hl
04030D E5          0552*      push hl
04030E C1          0553*      pop bc
04030F             0554*  @1:
04030F             0555*  ; now we're ready to snag our preliminary result
04030F C5          0556*  	push bc
040310 E1          0557*  	pop hl
040311 CD 7F 03 04 0558*      call atan_168fast ; uh.l comes back with prelim result
040315             0559*  ; now we adjust uh.l based on sign of de - bc
040315 F1          0560*      pop af
040316 F2 22 03 04 0561*      jp p,@2 ; bc <= de,so we skip ahead
04031A EB          0562*      ex de,hl
04031B 21 00 40 00 0563*      ld hl,0x004000 ; 90 degrees
04031F AF          0564*      xor a ; clear the carry flag
040320 ED 52       0565*      sbc hl,de ; subtract result from 90 degrees
040322             0566*  @2:
040322             0567*  ; now the fun part of adjusting the result
040322             0568*  ; based on which quadrant (x,y) is in
040322             0569*  ; #E0 315      0       45 #20
040322             0570*  ;        -x,-y | +x,-y
040322             0571*  ; #C0 270------+------ 90 #40
040322             0572*  ;        -x,+y | +x,+y
040322             0573*  ; #A0 225   180 #80   135 #60
040322 F1          0574*      pop af ; sign of y
040323 CA 60 03 04 0575*      jp z,@y_zero
040327 F2 40 03 04 0576*      jp p,@y_pos
04032B             0577*  ; y neg,check x
04032B F1          0578*      pop af ; sign of x
04032C CA 3A 03 04 0579*      jp z,@y_neg_x_zero
040330 F2 3F 03 04 0580*      jp p,@y_neg_x_pos
040334             0581*  ; y neg,x neg
040334             0582*  ; angle is 270-360
040334             0583*  ; negating the intermediate does the trick
040334 CD 9E 00 04 0584*      call neg_hlu
040338 18 31       0585*      jr @zero_hlu
04033A             0586*  
04033A             0587*  @y_neg_x_zero:
04033A             0588*  ; y neg,x zero
04033A             0589*  ; angle is 0
04033A 21 00 00 00 0590*      ld hl,0
04033E C9          0591*      ret
04033F             0592*  @y_neg_x_pos:
04033F             0593*  ; y neg,x pos
04033F             0594*  ; angle is 0 to 90
04033F             0595*  ; so we're good
04033F C9          0596*      ret
040340             0597*  
040340             0598*  @y_pos:
040340 F1          0599*      pop af ; sign of x
040341 CA 50 03 04 0600*      jp z,@y_pos_x_zero
040345 F2 55 03 04 0601*      jp p,@y_pos_x_pos
040349             0602*  ; y pos,x neg
040349             0603*  ; angle is 180-270
040349             0604*  ; so we add 180 to intermediate
040349 11 00 80 00 0605*      ld de,0x008000
04034D 19          0606*      add hl,de
04034E 18 1B       0607*      jr @zero_hlu
040350             0608*  @y_pos_x_zero:
040350             0609*  ; y pos,x zero
040350             0610*  ; angle is 180
040350 21 00 80 00 0611*      ld hl,0x008000
040354 C9          0612*      ret
040355             0613*  @y_pos_x_pos:
040355             0614*  ; y pos,x pos
040355             0615*  ; angle is 90-180
040355             0616*  ; neg the intermediate and add 180 degrees
040355 CD 9E 00 04 0617*      call neg_hlu
040359 11 00 80 00 0618*      ld de,0x008000
04035D 19          0619*      add hl,de
04035E 18 0B       0620*      jr @zero_hlu
040360             0621*  
040360             0622*  @y_zero:
040360 F1          0623*      pop af ; sign of x
040361 FA 66 03 04 0624*      jp m,@y_zero_x_neg
040365             0625*  ; y zero,x pos
040365             0626*  ; angle is 90,nothing to do
040365 C9          0627*      ret
040366             0628*  @y_zero_x_neg:
040366             0629*  ; y zero ,x neg
040366             0630*  ; angle is 270
040366 21 00 C0 00 0631*      ld hl,0x00C000
04036A C9          0632*      ret
04036B             0633*  @zero_hlu:
04036B AF          0634*      xor a
04036C 22 79 03 04 0635*      ld (@scratch),hl
040370 32 7B 03 04 0636*      ld (@scratch+2),a
040374 2A 79 03 04 0637*      ld hl,(@scratch)
040378 C9          0638*      ret
040379             0639*  @scratch: ds 6
04037F             0640*  
04037F             0641*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04037F             0642*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
04037F             0643*  ; destroys: a,hl,bc,de
04037F             0644*  ; the following note was written by github copilot:
04037F             0645*  ; note: only works for angles from 0 to 32 (45) degrees
04037F             0646*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
04037F             0647*  atan_168fast:
04037F             0648*  ; because we use compass headings instead of geometric angles
04037F             0649*  ; we compute dx/dy which is 1/tan(theta) in the maths world
04037F             0650*  ; we can do faster unsigned division here because we know dx and dy are positive
04037F CD 96 01 04 0651*  	call udiv168 ; ud.e = dx/dy
040383 EB          0652*  	ex de,hl ; uh.l = dx/dy
040384             0653*  ; test uh.l for 0
040384 19          0654*      add hl,de
040385 B7          0655*      or a
040386 ED 52       0656*      sbc hl,de
040388 28 22       0657*      jr z,@is_zero
04038A             0658*  ; test uh.l for 1
04038A AF          0659*      xor a ; clear carry
04038B EB          0660*      ex de,hl
04038C 21 00 01 00 0661*      ld hl,0x000100 ; 1 in 16.8 fixed format
040390 ED 52       0662*      sbc hl,de
040392 28 13       0663*      jr z,@is_45
040394 EB          0664*  	ex de,hl
040395             0665*  ; no special cases so we move on
040395             0666*  ; l contains the fractional portion of tan(uh.l)
040395             0667*  ; we multiply it by three to get our lookup table index
040395 26 03       0668*      ld h,3
040397 ED 6C       0669*      mlt hl ; gosh that is handy
040399 11 00 00 00 0670*      ld de,0 ; clear deu
04039D 54          0671*      ld d,h ; copy hl to de
04039E 5D          0672*      ld e,l ; de contains our index
04039F 21 D3 07 04 0673*      ld hl,atan_lut_168 ; grab the lut address
0403A3 19          0674*      add hl,de ; bump hl by the index
0403A4 ED 27       0675*      ld hl,(hl) ; don't try this on a z80!
0403A6 C9          0676*      ret ; and out
0403A7             0677*  @is_45:
0403A7 21 00 20 00 0678*      ld hl,0x002000 ; 45 degrees decimal
0403AB C9          0679*      ret
0403AC             0680*  ; for the case tan(0)
0403AC             0681*  @is_zero:
0403AC 21 00 00 00 0682*      ld hl,0x000000
0403B0 C9          0683*      ret
0403B1             0684*  
0403B1             0685*  ; Expects  ADL mode
0403B1             0686*  ; Inputs:  UH.L
0403B1             0687*  ; Outputs: UH.L is the 16.8 square root
0403B1             0688*  ;          UD.E is the difference inputHL-DE^2
0403B1             0689*  ;          c flag reset
0403B1             0690*  sqrt168:
0403B1 CD BB 03 04 0691*      call sqrt24
0403B5 EB          0692*      ex de,hl
0403B6 29          0693*      add hl,hl
0403B7 29          0694*      add hl,hl
0403B8 29          0695*      add hl,hl
0403B9 29          0696*      add hl,hl
0403BA C9          0697*      ret
0403BB             0698*  
0403BB             0699*  sqrt24:
0403BB             0700*  ; Expects ADL mode
0403BB             0701*  ; Inputs: HL
0403BB             0702*  ; Outputs: DE is the integer square root
0403BB             0703*  ;          HL is the difference inputHL-DE^2
0403BB             0704*  ;          c flag reset
0403BB 11 00 00 00 0705*  	ld de,0 ; clear output
0403BF AF          0706*      xor a
0403C0 45          0707*      ld b,l
0403C1             0708*  	; ld c, h     ; C = high byte of HL (CORRECTED)
0403C1 C5          0709*      push bc
0403C2 47          0710*      ld b,a
0403C3 57          0711*      ld d,a
0403C4 4F          0712*      ld c,a  ; WRONG, should be h (see above)
0403C5 6F          0713*      ld l,a
0403C6 5F          0714*      ld e,a
0403C7             0715*  ; Iteration 1
0403C7 29          0716*      add hl,hl
0403C8 CB 11       0717*      rl c
0403CA 29          0718*      add hl,hl
0403CB CB 11       0719*      rl c
0403CD 91          0720*      sub c
0403CE 30 04       0721*      jr nc,$+6
0403D0 1C          0722*      inc e
0403D1 1C          0723*      inc e
0403D2 2F          0724*      cpl
0403D3 4F          0725*      ld c,a
0403D4 CD E2 0D 04 0726*  	call debug_print
0403D8             0727*  ; Iteration 2
0403D8 29          0728*      add hl,hl
0403D9 CB 11       0729*      rl c
0403DB 29          0730*      add hl,hl
0403DC CB 11       0731*      rl c
0403DE CB 13       0732*      rl e
0403E0 7B          0733*      ld a,e
0403E1 91          0734*      sub c
0403E2 30 04       0735*      jr nc,$+6
0403E4 1C          0736*      inc e
0403E5 1C          0737*      inc e
0403E6 2F          0738*      cpl
0403E7 4F          0739*      ld c,a
0403E8 CD E2 0D 04 0740*  	call debug_print
0403EC             0741*  ; Iteration 3
0403EC 29          0742*      add hl,hl
0403ED CB 11       0743*      rl c
0403EF 29          0744*      add hl,hl
0403F0 CB 11       0745*      rl c
0403F2 CB 13       0746*      rl e
0403F4 7B          0747*      ld a,e
0403F5 91          0748*      sub c
0403F6 30 04       0749*      jr nc,$+6
0403F8 1C          0750*      inc e
0403F9 1C          0751*      inc e
0403FA 2F          0752*      cpl
0403FB 4F          0753*      ld c,a
0403FC CD E2 0D 04 0754*  	call debug_print
040400             0755*  ; Iteration 4
040400 29          0756*      add hl,hl
040401 CB 11       0757*      rl c
040403 29          0758*      add hl,hl
040404 CB 11       0759*      rl c
040406 CB 13       0760*      rl e
040408 7B          0761*      ld a,e
040409 91          0762*      sub c
04040A 30 04       0763*      jr nc,$+6
04040C 1C          0764*      inc e
04040D 1C          0765*      inc e
04040E 2F          0766*      cpl
04040F 4F          0767*      ld c,a
040410 CD E2 0D 04 0768*  	call debug_print
040414             0769*  ; Iteration 5
040414 29          0770*      add hl,hl
040415 CB 11       0771*      rl c
040417 29          0772*      add hl,hl
040418 CB 11       0773*      rl c
04041A CB 13       0774*      rl e
04041C 7B          0775*      ld a,e
04041D 91          0776*      sub c
04041E 30 04       0777*      jr nc,$+6
040420 1C          0778*      inc e
040421 1C          0779*      inc e
040422 2F          0780*      cpl
040423 4F          0781*      ld c,a
040424 CD E2 0D 04 0782*  	call debug_print
040428             0783*  ; Iteration 6
040428 29          0784*      add hl,hl
040429 CB 11       0785*      rl c
04042B 29          0786*      add hl,hl
04042C CB 11       0787*      rl c
04042E CB 13       0788*      rl e
040430 7B          0789*      ld a,e
040431 91          0790*      sub c
040432 30 04       0791*      jr nc,$+6
040434 1C          0792*      inc e
040435 1C          0793*      inc e
040436 2F          0794*      cpl
040437 4F          0795*      ld c,a
040438 CD E2 0D 04 0796*  	call debug_print
04043C             0797*  ; Iteration 7
04043C 29          0798*      add hl,hl
04043D CB 11       0799*      rl c
04043F 29          0800*      add hl,hl
040440 CB 11       0801*      rl c
040442 CB 10       0802*      rl b
040444 EB          0803*      ex de,hl
040445 29          0804*      add hl,hl
040446 E5          0805*      push hl
040447 ED 42       0806*      sbc hl,bc
040449 30 06       0807*      jr nc,$+8
04044B 7C          0808*      ld a,h
04044C 2F          0809*      cpl
04044D 47          0810*      ld b,a
04044E 7D          0811*      ld a,l
04044F 2F          0812*      cpl
040450 4F          0813*      ld c,a
040451 E1          0814*      pop hl
040452 30 02       0815*      jr nc,$+4
040454 23          0816*      inc hl
040455 23          0817*      inc hl
040456 EB          0818*      ex de,hl
040457 CD E2 0D 04 0819*  	call debug_print
04045B             0820*  ; Iteration 8
04045B 29          0821*      add hl,hl
04045C 69          0822*      ld l,c
04045D 60          0823*      ld h,b
04045E ED 6A       0824*      adc hl,hl
040460 ED 6A       0825*      adc hl,hl
040462 EB          0826*      ex de,hl
040463 29          0827*      add hl,hl
040464 ED 52       0828*      sbc hl,de
040466 19          0829*      add hl,de
040467 EB          0830*      ex de,hl
040468 30 04       0831*      jr nc,$+6
04046A ED 52       0832*      sbc hl,de
04046C 13          0833*      inc de
04046D 13          0834*      inc de
04046E CD E2 0D 04 0835*  	call debug_print
040472             0836*  ; Iteration 9
040472 F1          0837*      pop af
040473 17          0838*      rla
040474 ED 6A       0839*      adc hl,hl
040476 17          0840*      rla
040477 ED 6A       0841*      adc hl,hl
040479 EB          0842*      ex de,hl
04047A 29          0843*      add hl,hl
04047B ED 52       0844*      sbc hl,de
04047D 19          0845*      add hl,de
04047E EB          0846*      ex de,hl
04047F 30 04       0847*      jr nc,$+6
040481 ED 52       0848*      sbc hl,de
040483 13          0849*      inc de
040484 13          0850*      inc de
040485 CD E2 0D 04 0851*  	call debug_print
040489             0852*  ; Iteration 10
040489 17          0853*      rla
04048A ED 6A       0854*      adc hl,hl
04048C 17          0855*      rla
04048D ED 6A       0856*      adc hl,hl
04048F EB          0857*      ex de,hl
040490 29          0858*      add hl,hl
040491 ED 52       0859*      sbc hl,de
040493 19          0860*      add hl,de
040494 EB          0861*      ex de,hl
040495 30 04       0862*      jr nc,$+6
040497 ED 52       0863*      sbc hl,de
040499 13          0864*      inc de
04049A 13          0865*      inc de
04049B CD E2 0D 04 0866*  	call debug_print
04049F             0867*  ; Iteration 11
04049F 17          0868*      rla
0404A0 ED 6A       0869*      adc hl,hl
0404A2 17          0870*      rla
0404A3 ED 6A       0871*      adc hl,hl
0404A5 EB          0872*      ex de,hl
0404A6 29          0873*      add hl,hl
0404A7 ED 52       0874*      sbc hl,de
0404A9 19          0875*      add hl,de
0404AA EB          0876*      ex de,hl
0404AB 30 04       0877*      jr nc,$+6
0404AD ED 52       0878*      sbc hl,de
0404AF 13          0879*      inc de
0404B0 13          0880*      inc de
0404B1 CD E2 0D 04 0881*  	call debug_print
0404B5             0882*  ; Iteration 12
0404B5 17          0883*      rla
0404B6 ED 6A       0884*      adc hl,hl
0404B8 17          0885*      rla
0404B9 ED 6A       0886*      adc hl,hl
0404BB EB          0887*      ex de,hl
0404BC 29          0888*      add hl,hl
0404BD ED 52       0889*      sbc hl,de
0404BF 19          0890*      add hl,de
0404C0 EB          0891*      ex de,hl
0404C1 30 04       0892*      jr nc,$+6
0404C3 ED 52       0893*      sbc hl,de
0404C5 13          0894*      inc de
0404C6 13          0895*      inc de
0404C7 CD E2 0D 04 0896*  	call debug_print
0404CB             0897*  ; Final output
0404CB CB 1A       0898*      rr d
0404CD CB 1B       0899*      rr e
0404CF C9          0900*      ret
0404D0             0901*  
0404D0             0902*  sin_lut_168:
0404D0 00 00 00    0903*  	dl 0x000000 ; 0.000 00, 0.000
0404D3 06 00 00    0904*  	dl 0x000006 ; 1.406 01, 0.025
0404D6 0C 00 00    0905*  	dl 0x00000C ; 2.813 02, 0.049
0404D9 12 00 00    0906*  	dl 0x000012 ; 4.219 03, 0.074
0404DC 19 00 00    0907*  	dl 0x000019 ; 5.625 04, 0.098
0404DF 1F 00 00    0908*  	dl 0x00001F ; 7.031 05, 0.122
0404E2 25 00 00    0909*  	dl 0x000025 ; 8.438 06, 0.147
0404E5 2B 00 00    0910*  	dl 0x00002B ; 9.844 07, 0.171
0404E8 31 00 00    0911*  	dl 0x000031 ; 11.250 08, 0.195
0404EB 38 00 00    0912*  	dl 0x000038 ; 12.656 09, 0.219
0404EE 3E 00 00    0913*  	dl 0x00003E ; 14.063 0A, 0.243
0404F1 44 00 00    0914*  	dl 0x000044 ; 15.469 0B, 0.267
0404F4 4A 00 00    0915*  	dl 0x00004A ; 16.875 0C, 0.290
0404F7 50 00 00    0916*  	dl 0x000050 ; 18.281 0D, 0.314
0404FA 56 00 00    0917*  	dl 0x000056 ; 19.688 0E, 0.337
0404FD 5C 00 00    0918*  	dl 0x00005C ; 21.094 0F, 0.360
040500 61 00 00    0919*  	dl 0x000061 ; 22.500 10, 0.383
040503 67 00 00    0920*  	dl 0x000067 ; 23.906 11, 0.405
040506 6D 00 00    0921*  	dl 0x00006D ; 25.313 12, 0.428
040509 73 00 00    0922*  	dl 0x000073 ; 26.719 13, 0.450
04050C 78 00 00    0923*  	dl 0x000078 ; 28.125 14, 0.471
04050F 7E 00 00    0924*  	dl 0x00007E ; 29.531 15, 0.493
040512 83 00 00    0925*  	dl 0x000083 ; 30.938 16, 0.514
040515 88 00 00    0926*  	dl 0x000088 ; 32.344 17, 0.535
040518 8E 00 00    0927*  	dl 0x00008E ; 33.750 18, 0.556
04051B 93 00 00    0928*  	dl 0x000093 ; 35.156 19, 0.576
04051E 98 00 00    0929*  	dl 0x000098 ; 36.563 1A, 0.596
040521 9D 00 00    0930*  	dl 0x00009D ; 37.969 1B, 0.615
040524 A2 00 00    0931*  	dl 0x0000A2 ; 39.375 1C, 0.634
040527 A7 00 00    0932*  	dl 0x0000A7 ; 40.781 1D, 0.653
04052A AB 00 00    0933*  	dl 0x0000AB ; 42.188 1E, 0.672
04052D B0 00 00    0934*  	dl 0x0000B0 ; 43.594 1F, 0.690
040530 B5 00 00    0935*  	dl 0x0000B5 ; 45.000 20, 0.707
040533 B9 00 00    0936*  	dl 0x0000B9 ; 46.406 21, 0.724
040536 BD 00 00    0937*  	dl 0x0000BD ; 47.813 22, 0.741
040539 C1 00 00    0938*  	dl 0x0000C1 ; 49.219 23, 0.757
04053C C5 00 00    0939*  	dl 0x0000C5 ; 50.625 24, 0.773
04053F C9 00 00    0940*  	dl 0x0000C9 ; 52.031 25, 0.788
040542 CD 00 00    0941*  	dl 0x0000CD ; 53.438 26, 0.803
040545 D1 00 00    0942*  	dl 0x0000D1 ; 54.844 27, 0.818
040548 D4 00 00    0943*  	dl 0x0000D4 ; 56.250 28, 0.831
04054B D8 00 00    0944*  	dl 0x0000D8 ; 57.656 29, 0.845
04054E DB 00 00    0945*  	dl 0x0000DB ; 59.063 2A, 0.858
040551 DE 00 00    0946*  	dl 0x0000DE ; 60.469 2B, 0.870
040554 E1 00 00    0947*  	dl 0x0000E1 ; 61.875 2C, 0.882
040557 E4 00 00    0948*  	dl 0x0000E4 ; 63.281 2D, 0.893
04055A E7 00 00    0949*  	dl 0x0000E7 ; 64.688 2E, 0.904
04055D EA 00 00    0950*  	dl 0x0000EA ; 66.094 2F, 0.914
040560 EC 00 00    0951*  	dl 0x0000EC ; 67.500 30, 0.924
040563 EE 00 00    0952*  	dl 0x0000EE ; 68.906 31, 0.933
040566 F1 00 00    0953*  	dl 0x0000F1 ; 70.313 32, 0.942
040569 F3 00 00    0954*  	dl 0x0000F3 ; 71.719 33, 0.950
04056C F4 00 00    0955*  	dl 0x0000F4 ; 73.125 34, 0.957
04056F F6 00 00    0956*  	dl 0x0000F6 ; 74.531 35, 0.964
040572 F8 00 00    0957*  	dl 0x0000F8 ; 75.938 36, 0.970
040575 F9 00 00    0958*  	dl 0x0000F9 ; 77.344 37, 0.976
040578 FB 00 00    0959*  	dl 0x0000FB ; 78.750 38, 0.981
04057B FC 00 00    0960*  	dl 0x0000FC ; 80.156 39, 0.985
04057E FD 00 00    0961*  	dl 0x0000FD ; 81.563 3A, 0.989
040581 FE 00 00    0962*  	dl 0x0000FE ; 82.969 3B, 0.992
040584 FE 00 00    0963*  	dl 0x0000FE ; 84.375 3C, 0.995
040587 FF 00 00    0964*  	dl 0x0000FF ; 85.781 3D, 0.997
04058A FF 00 00    0965*  	dl 0x0000FF ; 87.188 3E, 0.999
04058D FF 00 00    0966*  	dl 0x0000FF ; 88.594 3F, 1.000
040590 00 01 00    0967*  	dl 0x000100 ; 90.000 40, 1.000
040593 FF 00 00    0968*  	dl 0x0000FF ; 91.406 41, 1.000
040596 FF 00 00    0969*  	dl 0x0000FF ; 92.813 42, 0.999
040599 FF 00 00    0970*  	dl 0x0000FF ; 94.219 43, 0.997
04059C FE 00 00    0971*  	dl 0x0000FE ; 95.625 44, 0.995
04059F FE 00 00    0972*  	dl 0x0000FE ; 97.031 45, 0.992
0405A2 FD 00 00    0973*  	dl 0x0000FD ; 98.438 46, 0.989
0405A5 FC 00 00    0974*  	dl 0x0000FC ; 99.844 47, 0.985
0405A8 FB 00 00    0975*  	dl 0x0000FB ; 101.250 48, 0.981
0405AB F9 00 00    0976*  	dl 0x0000F9 ; 102.656 49, 0.976
0405AE F8 00 00    0977*  	dl 0x0000F8 ; 104.063 4A, 0.970
0405B1 F6 00 00    0978*  	dl 0x0000F6 ; 105.469 4B, 0.964
0405B4 F4 00 00    0979*  	dl 0x0000F4 ; 106.875 4C, 0.957
0405B7 F3 00 00    0980*  	dl 0x0000F3 ; 108.281 4D, 0.950
0405BA F1 00 00    0981*  	dl 0x0000F1 ; 109.688 4E, 0.942
0405BD EE 00 00    0982*  	dl 0x0000EE ; 111.094 4F, 0.933
0405C0 EC 00 00    0983*  	dl 0x0000EC ; 112.500 50, 0.924
0405C3 EA 00 00    0984*  	dl 0x0000EA ; 113.906 51, 0.914
0405C6 E7 00 00    0985*  	dl 0x0000E7 ; 115.313 52, 0.904
0405C9 E4 00 00    0986*  	dl 0x0000E4 ; 116.719 53, 0.893
0405CC E1 00 00    0987*  	dl 0x0000E1 ; 118.125 54, 0.882
0405CF DE 00 00    0988*  	dl 0x0000DE ; 119.531 55, 0.870
0405D2 DB 00 00    0989*  	dl 0x0000DB ; 120.938 56, 0.858
0405D5 D8 00 00    0990*  	dl 0x0000D8 ; 122.344 57, 0.845
0405D8 D4 00 00    0991*  	dl 0x0000D4 ; 123.750 58, 0.831
0405DB D1 00 00    0992*  	dl 0x0000D1 ; 125.156 59, 0.818
0405DE CD 00 00    0993*  	dl 0x0000CD ; 126.563 5A, 0.803
0405E1 C9 00 00    0994*  	dl 0x0000C9 ; 127.969 5B, 0.788
0405E4 C5 00 00    0995*  	dl 0x0000C5 ; 129.375 5C, 0.773
0405E7 C1 00 00    0996*  	dl 0x0000C1 ; 130.781 5D, 0.757
0405EA BD 00 00    0997*  	dl 0x0000BD ; 132.188 5E, 0.741
0405ED B9 00 00    0998*  	dl 0x0000B9 ; 133.594 5F, 0.724
0405F0 B5 00 00    0999*  	dl 0x0000B5 ; 135.000 60, 0.707
0405F3 B0 00 00    1000*  	dl 0x0000B0 ; 136.406 61, 0.690
0405F6 AB 00 00    1001*  	dl 0x0000AB ; 137.813 62, 0.672
0405F9 A7 00 00    1002*  	dl 0x0000A7 ; 139.219 63, 0.653
0405FC A2 00 00    1003*  	dl 0x0000A2 ; 140.625 64, 0.634
0405FF 9D 00 00    1004*  	dl 0x00009D ; 142.031 65, 0.615
040602 98 00 00    1005*  	dl 0x000098 ; 143.438 66, 0.596
040605 93 00 00    1006*  	dl 0x000093 ; 144.844 67, 0.576
040608 8E 00 00    1007*  	dl 0x00008E ; 146.250 68, 0.556
04060B 88 00 00    1008*  	dl 0x000088 ; 147.656 69, 0.535
04060E 83 00 00    1009*  	dl 0x000083 ; 149.063 6A, 0.514
040611 7E 00 00    1010*  	dl 0x00007E ; 150.469 6B, 0.493
040614 78 00 00    1011*  	dl 0x000078 ; 151.875 6C, 0.471
040617 73 00 00    1012*  	dl 0x000073 ; 153.281 6D, 0.450
04061A 6D 00 00    1013*  	dl 0x00006D ; 154.688 6E, 0.428
04061D 67 00 00    1014*  	dl 0x000067 ; 156.094 6F, 0.405
040620 61 00 00    1015*  	dl 0x000061 ; 157.500 70, 0.383
040623 5C 00 00    1016*  	dl 0x00005C ; 158.906 71, 0.360
040626 56 00 00    1017*  	dl 0x000056 ; 160.313 72, 0.337
040629 50 00 00    1018*  	dl 0x000050 ; 161.719 73, 0.314
04062C 4A 00 00    1019*  	dl 0x00004A ; 163.125 74, 0.290
04062F 44 00 00    1020*  	dl 0x000044 ; 164.531 75, 0.267
040632 3E 00 00    1021*  	dl 0x00003E ; 165.938 76, 0.243
040635 38 00 00    1022*  	dl 0x000038 ; 167.344 77, 0.219
040638 31 00 00    1023*  	dl 0x000031 ; 168.750 78, 0.195
04063B 2B 00 00    1024*  	dl 0x00002B ; 170.156 79, 0.171
04063E 25 00 00    1025*  	dl 0x000025 ; 171.563 7A, 0.147
040641 1F 00 00    1026*  	dl 0x00001F ; 172.969 7B, 0.122
040644 19 00 00    1027*  	dl 0x000019 ; 174.375 7C, 0.098
040647 12 00 00    1028*  	dl 0x000012 ; 175.781 7D, 0.074
04064A 0C 00 00    1029*  	dl 0x00000C ; 177.188 7E, 0.049
04064D 06 00 00    1030*  	dl 0x000006 ; 178.594 7F, 0.025
040650 00 00 00    1031*  	dl 0x000000 ; 180.000 80, 0.000
040653 FA FF FF    1032*  	dl 0xFFFFFA ; 181.406 81, -0.025
040656 F4 FF FF    1033*  	dl 0xFFFFF4 ; 182.813 82, -0.049
040659 EE FF FF    1034*  	dl 0xFFFFEE ; 184.219 83, -0.074
04065C E7 FF FF    1035*  	dl 0xFFFFE7 ; 185.625 84, -0.098
04065F E1 FF FF    1036*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040662 DB FF FF    1037*  	dl 0xFFFFDB ; 188.438 86, -0.147
040665 D5 FF FF    1038*  	dl 0xFFFFD5 ; 189.844 87, -0.171
040668 CF FF FF    1039*  	dl 0xFFFFCF ; 191.250 88, -0.195
04066B C8 FF FF    1040*  	dl 0xFFFFC8 ; 192.656 89, -0.219
04066E C2 FF FF    1041*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040671 BC FF FF    1042*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040674 B6 FF FF    1043*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040677 B0 FF FF    1044*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04067A AA FF FF    1045*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04067D A4 FF FF    1046*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040680 9F FF FF    1047*  	dl 0xFFFF9F ; 202.500 90, -0.383
040683 99 FF FF    1048*  	dl 0xFFFF99 ; 203.906 91, -0.405
040686 93 FF FF    1049*  	dl 0xFFFF93 ; 205.313 92, -0.428
040689 8D FF FF    1050*  	dl 0xFFFF8D ; 206.719 93, -0.450
04068C 88 FF FF    1051*  	dl 0xFFFF88 ; 208.125 94, -0.471
04068F 82 FF FF    1052*  	dl 0xFFFF82 ; 209.531 95, -0.493
040692 7D FF FF    1053*  	dl 0xFFFF7D ; 210.938 96, -0.514
040695 78 FF FF    1054*  	dl 0xFFFF78 ; 212.344 97, -0.535
040698 72 FF FF    1055*  	dl 0xFFFF72 ; 213.750 98, -0.556
04069B 6D FF FF    1056*  	dl 0xFFFF6D ; 215.156 99, -0.576
04069E 68 FF FF    1057*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0406A1 63 FF FF    1058*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0406A4 5E FF FF    1059*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0406A7 59 FF FF    1060*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0406AA 55 FF FF    1061*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0406AD 50 FF FF    1062*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0406B0 4B FF FF    1063*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0406B3 47 FF FF    1064*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0406B6 43 FF FF    1065*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0406B9 3F FF FF    1066*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0406BC 3B FF FF    1067*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0406BF 37 FF FF    1068*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0406C2 33 FF FF    1069*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0406C5 2F FF FF    1070*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0406C8 2C FF FF    1071*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0406CB 28 FF FF    1072*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0406CE 25 FF FF    1073*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0406D1 22 FF FF    1074*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0406D4 1F FF FF    1075*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0406D7 1C FF FF    1076*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0406DA 19 FF FF    1077*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0406DD 16 FF FF    1078*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0406E0 14 FF FF    1079*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0406E3 12 FF FF    1080*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0406E6 0F FF FF    1081*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0406E9 0D FF FF    1082*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0406EC 0C FF FF    1083*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0406EF 0A FF FF    1084*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0406F2 08 FF FF    1085*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0406F5 07 FF FF    1086*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0406F8 05 FF FF    1087*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0406FB 04 FF FF    1088*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0406FE 03 FF FF    1089*  	dl 0xFFFF03 ; 261.563 BA, -0.989
040701 02 FF FF    1090*  	dl 0xFFFF02 ; 262.969 BB, -0.992
040704 02 FF FF    1091*  	dl 0xFFFF02 ; 264.375 BC, -0.995
040707 01 FF FF    1092*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04070A 01 FF FF    1093*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04070D 01 FF FF    1094*  	dl 0xFFFF01 ; 268.594 BF, -1.000
040710 00 FF FF    1095*  	dl 0xFFFF00 ; 270.000 C0, -1.000
040713 01 FF FF    1096*  	dl 0xFFFF01 ; 271.406 C1, -1.000
040716 01 FF FF    1097*  	dl 0xFFFF01 ; 272.813 C2, -0.999
040719 01 FF FF    1098*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04071C 02 FF FF    1099*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04071F 02 FF FF    1100*  	dl 0xFFFF02 ; 277.031 C5, -0.992
040722 03 FF FF    1101*  	dl 0xFFFF03 ; 278.438 C6, -0.989
040725 04 FF FF    1102*  	dl 0xFFFF04 ; 279.844 C7, -0.985
040728 05 FF FF    1103*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04072B 07 FF FF    1104*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04072E 08 FF FF    1105*  	dl 0xFFFF08 ; 284.063 CA, -0.970
040731 0A FF FF    1106*  	dl 0xFFFF0A ; 285.469 CB, -0.964
040734 0C FF FF    1107*  	dl 0xFFFF0C ; 286.875 CC, -0.957
040737 0D FF FF    1108*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04073A 0F FF FF    1109*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04073D 12 FF FF    1110*  	dl 0xFFFF12 ; 291.094 CF, -0.933
040740 14 FF FF    1111*  	dl 0xFFFF14 ; 292.500 D0, -0.924
040743 16 FF FF    1112*  	dl 0xFFFF16 ; 293.906 D1, -0.914
040746 19 FF FF    1113*  	dl 0xFFFF19 ; 295.313 D2, -0.904
040749 1C FF FF    1114*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04074C 1F FF FF    1115*  	dl 0xFFFF1F ; 298.125 D4, -0.882
04074F 22 FF FF    1116*  	dl 0xFFFF22 ; 299.531 D5, -0.870
040752 25 FF FF    1117*  	dl 0xFFFF25 ; 300.938 D6, -0.858
040755 28 FF FF    1118*  	dl 0xFFFF28 ; 302.344 D7, -0.845
040758 2C FF FF    1119*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04075B 2F FF FF    1120*  	dl 0xFFFF2F ; 305.156 D9, -0.818
04075E 33 FF FF    1121*  	dl 0xFFFF33 ; 306.563 DA, -0.803
040761 37 FF FF    1122*  	dl 0xFFFF37 ; 307.969 DB, -0.788
040764 3B FF FF    1123*  	dl 0xFFFF3B ; 309.375 DC, -0.773
040767 3F FF FF    1124*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04076A 43 FF FF    1125*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04076D 47 FF FF    1126*  	dl 0xFFFF47 ; 313.594 DF, -0.724
040770 4B FF FF    1127*  	dl 0xFFFF4B ; 315.000 E0, -0.707
040773 50 FF FF    1128*  	dl 0xFFFF50 ; 316.406 E1, -0.690
040776 55 FF FF    1129*  	dl 0xFFFF55 ; 317.813 E2, -0.672
040779 59 FF FF    1130*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04077C 5E FF FF    1131*  	dl 0xFFFF5E ; 320.625 E4, -0.634
04077F 63 FF FF    1132*  	dl 0xFFFF63 ; 322.031 E5, -0.615
040782 68 FF FF    1133*  	dl 0xFFFF68 ; 323.438 E6, -0.596
040785 6D FF FF    1134*  	dl 0xFFFF6D ; 324.844 E7, -0.576
040788 72 FF FF    1135*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04078B 78 FF FF    1136*  	dl 0xFFFF78 ; 327.656 E9, -0.535
04078E 7D FF FF    1137*  	dl 0xFFFF7D ; 329.063 EA, -0.514
040791 82 FF FF    1138*  	dl 0xFFFF82 ; 330.469 EB, -0.493
040794 88 FF FF    1139*  	dl 0xFFFF88 ; 331.875 EC, -0.471
040797 8D FF FF    1140*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04079A 93 FF FF    1141*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04079D 99 FF FF    1142*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0407A0 9F FF FF    1143*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0407A3 A4 FF FF    1144*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0407A6 AA FF FF    1145*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0407A9 B0 FF FF    1146*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0407AC B6 FF FF    1147*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0407AF BC FF FF    1148*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0407B2 C2 FF FF    1149*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0407B5 C8 FF FF    1150*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0407B8 CF FF FF    1151*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0407BB D5 FF FF    1152*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0407BE DB FF FF    1153*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0407C1 E1 FF FF    1154*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0407C4 E7 FF FF    1155*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0407C7 EE FF FF    1156*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0407CA F4 FF FF    1157*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0407CD FA FF FF    1158*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0407D0 00 00 00    1159*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0407D3             1160*  
0407D3             1161*  atan_lut_168:
0407D3 00 00 00    1162*  	dl 0x000000 ; 000000, 0.000
0407D6 28 00 00    1163*  	dl 0x000028 ; 000001, 0.224
0407D9 51 00 00    1164*  	dl 0x000051 ; 000002, 0.448
0407DC 7A 00 00    1165*  	dl 0x00007A ; 000003, 0.671
0407DF A2 00 00    1166*  	dl 0x0000A2 ; 000004, 0.895
0407E2 CB 00 00    1167*  	dl 0x0000CB ; 000005, 1.119
0407E5 F4 00 00    1168*  	dl 0x0000F4 ; 000006, 1.343
0407E8 1D 01 00    1169*  	dl 0x00011D ; 000007, 1.566
0407EB 45 01 00    1170*  	dl 0x000145 ; 000008, 1.790
0407EE 6E 01 00    1171*  	dl 0x00016E ; 000009, 2.013
0407F1 97 01 00    1172*  	dl 0x000197 ; 00000A, 2.237
0407F4 BF 01 00    1173*  	dl 0x0001BF ; 00000B, 2.460
0407F7 E8 01 00    1174*  	dl 0x0001E8 ; 00000C, 2.684
0407FA 11 02 00    1175*  	dl 0x000211 ; 00000D, 2.907
0407FD 39 02 00    1176*  	dl 0x000239 ; 00000E, 3.130
040800 62 02 00    1177*  	dl 0x000262 ; 00000F, 3.353
040803 8B 02 00    1178*  	dl 0x00028B ; 000010, 3.576
040806 B3 02 00    1179*  	dl 0x0002B3 ; 000011, 3.799
040809 DC 02 00    1180*  	dl 0x0002DC ; 000012, 4.022
04080C 04 03 00    1181*  	dl 0x000304 ; 000013, 4.245
04080F 2D 03 00    1182*  	dl 0x00032D ; 000014, 4.467
040812 55 03 00    1183*  	dl 0x000355 ; 000015, 4.690
040815 7E 03 00    1184*  	dl 0x00037E ; 000016, 4.912
040818 A6 03 00    1185*  	dl 0x0003A6 ; 000017, 5.134
04081B CE 03 00    1186*  	dl 0x0003CE ; 000018, 5.356
04081E F7 03 00    1187*  	dl 0x0003F7 ; 000019, 5.578
040821 1F 04 00    1188*  	dl 0x00041F ; 00001A, 5.799
040824 48 04 00    1189*  	dl 0x000448 ; 00001B, 6.021
040827 70 04 00    1190*  	dl 0x000470 ; 00001C, 6.242
04082A 98 04 00    1191*  	dl 0x000498 ; 00001D, 6.463
04082D C0 04 00    1192*  	dl 0x0004C0 ; 00001E, 6.684
040830 E8 04 00    1193*  	dl 0x0004E8 ; 00001F, 6.905
040833 11 05 00    1194*  	dl 0x000511 ; 000020, 7.125
040836 39 05 00    1195*  	dl 0x000539 ; 000021, 7.345
040839 61 05 00    1196*  	dl 0x000561 ; 000022, 7.565
04083C 89 05 00    1197*  	dl 0x000589 ; 000023, 7.785
04083F B1 05 00    1198*  	dl 0x0005B1 ; 000024, 8.005
040842 D9 05 00    1199*  	dl 0x0005D9 ; 000025, 8.224
040845 01 06 00    1200*  	dl 0x000601 ; 000026, 8.443
040848 28 06 00    1201*  	dl 0x000628 ; 000027, 8.662
04084B 50 06 00    1202*  	dl 0x000650 ; 000028, 8.881
04084E 78 06 00    1203*  	dl 0x000678 ; 000029, 9.099
040851 A0 06 00    1204*  	dl 0x0006A0 ; 00002A, 9.317
040854 C7 06 00    1205*  	dl 0x0006C7 ; 00002B, 9.535
040857 EF 06 00    1206*  	dl 0x0006EF ; 00002C, 9.752
04085A 16 07 00    1207*  	dl 0x000716 ; 00002D, 9.970
04085D 3E 07 00    1208*  	dl 0x00073E ; 00002E, 10.187
040860 65 07 00    1209*  	dl 0x000765 ; 00002F, 10.403
040863 8D 07 00    1210*  	dl 0x00078D ; 000030, 10.620
040866 B4 07 00    1211*  	dl 0x0007B4 ; 000031, 10.836
040869 DB 07 00    1212*  	dl 0x0007DB ; 000032, 11.051
04086C 03 08 00    1213*  	dl 0x000803 ; 000033, 11.267
04086F 2A 08 00    1214*  	dl 0x00082A ; 000034, 11.482
040872 51 08 00    1215*  	dl 0x000851 ; 000035, 11.697
040875 78 08 00    1216*  	dl 0x000878 ; 000036, 11.911
040878 9F 08 00    1217*  	dl 0x00089F ; 000037, 12.125
04087B C6 08 00    1218*  	dl 0x0008C6 ; 000038, 12.339
04087E ED 08 00    1219*  	dl 0x0008ED ; 000039, 12.553
040881 13 09 00    1220*  	dl 0x000913 ; 00003A, 12.766
040884 3A 09 00    1221*  	dl 0x00093A ; 00003B, 12.978
040887 61 09 00    1222*  	dl 0x000961 ; 00003C, 13.191
04088A 87 09 00    1223*  	dl 0x000987 ; 00003D, 13.403
04088D AE 09 00    1224*  	dl 0x0009AE ; 00003E, 13.614
040890 D4 09 00    1225*  	dl 0x0009D4 ; 00003F, 13.825
040893 FB 09 00    1226*  	dl 0x0009FB ; 000040, 14.036
040896 21 0A 00    1227*  	dl 0x000A21 ; 000041, 14.247
040899 47 0A 00    1228*  	dl 0x000A47 ; 000042, 14.457
04089C 6D 0A 00    1229*  	dl 0x000A6D ; 000043, 14.666
04089F 94 0A 00    1230*  	dl 0x000A94 ; 000044, 14.876
0408A2 BA 0A 00    1231*  	dl 0x000ABA ; 000045, 15.085
0408A5 E0 0A 00    1232*  	dl 0x000AE0 ; 000046, 15.293
0408A8 05 0B 00    1233*  	dl 0x000B05 ; 000047, 15.501
0408AB 2B 0B 00    1234*  	dl 0x000B2B ; 000048, 15.709
0408AE 51 0B 00    1235*  	dl 0x000B51 ; 000049, 15.916
0408B1 77 0B 00    1236*  	dl 0x000B77 ; 00004A, 16.123
0408B4 9C 0B 00    1237*  	dl 0x000B9C ; 00004B, 16.329
0408B7 C2 0B 00    1238*  	dl 0x000BC2 ; 00004C, 16.535
0408BA E7 0B 00    1239*  	dl 0x000BE7 ; 00004D, 16.740
0408BD 0C 0C 00    1240*  	dl 0x000C0C ; 00004E, 16.945
0408C0 32 0C 00    1241*  	dl 0x000C32 ; 00004F, 17.150
0408C3 57 0C 00    1242*  	dl 0x000C57 ; 000050, 17.354
0408C6 7C 0C 00    1243*  	dl 0x000C7C ; 000051, 17.558
0408C9 A1 0C 00    1244*  	dl 0x000CA1 ; 000052, 17.761
0408CC C6 0C 00    1245*  	dl 0x000CC6 ; 000053, 17.964
0408CF EB 0C 00    1246*  	dl 0x000CEB ; 000054, 18.166
0408D2 0F 0D 00    1247*  	dl 0x000D0F ; 000055, 18.368
0408D5 34 0D 00    1248*  	dl 0x000D34 ; 000056, 18.569
0408D8 58 0D 00    1249*  	dl 0x000D58 ; 000057, 18.770
0408DB 7D 0D 00    1250*  	dl 0x000D7D ; 000058, 18.970
0408DE A1 0D 00    1251*  	dl 0x000DA1 ; 000059, 19.170
0408E1 C6 0D 00    1252*  	dl 0x000DC6 ; 00005A, 19.370
0408E4 EA 0D 00    1253*  	dl 0x000DEA ; 00005B, 19.569
0408E7 0E 0E 00    1254*  	dl 0x000E0E ; 00005C, 19.767
0408EA 32 0E 00    1255*  	dl 0x000E32 ; 00005D, 19.965
0408ED 56 0E 00    1256*  	dl 0x000E56 ; 00005E, 20.163
0408F0 7A 0E 00    1257*  	dl 0x000E7A ; 00005F, 20.360
0408F3 9E 0E 00    1258*  	dl 0x000E9E ; 000060, 20.556
0408F6 C1 0E 00    1259*  	dl 0x000EC1 ; 000061, 20.752
0408F9 E5 0E 00    1260*  	dl 0x000EE5 ; 000062, 20.947
0408FC 08 0F 00    1261*  	dl 0x000F08 ; 000063, 21.142
0408FF 2C 0F 00    1262*  	dl 0x000F2C ; 000064, 21.337
040902 4F 0F 00    1263*  	dl 0x000F4F ; 000065, 21.531
040905 72 0F 00    1264*  	dl 0x000F72 ; 000066, 21.724
040908 95 0F 00    1265*  	dl 0x000F95 ; 000067, 21.917
04090B B8 0F 00    1266*  	dl 0x000FB8 ; 000068, 22.109
04090E DB 0F 00    1267*  	dl 0x000FDB ; 000069, 22.301
040911 FE 0F 00    1268*  	dl 0x000FFE ; 00006A, 22.493
040914 21 10 00    1269*  	dl 0x001021 ; 00006B, 22.683
040917 44 10 00    1270*  	dl 0x001044 ; 00006C, 22.874
04091A 66 10 00    1271*  	dl 0x001066 ; 00006D, 23.063
04091D 89 10 00    1272*  	dl 0x001089 ; 00006E, 23.253
040920 AB 10 00    1273*  	dl 0x0010AB ; 00006F, 23.441
040923 CD 10 00    1274*  	dl 0x0010CD ; 000070, 23.629
040926 EF 10 00    1275*  	dl 0x0010EF ; 000071, 23.817
040929 11 11 00    1276*  	dl 0x001111 ; 000072, 24.004
04092C 33 11 00    1277*  	dl 0x001133 ; 000073, 24.191
04092F 55 11 00    1278*  	dl 0x001155 ; 000074, 24.376
040932 77 11 00    1279*  	dl 0x001177 ; 000075, 24.562
040935 99 11 00    1280*  	dl 0x001199 ; 000076, 24.747
040938 BA 11 00    1281*  	dl 0x0011BA ; 000077, 24.931
04093B DC 11 00    1282*  	dl 0x0011DC ; 000078, 25.115
04093E FD 11 00    1283*  	dl 0x0011FD ; 000079, 25.298
040941 1E 12 00    1284*  	dl 0x00121E ; 00007A, 25.481
040944 3F 12 00    1285*  	dl 0x00123F ; 00007B, 25.663
040947 60 12 00    1286*  	dl 0x001260 ; 00007C, 25.844
04094A 81 12 00    1287*  	dl 0x001281 ; 00007D, 26.025
04094D A2 12 00    1288*  	dl 0x0012A2 ; 00007E, 26.206
040950 C3 12 00    1289*  	dl 0x0012C3 ; 00007F, 26.386
040953 E4 12 00    1290*  	dl 0x0012E4 ; 000080, 26.565
040956 04 13 00    1291*  	dl 0x001304 ; 000081, 26.744
040959 25 13 00    1292*  	dl 0x001325 ; 000082, 26.922
04095C 45 13 00    1293*  	dl 0x001345 ; 000083, 27.100
04095F 65 13 00    1294*  	dl 0x001365 ; 000084, 27.277
040962 85 13 00    1295*  	dl 0x001385 ; 000085, 27.453
040965 A5 13 00    1296*  	dl 0x0013A5 ; 000086, 27.629
040968 C5 13 00    1297*  	dl 0x0013C5 ; 000087, 27.805
04096B E5 13 00    1298*  	dl 0x0013E5 ; 000088, 27.979
04096E 05 14 00    1299*  	dl 0x001405 ; 000089, 28.154
040971 24 14 00    1300*  	dl 0x001424 ; 00008A, 28.327
040974 44 14 00    1301*  	dl 0x001444 ; 00008B, 28.501
040977 63 14 00    1302*  	dl 0x001463 ; 00008C, 28.673
04097A 83 14 00    1303*  	dl 0x001483 ; 00008D, 28.845
04097D A2 14 00    1304*  	dl 0x0014A2 ; 00008E, 29.017
040980 C1 14 00    1305*  	dl 0x0014C1 ; 00008F, 29.187
040983 E0 14 00    1306*  	dl 0x0014E0 ; 000090, 29.358
040986 FF 14 00    1307*  	dl 0x0014FF ; 000091, 29.527
040989 1E 15 00    1308*  	dl 0x00151E ; 000092, 29.697
04098C 3C 15 00    1309*  	dl 0x00153C ; 000093, 29.865
04098F 5B 15 00    1310*  	dl 0x00155B ; 000094, 30.033
040992 79 15 00    1311*  	dl 0x001579 ; 000095, 30.201
040995 98 15 00    1312*  	dl 0x001598 ; 000096, 30.368
040998 B6 15 00    1313*  	dl 0x0015B6 ; 000097, 30.534
04099B D4 15 00    1314*  	dl 0x0015D4 ; 000098, 30.700
04099E F2 15 00    1315*  	dl 0x0015F2 ; 000099, 30.865
0409A1 10 16 00    1316*  	dl 0x001610 ; 00009A, 31.030
0409A4 2E 16 00    1317*  	dl 0x00162E ; 00009B, 31.194
0409A7 4C 16 00    1318*  	dl 0x00164C ; 00009C, 31.357
0409AA 6A 16 00    1319*  	dl 0x00166A ; 00009D, 31.520
0409AD 87 16 00    1320*  	dl 0x001687 ; 00009E, 31.682
0409B0 A5 16 00    1321*  	dl 0x0016A5 ; 00009F, 31.844
0409B3 C2 16 00    1322*  	dl 0x0016C2 ; 0000A0, 32.005
0409B6 DF 16 00    1323*  	dl 0x0016DF ; 0000A1, 32.166
0409B9 FC 16 00    1324*  	dl 0x0016FC ; 0000A2, 32.326
0409BC 19 17 00    1325*  	dl 0x001719 ; 0000A3, 32.486
0409BF 36 17 00    1326*  	dl 0x001736 ; 0000A4, 32.645
0409C2 53 17 00    1327*  	dl 0x001753 ; 0000A5, 32.803
0409C5 70 17 00    1328*  	dl 0x001770 ; 0000A6, 32.961
0409C8 8C 17 00    1329*  	dl 0x00178C ; 0000A7, 33.118
0409CB A9 17 00    1330*  	dl 0x0017A9 ; 0000A8, 33.275
0409CE C5 17 00    1331*  	dl 0x0017C5 ; 0000A9, 33.431
0409D1 E2 17 00    1332*  	dl 0x0017E2 ; 0000AA, 33.587
0409D4 FE 17 00    1333*  	dl 0x0017FE ; 0000AB, 33.742
0409D7 1A 18 00    1334*  	dl 0x00181A ; 0000AC, 33.896
0409DA 36 18 00    1335*  	dl 0x001836 ; 0000AD, 34.050
0409DD 52 18 00    1336*  	dl 0x001852 ; 0000AE, 34.203
0409E0 6E 18 00    1337*  	dl 0x00186E ; 0000AF, 34.356
0409E3 8A 18 00    1338*  	dl 0x00188A ; 0000B0, 34.509
0409E6 A5 18 00    1339*  	dl 0x0018A5 ; 0000B1, 34.660
0409E9 C1 18 00    1340*  	dl 0x0018C1 ; 0000B2, 34.811
0409EC DC 18 00    1341*  	dl 0x0018DC ; 0000B3, 34.962
0409EF F7 18 00    1342*  	dl 0x0018F7 ; 0000B4, 35.112
0409F2 13 19 00    1343*  	dl 0x001913 ; 0000B5, 35.262
0409F5 2E 19 00    1344*  	dl 0x00192E ; 0000B6, 35.410
0409F8 49 19 00    1345*  	dl 0x001949 ; 0000B7, 35.559
0409FB 64 19 00    1346*  	dl 0x001964 ; 0000B8, 35.707
0409FE 7F 19 00    1347*  	dl 0x00197F ; 0000B9, 35.854
040A01 99 19 00    1348*  	dl 0x001999 ; 0000BA, 36.001
040A04 B4 19 00    1349*  	dl 0x0019B4 ; 0000BB, 36.147
040A07 CE 19 00    1350*  	dl 0x0019CE ; 0000BC, 36.293
040A0A E9 19 00    1351*  	dl 0x0019E9 ; 0000BD, 36.438
040A0D 03 1A 00    1352*  	dl 0x001A03 ; 0000BE, 36.582
040A10 1D 1A 00    1353*  	dl 0x001A1D ; 0000BF, 36.726
040A13 37 1A 00    1354*  	dl 0x001A37 ; 0000C0, 36.870
040A16 51 1A 00    1355*  	dl 0x001A51 ; 0000C1, 37.013
040A19 6B 1A 00    1356*  	dl 0x001A6B ; 0000C2, 37.155
040A1C 85 1A 00    1357*  	dl 0x001A85 ; 0000C3, 37.297
040A1F 9F 1A 00    1358*  	dl 0x001A9F ; 0000C4, 37.439
040A22 B9 1A 00    1359*  	dl 0x001AB9 ; 0000C5, 37.579
040A25 D2 1A 00    1360*  	dl 0x001AD2 ; 0000C6, 37.720
040A28 EC 1A 00    1361*  	dl 0x001AEC ; 0000C7, 37.859
040A2B 05 1B 00    1362*  	dl 0x001B05 ; 0000C8, 37.999
040A2E 1E 1B 00    1363*  	dl 0x001B1E ; 0000C9, 38.137
040A31 37 1B 00    1364*  	dl 0x001B37 ; 0000CA, 38.276
040A34 50 1B 00    1365*  	dl 0x001B50 ; 0000CB, 38.413
040A37 69 1B 00    1366*  	dl 0x001B69 ; 0000CC, 38.550
040A3A 82 1B 00    1367*  	dl 0x001B82 ; 0000CD, 38.687
040A3D 9B 1B 00    1368*  	dl 0x001B9B ; 0000CE, 38.823
040A40 B4 1B 00    1369*  	dl 0x001BB4 ; 0000CF, 38.959
040A43 CC 1B 00    1370*  	dl 0x001BCC ; 0000D0, 39.094
040A46 E5 1B 00    1371*  	dl 0x001BE5 ; 0000D1, 39.228
040A49 FD 1B 00    1372*  	dl 0x001BFD ; 0000D2, 39.362
040A4C 16 1C 00    1373*  	dl 0x001C16 ; 0000D3, 39.496
040A4F 2E 1C 00    1374*  	dl 0x001C2E ; 0000D4, 39.629
040A52 46 1C 00    1375*  	dl 0x001C46 ; 0000D5, 39.762
040A55 5E 1C 00    1376*  	dl 0x001C5E ; 0000D6, 39.894
040A58 76 1C 00    1377*  	dl 0x001C76 ; 0000D7, 40.025
040A5B 8E 1C 00    1378*  	dl 0x001C8E ; 0000D8, 40.156
040A5E A5 1C 00    1379*  	dl 0x001CA5 ; 0000D9, 40.286
040A61 BD 1C 00    1380*  	dl 0x001CBD ; 0000DA, 40.416
040A64 D5 1C 00    1381*  	dl 0x001CD5 ; 0000DB, 40.546
040A67 EC 1C 00    1382*  	dl 0x001CEC ; 0000DC, 40.675
040A6A 04 1D 00    1383*  	dl 0x001D04 ; 0000DD, 40.803
040A6D 1B 1D 00    1384*  	dl 0x001D1B ; 0000DE, 40.931
040A70 32 1D 00    1385*  	dl 0x001D32 ; 0000DF, 41.059
040A73 49 1D 00    1386*  	dl 0x001D49 ; 0000E0, 41.186
040A76 60 1D 00    1387*  	dl 0x001D60 ; 0000E1, 41.312
040A79 77 1D 00    1388*  	dl 0x001D77 ; 0000E2, 41.438
040A7C 8E 1D 00    1389*  	dl 0x001D8E ; 0000E3, 41.564
040A7F A5 1D 00    1390*  	dl 0x001DA5 ; 0000E4, 41.689
040A82 BB 1D 00    1391*  	dl 0x001DBB ; 0000E5, 41.814
040A85 D2 1D 00    1392*  	dl 0x001DD2 ; 0000E6, 41.938
040A88 E9 1D 00    1393*  	dl 0x001DE9 ; 0000E7, 42.061
040A8B FF 1D 00    1394*  	dl 0x001DFF ; 0000E8, 42.184
040A8E 15 1E 00    1395*  	dl 0x001E15 ; 0000E9, 42.307
040A91 2C 1E 00    1396*  	dl 0x001E2C ; 0000EA, 42.429
040A94 42 1E 00    1397*  	dl 0x001E42 ; 0000EB, 42.551
040A97 58 1E 00    1398*  	dl 0x001E58 ; 0000EC, 42.672
040A9A 6E 1E 00    1399*  	dl 0x001E6E ; 0000ED, 42.793
040A9D 84 1E 00    1400*  	dl 0x001E84 ; 0000EE, 42.913
040AA0 99 1E 00    1401*  	dl 0x001E99 ; 0000EF, 43.033
040AA3 AF 1E 00    1402*  	dl 0x001EAF ; 0000F0, 43.152
040AA6 C5 1E 00    1403*  	dl 0x001EC5 ; 0000F1, 43.271
040AA9 DA 1E 00    1404*  	dl 0x001EDA ; 0000F2, 43.390
040AAC F0 1E 00    1405*  	dl 0x001EF0 ; 0000F3, 43.508
040AAF 05 1F 00    1406*  	dl 0x001F05 ; 0000F4, 43.625
040AB2 1B 1F 00    1407*  	dl 0x001F1B ; 0000F5, 43.742
040AB5 30 1F 00    1408*  	dl 0x001F30 ; 0000F6, 43.859
040AB8 45 1F 00    1409*  	dl 0x001F45 ; 0000F7, 43.975
040ABB 5A 1F 00    1410*  	dl 0x001F5A ; 0000F8, 44.091
040ABE 6F 1F 00    1411*  	dl 0x001F6F ; 0000F9, 44.206
040AC1 84 1F 00    1412*  	dl 0x001F84 ; 0000FA, 44.321
040AC4 99 1F 00    1413*  	dl 0x001F99 ; 0000FB, 44.435
040AC7 AD 1F 00    1414*  	dl 0x001FAD ; 0000FC, 44.549
040ACA C2 1F 00    1415*  	dl 0x001FC2 ; 0000FD, 44.662
040ACD D7 1F 00    1416*  	dl 0x001FD7 ; 0000FE, 44.775
040AD0 EB 1F 00    1417*  	dl 0x001FEB ; 0000FF, 44.888
040AD3 00 20 00    1418*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
040AD6             1419*  
040AD6             1420*  	; include "functions.inc"
040AD6             1421*  
040AD6             1422*      MACRO printChar char
040AD6             1423*          LD A, char
040AD6             1424*          RST.LIL 10h
040AD6             1425*      ENDMACRO
040AD6             1426*  
040AD6             1427*  ; put the value in HLU into the accumulator
040AD6             1428*  ; destroys: af
040AD6             1429*      MACRO HLU_TO_A
040AD6             1430*          push hl ; 4 cycles
040AD6             1431*          inc sp ; 1 cycle
040AD6             1432*          pop af  ; 4 cycles
040AD6             1433*          dec sp ; 1 cycle
040AD6             1434*                 ; 10 cycles total
040AD6             1435*      ENDMACRO
040AD6             1436*  
040AD6             1437*  ; put the value in the accumulator into HLU
040AD6             1438*  ; destroys a
040AD6             1439*  A_TO_HLU:
040AD6             1440*      ; call is 7 cycles
040AD6 22 E3 0A 04 1441*      ld (@scratch),hl ; 7 cycles
040ADA 32 E5 0A 04 1442*      ld (@scratch+2),a ; 5 cycles
040ADE 2A E3 0A 04 1443*      ld hl,(@scratch) ; 7 cycles
040AE2 C9          1444*      ret ; 6 cycles
040AE3             1445*          ; 25 cycles total
040AE3 00 00 00    1446*  @scratch: dl 0
040AE6             1447*  
040AE6             1448*  
040AE6             1449*  ; Print a zero-terminated string inline with code, e.g.:
040AE6             1450*  ;
040AE6             1451*  ;    call printInline
040AE6             1452*  ;    ASCIZ "Hello, world!\r\n"
040AE6             1453*  ;
040AE6             1454*  ; Destroys: HL,AF
040AE6             1455*  printInline:
040AE6 E1          1456*      pop hl ; get the return address = pointer to start of string
040AE7 CD ED 0A 04 1457*      call printString ; HL advances to end of string
040AEB E5          1458*      push hl ; restore the return address = pointer to end of string
040AEC C9          1459*      ret
040AED             1460*  
040AED             1461*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040AED             1462*  ; Print a zero-terminated string
040AED             1463*  ; HL: Pointer to string
040AED             1464*  printString:
040AED C5          1465*  	PUSH	BC
040AEE 01 00 00 00 1466*  	LD		BC,0
040AF2 3E 00       1467*  	LD 	 	A,0
040AF4 5B DF       1468*  	RST.LIL 18h
040AF6 C1          1469*  	POP		BC
040AF7 C9          1470*  	RET
040AF8             1471*  ; print a VDU sequence
040AF8             1472*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040AF8             1473*  sendVDUsequence:
040AF8 C5          1474*  	PUSH	BC
040AF9 01 00 00 00 1475*  	LD		BC, 0
040AFD 4E          1476*  	LD		C, (HL)
040AFE 5B DF       1477*  	RST.LIL	18h
040B00 C1          1478*  	POP		BC
040B01 C9          1479*  	RET
040B02             1480*  ; Print Newline sequence to VDP
040B02             1481*  printNewLine:
040B02 F5          1482*      push af ; for some reason rst.lil 10h sets carry flag
040B03 3E 0D       1483*  	LD	A, '\r'
040B05 5B D7       1484*  	RST.LIL 10h
040B07 3E 0A       1485*  	LD	A, '\n'
040B09 5B D7       1486*  	RST.LIL 10h
040B0B F1          1487*      pop af
040B0C C9          1488*  	RET
040B0D             1489*  
040B0D             1490*  ; Print a 24-bit HEX number
040B0D             1491*  ; HLU: Number to print
040B0D             1492*  printHex24:
040B0D             1493*      HLU_TO_A
040B0D E5          0001*M         push hl ; 4 cycles
040B0E 33          0002*M         inc sp ; 1 cycle
040B0F F1          0003*M         pop af  ; 4 cycles
040B10 3B          0004*M         dec sp ; 1 cycle
040B11             0005*M                ; 10 cycles total
040B11 CD 1B 0B 04 1494*  	CALL	printHex8
040B15             1495*  ; Print a 16-bit HEX number
040B15             1496*  ; HL: Number to print
040B15             1497*  printHex16:
040B15 7C          1498*  	LD		A,H
040B16 CD 1B 0B 04 1499*  	CALL	printHex8
040B1A 7D          1500*  	LD		A,L
040B1B             1501*  ; Print an 8-bit HEX number
040B1B             1502*  ; A: Number to print
040B1B             1503*  printHex8:
040B1B 4F          1504*  	LD		C,A
040B1C 1F          1505*  	RRA
040B1D 1F          1506*  	RRA
040B1E 1F          1507*  	RRA
040B1F 1F          1508*  	RRA
040B20 CD 25 0B 04 1509*  	CALL	@F
040B24 79          1510*  	LD		A,C
040B25             1511*  @@:
040B25 E6 0F       1512*  	AND		0Fh
040B27 C6 90       1513*  	ADD		A,90h
040B29 27          1514*  	DAA
040B2A CE 40       1515*  	ADC		A,40h
040B2C 27          1516*  	DAA
040B2D 5B D7       1517*  	RST.LIL	10h
040B2F C9          1518*  	RET
040B30             1519*  
040B30             1520*  printHexUHL:
040B30 E5          1521*  	push hl
040B31 CD 0D 0B 04 1522*  	call printHex24
040B35 E1          1523*  	pop hl
040B36 C9          1524*  	ret
040B37             1525*  
040B37             1526*  ; Prints the right justified decimal value in HL without leading zeroes
040B37             1527*  ; HL : Value to print
040B37             1528*  ; preserves all registers and flags
040B37             1529*  printDec:
040B37             1530*  ; BEGIN MY CODE
040B37             1531*  ; back up all the things
040B37 F5          1532*      push af
040B38 C5          1533*      push bc
040B39 D5          1534*      push de
040B3A E5          1535*      push hl
040B3B             1536*  ; END MY CODE
040B3B 11 63 0B 04 1537*  	LD	 DE, _printDecBuffer
040B3F CD 73 0B 04 1538*  	CALL u24_to_ascii
040B43             1539*  ; BEGIN MY CODE
040B43             1540*  ; replace leading zeroes with spaces
040B43 21 63 0B 04 1541*      LD	 HL, _printDecBuffer
040B47 06 07       1542*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040B49             1543*  @loop:
040B49 7E          1544*      LD	 A, (HL)
040B4A FE 30       1545*      CP	 '0'
040B4C C2 56 0B 04 1546*      JP	 NZ, @done
040B50 3E 20       1547*      LD   A, ' '
040B52 77          1548*      LD	 (HL), A
040B53 23          1549*      INC	 HL
040B54             1550*      ; CALL vdu_cursor_forward
040B54 10 F3       1551*      DJNZ @loop
040B56             1552*  @done:
040B56             1553*  ; END MY CODE
040B56 21 63 0B 04 1554*  	LD	 HL, _printDecBuffer
040B5A CD ED 0A 04 1555*  	CALL printString
040B5E             1556*  ; BEGIN MY CODE
040B5E             1557*  ; restore all the things
040B5E E1          1558*      pop hl
040B5F D1          1559*      pop de
040B60 C1          1560*      pop bc
040B61 F1          1561*      pop af
040B62             1562*  ; END MY CODE
040B62 C9          1563*  	RET
040B63 00 00 00 00 1564*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B73             1565*  
040B73             1566*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040B73             1567*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040B73             1568*  ; so it will allways be 8 characters length
040B73             1569*  ; HL : Value to convert to string
040B73             1570*  ; DE : pointer to buffer, at least 8 byte + 0
040B73             1571*  u24_to_ascii:
040B73 01 80 69 67 1572*  	LD	 BC,-10000000
040B77 CD AA 0B 04 1573*  	CALL @one_digit
040B7B 01 C0 BD F0 1574*  	LD	 BC,-1000000
040B7F CD AA 0B 04 1575*  	CALL @one_digit
040B83 01 60 79 FE 1576*  	LD	 BC,-100000
040B87 CD AA 0B 04 1577*  	CALL @one_digit
040B8B 01 F0 D8 FF 1578*  	LD   BC,-10000
040B8F CD AA 0B 04 1579*  	CALL @one_digit
040B93 01 18 FC FF 1580*  	LD   BC,-1000
040B97 CD AA 0B 04 1581*  	CALL @one_digit
040B9B 01 9C FF FF 1582*  	LD   BC,-100
040B9F CD AA 0B 04 1583*  	CALL @one_digit
040BA3 0E F6       1584*  	LD   C,-10
040BA5 CD AA 0B 04 1585*  	CALL @one_digit
040BA9 48          1586*  	LD   C,B
040BAA             1587*  @one_digit:
040BAA 3E 2F       1588*  	LD   A,'0'-1
040BAC             1589*  @divide_me:
040BAC 3C          1590*  	INC  A
040BAD 09          1591*  	ADD  HL,BC
040BAE 38 FC       1592*  	JR   C,@divide_me
040BB0 ED 42       1593*  	SBC  HL,BC
040BB2 12          1594*  	LD   (DE),A
040BB3 13          1595*  	INC  DE
040BB4 C9          1596*  	RET
040BB5             1597*  
040BB5             1598*  print_u24:
040BB5 D5          1599*      push de
040BB6 E5          1600*      push hl
040BB7 11 63 0B 04 1601*      ld de,_printDecBuffer
040BBB CD 73 0B 04 1602*      call u24_to_ascii
040BBF 21 63 0B 04 1603*      ld hl,_printDecBuffer
040BC3 CD ED 0A 04 1604*      call printString
040BC7 3E 20       1605*      ld a,' '
040BC9 5B D7       1606*      rst.lil 10h
040BCB E1          1607*      pop hl
040BCC D1          1608*      pop de
040BCD C9          1609*      ret
040BCE             1610*  
040BCE             1611*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040BCE             1612*  ; HL : Value to convert to string (integer part in H, fractional part in L)
040BCE             1613*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040BCE             1614*  u168_to_ascii:
040BCE             1615*  ; add a leading space to make room for sign flag if needed
040BCE 3E 20       1616*      ld a,' '
040BD0 12          1617*      ld (de),a
040BD1 13          1618*      inc de
040BD2             1619*  ; Convert integer part
040BD2 E5          1620*      push hl               ; Save HL (well need the fractional part later)
040BD3 CD 7B 00 04 1621*      call hlu_udiv256    ; Shift to get integer portion in HL
040BD7 01 F0 D8 FF 1622*      ld   bc, -10000
040BDB CD FE 0B 04 1623*      call @one_int
040BDF 01 18 FC FF 1624*      ld   bc, -1000
040BE3 CD FE 0B 04 1625*      call @one_int
040BE7 01 9C FF FF 1626*      ld   bc, -100
040BEB CD FE 0B 04 1627*      call @one_int
040BEF 0E F6       1628*      ld   c, -10
040BF1 CD FE 0B 04 1629*      call @one_int
040BF5 48          1630*      ld   c, b
040BF6 CD FE 0B 04 1631*      call @one_int
040BFA C3 09 0C 04 1632*      jp   @frac            ; Jump to fractional part conversion
040BFE             1633*  @one_int:
040BFE 3E 2F       1634*      ld   a, '0' - 1       ; Start ASCII character at '0'
040C00             1635*  @divide_me:
040C00 3C          1636*      inc  a
040C01 09          1637*      add  hl, bc           ; Accumulate until overflow
040C02 38 FC       1638*      jr   c, @divide_me
040C04 ED 42       1639*      sbc  hl, bc           ; Remove excess after overflow
040C06 12          1640*      ld   (de), a          ; Store ASCII digit
040C07 13          1641*      inc  de
040C08 C9          1642*      ret
040C09             1643*  ; Convert fractional part
040C09             1644*  @frac:
040C09 3E 2E       1645*      ld   a, '.'           ; Decimal point
040C0B 12          1646*      ld   (de), a
040C0C 13          1647*      inc  de
040C0D E1          1648*      pop  hl               ; Restore HL with original fraction
040C0E 06 03       1649*      ld   b, 3             ; Loop counter for 3 fractional digits
040C10             1650*  @frac_loop:
040C10 26 0A       1651*      ld   h, 10            ; Load multiplier for fractional part
040C12 ED 6C       1652*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040C14 3E 30       1653*      ld   a, '0'
040C16 84          1654*      add  a, h             ; Convert integer part to ASCII
040C17 12          1655*      ld   (de), a
040C18 13          1656*      inc  de
040C19 10 F5       1657*      djnz @frac_loop       ; Repeat for each fractional digit
040C1B             1658*  ; Add null terminator
040C1B AF          1659*      xor  a                ; Null terminator
040C1C 12          1660*      ld   (de), a
040C1D C9          1661*      ret
040C1E             1662*  
040C1E             1663*  print_u168:
040C1E D5          1664*      push de
040C1F E5          1665*      push hl
040C20 11 63 0B 04 1666*      ld de,_printDecBuffer
040C24 CD CE 0B 04 1667*      call u168_to_ascii
040C28 21 63 0B 04 1668*      ld hl,_printDecBuffer
040C2C CD ED 0A 04 1669*      call printString
040C30 E1          1670*      pop hl
040C31 D1          1671*      pop de
040C32 C9          1672*      ret
040C33             1673*  
040C33             1674*  ; signed version of u168_to_ascii
040C33             1675*  s168_to_ascii:
040C33 D5          1676*      push de ; save starting address of buffer
040C34 CD 8E 00 04 1677*      call hlu_abs
040C38 F5          1678*      push af ; save sign flag
040C39 CD CE 0B 04 1679*      call u168_to_ascii
040C3D F1          1680*      pop af ; restore sign flag
040C3E D1          1681*      pop de ; restore starting address of buffer
040C3F F0          1682*      ret p ; hlu was positive so nothing to do
040C40 3E 2D       1683*      ld a,'-'
040C42 12          1684*      ld (de),a
040C43 C9          1685*      ret
040C44             1686*  
040C44             1687*  print_s168:
040C44 D5          1688*      push de
040C45 E5          1689*      push hl
040C46 11 63 0B 04 1690*      ld de,_printDecBuffer
040C4A CD 33 0C 04 1691*      call s168_to_ascii
040C4E 21 63 0B 04 1692*      ld hl,_printDecBuffer
040C52 CD ED 0A 04 1693*      call printString
040C56 E1          1694*      pop hl
040C57 D1          1695*      pop de
040C58 C9          1696*      ret
040C59             1697*  
040C59             1698*  	; include "parse.inc"
040C59             1699*  
040C59             1700*  ;
040C59             1701*  ; Title:	Number Parsing Functions
040C59             1702*  ; Author:	Dean Belfield
040C59             1703*  ; Created:	15/11/2022
040C59             1704*  ; Last Updated:	15/11/2022
040C59             1705*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
040C59             1706*  ; Modinfo:
040C59             1707*  ; 2024/04/08    Adapt for ez80asm
040C59             1708*  
040C59             1709*  ; Read a number and convert to binary
040C59             1710*  ; If prefixed with &, will read as hex, otherwise decimal
040C59             1711*  ;   Inputs: HL: Pointer in string buffer
040C59             1712*  ;  Outputs: HL: Updated text pointer
040C59             1713*  ;           DE: Value
040C59             1714*  ;            A: Terminator (spaces skipped)
040C59             1715*  ;            F: Carry set if valid number, otherwise reset
040C59             1716*  ; Destroys: A,D,E,H,L,F
040C59             1717*  ;
040C59 11 00 00 00 1718*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
040C5D             1719*  			; CALL		_skip_spaces		; Skip whitespace
040C5D 7E          1720*  			LD		A, (HL)			; Read first character
040C5E B7          1721*  			OR		A			; Check for end of string
040C5F C8          1722*  			RET		Z			; Return with no carry if not
040C60 C5          1723*  			PUSH		BC			; Preserve BC
040C61 FE 26       1724*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
040C63 20 23       1725*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
040C65 23          1726*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
040C66             1727*  ;
040C66 7E          1728*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
040C67 CD A9 0C 04 1729*  			CALL   	 	UPPRC			; Convert to uppercase
040C6B D6 30       1730*  			SUB		'0'			; Normalise to 0
040C6D 38 37       1731*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040C6F FE 0A       1732*  			CP 		10			; Check if >= 10
040C71 38 06       1733*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
040C73 D6 07       1734*  			SUB 		7			; Adjust ASCII A-F to nibble
040C75 FE 10       1735*  			CP 		16			; Check for > F
040C77 30 2D       1736*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
040C79             1737*  ;
040C79 E5          1738*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
040C7A D5          1739*  			PUSH		DE			; LD HL, DE
040C7B E1          1740*  			POP		HL
040C7C 29          1741*  			ADD		HL, HL
040C7D 29          1742*  			ADD		HL, HL
040C7E 29          1743*  			ADD		HL, HL
040C7F 29          1744*  			ADD		HL, HL
040C80 E5          1745*  			PUSH		HL			; LD DE, HL
040C81 D1          1746*  			POP		DE
040C82 E1          1747*  			POP		HL			; Restore HL
040C83 B3          1748*  			OR      	E			; OR the new digit in to the least significant nibble
040C84 5F          1749*  			LD      	E, A
040C85             1750*  ;
040C85 23          1751*  			INC		HL			; Onto the next character
040C86 18 DE       1752*  			JR      	ASC_TO_NUMBER1		; And loop
040C88             1753*  ;
040C88 7E          1754*  ASC_TO_NUMBER3:		LD		A, (HL)
040C89 D6 30       1755*  			SUB		'0'			; Normalise to 0
040C8B 38 19       1756*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040C8D FE 0A       1757*  			CP		10			; Check if >= 10
040C8F 30 15       1758*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
040C91             1759*  ;
040C91 E5          1760*  			PUSH		HL			; Stack HL
040C92 D5          1761*  			PUSH		DE			; LD HL, DE
040C93 E1          1762*  			POP		HL
040C94 E5          1763*  			PUSH		HL			; LD BC, HL
040C95 C1          1764*  			POP		BC
040C96 29          1765*  			ADD		HL, HL 			; x 2
040C97 29          1766*  			ADD		HL, HL 			; x 4
040C98 09          1767*  			ADD		HL, BC 			; x 5
040C99 29          1768*  			ADD		HL, HL 			; x 10
040C9A 01 00 00 00 1769*  			LD		BC, 0
040C9E 4F          1770*  			LD 		C, A			; LD BCU, A
040C9F 09          1771*  			ADD		HL, BC			; Add BCU to HL
040CA0 E5          1772*  			PUSH		HL			; LD DE, HL
040CA1 D1          1773*  			POP		DE
040CA2 E1          1774*  			POP		HL			; Restore HL
040CA3             1775*  ;
040CA3 23          1776*  			INC		HL
040CA4 18 E2       1777*  			JR		ASC_TO_NUMBER3
040CA6 C1          1778*  ASC_TO_NUMBER4:		POP		BC
040CA7 37          1779*  			SCF					; We have a valid number so set carry
040CA8 C9          1780*  			RET
040CA9             1781*  
040CA9             1782*  
040CA9             1783*  ; Convert a character to upper case
040CA9             1784*  ;  A: Character to convert
040CA9             1785*  ;
040CA9 E6 7F       1786*  UPPRC:  		AND     	7FH
040CAB FE 60       1787*  			CP      	'`'
040CAD D8          1788*  			RET     	C
040CAE E6 5F       1789*  			AND     	5FH			; Convert to upper case
040CB0 C9          1790*  			RET
040CB1             1791*  
040CB1             1792*  ; -----------------------------------------------------------------------
040CB1             1793*  ;
040CB1             1794*  ; additional functions by Brandon R. Gates based on Dean's code
040CB1             1795*  ;
040CB1             1796*  ;------------------------------------------------------------------------
040CB1             1797*  ; Read a number and convert to binary (decimal only)
040CB1             1798*  ; Inputs: hl: Pointer in string buffer
040CB1             1799*  ; Outputs: hl: Updated text pointer
040CB1             1800*  ;         de: Value
040CB1             1801*  ;         a: Terminator (spaces skipped)
040CB1             1802*  ;         f: Carry set if valid number, otherwise reset
040CB1             1803*  ; Destroys: a, d, e, h, l, f
040CB1             1804*  ;------------------------------------------------------------------------
040CB1             1805*  asc_to_s24:
040CB1 3E 01       1806*      ld a,1 ; set sign flag
040CB3 32 FF 0C 04 1807*      ld (@sign),a ; store sign flag
040CB7             1808*  
040CB7 11 00 00 00 1809*      ld de, 0 ; initialise de
040CBB             1810*      ; call _skip_spaces ; skip whitespace
040CBB             1811*  
040CBB 7E          1812*      ld a, (hl) ; read first character
040CBC B7          1813*      or a ; check for end of string
040CBD C8          1814*      ret z ; return with no carry if not
040CBE             1815*  
040CBE C5          1816*      push bc ; preserve bc
040CBF             1817*  
040CBF FE 2D       1818*      cp '-' ; check for negative number
040CC1 C2 CB 0C 04 1819*      jp nz,@loop ; number is positive, nothing more to do
040CC5 AF          1820*      xor a ; sign flag to zero
040CC6 32 FF 0C 04 1821*      ld (@sign),a ; store sign flag
040CCA 23          1822*      inc hl ; skip '-'
040CCB             1823*  
040CCB             1824*  @loop:
040CCB 7E          1825*      ld a, (hl)
040CCC D6 30       1826*      sub '0' ; normalise to 0
040CCE 38 19       1827*      jr c, @integer_end ; return if < ascii '0'
040CD0 FE 0A       1828*      cp 10 ; check if >= 10
040CD2 30 15       1829*      jr nc, @integer_end ; return if >= 10
040CD4 E5          1830*      push hl ; stack hl
040CD5 D5          1831*      push de ; ld hl, de
040CD6 E1          1832*      pop hl
040CD7 E5          1833*      push hl ; ld bc, hl
040CD8 C1          1834*      pop bc
040CD9 29          1835*      add hl, hl ; x 2
040CDA 29          1836*      add hl, hl ; x 4
040CDB 09          1837*      add hl, bc ; x 5
040CDC 29          1838*      add hl, hl ; x 10
040CDD 01 00 00 00 1839*      ld bc, 0
040CE1 4F          1840*      ld c, a ; ld bcu, a
040CE2 09          1841*      add hl, bc ; add bcu to hl
040CE3 E5          1842*      push hl ; ld de, hl
040CE4 D1          1843*      pop de
040CE5 E1          1844*      pop hl ; restore hl
040CE6 23          1845*      inc hl
040CE7 18 E2       1846*      jr @loop
040CE9             1847*  
040CE9             1848*  @integer_end:
040CE9 C1          1849*      pop bc ; send bc back how she came in
040CEA 3A FF 0C 04 1850*      ld a, (@sign) ; get sign flag
040CEE 3D          1851*      dec a ; check if negative
040CEF F2 FD 0C 04 1852*      jp p,@pos ; positive number
040CF3             1853*  
040CF3             1854*  ; Negate de
040CF3 E5          1855*      push hl ; save text pointer
040CF4 21 00 00 00 1856*      ld hl, 0
040CF8 AF          1857*      xor a ; clear carry
040CF9 ED 52       1858*      sbc hl, de ; subtract DE from HL
040CFB EB          1859*      ex de, hl ; DE = 0-HL
040CFC E1          1860*      pop hl ; restore text pointer
040CFD             1861*  
040CFD             1862*  @pos:
040CFD 37          1863*      scf ; we have a valid number so set carry
040CFE C9          1864*      ret
040CFF             1865*  
040CFF 00          1866*  @sign: db 0 ; sign flag buffer
040D00             1867*  
040D00             1868*  
040D00             1869*  ;------------------------------------------------------------------------
040D00             1870*  ; Read a number and convert to binary (decimal only)
040D00             1871*  ; Inputs: hl: Pointer in string buffer
040D00             1872*  ; Outputs: hl: Updated text pointer
040D00             1873*  ;         de: Value
040D00             1874*  ;         a: Terminator (spaces skipped)
040D00             1875*  ;         f: Carry set if valid number, otherwise reset
040D00             1876*  ; Destroys: a, d, e, h, l, f
040D00             1877*  ;------------------------------------------------------------------------
040D00             1878*  asc_to_s168:
040D00 3E 01       1879*      ld a,1 ; set sign flag
040D02 32 BF 0D 04 1880*      ld (@sign),a ; store sign flag
040D06             1881*  
040D06 11 00 00 00 1882*      ld de, 0 ; initialise de
040D0A ED 53 B7 0D 1883*      ld (@result), de ; clear low bytes of result buffer
       04          
040D0F ED 53 BB 0D 1884*      ld (@scratch), de ; clear low bytes of scratch buffer
       04          
040D14             1885*  
040D14             1886*      ; call _skip_spaces ; skip whitespace
040D14             1887*  
040D14 7E          1888*      ld a, (hl) ; read first character
040D15 B7          1889*      or a ; check for end of string
040D16 C8          1890*      ret z ; return with no carry if not
040D17             1891*  
040D17 C5          1892*      push bc ; preserve bc
040D18             1893*  
040D18 FE 2D       1894*      cp '-' ; check for negative number
040D1A C2 24 0D 04 1895*      jp nz,@loop ; number is positive, nothing more to do
040D1E AF          1896*      xor a ; sign flag to zero
040D1F 32 BF 0D 04 1897*      ld (@sign),a ; store sign flag
040D23 23          1898*      inc hl ; skip '-'
040D24             1899*  
040D24             1900*  @loop:
040D24 7E          1901*      ld a, (hl)
040D25             1902*  
040D25             1903*  ; chcek for decimal point
040D25 FE 2E       1904*      cp '.' ; check for decimal point
040D27 CA 68 0D 04 1905*      jp z,@fractional_start ; jump to fractional part
040D2B             1906*  
040D2B             1907*  ; process integer part
040D2B D6 30       1908*      sub '0' ; normalise to 0
040D2D 38 19       1909*      jr c, @integer_end ; return if < ascii '0'
040D2F FE 0A       1910*      cp 10 ; check if >= 10
040D31 30 15       1911*      jr nc, @integer_end ; return if >= 10
040D33 E5          1912*      push hl ; stack hl
040D34 D5          1913*      push de ; ld hl, de
040D35 E1          1914*      pop hl
040D36 E5          1915*      push hl ; ld bc, hl
040D37 C1          1916*      pop bc
040D38 29          1917*      add hl, hl ; x 2
040D39 29          1918*      add hl, hl ; x 4
040D3A 09          1919*      add hl, bc ; x 5
040D3B 29          1920*      add hl, hl ; x 10
040D3C 01 00 00 00 1921*      ld bc, 0
040D40 4F          1922*      ld c, a ; ld bcu, a
040D41 09          1923*      add hl, bc ; add bcu to hl
040D42 E5          1924*      push hl ; ld de, hl
040D43 D1          1925*      pop de
040D44 E1          1926*      pop hl ; restore hl
040D45 23          1927*      inc hl
040D46 18 DC       1928*      jr @loop
040D48             1929*  
040D48             1930*  @integer_end:
040D48 ED 53 B8 0D 1931*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       04          
040D4D             1932*  
040D4D             1933*  @end:
040D4D C1          1934*      pop bc ; send bc back how she came in
040D4E ED 5B B7 0D 1935*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       04          
040D53 3A BF 0D 04 1936*      ld a, (@sign) ; get sign flag
040D57 3D          1937*      dec a ; check if negative
040D58 F2 66 0D 04 1938*      jp p,@pos ; positive number
040D5C             1939*  
040D5C             1940*  ; Negate de
040D5C E5          1941*      push hl ; save text pointer
040D5D 21 00 00 00 1942*      ld hl, 0
040D61 AF          1943*      xor a ; clear carry
040D62 ED 52       1944*      sbc hl, de ; subtract DE from HL
040D64 EB          1945*      ex de, hl ; DE = 0-HL
040D65 E1          1946*      pop hl ; restore text pointer
040D66             1947*  
040D66             1948*  @pos:
040D66 37          1949*      scf ; we have a valid number so set carry
040D67 C9          1950*      ret
040D68             1951*  
040D68             1952*  @fractional_start:
040D68 DD E5       1953*      push ix                    ; preserve ix
040D6A ED 53 B8 0D 1954*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       04          
040D6F 06 03       1955*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
040D71 11 00 00 00 1956*      ld de, 0                   ; Initialize DE as the fractional accumulator
040D75 DD 21 C0 0D 1957*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       04          
040D7A 23          1958*      inc hl                     ; Skip decimal point
040D7B             1959*  
040D7B             1960*  @fractional_loop:
040D7B 7E          1961*      ld a, (hl)                 ; Load next character
040D7C D6 30       1962*      sub '0'                    ; Normalize ASCII to decimal
040D7E 38 1C       1963*      jr c, @end_fraction        ; Exit if < '0'
040D80 FE 0A       1964*      cp 10
040D82 30 18       1965*      jr nc, @end_fraction       ; Exit if >= 10
040D84             1966*  
040D84             1967*      ; Multiply the current fractional accumulator by 10
040D84 E5          1968*      push hl                    ; Save char pointer
040D85 F5          1969*      push af                    ; Save the digit
040D86 EB          1970*      ex de, hl
040D87 E5          1971*      push hl
040D88 29          1972*      add hl,hl ; * 2
040D89 29          1973*      add hl,hl ; * 4
040D8A D1          1974*      pop de
040D8B 19          1975*      add hl,de ; * 5
040D8C 29          1976*      add hl,hl ; * 10
040D8D 11 00 00 00 1977*      ld de, 0                   ; Clear DEU
040D91 F1          1978*      pop af                     ; Restore the current digit
040D92 5F          1979*      ld e, a                    ; Load the digit into E
040D93 19          1980*      add hl, de                 ; Add the digit to the accumulator
040D94 EB          1981*      ex de, hl                  ; Result back to DE
040D95 ED 32 03    1982*      lea ix,ix+3                ; Advance IX to the next scaling factor
040D98 E1          1983*      pop hl                     ; Restore char pointer
040D99 23          1984*      inc hl                     ; Move to the next character
040D9A 10 DF       1985*      djnz @fractional_loop      ; Loop if more digits to process
040D9C             1986*  
040D9C             1987*  @end_fraction:
040D9C             1988*  ; Final scaling based on number of fractional digits processed
040D9C ED 53 BC 0D 1989*      ld (@scratch+1), de          ; Shift fractional part up a byte
       04          
040DA1 2A BB 0D 04 1990*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
040DA5             1991*  
040DA5 DD 17 00    1992*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
040DA8 CD FE 01 04 1993*      call udiv24                ; Perform 24-bit division to scale down
040DAC 7B          1994*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
040DAD 32 B7 0D 04 1995*      ld (@result), a            ; Store fractional part in result buffer
040DB1 DD E1       1996*      pop ix                     ; Restore ix
040DB3 C3 4D 0D 04 1997*      jp @end                    ; Final sign check and flag setup
040DB7             1998*  
040DB7             1999*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
040DBB             2000*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
040DBF 00          2001*  @sign: db 0                    ; Sign flag buffer
040DC0             2002*  
040DC0             2003*  powers_of_10:
040DC0 01 00 00    2004*      dl 1                       ; 10^0
040DC3 0A 00 00    2005*      dl 10                      ; 10^1
040DC6 64 00 00    2006*      dl 100                     ; 10^2
040DC9 E8 03 00    2007*      dl 1000                    ; 10^3
040DCC 10 27 00    2008*      dl 10000                   ; 10^4
040DCF             0044       ; include "functions.inc"
040DCF             0045       ; include "vdu.inc"
040DCF             0046   	; include "maths.inc"
040DCF             0047   	; include "trig24fast.inc"
040DCF             0048   	; include "fixed24.inc"
040DCF             0049   	; include "files.inc"
040DCF             0050       ; include "timer.inc"
040DCF             0051   
040DCF             0052   ; --- INITIALIZATION ---
040DCF             0053   init:
040DCF C9          0054      ret
040DD0             0055   
040DD0             0056   ; --- MAIN PROGRAM ---
040DD0             0057   
040DD0             0058   main:
040DD0             0059       ; call printInline
040DD0             0060       ; asciz "rounding error in print_u168: "
040DD0             0061       ; ld hl,@arg1
040DD0             0062       ; call asc_to_s168 ; de = @arg1
040DD0             0063       ; ex de,hl
040DD0             0064       ; call printHexUHL
040DD0             0065       ; push hl
040DD0             0066       ; call printInline
040DD0             0067       ; asciz " -> "
040DD0             0068       ; pop hl
040DD0             0069       ; call print_u168
040DD0             0070       ; call printInline
040DD0             0071       ; asciz " should be: "
040DD0             0072       ; ld hl,@arg1
040DD0             0073       ; call printString
040DD0             0074       ; call printNewLine
040DD0             0075   
040DD0             0076       ; call printInline
040DD0             0077       ; asciz "sign overflow in print_u168: "
040DD0             0078       ; ld hl,@arg2
040DD0             0079       ; call asc_to_s168 ; de = @arg2
040DD0             0080       ; ex de,hl
040DD0             0081       ; call printHexUHL
040DD0             0082       ; push hl
040DD0             0083       ; call printInline
040DD0             0084       ; asciz " -> "
040DD0             0085       ; pop hl
040DD0             0086       ; call print_u168
040DD0             0087       ; call printInline
040DD0             0088       ; asciz " should be: "
040DD0             0089       ; ld hl,@arg2
040DD0             0090       ; call printString
040DD0             0091       ; call printNewLine
040DD0             0092   
040DD0             0093       ; call printInline
040DD0             0094       ; asciz "unsigned fixed place multiplication: e * pi = "
040DD0             0095       ; ld hl,0x0002B7 ; 2.718
040DD0             0096       ; ld de,0x000324 ; 3.141
040DD0             0097       ; call umul168
040DD0             0098       ; call print_u168
040DD0             0099       ; call printInline
040DD0             0100       ; asciz " should be: 8.539\r\n"
040DD0             0101   
040DD0             0102       ; call printInline
040DD0             0103       ; asciz "unsigned fixed place division: e / pi = "
040DD0             0104       ; ld hl,0x0002B7 ; 2.718
040DD0             0105       ; ld de,0x000324 ; 3.141
040DD0             0106       ; call udiv168
040DD0             0107       ; call print_u168
040DD0             0108       ; call printInline
040DD0             0109       ; asciz " should be: 0.864\r\n"
040DD0             0110   
040DD0             0111       ; call printInline
040DD0             0112       ; asciz "distance between two points: "
040DD0             0113       ; ld hl,0x000000 ; x0 0
040DD0             0114       ; ld de,0x000000 ; y0 0
040DD0             0115       ; ld ix,0x010000 ; x1 256
040DD0             0116       ; ld iy,0x010000 ; y1 256
040DD0             0117       ; call distance168
040DD0             0118       ; call printHexUHL
040DD0             0119       ; ; call print_u168
040DD0             0120       ; call printDec
040DD0             0121       ; call printInline
040DD0             0122       ; asciz " should be: 0x016A09 362.039\r\n"
040DD0             0123   
040DD0             0124       ; call printInline
040DD0             0125       ; asciz "24-bit integer square-root: "
040DD0 CD 02 0B 04 0126       call printNewLine
040DD4 21 00 01 00 0127       ld hl,256
040DD8 CD BB 03 04 0128       call sqrt24
040DDC EB          0129       ex de,hl
040DDD CD 37 0B 04 0130       call printDec
040DE1             0131       ; call dumpRegistersHex
040DE1             0132   
040DE1 C9          0133       ret
040DE2             0134   
040DE2             0135   debug_print:
040DE2 CD 37 0B 04 0136       call printDec
040DE6 EB          0137       ex de,hl
040DE7 CD 37 0B 04 0138       call printDec
040DEB EB          0139       ex de,hl
040DEC CD 02 0B 04 0140       call printNewLine
040DF0 C9          0141       ret
040DF1             0142   
040DF1 33 32 37 36 0143   @arg1: asciz "32767.999" ; 0x7FFFFF
       37 2E 39 39 
       39 00       
040DFB 2D 33 32 37 0144   @arg2: asciz "-32768" ; 0x800000
       36 38 00    
