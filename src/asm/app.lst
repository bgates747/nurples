PC     Output      Line
040000             0001   	.assume adl=1
040000             0002       .org 0x040000
040000             0003   
040000 C3 45 00 04 0004       jp start
040004             0005   
040004 FF FF FF FF 0006       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0007       .db "MOS"
040043 00          0008       .db 00h
040044 01          0009       .db 01h
040045             0010   
040045             0011   start:
040045 F5          0012       push af
040046 C5          0013       push bc
040047 D5          0014       push de
040048 DD E5       0015       push ix
04004A FD E5       0016       push iy
04004C             0017   
04004C             0018   ; ###############################################
04004C CD 1E 2F 04 0019   	call	init			; Initialization code
040050 CD A3 2F 04 0020   	call 	main			; Call the main function
040054             0021   ; ###############################################
040054             0022   
040054             0023   exit:
040054 FD E1       0024       pop iy
040056 DD E1       0025       pop ix
040058 D1          0026       pop de
040059 C1          0027       pop bc
04005A F1          0028       pop af
04005B 21 00 00 00 0029       ld hl,0
04005F C9          0030       ret
040060             0031   
040060             0032   ; API includes
040060             0033       include "mos_api.inc"
040060             0001*  ;
040060             0002*  ; Title:	AGON MOS - API for user projects
040060             0003*  ; Author:	Dean Belfield
040060             0004*  ; Created:	03/08/2022
040060             0005*  ; Last Updated:	11/11/2023
040060             0006*  ;
040060             0007*  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 05/08/2022:	Added mos_feof
040060             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*  ; 13/10/2022:	Added mos_oscli
040060             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*  ; 19/05/2023:	Added sysvar_scrMode
040060             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*  ; 03/08/2023:	Added mos_setkbvector
040060             0028*  ; 10/08/2023:	Added mos_getkbmap
040060             0029*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040060             0030*  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040060             0031*  ;
040060             0032*  ; VDP control (VDU 23, 0, n)
040060             0033*  ;
040060             0034*  vdp_gp:			EQU 	80h
040060             0035*  vdp_keycode:		EQU 	81h
040060             0036*  vdp_cursor:		EQU	82h
040060             0037*  vdp_scrchar:		EQU	83h
040060             0038*  vdp_scrpixel:		EQU	84h
040060             0039*  vdp_audio:		EQU	85h
040060             0040*  vdp_mode:		EQU	86h
040060             0041*  vdp_rtc:		EQU	87h
040060             0042*  vdp_keystate:		EQU	88h
040060             0043*  vdp_logicalcoords:	EQU	C0h
040060             0044*  vdp_terminalmode:	EQU	FFh
040060             0045*  
040060             0046*  ; MOS high level functions
040060             0047*  ;
040060             0048*  mos_getkey:		EQU	00h
040060             0049*  mos_load:		EQU	01h
040060             0050*  mos_save:		EQU	02h
040060             0051*  mos_cd:			EQU	03h
040060             0052*  mos_dir:		EQU	04h
040060             0053*  mos_del:		EQU	05h
040060             0054*  mos_ren:		EQU	06h
040060             0055*  mos_mkdir:		EQU	07h
040060             0056*  mos_sysvars:		EQU	08h
040060             0057*  mos_editline:		EQU	09h
040060             0058*  mos_fopen:		EQU	0Ah
040060             0059*  mos_fclose:		EQU	0Bh
040060             0060*  mos_fgetc:		EQU	0Ch
040060             0061*  mos_fputc:		EQU	0Dh
040060             0062*  mos_feof:		EQU	0Eh
040060             0063*  mos_getError:		EQU	0Fh
040060             0064*  mos_oscli:		EQU	10h
040060             0065*  mos_copy:		EQU	11h
040060             0066*  mos_getrtc:		EQU	12h
040060             0067*  mos_setrtc:		EQU	13h
040060             0068*  mos_setintvector:	EQU	14h
040060             0069*  mos_uopen:		EQU	15h
040060             0070*  mos_uclose:		EQU	16h
040060             0071*  mos_ugetc:		EQU	17h
040060             0072*  mos_uputc:		EQU 	18h
040060             0073*  mos_getfil:		EQU	19h
040060             0074*  mos_fread:		EQU	1Ah
040060             0075*  mos_fwrite:		EQU	1Bh
040060             0076*  mos_flseek:		EQU	1Ch
040060             0077*  mos_setkbvector:	EQU	1Dh
040060             0078*  mos_getkbmap:		EQU	1Eh
040060             0079*  mos_i2c_open:		EQU	1Fh
040060             0080*  mos_i2c_close:		EQU	20h
040060             0081*  mos_i2c_write:		EQU	21h
040060             0082*  mos_i2c_read:		EQU	22h
040060             0083*  
040060             0084*  
040060             0085*  ; FatFS file access functions
040060             0086*  ;
040060             0087*  ffs_fopen:		EQU	80h
040060             0088*  ffs_fclose:		EQU	81h
040060             0089*  ffs_fread:		EQU	82h
040060             0090*  ffs_fwrite:		EQU	83h
040060             0091*  ffs_flseek:		EQU	84h
040060             0092*  ffs_ftruncate:		EQU	85h
040060             0093*  ffs_fsync:		EQU	86h
040060             0094*  ffs_fforward:		EQU	87h
040060             0095*  ffs_fexpand:		EQU	88h
040060             0096*  ffs_fgets:		EQU	89h
040060             0097*  ffs_fputc:		EQU	8Ah
040060             0098*  ffs_fputs:		EQU	8Bh
040060             0099*  ffs_fprintf:		EQU	8Ch
040060             0100*  ffs_ftell:		EQU	8Dh
040060             0101*  ffs_feof:		EQU	8Eh
040060             0102*  ffs_fsize:		EQU	8Fh
040060             0103*  ffs_ferror:		EQU	90h
040060             0104*  
040060             0105*  ; FatFS directory access functions
040060             0106*  ;
040060             0107*  ffs_dopen:		EQU	91h
040060             0108*  ffs_dclose:		EQU	92h
040060             0109*  ffs_dread:		EQU	93h
040060             0110*  ffs_dfindfirst:		EQU	94h
040060             0111*  ffs_dfindnext:		EQU	95h
040060             0112*  
040060             0113*  ; FatFS file and directory management functions
040060             0114*  ;
040060             0115*  ffs_stat:		EQU	96h
040060             0116*  ffs_unlink:		EQU	97h
040060             0117*  ffs_rename:		EQU	98h
040060             0118*  ffs_chmod:		EQU	99h
040060             0119*  ffs_utime:		EQU	9Ah
040060             0120*  ffs_mkdir:		EQU	9Bh
040060             0121*  ffs_chdir:		EQU	9Ch
040060             0122*  ffs_chdrive:		EQU	9Dh
040060             0123*  ffs_getcwd:		EQU	9Eh
040060             0124*  
040060             0125*  ; FatFS volume management and system configuration functions
040060             0126*  ;
040060             0127*  ffs_mount:		EQU	9Fh
040060             0128*  ffs_mkfs:		EQU	A0h
040060             0129*  ffs_fdisk:		EQU	A1h
040060             0130*  ffs_getfree:		EQU	A2h
040060             0131*  ffs_getlabel:		EQU	A3h
040060             0132*  ffs_setlabel:		EQU	A4h
040060             0133*  ffs_setcp:		EQU	A5h
040060             0134*  
040060             0135*  ; File access modes
040060             0136*  ;
040060             0137*  fa_read:		EQU	01h
040060             0138*  fa_write:		EQU	02h
040060             0139*  fa_open_existing:	EQU	00h
040060             0140*  fa_create_new:		EQU	04h
040060             0141*  fa_create_always:	EQU	08h
040060             0142*  fa_open_always:		EQU	10h
040060             0143*  fa_open_append:		EQU	30h
040060             0144*  
040060             0145*  ; System variable indexes for api_sysvars
040060             0146*  ; Index into _sysvars in globals.asm
040060             0147*  ;
040060             0148*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0149*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0150*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0151*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040060             0152*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040060             0153*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040060             0154*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040060             0155*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0156*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0157*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0158*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040060             0159*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040060             0160*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040060             0161*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040060             0162*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040060             0163*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0164*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040060             0165*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0166*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040060             0167*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040060             0168*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040060             0169*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040060             0170*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040060             0171*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040060             0172*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040060             0173*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0174*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040060             0175*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040060             0176*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040060             0177*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040060             0178*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040060             0179*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040060             0180*  ;
040060             0181*  ; Flags for the VPD protocol
040060             0182*  ;
040060             0183*  vdp_pflag_cursor:	EQU	00000001b
040060             0184*  vdp_pflag_scrchar:	EQU	00000010b
040060             0185*  vdp_pflag_point:	EQU	00000100b
040060             0186*  vdp_pflag_audio:	EQU	00001000b
040060             0187*  vdp_pflag_mode:		EQU	00010000b
040060             0188*  vdp_pflag_rtc:		EQU	00100000b
040060             0189*  vdp_pflag_mouse:	EQU	01000000b
040060             0190*  ; vdp_pflag_buffered:	EQU	10000000b
040060             0191*  
040060             0192*  
040060             0193*  ; FatFS structures
040060             0194*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0195*  ;
040060             0196*  ; Object ID and allocation information (FFOBJID)
040060             0197*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040060             0198*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040060             0199*  FFOBJID.attr:     EQU 5    ; Object attribute
040060             0200*  FFOBJID.stat:     EQU 6    ; Object chain status
040060             0201*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040060             0202*  FFOBJID.objsize:  EQU 11   ; Object size
040060             0203*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040060             0204*  ;
040060             0205*  ; File object structure (FIL)
040060             0206*  ;
040060             0207*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040060             0208*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040060             0209*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040060             0210*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040060             0211*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040060             0212*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040060             0213*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040060             0214*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040060             0215*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040060             0216*  ;
040060             0217*  ; Directory object structure (DIR)
040060             0218*  ;
040060             0219*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040060             0220*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040060             0221*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040060             0222*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040060             0223*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040060             0224*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040060             0225*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040060             0226*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040060             0227*  ;
040060             0228*  ; File information structure (FILINFO)
040060             0229*  ;
040060             0230*  FILINFO.fsize:    EQU 0    ; File size
040060             0231*  FILINFO.fdate:    EQU 4    ; Modified date
040060             0232*  FILINFO.ftime:    EQU 6    ; Modified time
040060             0233*  FILINFO.fattrib:  EQU 8    ; File attribute
040060             0234*  FILINFO.altname:  EQU 9    ; Alternative file name
040060             0235*  FILINFO.fname:    EQU 22   ; Primary file name
040060             0236*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040060             0237*  ;
040060             0238*  ; Macro for calling the API
040060             0239*  ; Parameters:
040060             0240*  ; - function: One of the function numbers listed above
040060             0241*  ;
040060             0242*  			MACRO MOSCALL	function
040060             0243*  			LD	A, function
040060             0244*  			RST.LIS	08h
040060             0245*  			ENDMACRO
040060             0034       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*          LD A, char
040060             0004*          RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; test the sign of HL
040060             0008*  ; inputs: HL obviously
040060             0009*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0010*  ; destroys: flags
040060             0011*      MACRO sign_hlu
040060             0012*          add hl,de
040060             0013*          or a
040060             0014*          sbc hl,de
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at HL
040060             0018*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including HL and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callHL
040060             0022*          ld bc,$+7     ; Address of first instruction after the jump
040060             0023*          push bc       ; which constitutes the return address
040060             0024*          jp   (hl)     ; Jump to the address in HL
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to subroutine at IX
040060             0028*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IX and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIX
040060             0032*          ld bc,$+7     ; Address of first instruction after the jump
040060             0033*          push bc       ; which constitutes the return address
040060             0034*          jp   (ix)     ; Jump to the address in IX
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; Simulated call to soubroutinte at IY
040060             0038*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0039*  ; outputs: whatever the subroutine does, including IY and BC
040060             0040*  ; destroys: only what the subroutine does, but always BC
040060             0041*      MACRO callIY
040060             0042*          ld bc,$+7     ; Address of first instruction after the jump
040060             0043*          push bc       ; which constitutes the return address
040060             0044*          jp   (iy)     ; Jump to the address in IY
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  ; put the value in HLU into the accumulator
040060             0048*  ; destroys: af
040060             0049*      MACRO HLU_TO_A
040060             0050*          push hl ; 4 cycles
040060             0051*          inc sp ; 1 cycle
040060             0052*          pop af  ; 4 cycles
040060             0053*          dec sp ; 1 cycle
040060             0054*                 ; 10 cycles total
040060             0055*      ENDMACRO
040060             0056*  
040060             0057*  A_TO_HLU:
040060             0058*      ; call is 7 cycles
040060 22 6D 00 04 0059*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0060*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0061*      ld hl,(@scratch) ; 7 cycles
04006C C9          0062*      ret ; 6 cycles
04006D             0063*          ; 25 cycles total
04006D 00 00 00    0064*  @scratch: dl 0
040070             0065*  
040070             0066*      ; TODO: implement this
040070             0067*      ; MACRO A_TO_HLU
040070             0068*      ;     push.s af
040070             0069*      ;     inc sp
040070             0070*      ;     push.s hl
040070             0071*      ;     pop hl
040070             0072*      ;     inc sp
040070             0073*      ;     inc sp
040070             0074*      ; ENDMACRO
040070             0075*  
040070             0076*      MACRO PUSH_ALL
040070             0077*          ex af,af'
040070             0078*          exx
040070             0079*          push af
040070             0080*          push hl
040070             0081*          push bc
040070             0082*          push de
040070             0083*  
040070             0084*          ex af,af'
040070             0085*          exx
040070             0086*          push af
040070             0087*          push hl
040070             0088*          push bc
040070             0089*          push de
040070             0090*          push ix
040070             0091*          push iy
040070             0092*      ENDMACRO
040070             0093*  
040070             0094*      MACRO POP_ALL
040070             0095*          pop iy
040070             0096*          pop ix
040070             0097*          pop de
040070             0098*          pop bc
040070             0099*          pop hl
040070             0100*          pop af
040070             0101*          ex af,af'
040070             0102*          exx
040070             0103*  
040070             0104*          pop de
040070             0105*          pop bc
040070             0106*          pop hl
040070             0107*          pop af
040070             0108*          ex af,af'
040070             0109*          exx
040070             0110*      ENDMACRO
040070             0111*  
040070             0112*  ; Print a zero-terminated string inline with code, e.g.:
040070             0113*  ;
040070             0114*  ;    call printInline
040070             0115*  ;    ASCIZ "Hello, world!\r\n"
040070             0116*  ;
040070             0117*  ; Destroys: HL,AF
040070             0118*  printInline:
040070 E1          0119*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0120*      call printString ; HL advances to end of string
040075 E5          0121*      push hl ; restore the return address = pointer to end of string
040076 C9          0122*      ret
040077             0123*  
040077             0124*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0125*  ; Print a zero-terminated string
040077             0126*  ; HL: Pointer to string
040077             0127*  printString:
040077 C5          0128*  	PUSH	BC
040078 01 00 00 00 0129*  	LD		BC,0
04007C 3E 00       0130*  	LD 	 	A,0
04007E 5B DF       0131*  	RST.LIL 18h
040080 C1          0132*  	POP		BC
040081 C9          0133*  	RET
040082             0134*  ; print a VDU sequence
040082             0135*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0136*  sendVDUsequence:
040082 C5          0137*  	PUSH	BC
040083 01 00 00 00 0138*  	LD		BC, 0
040087 4E          0139*  	LD		C, (HL)
040088 5B DF       0140*  	RST.LIL	18h
04008A C1          0141*  	POP		BC
04008B C9          0142*  	RET
04008C             0143*  ; Print Newline sequence to VDP
04008C             0144*  printNewLine:
04008C F5          0145*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0146*  	LD	A, '\r'
04008F 5B D7       0147*  	RST.LIL 10h
040091 3E 0A       0148*  	LD	A, '\n'
040093 5B D7       0149*  	RST.LIL 10h
040095 F1          0150*      pop af
040096 C9          0151*  	RET
040097             0152*  
040097             0153*  ; Print a 24-bit HEX number
040097             0154*  ; HLU: Number to print
040097             0155*  printHex24:
040097             0156*      HLU_TO_A
040097 E5          0001*M         push hl ; 4 cycles
040098 33          0002*M         inc sp ; 1 cycle
040099 F1          0003*M         pop af  ; 4 cycles
04009A 3B          0004*M         dec sp ; 1 cycle
04009B             0005*M                ; 10 cycles total
04009B CD A5 00 04 0157*  	CALL	printHex8
04009F             0158*  ; Print a 16-bit HEX number
04009F             0159*  ; HL: Number to print
04009F             0160*  printHex16:
04009F 7C          0161*  	LD		A,H
0400A0 CD A5 00 04 0162*  	CALL	printHex8
0400A4 7D          0163*  	LD		A,L
0400A5             0164*  ; Print an 8-bit HEX number
0400A5             0165*  ; A: Number to print
0400A5             0166*  printHex8:
0400A5 4F          0167*  	LD		C,A
0400A6 1F          0168*  	RRA
0400A7 1F          0169*  	RRA
0400A8 1F          0170*  	RRA
0400A9 1F          0171*  	RRA
0400AA CD AF 00 04 0172*  	CALL	@F
0400AE 79          0173*  	LD		A,C
0400AF             0174*  @@:
0400AF E6 0F       0175*  	AND		0Fh
0400B1 C6 90       0176*  	ADD		A,90h
0400B3 27          0177*  	DAA
0400B4 CE 40       0178*  	ADC		A,40h
0400B6 27          0179*  	DAA
0400B7 5B D7       0180*  	RST.LIL	10h
0400B9 C9          0181*  	RET
0400BA             0182*  
0400BA             0183*  printHexA:
0400BA F5          0184*      push af
0400BB C5          0185*      push bc
0400BC CD A5 00 04 0186*      call printHex8
0400C0 3E 20       0187*      ld a,' '
0400C2 5B D7       0188*      rst.lil 10h
0400C4 C1          0189*      pop bc
0400C5 F1          0190*      pop af
0400C6 C9          0191*      ret
0400C7             0192*  
0400C7             0193*  printHexHL:
0400C7 F5          0194*      push af
0400C8 C5          0195*      push bc
0400C9 CD 9F 00 04 0196*      call printHex16
0400CD 3E 20       0197*      ld a,' '
0400CF 5B D7       0198*      rst.lil 10h
0400D1 C1          0199*      pop bc
0400D2 F1          0200*      pop af
0400D3 C9          0201*      ret
0400D4             0202*  
0400D4             0203*  printHexUHL:
0400D4 F5          0204*      push af
0400D5 C5          0205*      push bc
0400D6 CD 97 00 04 0206*      call printHex24
0400DA 3E 20       0207*      ld a,' '
0400DC 5B D7       0208*      rst.lil 10h
0400DE C1          0209*      pop bc
0400DF F1          0210*      pop af
0400E0 C9          0211*      ret
0400E1             0212*  
0400E1             0213*  printHexAUHL:
0400E1 F5          0214*      push af
0400E2 C5          0215*      push bc
0400E3 CD A5 00 04 0216*      call printHex8
0400E7 3E 2E       0217*      ld a,'.'
0400E9 5B D7       0218*      rst.lil 10h
0400EB CD 97 00 04 0219*      call printHex24
0400EF 3E 20       0220*      ld a,' '
0400F1 5B D7       0221*      rst.lil 10h
0400F3 C1          0222*      pop bc
0400F4 F1          0223*      pop af
0400F5 C9          0224*      ret
0400F6             0225*  
0400F6             0226*  printHexABHL:
0400F6             0227*  ; preserve registers
0400F6 C5          0228*      push bc ; b will be ok c will not
0400F7 F5          0229*      push af ; will get totally destroyed
0400F8             0230*  ; print a
0400F8 CD A5 00 04 0231*      call printHex8
0400FC             0232*  ; print b
0400FC 78          0233*      ld a,b
0400FD CD A5 00 04 0234*      call printHex8
040101             0235*  ; print hl
040101 CD 9F 00 04 0236*      call printHex16
040105             0237*  ; restore registers
040105 F1          0238*      pop af
040106 C1          0239*      pop bc
040107 C9          0240*      ret
040108             0241*  
040108             0242*  printHexBHL:
040108             0243*  ; preserve registers
040108 C5          0244*      push bc ; b will be ok c will not
040109 F5          0245*      push af ; will get totally destroyed
04010A             0246*  ; print b
04010A 78          0247*      ld a,b
04010B CD A5 00 04 0248*      call printHex8
04010F             0249*  ; print hl
04010F CD 9F 00 04 0250*      call printHex16
040113             0251*  ; restore registers
040113 F1          0252*      pop af
040114 C1          0253*      pop bc
040115 C9          0254*      ret
040116             0255*  
040116             0256*  printHexCDE:
040116             0257*  ; preserve registers
040116 C5          0258*      push bc ; b will be ok c will not
040117 F5          0259*      push af ; will get totally destroyed
040118             0260*  ; print c
040118 79          0261*      ld a,c
040119 CD A5 00 04 0262*      call printHex8
04011D             0263*  ; print de
04011D EB          0264*      ex de,hl
04011E CD 9F 00 04 0265*      call printHex16
040122 EB          0266*      ex de,hl
040123             0267*  ; restore registers
040123 F1          0268*      pop af
040124 C1          0269*      pop bc
040125 C9          0270*      ret
040126             0271*  
040126             0272*  printHexUIX:
040126             0273*  ; store everything in scratch
040126 22 9F 05 04 0274*      ld (uhl),hl
04012A ED 43 A2 05 0275*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0276*      ld (ude),de
       04          
040134 DD 22 A8 05 0277*      ld (uix),ix
       04          
040139 FD 22 AB 05 0278*      ld (uiy),iy
       04          
04013E F5          0279*      push af ; fml
04013F             0280*  
04013F 21 36 05 04 0281*      ld hl,str_ixu
040143 CD 77 00 04 0282*      call printString
040147 2A A8 05 04 0283*      ld hl,(uix)
04014B CD 97 00 04 0284*      call printHex24
04014F CD 8C 00 04 0285*      call printNewLine
040153             0286*  
040153             0287*  ; restore everything
040153 2A 9F 05 04 0288*      ld hl, (uhl)
040157 ED 4B A2 05 0289*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0290*      ld de, (ude)
       04          
040161 DD 2A A8 05 0291*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0292*      ld iy, (uiy)
       04          
04016B F1          0293*      pop af
04016C             0294*  ; all done
04016C C9          0295*      ret
04016D             0296*  
04016D             0297*  ; Print a 0x HEX prefix
04016D             0298*  DisplayHexPrefix:
04016D 3E 30       0299*  	LD	A, '0'
04016F 5B D7       0300*  	RST.LIL 10h
040171 3E 78       0301*  	LD	A, 'x'
040173 5B D7       0302*  	RST.LIL 10h
040175 C9          0303*  	RET
040176             0304*  
040176             0305*      MACRO printDecBC
040176             0306*          push hl
040176             0307*          push bc
040176             0308*          pop hl
040176             0309*          call printDec
040176             0310*          pop hl
040176             0311*      ENDMACRO
040176             0312*  
040176             0313*      MACRO printDecDE
040176             0314*          push hl
040176             0315*          push de
040176             0316*          pop hl
040176             0317*          call printDec
040176             0318*          pop hl
040176             0319*      ENDMACRO
040176             0320*  
040176             0321*      MACRO printDecHL
040176             0322*          call printDec
040176             0323*      ENDMACRO
040176             0324*  
040176             0325*      MACRO printDecIX
040176             0326*          push hl
040176             0327*          push ix
040176             0328*          pop hl
040176             0329*          call printDec
040176             0330*          pop hl
040176             0331*      ENDMACRO
040176             0332*  
040176             0333*      MACRO printDecIY
040176             0334*          push hl
040176             0335*          push iy
040176             0336*          pop hl
040176             0337*          call printDec
040176             0338*          pop hl
040176             0339*      ENDMACRO
040176             0340*  
040176             0341*  
040176             0342*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0343*  ; HL : Value to print
040176             0344*  ; preserves all registers and flags
040176             0345*  printDec:
040176             0346*  ; BEGIN MY CODE
040176             0347*  ; back up all the things
040176 F5          0348*      push af
040177 C5          0349*      push bc
040178 D5          0350*      push de
040179 E5          0351*      push hl
04017A             0352*  ; END MY CODE
04017A 11 A2 01 04 0353*  	LD	 DE, _printDecBuffer
04017E CD B2 01 04 0354*  	CALL u24_to_ascii
040182             0355*  ; BEGIN MY CODE
040182             0356*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0357*      LD	 HL, _printDecBuffer
040186 06 07       0358*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040188             0359*  @loop:
040188 7E          0360*      LD	 A, (HL)
040189 FE 30       0361*      CP	 '0'
04018B C2 95 01 04 0362*      JP	 NZ, @done
04018F 3E 20       0363*      LD   A, ' '
040191 77          0364*      LD	 (HL), A
040192 23          0365*      INC	 HL
040193             0366*      ; CALL vdu_cursor_forward
040193 10 F3       0367*      DJNZ @loop
040195             0368*  @done:
040195             0369*  ; END MY CODE
040195 21 A2 01 04 0370*  	LD	 HL, _printDecBuffer
040199 CD 77 00 04 0371*  	CALL printString
04019D             0372*  ; BEGIN MY CODE
04019D             0373*  ; restore all the things
04019D E1          0374*      pop hl
04019E D1          0375*      pop de
04019F C1          0376*      pop bc
0401A0 F1          0377*      pop af
0401A1             0378*  ; END MY CODE
0401A1 C9          0379*  	RET
0401A2 00 00 00 00 0380*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0381*  
0401B2             0382*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0383*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0384*  ; so it will allways be 8 characters length
0401B2             0385*  ; HL : Value to convert to string
0401B2             0386*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0387*  u24_to_ascii:
0401B2 01 80 69 67 0388*  	LD	 BC,-10000000
0401B6 CD E9 01 04 0389*  	CALL @one_digit
0401BA 01 C0 BD F0 0390*  	LD	 BC,-1000000
0401BE CD E9 01 04 0391*  	CALL @one_digit
0401C2 01 60 79 FE 0392*  	LD	 BC,-100000
0401C6 CD E9 01 04 0393*  	CALL @one_digit
0401CA 01 F0 D8 FF 0394*  	LD   BC,-10000
0401CE CD E9 01 04 0395*  	CALL @one_digit
0401D2 01 18 FC FF 0396*  	LD   BC,-1000
0401D6 CD E9 01 04 0397*  	CALL @one_digit
0401DA 01 9C FF FF 0398*  	LD   BC,-100
0401DE CD E9 01 04 0399*  	CALL @one_digit
0401E2 0E F6       0400*  	LD   C,-10
0401E4 CD E9 01 04 0401*  	CALL @one_digit
0401E8 48          0402*  	LD   C,B
0401E9             0403*  @one_digit:
0401E9 3E 2F       0404*  	LD   A,'0'-1
0401EB             0405*  @divide_me:
0401EB 3C          0406*  	INC  A
0401EC 09          0407*  	ADD  HL,BC
0401ED 38 FC       0408*  	JR   C,@divide_me
0401EF ED 42       0409*  	SBC  HL,BC
0401F1 12          0410*  	LD   (DE),A
0401F2 13          0411*  	INC  DE
0401F3 C9          0412*  	RET
0401F4             0413*  
0401F4             0414*  print_u24:
0401F4 D5          0415*      push de
0401F5 E5          0416*      push hl
0401F6 11 A2 01 04 0417*      ld de,_printDecBuffer
0401FA CD B2 01 04 0418*      call u24_to_ascii
0401FE 21 A2 01 04 0419*      ld hl,_printDecBuffer
040202 CD 77 00 04 0420*      call printString
040206 3E 20       0421*      ld a,' '
040208 5B D7       0422*      rst.lil 10h
04020A E1          0423*      pop hl
04020B D1          0424*      pop de
04020C C9          0425*      ret
04020D             0426*  
04020D             0427*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0428*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0429*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0430*  u168_to_ascii:
04020D             0431*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0432*      ld a,' '
04020F 12          0433*      ld (de),a
040210 13          0434*      inc de
040211             0435*  ; Convert integer part
040211 E5          0436*      push hl               ; Save HL (we’ll need the fractional part later)
040212 CD 26 0F 04 0437*      call hlu_udiv256    ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0438*      ld   bc, -10000
04021A CD 3D 02 04 0439*      call @one_int
04021E 01 18 FC FF 0440*      ld   bc, -1000
040222 CD 3D 02 04 0441*      call @one_int
040226 01 9C FF FF 0442*      ld   bc, -100
04022A CD 3D 02 04 0443*      call @one_int
04022E 0E F6       0444*      ld   c, -10
040230 CD 3D 02 04 0445*      call @one_int
040234 48          0446*      ld   c, b
040235 CD 3D 02 04 0447*      call @one_int
040239 C3 48 02 04 0448*      jp   @frac            ; Jump to fractional part conversion
04023D             0449*  @one_int:
04023D 3E 2F       0450*      ld   a, '0' - 1       ; Start ASCII character at '0'
04023F             0451*  @divide_me:
04023F 3C          0452*      inc  a
040240 09          0453*      add  hl, bc           ; Accumulate until overflow
040241 38 FC       0454*      jr   c, @divide_me
040243 ED 42       0455*      sbc  hl, bc           ; Remove excess after overflow
040245 12          0456*      ld   (de), a          ; Store ASCII digit
040246 13          0457*      inc  de
040247 C9          0458*      ret
040248             0459*  ; Convert fractional part
040248             0460*  @frac:
040248 3E 2E       0461*      ld   a, '.'           ; Decimal point
04024A 12          0462*      ld   (de), a
04024B 13          0463*      inc  de
04024C E1          0464*      pop  hl               ; Restore HL with original fraction
04024D 06 03       0465*      ld   b, 3             ; Loop counter for 3 fractional digits
04024F             0466*  @frac_loop:
04024F 26 0A       0467*      ld   h, 10            ; Load multiplier for fractional part
040251 ED 6C       0468*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0469*      ld   a, '0'
040255 84          0470*      add  a, h             ; Convert integer part to ASCII
040256 12          0471*      ld   (de), a
040257 13          0472*      inc  de
040258 10 F5       0473*      djnz @frac_loop       ; Repeat for each fractional digit
04025A             0474*  ; Add null terminator
04025A AF          0475*      xor  a                ; Null terminator
04025B 12          0476*      ld   (de), a
04025C C9          0477*      ret
04025D             0478*  
04025D             0479*  print_u168:
04025D D5          0480*      push de
04025E E5          0481*      push hl
04025F 11 A2 01 04 0482*      ld de,_printDecBuffer
040263 CD 0D 02 04 0483*      call u168_to_ascii
040267 21 A2 01 04 0484*      ld hl,_printDecBuffer
04026B CD 77 00 04 0485*      call printString
04026F E1          0486*      pop hl
040270 D1          0487*      pop de
040271 C9          0488*      ret
040272             0489*  
040272             0490*  ; signed version of u168_to_ascii
040272             0491*  s168_to_ascii:
040272 D5          0492*      push de ; save starting address of buffer
040273 CD BF 0E 04 0493*      call hlu_abs
040277 F5          0494*      push af ; save sign flag
040278 CD 0D 02 04 0495*      call u168_to_ascii
04027C F1          0496*      pop af ; restore sign flag
04027D D1          0497*      pop de ; restore starting address of buffer
04027E F0          0498*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0499*      ld a,'-'
040281 12          0500*      ld (de),a
040282 C9          0501*      ret
040283             0502*  
040283             0503*  print_s168:
040283 D5          0504*      push de
040284 E5          0505*      push hl
040285 11 A2 01 04 0506*      ld de,_printDecBuffer
040289 CD 72 02 04 0507*      call s168_to_ascii
04028D 21 A2 01 04 0508*      ld hl,_printDecBuffer
040291 CD 77 00 04 0509*      call printString
040295 E1          0510*      pop hl
040296 D1          0511*      pop de
040297 C9          0512*      ret
040298             0513*  
040298             0514*  print_s168_hl:
040298 F5          0515*      push af
040299 E5          0516*      push hl
04029A CD 83 02 04 0517*      call print_s168
04029E 3E 20       0518*      ld a,' '
0402A0 5B D7       0519*      rst.lil 10h
0402A2 E1          0520*      pop hl
0402A3 F1          0521*      pop af
0402A4 C9          0522*      ret
0402A5             0523*  
0402A5             0524*  print_s168_bc:
0402A5 F5          0525*      push af
0402A6 C5          0526*      push bc
0402A7 E5          0527*      push hl
0402A8 C5          0528*      push bc
0402A9 E1          0529*      pop hl
0402AA CD 83 02 04 0530*      call print_s168
0402AE 3E 20       0531*      ld a,' '
0402B0 5B D7       0532*      rst.lil 10h
0402B2 E1          0533*      pop hl
0402B3 C1          0534*      pop bc
0402B4 F1          0535*      pop af
0402B5 C9          0536*      ret
0402B6             0537*  
0402B6             0538*  print_s168_de:
0402B6 F5          0539*      push af
0402B7 D5          0540*      push de
0402B8 E5          0541*      push hl
0402B9 EB          0542*      ex de,hl
0402BA CD 83 02 04 0543*      call print_s168
0402BE 3E 20       0544*      ld a,' '
0402C0 5B D7       0545*      rst.lil 10h
0402C2 E1          0546*      pop hl
0402C3 D1          0547*      pop de
0402C4 F1          0548*      pop af
0402C5 C9          0549*      ret
0402C6             0550*  
0402C6             0551*  print_s168_hl_bc_de:
0402C6 F5          0552*      push af
0402C7 C5          0553*      push bc
0402C8 D5          0554*      push de
0402C9 E5          0555*      push hl
0402CA CD 83 02 04 0556*      call print_s168
0402CE 3E 20       0557*      ld a,' '
0402D0 5B D7       0558*      rst.lil 10h
0402D2 C5          0559*      push bc
0402D3 E1          0560*      pop hl
0402D4 CD 83 02 04 0561*      call print_s168
0402D8 3E 20       0562*      ld a,' '
0402DA 5B D7       0563*      rst.lil 10h
0402DC EB          0564*      ex de,hl
0402DD CD 83 02 04 0565*      call print_s168
0402E1 3E 20       0566*      ld a,' '
0402E3 5B D7       0567*      rst.lil 10h
0402E5 E1          0568*      pop hl
0402E6 D1          0569*      pop de
0402E7 C1          0570*      pop bc
0402E8 F1          0571*      pop af
0402E9 C9          0572*      ret
0402EA             0573*  
0402EA             0574*  print_s168_bc_de:
0402EA F5          0575*      push af
0402EB C5          0576*      push bc
0402EC D5          0577*      push de
0402ED C5          0578*      push bc
0402EE E1          0579*      pop hl
0402EF CD 83 02 04 0580*      call print_s168
0402F3 3E 20       0581*      ld a,' '
0402F5 5B D7       0582*      rst.lil 10h
0402F7 EB          0583*      ex de,hl
0402F8 CD 83 02 04 0584*      call print_s168
0402FC 3E 20       0585*      ld a,' '
0402FE 5B D7       0586*      rst.lil 10h
040300 E1          0587*      pop hl
040301 D1          0588*      pop de
040302 C1          0589*      pop bc
040303 F1          0590*      pop af
040304 C9          0591*      ret
040305             0592*  
040305             0593*  print_s168_a:
040305 F5          0594*      push af
040306 C5          0595*      push bc
040307 E5          0596*      push hl
040308 21 00 00 00 0597*      ld hl,0
04030C 6F          0598*      ld l,a
04030D CD 98 02 04 0599*      call print_s168_hl
040311 E1          0600*      pop hl
040312 C1          0601*      pop bc
040313 F1          0602*      pop af
040314 C9          0603*      ret
040315             0604*  
040315             0605*  ; #### new functions added by Brandon R. Gates ####
040315             0606*  
040315             0607*  ; print the binary representation of the 8-bit value in a
040315             0608*  ; destroys a, hl, bc
040315             0609*  printBin8:
040315 06 08       0610*      ld b,8      ; loop counter for 8 bits
040317 21 32 03 04 0611*      ld hl,@cmd  ; set hl to the low byte of the output string
04031B             0612*                  ; (which will be the high bit of the value in a)
04031B             0613*  @loop:
04031B 07          0614*      rlca ; put the next highest bit into carry
04031C 38 04       0615*      jr c,@one
04031E 36 30       0616*      ld (hl),'0'
040320 18 02       0617*      jr @next_bit
040322             0618*  @one:
040322 36 31       0619*      ld (hl),'1'
040324             0620*  @next_bit:
040324 23          0621*      inc hl
040325 10 F4       0622*      djnz @loop
040327             0623*  ; print it
040327 21 32 03 04 0624*  	ld hl,@cmd
04032B 01 08 00 00 0625*  	ld bc,@end-@cmd
04032F 5B DF       0626*  	rst.lil $18
040331 C9          0627*  	ret
040332             0628*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0629*  @end:
04033A             0630*  
04033A             0631*  ; print the binary representation of the 8-bit value in a
04033A             0632*  ; in reverse order (lsb first)
04033A             0633*  ; destroys a, hl, bc
04033A             0634*  printBin8Rev:
04033A 06 08       0635*      ld b,8      ; loop counter for 8 bits
04033C 21 57 03 04 0636*      ld hl,@cmd  ; set hl to the low byte of the output string
040340             0637*                  ; (which will be the high bit of the value in a)
040340             0638*  @loop:
040340 0F          0639*      rrca ; put the next lowest bit into carry
040341 38 04       0640*      jr c,@one
040343 36 30       0641*      ld (hl),'0'
040345 18 02       0642*      jr @next_bit
040347             0643*  @one:
040347 36 31       0644*      ld (hl),'1'
040349             0645*  @next_bit:
040349 23          0646*      inc hl
04034A 10 F4       0647*      djnz @loop
04034C             0648*  ; print it
04034C 21 57 03 04 0649*  	ld hl,@cmd
040350 01 08 00 00 0650*  	ld bc,@end-@cmd
040354 5B DF       0651*  	rst.lil $18
040356 C9          0652*  	ret
040357             0653*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0654*  @end:
04035F             0655*  
04035F             0656*  ; print registers to screen in hexidecimal format
04035F             0657*  ; inputs: none
04035F             0658*  ; outputs: values of every register printed to screen
04035F             0659*  ;    values of each register in global scratch memory
04035F             0660*  ; destroys: nothing
04035F             0661*  stepRegistersHex:
04035F             0662*  ; store everything in scratch
04035F 22 9F 05 04 0663*      ld (uhl),hl
040363 ED 43 A2 05 0664*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0665*      ld (ude),de
       04          
04036D DD 22 A8 05 0666*      ld (uix),ix
       04          
040372 FD 22 AB 05 0667*      ld (uiy),iy
       04          
040377 F5          0668*      push af ; fml
040378 E1          0669*      pop hl  ; thanks, zilog
040379 22 9C 05 04 0670*      ld (uaf),hl
04037D F5          0671*      push af ; dammit
04037E             0672*  
04037E             0673*  ; home the cursor
04037E             0674*      ; call vdu_home_cursor
04037E             0675*  
04037E             0676*  ; print each register
04037E 21 22 05 04 0677*      ld hl,str_afu
040382 CD 77 00 04 0678*      call printString
040386 2A 9C 05 04 0679*      ld hl,(uaf)
04038A CD 97 00 04 0680*      call printHex24
04038E CD 8C 00 04 0681*      call printNewLine
040392             0682*  
040392 21 27 05 04 0683*      ld hl,str_hlu
040396 CD 77 00 04 0684*      call printString
04039A 2A 9F 05 04 0685*      ld hl,(uhl)
04039E CD 97 00 04 0686*      call printHex24
0403A2 CD 8C 00 04 0687*      call printNewLine
0403A6             0688*  
0403A6 21 2C 05 04 0689*      ld hl,str_bcu
0403AA CD 77 00 04 0690*      call printString
0403AE 2A A2 05 04 0691*      ld hl,(ubc)
0403B2 CD 97 00 04 0692*      call printHex24
0403B6 CD 8C 00 04 0693*      call printNewLine
0403BA             0694*  
0403BA 21 31 05 04 0695*      ld hl,str_deu
0403BE CD 77 00 04 0696*      call printString
0403C2 2A A5 05 04 0697*      ld hl,(ude)
0403C6 CD 97 00 04 0698*      call printHex24
0403CA CD 8C 00 04 0699*      call printNewLine
0403CE             0700*  
0403CE 21 36 05 04 0701*      ld hl,str_ixu
0403D2 CD 77 00 04 0702*      call printString
0403D6 2A A8 05 04 0703*      ld hl,(uix)
0403DA CD 97 00 04 0704*      call printHex24
0403DE CD 8C 00 04 0705*      call printNewLine
0403E2             0706*  
0403E2 21 3B 05 04 0707*      ld hl,str_iyu
0403E6 CD 77 00 04 0708*      call printString
0403EA 2A AB 05 04 0709*      ld hl,(uiy)
0403EE CD 97 00 04 0710*      call printHex24
0403F2 CD 8C 00 04 0711*      call printNewLine
0403F6             0712*  
0403F6             0713*      ; call vsync
0403F6             0714*  
0403F6 CD 8C 00 04 0715*      call printNewLine
0403FA             0716*  
0403FA             0717*  ; check for right shift key and quit if pressed
0403FA             0718*  	MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 49 CF       0002*M 			RST.LIS	08h
0403FE             0719*  @stayhere:
0403FE             0720*  ; 7 RightShift
0403FE DD CB 00 76 0721*      bit 6,(ix+0)
040402 20 02       0722*      jr nz,@RightShift
040404 18 F8       0723*      jr @stayhere
040406             0724*  @RightShift:
040406 DD CB 0E 86 0725*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0726*      ld a,%10000000
04040C             0727*      ; call multiPurposeDelay
04040C             0728*  
04040C             0729*  ; restore everything
04040C 2A 9F 05 04 0730*      ld hl, (uhl)
040410 ED 4B A2 05 0731*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0732*      ld de, (ude)
       04          
04041A DD 2A A8 05 0733*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0734*      ld iy, (uiy)
       04          
040424 F1          0735*      pop af
040425             0736*  ; all done
040425 C9          0737*      ret
040426             0738*  
040426             0739*  ; print registers to screen in hexidecimal format
040426             0740*  ; inputs: none
040426             0741*  ; outputs: values of every register printed to screen
040426             0742*  ;    values of each register in global scratch memory
040426             0743*  ; destroys: nothing
040426             0744*  dumpRegistersHex:
040426             0745*  ; store everything in scratch
040426 22 9F 05 04 0746*      ld (uhl),hl
04042A ED 43 A2 05 0747*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0748*      ld (ude),de
       04          
040434 DD 22 A8 05 0749*      ld (uix),ix
       04          
040439 FD 22 AB 05 0750*      ld (uiy),iy
       04          
04043E F5          0751*      push af ; fml
04043F E1          0752*      pop hl  ; thanks, zilog
040440 22 9C 05 04 0753*      ld (uaf),hl
040444 F5          0754*      push af ; dammit
040445             0755*  
040445             0756*  ; home the cursor
040445             0757*      ; call vdu_home_cursor
040445             0758*      ; call printNewLine
040445             0759*  
040445             0760*  ; print each register
040445 21 22 05 04 0761*      ld hl,str_afu
040449 CD 77 00 04 0762*      call printString
04044D 2A 9C 05 04 0763*      ld hl,(uaf)
040451 CD 97 00 04 0764*      call printHex24
040455             0765*      ; call printNewLine
040455             0766*  
040455 21 27 05 04 0767*      ld hl,str_hlu
040459 CD 77 00 04 0768*      call printString
04045D 2A 9F 05 04 0769*      ld hl,(uhl)
040461 CD 97 00 04 0770*      call printHex24
040465             0771*      ; call printNewLine
040465             0772*  
040465 21 2C 05 04 0773*      ld hl,str_bcu
040469 CD 77 00 04 0774*      call printString
04046D 2A A2 05 04 0775*      ld hl,(ubc)
040471 CD 97 00 04 0776*      call printHex24
040475             0777*      ; call printNewLine
040475             0778*  
040475 21 31 05 04 0779*      ld hl,str_deu
040479 CD 77 00 04 0780*      call printString
04047D 2A A5 05 04 0781*      ld hl,(ude)
040481 CD 97 00 04 0782*      call printHex24
040485             0783*      ; call printNewLine
040485             0784*  
040485 21 36 05 04 0785*      ld hl,str_ixu
040489 CD 77 00 04 0786*      call printString
04048D 2A A8 05 04 0787*      ld hl,(uix)
040491 CD 97 00 04 0788*      call printHex24
040495             0789*      ; call printNewLine
040495             0790*  
040495 21 3B 05 04 0791*      ld hl,str_iyu
040499 CD 77 00 04 0792*      call printString
04049D 2A AB 05 04 0793*      ld hl,(uiy)
0404A1 CD 97 00 04 0794*      call printHex24
0404A5             0795*      ; call printNewLine
0404A5             0796*  
0404A5             0797*      ; call vdu_vblank
0404A5             0798*  
0404A5 CD 8C 00 04 0799*      call printNewLine
0404A9             0800*  ; restore everything
0404A9 2A 9F 05 04 0801*      ld hl, (uhl)
0404AD ED 4B A2 05 0802*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0803*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0804*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0805*      ld iy, (uiy)
       04          
0404C1 F1          0806*      pop af
0404C2             0807*  ; all done
0404C2 C9          0808*      ret
0404C3             0809*  
0404C3             0810*  dumpRegistersHexPrime:
0404C3 D9          0811*      exx
0404C4 08          0812*      ex af,af'
0404C5 CD 26 04 04 0813*      call dumpRegistersHex
0404C9 08          0814*      ex af,af'
0404CA D9          0815*      exx
0404CB C9          0816*      ret
0404CC             0817*  
0404CC             0818*  ; additionally dump prime registers
0404CC             0819*  ; inputs: none
0404CC             0820*  ; outputs: values of every register printed to screen
0404CC             0821*  ; destroys: nothing
0404CC             0822*  dumpRegistersHexAll:
0404CC CD 26 04 04 0823*      call dumpRegistersHex
0404D0 08          0824*      ex af,af'
0404D1 D9          0825*      exx
0404D2 CD 26 04 04 0826*      call dumpRegistersHex
0404D6 08          0827*      ex af,af'
0404D7 D9          0828*      exx
0404D8 C9          0829*      ret
0404D9             0830*  
0404D9             0831*  ; print hlu to screen in hexidecimal format
0404D9             0832*  ; inputs: none
0404D9             0833*  ; destroys: nothing
0404D9             0834*  print_hex_hl:
0404D9 F5          0835*      push af
0404DA E5          0836*      push hl
0404DB 21 27 05 04 0837*      ld hl,str_hlu
0404DF CD 77 00 04 0838*      call printString
0404E3 E1          0839*      pop hl
0404E4 E5          0840*      push hl
0404E5 CD 97 00 04 0841*      call printHex24
0404E9 3E 20       0842*      ld a,' '
0404EB 5B D7       0843*      rst.lil 10h
0404ED E1          0844*      pop hl
0404EE F1          0845*      pop af
0404EF C9          0846*      ret
0404F0             0847*  
0404F0             0848*  ; print bcu to screen in hexidecimal format
0404F0             0849*  ; inputs: none
0404F0             0850*  ; destroys: nothing
0404F0             0851*  print_hex_bc:
0404F0 F5          0852*      push af
0404F1 E5          0853*      push hl
0404F2 C5          0854*      push bc
0404F3 21 2C 05 04 0855*      ld hl,str_bcu
0404F7 CD 77 00 04 0856*      call printString
0404FB E1          0857*      pop hl
0404FC E5          0858*      push hl
0404FD CD 97 00 04 0859*      call printHex24
040501 3E 20       0860*      ld a,' '
040503 5B D7       0861*      rst.lil 10h
040505 C1          0862*      pop bc
040506 E1          0863*      pop hl
040507 F1          0864*      pop af
040508 C9          0865*      ret
040509             0866*  
040509             0867*  ; print deu to screen in hexidecimal format
040509             0868*  ; inputs: none
040509             0869*  ; destroys: nothing
040509             0870*  print_hex_de:
040509 F5          0871*      push af
04050A E5          0872*      push hl
04050B D5          0873*      push de
04050C 21 31 05 04 0874*      ld hl,str_deu
040510 CD 77 00 04 0875*      call printString
040514 E1          0876*      pop hl
040515 E5          0877*      push hl
040516 CD 97 00 04 0878*      call printHex24
04051A 3E 20       0879*      ld a,' '
04051C 5B D7       0880*      rst.lil 10h
04051E D1          0881*      pop de
04051F E1          0882*      pop hl
040520 F1          0883*      pop af
040521 C9          0884*      ret
040522             0885*  
040522 20 61 66 3D 0886*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0887*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0888*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0889*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0890*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0891*  str_iyu: db " iy=",0
       00          
040540             0892*  
040540             0893*  ; print udeuhl to screen in hexidecimal format
040540             0894*  ; inputs: none
040540             0895*  ; outputs: concatenated hexidecimal udeuhl
040540             0896*  ; destroys: nothing
040540             0897*  dumpUDEUHLHex:
040540             0898*  ; store everything in scratch
040540 22 9F 05 04 0899*      ld (uhl),hl
040544 ED 43 A2 05 0900*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0901*      ld (ude),de
       04          
04054E DD 22 A8 05 0902*      ld (uix),ix
       04          
040553 FD 22 AB 05 0903*      ld (uiy),iy
       04          
040558 F5          0904*      push af
040559             0905*  
040559             0906*  ; print each register
040559             0907*  
040559 21 93 05 04 0908*      ld hl,str_udeuhl
04055D CD 77 00 04 0909*      call printString
040561 2A A5 05 04 0910*      ld hl,(ude)
040565 CD 97 00 04 0911*      call printHex24
040569 3E 2E       0912*  	ld a,'.'	; print a dot to separate the values
04056B 5B D7       0913*  	rst.lil 10h
04056D 2A 9F 05 04 0914*      ld hl,(uhl)
040571 CD 97 00 04 0915*      call printHex24
040575 CD 8C 00 04 0916*      call printNewLine
040579             0917*  
040579             0918*  ; restore everything
040579 2A 9F 05 04 0919*      ld hl, (uhl)
04057D ED 4B A2 05 0920*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0921*      ld de, (ude)
       04          
040587 DD 2A A8 05 0922*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0923*      ld iy, (uiy)
       04          
040591 F1          0924*      pop af
040592             0925*  ; all done
040592 C9          0926*      ret
040593             0927*  
040593 75 64 65 2E 0928*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0929*  
04059C             0930*  ; global scratch memory for registers
04059C 00 00 00    0931*  uaf: dl 0
04059F 00 00 00    0932*  uhl: dl 0
0405A2 00 00 00    0933*  ubc: dl 0
0405A5 00 00 00    0934*  ude: dl 0
0405A8 00 00 00    0935*  uix: dl 0
0405AB 00 00 00    0936*  uiy: dl 0
0405AE 00 00 00    0937*  usp: dl 0
0405B1 00 00 00    0938*  upc: dl 0
0405B4             0939*  
0405B4             0940*  ; inputs: whatever is in the flags register
0405B4             0941*  ; outputs: binary representation of flags
0405B4             0942*  ;          with a header so we know which is what
0405B4             0943*  ; destroys: nothing
0405B4             0944*  ; preserves: everything
0405B4             0945*  dumpFlags:
0405B4             0946*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0947*      push af ; this is so we can send it back unharmed
0405B5 F5          0948*      push af ; this is so we can pop it to hl
0405B6             0949*  ; store everything in scratch
0405B6 22 9F 05 04 0950*      ld (uhl),hl
0405BA ED 43 A2 05 0951*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0952*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0953*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0954*      ld (uiy),iy
       04          
0405CE             0955*  ; next we print the header
0405CE 21 FA 05 04 0956*      ld hl,@header
0405D2 CD 77 00 04 0957*      call printString
0405D6 E1          0958*      pop hl ; flags are now in l
0405D7 7D          0959*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0960*      call printBin8
0405DC CD 8C 00 04 0961*  	call printNewLine
0405E0             0962*  ; restore everything
0405E0 2A 9F 05 04 0963*      ld hl, (uhl)
0405E4 ED 4B A2 05 0964*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0965*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0966*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0967*      ld iy, (uiy)
       04          
0405F8 F1          0968*      pop af ; send her home the way she came
0405F9 C9          0969*      ret
0405FA             0970*  ; Bit 7 (S): Sign flag
0405FA             0971*  ; Bit 6 (Z): Zero flag
0405FA             0972*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0973*  ; Bit 4 (H): Half Carry flag
0405FA             0974*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0975*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0976*  ; Bit 1 (N): Subtract flag
0405FA             0977*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0978*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0979*  
040605             0980*  ; set all the bits in the flag register
040605             0981*  ; more of an academic exercise than anything useful
040605             0982*  ; inputs; none
040605             0983*  ; outputs; a=0,f=255
040605             0984*  ; destroys: flags, hl
040605             0985*  ; preserves: a, because why not
040605             0986*  setAllFlags:
040605 21 FF 00 00 0987*      ld hl,255
040609 67          0988*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0989*      push hl
04060B F1          0990*      pop af
04060C C9          0991*      ret
04060D             0992*  
04060D             0993*  ; reset all the bits in the flag register
04060D             0994*  ; unlike its inverse counterpart, this may actually be useful
04060D             0995*  ; inputs; none
04060D             0996*  ; outputs; a=0,f=0
04060D             0997*  ; destroys: flags, hl
04060D             0998*  ; preserves: a, because why not
04060D             0999*  resetAllFlags:
04060D 21 00 00 00 1000*      ld hl,0
040611 67          1001*      ld h,a ; four cycles to preserve a is cheap
040612 E5          1002*      push hl
040613 F1          1003*      pop af
040614 C9          1004*      ret
040615             1005*  
040615             1006*  ; wait until user presses a key
040615             1007*  ; inputs: none
040615             1008*  ; outputs: ascii code of key pressed in a
040615             1009*  ; destroys: af,ix
040615             1010*  waitKeypress:
040615             1011*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 49 CF       0002*M 			RST.LIS	08h
040619 C9          1012*      ret
04061A             1013*  
04061A             1014*  ; print bytes from an address to the screen in hexidecimal format
04061A             1015*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1016*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1017*  ; destroys: nothing
04061A             1018*  dumpMemoryHex:
04061A             1019*  ; save registers to the stack
04061A C5          1020*      push bc
04061B E5          1021*      push hl
04061C F5          1022*      push af
04061D             1023*  
04061D             1024*  ; print the address and separator
04061D CD 97 00 04 1025*      call printHex24
040621 3E 3A       1026*      ld a,':'
040623 5B D7       1027*      rst.lil 10h
040625 3E 20       1028*      ld a,' '
040627 5B D7       1029*      rst.lil 10h
040629             1030*  
040629             1031*  ; set b to be our loop counter
040629 F1          1032*      pop af
04062A 47          1033*      ld b,a
04062B E1          1034*      pop hl
04062C E5          1035*      push hl
04062D F5          1036*      push af
04062E             1037*  @loop:
04062E             1038*  ; print the byte
04062E 7E          1039*      ld a,(hl)
04062F CD A5 00 04 1040*      call printHex8
040633             1041*  ; print a space
040633 3E 20       1042*      ld a,' '
040635 5B D7       1043*      rst.lil 10h
040637 23          1044*      inc hl
040638 10 F4       1045*      djnz @loop
04063A CD 8C 00 04 1046*      call printNewLine
04063E             1047*  
04063E             1048*  ; restore everything
04063E F1          1049*      pop af
04063F E1          1050*      pop hl
040640 C1          1051*      pop bc
040641             1052*  
040641             1053*  ; all done
040641 C9          1054*      ret
040642             1055*  
040642             1056*  
040642             1057*  ; print bytes from an address to the screen in binary format
040642             1058*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1059*  ; outputs: values of each byte printed to screen separated by spaces
040642             1060*  ; destroys: nothing
040642             1061*  dumpMemoryBin:
040642             1062*  ; save all registers to the stack
040642 F5          1063*      push af
040643 C5          1064*      push bc
040644 D5          1065*      push de
040645 E5          1066*      push hl
040646 DD E5       1067*      push ix
040648 FD E5       1068*      push iy
04064A             1069*  
04064A             1070*  ; set b to be our loop counter
04064A 47          1071*      ld b,a
04064B             1072*  @loop:
04064B             1073*  ; print the byte
04064B 7E          1074*      ld a,(hl)
04064C E5          1075*      push hl
04064D C5          1076*      push bc
04064E CD 15 03 04 1077*      call printBin8
040652 C1          1078*      pop bc
040653             1079*  ; print a space
040653 3E 20       1080*      ld a,' '
040655 5B D7       1081*      rst.lil 10h
040657 E1          1082*      pop hl
040658 23          1083*      inc hl
040659 10 F0       1084*      djnz @loop
04065B CD 8C 00 04 1085*      call printNewLine
04065F             1086*  
04065F             1087*  ; restore everything
04065F FD E1       1088*      pop iy
040661 DD E1       1089*      pop ix
040663 E1          1090*      pop hl
040664 D1          1091*      pop de
040665 C1          1092*      pop bc
040666 F1          1093*      pop af
040667             1094*  ; all done
040667 C9          1095*      ret
040668             1096*  
040668             1097*  ; print bytes from an address to the screen in binary format
040668             1098*  ; with the bits of each byte in reverse order (lsb first)
040668             1099*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1100*  ; outputs: values of each byte printed to screen separated by spaces
040668             1101*  ; destroys: nothing
040668             1102*  dumpMemoryBinRev:
040668             1103*  ; save all registers to the stack
040668 F5          1104*      push af
040669 C5          1105*      push bc
04066A D5          1106*      push de
04066B E5          1107*      push hl
04066C DD E5       1108*      push ix
04066E FD E5       1109*      push iy
040670             1110*  
040670             1111*  ; set b to be our loop counter
040670 47          1112*      ld b,a
040671             1113*  @loop:
040671             1114*  ; print the byte
040671 7E          1115*      ld a,(hl)
040672 E5          1116*      push hl
040673 C5          1117*      push bc
040674 CD 3A 03 04 1118*      call printBin8Rev
040678 C1          1119*      pop bc
040679             1120*  ; print a space
040679 3E 20       1121*      ld a,' '
04067B 5B D7       1122*      rst.lil 10h
04067D E1          1123*      pop hl
04067E 23          1124*      inc hl
04067F 10 F0       1125*      djnz @loop
040681 CD 8C 00 04 1126*      call printNewLine
040685             1127*  
040685             1128*  ; restore everything
040685 FD E1       1129*      pop iy
040687 DD E1       1130*      pop ix
040689 E1          1131*      pop hl
04068A D1          1132*      pop de
04068B C1          1133*      pop bc
04068C F1          1134*      pop af
04068D             1135*  ; all done
04068D C9          1136*      ret
04068E             0035   	include "files.inc"
04068E             0001*  ; load to onboard 8k sram
04068E             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04068E             0036   	include "fonts_bmp.inc"
04068E             0001*  ; plots a bitmap character to the screen
04068E             0002*  ; inputs: a; ascii character to plot
04068E             0003*  ;      bc,de = x,y screen coordinates in pixels
04068E             0004*  ;      ix pointed at the font definition lut
04068E             0005*  ; returns: bc as the next x coordinate to plot
04068E             0006*  ;          pretty pixels which hopefully resemble readable text
04068E             0007*  ; destroys: lotsa stuff
04068E             0008*  font_bmp_plot:
04068E             0009*  ; back up bc,de
04068E C5          0010*      push bc
04068F D5          0011*      push de
040690             0012*  ; get the buffer id of the character
040690 D6 20       0013*      sub 32 ; lookup table starts at ascii 32
040692 06 06       0014*      ld b,6 ; six bytes per lookup record
040694 4F          0015*      ld c,a
040695 ED 4C       0016*      mlt bc
040697 DD 09       0017*      add ix,bc ; now ix points to the character definition
040699 DD 27 03    0018*      ld hl,(ix+3) ; hl has the buffer id
04069C CD 74 09 04 0019*      call vdu_buff_select
0406A0             0020*  ; plot the character
0406A0 D1          0021*      pop de
0406A1 DD 7E 02    0022*      ld a,(ix+2) ; a has the y-offset of the character
0406A4 83          0023*      add a,e ; add the y-coordinate
0406A5 5F          0024*      ld e,a
0406A6 3E 00       0025*      ld a,0 ; can't xor it because we need carry
0406A8 8A          0026*      adc a,d
0406A9 57          0027*      ld d,a ; plot_y now correct for the character
0406AA C1          0028*      pop bc ; plot_x
0406AB C5          0029*      push bc ; we want it back after the plot
0406AC CD 5C 0C 04 0030*      call vdu_plot_bmp
0406B0             0031*  ; now set bc to the next x coordinate
0406B0 C1          0032*      pop bc
0406B1 DD 7E 00    0033*      ld a,(ix+0) ; a has the width of the character
0406B4 C6 02       0034*      add a,2 ; add a little padding between characters
0406B6 81          0035*      add a,c ; bump the original x-coordinate
0406B7 4F          0036*      ld c,a
0406B8 3E 00       0037*      ld a,0 ; can't xor it because we need carry
0406BA 88          0038*      adc a,b
0406BB 47          0039*      ld b,a ; plot_x now correct for the next character
0406BC C9          0040*      ret
0406BD             0041*  
0406BD             0042*  ; plots a zero-terminated string of bitmap characters to the screen
0406BD             0043*  ; inputs: hl; pointer to the string
0406BD             0044*  ;       bc,de = x,y screen coordinates in pixels
0406BD             0045*  ;       ix pointed at the font definition lut
0406BD             0046*  ; returns: bc as the next x coordinate to plot
0406BD             0047*  ;          de as the next y coordinate to plot
0406BD             0048*  ;          pretty pixels which hopefully resemble readable text
0406BD             0049*  font_bmp_print:
0406BD             0050*  @next_char:
0406BD             0051*  ; fetch the next character in the string
0406BD 7E          0052*      ld a,(hl) ; a has the ascii value of the character
0406BE FE 00       0053*      cp 0 ; is it zero?
0406C0 C8          0054*      ret z ; if so, we're done
0406C1 23          0055*      inc hl ; point to the next character
0406C2 E5          0056*      push hl ; save the pointer
0406C3 D5          0057*      push de ; save our y-coordinate
0406C4 DD E5       0058*      push ix ; save the font lut pointer
0406C6 CD 8E 06 04 0059*      call font_bmp_plot ; plot the character
0406CA DD E1       0060*      pop ix ; restore the font lut pointer
0406CC D1          0061*      pop de ; restore our y-coordinate
0406CD E1          0062*      pop hl ; restore the pointer
0406CE C3 BD 06 04 0063*      jp @next_char ; loop
0406D2             0037       include "timer.inc"
0406D2             0001*  ; Table 32. Timer Control Registers
0406D2             0002*  ; this constant is the base address of the timer control registers
0406D2             0003*  ; each timer takes three bytes:
0406D2             0004*  ;   0: control register
0406D2             0005*  ;   1: low byte of timer reset value
0406D2             0006*  ;   2: high byte of timer reset value
0406D2             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0406D2             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0406D2             0009*  TMR_CTL:     equ 80h
0406D2             0010*  
0406D2             0011*  ; Timer Control Register Bit Definitions
0406D2             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0406D2             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0406D2             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0406D2             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0406D2             0016*                              ; the TMRx_CTL register is read.
0406D2             0017*  
0406D2             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0406D2             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0406D2             0020*  
0406D2             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0406D2             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0406D2             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0406D2             0024*                              ; written to the counter when the end-of-count value is reached.
0406D2             0025*  
0406D2             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0406D2             0027*  CLK_DIV_256:  equ %00001100 ;
0406D2             0028*  CLK_DIV_64:   equ %00001000 ;
0406D2             0029*  CLK_DIV_16:   equ %00000100 ;
0406D2             0030*  CLK_DIV_4:    equ %00000000 ;
0406D2             0031*  
0406D2             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0406D2             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0406D2             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0406D2             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0406D2             0036*                              ; programmer must ensure that this bit is set to 1 each time
0406D2             0037*                              ; SINGLE-PASS mode is used.
0406D2             0038*  
0406D2             0039*  ; disable/enable the programmable reload timer
0406D2             0040*  PRT_EN_0:     equ %00000000 ;
0406D2             0041*  PRT_EN_1:     equ %00000001 ;
0406D2             0042*  
0406D2             0043*  ; Table 37. Timer Input Source Select Register
0406D2             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0406D2             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0406D2             0046*  ;   00: System clock / CLK_DIV
0406D2             0047*  ;   01: RTC / CLK_DIV
0406D2             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0406D2             0049*  ;   10: GPIO port B pin 1.
0406D2             0050*  ;   11: GPIO port B pin 1.
0406D2             0051*  TMR_ISS:   equ 92h ; register address
0406D2             0052*  
0406D2             0053*  ; Table 51. Real-Time Clock Control Register
0406D2             0054*  RTC_CTRL: equ EDh ; register address
0406D2             0055*  
0406D2             0056*  ; alarm interrupt disable/enable
0406D2             0057*  RTC_ALARM_0:    equ %00000000
0406D2             0058*  RTC_ALARM_1:    equ %10000000
0406D2             0059*  
0406D2             0060*  ; interrupt on alarm disable/enable
0406D2             0061*  RTC_INT_ENT_0:  equ %00000000
0406D2             0062*  RTC_INT_ENT_1:  equ %01000000
0406D2             0063*  
0406D2             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0406D2             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0406D2             0066*  
0406D2             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0406D2             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0406D2             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0406D2             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0406D2             0071*  
0406D2             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0406D2             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0406D2             0074*  
0406D2             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0406D2             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0406D2             0077*  
0406D2             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0406D2             0079*                                  ; RTC counter is enabled.
0406D2             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0406D2             0081*                                  ; RTC counter is disabled.
0406D2             0082*  
0406D2             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0406D2             0084*  
0406D2             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0406D2             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0406D2 00 00 00    0087*  prt_reload: dl 0x000000
0406D5             0088*  
0406D5             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0406D5             0090*  ; ;          de = number PRT interrupts during test interval
0406D5             0091*  ; prt_calibrate:
0406D5             0092*  ;     call vdu_vblank
0406D5             0093*  ; ; set a MOS timer
0406D5             0094*  ;     ld hl,120*1 ; 1 second
0406D5             0095*  ;     ld iy,tmr_test
0406D5             0096*  ;     call tmr_set
0406D5             0097*  ; ; set a PRT timer
0406D5             0098*  ;     ; ld hl,prt_reload_hardware
0406D5             0099*  ;     ; ld hl,prt_reload_emulator
0406D5             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0406D5             0101*  ;     ld (prt_reload),hl
0406D5             0102*  ;     call prt_set
0406D5             0103*  ; @loop:
0406D5             0104*  ; ; check time remaining on MOS timer
0406D5             0105*  ;     call tmr_get
0406D5             0106*  ;     jp z,@done ; time expired,so quit
0406D5             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0406D5             0108*  ;     jr @loop
0406D5             0109*  ; @done:
0406D5             0110*  ;     ld de,(prt_irq_counter)
0406D5             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0406D5             0112*  ;     ld (prt_reload),bc
0406D5             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0406D5             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0406D5             0115*  ;     ld (is_emulator),a
0406D5             0116*  ;     sbc hl,de
0406D5             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0406D5             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0406D5             0119*  ;     ret m ; negative result means we're on hardware
0406D5             0120*  ;     inc a ; we're on emulator
0406D5             0121*  ;     ld (is_emulator),a
0406D5             0122*  ;     ld bc,prt_reload_emulator
0406D5             0123*  ;     ld (prt_reload),bc
0406D5             0124*  ;     ld hl,on_emulator
0406D5             0125*  ;     ret
0406D5             0126*  
0406D5             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0406D5             0128*  
0406D5             0129*  ; set PRT timer
0406D5             0130*  prt_set:
0406D5 21 00 00 00 0131*      ld hl,0
0406D9 22 23 07 04 0132*      ld (prt_irq_counter),hl
0406DD 2A D2 06 04 0133*      ld hl,(prt_reload)
0406E1 ED 29 84    0134*      out0 ($84),l
0406E4 ED 21 85    0135*  	out0 ($85),h
0406E7             0136*  ; disable timer
0406E7 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0406E9 ED 39 83    0138*  	out0 ($83),a
0406EC             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0406EC 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0406EE ED 39 83    0141*  	out0 ($83),a
0406F1 C9          0142*      ret
0406F2             0143*  
0406F2             0144*  ; ===============================================
0406F2             0145*  ; PRT Timer Interrupt Handling
0406F2             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0406F2             0147*  ; -----------------------------------------------
0406F2             0148*  prt_irq_init:
0406F2             0149*      ; set up interrupt vector table 2
0406F2 21 00 00 00 0150*  	ld hl,0
0406F6 3A 0C 01 00 0151*  	ld a,($10c)
0406FA 6F          0152*  	ld l,a
0406FB 3A 0D 01 00 0153*  	ld a,($10d)
0406FF 67          0154*  	ld h,a
040700             0155*  
040700             0156*  	; skip over CALL ($c3)
040700 23          0157*  	inc hl
040701             0158*  	; load address of jump into vector table 2 (in ram)
040701 ED 27       0159*  	ld hl,(hl)
040703             0160*  
040703             0161*  	; write CALL prt_irq_handler to vector table 2
040703 3E C3       0162*  	ld a,$c3
040705 77          0163*  	ld (hl),a
040706 23          0164*  	inc hl
040707 11 0E 07 04 0165*  	ld de,prt_irq_handler
04070B ED 1F       0166*  	ld (hl),de
04070D             0167*  
04070D C9          0168*      ret
04070E             0169*  
04070E             0170*  prt_irq_handler:
04070E F3          0171*  	di
04070F F5          0172*  	push af
040710 E5          0173*      push hl
040711 ED 38 83    0174*  	in0 a,($83)
040714 2A 23 07 04 0175*  	ld hl,(prt_irq_counter)
040718 23          0176*  	inc hl
040719 22 23 07 04 0177*  	ld (prt_irq_counter),hl
04071D E1          0178*      pop hl
04071E F1          0179*  	pop af
04071F FB          0180*  	ei
040720 5B ED 4D    0181*  	reti.l
040723             0182*  
040723             0183*  prt_irq_counter:
040723 00 00 00    0184*  	.dl 0
040726             0185*  prt_irq_counter_saved:
040726 00 00 00    0186*      .dl 0
040729             0187*  
040729             0188*  prt_loop_reset:
040729 E5          0189*      push hl
04072A 21 00 00 00 0190*  	ld hl,0
04072E 22 23 07 04 0191*  	ld (prt_irq_counter),hl
040732 22 94 07 04 0192*      ld (prt_loop_counter),hl
040736 22 97 07 04 0193*      ld (prt_loops),hl
04073A CD D5 06 04 0194*      call prt_set
04073E E1          0195*      pop hl
04073F C9          0196*      ret
040740             0197*  
040740             0198*  prt_loop_start:
040740 E5          0199*      push hl
040741 21 00 00 00 0200*  	ld hl,0
040745 22 23 07 04 0201*  	ld (prt_irq_counter),hl
040749 E1          0202*      pop hl
04074A C9          0203*      ret
04074B             0204*  
04074B             0205*  prt_loop_stop:
04074B E5          0206*      push hl
04074C D5          0207*      push de
04074D 2A 23 07 04 0208*      ld hl,(prt_irq_counter)
040751 ED 5B 94 07 0209*      ld de,(prt_loop_counter)
       04          
040756 19          0210*      add hl,de
040757 22 94 07 04 0211*      ld (prt_loop_counter),hl
04075B 21 00 00 00 0212*      ld hl,0
04075F 22 23 07 04 0213*      ld (prt_irq_counter),hl
040763 2A 97 07 04 0214*      ld hl,(prt_loops)
040767 23          0215*      inc hl
040768 22 97 07 04 0216*      ld (prt_loops),hl
04076C D1          0217*      pop de
04076D E1          0218*      pop hl
04076E C9          0219*      ret
04076F             0220*  
04076F             0221*  ; inputs: bc = y,x text coordinates to print
04076F             0222*  prt_loop_print:
04076F F5          0223*      push af
040770 E5          0224*      push hl
040771 C5          0225*      push bc
040772 D5          0226*      push de
040773 DD E5       0227*      push ix
040775 FD E5       0228*      push iy
040777 CD 8C 08 04 0229*      call vdu_move_cursor
04077B             0230*  
04077B 2A 94 07 04 0231*      ld hl,(prt_loop_counter)
04077F CD 76 01 04 0232*      call printDec
040783             0233*  
040783 2A 97 07 04 0234*      ld hl,(prt_loops)
040787 CD 76 01 04 0235*      call printDec
04078B             0236*  
04078B FD E1       0237*      pop iy
04078D DD E1       0238*      pop ix
04078F D1          0239*      pop de
040790 C1          0240*      pop bc
040791 E1          0241*      pop hl
040792 F1          0242*      pop af
040793 C9          0243*      ret
040794             0244*  
040794             0245*  prt_loop_counter:
040794 00 00 00    0246*      .dl 0
040797             0247*  prt_loops:
040797 00 00 00    0248*      .dl 0
04079A             0249*  
04079A             0250*  ; ===============================================
04079A             0251*  ; Timer functions
04079A             0252*  ; -----------------------------------------------
04079A             0253*  ; set a countdown timer
04079A             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04079A             0255*  ; returns: hl = current time
04079A             0256*  tmr_set:
04079A FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
04079D             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
04079D 3E 08       0001*M 			LD	A, function
04079F 49 CF       0002*M 			RST.LIS	08h
0407A1 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0407A4 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0407A7 C9          0261*      ret
0407A8             0262*  
0407A8             0263*  ; gets time remaining on a countdown timer
0407A8             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0407A8             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0407A8             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0407A8             0267*  tmr_get:
0407A8             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0407A8 3E 08       0001*M 			LD	A, function
0407AA 49 CF       0002*M 			RST.LIS	08h
0407AC DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0407AF FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0407B2 AF          0271*      xor a                   ; clear carry
0407B3 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0407B5 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0407B8 AF          0274*      xor a                   ; clear carry
0407B9 ED 5A       0275*      adc hl,de               ; hl = time remaining
0407BB             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0407BB C9          0277*      ret
0407BC             0278*  
0407BC 00 00 00    0279*  timestamp_now: dl 0
0407BF 00 00 00    0280*  timestamp_old: dl 0
0407C2 00 00 00    0281*  timestamp_chg: dl 0
0407C5             0282*  
0407C5             0283*  ; update the global timestamp from the system clock
0407C5             0284*  ; inputs: none
0407C5             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0407C5             0286*  ;          de = current time
0407C5             0287*  ;          ix = pointer to syvars table
0407C5             0288*  ; destroys: af,hl,de,ix
0407C5             0289*  timestamp_tick:
0407C5 ED 5B BC 07 0290*      ld de,(timestamp_now)   ; get previous time
       04          
0407CA ED 53 BF 07 0291*      ld (timestamp_old),de   ; save previous time
       04          
0407CF             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0407CF 3E 08       0001*M 			LD	A, function
0407D1 49 CF       0002*M 			RST.LIS	08h
0407D3 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0407D6 22 BC 07 04 0294*      ld (timestamp_now),hl   ; save current time
0407DA AF          0295*      xor a                   ; clear carry
0407DB ED 52       0296*      sbc hl,de               ; hl = time elapsed
0407DD 22 C2 07 04 0297*      ld (timestamp_chg),hl   ; save elapsed time
0407E1 C9          0298*      ret
0407E2             0299*  
0407E2             0300*  ; set a countdown timer
0407E2             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0407E2             0302*  ; requires: timestamp_tick to be called at least once before this function
0407E2             0303*  ; returns: hl = current time
0407E2             0304*  ; destroys: hl
0407E2             0305*  timestamp_tmr_set:
0407E2 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0407E5 2A BC 07 04 0307*      ld hl,(timestamp_now)   ; get current timestamp
0407E9 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0407EC C9          0309*      ret
0407ED             0310*  
0407ED             0311*  ; gets time remaining on a countdown timer following the global timestamp
0407ED             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0407ED             0313*  ; requires: timestamp_tick to be called at least once before this function
0407ED             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0407ED             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0407ED             0316*  ; destroys: af,hl,de
0407ED             0317*  timestamp_tmr_get:
0407ED ED 5B BC 07 0318*      ld de,(timestamp_now)   ; get current timestamp
       04          
0407F2 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0407F5 AF          0320*      xor a                   ; clear carry
0407F6 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0407F8 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0407FB AF          0323*      xor a                   ; clear carry
0407FC ED 5A       0324*      adc hl,de               ; hl = time remaining
0407FE             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0407FE C9          0326*      ret
0407FF             0327*  
0407FF             0328*  ; main loop timer functions
0407FF             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
040805             0330*  
040805             0331*  ; set a countdown timer for the main loop using the timestamp timer
040805             0332*  ; inputs: hl = time to set in 1/120ths of a second
040805             0333*  ; returns: hl = current time
040805             0334*  ; destroys: af,hl,de,ix,iy
040805             0335*  tmr_main_loop_set:
040805 FD 21 FF 07 0336*      ld iy,tmr_main_loop
       04          
04080A FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
04080D CD C5 07 04 0338*      call timestamp_tick
040811 2A BC 07 04 0339*      ld hl,(timestamp_now)   ; get current timestamp
040815 FD 2F 00    0340*      ld (iy+0),hl ; set start time
040818 C9          0341*      ret
040819             0342*  
040819             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
040819             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
040819             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
040819             0346*  ; destroys: af,hl,de,ix,iy
040819             0347*  tmr_main_loop_get:
040819 CD C5 07 04 0348*      call timestamp_tick
04081D FD 21 FF 07 0349*      ld iy,tmr_main_loop
       04          
040822 CD ED 07 04 0350*      call timestamp_tmr_get
040826 C9          0351*      ret
040827             0352*  
040827             0353*  ; set a stopwatch
040827             0354*  ; returns: hl = start time
040827             0355*  ; destroys: hl,ix
040827             0356*  stopwatch_set:
040827             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
040827 3E 08       0001*M 			LD	A, function
040829 49 CF       0002*M 			RST.LIS	08h
04082B DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
04082E 22 43 08 04 0359*      ld (stopwatch_started),hl            ; set start time
040832 C9          0360*      ret
040833             0361*  
040833             0362*  ; gets time elapsed on a stopwatch
040833             0363*  ; returns: hl = time elapsed in 1/120ths of a second
040833             0364*  ; destroys: af,hl,de,ix
040833             0365*  stopwatch_get:
040833             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
040833 3E 08       0001*M 			LD	A, function
040835 49 CF       0002*M 			RST.LIS	08h
040837 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
04083A ED 5B 43 08 0368*      ld de,(stopwatch_started)            ; get start time
       04          
04083F AF          0369*      xor a                   ; clear carry
040840 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
040842 C9          0371*      ret
040843             0372*  
040843             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
040846             0374*  
040846             0375*  ; ------------------
040846             0376*  ; delay routine
040846             0377*  ; Author: Richard Turrnidge
040846             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
040846             0379*  ; routine waits a fixed time,then returns
040846             0380*  ; arrive with A =  the delay byte. One bit to be set only.
040846             0381*  ; eg. ld A,00000100b
040846             0382*  
040846             0383*  multiPurposeDelay:
040846 F5          0384*      push af
040847 C5          0385*      push bc
040848 DD E5       0386*      push ix
04084A 47          0387*      ld b,a
04084B 3E 08       0388*      ld a,$08
04084D 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
04084F             0390*  
04084F             0391*  waitLoop:
04084F             0392*  
04084F DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
040852             0394*  
040852             0395*                                  ;   we check if bit set is same as last time we checked.
040852             0396*                                  ;   bit 0 - don't use
040852             0397*                                  ;   bit 1 - changes 64 times per second
040852             0398*                                  ;   bit 2 - changes 32 times per second
040852             0399*                                  ;   bit 3 - changes 16 times per second
040852             0400*  
040852             0401*                                  ;   bit 4 - changes 8 times per second
040852             0402*                                  ;   bit 5 - changes 4 times per second
040852             0403*                                  ;   bit 6 - changes 2 times per second
040852             0404*                                  ;   bit 7 - changes 1 times per second
040852 A0          0405*      and b
040853 4F          0406*      ld c,a
040854 3A 65 08 04 0407*      ld a,(oldTimeStamp)
040858 B9          0408*      cp c                        ; is A same as last value?
040859 28 F4       0409*      jr z,waitLoop              ; loop here if it is
04085B 79          0410*      ld a,c
04085C 32 65 08 04 0411*      ld (oldTimeStamp),a        ; set new value
040860             0412*  
040860 DD E1       0413*      pop ix
040862 C1          0414*      pop bc
040863 F1          0415*      pop af
040864 C9          0416*      ret
040865             0417*  
040865 00          0418*  oldTimeStamp:   .db 00h
040866             0038       include "vdu.inc"
040866             0001*  
040866             0002*  ; VDU 30: Home cursor
040866             0003*  vdu_home_cursor:
040866 3E 1E       0004*      ld a,30
040868 5B D7       0005*  	rst.lil $10
04086A C9          0006*  	ret
04086B             0007*  
04086B             0008*  cursor_on:
04086B 21 76 08 04 0009*  	ld hl,@cmd
04086F 01 03 00 00 0010*  	ld bc,@end-@cmd
040873 5B DF       0011*  	rst.lil $18
040875 C9          0012*  	ret
040876             0013*  @cmd:
040876 17 01 01    0014*  	db 23,1,1
040879             0015*  @end:
040879             0016*  
040879             0017*  cursor_off:
040879 21 84 08 04 0018*  	ld hl,@cmd
04087D 01 03 00 00 0019*  	ld bc,@end-@cmd
040881 5B DF       0020*  	rst.lil $18
040883 C9          0021*  	ret
040884             0022*  @cmd:
040884 17 01 00    0023*  	db 23,1,0
040887             0024*  @end:
040887             0025*  
040887             0026*  ; VDU 9: Move cursor forward one character
040887             0027*  vdu_cursor_forward:
040887 3E 09       0028*      ld a,9
040889 5B D7       0029*  	rst.lil $10
04088B C9          0030*  	ret
04088C             0031*  
04088C             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04088C             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
04088C             0034*  vdu_move_cursor:
04088C ED 43 9D 08 0035*      ld (@x0),bc
       04          
040891 21 9C 08 04 0036*  	ld hl,@cmd
040895 01 03 00 00 0037*  	ld bc,@end-@cmd
040899 5B DF       0038*  	rst.lil $18
04089B C9          0039*  	ret
04089C 1F          0040*  @cmd: 	db 31
04089D 00          0041*  @x0:	db 0
04089E 00          0042*  @y0: 	db 0
04089F 00          0043*  @end: 	db 0 ; padding
0408A0             0044*  
0408A0             0045*  ; VDU 12: Clear text area (CLS)
0408A0             0046*  vdu_cls:
0408A0 3E 0C       0047*      ld a,12
0408A2 5B D7       0048*  	rst.lil $10
0408A4 C9          0049*  	ret
0408A5             0050*  
0408A5             0051*  vdu_flip:
0408A5 21 B0 08 04 0052*  	ld hl,@cmd
0408A9 01 03 00 00 0053*  	ld bc,@end-@cmd
0408AD 5B DF       0054*  	rst.lil $18
0408AF C9          0055*  	ret
0408B0 17 00 C3    0056*  @cmd: db 23,0,0xC3
0408B3             0057*  @end:
0408B3             0058*  
0408B3             0059*  ; VDU 16: Clear graphics area (CLG)
0408B3             0060*  vdu_clg:
0408B3 3E 10       0061*      ld a,16
0408B5 5B D7       0062*  	rst.lil $10
0408B7 C9          0063*  	ret
0408B8             0064*  
0408B8             0065*  ; COLOUR MODES
0408B8             0066*  ; Mode	Effect
0408B8             0067*  ; 0	Set on-screen pixel to target colour value
0408B8             0068*  ; 1	OR value with the on-screen pixel
0408B8             0069*  ; 2	AND value with the on-screen pixel
0408B8             0070*  ; 3	XOR value with the on-screen pixel
0408B8             0071*  ; 4	Invert the on-screen pixel
0408B8             0072*  ; 5	No operation
0408B8             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0408B8             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0408B8             0075*  
0408B8             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0408B8             0077*  vdu_colour_text:
0408B8 32 C8 08 04 0078*  	ld (@arg),a
0408BC 21 C7 08 04 0079*  	ld hl,@cmd
0408C0 01 02 00 00 0080*  	ld bc,@end-@cmd
0408C4 5B DF       0081*  	rst.lil $18
0408C6 C9          0082*  	ret
0408C7 11          0083*  @cmd: db 17
0408C8 00          0084*  @arg: db 0
0408C9             0085*  @end:
0408C9             0086*  
0408C9             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0408C9             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0408C9             0089*  vdu_gcol:
0408C9 32 DE 08 04 0090*  	ld (@mode),a
0408CD 79          0091*      ld a,c
0408CE 32 DF 08 04 0092*      ld (@col),a
0408D2 21 DD 08 04 0093*  	ld hl,@cmd
0408D6 01 03 00 00 0094*  	ld bc,@end-@cmd
0408DA 5B DF       0095*  	rst.lil $18
0408DC C9          0096*  	ret
0408DD 12          0097*  @cmd:  db 18
0408DE 00          0098*  @mode: db 0
0408DF 00          0099*  @col:  db 0
0408E0             0100*  @end:
0408E0             0101*  
0408E0             0102*  
0408E0             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0408E0             0104*  ; MIND THE LITTLE-ENDIANESS
0408E0             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0408E0             0106*  ; outputs; nothing
0408E0             0107*  ; destroys: a might make it out alive
0408E0             0108*  vdu_set_txt_viewport:
0408E0 ED 43 F6 08 0109*      ld (@lb),bc
       04          
0408E5 ED 53 F8 08 0110*  	ld (@rt),de
       04          
0408EA 21 F5 08 04 0111*  	ld hl,@cmd
0408EE 01 05 00 00 0112*  	ld bc,@end-@cmd
0408F2 5B DF       0113*  	rst.lil $18
0408F4 C9          0114*  	ret
0408F5 1C          0115*  @cmd:   db 28 ; set text viewport command
0408F6 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0408F8 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0408FA 00          0118*  @end:   db 0x00	  ; padding
0408FB             0119*  
0408FB             0120*  ; Wait for VBLANK interrupt
0408FB             0121*  vdu_vblank:
0408FB DD E5       0122*      PUSH 	IX
0408FD             0123*  	MOSCALL	mos_sysvars
0408FD 3E 08       0001*M 			LD	A, function
0408FF 49 CF       0002*M 			RST.LIS	08h
040901 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
040904             0125*  @wait:
040904 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
040907 28 FB       0127*      JR	Z, @wait
040909 DD E1       0128*      POP	IX
04090B C9          0129*      RET
04090C             0130*  
04090C             0131*  ; VDU 29, x; y;: Set graphics origin
04090C             0132*  ; This command sets the graphics origin.
04090C             0133*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04090C             0134*  ; inputs: bc=x0,de=y0
04090C             0135*  ; outputs; nothing
04090C             0136*  ; destroys: a might make it out alive
04090C             0137*  vdu_set_gfx_origin:
04090C ED 43 22 09 0138*      ld (@x0),bc
       04          
040911 ED 53 24 09 0139*      ld (@y0),de
       04          
040916 21 21 09 04 0140*      ld hl,@cmd
04091A 01 05 00 00 0141*      ld bc,@end-@cmd
04091E 5B DF       0142*      rst.lil $18
040920 C9          0143*      ret
040921 1D          0144*  @cmd:   db 29 ; set graphics origin command
040922 00 00       0145*  @x0: 	dw 0x0000 ; set by bc
040924 00 00       0146*  @y0: 	dw 0x0000 ; set by de
040926 00          0147*  @end:   db 0x00	  ; padding
040927             0148*  
040927             0149*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040927             0150*  ; NOTE: the order of the y-coordinate parameters are inverted
040927             0151*  ; 	because we have turned off logical screen scaling
040927             0152*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040927             0153*  ; outputs; nothing
040927             0154*  ; destroys: a might make it out alive
040927             0155*  vdu_set_gfx_viewport:
040927 ED 43 47 09 0156*      ld (@x0),bc
       04          
04092C FD 22 49 09 0157*      ld (@y1),iy
       04          
040931 DD 22 4B 09 0158*  	ld (@x1),ix
       04          
040936 ED 53 4D 09 0159*  	ld (@y0),de
       04          
04093B 21 46 09 04 0160*  	ld hl,@cmd
04093F 01 09 00 00 0161*  	ld bc,@end-@cmd
040943 5B DF       0162*  	rst.lil $18
040945 C9          0163*  	ret
040946 18          0164*  @cmd:   db 24 ; set graphics viewport command
040947 00 00       0165*  @x0: 	dw 0x0000 ; set by bc
040949 00 00       0166*  @y1: 	dw 0x0000 ; set by iy
04094B 00 00       0167*  @x1: 	dw 0x0000 ; set by ix
04094D 00 00       0168*  @y0: 	dw 0x0000 ; set by de
04094F 00          0169*  @end:   db 0x00	  ; padding
040950             0170*  
040950             0171*  ; SCREEN MODES
040950             0172*  ; ===============================
040950             0173*  ; Mode  Horz  Vert  Cols  Refresh
040950             0174*  ; ---   ----  ----  ----  -------
040950             0175*  ; 11    320   240   2     60hz
040950             0176*  ; 139   320   240   2     60hz
040950             0177*  ; 23    512   384   2     60hz
040950             0178*  ; 151   512   384   2     60hz
040950             0179*  ; 6     640   240   2     60hz
040950             0180*  ; 134   640   240   2     60hz
040950             0181*  ; 2     640   480   2     60hz
040950             0182*  ; 130   640   480   2     60hz
040950             0183*  ; 17    800   600   2     60hz
040950             0184*  ; 145   800   600   2     60hz
040950             0185*  ; 18    1024  768   2     60hz
040950             0186*  ; 146   1024  768   2     60hz
040950             0187*  ; ---   ----  ----  ----  -------
040950             0188*  ; 10    320   240   4     60hz
040950             0189*  ; 138   320   240   4     60hz
040950             0190*  ; 22    512   384   4     60hz
040950             0191*  ; 150   512   384   4     60hz
040950             0192*  ; 5     640   240   4     60hz
040950             0193*  ; 133   640   240   4     60hz
040950             0194*  ; 1     640   480   4     60hz
040950             0195*  ; 129   640   480   4     60hz
040950             0196*  ; 16    800   600   4     60hz
040950             0197*  ; 19    1024  768   4     60hz
040950             0198*  ; ---   ----  ----  ----  -------
040950             0199*  ; 9     320   240   16    60hz
040950             0200*  ; 137   320   240   16    60hz
040950             0201*  ; 21    512   384   16    60hz
040950             0202*  ; 149   512   384   16    60hz
040950             0203*  ; 4     640   240   16    60hz
040950             0204*  ; 132   640   240   16    60hz
040950             0205*  ; 0     640   480   16    60hz
040950             0206*  ; 7     n/a   n/a   16    60hz
040950             0207*  ; ---   ----  ----  ----  -------
040950             0208*  ; 8     320   240   64    60hz
040950             0209*  ; 136   320   240   64    60hz
040950             0210*  ; 20    512   384   64    60hz
040950             0211*  ; 3     640   240   64    60hz
040950             0212*  ; ---   ----  ----  ----  -------
040950             0213*  vdu_set_screen_mode:
040950 32 60 09 04 0214*  	ld (@arg),a
040954 21 5F 09 04 0215*  	ld hl,@cmd
040958 01 02 00 00 0216*  	ld bc,@end-@cmd
04095C 5B DF       0217*  	rst.lil $18
04095E C9          0218*  	ret
04095F 16          0219*  @cmd: db 22 ; set screen mode
040960 00          0220*  @arg: db 0  ; screen mode parameter
040961             0221*  @end:
040961             0222*  
040961             0223*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
040961             0224*  ; inputs: a is scaling mode, 1=on, 0=off
040961             0225*  ; note: default setting on boot is scaling ON
040961             0226*  vdu_set_scaling:
040961 32 73 09 04 0227*  	ld (@arg),a
040965 21 70 09 04 0228*  	ld hl,@cmd
040969 01 04 00 00 0229*  	ld bc,@end-@cmd
04096D 5B DF       0230*  	rst.lil $18
04096F C9          0231*  	ret
040970 17 00 C0    0232*  @cmd: db 23,0,0xC0
040973 00          0233*  @arg: db 0  ; scaling on/off
040974             0234*  @end:
040974             0235*  
040974             0236*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
040974             0237*  ; inputs: hl=bufferId
040974             0238*  vdu_buff_select:
040974 22 86 09 04 0239*  	ld (@bufferId),hl
040978 21 83 09 04 0240*  	ld hl,@cmd
04097C 01 05 00 00 0241*  	ld bc,@end-@cmd
040980 5B DF       0242*  	rst.lil $18
040982 C9          0243*  	ret
040983 17 1B 20    0244*  @cmd: db 23,27,0x20
040986 00 00       0245*  @bufferId: dw 0x0000
040988 00          0246*  @end: db 0x00 ; padding
040989             0247*  
040989             0248*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
040989             0249*  ; inputs: a=format; bc=width; de=height
040989             0250*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
040989             0251*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040989             0252*  ; 0 	RGBA8888 (4-bytes per pixel)
040989             0253*  ; 1 	RGBA2222 (1-bytes per pixel)
040989             0254*  ; 2 	Mono/Mask (1-bit per pixel)
040989             0255*  ; 3 	Reserved for internal use by VDP (“native” format)
040989             0256*  vdu_bmp_create:
040989 ED 43 A5 09 0257*      ld (@width),bc
       04          
04098E ED 53 A7 09 0258*      ld (@height),de
       04          
040993 32 A9 09 04 0259*      ld (@fmt),a
040997 21 A2 09 04 0260*  	ld hl,@cmd
04099B 01 08 00 00 0261*  	ld bc,@end-@cmd
04099F 5B DF       0262*  	rst.lil $18
0409A1 C9          0263*  	ret
0409A2 17 1B 21    0264*  @cmd:       db 23,27,0x21
0409A5 00 00       0265*  @width:     dw 0x0000
0409A7 00 00       0266*  @height:    dw 0x0000
0409A9 00          0267*  @fmt:       db 0x00
0409AA             0268*  @end:
0409AA             0269*  
0409AA             0270*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0409AA             0271*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0409AA             0272*  vdu_load_img_rgba2_to_8:
0409AA             0273*  ; backup the target buffer id and image dimensions
0409AA E5          0274*      push hl
0409AB D5          0275*      push de
0409AC C5          0276*      push bc
0409AD             0277*  ; load the rgba2 image to working buffer 65534
0409AD 21 FE FF 00 0278*      ld hl,65534 ; temporary working buffer id
0409B1 CD B4 0A 04 0279*  	call vdu_load_buffer_from_file
0409B5             0280*  ; restore the image dimensions and target buffer id
0409B5 C1          0281*      pop bc
0409B6 D1          0282*      pop de
0409B7 E1          0283*      pop hl
0409B8             0284*  ; fall through to vdu_rgba2_to_8
0409B8             0285*  
0409B8             0286*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0409B8             0287*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0409B8             0288*  ; the "expand bitmap" command is:
0409B8             0289*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0409B8             0290*  ; and then to reverse the byte order to fix endian-ness:
0409B8             0291*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0409B8             0292*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0409B8             0293*  ; VDU 23,27,&20,targetBufferID%;
0409B8             0294*  ; VDU 23,27,&21,width%;height%;0
0409B8             0295*  ; -------------------------------------------------------------------
0409B8             0296*  ; inputs: bc,de image width,height ; hl = targetBufferId
0409B8             0297*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0409B8             0298*  vdu_rgba2_to_8:
0409B8             0299*  ; load the image dimensions and buffer id parameters
0409B8 ED 43 14 0A 0300*      ld (@width),bc
       04          
0409BD ED 53 16 0A 0301*      ld (@height),de
       04          
0409C2 22 F9 09 04 0302*      ld (@bufferId0),hl
0409C6 22 06 0A 04 0303*      ld (@bufferId2),hl
0409CA 22 0F 0A 04 0304*      ld (@bufferId1),hl
0409CE             0305*  ; clean up bytes that got stomped on by the ID loads
0409CE 3E 48       0306*      ld a,0x48
0409D0 32 FB 09 04 0307*      ld (@bufferId0+2),a
0409D4 3E 17       0308*      ld a,23
0409D6 32 11 0A 04 0309*      ld (@bufferId1+2),a
0409DA 3E 18       0310*      ld a,24
0409DC 32 08 0A 04 0311*      ld (@bufferId2+2),a
0409E0 AF          0312*      xor a
0409E1 32 18 0A 04 0313*      ld (@height+2),a
0409E5             0314*  ; send the vdu command strings
0409E5 21 F0 09 04 0315*      ld hl,@beg
0409E9 01 29 00 00 0316*      ld bc,@end-@beg
0409ED 5B DF       0317*      rst.lil $18
0409EF C9          0318*      ret
0409F0             0319*  @beg:
0409F0             0320*  ; Command 14: Consolidate blocks in a buffer
0409F0             0321*  ; VDU 23, 0, &A0, bufferId; 14
0409F0 17 00 A0    0322*      db 23,0,0xA0
0409F3 FE FF       0323*      dw 65534 ; workingBufferId
0409F5 0E          0324*      db 14 ; consolidate blocks
0409F6             0325*  ; the "expand bitmap" command is:
0409F6             0326*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0409F6 17 00 A0    0327*      db 23,0,0xA0
0409F9 00 00       0328*  @bufferId0: dw 0x0000 ; targetBufferId
0409FB 48          0329*      db 0x48 ; given as decimal command 72 in the docs
0409FC 02          0330*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0409FD FE FF       0331*      dw 65534 ; sourceBufferId
0409FF 00 7F BF FF 0332*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040A03             0333*  ; reverse the byte order to fix endian-ness:
040A03             0334*  ; Command 24: Reverse the order of data of blocks within a buffer
040A03             0335*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040A03             0336*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040A03 17 00 A0    0337*      db 23,0,0xA0
040A06 00 00       0338*  @bufferId2:    dw 0x0000 ; targetBufferId
040A08 18          0339*      db 24 ; reverse byte order
040A09 04          0340*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
040A0A 04 00       0341*      dw 4 ; size (4 bytes)
040A0C             0342*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040A0C             0343*  ; VDU 23,27,&20,targetBufferID%;
040A0C 17 1B 20    0344*      db 23,27,0x20 ; select bitmap
040A0F 00 00       0345*  @bufferId1: dw 0x0000 ; targetBufferId
040A11             0346*  ; VDU 23,27,&21,width%;height%;0
040A11 17 1B 21    0347*      db 23,27,0x21 ; create bitmap from buffer
040A14 00 00       0348*  @width: dw 0x0000
040A16 00 00       0349*  @height: dw 0x0000
040A18 00          0350*      db 0x00 ; rgba8888 format
040A19             0351*  @end:
040A19             0352*  
040A19             0353*  ; scratch variables
040A19 00 00 00    0354*  bufferId0: dl 0x000000
040A1C 00 00 00    0355*  bufferId1: dl 0x000000
040A1F             0356*  
040A1F             0357*  ; load a vdu buffer from local memory
040A1F             0358*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040A1F             0359*  vdu_load_buffer:
040A1F ED 43 48 0A 0360*      ld (@length),bc
       04          
040A24 D5          0361*      push de ; save data pointer
040A25             0362*  ; send the vdu command string
040A25 7D          0363*      ld a,l
040A26 32 45 0A 04 0364*      ld (@bufferId),a
040A2A 7C          0365*      ld a,h
040A2B 32 46 0A 04 0366*      ld (@bufferId+1),a
040A2F 21 42 0A 04 0367*      ld hl,@cmd
040A33 01 08 00 00 0368*      ld bc,@end-@cmd
040A37 5B DF       0369*      rst.lil $18
040A39             0370*  ; send the buffer data
040A39 E1          0371*      pop hl ; pointer to data
040A3A ED 4B 48 0A 0372*      ld bc,(@length)
       04          
040A3F 5B DF       0373*      rst.lil $18 ; send it
040A41 C9          0374*      ret
040A42             0375*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A42 17 00 A0    0376*  @cmd:       db 23,0,0xA0
040A45 00 00       0377*  @bufferId:	dw 0x0000
040A47 00          0378*  		    db 0 ; load buffer
040A48 00 00       0379*  @length:	dw 0x0000
040A4A 00          0380*  @end: db 0 ; padding
040A4B             0381*  
040A4B             0382*  ; clear a buffer
040A4B             0383*  ; inputs: hl = bufferId
040A4B             0384*  vdu_clear_buffer:
040A4B 7D          0385*      ld a,l
040A4C 32 63 0A 04 0386*      ld (@bufferId),a
040A50 7C          0387*      ld a,h
040A51 32 64 0A 04 0388*      ld (@bufferId+1),a
040A55 21 60 0A 04 0389*      ld hl,@cmd
040A59 01 06 00 00 0390*      ld bc,@end-@cmd
040A5D 5B DF       0391*      rst.lil $18
040A5F C9          0392*      ret
040A60 17 00 A0    0393*  @cmd:       db 23,0,0xA0
040A63 00 00       0394*  @bufferId:	dw 0x0000
040A65 02          0395*  		    db 2 ; clear buffer
040A66             0396*  @end:
040A66             0397*  
040A66             0398*  vdu_clear_all_buffers:
040A66             0399*  ; clear all buffers
040A66 21 71 0A 04 0400*      ld hl,@beg
040A6A 01 06 00 00 0401*      ld bc,@end-@beg
040A6E 5B DF       0402*      rst.lil $18
040A70 C9          0403*      ret
040A71 17 00 A0    0404*  @beg: db 23,0,$A0
040A74 FF FF       0405*        dw -1 ; clear all buffers
040A76 02          0406*        db 2  ; command 2: clear a buffer
040A77             0407*  @end:
040A77             0408*  
040A77             0409*  ; Command 14: Consolidate blocks in a buffer
040A77             0410*  vdu_consolidate_buffer:
040A77             0411*  ; set parameters for vdu call
040A77 7D          0412*      ld a,l
040A78 32 8F 0A 04 0413*      ld (@bufferId),a
040A7C 7C          0414*      ld a,h
040A7D 32 90 0A 04 0415*      ld (@bufferId+1),a
040A81 21 8C 0A 04 0416*      ld hl,@beg
040A85 01 06 00 00 0417*      ld bc,@end-@beg
040A89 5B DF       0418*      rst.lil $18
040A8B C9          0419*      ret
040A8C             0420*  ; VDU 23, 0, &A0, bufferId; 14
040A8C 17 00 A0    0421*  @beg: db 23,0,0xA0
040A8F 00 00       0422*  @bufferId: dw 0x0000
040A91 0E          0423*             db 14
040A92             0424*  @end:
040A92             0425*  
040A92             0426*  ; load an image file to a buffer and make it a bitmap
040A92             0427*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
040A92             0428*  vdu_load_img:
040A92             0429*  ; back up image type and dimension parameters
040A92 22 19 0A 04 0430*      ld (bufferId0),hl
040A96 F5          0431*      push af
040A97 C5          0432*  	push bc
040A98 D5          0433*  	push de
040A99             0434*  ; load the image
040A99 CD B4 0A 04 0435*  	call vdu_load_buffer_from_file
040A9D             0436*  ; now make it a bitmap
040A9D 2A 19 0A 04 0437*      ld hl,(bufferId0)
040AA1 CD 77 0A 04 0438*      call vdu_consolidate_buffer
040AA5 2A 19 0A 04 0439*      ld hl,(bufferId0)
040AA9 CD 74 09 04 0440*      call vdu_buff_select
040AAD D1          0441*  	pop de ; image height
040AAE C1          0442*  	pop bc ; image width
040AAF F1          0443*  	pop af ; image type
040AB0 C3 89 09 04 0444*  	jp vdu_bmp_create ; will return to caller from there
040AB4             0445*  
040AB4             0446*  ; inputs: hl = bufferId; iy = pointer to filename
040AB4             0447*  vdu_load_buffer_from_file:
040AB4 22 19 0A 04 0448*      ld (bufferId0),hl
040AB8             0449*  
040AB8             0450*  ; clear target buffer
040AB8 CD 4B 0A 04 0451*      call vdu_clear_buffer
040ABC             0452*  
040ABC             0453*  ; open the file in read mode
040ABC             0454*  ; Open a file
040ABC             0455*  ; HLU: Filename
040ABC             0456*  ;   C: Mode
040ABC             0457*  ; Returns:
040ABC             0458*  ;   A: Filehandle, or 0 if couldn't open
040ABC FD E5       0459*  	push iy ; pointer to filename
040ABE E1          0460*  	pop hl
040ABF 0E 01       0461*  	ld c,fa_read
040AC1             0462*      MOSCALL mos_fopen
040AC1 3E 0A       0001*M 			LD	A, function
040AC3 49 CF       0002*M 			RST.LIS	08h
040AC5 32 00 0B 04 0463*      ld (@filehandle),a
040AC9             0464*  
040AC9             0465*  @read_file:
040AC9             0466*  ; Read a block of data from a file
040AC9             0467*  ;   C: Filehandle
040AC9             0468*  ; HLU: Pointer to where to write the data to
040AC9             0469*  ; DEU: Number of bytes to read
040AC9             0470*  ; Returns:
040AC9             0471*  ; DEU: Number of bytes read
040AC9 3A 00 0B 04 0472*      ld a,(@filehandle)
040ACD 4F          0473*      ld c,a
040ACE 21 00 E0 B7 0474*      ld hl,filedata
040AD2 11 00 20 00 0475*      ld de,8192 ; max we can read into onboard sram at one time
040AD6             0476*      MOSCALL mos_fread
040AD6 3E 1A       0001*M 			LD	A, function
040AD8 49 CF       0002*M 			RST.LIS	08h
040ADA             0477*  
040ADA             0478*  ; ; DEBUG: print chunk size
040ADA             0479*  ;     push de
040ADA             0480*  ;     pop hl
040ADA             0481*  ;     call printDec
040ADA             0482*  ;     call printNewLine
040ADA             0483*  
040ADA             0484*  ; test de for zero bytes read
040ADA 21 00 00 00 0485*      ld hl,0
040ADE AF          0486*      xor a ; clear carry
040ADF ED 52       0487*      sbc hl,de
040AE1 CA F7 0A 04 0488*      jp z,@close_file
040AE5             0489*  
040AE5             0490*  ; load a vdu buffer from local memory
040AE5             0491*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040AE5 2A 19 0A 04 0492*      ld hl,(bufferId0)
040AE9 D5          0493*      push de ; chunksize
040AEA C1          0494*      pop bc
040AEB 11 00 E0 B7 0495*      ld de,filedata
040AEF CD 1F 0A 04 0496*      call vdu_load_buffer
040AF3             0497*  
040AF3             0498*  ; ; print progress breadcrumbs
040AF3             0499*  ;     ld a,'.'
040AF3             0500*  ;     rst.lil 10h
040AF3             0501*  
040AF3             0502*  ; read the next block
040AF3 C3 C9 0A 04 0503*      jp @read_file
040AF7             0504*  
040AF7             0505*  ; close the file
040AF7             0506*  @close_file:
040AF7 3A 00 0B 04 0507*      ld a,(@filehandle)
040AFB             0508*      MOSCALL mos_fclose
040AFB 3E 0B       0001*M 			LD	A, function
040AFD 49 CF       0002*M 			RST.LIS	08h
040AFF C9          0509*      ret ; vdu_load_buffer_from_file
040B00             0510*  
040B00 00          0511*  @filehandle: db 0 ; file handle
040B01 00 00 00    0512*  @fil: dl 0 ; pointer to FIL struct
040B04             0513*  
040B04 00 00 00    0514*  @chunkpointer: dl 0 ; pointer to current chunk
040B07             0515*  
040B07             0516*  ; File information structure (FILINFO)
040B07             0517*  @filinfo:
040B07 00 00 00 00 0518*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
040B0B 00 00       0519*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
040B0D 00 00       0520*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040B0F 00          0521*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040B10 00 00 00 00 0522*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
040B1D 00 00 00 00 0523*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C1D             0039   	include "vdu_plot.inc"
040C1D             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040C1D             0002*  ; PLOT code 	(Decimal) 	Effect
040C1D             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
040C1D             0004*  plot_sl_both: equ 0x00
040C1D             0005*  
040C1D             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
040C1D             0007*  plot_sl_first: equ 0x08
040C1D             0008*  
040C1D             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
040C1D             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
040C1D             0011*  
040C1D             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
040C1D             0013*  plot_sl_last: equ 0x20
040C1D             0014*  
040C1D             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
040C1D             0016*  plot_sl_none: equ 0x28
040C1D             0017*  
040C1D             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
040C1D             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
040C1D             0020*  
040C1D             0021*  ; &40-&47 	64-71 	Point plot
040C1D             0022*  plot_pt: equ 0x40
040C1D             0023*  
040C1D             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
040C1D             0025*  plot_lf_lr_non_bg: equ 0x48
040C1D             0026*  
040C1D             0027*  ; &50-&57 	80-87 	Triangle fill
040C1D             0028*  plot_tf: equ 0x50
040C1D             0029*  
040C1D             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
040C1D             0031*  plot_lf_r_bg: equ 0x58
040C1D             0032*  
040C1D             0033*  ; &60-&67 	96-103 	Rectangle fill
040C1D             0034*  plot_rf: equ 0x60
040C1D             0035*  
040C1D             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
040C1D             0037*  plot_lf_lr_fg: equ 0x60
040C1D             0038*  
040C1D             0039*  ; &70-&77 	112-119 	Parallelogram fill
040C1D             0040*  plot_pf: equ 0x70
040C1D             0041*  
040C1D             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
040C1D             0043*  plot_lf_r_non_fg: equ 0x78
040C1D             0044*  
040C1D             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
040C1D             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
040C1D             0047*  
040C1D             0048*  ; &90-&97 	144-151 	Circle outline
040C1D             0049*  plot_co: equ 0x90
040C1D             0050*  
040C1D             0051*  ; &98-&9F 	152-159 	Circle fill
040C1D             0052*  plot_cf: equ 0x98
040C1D             0053*  
040C1D             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
040C1D             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
040C1D             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
040C1D             0057*  
040C1D             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
040C1D             0059*  plot_rcm: equ 0xB8
040C1D             0060*  
040C1D             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
040C1D             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
040C1D             0063*  ; &D0-&D7 	208-215 	Not defined
040C1D             0064*  ; &D8-&DF 	216-223 	Not defined
040C1D             0065*  ; &E0-&E7 	224-231 	Not defined
040C1D             0066*  
040C1D             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
040C1D             0068*  plot_bmp: equ 0xE8
040C1D             0069*  
040C1D             0070*  ; &F0-&F7 	240-247 	Not defined
040C1D             0071*  ; &F8-&FF 	248-255 	Not defined
040C1D             0072*  
040C1D             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
040C1D             0074*  ; Agon Console8 VDP 2.2.0
040C1D             0075*  
040C1D             0076*  ; Within each group of eight plot codes, the effects are as follows:
040C1D             0077*  ; Plot code 	Effect
040C1D             0078*  ; 0 	Move relative
040C1D             0079*  mv_rel: equ 0
040C1D             0080*  
040C1D             0081*  ; 1 	Plot relative in current foreground colour
040C1D             0082*  dr_rel_fg: equ 1
040C1D             0083*  
040C1D             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
040C1D             0085*  ; 3 	Plot relative in current background colour
040C1D             0086*  dr_rel_bg: equ 3
040C1D             0087*  
040C1D             0088*  ; 4 	Move absolute
040C1D             0089*  mv_abs: equ 4
040C1D             0090*  
040C1D             0091*  ; 5 	Plot absolute in current foreground colour
040C1D             0092*  dr_abs_fg: equ 5
040C1D             0093*  
040C1D             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
040C1D             0095*  ; 7 	Plot absolute in current background colour
040C1D             0096*  dr_abs_bg: equ 7
040C1D             0097*  
040C1D             0098*  ; Codes 0-3 use the position data provided as part of the command
040C1D             0099*  ; as a relative position, adding the position given to the current
040C1D             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
040C1D             0101*  ; as part of the command as an absolute position, setting the current
040C1D             0102*  ; graphical cursor position to the position given.
040C1D             0103*  
040C1D             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
040C1D             0105*  ; current pixel colour. These operations cannot currently be supported
040C1D             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
040C1D             0107*  ; supported. Support for these codes may be added in a future version
040C1D             0108*  ; of the VDP firmware.
040C1D             0109*  
040C1D             0110*  ; 16 colour palette constants
040C1D             0111*  c_black: equ 0
040C1D             0112*  c_red_dk: equ 1
040C1D             0113*  c_green_dk: equ 2
040C1D             0114*  c_yellow_dk: equ 3
040C1D             0115*  c_blue_dk: equ 4
040C1D             0116*  c_magenta_dk: equ 5
040C1D             0117*  c_cyan_dk: equ 6
040C1D             0118*  c_grey: equ 7
040C1D             0119*  c_grey_dk: equ 8
040C1D             0120*  c_red: equ 9
040C1D             0121*  c_green: equ 10
040C1D             0122*  c_yellow: equ 11
040C1D             0123*  c_blue: equ 12
040C1D             0124*  c_magenta: equ 13
040C1D             0125*  c_cyan: equ 14
040C1D             0126*  c_white: equ 15
040C1D             0127*  
040C1D             0128*  ; VDU 25, mode, x; y;: PLOT command
040C1D             0129*  ; inputs: a=mode, bc=x0, de=y0
040C1D             0130*  vdu_plot:
040C1D 32 37 0C 04 0131*      ld (@mode),a
040C21 ED 43 38 0C 0132*      ld (@x0),bc
       04          
040C26 ED 53 3A 0C 0133*      ld (@y0),de
       04          
040C2B 21 36 0C 04 0134*  	ld hl,@cmd
040C2F 01 06 00 00 0135*  	ld bc,@end-@cmd
040C33 5B DF       0136*  	rst.lil $18
040C35 C9          0137*  	ret
040C36 19          0138*  @cmd:   db 25
040C37 00          0139*  @mode:  db 0
040C38 00 00       0140*  @x0: 	dw 0
040C3A 00 00       0141*  @y0: 	dw 0
040C3C 00          0142*  @end:   db 0 ; extra byte to soak up deu
040C3D             0143*  
040C3D             0144*  ; VDU 25, mode, x; y;: PLOT command
040C3D             0145*  ; USING 16.8 FIXED POINT COORDINATES
040C3D             0146*  ; inputs: a=mode, ub.c=x0, ud.e=y0
040C3D             0147*  vdu_plot_168:
040C3D ED 53 59 0C 0148*      ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       04          
040C42 ED 43 57 0C 0149*      ld (@x0-1),bc ; integer portion only
       04          
040C47 32 57 0C 04 0150*      ld (@mode),a  ; load this order b/c we shifted bc right
040C4B 21 56 0C 04 0151*  	ld hl,@cmd
040C4F 01 06 00 00 0152*  	ld bc,@end-@cmd
040C53 5B DF       0153*  	rst.lil $18
040C55             0154*      ; ld hl,@cmd
040C55             0155*      ; ld a,6
040C55             0156*      ; call dumpMemoryHex
040C55             0157*      ; call printNewLine
040C55 C9          0158*  	ret
040C56 19          0159*  @cmd:   db 25
040C57 00          0160*  @mode:  db 0
040C58 00 00       0161*  @x0: 	dw 0
040C5A 00 00       0162*  @y0: 	dw 0
040C5C             0163*  @end:  ; no padding required b/c we shifted de right
040C5C             0164*  
040C5C             0165*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040C5C             0166*  ; &E8-&EF 	232-239 	Bitmap plot §
040C5C             0167*  ; VDU 25, mode, x; y;: PLOT command
040C5C             0168*  ; inputs: bc=x0, de=y0
040C5C             0169*  ; prerequisites: vdu_buff_select
040C5C             0170*  vdu_plot_bmp:
040C5C ED 43 73 0C 0171*      ld (@x0),bc
       04          
040C61 ED 53 75 0C 0172*      ld (@y0),de
       04          
040C66 21 71 0C 04 0173*  	ld hl,@cmd
040C6A 01 06 00 00 0174*  	ld bc,@end-@cmd
040C6E 5B DF       0175*  	rst.lil $18
040C70 C9          0176*  	ret
040C71 19          0177*  @cmd:   db 25
040C72 ED          0178*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040C73 00 00       0179*  @x0: 	dw 0x0000
040C75 00 00       0180*  @y0: 	dw 0x0000
040C77 00          0181*  @end:   db 0x00 ; padding
040C78             0182*  
040C78             0183*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040C78             0184*  ; &E8-&EF 	232-239 	Bitmap plot §
040C78             0185*  ; VDU 25, mode, x; y;: PLOT command
040C78             0186*  ; inputs: bc=x0, de=y0
040C78             0187*  ; USING 16.8 FIXED POINT COORDINATES
040C78             0188*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040C78             0189*  ;   the fractional portiion of the inputs are truncated
040C78             0190*  ;   leaving only the 16-bit integer portion
040C78             0191*  ; prerequisites: vdu_buff_select
040C78             0192*  vdu_plot_bmp168:
040C78             0193*  ; populate in the reverse of normal to keep the
040C78             0194*  ; inputs from stomping on each other
040C78 ED 53 96 0C 0195*      ld (@y0-1),de
       04          
040C7D ED 43 94 0C 0196*      ld (@x0-1),bc
       04          
040C82 3E ED       0197*      ld a,plot_bmp+dr_abs_fg ; 0xED
040C84 32 94 0C 04 0198*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040C88 21 93 0C 04 0199*  	ld hl,@cmd
040C8C 01 06 00 00 0200*  	ld bc,@end-@cmd
040C90 5B DF       0201*  	rst.lil $18
040C92 C9          0202*  	ret
040C93 19          0203*  @cmd:   db 25
040C94 ED          0204*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040C95 00 00       0205*  @x0: 	dw 0x0000
040C97 00 00       0206*  @y0: 	dw 0x0000
040C99             0207*  @end:  ; no padding required b/c we shifted de right
040C99             0208*  
040C99             0209*  ; draw a filled rectangle
040C99             0210*  vdu_plot_rf:
040C99 ED 43 C0 0C 0211*      ld (@x0),bc
       04          
040C9E ED 53 C2 0C 0212*      ld (@y0),de
       04          
040CA3 DD 22 C6 0C 0213*      ld (@x1),ix
       04          
040CA8 FD 22 C8 0C 0214*      ld (@y1),iy
       04          
040CAD 3E 19       0215*      ld a,25 ; we have to reload the 2nd plot command
040CAF 32 C4 0C 04 0216*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040CB3 21 BE 0C 04 0217*  	ld hl,@cmd0
040CB7 01 0C 00 00 0218*  	ld bc,@end-@cmd0
040CBB 5B DF       0219*  	rst.lil $18
040CBD C9          0220*      ret
040CBE 19          0221*  @cmd0:  db 25 ; plot
040CBF 04          0222*  @arg0:  db plot_sl_both+mv_abs
040CC0 00 00       0223*  @x0:    dw 0x0000
040CC2 00 00       0224*  @y0:    dw 0x0000
040CC4 19          0225*  @cmd1:  db 25 ; plot
040CC5 65          0226*  @arg1:  db plot_rf+dr_abs_fg
040CC6 00 00       0227*  @x1:    dw 0x0000
040CC8 00 00       0228*  @y1:    dw 0x0000
040CCA 00          0229*  @end:   db 0x00 ; padding
040CCB             0230*  
040CCB             0231*  ; draw a filled circle
040CCB             0232*  vdu_plot_cf:
040CCB ED 43 F2 0C 0233*      ld (@x0),bc
       04          
040CD0 ED 53 F4 0C 0234*      ld (@y0),de
       04          
040CD5 DD 22 F8 0C 0235*      ld (@x1),ix
       04          
040CDA FD 22 FA 0C 0236*      ld (@y1),iy
       04          
040CDF 3E 19       0237*      ld a,25 ; we have to reload the 2nd plot command
040CE1 32 F6 0C 04 0238*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040CE5 21 F0 0C 04 0239*  	ld hl,@cmd0
040CE9 01 0C 00 00 0240*  	ld bc,@end-@cmd0
040CED 5B DF       0241*  	rst.lil $18
040CEF C9          0242*      ret
040CF0 19          0243*  @cmd0:  db 25 ; plot
040CF1 04          0244*  @arg0:  db plot_sl_both+mv_abs
040CF2 00 00       0245*  @x0:    dw 0x0000
040CF4 00 00       0246*  @y0:    dw 0x0000
040CF6 19          0247*  @cmd1:  db 25 ; plot
040CF7 9D          0248*  @arg1:  db plot_cf+dr_abs_fg
040CF8 00 00       0249*  @x1:    dw 0x0000
040CFA 00 00       0250*  @y1:    dw 0x0000
040CFC 00          0251*  @end:   db 0x00 ; padding
040CFD             0252*  
040CFD             0253*  ; VDU 25, mode, x; y;: PLOT command
040CFD             0254*  ; inputs: a=mode, ix=x0, iy=y0
040CFD             0255*  plot:
040CFD 32 17 0D 04 0256*      ld (@mode),a
040D01 DD 22 18 0D 0257*      ld (@x0),ix
       04          
040D06 FD 22 1A 0D 0258*      ld (@y0),iy
       04          
040D0B 21 16 0D 04 0259*  	ld hl,@cmd
040D0F 01 06 00 00 0260*  	ld bc,@end-@cmd
040D13 5B DF       0261*  	rst.lil $18
040D15 C9          0262*  	ret
040D16 19          0263*  @cmd:   db 25
040D17 00          0264*  @mode:  db 0
040D18 00 00       0265*  @x0: 	dw 0
040D1A 00 00       0266*  @y0: 	dw 0
040D1C 00          0267*  @end:   db 0 ; padding
040D1D             0268*  
040D1D             0269*  ; VDU 5: Write text at graphics cursor
040D1D             0270*  ; inputs: hl = pointer to text, ix=x0, iy=y0
040D1D             0271*  ; prerequisites: gcol foreground set, VDU 5 set
040D1D             0272*  plot_text:
040D1D E5          0273*      push hl ; save text pointer
040D1E             0274*  ; move graphics cursor to x0, y0
040D1E 3E 44       0275*      ld a,plot_pt+mv_abs
040D20 CD FD 0C 04 0276*      call plot
040D24             0277*  ; write text
040D24 E1          0278*      pop hl ; restore text pointer
040D25 CD 77 00 04 0279*      call printString
040D29 C9          0280*      ret
040D2A             0040       include "vdu_sound.inc"
040D2A 00          0001*  last_channel: db 0
040D2B             0002*  max_channels: equ 6
040D2B             0003*  
040D2B             0004*  vdu_play_sfx:
040D2B C9          0005*  vdu_play_sfx_disable: ret ; disabled by default, set to nop to enable
040D2C 22 64 0D 04 0006*      ld (@bufferId),hl
040D30 ED 43 6E 0D 0007*      ld (@duration),bc
       04          
040D35 3E 17       0008*      ld a,23
040D37 32 66 0D 04 0009*      ld (@bufferId+2),a
040D3B 3A 2A 0D 04 0010*      ld a,(last_channel)
040D3F 3C          0011*      inc a
040D40             0012*      ; and 31 ; modulo 32
040D40 FE 06       0013*      cp max_channels
040D42 C2 47 0D 04 0014*      jp nz,@load_channel
040D46 AF          0015*      xor a
040D47             0016*  @load_channel:
040D47 32 2A 0D 04 0017*      ld (last_channel),a
040D4B 32 61 0D 04 0018*      ld (@channel0),a
040D4F 32 69 0D 04 0019*      ld (@channel1),a
040D53 21 5E 0D 04 0020*      ld hl, @sample
040D57 01 12 00 00 0021*      ld bc, @sample_end - @sample
040D5B 5B DF       0022*      rst.lil $18
040D5D C9          0023*      ret
040D5E             0024*  @sample:
040D5E             0025*  ; Command 4: Set waveform
040D5E             0026*  ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
040D5E 17 00 85    0027*      .db 23,0,$85                        ; do sound
040D61             0028*  @channel0:
040D61 00 04 08    0029*      .db 0,4,8 ; channel, command, waveform
040D64             0030*  @bufferId:
040D64 00 00       0031*      .dw 0x0000
040D66             0032*  ; Command 0: Play note
040D66             0033*  ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
040D66 17 00 85    0034*      .db 23,0,$85                        ; do sound
040D69             0035*  @channel1:
040D69 00 00 7F    0036*      .db 0,0,127                ; channel, volume
040D6C 00 00       0037*      .dw 0
040D6E             0038*  @duration:                              ; freq (tuneable samples only)
040D6E 00 00       0039*      .dw 0x0000                        ; duration
040D70             0040*  @sample_end:
040D70 00          0041*      .db 0x00 ; padding
040D71             0042*  
040D71             0043*  ; enable enough additional channels so that total enabled = max_channels
040D71             0044*  ; inputs: max_channels set
040D71             0045*  ; returns: nothing
040D71             0046*  ; destroys: af, bc, hl
040D71             0047*  vdu_enable_channels:
040D71 3E 06       0048*      ld a,max_channels
040D73 D6 03       0049*      sub 3 ; subtract number of default channels already enabled
040D75 F2 7C 0D 04 0050*      jp p,@loop
040D79 C9          0051*      ret
040D7A 3E 03       0052*      ld a,3 ; first non-default channel
040D7C             0053*  @loop:
040D7C 32 97 0D 04 0054*      ld (@channel),a
040D80 21 94 0D 04 0055*      ld hl,@beg
040D84 01 05 00 00 0056*      ld bc,@end-@beg
040D88 F5          0057*      push af
040D89 5B DF       0058*      rst.lil $18
040D8B F1          0059*      pop af
040D8C 3C          0060*      inc a
040D8D FE 06       0061*      cp max_channels
040D8F C2 7C 0D 04 0062*      jp nz,@loop
040D93 C9          0063*      ret
040D94             0064*  @beg:
040D94 17 00 85    0065*              db 23, 0, $85
040D97 00          0066*  @channel:   db 0
040D98 08          0067*              db 8 ; command 8: enable channel
040D99             0068*  @end:
040D99             0069*  
040D99             0070*  ; disable all but the three default sound channels
040D99             0071*  ; inputs: max_channels set
040D99             0072*  ; outputs: none
040D99             0073*  ; destroys: ah,hl,bc
040D99             0074*  vdu_disable_channels:
040D99 3E 06       0075*      ld a,max_channels
040D9B D6 03       0076*      sub 3 ; subtract number of default channels already enabled
040D9D F2 A4 0D 04 0077*      jp p,@loop
040DA1 C9          0078*      ret
040DA2 3E 03       0079*      ld a,3 ; first non-default channel
040DA4             0080*  @loop:
040DA4 32 BF 0D 04 0081*      ld (@channel),a
040DA8 21 BC 0D 04 0082*      ld hl,@beg
040DAC 01 05 00 00 0083*      ld bc,@end-@beg
040DB0 F5          0084*      push af
040DB1 5B DF       0085*      rst.lil $18
040DB3 F1          0086*      pop af
040DB4 3C          0087*      inc a
040DB5 FE 06       0088*      cp max_channels
040DB7 C2 A4 0D 04 0089*      jp nz,@loop
040DBB C9          0090*      ret
040DBC             0091*  @beg:
040DBC 17 00 85    0092*      db 23, 0, $85
040DBF 00          0093*  @channel: db 0
040DC0 09          0094*      db 9 ; command 9: disable channel
040DC1             0095*  @end:
040DC1             0096*  
040DC1             0097*  
040DC1             0098*  ; ############################################################
040DC1             0099*  ; VDU SOUND API
040DC1             0100*  ; ############################################################
040DC1             0101*  ; Command 0: Play note
040DC1             0102*  ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
040DC1             0103*      MACRO PLAY_NOTE channel, volume, frequency, duration
040DC1             0104*      ld hl, @PLAY_NOTE_CMD        ; Start of command block
040DC1             0105*      ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
040DC1             0106*      rst.lil $18
040DC1             0107*      jr @PLAY_NOTE_END
040DC1             0108*  @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
040DC1             0109*                   db channel                  ; Channel, 0 (commented out)
040DC1             0110*                   db 0                        ; Play note command
040DC1             0111*                   db volume                   ; Volume
040DC1             0112*                   dw frequency                ; Frequency
040DC1             0113*                   dw duration                 ; Duration
040DC1             0114*  @PLAY_NOTE_END:
040DC1             0115*      ENDMACRO
040DC1             0116*  
040DC1             0117*      MACRO MUTE_CHANNEL channel
040DC1             0118*      ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
040DC1             0119*      ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
040DC1             0120*      rst.lil $18
040DC1             0121*      jr @MUTE_CHANNEL_END
040DC1             0122*  @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
040DC1             0123*                     db channel                ; Channel, 0 (commented out)
040DC1             0124*                     db 2                      ; Set volume command
040DC1             0125*                     db 0                      ; Volume (mute)
040DC1             0126*  @MUTE_CHANNEL_END:
040DC1             0127*      ENDMACRO
040DC1             0128*  
040DC1             0129*  ; inputs: c = channel, b = volume, hl = frequency; de = duration;
040DC1             0130*  vdu_play_note:
040DC1 79          0131*      ld a,c
040DC2 32 E2 0D 04 0132*      ld (@channel),a
040DC6 78          0133*      ld a,b
040DC7 32 E4 0D 04 0134*      ld (@volume),a
040DCB 22 E5 0D 04 0135*      ld (@frequency),hl
040DCF ED 53 E7 0D 0136*      ld (@duration),de
       04          
040DD4 21 DF 0D 04 0137*      ld hl,@cmd
040DD8 01 0A 00 00 0138*      ld bc,@end-@cmd
040DDC 5B DF       0139*      rst.lil $18
040DDE C9          0140*      ret
040DDF 17 00 85    0141*  @cmd:       db 23, 0, 0x85
040DE2 00          0142*  @channel:   db 0x00
040DE3 00          0143*              db 0x00 ; play note command
040DE4 00          0144*  @volume:    db 0x00
040DE5 00 00       0145*  @frequency: dw 0x0000
040DE7 00 00       0146*  @duration:  dw 0x0000
040DE9 00          0147*  @end:       db 0x00 ; padding
040DEA             0148*  
040DEA             0149*  ; Command 1: Status
040DEA             0150*  ; VDU 23, 0, &85, channel, 1
040DEA             0151*  ; inputs: a = channel
040DEA             0152*  ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
040DEA             0153*  ; Bit 	Name 	Meaning
040DEA             0154*  ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
040DEA             0155*  ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
040DEA             0156*  ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
040DEA             0157*  ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
040DEA             0158*  ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
040DEA             0159*  
040DEA             0160*  ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
040DEA             0161*  vdu_channel_status:
040DEA 32 FC 0D 04 0162*      ld (@channel),a
040DEE 21 F9 0D 04 0163*      ld hl,@cmd
040DF2 01 05 00 00 0164*      ld bc,@end-@cmd
040DF6 5B DF       0165*      rst.lil $18
040DF8 C9          0166*      ret
040DF9 17 00 85    0167*  @cmd:       db 23, 0, 0x85
040DFC 00          0168*  @channel:   db 0x00
040DFD 01          0169*              db 0x01 ; get channel status command
040DFE             0170*  @end:
040DFE             0171*  
040DFE             0172*  ; VDU 23, 0, &85, channel, 2, volume
040DFE             0173*  ; inputs: c = channel, b = volume
040DFE             0174*  ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
040DFE             0175*  
040DFE             0176*  ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
040DFE             0177*  
040DFE             0178*  ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
040DFE             0179*  vdu_channel_volume:
040DFE 79          0180*      ld a,c
040DFF 32 16 0E 04 0181*      ld (@channel),a
040E03 78          0182*      ld a,b
040E04 32 18 0E 04 0183*      ld (@volume),a
040E08 21 13 0E 04 0184*      ld hl,@cmd
040E0C 01 06 00 00 0185*      ld bc,@end-@cmd
040E10 5B DF       0186*      rst.lil $18
040E12 C9          0187*      ret
040E13 17 00 85    0188*  @cmd:       db 23, 0, 0x85
040E16 00          0189*  @channel:   db 0x00
040E17 02          0190*              db 0x02 ; set volume command
040E18 00          0191*  @volume:    db 0x00
040E19             0192*  @end:
040E19             0193*  
040E19             0194*  ; VDU 23, 0, &85, channel, 3, frequency;
040E19             0195*  
040E19             0196*  ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
040E19             0197*  
040E19             0198*  ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
040E19             0199*  
040E19             0200*  ; Returns 1 on success, 0 for failure.
040E19             0201*  vdu_channel_frequency:
040E19 79          0202*      ld a,c
040E1A 32 31 0E 04 0203*      ld (@channel),a
040E1E ED 53 33 0E 0204*      ld (@frequency),de
       04          
040E23 21 2E 0E 04 0205*      ld hl,@cmd
040E27 01 07 00 00 0206*      ld bc,@end-@cmd
040E2B 5B DF       0207*      rst.lil $18
040E2D C9          0208*      ret
040E2E 17 00 85    0209*  @cmd:       db 23, 0, 0x85
040E31 00          0210*  @channel:   db 0x00
040E32 03          0211*              db 0x03 ; set frequency command
040E33 00 00       0212*  @frequency: dw 0x0000
040E35 00          0213*  @end:       db 0x00 ; padding
040E36             0214*  
040E36             0215*  
040E36             0216*  ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
040E36             0217*  ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
040E36             0218*  ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
040E36             0219*  
040E36             0220*  ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
040E36             0221*  
040E36             0222*  ; By default a channel is set to use waveform 0 (square wave).
040E36             0223*  
040E36             0224*  ; Valid waveform values are as follows:
040E36             0225*  ; Value 	Waveform
040E36             0226*  ; 0 	Square wave
040E36             0227*  ; 1 	Triangle wave
040E36             0228*  ; 2 	Sawtooth wave
040E36             0229*  ; 3 	Sine wave
040E36             0230*  ; 4 	Noise (simple white noise with no frequency support)
040E36             0231*  ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
040E36             0232*  ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
040E36             0233*  
040E36             0234*  vdu_channel_waveform:
040E36 79          0235*      ld a,c
040E37 32 5C 0E 04 0236*      ld (@channel),a
040E3B 78          0237*      ld a,b
040E3C 32 5E 0E 04 0238*      ld (@waveform),a
040E40 FE 08       0239*      cp 8 ; check if the waveform is a sample
040E42 28 06       0240*      jr z, @sample
040E44 01 06 00 00 0241*      ld bc,@bufferId-@cmd
040E48 18 08       0242*      jr @sendToVdu
040E4A             0243*  @sample:
040E4A 22 5F 0E 04 0244*      ld (@bufferId),hl
040E4E 01 08 00 00 0245*      ld bc,@end-@cmd
040E52             0246*  @sendToVdu:
040E52 21 59 0E 04 0247*      ld hl,@cmd
040E56 5B DF       0248*      rst.lil $18
040E58 C9          0249*      ret
040E59 17 00 85    0250*  @cmd:       db 23, 0, 0x85
040E5C 00          0251*  @channel:   db 0x00
040E5D 04          0252*              db 0x04 ; set waveform command
040E5E 00          0253*  @waveform:  db 0x00
040E5F 00 00       0254*  @bufferId:  dw 0x0000
040E61 00          0255*  @end:       db 0x00 ; padding
040E62             0256*  
040E62             0257*  
040E62             0258*  
040E62             0259*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
040E62             0260*  ; inputs: hl = bufferId; a = format
040E62             0261*  ; The format parameter is an 8-bit value that indicates the format of the sample data. The following values are supported:
040E62             0262*  ; Value 	Description
040E62             0263*  ; 0 	8-bit signed, 16KHz
040E62             0264*  ; 1 	8-bit unsigned, 16KHz
040E62             0265*  vdu_buffer_to_sound:
040E62 22 7B 0E 04 0266*      ld (@bufferId),hl
040E66 32 7D 0E 04 0267*      ld (@format),a
040E6A 21 75 0E 04 0268*      ld hl,@cmd
040E6E 01 09 00 00 0269*      ld bc,@end-@cmd
040E72 5B DF       0270*      rst.lil $18
040E74 C9          0271*      ret
040E75 17 00 85    0272*  @cmd:       db 23, 0, 0x85
040E78 00          0273*              db 0x00 ; a magic number that is always 0
040E79 05          0274*              db 0x05 ; buffer to sound command
040E7A 02          0275*              db 0x02 ; a magic number that is always 2
040E7B 00 00       0276*  @bufferId:  dw 0x0000
040E7D 00          0277*  @format:    db 0x00
040E7E             0278*  @end:
040E7E             0279*  
040E7E             0280*  
040E7E             0281*  ; inputs: c = channel, b = volume, de = duration; hl = bufferId
040E7E             0282*  vdu_play_sample:
040E7E             0283*      ; populate input parameters
040E7E 79          0284*      ld a,c
040E7F 32 A9 0E 04 0285*      ld (@channel0),a
040E83 32 B1 0E 04 0286*      ld (@channel1),a
040E87 78          0287*      ld a,b
040E88 32 B3 0E 04 0288*      ld (@volume),a
040E8C ED 53 B4 0E 0289*      ld (@frequency),de
       04          
040E91 22 AC 0E 04 0290*      ld (@bufferId),hl
040E95             0291*      ; clean up byte that got stomped on by bufferId load from hl
040E95 3E 17       0292*      ld a,23
040E97 32 AE 0E 04 0293*      ld (@cmd1),a
040E9B             0294*      ; prep the vdu command string
040E9B 21 A6 0E 04 0295*      ld hl, @cmd0
040E9F 01 12 00 00 0296*      ld bc, @end - @cmd0
040EA3 5B DF       0297*      rst.lil $18
040EA5 C9          0298*      ret
040EA6 17 00 85    0299*  @cmd0:       db 23, 0, 0x85
040EA9 00          0300*  @channel0:   db 0x00
040EAA 04          0301*               db 0x04 ; set waveform command
040EAB 08          0302*  @waveform:   db 0x08 ; sample
040EAC 00 00       0303*  @bufferId:   dw 0x0000
040EAE 17 00 85    0304*  @cmd1:       db 23, 0, 0x85
040EB1 00          0305*  @channel1:   db 0x00
040EB2 00          0306*               db 0x00 ; play note command
040EB3 00          0307*  @volume:     db 0x00
040EB4 00 00       0308*  @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
040EB6 00 00       0309*  @duration:   dw 0x0000 ; milliseconds
040EB8 00          0310*  @end:        db 0x00 ; padding
040EB9             0041   	include "maths.inc"
040EB9             0001*  ;------------------------------------------------------------------------
040EB9             0002*  ; Scratch area for calculations
040EB9             0003*  ;------------------------------------------------------------------------
040EB9 00 00 00    0004*  scratch1:	dw24	0	;bit manipulation buffer 1
040EBC 00 00 00    0005*  scratch2:	dw24	0	;bit manipulation buffer 2
040EBF             0006*  
040EBF             0007*  ; absolute value of hlu
040EBF             0008*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040EBF             0009*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040EBF             0010*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040EBF             0011*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040EBF             0012*  ; destroys: a
040EBF             0013*  hlu_abs:
040EBF 19          0014*      add hl,de
040EC0 B7          0015*      or a
040EC1 ED 52       0016*      sbc hl,de
040EC3 FA C8 0E 04 0017*      jp m,@is_neg
040EC7 C9          0018*      ret         ; hlu is positive or zero so we're done
040EC8             0019*  @is_neg:
040EC8 F5          0020*      push af     ; otherwise, save current flags for return
040EC9 CD CF 0E 04 0021*      call neg_hlu ; negate hlu
040ECD F1          0022*      pop af      ; get back flags
040ECE C9          0023*      ret
040ECF             0024*  
040ECF             0025*  ; flip the sign of hlu
040ECF             0026*  ; inputs: hlu
040ECF             0027*  ; returns: 0-hlu, flags set appropriately for the result:
040ECF             0028*  ;         s1,z0,pv0,n1,c1 if result is negative
040ECF             0029*  ;         s0,z1,pv0,n1,c0 if result is zero
040ECF             0030*  ;         s0,z0,pv0,n1,c1 if result is positive
040ECF             0031*  ; destroys a
040ECF             0032*  neg_hlu:
040ECF D5          0033*      push de     ; save de
040ED0 EB          0034*      ex de,hl    ; put hl into de
040ED1 21 00 00 00 0035*      ld hl,0     ; clear hl
040ED5 AF          0036*      xor a       ; clear carry
040ED6 ED 52       0037*      sbc hl,de   ; 0-hlu = -hlu
040ED8 D1          0038*      pop de      ; get de back
040ED9 C9          0039*      ret         ; easy peasy
040EDA             0040*  
040EDA             0041*  ;------------------------------------------------------------------------
040EDA             0042*  ; divide hlu by 2, inspired by above
040EDA             0043*  ;------------------------------------------------------------------------
040EDA             0044*  hlu_div2:
040EDA 22 B9 0E 04 0045*  	ld		(scratch1),hl
040EDE 21 BB 0E 04 0046*  	ld		hl,scratch1+2
040EE2 CB 1E       0047*  	rr		(hl)
040EE4 2B          0048*  	dec		hl
040EE5 CB 1E       0049*  	rr		(hl)
040EE7 2B          0050*  	dec		hl
040EE8 CB 1E       0051*  	rr		(hl)
040EEA 23          0052*  	inc		hl
040EEB 23          0053*  	inc		hl
040EEC 2A B9 0E 04 0054*      ld hl,(scratch1)
040EF0 C9          0055*      ret
040EF1             0056*  
040EF1             0057*  ; this is my little hack to divide by 16
040EF1             0058*  hlu_div16:
040EF1 AF          0059*      xor a
040EF2 29          0060*      add hl,hl
040EF3 17          0061*      rla
040EF4 29          0062*      add hl,hl
040EF5 17          0063*      rla
040EF6 29          0064*      add hl,hl
040EF7 17          0065*      rla
040EF8 29          0066*      add hl,hl
040EF9 17          0067*      rla
040EFA 22 07 0F 04 0068*      ld (@scratch),hl
040EFE 32 0A 0F 04 0069*      ld (@scratch+3),a
040F02 2A 08 0F 04 0070*      ld hl,(@scratch+1)
040F06 C9          0071*      ret
040F07             0072*  @scratch: ds 4
040F0B             0073*  
040F0B             0074*  ; hlu signed division by 256
040F0B             0075*  ; returns: hlu / 256
040F0B             0076*  ; destroys: af
040F0B             0077*  hlu_sdiv256:
040F0B AF          0078*      xor a ; assume hl is positive
040F0C 22 22 0F 04 0079*      ld (@buffer),hl
040F10             0080*      sign_hlu
040F10 19          0001*M         add hl,de
040F11 B7          0002*M         or a
040F12 ED 52       0003*M         sbc hl,de
040F14 F2 19 0F 04 0081*      jp p,@hl_pos
040F18 3D          0082*      dec a
040F19             0083*  @hl_pos:
040F19 32 25 0F 04 0084*      ld (@buffer+3),a
040F1D 2A 23 0F 04 0085*      ld hl,(@buffer+1)
040F21 C9          0086*      ret
040F22             0087*  @buffer: ds 4
040F26             0088*  
040F26             0089*  ; hlu 1 byte right shift, unsigned
040F26             0090*  ; returns: hlu / 256, fractional portion in a
040F26             0091*  ; destroys: af
040F26             0092*  hlu_udiv256:
040F26 AF          0093*  	xor a
040F27 32 38 0F 04 0094*  	ld (@buffer+3),a
040F2B 7D          0095*  	ld a,l ; save the fractional portion
040F2C 22 35 0F 04 0096*  	ld (@buffer),hl
040F30 2A 36 0F 04 0097*  	ld hl,(@buffer+1)
040F34 C9          0098*  	ret
040F35             0099*  @buffer: ds 4
040F39             0100*  
040F39             0101*      MACRO hlu_mul256
040F39             0102*          add hl,hl ; * 2
040F39             0103*          add hl,hl ; * 4
040F39             0104*          add hl,hl ; * 8
040F39             0105*          add hl,hl ; * 16
040F39             0106*          add hl,hl ; * 32
040F39             0107*          add hl,hl ; * 64
040F39             0108*          add hl,hl ; * 128
040F39             0109*          add hl,hl ; * 256
040F39             0110*      ENDMACRO
040F39             0111*  
040F39             0112*  ; compute the modulo of hlu by deu
040F39             0113*  ; outputs: hlu = hlu % deu
040F39             0114*  ; destroys: f, hl
040F39             0115*  hlu_mod:
040F39 B7          0116*  	or a ; clear carry
040F3A             0117*  @loop:
040F3A ED 52       0118*      sbc hl,de
040F3C DA 44 0F 04 0119*      jp c, @end
040F40 C3 3A 0F 04 0120*      jp @loop
040F44             0121*  @end:
040F44 19          0122*      add hl,de
040F45 C9          0123*  	ret
040F46             0124*  
040F46             0125*  
040F46 00 00 00 00 0126*  add_bcd_arg1: db #00,#00,#00,#00
040F4A 00 00 00 00 0127*  add_bcd_arg2: db #00,#00,#00,#00
040F4E             0128*  
040F4E             0129*  ; set bcd values in a scratch memory address from registers bcde
040F4E             0130*  ; input: hl; scratch address,bcde; 8-place bcd number
040F4E             0131*  ; destroys ; hl
040F4E             0132*  set_bcd:
040F4E 73          0133*      ld (hl),e
040F4F 23          0134*      inc hl
040F50 72          0135*      ld (hl),d
040F51 23          0136*      inc hl
040F52 71          0137*      ld (hl),c
040F53 23          0138*      inc hl
040F54 70          0139*      ld (hl),b
040F55 C9          0140*      ret
040F56             0141*  
040F56             0142*  ; load bcd values from a scratch memory address to bcde
040F56             0143*  ; input: hl; scratch address
040F56             0144*  ; output: bcde; 8-place bcd number
040F56             0145*  ; destroys: hl
040F56             0146*  get_bcd:
040F56 5E          0147*      ld e,(hl)
040F57 23          0148*      inc hl
040F58 56          0149*      ld d,(hl)
040F59 23          0150*      inc hl
040F5A 4E          0151*      ld c,(hl)
040F5B 23          0152*      inc hl
040F5C 46          0153*      ld b,(hl)
040F5D C9          0154*      ret
040F5E             0155*  
040F5E             0156*  ; BCD addition
040F5E             0157*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040F5E             0158*  ;       a is the number of bytes holding each number (number of places/2)
040F5E             0159*  ; outputs: (hl) + (de) --> (hl)
040F5E             0160*  ; destroys: a,b,de,hl
040F5E             0161*  add_bcd:
040F5E 47          0162*      ld b,a ; loop counter
040F5F AF          0163*      xor a ; reset a, clear carry flag
040F60             0164*  adcec:
040F60 1A          0165*      ld a,(de) ; addend to acc
040F61 8E          0166*      adc a,(hl) ; add (hl) to acc
040F62 27          0167*      daa ; adjust result to bcd
040F63 77          0168*      ld (hl),a ; store result
040F64 23          0169*      inc hl ; advance memory pointers
040F65 13          0170*      inc de
040F66 10 F8       0171*      djnz adcec ; loop until b == 0
040F68 C9          0172*      ret
040F69             0173*  
040F69             0174*  ; BCD subtraction
040F69             0175*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040F69             0176*  ;       a is the number of bytes holding each number (number of places/2)
040F69             0177*  ; outputs: (hl) - (de) --> (hl)
040F69             0178*  ; destroys: a,b,de,hl
040F69             0179*  sub_bcd:
040F69 47          0180*      ld b,a ; loop counter
040F6A AF          0181*      xor a ; reset a,clear carry flag
040F6B             0182*  subdec:
040F6B 1A          0183*      ld a,(de) ; subtrahend to acc
040F6C 9E          0184*      sbc a,(hl) ; subtract (hl) from acc
040F6D 27          0185*      daa ; adjust result to bcd
040F6E 77          0186*      ld (hl),a ; store result
040F6F 23          0187*      inc hl ; advance memory pointers
040F70 13          0188*      inc de
040F71 10 F8       0189*      djnz subdec ; loop until b == 0
040F73 C9          0190*      ret
040F74             0191*  
040F74             0192*  ; http://www.z80.info/pseudo-random.txt
040F74             0193*  rand_8:
040F74 C5          0194*      push bc
040F75 3A 88 0F 04 0195*      ld a,(r_seed)
040F79 4F          0196*      ld c,a
040F7A             0197*  
040F7A 0F          0198*      rrca ; multiply by 32
040F7B 0F          0199*      rrca
040F7C 0F          0200*      rrca
040F7D EE 1F       0201*      xor 0x1f
040F7F             0202*  
040F7F 81          0203*      add a,c
040F80 DE FF       0204*      sbc a,255 ; carry
040F82             0205*  
040F82 32 88 0F 04 0206*      ld (r_seed),a
040F86 C1          0207*      pop bc
040F87 C9          0208*      ret
040F88 50          0209*  r_seed: defb $50
040F89             0042   	include "arith24.inc"
040F89             0001*  ;------------------------------------------------------------------------
040F89             0002*  ;  arith24.asm
040F89             0003*  ;  24-bit ez80 arithmetic routines
040F89             0004*  ;  Copyright (c) Shawn Sijnstra 2024
040F89             0005*  ;  MIT license
040F89             0006*  ;
040F89             0007*  ;  This library was created as a tool to help make ez80
040F89             0008*  ;  24-bit native assembly routines for simple mathematical problems
040F89             0009*  ;  more widely available.
040F89             0010*  ;
040F89             0011*  ;------------------------------------------------------------------------
040F89             0012*  
040F89             0013*  ;------------------------------------------------------------------------
040F89             0014*  ; umul24:	HL = HL*DE (unsigned)
040F89             0015*  ; Preserves AF, BC, DE
040F89             0016*  ; Uses a fast multiply routine.
040F89             0017*  ;------------------------------------------------------------------------
040F89             0018*  umul24:
040F89 D5          0019*  	push	DE
040F8A C5          0020*  	push	BC
040F8B F5          0021*  	push	AF
040F8C E5          0022*  	push	HL
040F8D C1          0023*  	pop		BC
040F8E 3E 18       0024*      ld	 	a, 24 ; No. of bits to process
040F90 21 00 00 00 0025*      ld	 	hl, 0 ; Result
040F94             0026*  umul24_lp:
040F94 29          0027*  	add	hl,hl
040F95 EB          0028*  	ex	de,hl
040F96 29          0029*  	add	hl,hl
040F97 EB          0030*  	ex	de,hl
040F98 30 01       0031*  	jr	nc,umul24_nc
040F9A 09          0032*  	add	hl,bc
040F9B             0033*  umul24_nc:
040F9B 3D          0034*  	dec	a
040F9C 20 F6       0035*  	jr	nz,umul24_lp
040F9E F1          0036*  	pop	af
040F9F C1          0037*  	pop	bc
040FA0 D1          0038*  	pop	de
040FA1 C9          0039*  	ret
040FA2             0040*  
040FA2             0041*  
040FA2             0042*  ;------------------------------------------------------------------------
040FA2             0043*  ; udiv24
040FA2             0044*  ; Unsigned 24-bit division
040FA2             0045*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040FA2             0046*  ;
040FA2             0047*  ; Uses AF BC DE HL
040FA2             0048*  ; Uses Restoring Division algorithm
040FA2             0049*  ;------------------------------------------------------------------------
040FA2             0050*  
040FA2             0051*  udiv24:
040FA2 E5          0052*  	push	hl
040FA3 C1          0053*  	pop		bc	;move dividend to BCU
040FA4 21 00 00 00 0054*  	ld		hl,0	;result
040FA8 A7          0055*  	and		a
040FA9 ED 52       0056*  	sbc		hl,de	;test for div by 0
040FAB C8          0057*  	ret		z		;it's zero, carry flag is clear
040FAC 19          0058*  	add		hl,de	;HL is 0 again
040FAD 3E 18       0059*  	ld		a,24	;number of loops through.
040FAF             0060*  udiv1:
040FAF C5          0061*  	push	bc	;complicated way of doing this because of lack of access to top bits
040FB0 E3          0062*  	ex		(sp),hl
040FB1 37          0063*  	scf
040FB2 ED 6A       0064*  	adc	hl,hl
040FB4 E3          0065*  	ex	(sp),hl
040FB5 C1          0066*  	pop	bc		;we now have bc = (bc * 2) + 1
040FB6             0067*  
040FB6 ED 6A       0068*  	adc	hl,hl
040FB8 A7          0069*  	and	a		;is this the bug
040FB9 ED 52       0070*  	sbc	hl,de
040FBB 30 02       0071*  	jr	nc,udiv2
040FBD 19          0072*  	add	hl,de
040FBE             0073*  ;	dec	c
040FBE 0B          0074*  	dec	bc
040FBF             0075*  udiv2:
040FBF 3D          0076*  	dec	a
040FC0 20 ED       0077*  	jr	nz,udiv1
040FC2 37          0078*  	scf		;flag used for div0 error
040FC3 C5          0079*  	push	bc
040FC4 D1          0080*  	pop		de	;remainder
040FC5 C9          0081*  	ret
040FC6             0082*  
040FC6             0083*  
040FC6             0084*  
040FC6             0085*  ;------------------------------------------------------------------------
040FC6             0086*  ; neg24
040FC6             0087*  ; Returns: HLU = 0-HLU
040FC6             0088*  ; preserves all other registers
040FC6             0089*  ;------------------------------------------------------------------------
040FC6             0090*  neg24:
040FC6 D5          0091*  	push	de
040FC7 EB          0092*  	ex		de,hl
040FC8 21 00 00 00 0093*  	ld		hl,0
040FCC B7          0094*  	or		a
040FCD ED 52       0095*  	sbc		hl,de
040FCF D1          0096*  	pop		de
040FD0 C9          0097*  	ret
040FD1             0098*  
040FD1             0099*  ;------------------------------------------------------------------------
040FD1             0100*  ; or_hlu_deu: 24 bit bitwise OR
040FD1             0101*  ; Returns: hlu = hlu OR deu
040FD1             0102*  ; preserves all other registers
040FD1             0103*  ;------------------------------------------------------------------------
040FD1             0104*  or_hlu_deu:
040FD1 22 5C 10 04 0105*  	ld	(bitbuf1),hl
040FD5 ED 53 5F 10 0106*  	ld	(bitbuf2),de
       04          
040FDA D5          0107*  	push	de	;preserve DEU
040FDB C5          0108*  	push	bc	;preserve BCU
040FDC 06 03       0109*  	ld		b,3
040FDE 21 5C 10 04 0110*  	ld	hl,bitbuf1
040FE2 11 5C 10 04 0111*  	ld	de,bitbuf1
040FE6             0112*  orloop_24:
040FE6 1A          0113*  	ld	a,(de)
040FE7 B6          0114*  	or	(hl)
040FE8 12          0115*  	ld	(de),a
040FE9 13          0116*  	inc	de
040FEA 23          0117*  	inc	hl
040FEB 10 F9       0118*  	djnz	orloop_24
040FED 2A 5F 10 04 0119*  	ld	hl,(bitbuf2)
040FF1 C1          0120*  	pop		bc	;restore BC
040FF2 D1          0121*  	pop		de	;restore DE
040FF3             0122*  
040FF3             0123*  ;------------------------------------------------------------------------
040FF3             0124*  ; and_hlu_deu: 24 bit bitwise AND
040FF3             0125*  ; Returns: hlu = hlu AND deu
040FF3             0126*  ; preserves all other registers
040FF3             0127*  ;------------------------------------------------------------------------
040FF3             0128*  and_hlu_deu:
040FF3 22 5C 10 04 0129*  	ld	(bitbuf1),hl
040FF7 ED 53 5F 10 0130*  	ld	(bitbuf2),de
       04          
040FFC D5          0131*  	push	de	;preserve DEU
040FFD C5          0132*  	push	bc	;preserve BCU
040FFE 06 03       0133*  	ld		b,3
041000 21 5C 10 04 0134*  	ld	hl,bitbuf1
041004 11 5C 10 04 0135*  	ld	de,bitbuf1
041008             0136*  andloop_24:
041008 1A          0137*  	ld	a,(de)
041009 A6          0138*  	and	(hl)
04100A 12          0139*  	ld	(de),a
04100B 13          0140*  	inc	de
04100C 23          0141*  	inc	hl
04100D 10 F9       0142*  	djnz	andloop_24
04100F 2A 5F 10 04 0143*  	ld	hl,(bitbuf2)
041013 C1          0144*  	pop		bc	;restore BC
041014 D1          0145*  	pop		de	;restore DE
041015             0146*  
041015             0147*  ;------------------------------------------------------------------------
041015             0148*  ; xor_hlu_deu: 24 bit bitwise XOR
041015             0149*  ; Returns: hlu = hlu XOR deu
041015             0150*  ; preserves all other registers
041015             0151*  ;------------------------------------------------------------------------
041015             0152*  xor_hlu_deu:
041015 22 5C 10 04 0153*  	ld	(bitbuf1),hl
041019 ED 53 5F 10 0154*  	ld	(bitbuf2),de
       04          
04101E D5          0155*  	push	de	;preserve DEU
04101F C5          0156*  	push	bc	;preserve BCU
041020 06 03       0157*  	ld		b,3
041022 21 5C 10 04 0158*  	ld	hl,bitbuf1
041026 11 5C 10 04 0159*  	ld	de,bitbuf1
04102A             0160*  xorloop_24:
04102A 1A          0161*  	ld	a,(de)
04102B AE          0162*  	xor	(hl)
04102C 12          0163*  	ld	(de),a
04102D 13          0164*  	inc	de
04102E 23          0165*  	inc	hl
04102F 10 F9       0166*  	djnz	xorloop_24
041031 2A 5F 10 04 0167*  	ld	hl,(bitbuf2)
041035 C1          0168*  	pop		bc	;restore BC
041036 D1          0169*  	pop		de	;restore DE
041037             0170*  
041037             0171*  ;------------------------------------------------------------------------
041037             0172*  ; shl_hlu: 24 bit shift left hlu by deu positions
041037             0173*  ; Returns: hlu = hlu << deu
041037             0174*  ;		   de = 0
041037             0175*  ; NOTE: only considers deu up to 16 bits.
041037             0176*  ; preserves all other registers
041037             0177*  ;------------------------------------------------------------------------
041037             0178*  shl_hlu:
041037 7A          0179*  	ld		a,d		;up to 16 bit.
041038 B3          0180*  	or		e
041039 C8          0181*  	ret		z		;we're done
04103A 29          0182*  	add		hl,hl	;shift HLU left
04103B 1B          0183*  	dec		de
04103C 18 F9       0184*  	jr		shl_hlu
04103E             0185*  
04103E             0186*  ;------------------------------------------------------------------------
04103E             0187*  ; shr_hlu: 24 bit shift right hlu by deu positions
04103E             0188*  ; Returns: hlu = hlu >> deu
04103E             0189*  ;		   de = 0
04103E             0190*  ; NOTE: only considers deu up to 16 bits.
04103E             0191*  ; preserves all other registers
04103E             0192*  ;------------------------------------------------------------------------
04103E             0193*  shr_hlu:
04103E 22 5C 10 04 0194*  	ld		(bitbuf1),hl
041042 21 5E 10 04 0195*  	ld		hl,bitbuf1+2
041046             0196*  shr_loop:
041046 7A          0197*  	ld		a,d		;up to 16 bit.
041047 B3          0198*  	or		e
041048 28 0D       0199*  	jr		z,shr_done		;we're done
04104A             0200*  ;carry is clear from or instruction
04104A CB 1E       0201*  	rr		(hl)
04104C 2B          0202*  	dec		hl
04104D CB 1E       0203*  	rr		(hl)
04104F 2B          0204*  	dec		hl
041050 CB 1E       0205*  	rr		(hl)
041052 23          0206*  	inc		hl
041053 23          0207*  	inc		hl
041054 1B          0208*  	dec		de
041055 18 EF       0209*  	jr		shr_loop
041057             0210*  shr_done:
041057 2A 5C 10 04 0211*  	ld		hl,(bitbuf1)	;collect result
04105B C9          0212*  	ret
04105C             0213*  
04105C             0214*  ;------------------------------------------------------------------------
04105C             0215*  ; Scratch area for calculations
04105C             0216*  ;------------------------------------------------------------------------
04105C 00 00 00    0217*  bitbuf1:	dw24	0	;bit manipulation buffer 1
04105F 00 00 00    0218*  bitbuf2:	dw24	0	;bit manipulation buffer 2
041062             0043   	include "fixed24.inc"
041062             0001*  arith24uaf: ds 6
041068             0002*  arith24uhl: ds 6
04106E             0003*  arith24ubc: ds 6
041074             0004*  arith24ude: ds 6
04107A             0005*  arith24uix: ds 6
041080             0006*  arith24uiy: ds 6
041086             0007*  arith24usp: ds 6
04108C             0008*  arith24upc: ds 6
041092             0009*  
041092             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
041092             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
041092             0012*  ; inputs: hlu = 24-bit number to shift
041092             0013*  ;         a = signed number of bits to shift
041092             0014*  ;         ix = output buffer address
041092             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
041092             0016*  shift_hlu:
041092 C5          0017*      push bc ; preserve
041093 47          0018*      ld b,a            ; store shift value in b for later
041094             0019*  
041094             0020*  ; Initialize DE to zero and clear output buffer
041094 11 00 00 00 0021*      ld de, 0
041098 DD 1F FD    0022*      ld (ix-3), de
04109B DD 1F 03    0023*      ld (ix+3), de
04109E             0024*  
04109E             0025*  ; Get absolute value of a and save its original sign
04109E B7          0026*      or a
04109F F5          0027*      push af ; save sign flag
0410A0 F2 A6 10 04 0028*      jp p,@F ; If a is positive do nothing
0410A4 ED 44       0029*      neg ; If a is negative, negate it
0410A6             0030*  @@:
0410A6             0031*  
0410A6             0032*  ; Write abs(HLU) to the output buffer and save its original sign
0410A6 CD BF 0E 04 0033*      call hlu_abs
0410AA F5          0034*      push af ; save sign of HLU
0410AB DD 2F 00    0035*      ld (ix), hl
0410AE             0036*  
0410AE             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
0410AE 78          0038*      ld a,b            ; Restore original shift value into 'a'
0410AF CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
0410B1 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
0410B3 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
0410B5 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
0410B6             0043*  
0410B6             0044*  ; Calculate remainder of a (original shift) mod 8
0410B6 E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0410B8 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
0410B9 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
0410BD             0048*  
0410BD             0049*      ; call dumpRegistersHex ; DEBUG
0410BD             0050*  
0410BD             0051*  ; Get back the original sign of the byte shift
0410BD F1          0052*      pop af            ; Restore sign flag
0410BE F2 CC 10 04 0053*      jp p,@F           ; If a was positive, we're done
0410C2 79          0054*      ld a,c            ; 'a' now holds the number of whole bytes to shift
0410C3 ED 44       0055*      neg               ; Negate the number of whole bytes to shift
0410C5 3D          0056*      dec a             ; Subtract 1 because that's just how this works
0410C6 4F          0057*      ld c,a            ; 'c' now holds the number of whole bytes to shift
0410C7 1B          0058*      dec de            ; DE = -1 to make the signed addition below work
0410C8 3E 08       0059*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0410CA 90          0060*      sub b
0410CB 47          0061*      ld b,a            ; b is the number of bits to shift back up
0410CC             0062*  
0410CC             0063*      ; call dumpRegistersHex ; DEBUG
0410CC             0064*  
0410CC             0065*  @@:
0410CC             0066*  
0410CC             0067*  ; Add the byte offset to the base address of output buffer
0410CC 59          0068*      ld e,c            ; DEU and D were properly signed above
0410CD DD 19       0069*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
0410CF             0070*  
0410CF             0071*      ; call dumpRegistersHex ; DEBUG
0410CF             0072*  
0410CF             0073*  ; Read the byte-aligned result into HL and shift in the required number of bits
0410CF DD 27 00    0074*      ld hl,(ix)        ; Byte-aligned result
0410D2             0075*  
0410D2 CD 26 04 04 0076*      call dumpRegistersHex ; DEBUG
0410D6             0077*  
0410D6             0078*  ; Check whether we're already byte-aligned
0410D6 AF          0079*      xor a
0410D7 B0          0080*      or b
0410D8 28 10       0081*      jr z,@end         ; If no bits to shift, we're done
0410DA             0082*  
0410DA             0083*  ; Otherwise shiften zee bitzen
0410DA DD 7E FF    0084*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
0410DD             0085*  @loop:
0410DD 07          0086*      rlca              ; One bit to carry
0410DE             0087*  
0410DE CD B4 05 04 0088*      call dumpFlags ; DEBUG
0410E2             0089*  
0410E2 ED 6A       0090*      adc hl,hl         ; Shift the carry into the result
0410E4             0091*  
0410E4 CD 26 04 04 0092*      call dumpRegistersHex ; DEBUG
0410E8             0093*  
0410E8 10 F3       0094*      djnz @loop        ; Loop until all bits are shifted up
0410EA             0095*  
0410EA             0096*  @end:
0410EA             0097*  
0410EA CD 26 04 04 0098*      call dumpRegistersHex ; DEBUG
0410EE             0099*  
0410EE             0100*  ; get back HLU's original sign and negate if necessary
0410EE F1          0101*      pop af
0410EF F2 F7 10 04 0102*      jp p,@F
0410F3 CD CF 0E 04 0103*      call neg_hlu
0410F7             0104*  @@:
0410F7             0105*  ; return the result
0410F7 DD 2F 00    0106*      ld (ix),hl        ; Store the shifted result
0410FA C1          0107*      pop bc              ; Restore BC
0410FB C9          0108*      ret
0410FC             0109*  
0410FC             0110*  ; operation: UHL * UDE --> UHL
0410FC             0111*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
0410FC             0112*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0410FC             0113*  ; inputs: hl = 24-bit number, de = 24-bit number,
0410FC             0114*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0410FC             0115*  ; outputs: umulfxout = 48-bit intermediate
0410FC             0116*  ; destroys: af, hl, bc, de
0410FC             0117*  umulfx:
0410FC DD E5       0118*      push ix ; preserve
0410FE F5          0119*      push af ; need later
0410FF             0120*  
0410FF             0121*  ; do the multiplication
0410FF CD C0 11 04 0122*      call umul24x24
041103             0123*      ; DEBUG
041103 21 55 11 04 0124*      ld hl,umulfxout ; point to output buffer
041107 3E 06       0125*      ld a,6 ; 6 bytes to print
041109 CD 1A 06 04 0126*      call dumpMemoryHex ; print the result
04110D             0127*      ; END DEBUG
04110D             0128*  
04110D             0129*  ; shift the result to the required output precision
04110D 78          0130*      ld a,b
04110E 81          0131*      add a,c ; a is left shift from the multiplication
04110F C1          0132*      pop bc ; b is the output precision (was a)
041110 90          0133*      sub b ; a is the net shift of the output
041111             0134*  
041111             0135*  ; Get absolute value of a and save its original sign
041111 B7          0136*      or a
041112 F5          0137*      push af ; save sign flag
041113 F2 19 11 04 0138*      jp p,@F ; If a is positive do nothing
041117 ED 44       0139*      neg ; If a is negative, negate it
041119             0140*  @@:
041119             0141*  
041119             0142*  ; Divide a by 8 to get the whole byte shift and bit remainder
041119 47          0143*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
04111A CB 3F       0144*      srl a             ; a = a / 2 (shift right 1 bit)
04111C CB 3F       0145*      srl a             ; a = a / 4 (shift right another bit)
04111E CB 3F       0146*      srl a             ; a = a / 8 (final shift for division by 8)
041120 4F          0147*      ld c,a            ; c holds the number of whole bytes to shift
041121             0148*  
041121             0149*  ; Calculate remainder of a (original shift) mod 8
041121 78          0150*      ld a,b            ; Restore original shift value into 'a'
041122 E6 07       0151*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
041124 47          0152*      ld b,a            ; 'b' now holds the number of bits to shift back up
041125 11 00 00 00 0153*      ld de,0           ; Clear deu for computing the offset address later
041129             0154*  
041129             0155*      ; call dumpRegistersHex ; DEBUG
041129             0156*  
041129             0157*  ; Get back the original sign of the byte shift
041129 F1          0158*      pop af            ; Restore sign flag
04112A F2 38 11 04 0159*      jp p,@F           ; If a was positive, we're done
04112E 79          0160*      ld a,c            ; 'a' now holds the number of whole bytes to shift
04112F ED 44       0161*      neg               ; Negate the number of whole bytes to shift
041131 3D          0162*      dec a             ; Subtract 1 because that's just how this works
041132 4F          0163*      ld c,a            ; 'c' now holds the number of whole bytes to shift
041133 1B          0164*      dec de            ; DE = -1 to make the signed addition below work
041134 3E 08       0165*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
041136 90          0166*      sub b
041137 47          0167*      ld b,a            ; b is the number of bits to shift back up
041138             0168*  
041138             0169*      ; call dumpRegistersHex ; DEBUG
041138             0170*  
041138             0171*  @@:
041138             0172*  
041138             0173*  ; Add the byte offset to the base address of umulfxout
041138 59          0174*      ld e,c            ; DEU and D were properly signed above
041139 DD 21 55 11 0175*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
04113E DD 19       0176*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
041140             0177*  
041140             0178*      ; call dumpRegistersHex ; DEBUG
041140             0179*  
041140             0180*  ; Read the byte-aligned result into HL and shift in the required number of bits
041140 DD 27 00    0181*      ld hl,(ix)        ; Byte-aligned result
041143 DD 7E FF    0182*      ld a,(ix-1)       ; One byte below
041146             0183*  
041146             0184*  ; Check whether we're already byte-aligned
041146 AF          0185*      xor a
041147 B0          0186*      or b
041148 28 05       0187*      jr z,@end         ; If no bits to shift, we're done
04114A             0188*  
04114A             0189*  ; Otherwise shiften zee bitzen
04114A             0190*  @loop:
04114A             0191*  
04114A             0192*      ; call dumpRegistersHex ; DEBUG
04114A             0193*  
04114A 07          0194*      rlca              ; One bit to carry
04114B ED 6A       0195*      adc hl,hl         ; Shift the carry into the result
04114D             0196*  
04114D 10 FB       0197*      djnz @loop        ; Loop until all bits are shifted up
04114F             0198*  
04114F             0199*  @end:
04114F             0200*  ; return the result
04114F DD E1       0201*      pop ix ; restore
041151 C9          0202*      ret
041152             0203*  
041152 00 00 00    0204*      dl 0 ; padding
041155 00 00 00 00 0205*  umulfxout: blkb 6,0
       00 00       
04115B 00 00 00    0206*      dl 0 ; padding
04115E             0207*  
04115E             0208*  ; operation: UHL * UDE --> UHL
04115E             0209*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
04115E             0210*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
04115E             0211*  ; inputs: hl = 24-bit number, de = 24-bit number,
04115E             0212*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
04115E             0213*  ; outputs: umulfxout = 48-bit intermediate
04115E             0214*  ; destroys: af, hl, bc, de
04115E             0215*  smulfx:
04115E             0216*  ; make everything positive and store sign flags
04115E CD BF 0E 04 0217*  	call hlu_abs
041162 F5          0218*  	push af
041163 EB          0219*  	ex de,hl
041164 CD BF 0E 04 0220*  	call hlu_abs
041168 EB          0221*  	ex de,hl
041169 F5          0222*  	push af
04116A             0223*  ; do the division
04116A CD FC 10 04 0224*      call umulfx ; hl = product
04116E             0225*  ; adjust sign of result
04116E F1          0226*  	pop af ; sign de
04116F FA 7A 11 04 0227*  	jp m,@de_neg
041173 F1          0228*  	pop af ; sign hl
041174 F0          0229*  	ret p ; both positive, nothing to do
041175             0230*  @hl_neg:
041175 CD CF 0E 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
041179 C9          0232*      ret
04117A             0233*  @de_neg:
04117A F1          0234*  	pop af
04117B F8          0235*  	ret m ; both negative, nothing to do
04117C CD CF 0E 04 0236*  	call neg_hlu ; result is negative
041180 C9          0237*  	ret
041181             0238*  
041181             0239*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
041181             0240*  ; uses EZ80 MLT instruction for speed
041181             0241*  ; operation: UHL * A --> UHL
041181             0242*  ; destroys: AF, HL
041181             0243*  smul24x8:
041181             0244*  ; make hl positive and store sign flag
041181 CD BF 0E 04 0245*  	call hlu_abs
041185 F5          0246*  	push af
041186             0247*  ; do the division
041186 CD 91 11 04 0248*      call umul24x8 ; hl = product
04118A             0249*  ; adjust sign of result
04118A F1          0250*  	pop af ; sign de
04118B F0          0251*  	ret p ; hl was positive, nothing to do
04118C CD CF 0E 04 0252*  	call neg_hlu ; result is negative
041190 C9          0253*  	ret
041191             0254*  
041191             0255*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
041191             0256*  ; uses EZ80 MLT instruction for speed
041191             0257*  ; operation: UHL * A --> AUHL
041191             0258*  ; destroys: AF, HL
041191             0259*  umul24x8:
041191 D5          0260*  	push de ; preserve de
041192             0261*  ; low byte
041192 5D          0262*  	ld e,l
041193 57          0263*  	ld d,a
041194 ED 5C       0264*  	mlt de
041196 6B          0265*  	ld l,e ; product low byte
041197 08          0266*  	ex af,af' ; save multiplier
041198 7A          0267*  	ld a,d ; carry
041199 08          0268*  	ex af,af' ; save carry, restore multiplier
04119A             0269*  ; high byte
04119A 5C          0270*  	ld e,h
04119B 57          0271*  	ld d,a
04119C ED 5C       0272*  	mlt de
04119E 08          0273*  	ex af,af' ; save multiplier, restore carry
04119F 83          0274*  	add a,e ; add carry
0411A0 67          0275*  	ld h,a ; product middle byte
0411A1 7A          0276*  	ld a,d ; carry
0411A2 08          0277*  	ex af,af' ; save carry, restore multiplier
0411A3             0278*  ; upper byte
0411A3 E5          0279*  	push hl
0411A4 33          0280*  	inc sp
0411A5 D1          0281*  	pop de ; d = hlu
0411A6 3B          0282*  	dec sp
0411A7 5F          0283*  	ld e,a
0411A8 ED 5C       0284*  	mlt de
0411AA 08          0285*  	ex af,af' ; restore carry
0411AB 8B          0286*  	adc a,e ; add carry
0411AC 22 BD 11 04 0287*      ld (@scratch),hl ; 7 cycles
0411B0 32 BF 11 04 0288*      ld (@scratch+2),a ; 5 cycles
0411B4 2A BD 11 04 0289*      ld hl,(@scratch) ; 7 cycles
0411B8             0290*  ; highest byte
0411B8 3E 00       0291*  	ld a,0 ; preserve carry flag
0411BA 8A          0292*  	adc a,d ; product highest byte
0411BB D1          0293*  	pop de ; restore de
0411BC C9          0294*  	ret
0411BD             0295*  @scratch: ds 3
0411C0             0296*  
0411C0             0297*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0411C0             0298*  ; operation: UHL * UDE --> umulfxout
0411C0             0299*  umul24x24:
0411C0 FD 21 55 11 0300*  	ld iy,umulfxout ; point to output buffer
       04          
0411C5 C5          0301*  	push bc
0411C6 01 00 00 00 0302*  	ld bc,0
0411CA FD 0F 00    0303*  	ld (iy),bc
0411CD FD 0F 03    0304*  	ld (iy+3),bc
0411D0 C1          0305*  	pop bc
0411D1             0306*  
0411D1             0307*  ; STEP 1: UHL * E
0411D1 7B          0308*  	ld a,e
0411D2 E5          0309*  	push hl
0411D3 CD 91 11 04 0310*  	call umul24x8
0411D7 FD 2F 00    0311*  	ld (iy+0),hl
0411DA FD 77 03    0312*  	ld (iy+3),a
0411DD             0313*  
0411DD             0314*  ; STEP 2: UHL * D
0411DD E1          0315*  	pop hl
0411DE E5          0316*  	push hl
0411DF 7A          0317*  	ld a,d
0411E0 CD 91 11 04 0318*  	call umul24x8
0411E4 CD F1 11 04 0319*  	call @accumulate
0411E8             0320*  
0411E8             0321*  ; STEP 3: UHL * DEU
0411E8 E1          0322*  	pop hl
0411E9 D5          0323*  	push de
0411EA 33          0324*  	inc sp
0411EB F1          0325*  	pop af
0411EC 3B          0326*  	dec sp
0411ED CD 91 11 04 0327*  	call umul24x8
0411F1             0328*  
0411F1             0329*  @accumulate:
0411F1 FD 23       0330*  	inc iy
0411F3             0331*  ; highest byte of product to carry
0411F3 FD 77 03    0332*  	ld (iy+3),a
0411F6             0333*  ; low byte of product
0411F6 7D          0334*  	ld a,l
0411F7 FD 86 00    0335*  	add a,(iy+0)
0411FA FD 77 00    0336*  	ld (iy+0),a
0411FD             0337*  ; high byte of product
0411FD 7C          0338*  	ld a,h
0411FE FD 8E 01    0339*  	adc a,(iy+1)
041201 FD 77 01    0340*  	ld (iy+1),a
041204             0341*  ; uppper byte of product
041204 E5          0342*  	push hl
041205 33          0343*  	inc sp
041206 E1          0344*  	pop hl
041207 3B          0345*  	dec sp
041208 7C          0346*  	ld a,h
041209 FD 8E 02    0347*  	adc a,(iy+2)
04120C FD 77 02    0348*  	ld (iy+2),a
04120F             0349*  ; carry
04120F 3E 00       0350*  	ld a,0 ; preserve flags
041211 FD 8E 03    0351*  	adc a,(iy+3)
041214 FD 77 03    0352*  	ld (iy+3),a
041217 C9          0353*  	ret
041218             0354*  
041218             0355*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
041218             0356*  umul168:
041218 CD C0 11 04 0357*  	call umul24x24
04121C FD 27 FF    0358*  	ld hl,(iy-1)
04121F C9          0359*  	ret
041220             0360*  
041220             0361*  ; smul168:	UH.L * UD.E --> UH.L (signed)
041220             0362*  smul168:
041220             0363*  ; make everything positive and store sign flags
041220 CD BF 0E 04 0364*  	call hlu_abs
041224 F5          0365*  	push af
041225 EB          0366*  	ex de,hl
041226 CD BF 0E 04 0367*  	call hlu_abs
04122A EB          0368*  	ex de,hl
04122B F5          0369*  	push af
04122C             0370*  ; do the division
04122C CD 18 12 04 0371*      call umul168 ; hl = product
041230             0372*  ; adjust sign of result
041230 F1          0373*  	pop af ; sign de
041231 FA 3C 12 04 0374*  	jp m,@de_neg
041235 F1          0375*  	pop af ; sign hl
041236 F0          0376*  	ret p ; both positive, nothing to do
041237             0377*  @hl_neg:
041237 CD CF 0E 04 0378*      call neg_hlu ; de pos, hl neg, result is negative
04123B C9          0379*      ret
04123C             0380*  @de_neg:
04123C F1          0381*  	pop af
04123D F8          0382*  	ret m ; both negative, nothing to do
04123E CD CF 0E 04 0383*  	call neg_hlu ; result is negative
041242 C9          0384*  	ret
041243             0385*  
041243             0386*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
041243             0387*  ; perform unsigned division of 16.8 fixed place values
041243             0388*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
041243             0389*  udiv168:
041243             0390*  ; back up divisor
041243 ED 53 7A 12 0391*  	ld (@ude),de
       04          
041248             0392*  ; get the 16-bit integer part of the quotient
041248 CD A2 0F 04 0393*      call udiv24 ; de = quotient, hl = remainder
04124C             0394*  ; load quotient to upper three bytes of output
04124C ED 53 81 12 0395*      ld (div168_out+1),de
       04          
041251             0396*  @div256:
041251             0397*  ; multiply remainder by 256
041251             0398*  	hlu_mul256
041251 29          0001*M         add hl,hl ; * 2
041252 29          0002*M         add hl,hl ; * 4
041253 29          0003*M         add hl,hl ; * 8
041254 29          0004*M         add hl,hl ; * 16
041255 29          0005*M         add hl,hl ; * 32
041256 29          0006*M         add hl,hl ; * 64
041257 29          0007*M         add hl,hl ; * 128
041258 29          0008*M         add hl,hl ; * 256
041259             0399*  ; skip fractional computation if remainder is zero
041259             0400*      sign_hlu
041259 19          0001*M         add hl,de
04125A B7          0002*M         or a
04125B ED 52       0003*M         sbc hl,de
04125D 20 03       0401*      jr nz,@div_frac
04125F AF          0402*      xor a
041260 18 0A       0403*      jr @write_frac
041262             0404*  ; now divide the shifted remainder by the divisor
041262             0405*  @div_frac:
041262 ED 5B 7A 12 0406*  	ld de,(@ude) ; get back divisor
       04          
041267 CD A2 0F 04 0407*      call udiv24 ; de = quotient, hl = remainder
04126B             0408*  ; load low byte of quotient to low byte of output
04126B 7B          0409*      ld a,e
04126C             0410*  @write_frac:
04126C 32 80 12 04 0411*      ld (div168_out),a
041270             0412*  ; load de with return value
041270 ED 5B 80 12 0413*      ld de,(div168_out)
       04          
041275             0414*  ; load a with any overflow
041275 3A 83 12 04 0415*      ld a,(div168_out+3)
041279 C9          0416*      ret ; ud.e is the 16.8 result
04127A             0417*  @ude: ds 6
041280             0418*  div168_out: ds 4 ; the extra byte is for overflow
041284             0419*  
041284             0420*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
041284             0421*  ; perform signed division of 16.8 fixed place values
041284             0422*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
041284             0423*  sdiv168:
041284             0424*  ; make everything positive and store sign flags
041284 CD BF 0E 04 0425*  	call hlu_abs
041288 F5          0426*  	push af
041289 EB          0427*  	ex de,hl
04128A CD BF 0E 04 0428*  	call hlu_abs
04128E EB          0429*  	ex de,hl
04128F F5          0430*  	push af
041290             0431*  ; do the division
041290 CD 43 12 04 0432*      call udiv168 ; de = quotient, hl = remainder
041294             0433*  ; adjust sign of result
041294 F1          0434*  	pop af ; sign de
041295 FA A2 12 04 0435*  	jp m,@de_neg
041299 F1          0436*  	pop af ; sign hl
04129A F0          0437*  	ret p ; both positive, nothing to do
04129B             0438*  @hl_neg:
04129B EB          0439*      ex de,hl ; hl = quotient, de = remainder
04129C CD CF 0E 04 0440*      call neg_hlu ; de pos, hl neg, result is negative
0412A0 EB          0441*      ex de,hl ; de = negated quotient, hl = remainder
0412A1 C9          0442*      ret
0412A2             0443*  @de_neg:
0412A2 F1          0444*  	pop af
0412A3 F8          0445*  	ret m ; both negative, nothing to do
0412A4 EB          0446*      ex de,hl ; hl = quotient, de = remainder
0412A5 CD CF 0E 04 0447*  	call neg_hlu ; result is negative
0412A9 EB          0448*      ex de,hl ; de = negated quotient, hl = remainder
0412AA C9          0449*  	ret
0412AB             0450*  ; ========== FROM maths24.inc ==========
0412AB             0451*  
0412AB             0452*  ; Expects  ADL mode
0412AB             0453*  ; Inputs:  UH.L
0412AB             0454*  ; Outputs: UH.L is the 16.8 square root
0412AB             0455*  ;          UD.E is the difference inputHL-DE^2
0412AB             0456*  ;          c flag reset
0412AB             0457*  sqrt168:
0412AB CD B5 12 04 0458*      call sqrt24
0412AF EB          0459*      ex de,hl
0412B0 29          0460*      add hl,hl
0412B1 29          0461*      add hl,hl
0412B2 29          0462*      add hl,hl
0412B3 29          0463*      add hl,hl
0412B4 C9          0464*      ret
0412B5             0465*  
0412B5             0466*  ; Expects  ADL mode
0412B5             0467*  ; Inputs:  HL
0412B5             0468*  ; Outputs: DE is the integer square root
0412B5             0469*  ;          HL is the difference inputHL-DE^2
0412B5             0470*  ;          c flag reset
0412B5             0471*  sqrt24:
0412B5 AF          0472*      xor a
0412B6 45          0473*      ld b,l
0412B7 C5          0474*      push bc
0412B8 47          0475*      ld b,a
0412B9 57          0476*      ld d,a
0412BA 4F          0477*      ld c,a
0412BB 6F          0478*      ld l,a
0412BC 5F          0479*      ld e,a
0412BD             0480*  
0412BD             0481*      ;Iteration 1
0412BD 29          0482*      add hl,hl
0412BE CB 11       0483*      rl c
0412C0 29          0484*      add hl,hl
0412C1 CB 11       0485*      rl c
0412C3 91          0486*      sub c
0412C4 30 04       0487*      jr nc,$+6
0412C6 1C          0488*      inc e
0412C7 1C          0489*      inc e
0412C8 2F          0490*      cpl
0412C9 4F          0491*      ld c,a
0412CA             0492*  
0412CA             0493*      ;Iteration 2
0412CA 29          0494*      add hl,hl
0412CB CB 11       0495*      rl c
0412CD 29          0496*      add hl,hl
0412CE CB 11       0497*      rl c
0412D0 CB 13       0498*      rl e
0412D2 7B          0499*      ld a,e
0412D3 91          0500*      sub c
0412D4 30 04       0501*      jr nc,$+6
0412D6 1C          0502*      inc e
0412D7 1C          0503*      inc e
0412D8 2F          0504*      cpl
0412D9 4F          0505*      ld c,a
0412DA             0506*  
0412DA             0507*      ;Iteration 3
0412DA 29          0508*      add hl,hl
0412DB CB 11       0509*      rl c
0412DD 29          0510*      add hl,hl
0412DE CB 11       0511*      rl c
0412E0 CB 13       0512*      rl e
0412E2 7B          0513*      ld a,e
0412E3 91          0514*      sub c
0412E4 30 04       0515*      jr nc,$+6
0412E6 1C          0516*      inc e
0412E7 1C          0517*      inc e
0412E8 2F          0518*      cpl
0412E9 4F          0519*      ld c,a
0412EA             0520*  
0412EA             0521*      ;Iteration 4
0412EA 29          0522*      add hl,hl
0412EB CB 11       0523*      rl c
0412ED 29          0524*      add hl,hl
0412EE CB 11       0525*      rl c
0412F0 CB 13       0526*      rl e
0412F2 7B          0527*      ld a,e
0412F3 91          0528*      sub c
0412F4 30 04       0529*      jr nc,$+6
0412F6 1C          0530*      inc e
0412F7 1C          0531*      inc e
0412F8 2F          0532*      cpl
0412F9 4F          0533*      ld c,a
0412FA             0534*  
0412FA             0535*      ;Iteration 5
0412FA 29          0536*      add hl,hl
0412FB CB 11       0537*      rl c
0412FD 29          0538*      add hl,hl
0412FE CB 11       0539*      rl c
041300 CB 13       0540*      rl e
041302 7B          0541*      ld a,e
041303 91          0542*      sub c
041304 30 04       0543*      jr nc,$+6
041306 1C          0544*      inc e
041307 1C          0545*      inc e
041308 2F          0546*      cpl
041309 4F          0547*      ld c,a
04130A             0548*  
04130A             0549*      ;Iteration 6
04130A 29          0550*      add hl,hl
04130B CB 11       0551*      rl c
04130D 29          0552*      add hl,hl
04130E CB 11       0553*      rl c
041310 CB 13       0554*      rl e
041312 7B          0555*      ld a,e
041313 91          0556*      sub c
041314 30 04       0557*      jr nc,$+6
041316 1C          0558*      inc e
041317 1C          0559*      inc e
041318 2F          0560*      cpl
041319 4F          0561*      ld c,a
04131A             0562*  
04131A             0563*      ;Iteration 7
04131A 29          0564*      add hl,hl
04131B CB 11       0565*      rl c
04131D 29          0566*      add hl,hl
04131E CB 11       0567*      rl c
041320 CB 10       0568*      rl b
041322 EB          0569*      ex de,hl
041323 29          0570*      add hl,hl
041324 E5          0571*      push hl
041325 ED 42       0572*      sbc hl,bc
041327 30 06       0573*      jr nc,$+8
041329 7C          0574*      ld a,h
04132A 2F          0575*      cpl
04132B 47          0576*      ld b,a
04132C 7D          0577*      ld a,l
04132D 2F          0578*      cpl
04132E 4F          0579*      ld c,a
04132F E1          0580*      pop hl
041330 30 02       0581*      jr nc,$+4
041332 23          0582*      inc hl
041333 23          0583*      inc hl
041334 EB          0584*      ex de,hl
041335             0585*  
041335             0586*      ;Iteration 8
041335 29          0587*      add hl,hl
041336 69          0588*      ld l,c
041337 60          0589*      ld h,b
041338 ED 6A       0590*      adc hl,hl
04133A ED 6A       0591*      adc hl,hl
04133C EB          0592*      ex de,hl
04133D 29          0593*      add hl,hl
04133E ED 52       0594*      sbc hl,de
041340 19          0595*      add hl,de
041341 EB          0596*      ex de,hl
041342 30 04       0597*      jr nc,$+6
041344 ED 52       0598*      sbc hl,de
041346 13          0599*      inc de
041347 13          0600*      inc de
041348             0601*  
041348             0602*      ;Iteration 9
041348 F1          0603*      pop af
041349 17          0604*      rla
04134A ED 6A       0605*      adc hl,hl
04134C 17          0606*      rla
04134D ED 6A       0607*      adc hl,hl
04134F EB          0608*      ex de,hl
041350 29          0609*      add hl,hl
041351 ED 52       0610*      sbc hl,de
041353 19          0611*      add hl,de
041354 EB          0612*      ex de,hl
041355 30 04       0613*      jr nc,$+6
041357 ED 52       0614*      sbc hl,de
041359 13          0615*      inc de
04135A 13          0616*      inc de
04135B             0617*  
04135B             0618*      ;Iteration 10
04135B 17          0619*      rla
04135C ED 6A       0620*      adc hl,hl
04135E 17          0621*      rla
04135F ED 6A       0622*      adc hl,hl
041361 EB          0623*      ex de,hl
041362 29          0624*      add hl,hl
041363 ED 52       0625*      sbc hl,de
041365 19          0626*      add hl,de
041366 EB          0627*      ex de,hl
041367 30 04       0628*      jr nc,$+6
041369 ED 52       0629*      sbc hl,de
04136B 13          0630*      inc de
04136C 13          0631*      inc de
04136D             0632*  
04136D             0633*      ;Iteration 11
04136D 17          0634*      rla
04136E ED 6A       0635*      adc hl,hl
041370 17          0636*      rla
041371 ED 6A       0637*      adc hl,hl
041373 EB          0638*      ex de,hl
041374 29          0639*      add hl,hl
041375 ED 52       0640*      sbc hl,de
041377 19          0641*      add hl,de
041378 EB          0642*      ex de,hl
041379 30 04       0643*      jr nc,$+6
04137B ED 52       0644*      sbc hl,de
04137D 13          0645*      inc de
04137E 13          0646*      inc de
04137F             0647*  
04137F             0648*      ;Iteration 11
04137F 17          0649*      rla
041380 ED 6A       0650*      adc hl,hl
041382 17          0651*      rla
041383 ED 6A       0652*      adc hl,hl
041385 EB          0653*      ex de,hl
041386 29          0654*      add hl,hl
041387 ED 52       0655*      sbc hl,de
041389 19          0656*      add hl,de
04138A EB          0657*      ex de,hl
04138B 30 04       0658*      jr nc,$+6
04138D ED 52       0659*      sbc hl,de
04138F 13          0660*      inc de
041390 13          0661*      inc de
041391             0662*  
041391 CB 1A       0663*      rr d
041393 CB 1B       0664*      rr e
041395 C9          0665*      ret
041396             0044   
041396             0045   ; Application includes
041396             0046   	include "font_rc.inc"
041396             0001*  ; Bitmap indices:
041396             0002*  BUF_0032: equ 0x0020 ; 32
041396             0003*  BUF_0033: equ 0x0021 ; 33 !
041396             0004*  ; Missing character 34 "
041396             0005*  ; Missing character 35 #
041396             0006*  ; Missing character 36 $
041396             0007*  ; Missing character 37 %
041396             0008*  ; Missing character 38 &
041396             0009*  ; Missing character 39 '
041396             0010*  ; Missing character 40 (
041396             0011*  ; Missing character 41 )
041396             0012*  ; Missing character 42 *
041396             0013*  ; Missing character 43 +
041396             0014*  ; Missing character 44 ,
041396             0015*  ; Missing character 45 -
041396             0016*  ; Missing character 46 .
041396             0017*  ; Missing character 47 /
041396             0018*  BUF_0048: equ 0x0030 ; 48 0
041396             0019*  BUF_0049: equ 0x0031 ; 49 1
041396             0020*  BUF_0050: equ 0x0032 ; 50 2
041396             0021*  BUF_0051: equ 0x0033 ; 51 3
041396             0022*  BUF_0052: equ 0x0034 ; 52 4
041396             0023*  BUF_0053: equ 0x0035 ; 53 5
041396             0024*  BUF_0054: equ 0x0036 ; 54 6
041396             0025*  BUF_0055: equ 0x0037 ; 55 7
041396             0026*  BUF_0056: equ 0x0038 ; 56 8
041396             0027*  BUF_0057: equ 0x0039 ; 57 9
041396             0028*  ; Missing character 58 :
041396             0029*  ; Missing character 59 ;
041396             0030*  ; Missing character 60 <
041396             0031*  ; Missing character 61 =
041396             0032*  ; Missing character 62 >
041396             0033*  BUF_0063: equ 0x003F ; 63 ?
041396             0034*  ; Missing character 64 @
041396             0035*  BUF_0065: equ 0x0041 ; 65 A
041396             0036*  BUF_0066: equ 0x0042 ; 66 B
041396             0037*  BUF_0067: equ 0x0043 ; 67 C
041396             0038*  BUF_0068: equ 0x0044 ; 68 D
041396             0039*  BUF_0069: equ 0x0045 ; 69 E
041396             0040*  BUF_0070: equ 0x0046 ; 70 F
041396             0041*  BUF_0071: equ 0x0047 ; 71 G
041396             0042*  BUF_0072: equ 0x0048 ; 72 H
041396             0043*  BUF_0073: equ 0x0049 ; 73 I
041396             0044*  BUF_0074: equ 0x004A ; 74 J
041396             0045*  BUF_0075: equ 0x004B ; 75 K
041396             0046*  BUF_0076: equ 0x004C ; 76 L
041396             0047*  BUF_0077: equ 0x004D ; 77 M
041396             0048*  BUF_0078: equ 0x004E ; 78 N
041396             0049*  BUF_0079: equ 0x004F ; 79 O
041396             0050*  BUF_0080: equ 0x0050 ; 80 P
041396             0051*  BUF_0081: equ 0x0051 ; 81 Q
041396             0052*  BUF_0082: equ 0x0052 ; 82 R
041396             0053*  BUF_0083: equ 0x0053 ; 83 S
041396             0054*  BUF_0084: equ 0x0054 ; 84 T
041396             0055*  BUF_0085: equ 0x0055 ; 85 U
041396             0056*  BUF_0086: equ 0x0056 ; 86 V
041396             0057*  BUF_0087: equ 0x0057 ; 87 W
041396             0058*  BUF_0088: equ 0x0058 ; 88 X
041396             0059*  BUF_0089: equ 0x0059 ; 89 Y
041396             0060*  BUF_0090: equ 0x005A ; 90 Z
041396             0061*  ; Missing character 91 [
041396             0062*  ; Missing character 92 \
041396             0063*  ; Missing character 93 ]
041396             0064*  ; Missing character 94 ^
041396             0065*  ; Missing character 95 _
041396             0066*  ; Missing character 96 `
041396             0067*  ; Missing character 97 a
041396             0068*  ; Missing character 98 b
041396             0069*  ; Missing character 99 c
041396             0070*  ; Missing character 100 d
041396             0071*  ; Missing character 101 e
041396             0072*  ; Missing character 102 f
041396             0073*  ; Missing character 103 g
041396             0074*  ; Missing character 104 h
041396             0075*  ; Missing character 105 i
041396             0076*  ; Missing character 106 j
041396             0077*  ; Missing character 107 k
041396             0078*  ; Missing character 108 l
041396             0079*  ; Missing character 109 m
041396             0080*  ; Missing character 110 n
041396             0081*  ; Missing character 111 o
041396             0082*  ; Missing character 112 p
041396             0083*  ; Missing character 113 q
041396             0084*  ; Missing character 114 r
041396             0085*  ; Missing character 115 s
041396             0086*  ; Missing character 116 t
041396             0087*  ; Missing character 117 u
041396             0088*  ; Missing character 118 v
041396             0089*  ; Missing character 119 w
041396             0090*  ; Missing character 120 x
041396             0091*  ; Missing character 121 y
041396             0092*  ; Missing character 122 z
041396             0093*  ; [y_offset, dim_y, dim_x], buffer_id label: ; mind the little-endian order when fetching these!!!
041396             0094*  font_rc:
041396 06 01 00 20 0095*  	dl 0x000106,BUF_0032
       00 00       
04139C 03 0E 00 21 0096*  	dl 0x000E03,BUF_0033
       00 00       
0413A2 06 01 00 20 0097*  	dl 0x000106,BUF_0032 ; Missing character 34
       00 00       
0413A8 06 01 00 20 0098*  	dl 0x000106,BUF_0032 ; Missing character 35
       00 00       
0413AE 06 01 00 20 0099*  	dl 0x000106,BUF_0032 ; Missing character 36
       00 00       
0413B4 06 01 00 20 0100*  	dl 0x000106,BUF_0032 ; Missing character 37
       00 00       
0413BA 06 01 00 20 0101*  	dl 0x000106,BUF_0032 ; Missing character 38
       00 00       
0413C0 06 01 00 20 0102*  	dl 0x000106,BUF_0032 ; Missing character 39
       00 00       
0413C6 06 01 00 20 0103*  	dl 0x000106,BUF_0032 ; Missing character 40
       00 00       
0413CC 06 01 00 20 0104*  	dl 0x000106,BUF_0032 ; Missing character 41
       00 00       
0413D2 06 01 00 20 0105*  	dl 0x000106,BUF_0032 ; Missing character 42
       00 00       
0413D8 06 01 00 20 0106*  	dl 0x000106,BUF_0032 ; Missing character 43
       00 00       
0413DE 06 01 00 20 0107*  	dl 0x000106,BUF_0032 ; Missing character 44
       00 00       
0413E4 06 01 00 20 0108*  	dl 0x000106,BUF_0032 ; Missing character 45
       00 00       
0413EA 06 01 00 20 0109*  	dl 0x000106,BUF_0032 ; Missing character 46
       00 00       
0413F0 06 01 00 20 0110*  	dl 0x000106,BUF_0032 ; Missing character 47
       00 00       
0413F6 08 0E 00 30 0111*  	dl 0x000E08,BUF_0048
       00 00       
0413FC 08 0E 00 31 0112*  	dl 0x000E08,BUF_0049
       00 00       
041402 08 0E 00 32 0113*  	dl 0x000E08,BUF_0050
       00 00       
041408 08 0E 00 33 0114*  	dl 0x000E08,BUF_0051
       00 00       
04140E 08 0E 00 34 0115*  	dl 0x000E08,BUF_0052
       00 00       
041414 08 0E 00 35 0116*  	dl 0x000E08,BUF_0053
       00 00       
04141A 08 0E 00 36 0117*  	dl 0x000E08,BUF_0054
       00 00       
041420 08 0E 00 37 0118*  	dl 0x000E08,BUF_0055
       00 00       
041426 08 0E 00 38 0119*  	dl 0x000E08,BUF_0056
       00 00       
04142C 08 0E 00 39 0120*  	dl 0x000E08,BUF_0057
       00 00       
041432 06 01 00 20 0121*  	dl 0x000106,BUF_0032 ; Missing character 58
       00 00       
041438 06 01 00 20 0122*  	dl 0x000106,BUF_0032 ; Missing character 59
       00 00       
04143E 06 01 00 20 0123*  	dl 0x000106,BUF_0032 ; Missing character 60
       00 00       
041444 06 01 00 20 0124*  	dl 0x000106,BUF_0032 ; Missing character 61
       00 00       
04144A 06 01 00 20 0125*  	dl 0x000106,BUF_0032 ; Missing character 62
       00 00       
041450 08 0E 00 3F 0126*  	dl 0x000E08,BUF_0063
       00 00       
041456 06 01 00 20 0127*  	dl 0x000106,BUF_0032 ; Missing character 64
       00 00       
04145C 07 0E 00 41 0128*  	dl 0x000E07,BUF_0065
       00 00       
041462 08 0E 00 42 0129*  	dl 0x000E08,BUF_0066
       00 00       
041468 07 0E 00 43 0130*  	dl 0x000E07,BUF_0067
       00 00       
04146E 08 0E 00 44 0131*  	dl 0x000E08,BUF_0068
       00 00       
041474 08 0E 00 45 0132*  	dl 0x000E08,BUF_0069
       00 00       
04147A 07 0E 00 46 0133*  	dl 0x000E07,BUF_0070
       00 00       
041480 08 0E 00 47 0134*  	dl 0x000E08,BUF_0071
       00 00       
041486 07 0E 00 48 0135*  	dl 0x000E07,BUF_0072
       00 00       
04148C 07 0E 00 49 0136*  	dl 0x000E07,BUF_0073
       00 00       
041492 08 0E 00 4A 0137*  	dl 0x000E08,BUF_0074
       00 00       
041498 07 0E 00 4B 0138*  	dl 0x000E07,BUF_0075
       00 00       
04149E 08 0E 00 4C 0139*  	dl 0x000E08,BUF_0076
       00 00       
0414A4 09 0E 00 4D 0140*  	dl 0x000E09,BUF_0077
       00 00       
0414AA 07 0E 00 4E 0141*  	dl 0x000E07,BUF_0078
       00 00       
0414B0 08 0E 00 4F 0142*  	dl 0x000E08,BUF_0079
       00 00       
0414B6 07 0E 00 50 0143*  	dl 0x000E07,BUF_0080
       00 00       
0414BC 08 0F 00 51 0144*  	dl 0x000F08,BUF_0081
       00 00       
0414C2 08 0E 00 52 0145*  	dl 0x000E08,BUF_0082
       00 00       
0414C8 08 0E 00 53 0146*  	dl 0x000E08,BUF_0083
       00 00       
0414CE 07 0E 00 54 0147*  	dl 0x000E07,BUF_0084
       00 00       
0414D4 08 0E 00 55 0148*  	dl 0x000E08,BUF_0085
       00 00       
0414DA 07 0E 00 56 0149*  	dl 0x000E07,BUF_0086
       00 00       
0414E0 0B 0E 00 57 0150*  	dl 0x000E0B,BUF_0087
       00 00       
0414E6 07 0E 00 58 0151*  	dl 0x000E07,BUF_0088
       00 00       
0414EC 08 0E 00 59 0152*  	dl 0x000E08,BUF_0089
       00 00       
0414F2 07 0E 00 5A 0153*  	dl 0x000E07,BUF_0090
       00 00       
0414F8 06 01 00 20 0154*  	dl 0x000106,BUF_0032 ; Missing character 91
       00 00       
0414FE 06 01 00 20 0155*  	dl 0x000106,BUF_0032 ; Missing character 92
       00 00       
041504 06 01 00 20 0156*  	dl 0x000106,BUF_0032 ; Missing character 93
       00 00       
04150A 06 01 00 20 0157*  	dl 0x000106,BUF_0032 ; Missing character 94
       00 00       
041510 06 01 00 20 0158*  	dl 0x000106,BUF_0032 ; Missing character 95
       00 00       
041516 06 01 00 20 0159*  	dl 0x000106,BUF_0032 ; Missing character 96
       00 00       
04151C 06 01 00 20 0160*  	dl 0x000106,BUF_0032 ; Missing character 97
       00 00       
041522 06 01 00 20 0161*  	dl 0x000106,BUF_0032 ; Missing character 98
       00 00       
041528 06 01 00 20 0162*  	dl 0x000106,BUF_0032 ; Missing character 99
       00 00       
04152E 06 01 00 20 0163*  	dl 0x000106,BUF_0032 ; Missing character 100
       00 00       
041534 06 01 00 20 0164*  	dl 0x000106,BUF_0032 ; Missing character 101
       00 00       
04153A 06 01 00 20 0165*  	dl 0x000106,BUF_0032 ; Missing character 102
       00 00       
041540 06 01 00 20 0166*  	dl 0x000106,BUF_0032 ; Missing character 103
       00 00       
041546 06 01 00 20 0167*  	dl 0x000106,BUF_0032 ; Missing character 104
       00 00       
04154C 06 01 00 20 0168*  	dl 0x000106,BUF_0032 ; Missing character 105
       00 00       
041552 06 01 00 20 0169*  	dl 0x000106,BUF_0032 ; Missing character 106
       00 00       
041558 06 01 00 20 0170*  	dl 0x000106,BUF_0032 ; Missing character 107
       00 00       
04155E 06 01 00 20 0171*  	dl 0x000106,BUF_0032 ; Missing character 108
       00 00       
041564 06 01 00 20 0172*  	dl 0x000106,BUF_0032 ; Missing character 109
       00 00       
04156A 06 01 00 20 0173*  	dl 0x000106,BUF_0032 ; Missing character 110
       00 00       
041570 06 01 00 20 0174*  	dl 0x000106,BUF_0032 ; Missing character 111
       00 00       
041576 06 01 00 20 0175*  	dl 0x000106,BUF_0032 ; Missing character 112
       00 00       
04157C 06 01 00 20 0176*  	dl 0x000106,BUF_0032 ; Missing character 113
       00 00       
041582 06 01 00 20 0177*  	dl 0x000106,BUF_0032 ; Missing character 114
       00 00       
041588 06 01 00 20 0178*  	dl 0x000106,BUF_0032 ; Missing character 115
       00 00       
04158E 06 01 00 20 0179*  	dl 0x000106,BUF_0032 ; Missing character 116
       00 00       
041594 06 01 00 20 0180*  	dl 0x000106,BUF_0032 ; Missing character 117
       00 00       
04159A 06 01 00 20 0181*  	dl 0x000106,BUF_0032 ; Missing character 118
       00 00       
0415A0 06 01 00 20 0182*  	dl 0x000106,BUF_0032 ; Missing character 119
       00 00       
0415A6 06 01 00 20 0183*  	dl 0x000106,BUF_0032 ; Missing character 120
       00 00       
0415AC 06 01 00 20 0184*  	dl 0x000106,BUF_0032 ; Missing character 121
       00 00       
0415B2 06 01 00 20 0185*  	dl 0x000106,BUF_0032 ; Missing character 122
       00 00       
0415B8             0186*  
0415B8             0187*  ; Import .rgba2 bitmap files and load them into VDP buffers
0415B8             0188*  load_font_rc:
0415B8             0189*  
0415B8 21 5C 1B 04 0190*  	ld hl,Frc032
0415BC 11 00 E0 B7 0191*  	ld de,filedata
0415C0 01 00 00 01 0192*  	ld bc,65536
0415C4 3E 01       0193*  	ld a,mos_load
0415C6 5B CF       0194*  	RST.LIL 08h
0415C8 21 20 00 00 0195*  	ld hl,BUF_0032
0415CC 01 06 00 00 0196*  	ld bc,6
0415D0 11 01 00 00 0197*  	ld de,1
0415D4 DD 21 06 00 0198*  	ld ix,6
       00          
0415D9 CD 92 0A 04 0199*  	call vdu_load_img
0415DD             0200*  
0415DD 21 6F 1B 04 0201*  	ld hl,Frc033
0415E1 11 00 E0 B7 0202*  	ld de,filedata
0415E5 01 00 00 01 0203*  	ld bc,65536
0415E9 3E 01       0204*  	ld a,mos_load
0415EB 5B CF       0205*  	RST.LIL 08h
0415ED 21 21 00 00 0206*  	ld hl,BUF_0033
0415F1 01 03 00 00 0207*  	ld bc,3
0415F5 11 0E 00 00 0208*  	ld de,14
0415F9 DD 21 2A 00 0209*  	ld ix,42
       00          
0415FE CD 92 0A 04 0210*  	call vdu_load_img
041602             0211*  ; Missing character 34
041602             0212*  ; Missing character 35
041602             0213*  ; Missing character 36
041602             0214*  ; Missing character 37
041602             0215*  ; Missing character 38
041602             0216*  ; Missing character 39
041602             0217*  ; Missing character 40
041602             0218*  ; Missing character 41
041602             0219*  ; Missing character 42
041602             0220*  ; Missing character 43
041602             0221*  ; Missing character 44
041602             0222*  ; Missing character 45
041602             0223*  ; Missing character 46
041602             0224*  ; Missing character 47
041602             0225*  
041602 21 82 1B 04 0226*  	ld hl,Frc048
041606 11 00 E0 B7 0227*  	ld de,filedata
04160A 01 00 00 01 0228*  	ld bc,65536
04160E 3E 01       0229*  	ld a,mos_load
041610 5B CF       0230*  	RST.LIL 08h
041612 21 30 00 00 0231*  	ld hl,BUF_0048
041616 01 08 00 00 0232*  	ld bc,8
04161A 11 0E 00 00 0233*  	ld de,14
04161E DD 21 70 00 0234*  	ld ix,112
       00          
041623 CD 92 0A 04 0235*  	call vdu_load_img
041627             0236*  
041627 21 95 1B 04 0237*  	ld hl,Frc049
04162B 11 00 E0 B7 0238*  	ld de,filedata
04162F 01 00 00 01 0239*  	ld bc,65536
041633 3E 01       0240*  	ld a,mos_load
041635 5B CF       0241*  	RST.LIL 08h
041637 21 31 00 00 0242*  	ld hl,BUF_0049
04163B 01 08 00 00 0243*  	ld bc,8
04163F 11 0E 00 00 0244*  	ld de,14
041643 DD 21 70 00 0245*  	ld ix,112
       00          
041648 CD 92 0A 04 0246*  	call vdu_load_img
04164C             0247*  
04164C 21 A8 1B 04 0248*  	ld hl,Frc050
041650 11 00 E0 B7 0249*  	ld de,filedata
041654 01 00 00 01 0250*  	ld bc,65536
041658 3E 01       0251*  	ld a,mos_load
04165A 5B CF       0252*  	RST.LIL 08h
04165C 21 32 00 00 0253*  	ld hl,BUF_0050
041660 01 08 00 00 0254*  	ld bc,8
041664 11 0E 00 00 0255*  	ld de,14
041668 DD 21 70 00 0256*  	ld ix,112
       00          
04166D CD 92 0A 04 0257*  	call vdu_load_img
041671             0258*  
041671 21 BB 1B 04 0259*  	ld hl,Frc051
041675 11 00 E0 B7 0260*  	ld de,filedata
041679 01 00 00 01 0261*  	ld bc,65536
04167D 3E 01       0262*  	ld a,mos_load
04167F 5B CF       0263*  	RST.LIL 08h
041681 21 33 00 00 0264*  	ld hl,BUF_0051
041685 01 08 00 00 0265*  	ld bc,8
041689 11 0E 00 00 0266*  	ld de,14
04168D DD 21 70 00 0267*  	ld ix,112
       00          
041692 CD 92 0A 04 0268*  	call vdu_load_img
041696             0269*  
041696 21 CE 1B 04 0270*  	ld hl,Frc052
04169A 11 00 E0 B7 0271*  	ld de,filedata
04169E 01 00 00 01 0272*  	ld bc,65536
0416A2 3E 01       0273*  	ld a,mos_load
0416A4 5B CF       0274*  	RST.LIL 08h
0416A6 21 34 00 00 0275*  	ld hl,BUF_0052
0416AA 01 08 00 00 0276*  	ld bc,8
0416AE 11 0E 00 00 0277*  	ld de,14
0416B2 DD 21 70 00 0278*  	ld ix,112
       00          
0416B7 CD 92 0A 04 0279*  	call vdu_load_img
0416BB             0280*  
0416BB 21 E1 1B 04 0281*  	ld hl,Frc053
0416BF 11 00 E0 B7 0282*  	ld de,filedata
0416C3 01 00 00 01 0283*  	ld bc,65536
0416C7 3E 01       0284*  	ld a,mos_load
0416C9 5B CF       0285*  	RST.LIL 08h
0416CB 21 35 00 00 0286*  	ld hl,BUF_0053
0416CF 01 08 00 00 0287*  	ld bc,8
0416D3 11 0E 00 00 0288*  	ld de,14
0416D7 DD 21 70 00 0289*  	ld ix,112
       00          
0416DC CD 92 0A 04 0290*  	call vdu_load_img
0416E0             0291*  
0416E0 21 F4 1B 04 0292*  	ld hl,Frc054
0416E4 11 00 E0 B7 0293*  	ld de,filedata
0416E8 01 00 00 01 0294*  	ld bc,65536
0416EC 3E 01       0295*  	ld a,mos_load
0416EE 5B CF       0296*  	RST.LIL 08h
0416F0 21 36 00 00 0297*  	ld hl,BUF_0054
0416F4 01 08 00 00 0298*  	ld bc,8
0416F8 11 0E 00 00 0299*  	ld de,14
0416FC DD 21 70 00 0300*  	ld ix,112
       00          
041701 CD 92 0A 04 0301*  	call vdu_load_img
041705             0302*  
041705 21 07 1C 04 0303*  	ld hl,Frc055
041709 11 00 E0 B7 0304*  	ld de,filedata
04170D 01 00 00 01 0305*  	ld bc,65536
041711 3E 01       0306*  	ld a,mos_load
041713 5B CF       0307*  	RST.LIL 08h
041715 21 37 00 00 0308*  	ld hl,BUF_0055
041719 01 08 00 00 0309*  	ld bc,8
04171D 11 0E 00 00 0310*  	ld de,14
041721 DD 21 70 00 0311*  	ld ix,112
       00          
041726 CD 92 0A 04 0312*  	call vdu_load_img
04172A             0313*  
04172A 21 1A 1C 04 0314*  	ld hl,Frc056
04172E 11 00 E0 B7 0315*  	ld de,filedata
041732 01 00 00 01 0316*  	ld bc,65536
041736 3E 01       0317*  	ld a,mos_load
041738 5B CF       0318*  	RST.LIL 08h
04173A 21 38 00 00 0319*  	ld hl,BUF_0056
04173E 01 08 00 00 0320*  	ld bc,8
041742 11 0E 00 00 0321*  	ld de,14
041746 DD 21 70 00 0322*  	ld ix,112
       00          
04174B CD 92 0A 04 0323*  	call vdu_load_img
04174F             0324*  
04174F 21 2D 1C 04 0325*  	ld hl,Frc057
041753 11 00 E0 B7 0326*  	ld de,filedata
041757 01 00 00 01 0327*  	ld bc,65536
04175B 3E 01       0328*  	ld a,mos_load
04175D 5B CF       0329*  	RST.LIL 08h
04175F 21 39 00 00 0330*  	ld hl,BUF_0057
041763 01 08 00 00 0331*  	ld bc,8
041767 11 0E 00 00 0332*  	ld de,14
04176B DD 21 70 00 0333*  	ld ix,112
       00          
041770 CD 92 0A 04 0334*  	call vdu_load_img
041774             0335*  ; Missing character 58
041774             0336*  ; Missing character 59
041774             0337*  ; Missing character 60
041774             0338*  ; Missing character 61
041774             0339*  ; Missing character 62
041774             0340*  
041774 21 40 1C 04 0341*  	ld hl,Frc063
041778 11 00 E0 B7 0342*  	ld de,filedata
04177C 01 00 00 01 0343*  	ld bc,65536
041780 3E 01       0344*  	ld a,mos_load
041782 5B CF       0345*  	RST.LIL 08h
041784 21 3F 00 00 0346*  	ld hl,BUF_0063
041788 01 08 00 00 0347*  	ld bc,8
04178C 11 0E 00 00 0348*  	ld de,14
041790 DD 21 70 00 0349*  	ld ix,112
       00          
041795 CD 92 0A 04 0350*  	call vdu_load_img
041799             0351*  ; Missing character 64
041799             0352*  
041799 21 53 1C 04 0353*  	ld hl,Frc065
04179D 11 00 E0 B7 0354*  	ld de,filedata
0417A1 01 00 00 01 0355*  	ld bc,65536
0417A5 3E 01       0356*  	ld a,mos_load
0417A7 5B CF       0357*  	RST.LIL 08h
0417A9 21 41 00 00 0358*  	ld hl,BUF_0065
0417AD 01 07 00 00 0359*  	ld bc,7
0417B1 11 0E 00 00 0360*  	ld de,14
0417B5 DD 21 62 00 0361*  	ld ix,98
       00          
0417BA CD 92 0A 04 0362*  	call vdu_load_img
0417BE             0363*  
0417BE 21 66 1C 04 0364*  	ld hl,Frc066
0417C2 11 00 E0 B7 0365*  	ld de,filedata
0417C6 01 00 00 01 0366*  	ld bc,65536
0417CA 3E 01       0367*  	ld a,mos_load
0417CC 5B CF       0368*  	RST.LIL 08h
0417CE 21 42 00 00 0369*  	ld hl,BUF_0066
0417D2 01 08 00 00 0370*  	ld bc,8
0417D6 11 0E 00 00 0371*  	ld de,14
0417DA DD 21 70 00 0372*  	ld ix,112
       00          
0417DF CD 92 0A 04 0373*  	call vdu_load_img
0417E3             0374*  
0417E3 21 79 1C 04 0375*  	ld hl,Frc067
0417E7 11 00 E0 B7 0376*  	ld de,filedata
0417EB 01 00 00 01 0377*  	ld bc,65536
0417EF 3E 01       0378*  	ld a,mos_load
0417F1 5B CF       0379*  	RST.LIL 08h
0417F3 21 43 00 00 0380*  	ld hl,BUF_0067
0417F7 01 07 00 00 0381*  	ld bc,7
0417FB 11 0E 00 00 0382*  	ld de,14
0417FF DD 21 62 00 0383*  	ld ix,98
       00          
041804 CD 92 0A 04 0384*  	call vdu_load_img
041808             0385*  
041808 21 8C 1C 04 0386*  	ld hl,Frc068
04180C 11 00 E0 B7 0387*  	ld de,filedata
041810 01 00 00 01 0388*  	ld bc,65536
041814 3E 01       0389*  	ld a,mos_load
041816 5B CF       0390*  	RST.LIL 08h
041818 21 44 00 00 0391*  	ld hl,BUF_0068
04181C 01 08 00 00 0392*  	ld bc,8
041820 11 0E 00 00 0393*  	ld de,14
041824 DD 21 70 00 0394*  	ld ix,112
       00          
041829 CD 92 0A 04 0395*  	call vdu_load_img
04182D             0396*  
04182D 21 9F 1C 04 0397*  	ld hl,Frc069
041831 11 00 E0 B7 0398*  	ld de,filedata
041835 01 00 00 01 0399*  	ld bc,65536
041839 3E 01       0400*  	ld a,mos_load
04183B 5B CF       0401*  	RST.LIL 08h
04183D 21 45 00 00 0402*  	ld hl,BUF_0069
041841 01 08 00 00 0403*  	ld bc,8
041845 11 0E 00 00 0404*  	ld de,14
041849 DD 21 70 00 0405*  	ld ix,112
       00          
04184E CD 92 0A 04 0406*  	call vdu_load_img
041852             0407*  
041852 21 B2 1C 04 0408*  	ld hl,Frc070
041856 11 00 E0 B7 0409*  	ld de,filedata
04185A 01 00 00 01 0410*  	ld bc,65536
04185E 3E 01       0411*  	ld a,mos_load
041860 5B CF       0412*  	RST.LIL 08h
041862 21 46 00 00 0413*  	ld hl,BUF_0070
041866 01 07 00 00 0414*  	ld bc,7
04186A 11 0E 00 00 0415*  	ld de,14
04186E DD 21 62 00 0416*  	ld ix,98
       00          
041873 CD 92 0A 04 0417*  	call vdu_load_img
041877             0418*  
041877 21 C5 1C 04 0419*  	ld hl,Frc071
04187B 11 00 E0 B7 0420*  	ld de,filedata
04187F 01 00 00 01 0421*  	ld bc,65536
041883 3E 01       0422*  	ld a,mos_load
041885 5B CF       0423*  	RST.LIL 08h
041887 21 47 00 00 0424*  	ld hl,BUF_0071
04188B 01 08 00 00 0425*  	ld bc,8
04188F 11 0E 00 00 0426*  	ld de,14
041893 DD 21 70 00 0427*  	ld ix,112
       00          
041898 CD 92 0A 04 0428*  	call vdu_load_img
04189C             0429*  
04189C 21 D8 1C 04 0430*  	ld hl,Frc072
0418A0 11 00 E0 B7 0431*  	ld de,filedata
0418A4 01 00 00 01 0432*  	ld bc,65536
0418A8 3E 01       0433*  	ld a,mos_load
0418AA 5B CF       0434*  	RST.LIL 08h
0418AC 21 48 00 00 0435*  	ld hl,BUF_0072
0418B0 01 07 00 00 0436*  	ld bc,7
0418B4 11 0E 00 00 0437*  	ld de,14
0418B8 DD 21 62 00 0438*  	ld ix,98
       00          
0418BD CD 92 0A 04 0439*  	call vdu_load_img
0418C1             0440*  
0418C1 21 EB 1C 04 0441*  	ld hl,Frc073
0418C5 11 00 E0 B7 0442*  	ld de,filedata
0418C9 01 00 00 01 0443*  	ld bc,65536
0418CD 3E 01       0444*  	ld a,mos_load
0418CF 5B CF       0445*  	RST.LIL 08h
0418D1 21 49 00 00 0446*  	ld hl,BUF_0073
0418D5 01 07 00 00 0447*  	ld bc,7
0418D9 11 0E 00 00 0448*  	ld de,14
0418DD DD 21 62 00 0449*  	ld ix,98
       00          
0418E2 CD 92 0A 04 0450*  	call vdu_load_img
0418E6             0451*  
0418E6 21 FE 1C 04 0452*  	ld hl,Frc074
0418EA 11 00 E0 B7 0453*  	ld de,filedata
0418EE 01 00 00 01 0454*  	ld bc,65536
0418F2 3E 01       0455*  	ld a,mos_load
0418F4 5B CF       0456*  	RST.LIL 08h
0418F6 21 4A 00 00 0457*  	ld hl,BUF_0074
0418FA 01 08 00 00 0458*  	ld bc,8
0418FE 11 0E 00 00 0459*  	ld de,14
041902 DD 21 70 00 0460*  	ld ix,112
       00          
041907 CD 92 0A 04 0461*  	call vdu_load_img
04190B             0462*  
04190B 21 11 1D 04 0463*  	ld hl,Frc075
04190F 11 00 E0 B7 0464*  	ld de,filedata
041913 01 00 00 01 0465*  	ld bc,65536
041917 3E 01       0466*  	ld a,mos_load
041919 5B CF       0467*  	RST.LIL 08h
04191B 21 4B 00 00 0468*  	ld hl,BUF_0075
04191F 01 07 00 00 0469*  	ld bc,7
041923 11 0E 00 00 0470*  	ld de,14
041927 DD 21 62 00 0471*  	ld ix,98
       00          
04192C CD 92 0A 04 0472*  	call vdu_load_img
041930             0473*  
041930 21 24 1D 04 0474*  	ld hl,Frc076
041934 11 00 E0 B7 0475*  	ld de,filedata
041938 01 00 00 01 0476*  	ld bc,65536
04193C 3E 01       0477*  	ld a,mos_load
04193E 5B CF       0478*  	RST.LIL 08h
041940 21 4C 00 00 0479*  	ld hl,BUF_0076
041944 01 08 00 00 0480*  	ld bc,8
041948 11 0E 00 00 0481*  	ld de,14
04194C DD 21 70 00 0482*  	ld ix,112
       00          
041951 CD 92 0A 04 0483*  	call vdu_load_img
041955             0484*  
041955 21 37 1D 04 0485*  	ld hl,Frc077
041959 11 00 E0 B7 0486*  	ld de,filedata
04195D 01 00 00 01 0487*  	ld bc,65536
041961 3E 01       0488*  	ld a,mos_load
041963 5B CF       0489*  	RST.LIL 08h
041965 21 4D 00 00 0490*  	ld hl,BUF_0077
041969 01 09 00 00 0491*  	ld bc,9
04196D 11 0E 00 00 0492*  	ld de,14
041971 DD 21 7E 00 0493*  	ld ix,126
       00          
041976 CD 92 0A 04 0494*  	call vdu_load_img
04197A             0495*  
04197A 21 4A 1D 04 0496*  	ld hl,Frc078
04197E 11 00 E0 B7 0497*  	ld de,filedata
041982 01 00 00 01 0498*  	ld bc,65536
041986 3E 01       0499*  	ld a,mos_load
041988 5B CF       0500*  	RST.LIL 08h
04198A 21 4E 00 00 0501*  	ld hl,BUF_0078
04198E 01 07 00 00 0502*  	ld bc,7
041992 11 0E 00 00 0503*  	ld de,14
041996 DD 21 62 00 0504*  	ld ix,98
       00          
04199B CD 92 0A 04 0505*  	call vdu_load_img
04199F             0506*  
04199F 21 5D 1D 04 0507*  	ld hl,Frc079
0419A3 11 00 E0 B7 0508*  	ld de,filedata
0419A7 01 00 00 01 0509*  	ld bc,65536
0419AB 3E 01       0510*  	ld a,mos_load
0419AD 5B CF       0511*  	RST.LIL 08h
0419AF 21 4F 00 00 0512*  	ld hl,BUF_0079
0419B3 01 08 00 00 0513*  	ld bc,8
0419B7 11 0E 00 00 0514*  	ld de,14
0419BB DD 21 70 00 0515*  	ld ix,112
       00          
0419C0 CD 92 0A 04 0516*  	call vdu_load_img
0419C4             0517*  
0419C4 21 70 1D 04 0518*  	ld hl,Frc080
0419C8 11 00 E0 B7 0519*  	ld de,filedata
0419CC 01 00 00 01 0520*  	ld bc,65536
0419D0 3E 01       0521*  	ld a,mos_load
0419D2 5B CF       0522*  	RST.LIL 08h
0419D4 21 50 00 00 0523*  	ld hl,BUF_0080
0419D8 01 07 00 00 0524*  	ld bc,7
0419DC 11 0E 00 00 0525*  	ld de,14
0419E0 DD 21 62 00 0526*  	ld ix,98
       00          
0419E5 CD 92 0A 04 0527*  	call vdu_load_img
0419E9             0528*  
0419E9 21 83 1D 04 0529*  	ld hl,Frc081
0419ED 11 00 E0 B7 0530*  	ld de,filedata
0419F1 01 00 00 01 0531*  	ld bc,65536
0419F5 3E 01       0532*  	ld a,mos_load
0419F7 5B CF       0533*  	RST.LIL 08h
0419F9 21 51 00 00 0534*  	ld hl,BUF_0081
0419FD 01 08 00 00 0535*  	ld bc,8
041A01 11 0F 00 00 0536*  	ld de,15
041A05 DD 21 78 00 0537*  	ld ix,120
       00          
041A0A CD 92 0A 04 0538*  	call vdu_load_img
041A0E             0539*  
041A0E 21 96 1D 04 0540*  	ld hl,Frc082
041A12 11 00 E0 B7 0541*  	ld de,filedata
041A16 01 00 00 01 0542*  	ld bc,65536
041A1A 3E 01       0543*  	ld a,mos_load
041A1C 5B CF       0544*  	RST.LIL 08h
041A1E 21 52 00 00 0545*  	ld hl,BUF_0082
041A22 01 08 00 00 0546*  	ld bc,8
041A26 11 0E 00 00 0547*  	ld de,14
041A2A DD 21 70 00 0548*  	ld ix,112
       00          
041A2F CD 92 0A 04 0549*  	call vdu_load_img
041A33             0550*  
041A33 21 A9 1D 04 0551*  	ld hl,Frc083
041A37 11 00 E0 B7 0552*  	ld de,filedata
041A3B 01 00 00 01 0553*  	ld bc,65536
041A3F 3E 01       0554*  	ld a,mos_load
041A41 5B CF       0555*  	RST.LIL 08h
041A43 21 53 00 00 0556*  	ld hl,BUF_0083
041A47 01 08 00 00 0557*  	ld bc,8
041A4B 11 0E 00 00 0558*  	ld de,14
041A4F DD 21 70 00 0559*  	ld ix,112
       00          
041A54 CD 92 0A 04 0560*  	call vdu_load_img
041A58             0561*  
041A58 21 BC 1D 04 0562*  	ld hl,Frc084
041A5C 11 00 E0 B7 0563*  	ld de,filedata
041A60 01 00 00 01 0564*  	ld bc,65536
041A64 3E 01       0565*  	ld a,mos_load
041A66 5B CF       0566*  	RST.LIL 08h
041A68 21 54 00 00 0567*  	ld hl,BUF_0084
041A6C 01 07 00 00 0568*  	ld bc,7
041A70 11 0E 00 00 0569*  	ld de,14
041A74 DD 21 62 00 0570*  	ld ix,98
       00          
041A79 CD 92 0A 04 0571*  	call vdu_load_img
041A7D             0572*  
041A7D 21 CF 1D 04 0573*  	ld hl,Frc085
041A81 11 00 E0 B7 0574*  	ld de,filedata
041A85 01 00 00 01 0575*  	ld bc,65536
041A89 3E 01       0576*  	ld a,mos_load
041A8B 5B CF       0577*  	RST.LIL 08h
041A8D 21 55 00 00 0578*  	ld hl,BUF_0085
041A91 01 08 00 00 0579*  	ld bc,8
041A95 11 0E 00 00 0580*  	ld de,14
041A99 DD 21 70 00 0581*  	ld ix,112
       00          
041A9E CD 92 0A 04 0582*  	call vdu_load_img
041AA2             0583*  
041AA2 21 E2 1D 04 0584*  	ld hl,Frc086
041AA6 11 00 E0 B7 0585*  	ld de,filedata
041AAA 01 00 00 01 0586*  	ld bc,65536
041AAE 3E 01       0587*  	ld a,mos_load
041AB0 5B CF       0588*  	RST.LIL 08h
041AB2 21 56 00 00 0589*  	ld hl,BUF_0086
041AB6 01 07 00 00 0590*  	ld bc,7
041ABA 11 0E 00 00 0591*  	ld de,14
041ABE DD 21 62 00 0592*  	ld ix,98
       00          
041AC3 CD 92 0A 04 0593*  	call vdu_load_img
041AC7             0594*  
041AC7 21 F5 1D 04 0595*  	ld hl,Frc087
041ACB 11 00 E0 B7 0596*  	ld de,filedata
041ACF 01 00 00 01 0597*  	ld bc,65536
041AD3 3E 01       0598*  	ld a,mos_load
041AD5 5B CF       0599*  	RST.LIL 08h
041AD7 21 57 00 00 0600*  	ld hl,BUF_0087
041ADB 01 0B 00 00 0601*  	ld bc,11
041ADF 11 0E 00 00 0602*  	ld de,14
041AE3 DD 21 9A 00 0603*  	ld ix,154
       00          
041AE8 CD 92 0A 04 0604*  	call vdu_load_img
041AEC             0605*  
041AEC 21 08 1E 04 0606*  	ld hl,Frc088
041AF0 11 00 E0 B7 0607*  	ld de,filedata
041AF4 01 00 00 01 0608*  	ld bc,65536
041AF8 3E 01       0609*  	ld a,mos_load
041AFA 5B CF       0610*  	RST.LIL 08h
041AFC 21 58 00 00 0611*  	ld hl,BUF_0088
041B00 01 07 00 00 0612*  	ld bc,7
041B04 11 0E 00 00 0613*  	ld de,14
041B08 DD 21 62 00 0614*  	ld ix,98
       00          
041B0D CD 92 0A 04 0615*  	call vdu_load_img
041B11             0616*  
041B11 21 1B 1E 04 0617*  	ld hl,Frc089
041B15 11 00 E0 B7 0618*  	ld de,filedata
041B19 01 00 00 01 0619*  	ld bc,65536
041B1D 3E 01       0620*  	ld a,mos_load
041B1F 5B CF       0621*  	RST.LIL 08h
041B21 21 59 00 00 0622*  	ld hl,BUF_0089
041B25 01 08 00 00 0623*  	ld bc,8
041B29 11 0E 00 00 0624*  	ld de,14
041B2D DD 21 70 00 0625*  	ld ix,112
       00          
041B32 CD 92 0A 04 0626*  	call vdu_load_img
041B36             0627*  
041B36 21 2E 1E 04 0628*  	ld hl,Frc090
041B3A 11 00 E0 B7 0629*  	ld de,filedata
041B3E 01 00 00 01 0630*  	ld bc,65536
041B42 3E 01       0631*  	ld a,mos_load
041B44 5B CF       0632*  	RST.LIL 08h
041B46 21 5A 00 00 0633*  	ld hl,BUF_0090
041B4A 01 07 00 00 0634*  	ld bc,7
041B4E 11 0E 00 00 0635*  	ld de,14
041B52 DD 21 62 00 0636*  	ld ix,98
       00          
041B57 CD 92 0A 04 0637*  	call vdu_load_img
041B5B             0638*  ; Missing character 91
041B5B             0639*  ; Missing character 92
041B5B             0640*  ; Missing character 93
041B5B             0641*  ; Missing character 94
041B5B             0642*  ; Missing character 95
041B5B             0643*  ; Missing character 96
041B5B             0644*  ; Missing character 97
041B5B             0645*  ; Missing character 98
041B5B             0646*  ; Missing character 99
041B5B             0647*  ; Missing character 100
041B5B             0648*  ; Missing character 101
041B5B             0649*  ; Missing character 102
041B5B             0650*  ; Missing character 103
041B5B             0651*  ; Missing character 104
041B5B             0652*  ; Missing character 105
041B5B             0653*  ; Missing character 106
041B5B             0654*  ; Missing character 107
041B5B             0655*  ; Missing character 108
041B5B             0656*  ; Missing character 109
041B5B             0657*  ; Missing character 110
041B5B             0658*  ; Missing character 111
041B5B             0659*  ; Missing character 112
041B5B             0660*  ; Missing character 113
041B5B             0661*  ; Missing character 114
041B5B             0662*  ; Missing character 115
041B5B             0663*  ; Missing character 116
041B5B             0664*  ; Missing character 117
041B5B             0665*  ; Missing character 118
041B5B             0666*  ; Missing character 119
041B5B             0667*  ; Missing character 120
041B5B             0668*  ; Missing character 121
041B5B             0669*  ; Missing character 122
041B5B             0670*  
041B5B C9          0671*  	ret
041B5C             0672*  
041B5C 66 6F 6E 74 0673*  Frc032: db "fonts/rc/032.rgba2",0
       73 2F 72 63 
       2F 30 33 32 
       2E 72 67 62 
       61 32 00    
041B6F 66 6F 6E 74 0674*  Frc033: db "fonts/rc/033.rgba2",0
       73 2F 72 63 
       2F 30 33 33 
       2E 72 67 62 
       61 32 00    
041B82 66 6F 6E 74 0675*  Frc048: db "fonts/rc/048.rgba2",0
       73 2F 72 63 
       2F 30 34 38 
       2E 72 67 62 
       61 32 00    
041B95 66 6F 6E 74 0676*  Frc049: db "fonts/rc/049.rgba2",0
       73 2F 72 63 
       2F 30 34 39 
       2E 72 67 62 
       61 32 00    
041BA8 66 6F 6E 74 0677*  Frc050: db "fonts/rc/050.rgba2",0
       73 2F 72 63 
       2F 30 35 30 
       2E 72 67 62 
       61 32 00    
041BBB 66 6F 6E 74 0678*  Frc051: db "fonts/rc/051.rgba2",0
       73 2F 72 63 
       2F 30 35 31 
       2E 72 67 62 
       61 32 00    
041BCE 66 6F 6E 74 0679*  Frc052: db "fonts/rc/052.rgba2",0
       73 2F 72 63 
       2F 30 35 32 
       2E 72 67 62 
       61 32 00    
041BE1 66 6F 6E 74 0680*  Frc053: db "fonts/rc/053.rgba2",0
       73 2F 72 63 
       2F 30 35 33 
       2E 72 67 62 
       61 32 00    
041BF4 66 6F 6E 74 0681*  Frc054: db "fonts/rc/054.rgba2",0
       73 2F 72 63 
       2F 30 35 34 
       2E 72 67 62 
       61 32 00    
041C07 66 6F 6E 74 0682*  Frc055: db "fonts/rc/055.rgba2",0
       73 2F 72 63 
       2F 30 35 35 
       2E 72 67 62 
       61 32 00    
041C1A 66 6F 6E 74 0683*  Frc056: db "fonts/rc/056.rgba2",0
       73 2F 72 63 
       2F 30 35 36 
       2E 72 67 62 
       61 32 00    
041C2D 66 6F 6E 74 0684*  Frc057: db "fonts/rc/057.rgba2",0
       73 2F 72 63 
       2F 30 35 37 
       2E 72 67 62 
       61 32 00    
041C40 66 6F 6E 74 0685*  Frc063: db "fonts/rc/063.rgba2",0
       73 2F 72 63 
       2F 30 36 33 
       2E 72 67 62 
       61 32 00    
041C53 66 6F 6E 74 0686*  Frc065: db "fonts/rc/065.rgba2",0
       73 2F 72 63 
       2F 30 36 35 
       2E 72 67 62 
       61 32 00    
041C66 66 6F 6E 74 0687*  Frc066: db "fonts/rc/066.rgba2",0
       73 2F 72 63 
       2F 30 36 36 
       2E 72 67 62 
       61 32 00    
041C79 66 6F 6E 74 0688*  Frc067: db "fonts/rc/067.rgba2",0
       73 2F 72 63 
       2F 30 36 37 
       2E 72 67 62 
       61 32 00    
041C8C 66 6F 6E 74 0689*  Frc068: db "fonts/rc/068.rgba2",0
       73 2F 72 63 
       2F 30 36 38 
       2E 72 67 62 
       61 32 00    
041C9F 66 6F 6E 74 0690*  Frc069: db "fonts/rc/069.rgba2",0
       73 2F 72 63 
       2F 30 36 39 
       2E 72 67 62 
       61 32 00    
041CB2 66 6F 6E 74 0691*  Frc070: db "fonts/rc/070.rgba2",0
       73 2F 72 63 
       2F 30 37 30 
       2E 72 67 62 
       61 32 00    
041CC5 66 6F 6E 74 0692*  Frc071: db "fonts/rc/071.rgba2",0
       73 2F 72 63 
       2F 30 37 31 
       2E 72 67 62 
       61 32 00    
041CD8 66 6F 6E 74 0693*  Frc072: db "fonts/rc/072.rgba2",0
       73 2F 72 63 
       2F 30 37 32 
       2E 72 67 62 
       61 32 00    
041CEB 66 6F 6E 74 0694*  Frc073: db "fonts/rc/073.rgba2",0
       73 2F 72 63 
       2F 30 37 33 
       2E 72 67 62 
       61 32 00    
041CFE 66 6F 6E 74 0695*  Frc074: db "fonts/rc/074.rgba2",0
       73 2F 72 63 
       2F 30 37 34 
       2E 72 67 62 
       61 32 00    
041D11 66 6F 6E 74 0696*  Frc075: db "fonts/rc/075.rgba2",0
       73 2F 72 63 
       2F 30 37 35 
       2E 72 67 62 
       61 32 00    
041D24 66 6F 6E 74 0697*  Frc076: db "fonts/rc/076.rgba2",0
       73 2F 72 63 
       2F 30 37 36 
       2E 72 67 62 
       61 32 00    
041D37 66 6F 6E 74 0698*  Frc077: db "fonts/rc/077.rgba2",0
       73 2F 72 63 
       2F 30 37 37 
       2E 72 67 62 
       61 32 00    
041D4A 66 6F 6E 74 0699*  Frc078: db "fonts/rc/078.rgba2",0
       73 2F 72 63 
       2F 30 37 38 
       2E 72 67 62 
       61 32 00    
041D5D 66 6F 6E 74 0700*  Frc079: db "fonts/rc/079.rgba2",0
       73 2F 72 63 
       2F 30 37 39 
       2E 72 67 62 
       61 32 00    
041D70 66 6F 6E 74 0701*  Frc080: db "fonts/rc/080.rgba2",0
       73 2F 72 63 
       2F 30 38 30 
       2E 72 67 62 
       61 32 00    
041D83 66 6F 6E 74 0702*  Frc081: db "fonts/rc/081.rgba2",0
       73 2F 72 63 
       2F 30 38 31 
       2E 72 67 62 
       61 32 00    
041D96 66 6F 6E 74 0703*  Frc082: db "fonts/rc/082.rgba2",0
       73 2F 72 63 
       2F 30 38 32 
       2E 72 67 62 
       61 32 00    
041DA9 66 6F 6E 74 0704*  Frc083: db "fonts/rc/083.rgba2",0
       73 2F 72 63 
       2F 30 38 33 
       2E 72 67 62 
       61 32 00    
041DBC 66 6F 6E 74 0705*  Frc084: db "fonts/rc/084.rgba2",0
       73 2F 72 63 
       2F 30 38 34 
       2E 72 67 62 
       61 32 00    
041DCF 66 6F 6E 74 0706*  Frc085: db "fonts/rc/085.rgba2",0
       73 2F 72 63 
       2F 30 38 35 
       2E 72 67 62 
       61 32 00    
041DE2 66 6F 6E 74 0707*  Frc086: db "fonts/rc/086.rgba2",0
       73 2F 72 63 
       2F 30 38 36 
       2E 72 67 62 
       61 32 00    
041DF5 66 6F 6E 74 0708*  Frc087: db "fonts/rc/087.rgba2",0
       73 2F 72 63 
       2F 30 38 37 
       2E 72 67 62 
       61 32 00    
041E08 66 6F 6E 74 0709*  Frc088: db "fonts/rc/088.rgba2",0
       73 2F 72 63 
       2F 30 38 38 
       2E 72 67 62 
       61 32 00    
041E1B 66 6F 6E 74 0710*  Frc089: db "fonts/rc/089.rgba2",0
       73 2F 72 63 
       2F 30 38 39 
       2E 72 67 62 
       61 32 00    
041E2E 66 6F 6E 74 0711*  Frc090: db "fonts/rc/090.rgba2",0
       73 2F 72 63 
       2F 30 39 30 
       2E 72 67 62 
       61 32 00    
041E41             0047   	include "input.inc"
041E41             0001*  keyboard_masks: ds 16 ; 16 bytes for the keyboard masks
041E51             0002*  
041E51             0003*  ; reset the local keyboard masks to zero
041E51             0004*  ; inputs: none
041E51             0005*  ; outputs: none
041E51             0006*  ; clobbers: a, b, iy
041E51             0007*  reset_keys:
041E51 FD 21 41 1E 0008*      ld iy,keyboard_masks
       04          
041E56 AF          0009*      xor a
041E57 06 10       0010*      ld b,16 ; loop counter
041E59             0011*  @loop:
041E59 FD 77 00    0012*      ld (iy),a
041E5C FD 23       0013*      inc iy
041E5E 10 F9       0014*      djnz @loop
041E60 C9          0015*      ret
041E61             0016*  
041E61             0017*  ; check system virtual keyboard map for keys down and or them with local keyboard masks
041E61             0018*  ; inputs: none
041E61             0019*  ; outputs: none
041E61             0020*  ; clobbers: a, b, ix, iy
041E61             0021*  set_keys:
041E61             0022*      MOSCALL mos_getkbmap ; ix points to the virtual keyboard map
041E61 3E 1E       0001*M 			LD	A, function
041E63 49 CF       0002*M 			RST.LIS	08h
041E65 FD 21 41 1E 0023*      ld iy,keyboard_masks
       04          
041E6A 06 10       0024*      ld b,16 ; loop counter
041E6C             0025*  @loop:
041E6C DD 7E 00    0026*      ld a,(ix)
041E6F FD B6 00    0027*      or (iy)
041E72 FD 77 00    0028*      ld (iy),a
041E75 DD 23       0029*      inc ix
041E77 FD 23       0030*      inc iy
041E79 10 F1       0031*      djnz @loop
041E7B C9          0032*      ret
041E7C             0033*  
041E7C             0034*  ; ============ KEYBOARD INPUT ============
041E7C             0035*  do_input:
041E7C             0036*  ; get user keyboard input
041E7C DD 21 41 1E 0037*      ld ix,keyboard_masks
       04          
041E81 3E FF       0038*      ld a,-1 ; anything non-zero to indicates no ship movement key pressed
041E83             0039*  
041E83             0040*  ; ------ QUIT ------
041E83             0041*  ; 113 Escape
041E83 DD CB 0E 46 0042*      bit 0,(ix+14)
041E87 C2 D9 2F 04 0043*  	jp nz,main_end
041E8B             0044*  
041E8B             0045*  ; 99 Space fire zee missiles
041E8B DD CB 0C 56 0046*      bit 2,(ix+12)
041E8F CA 93 1E 04 0047*      jp z,@Space
041E93             0048*  @Space:
041E93             0049*  
041E93             0050*  ; 26 Left
041E93 DD CB 03 4E 0051*      bit 1,(ix+3)
041E97 CA 9C 1E 04 0052*      jp z,@Left
041E9B             0053*  
041E9B AF          0054*      xor a
041E9C             0055*  @Left:
041E9C             0056*  
041E9C             0057*  ; 122 Right
041E9C DD CB 0F 4E 0058*      bit 1,(ix+15)
041EA0 CA A4 1E 04 0059*      jp z,@Right
041EA4             0060*  
041EA4             0061*  @Right:
041EA4             0062*  
041EA4             0063*  ; check keypress flag and branch accordingly
041EA4 A7          0064*      and a
041EA5             0065*  
041EA5 C9          0066*      ret
041EA6             0048       include "images.inc"
041EA6             0001*  image_type: equ 0
041EA6             0002*  image_width: equ image_type+3
041EA6             0003*  image_height: equ image_width+3
041EA6             0004*  image_filesize: equ image_height+3
041EA6             0005*  image_filename: equ image_filesize+3
041EA6             0006*  image_bufferId: equ image_filename+3
041EA6             0007*  image_record_size: equ image_bufferId+3
041EA6             0008*  
041EA6 00 00 00    0009*  cur_image_list: dl 0
041EA9 00 00 00    0010*  cur_file_idx: dl 0
041EAC 00 00 00    0011*  cur_filename: dl 0
041EAF 00 00 00    0012*  cur_buffer_id: dl 0
041EB2             0013*  
041EB2             0014*  load_ui_images:
041EB2             0015*  ; initialize image loading variables
041EB2 21 00 00 00 0016*  	ld hl,0
041EB6 22 A9 1E 04 0017*  	ld (cur_file_idx),hl
041EBA 21 83 2E 04 0018*  	ld hl,ui_image_list
041EBE 22 A6 1E 04 0019*  	ld (cur_image_list),hl
041EC2             0020*  ; load images
041EC2 06 02       0021*  	ld b,ui_num_images
041EC4             0022*  @loop:
041EC4 C5          0023*  	push bc
041EC5 CD 16 1F 04 0024*  	call load_next_image
041EC9 C1          0025*  	pop bc
041ECA 10 F8       0026*  	djnz @loop
041ECC C9          0027*  	ret
041ECD             0028*  
041ECD             0029*  ; inputs: bc is the number of images to load, cur_buffer_id_lut and cur_load_jump_table set to the address of the first entry in the respective lookup tables
041ECD             0030*  img_load_main:
041ECD AF          0031*  	xor a
041ECE 32 A9 1E 04 0032*      ld (cur_file_idx),a
041ED2             0033*  
041ED2             0034*  img_load_main_loop:
041ED2             0035*  ; back up loop counter
041ED2 C5          0036*      push bc
041ED3             0037*  
041ED3             0038*  ; plot the background
041ED3 CD A0 08 04 0039*  	call vdu_cls
041ED7 21 00 00 00 0040*      ld hl,BUF_SPLASH_BG
041EDB CD 74 09 04 0041*      call vdu_buff_select
041EDF 01 00 00 00 0042*      ld bc,0
041EE3 11 00 00 00 0043*      ld de,0
041EE7 CD 5C 0C 04 0044*      call vdu_plot_bmp
041EEB             0045*  
041EEB             0046*  ; load the next image
041EEB CD 16 1F 04 0047*      call load_next_image
041EEF             0048*  
041EEF             0049*  ; ; draw the most recently loaded image
041EEF             0050*  ; 	ld hl,(cur_buffer_id)
041EEF             0051*  ; 	call vdu_buff_select
041EEF             0052*  ; 	ld bc,0
041EEF             0053*  ; 	ld de,0
041EEF             0054*  ; 	call vdu_plot_bmp
041EEF             0055*  
041EEF             0056*  ; move logo
041EEF CD 76 1F 04 0057*  	call move_logo
041EF3             0058*  
041EF3             0059*  ; print current filename
041EF3 0E 03       0060*  	ld c,3 ; x
041EF5 06 00       0061*  	ld b,0 ; y
041EF7 CD 8C 08 04 0062*  	call vdu_move_cursor
041EFB 2A AC 1E 04 0063*  	ld hl,(cur_filename)
041EFF CD 77 00 04 0064*  	call printString
041F03             0065*  
041F03             0066*  ; wait for vblank to mitigate flicker
041F03 CD FB 08 04 0067*  	call vdu_vblank
041F07             0068*  
041F07             0069*  ; decrement loop counter
041F07 C1          0070*      pop bc
041F08 0B          0071*  	dec bc
041F09 79          0072*      ld a,c
041F0A B7          0073*      or a
041F0B C2 D2 1E 04 0074*      jp nz,img_load_main_loop
041F0F 78          0075*      ld a,b
041F10 B7          0076*      or a
041F11 C2 D2 1E 04 0077*      jp nz,img_load_main_loop
041F15 C9          0078*      ret
041F16             0079*  
041F16             0080*  load_next_image:
041F16 16 12       0081*      ld d,image_record_size
041F18 3A A9 1E 04 0082*  	ld a,(cur_file_idx)
041F1C 5F          0083*  	ld e,a
041F1D ED 5C       0084*      mlt de
041F1F FD 2A A6 1E 0085*      ld iy,(cur_image_list)
       04          
041F24 FD 19       0086*      add iy,de
041F26             0087*  
041F26 FD 7E 00    0088*      ld a,(iy+image_type) ; get image type
041F29 FD 07 03    0089*      ld bc,(iy+image_width) ; get image width
041F2C FD 17 06    0090*      ld de,(iy+image_height) ; get image height
041F2F FD 31 09    0091*      ld ix,(iy+image_filesize) ; get image file size
041F32 FD 27 0F    0092*  	ld hl,(iy+image_bufferId) ; get image bufferId
041F35 22 AF 1E 04 0093*  	ld (cur_buffer_id),hl
041F39 FD 37 0C    0094*      ld iy,(iy+image_filename) ; get image filename
041F3C FD 22 AC 1E 0095*  	ld (cur_filename),iy
       04          
041F41 CD 92 0A 04 0096*      call vdu_load_img
041F45 FD 21 A9 1E 0097*      ld iy,cur_file_idx
       04          
041F4A FD 34 00    0098*  	inc (iy)
041F4D C9          0099*  	ret
041F4E             0100*  
041F4E             0101*  img_load_init:
041F4E             0102*  ; initialize logo's position parameters
041F4E 21 00 00 00 0103*  	ld hl,0
041F52 22 9B 1F 04 0104*  	ld (logo_xvel),hl
041F56 22 9E 1F 04 0105*  	ld (logo_xpos),hl
041F5A             0106*  ; begin 16.8 maths to determine logo's y position and velocity
041F5A 21 00 E0 00 0107*  	ld hl,240-16*256 ; allow space for text at bottom of screen
041F5E 22 A4 1F 04 0108*  	ld (logo_ypos),hl
041F62 EB          0109*  	ex de,hl
041F63 21 00 F8 FF 0110*  	ld hl,-8*256 ; 8 pixels from top of screen
041F67 19          0111*  	add hl,de ; distance for logo to travel
041F68 11 00 A7 FF 0112*  	ld de,-sprites_num_images*256
041F6C CD 84 12 04 0113*  	call sdiv168 ; ud.e = distance / num images = y velocity
041F70 ED 53 A1 1F 0114*  	ld (logo_yvel),de
       04          
041F75             0115*  ; all done
041F75 C9          0116*      ret
041F76             0117*  
041F76             0118*  move_logo:
041F76             0119*  ; activate logo bitmap
041F76 21 01 00 00 0120*  	ld hl, BUF_SPLASH_LOGO
041F7A CD 74 09 04 0121*  	call vdu_buff_select
041F7E             0122*  ; update position based on velocity parameters
041F7E 2A A4 1F 04 0123*  	ld hl,(logo_ypos)
041F82 ED 5B A1 1F 0124*  	ld de,(logo_yvel)
       04          
041F87 19          0125*  	add hl,de
041F88 22 A4 1F 04 0126*  	ld (logo_ypos),hl
041F8C             0127*  ; draw logo
041F8C ED 4B 9E 1F 0128*  	ld bc,(logo_xpos)
       04          
041F91 ED 5B A4 1F 0129*  	ld de,(logo_ypos)
       04          
041F96 CD 78 0C 04 0130*  	call vdu_plot_bmp168
041F9A C9          0131*  	ret
041F9B             0132*  
041F9B 00 00 00    0133*  logo_xvel: dl 0
041F9E 00 00 00    0134*  logo_xpos: dl 0
041FA1             0135*  
041FA1 00 00 00    0136*  logo_yvel: dl 0
041FA4 00 00 00    0137*  logo_ypos: dl 0
041FA7             0049       include "images_sprites.inc"
041FA7             0001*  ; Generated by make_images.py
041FA7             0002*  
041FA7             0003*  sprites_num_images: equ 89
041FA7             0004*  
041FA7             0005*  ; buffer_ids:
041FA7             0006*  BUF_0TILE_EMPTY: equ 256
041FA7             0007*  BUF_1TILE_CROSS: equ 257
041FA7             0008*  BUF_2TILE_HORIZ: equ 258
041FA7             0009*  BUF_3TILE_VERT: equ 259
041FA7             0010*  BUF_4TILE_SQUARE: equ 260
041FA7             0011*  BUF_5TILE_CIRCLE: equ 261
041FA7             0012*  BUF_6TILE_PAD: equ 262
041FA7             0013*  BUF_7TILE_TURRET: equ 263
041FA7             0014*  BUF_CIRCLE: equ 264
041FA7             0015*  BUF_CRATER: equ 265
041FA7             0016*  BUF_EXPLOSION_A: equ 266
041FA7             0017*  BUF_EXPLOSION_B: equ 267
041FA7             0018*  BUF_EXPLOSION_C: equ 268
041FA7             0019*  BUF_EXPLOSION_D: equ 269
041FA7             0020*  BUF_EXPLOSION_E: equ 270
041FA7             0021*  BUF_FIREBALL_A: equ 271
041FA7             0022*  BUF_FIREBALL_B: equ 272
041FA7             0023*  BUF_LASER_A: equ 273
041FA7             0024*  BUF_LASER_B: equ 274
041FA7             0025*  BUF_PAD: equ 275
041FA7             0026*  BUF_SEEKER_000: equ 276
041FA7             0027*  BUF_SEEKER_008: equ 277
041FA7             0028*  BUF_SEEKER_016: equ 278
041FA7             0029*  BUF_SEEKER_024: equ 279
041FA7             0030*  BUF_SEEKER_032: equ 280
041FA7             0031*  BUF_SEEKER_040: equ 281
041FA7             0032*  BUF_SEEKER_048: equ 282
041FA7             0033*  BUF_SEEKER_056: equ 283
041FA7             0034*  BUF_SEEKER_064: equ 284
041FA7             0035*  BUF_SEEKER_072: equ 285
041FA7             0036*  BUF_SEEKER_080: equ 286
041FA7             0037*  BUF_SEEKER_088: equ 287
041FA7             0038*  BUF_SEEKER_096: equ 288
041FA7             0039*  BUF_SEEKER_104: equ 289
041FA7             0040*  BUF_SEEKER_112: equ 290
041FA7             0041*  BUF_SEEKER_120: equ 291
041FA7             0042*  BUF_SEEKER_128: equ 292
041FA7             0043*  BUF_SEEKER_136: equ 293
041FA7             0044*  BUF_SEEKER_144: equ 294
041FA7             0045*  BUF_SEEKER_152: equ 295
041FA7             0046*  BUF_SEEKER_160: equ 296
041FA7             0047*  BUF_SEEKER_168: equ 297
041FA7             0048*  BUF_SEEKER_176: equ 298
041FA7             0049*  BUF_SEEKER_184: equ 299
041FA7             0050*  BUF_SEEKER_192: equ 300
041FA7             0051*  BUF_SEEKER_200: equ 301
041FA7             0052*  BUF_SEEKER_208: equ 302
041FA7             0053*  BUF_SEEKER_216: equ 303
041FA7             0054*  BUF_SEEKER_224: equ 304
041FA7             0055*  BUF_SEEKER_232: equ 305
041FA7             0056*  BUF_SEEKER_240: equ 306
041FA7             0057*  BUF_SEEKER_248: equ 307
041FA7             0058*  BUF_SHIP_0L: equ 308
041FA7             0059*  BUF_SHIP_1C: equ 309
041FA7             0060*  BUF_SHIP_2R: equ 310
041FA7             0061*  BUF_SHIP_SMALL: equ 311
041FA7             0062*  BUF_STAR: equ 312
041FA7             0063*  BUF_TURRET_000: equ 313
041FA7             0064*  BUF_TURRET_008: equ 314
041FA7             0065*  BUF_TURRET_016: equ 315
041FA7             0066*  BUF_TURRET_024: equ 316
041FA7             0067*  BUF_TURRET_032: equ 317
041FA7             0068*  BUF_TURRET_040: equ 318
041FA7             0069*  BUF_TURRET_048: equ 319
041FA7             0070*  BUF_TURRET_056: equ 320
041FA7             0071*  BUF_TURRET_064: equ 321
041FA7             0072*  BUF_TURRET_072: equ 322
041FA7             0073*  BUF_TURRET_080: equ 323
041FA7             0074*  BUF_TURRET_088: equ 324
041FA7             0075*  BUF_TURRET_096: equ 325
041FA7             0076*  BUF_TURRET_104: equ 326
041FA7             0077*  BUF_TURRET_112: equ 327
041FA7             0078*  BUF_TURRET_120: equ 328
041FA7             0079*  BUF_TURRET_128: equ 329
041FA7             0080*  BUF_TURRET_136: equ 330
041FA7             0081*  BUF_TURRET_144: equ 331
041FA7             0082*  BUF_TURRET_152: equ 332
041FA7             0083*  BUF_TURRET_160: equ 333
041FA7             0084*  BUF_TURRET_168: equ 334
041FA7             0085*  BUF_TURRET_176: equ 335
041FA7             0086*  BUF_TURRET_184: equ 336
041FA7             0087*  BUF_TURRET_192: equ 337
041FA7             0088*  BUF_TURRET_200: equ 338
041FA7             0089*  BUF_TURRET_208: equ 339
041FA7             0090*  BUF_TURRET_216: equ 340
041FA7             0091*  BUF_TURRET_224: equ 341
041FA7             0092*  BUF_TURRET_232: equ 342
041FA7             0093*  BUF_TURRET_240: equ 343
041FA7             0094*  BUF_TURRET_248: equ 344
041FA7             0095*  
041FA7             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
041FA7 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       E9 25 04 00 
       01 00       
041FB9 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       03 26 04 01 
       01 00       
041FCB 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       1D 26 04 02 
       01 00       
041FDD 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       37 26 04 03 
       01 00       
041FEF 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       50 26 04 04 
       01 00       
042001 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       6B 26 04 05 
       01 00       
042013 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       86 26 04 06 
       01 00       
042025 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       9E 26 04 07 
       01 00       
042037 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       B9 26 04 08 
       01 00       
042049 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       CE 26 04 09 
       01 00       
04205B 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       E3 26 04 0A 
       01 00       
04206D 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       FD 26 04 0B 
       01 00       
04207F 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       17 27 04 0C 
       01 00       
042091 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       31 27 04 0D 
       01 00       
0420A3 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       4B 27 04 0E 
       01 00       
0420B5 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       65 27 04 0F 
       01 00       
0420C7 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       7E 27 04 10 
       01 00       
0420D9 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       97 27 04 11 
       01 00       
0420EB 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       AD 27 04 12 
       01 00       
0420FD 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       C3 27 04 13 
       01 00       
04210F 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       D5 27 04 14 
       01 00       
042121 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       EE 27 04 15 
       01 00       
042133 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       07 28 04 16 
       01 00       
042145 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       20 28 04 17 
       01 00       
042157 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       39 28 04 18 
       01 00       
042169 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       52 28 04 19 
       01 00       
04217B 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       6B 28 04 1A 
       01 00       
04218D 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       84 28 04 1B 
       01 00       
04219F 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       9D 28 04 1C 
       01 00       
0421B1 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       B6 28 04 1D 
       01 00       
0421C3 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       CF 28 04 1E 
       01 00       
0421D5 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       E8 28 04 1F 
       01 00       
0421E7 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       01 29 04 20 
       01 00       
0421F9 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       1A 29 04 21 
       01 00       
04220B 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       33 29 04 22 
       01 00       
04221D 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       4C 29 04 23 
       01 00       
04222F 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       65 29 04 24 
       01 00       
042241 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       7E 29 04 25 
       01 00       
042253 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       97 29 04 26 
       01 00       
042265 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       B0 29 04 27 
       01 00       
042277 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       C9 29 04 28 
       01 00       
042289 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       E2 29 04 29 
       01 00       
04229B 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       FB 29 04 2A 
       01 00       
0422AD 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       14 2A 04 2B 
       01 00       
0422BF 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       2D 2A 04 2C 
       01 00       
0422D1 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       46 2A 04 2D 
       01 00       
0422E3 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       5F 2A 04 2E 
       01 00       
0422F5 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       78 2A 04 2F 
       01 00       
042307 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       91 2A 04 30 
       01 00       
042319 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       AA 2A 04 31 
       01 00       
04232B 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       C3 2A 04 32 
       01 00       
04233D 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       DC 2A 04 33 
       01 00       
04234F 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       F5 2A 04 34 
       01 00       
042361 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       0B 2B 04 35 
       01 00       
042373 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       21 2B 04 36 
       01 00       
042385 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       37 2B 04 37 
       01 00       
042397 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       50 2B 04 38 
       01 00       
0423A9 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       63 2B 04 39 
       01 00       
0423BB 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       7C 2B 04 3A 
       01 00       
0423CD 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       95 2B 04 3B 
       01 00       
0423DF 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       AE 2B 04 3C 
       01 00       
0423F1 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       C7 2B 04 3D 
       01 00       
042403 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       E0 2B 04 3E 
       01 00       
042415 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       F9 2B 04 3F 
       01 00       
042427 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       12 2C 04 40 
       01 00       
042439 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       2B 2C 04 41 
       01 00       
04244B 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       44 2C 04 42 
       01 00       
04245D 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       5D 2C 04 43 
       01 00       
04246F 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       76 2C 04 44 
       01 00       
042481 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       8F 2C 04 45 
       01 00       
042493 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       A8 2C 04 46 
       01 00       
0424A5 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       C1 2C 04 47 
       01 00       
0424B7 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       DA 2C 04 48 
       01 00       
0424C9 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       F3 2C 04 49 
       01 00       
0424DB 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       0C 2D 04 4A 
       01 00       
0424ED 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       25 2D 04 4B 
       01 00       
0424FF 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       3E 2D 04 4C 
       01 00       
042511 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       57 2D 04 4D 
       01 00       
042523 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       70 2D 04 4E 
       01 00       
042535 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       89 2D 04 4F 
       01 00       
042547 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       A2 2D 04 50 
       01 00       
042559 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       BB 2D 04 51 
       01 00       
04256B 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       D4 2D 04 52 
       01 00       
04257D 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       ED 2D 04 53 
       01 00       
04258F 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       06 2E 04 54 
       01 00       
0425A1 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       1F 2E 04 55 
       01 00       
0425B3 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       38 2E 04 56 
       01 00       
0425C5 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       51 2E 04 57 
       01 00       
0425D7 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       6A 2E 04 58 
       01 00       
0425E9             0186*  
0425E9             0187*  ; files_list: ; filename:
0425E9 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
042603 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
04261D 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
042637 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
042650 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
04266B 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
042686 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
04269E 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
0426B9 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
0426CE 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
0426E3 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
0426FD 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
042717 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
042731 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
04274B 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
042765 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
04277E 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
042797 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
0427AD 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
0427C3 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
0427D5 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0427EE 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
042807 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
042820 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
042839 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
042852 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
04286B 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
042884 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
04289D 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0428B6 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0428CF 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0428E8 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
042901 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
04291A 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
042933 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
04294C 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042965 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04297E 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
042997 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0429B0 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0429C9 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0429E2 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0429FB 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
042A14 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042A2D 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
042A46 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
042A5F 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042A78 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
042A91 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042AAA 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
042AC3 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
042ADC 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
042AF5 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
042B0B 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
042B21 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
042B37 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
042B50 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
042B63 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
042B7C 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
042B95 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
042BAE 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
042BC7 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
042BE0 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
042BF9 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
042C12 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
042C2B 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
042C44 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
042C5D 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
042C76 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
042C8F 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
042CA8 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
042CC1 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
042CDA 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
042CF3 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
042D0C 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
042D25 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
042D3E 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
042D57 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
042D70 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
042D89 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
042DA2 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
042DBB 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
042DD4 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
042DED 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
042E06 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
042E1F 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
042E38 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
042E51 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
042E6A 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
042E83             0050   	include "images_ui.inc"
042E83             0001*  ; Generated by make_images.py
042E83             0002*  
042E83             0003*  ui_num_images: equ 2
042E83             0004*  
042E83             0005*  ; buffer_ids:
042E83             0006*  BUF_SPLASH_BG: equ 0
042E83             0007*  BUF_SPLASH_LOGO: equ 1
042E83             0008*  
042E83             0009*  ui_image_list: ; type; width; height; filename; bufferId:
042E83 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       A7 2E 04 00 
       00 00       
042E95 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       BA 2E 04 01 
       00 00       
042EA7             0012*  
042EA7             0013*  ; files_list: ; filename:
042EA7 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
042EBA 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
042ECF             0051   
042ECF 57 65 6C 63 0052   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
042EEA 4C 6F 61 64 0053   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
042EF5 4C 6F 61 64 0054   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
042F03 50 72 65 73 0055   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
042F1E             0056   
042F1E             0057   init:
042F1E             0058   ; clear all buffers
042F1E CD 66 0A 04 0059       call vdu_clear_all_buffers
042F22             0060   
042F22             0061   ; set up the display
042F22 3E 08       0062       ld a,8 ; 320x240x64 single-buffered
042F24 CD 50 09 04 0063       call vdu_set_screen_mode
042F28 AF          0064       xor a
042F29 CD 61 09 04 0065       call vdu_set_scaling
042F2D             0066   
042F2D             0067   ; start generic stopwatch to time setup loop
042F2D             0068   ; so we can determine if we're running on emulator or hardware
042F2D CD 27 08 04 0069   	call stopwatch_set
042F31             0070   
042F31             0071   ; initialize global timestamp
042F31 DD 27 00    0072       ld hl,(ix+sysvar_time) ; ix was set by stopwatch_start
042F34 22 BC 07 04 0073       ld (timestamp_now),hl
042F38             0074   
042F38             0075   ; enable additional audio channels
042F38 CD 71 0D 04 0076   	call vdu_enable_channels
042F3C             0077   
042F3C             0078   ; set the cursor off
042F3C CD 79 08 04 0079   	call cursor_off
042F40             0080   
042F40             0081   ; set text background color
042F40 3E 84       0082   	ld a,4 + 128
042F42 CD B8 08 04 0083   	call vdu_colour_text
042F46             0084   
042F46             0085   ; set text foreground color
042F46 3E 2F       0086   	ld a,47 ; aaaaff lavenderish
042F48 CD B8 08 04 0087   	call vdu_colour_text
042F4C             0088   
042F4C             0089   ; set gfx bg color
042F4C AF          0090   	xor a ; plotting mode 0
042F4D 0E 84       0091   	ld c,4+128 ; dark blue bg
042F4F CD C9 08 04 0092   	call vdu_gcol
042F53 CD B3 08 04 0093   	call vdu_clg
042F57             0094   
042F57             0095   ; set the cursor off again since we changed screen modes
042F57 CD 79 08 04 0096   	call cursor_off
042F5B             0097   
042F5B             0098   ; VDU 28, left, bottom, right, top: Set text viewport **
042F5B             0099   ; MIND THE LITTLE-ENDIANESS
042F5B             0100   ; inputs: c=left,b=bottom,e=right,d=top
042F5B 0E 00       0101   	ld c,0 ; left
042F5D 16 1D       0102   	ld d,29 ; top
042F5F 1E 27       0103   	ld e,39 ; right
042F61 06 1D       0104   	ld b,29; bottom
042F63 CD E0 08 04 0105   	call vdu_set_txt_viewport
042F67             0106   
042F67             0107   ; print loading ui message
042F67 21 EA 2E 04 0108   	ld hl,loading_ui
042F6B CD 77 00 04 0109   	call printString
042F6F             0110   
042F6F             0111   ; load UI images
042F6F CD B2 1E 04 0112   	call load_ui_images
042F73             0113   
042F73             0114   ; ; load fonts ; TODO
042F73             0115   ; 	call load_font_rc
042F73             0116   
042F73             0117   ; load images
042F73 CD 4E 1F 04 0118   	call img_load_init
042F77             0119   
042F77             0120   ; load sprites
042F77 01 59 00 00 0121   	ld bc,sprites_num_images
042F7B 21 A7 1F 04 0122   	ld hl,sprites_image_list
042F7F 22 A6 1E 04 0123   	ld (cur_image_list),hl
042F83 CD CD 1E 04 0124   	call img_load_main
042F87             0125   
042F87             0126   ; ; load sound effects ; TODO
042F87             0127   ; 	ld bc,SFX_num_buffers
042F87             0128   ; 	ld hl,SFX_buffer_id_lut
042F87             0129   ; 	ld (cur_buffer_id_lut),hl
042F87             0130   ; 	ld hl,SFX_load_routines_table
042F87             0131   ; 	ld (cur_load_jump_table),hl
042F87             0132   ; 	call sfx_load_main
042F87             0133   
042F87             0134   ; print loading complete message and wait for user keypress
042F87 CD A0 08 04 0135   	call vdu_cls
042F8B 21 03 2F 04 0136   	ld hl,loading_complete
042F8F CD 77 00 04 0137   	call printString
042F93 CD A5 08 04 0138   	call vdu_flip
042F97 CD 15 06 04 0139   	call waitKeypress
042F9B             0140   
042F9B             0141   ; initialization done
042F9B C9          0142   	ret
042F9C             0143   
042F9C             0144   main_loop_tmr: ds 6
042FA2             0145   framerate: equ 30
042FA2             0146   
042FA2             0147   new_game:
042FA2             0148   
042FA2 C9          0149   	ret
042FA3             0150   
042FA3             0151   main:
042FA3             0152   
042FA3             0153   
042FA3             0154   main_loop:
042FA3             0155   ; update global timestamp
042FA3 CD C5 07 04 0156       call timestamp_tick
042FA7             0157   
042FA7             0158   ; move player
042FA7             0159   
042FA7             0160   
042FA7             0161   ; move enemies
042FA7             0162   
042FA7             0163   
042FA7             0164   ; render frame
042FA7             0165   
042FA7             0166   @wait:
042FA7 CD 61 1E 04 0167   	call set_keys
042FAB FD 21 9C 2F 0168   	ld iy,main_loop_tmr
       04          
042FB0 CD A8 07 04 0169   	call tmr_get
042FB4 CA C0 2F 04 0170   	jp z,@continue
042FB8 FA C0 2F 04 0171   	jp m,@continue
042FBC C3 A7 2F 04 0172   	jp @wait
042FC0             0173   @continue:
042FC0             0174   
042FC0             0175   ; reset main loop timer
042FC0 FD 21 9C 2F 0176   	ld iy,main_loop_tmr
       04          
042FC5 21 04 00 00 0177   	ld hl,120/framerate
042FC9 CD 9A 07 04 0178   	call tmr_set
042FCD             0179   
042FCD             0180   ; check for escape key and quit if pressed
042FCD             0181   	MOSCALL mos_getkbmap
042FCD 3E 1E       0001M  			LD	A, function
042FCF 49 CF       0002M  			RST.LIS	08h
042FD1             0182   ; 113 Escape
042FD1 DD CB 0E 46 0183       bit 0,(ix+14)
042FD5 20 02       0184   	jr nz,main_end
042FD7             0185   @Escape:
042FD7 18 CA       0186   	jr main_loop
042FD9             0187   
042FD9             0188   main_end:
042FD9             0189   	; call do_outro
042FD9             0190   
042FD9 CD 66 0A 04 0191       call vdu_clear_all_buffers
042FDD CD 99 0D 04 0192   	call vdu_disable_channels
042FE1             0193   
042FE1             0194   ; restore screen to something normalish
042FE1 AF          0195   	xor a
042FE2 CD 50 09 04 0196   	call vdu_set_screen_mode
042FE6 CD 6B 08 04 0197   	call cursor_on
042FEA C9          0198   	ret
