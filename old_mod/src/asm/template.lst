PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.inc
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0005   
040000             0006       MACRO PROGNAME
040000             0007       ASCIZ "flower_demo"
040000             0008       ENDMACRO
040000             0009   
040000 C3 45 00 04 0010       jp start
040004             0011   
040004             0012   _exec_name:
040004             0013   	PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010             0014   
040010 FF FF FF FF 0015       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0016       db "MOS"
040043 00          0017       db 00h
040044 01          0018       db 01h
040045             0019   
040045             0020   start:
040045 F5          0021       push af
040046 C5          0022       push bc
040047 D5          0023       push de
040048 DD E5       0024       push ix
04004A FD E5       0025       push iy
04004C             0026   
04004C CD 42 16 04 0027       call init
040050 CD 43 16 04 0028       call main
040054             0029   
040054             0030   exit:
040054             0031   
040054 FD E1       0032       pop iy
040056 DD E1       0033       pop ix
040058 D1          0034       pop de
040059 C1          0035       pop bc
04005A F1          0036       pop af
04005B 21 00 00 00 0037       ld hl,0
04005F             0038   
04005F C9          0039       ret
040060             0040   
040060             0041   ; --- MAIN PROGRAM ---
040060             0042   ; APPLICATION INCLUDES
040060             0043   ; API includes
040060             0044       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*          LD A, char
040060             0004*          RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*          ld bc,$+7     ; Address of first instruction after the jump
040060             0013*          push bc       ; which constitutes the return address
040060             0014*          jp   (hl)     ; Jump to the address in HL
040060             0015*      ENDMACRO
040060             0016*  
040060             0017*  ; Simulated call to subroutine at IX
040060             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0019*  ; outputs: whatever the subroutine does, including IX and BC
040060             0020*  ; destroys: only what the subroutine does, but always BC
040060             0021*      MACRO callIX
040060             0022*          ld bc,$+7     ; Address of first instruction after the jump
040060             0023*          push bc       ; which constitutes the return address
040060             0024*          jp   (ix)     ; Jump to the address in IX
040060             0025*      ENDMACRO
040060             0026*  
040060             0027*  ; Simulated call to soubroutinte at IY
040060             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0029*  ; outputs: whatever the subroutine does, including IY and BC
040060             0030*  ; destroys: only what the subroutine does, but always BC
040060             0031*      MACRO callIY
040060             0032*          ld bc,$+7     ; Address of first instruction after the jump
040060             0033*          push bc       ; which constitutes the return address
040060             0034*          jp   (iy)     ; Jump to the address in IY
040060             0035*      ENDMACRO
040060             0036*  
040060             0037*  ; put the value in HLU into the accumulator
040060             0038*  ; destroys: af
040060             0039*      MACRO HLU_TO_A
040060             0040*          push hl ; 4 cycles
040060             0041*          inc sp ; 1 cycle
040060             0042*          pop af  ; 4 cycles
040060             0043*          dec sp ; 1 cycle
040060             0044*                 ; 10 cycles total
040060             0045*      ENDMACRO
040060             0046*  
040060             0047*  A_TO_HLU:
040060             0048*      ; call is 7 cycles
040060 22 6D 00 04 0049*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0050*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0051*      ld hl,(@scratch) ; 7 cycles
04006C C9          0052*      ret ; 6 cycles
04006D             0053*          ; 25 cycles total
04006D 00 00 00    0054*  @scratch: dl 0
040070             0055*  
040070             0056*      ; TODO: implement this
040070             0057*      ; MACRO A_TO_HLU
040070             0058*      ;     push.s af
040070             0059*      ;     inc sp
040070             0060*      ;     push.s hl
040070             0061*      ;     pop hl
040070             0062*      ;     inc sp
040070             0063*      ;     inc sp
040070             0064*      ; ENDMACRO
040070             0065*  
040070             0066*      MACRO PUSH_ALL
040070             0067*          ex af,af'
040070             0068*          exx
040070             0069*          push af
040070             0070*          push hl
040070             0071*          push bc
040070             0072*          push de
040070             0073*  
040070             0074*          ex af,af'
040070             0075*          exx
040070             0076*          push af
040070             0077*          push hl
040070             0078*          push bc
040070             0079*          push de
040070             0080*          push ix
040070             0081*          push iy
040070             0082*      ENDMACRO
040070             0083*  
040070             0084*      MACRO POP_ALL
040070             0085*          pop iy
040070             0086*          pop ix
040070             0087*          pop de
040070             0088*          pop bc
040070             0089*          pop hl
040070             0090*          pop af
040070             0091*          ex af,af'
040070             0092*          exx
040070             0093*  
040070             0094*          pop de
040070             0095*          pop bc
040070             0096*          pop hl
040070             0097*          pop af
040070             0098*          ex af,af'
040070             0099*          exx
040070             0100*      ENDMACRO
040070             0101*  
040070             0102*  ; Print a zero-terminated string inline with code, e.g.:
040070             0103*  ;
040070             0104*  ;    call printInline
040070             0105*  ;    ASCIZ "Hello, world!\r\n"
040070             0106*  ;
040070             0107*  ; Destroys: HL,AF
040070             0108*  printInline:
040070 E1          0109*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0110*      call printString ; HL advances to end of string
040075 E5          0111*      push hl ; restore the return address = pointer to end of string
040076 C9          0112*      ret
040077             0113*  
040077             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0115*  ; Print a zero-terminated string
040077             0116*  ; HL: Pointer to string
040077             0117*  printString:
040077 C5          0118*  	PUSH	BC
040078 01 00 00 00 0119*  	LD		BC,0
04007C 3E 00       0120*  	LD 	 	A,0
04007E 5B DF       0121*  	RST.LIL 18h
040080 C1          0122*  	POP		BC
040081 C9          0123*  	RET
040082             0124*  ; print a VDU sequence
040082             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0126*  sendVDUsequence:
040082 C5          0127*  	PUSH	BC
040083 01 00 00 00 0128*  	LD		BC, 0
040087 4E          0129*  	LD		C, (HL)
040088 5B DF       0130*  	RST.LIL	18h
04008A C1          0131*  	POP		BC
04008B C9          0132*  	RET
04008C             0133*  ; Print Newline sequence to VDP
04008C             0134*  printNewLine:
04008C F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0136*  	LD	A, '\r'
04008F 5B D7       0137*  	RST.LIL 10h
040091 3E 0A       0138*  	LD	A, '\n'
040093 5B D7       0139*  	RST.LIL 10h
040095 F1          0140*      pop af
040096 C9          0141*  	RET
040097             0142*  
040097             0143*  ; Print a 24-bit HEX number
040097             0144*  ; HLU: Number to print
040097             0145*  printHex24:
040097             0146*      HLU_TO_A
040097 E5          0001*M         push hl ; 4 cycles
040098 33          0002*M         inc sp ; 1 cycle
040099 F1          0003*M         pop af  ; 4 cycles
04009A 3B          0004*M         dec sp ; 1 cycle
04009B             0005*M                ; 10 cycles total
04009B CD A5 00 04 0147*  	CALL	printHex8
04009F             0148*  ; Print a 16-bit HEX number
04009F             0149*  ; HL: Number to print
04009F             0150*  printHex16:
04009F 7C          0151*  	LD		A,H
0400A0 CD A5 00 04 0152*  	CALL	printHex8
0400A4 7D          0153*  	LD		A,L
0400A5             0154*  ; Print an 8-bit HEX number
0400A5             0155*  ; A: Number to print
0400A5             0156*  printHex8:
0400A5 4F          0157*  	LD		C,A
0400A6 1F          0158*  	RRA
0400A7 1F          0159*  	RRA
0400A8 1F          0160*  	RRA
0400A9 1F          0161*  	RRA
0400AA CD AF 00 04 0162*  	CALL	@F
0400AE 79          0163*  	LD		A,C
0400AF             0164*  @@:
0400AF E6 0F       0165*  	AND		0Fh
0400B1 C6 90       0166*  	ADD		A,90h
0400B3 27          0167*  	DAA
0400B4 CE 40       0168*  	ADC		A,40h
0400B6 27          0169*  	DAA
0400B7 5B D7       0170*  	RST.LIL	10h
0400B9 C9          0171*  	RET
0400BA             0172*  
0400BA             0173*  printHexA:
0400BA F5          0174*      push af
0400BB C5          0175*      push bc
0400BC CD A5 00 04 0176*      call printHex8
0400C0 3E 20       0177*      ld a,' '
0400C2 5B D7       0178*      rst.lil 10h
0400C4 C1          0179*      pop bc
0400C5 F1          0180*      pop af
0400C6 C9          0181*      ret
0400C7             0182*  
0400C7             0183*  printHexHL:
0400C7 F5          0184*      push af
0400C8 C5          0185*      push bc
0400C9 CD 9F 00 04 0186*      call printHex16
0400CD 3E 20       0187*      ld a,' '
0400CF 5B D7       0188*      rst.lil 10h
0400D1 C1          0189*      pop bc
0400D2 F1          0190*      pop af
0400D3 C9          0191*      ret
0400D4             0192*  
0400D4             0193*  printHexUHL:
0400D4 F5          0194*      push af
0400D5 C5          0195*      push bc
0400D6 CD 97 00 04 0196*      call printHex24
0400DA 3E 20       0197*      ld a,' '
0400DC 5B D7       0198*      rst.lil 10h
0400DE C1          0199*      pop bc
0400DF F1          0200*      pop af
0400E0 C9          0201*      ret
0400E1             0202*  
0400E1             0203*  printHexAUHL:
0400E1 F5          0204*      push af
0400E2 C5          0205*      push bc
0400E3 CD A5 00 04 0206*      call printHex8
0400E7 3E 2E       0207*      ld a,'.'
0400E9 5B D7       0208*      rst.lil 10h
0400EB CD 97 00 04 0209*      call printHex24
0400EF 3E 20       0210*      ld a,' '
0400F1 5B D7       0211*      rst.lil 10h
0400F3 C1          0212*      pop bc
0400F4 F1          0213*      pop af
0400F5 C9          0214*      ret
0400F6             0215*  
0400F6             0216*  printHexABHL:
0400F6             0217*  ; preserve registers
0400F6 C5          0218*      push bc ; b will be ok c will not
0400F7 F5          0219*      push af ; will get totally destroyed
0400F8             0220*  ; print a
0400F8 CD A5 00 04 0221*      call printHex8
0400FC             0222*  ; print b
0400FC 78          0223*      ld a,b
0400FD CD A5 00 04 0224*      call printHex8
040101             0225*  ; print hl
040101 CD 9F 00 04 0226*      call printHex16
040105             0227*  ; restore registers
040105 F1          0228*      pop af
040106 C1          0229*      pop bc
040107 C9          0230*      ret
040108             0231*  
040108             0232*  printHexBHL:
040108             0233*  ; preserve registers
040108 C5          0234*      push bc ; b will be ok c will not
040109 F5          0235*      push af ; will get totally destroyed
04010A             0236*  ; print b
04010A 78          0237*      ld a,b
04010B CD A5 00 04 0238*      call printHex8
04010F             0239*  ; print hl
04010F CD 9F 00 04 0240*      call printHex16
040113             0241*  ; restore registers
040113 F1          0242*      pop af
040114 C1          0243*      pop bc
040115 C9          0244*      ret
040116             0245*  
040116             0246*  printHexCDE:
040116             0247*  ; preserve registers
040116 C5          0248*      push bc ; b will be ok c will not
040117 F5          0249*      push af ; will get totally destroyed
040118             0250*  ; print c
040118 79          0251*      ld a,c
040119 CD A5 00 04 0252*      call printHex8
04011D             0253*  ; print de
04011D EB          0254*      ex de,hl
04011E CD 9F 00 04 0255*      call printHex16
040122 EB          0256*      ex de,hl
040123             0257*  ; restore registers
040123 F1          0258*      pop af
040124 C1          0259*      pop bc
040125 C9          0260*      ret
040126             0261*  
040126             0262*  printHexUIX:
040126             0263*  ; store everything in scratch
040126 22 9F 05 04 0264*      ld (uhl),hl
04012A ED 43 A2 05 0265*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0266*      ld (ude),de
       04          
040134 DD 22 A8 05 0267*      ld (uix),ix
       04          
040139 FD 22 AB 05 0268*      ld (uiy),iy
       04          
04013E F5          0269*      push af ; fml
04013F             0270*  
04013F 21 36 05 04 0271*      ld hl,str_ixu
040143 CD 77 00 04 0272*      call printString
040147 2A A8 05 04 0273*      ld hl,(uix)
04014B CD 97 00 04 0274*      call printHex24
04014F CD 8C 00 04 0275*      call printNewLine
040153             0276*  
040153             0277*  ; restore everything
040153 2A 9F 05 04 0278*      ld hl, (uhl)
040157 ED 4B A2 05 0279*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0280*      ld de, (ude)
       04          
040161 DD 2A A8 05 0281*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0282*      ld iy, (uiy)
       04          
04016B F1          0283*      pop af
04016C             0284*  ; all done
04016C C9          0285*      ret
04016D             0286*  
04016D             0287*  ; Print a 0x HEX prefix
04016D             0288*  DisplayHexPrefix:
04016D 3E 30       0289*  	LD	A, '0'
04016F 5B D7       0290*  	RST.LIL 10h
040171 3E 78       0291*  	LD	A, 'x'
040173 5B D7       0292*  	RST.LIL 10h
040175 C9          0293*  	RET
040176             0294*  
040176             0295*      MACRO printDecBC
040176             0296*          push hl
040176             0297*          push bc
040176             0298*          pop hl
040176             0299*          call printDec
040176             0300*          pop hl
040176             0301*      ENDMACRO
040176             0302*  
040176             0303*      MACRO printDecDE
040176             0304*          push hl
040176             0305*          push de
040176             0306*          pop hl
040176             0307*          call printDec
040176             0308*          pop hl
040176             0309*      ENDMACRO
040176             0310*  
040176             0311*      MACRO printDecHL
040176             0312*          call printDec
040176             0313*      ENDMACRO
040176             0314*  
040176             0315*      MACRO printDecIX
040176             0316*          push hl
040176             0317*          push ix
040176             0318*          pop hl
040176             0319*          call printDec
040176             0320*          pop hl
040176             0321*      ENDMACRO
040176             0322*  
040176             0323*      MACRO printDecIY
040176             0324*          push hl
040176             0325*          push iy
040176             0326*          pop hl
040176             0327*          call printDec
040176             0328*          pop hl
040176             0329*      ENDMACRO
040176             0330*  
040176             0331*  
040176             0332*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0333*  ; HL : Value to print
040176             0334*  ; preserves all registers and flags
040176             0335*  printDec:
040176             0336*  ; BEGIN MY CODE
040176             0337*  ; back up all the things
040176 F5          0338*      push af
040177 C5          0339*      push bc
040178 D5          0340*      push de
040179 E5          0341*      push hl
04017A             0342*  ; END MY CODE
04017A 11 A2 01 04 0343*  	LD	 DE, _printDecBuffer
04017E CD B2 01 04 0344*  	CALL u24_to_ascii
040182             0345*  ; BEGIN MY CODE
040182             0346*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0347*      LD	 HL, _printDecBuffer
040186 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040188             0349*  @loop:
040188 7E          0350*      LD	 A, (HL)
040189 FE 30       0351*      CP	 '0'
04018B C2 95 01 04 0352*      JP	 NZ, @done
04018F 3E 20       0353*      LD   A, ' '
040191 77          0354*      LD	 (HL), A
040192 23          0355*      INC	 HL
040193             0356*      ; CALL vdu_cursor_forward
040193 10 F3       0357*      DJNZ @loop
040195             0358*  @done:
040195             0359*  ; END MY CODE
040195 21 A2 01 04 0360*  	LD	 HL, _printDecBuffer
040199 CD 77 00 04 0361*  	CALL printString
04019D             0362*  ; BEGIN MY CODE
04019D             0363*  ; restore all the things
04019D E1          0364*      pop hl
04019E D1          0365*      pop de
04019F C1          0366*      pop bc
0401A0 F1          0367*      pop af
0401A1             0368*  ; END MY CODE
0401A1 C9          0369*  	RET
0401A2 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0371*  
0401B2             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0374*  ; so it will allways be 8 characters length
0401B2             0375*  ; HL : Value to convert to string
0401B2             0376*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0377*  u24_to_ascii:
0401B2 01 80 69 67 0378*  	LD	 BC,-10000000
0401B6 CD E9 01 04 0379*  	CALL @one_digit
0401BA 01 C0 BD F0 0380*  	LD	 BC,-1000000
0401BE CD E9 01 04 0381*  	CALL @one_digit
0401C2 01 60 79 FE 0382*  	LD	 BC,-100000
0401C6 CD E9 01 04 0383*  	CALL @one_digit
0401CA 01 F0 D8 FF 0384*  	LD   BC,-10000
0401CE CD E9 01 04 0385*  	CALL @one_digit
0401D2 01 18 FC FF 0386*  	LD   BC,-1000
0401D6 CD E9 01 04 0387*  	CALL @one_digit
0401DA 01 9C FF FF 0388*  	LD   BC,-100
0401DE CD E9 01 04 0389*  	CALL @one_digit
0401E2 0E F6       0390*  	LD   C,-10
0401E4 CD E9 01 04 0391*  	CALL @one_digit
0401E8 48          0392*  	LD   C,B
0401E9             0393*  @one_digit:
0401E9 3E 2F       0394*  	LD   A,'0'-1
0401EB             0395*  @divide_me:
0401EB 3C          0396*  	INC  A
0401EC 09          0397*  	ADD  HL,BC
0401ED 38 FC       0398*  	JR   C,@divide_me
0401EF ED 42       0399*  	SBC  HL,BC
0401F1 12          0400*  	LD   (DE),A
0401F2 13          0401*  	INC  DE
0401F3 C9          0402*  	RET
0401F4             0403*  
0401F4             0404*  print_u24:
0401F4 D5          0405*      push de
0401F5 E5          0406*      push hl
0401F6 11 A2 01 04 0407*      ld de,_printDecBuffer
0401FA CD B2 01 04 0408*      call u24_to_ascii
0401FE 21 A2 01 04 0409*      ld hl,_printDecBuffer
040202 CD 77 00 04 0410*      call printString
040206 3E 20       0411*      ld a,' '
040208 5B D7       0412*      rst.lil 10h
04020A E1          0413*      pop hl
04020B D1          0414*      pop de
04020C C9          0415*      ret
04020D             0416*  
04020D             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0420*  u168_to_ascii:
04020D             0421*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0422*      ld a,' '
04020F 12          0423*      ld (de),a
040210 13          0424*      inc de
040211             0425*  ; Convert integer part
040211 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
040212 CD DC 0A 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0428*      ld   bc, -10000
04021A CD 3D 02 04 0429*      call @one_int
04021E 01 18 FC FF 0430*      ld   bc, -1000
040222 CD 3D 02 04 0431*      call @one_int
040226 01 9C FF FF 0432*      ld   bc, -100
04022A CD 3D 02 04 0433*      call @one_int
04022E 0E F6       0434*      ld   c, -10
040230 CD 3D 02 04 0435*      call @one_int
040234 48          0436*      ld   c, b
040235 CD 3D 02 04 0437*      call @one_int
040239 C3 48 02 04 0438*      jp   @frac            ; Jump to fractional part conversion
04023D             0439*  @one_int:
04023D 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04023F             0441*  @divide_me:
04023F 3C          0442*      inc  a
040240 09          0443*      add  hl, bc           ; Accumulate until overflow
040241 38 FC       0444*      jr   c, @divide_me
040243 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
040245 12          0446*      ld   (de), a          ; Store ASCII digit
040246 13          0447*      inc  de
040247 C9          0448*      ret
040248             0449*  ; Convert fractional part
040248             0450*  @frac:
040248 3E 2E       0451*      ld   a, '.'           ; Decimal point
04024A 12          0452*      ld   (de), a
04024B 13          0453*      inc  de
04024C E1          0454*      pop  hl               ; Restore HL with original fraction
04024D 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
04024F             0456*  @frac_loop:
04024F 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
040251 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0459*      ld   a, '0'
040255 84          0460*      add  a, h             ; Convert integer part to ASCII
040256 12          0461*      ld   (de), a
040257 13          0462*      inc  de
040258 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
04025A             0464*  ; Add null terminator
04025A AF          0465*      xor  a                ; Null terminator
04025B 12          0466*      ld   (de), a
04025C C9          0467*      ret
04025D             0468*  
04025D             0469*  print_u168:
04025D D5          0470*      push de
04025E E5          0471*      push hl
04025F 11 A2 01 04 0472*      ld de,_printDecBuffer
040263 CD 0D 02 04 0473*      call u168_to_ascii
040267 21 A2 01 04 0474*      ld hl,_printDecBuffer
04026B CD 77 00 04 0475*      call printString
04026F E1          0476*      pop hl
040270 D1          0477*      pop de
040271 C9          0478*      ret
040272             0479*  
040272             0480*  ; signed version of u168_to_ascii
040272             0481*  s168_to_ascii:
040272 D5          0482*      push de ; save starting address of buffer
040273 CD 75 0A 04 0483*      call hlu_abs
040277 F5          0484*      push af ; save sign flag
040278 CD 0D 02 04 0485*      call u168_to_ascii
04027C F1          0486*      pop af ; restore sign flag
04027D D1          0487*      pop de ; restore starting address of buffer
04027E F0          0488*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0489*      ld a,'-'
040281 12          0490*      ld (de),a
040282 C9          0491*      ret
040283             0492*  
040283             0493*  print_s168:
040283 D5          0494*      push de
040284 E5          0495*      push hl
040285 11 A2 01 04 0496*      ld de,_printDecBuffer
040289 CD 72 02 04 0497*      call s168_to_ascii
04028D 21 A2 01 04 0498*      ld hl,_printDecBuffer
040291 CD 77 00 04 0499*      call printString
040295 E1          0500*      pop hl
040296 D1          0501*      pop de
040297 C9          0502*      ret
040298             0503*  
040298             0504*  print_s168_hl:
040298 F5          0505*      push af
040299 E5          0506*      push hl
04029A CD 83 02 04 0507*      call print_s168
04029E 3E 20       0508*      ld a,' '
0402A0 5B D7       0509*      rst.lil 10h
0402A2 E1          0510*      pop hl
0402A3 F1          0511*      pop af
0402A4 C9          0512*      ret
0402A5             0513*  
0402A5             0514*  print_s168_bc:
0402A5 F5          0515*      push af
0402A6 C5          0516*      push bc
0402A7 E5          0517*      push hl
0402A8 C5          0518*      push bc
0402A9 E1          0519*      pop hl
0402AA CD 83 02 04 0520*      call print_s168
0402AE 3E 20       0521*      ld a,' '
0402B0 5B D7       0522*      rst.lil 10h
0402B2 E1          0523*      pop hl
0402B3 C1          0524*      pop bc
0402B4 F1          0525*      pop af
0402B5 C9          0526*      ret
0402B6             0527*  
0402B6             0528*  print_s168_de:
0402B6 F5          0529*      push af
0402B7 D5          0530*      push de
0402B8 E5          0531*      push hl
0402B9 EB          0532*      ex de,hl
0402BA CD 83 02 04 0533*      call print_s168
0402BE 3E 20       0534*      ld a,' '
0402C0 5B D7       0535*      rst.lil 10h
0402C2 E1          0536*      pop hl
0402C3 D1          0537*      pop de
0402C4 F1          0538*      pop af
0402C5 C9          0539*      ret
0402C6             0540*  
0402C6             0541*  print_s168_hl_bc_de:
0402C6 F5          0542*      push af
0402C7 C5          0543*      push bc
0402C8 D5          0544*      push de
0402C9 E5          0545*      push hl
0402CA CD 83 02 04 0546*      call print_s168
0402CE 3E 20       0547*      ld a,' '
0402D0 5B D7       0548*      rst.lil 10h
0402D2 C5          0549*      push bc
0402D3 E1          0550*      pop hl
0402D4 CD 83 02 04 0551*      call print_s168
0402D8 3E 20       0552*      ld a,' '
0402DA 5B D7       0553*      rst.lil 10h
0402DC EB          0554*      ex de,hl
0402DD CD 83 02 04 0555*      call print_s168
0402E1 3E 20       0556*      ld a,' '
0402E3 5B D7       0557*      rst.lil 10h
0402E5 E1          0558*      pop hl
0402E6 D1          0559*      pop de
0402E7 C1          0560*      pop bc
0402E8 F1          0561*      pop af
0402E9 C9          0562*      ret
0402EA             0563*  
0402EA             0564*  print_s168_bc_de:
0402EA F5          0565*      push af
0402EB C5          0566*      push bc
0402EC D5          0567*      push de
0402ED C5          0568*      push bc
0402EE E1          0569*      pop hl
0402EF CD 83 02 04 0570*      call print_s168
0402F3 3E 20       0571*      ld a,' '
0402F5 5B D7       0572*      rst.lil 10h
0402F7 EB          0573*      ex de,hl
0402F8 CD 83 02 04 0574*      call print_s168
0402FC 3E 20       0575*      ld a,' '
0402FE 5B D7       0576*      rst.lil 10h
040300 E1          0577*      pop hl
040301 D1          0578*      pop de
040302 C1          0579*      pop bc
040303 F1          0580*      pop af
040304 C9          0581*      ret
040305             0582*  
040305             0583*  print_s168_a:
040305 F5          0584*      push af
040306 C5          0585*      push bc
040307 E5          0586*      push hl
040308 21 00 00 00 0587*      ld hl,0
04030C 6F          0588*      ld l,a
04030D CD 98 02 04 0589*      call print_s168_hl
040311 E1          0590*      pop hl
040312 C1          0591*      pop bc
040313 F1          0592*      pop af
040314 C9          0593*      ret
040315             0594*  
040315             0595*  ; #### new functions added by Brandon R. Gates ####
040315             0596*  
040315             0597*  ; print the binary representation of the 8-bit value in a
040315             0598*  ; destroys a, hl, bc
040315             0599*  printBin8:
040315 06 08       0600*      ld b,8      ; loop counter for 8 bits
040317 21 32 03 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
04031B             0602*                  ; (which will be the high bit of the value in a)
04031B             0603*  @loop:
04031B 07          0604*      rlca ; put the next highest bit into carry
04031C 38 04       0605*      jr c,@one
04031E 36 30       0606*      ld (hl),'0'
040320 18 02       0607*      jr @next_bit
040322             0608*  @one:
040322 36 31       0609*      ld (hl),'1'
040324             0610*  @next_bit:
040324 23          0611*      inc hl
040325 10 F4       0612*      djnz @loop
040327             0613*  ; print it
040327 21 32 03 04 0614*  	ld hl,@cmd
04032B 01 08 00 00 0615*  	ld bc,@end-@cmd
04032F 5B DF       0616*  	rst.lil $18
040331 C9          0617*  	ret
040332             0618*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0619*  @end:
04033A             0620*  
04033A             0621*  ; print the binary representation of the 8-bit value in a
04033A             0622*  ; in reverse order (lsb first)
04033A             0623*  ; destroys a, hl, bc
04033A             0624*  printBin8Rev:
04033A 06 08       0625*      ld b,8      ; loop counter for 8 bits
04033C 21 57 03 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
040340             0627*                  ; (which will be the high bit of the value in a)
040340             0628*  @loop:
040340 0F          0629*      rrca ; put the next lowest bit into carry
040341 38 04       0630*      jr c,@one
040343 36 30       0631*      ld (hl),'0'
040345 18 02       0632*      jr @next_bit
040347             0633*  @one:
040347 36 31       0634*      ld (hl),'1'
040349             0635*  @next_bit:
040349 23          0636*      inc hl
04034A 10 F4       0637*      djnz @loop
04034C             0638*  ; print it
04034C 21 57 03 04 0639*  	ld hl,@cmd
040350 01 08 00 00 0640*  	ld bc,@end-@cmd
040354 5B DF       0641*  	rst.lil $18
040356 C9          0642*  	ret
040357             0643*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0644*  @end:
04035F             0645*  
04035F             0646*  ; print registers to screen in hexidecimal format
04035F             0647*  ; inputs: none
04035F             0648*  ; outputs: values of every register printed to screen
04035F             0649*  ;    values of each register in global scratch memory
04035F             0650*  ; destroys: nothing
04035F             0651*  stepRegistersHex:
04035F             0652*  ; store everything in scratch
04035F 22 9F 05 04 0653*      ld (uhl),hl
040363 ED 43 A2 05 0654*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0655*      ld (ude),de
       04          
04036D DD 22 A8 05 0656*      ld (uix),ix
       04          
040372 FD 22 AB 05 0657*      ld (uiy),iy
       04          
040377 F5          0658*      push af ; fml
040378 E1          0659*      pop hl  ; thanks, zilog
040379 22 9C 05 04 0660*      ld (uaf),hl
04037D F5          0661*      push af ; dammit
04037E             0662*  
04037E             0663*  ; home the cursor
04037E             0664*      ; call vdu_home_cursor
04037E             0665*  
04037E             0666*  ; print each register
04037E 21 22 05 04 0667*      ld hl,str_afu
040382 CD 77 00 04 0668*      call printString
040386 2A 9C 05 04 0669*      ld hl,(uaf)
04038A CD 97 00 04 0670*      call printHex24
04038E CD 8C 00 04 0671*      call printNewLine
040392             0672*  
040392 21 27 05 04 0673*      ld hl,str_hlu
040396 CD 77 00 04 0674*      call printString
04039A 2A 9F 05 04 0675*      ld hl,(uhl)
04039E CD 97 00 04 0676*      call printHex24
0403A2 CD 8C 00 04 0677*      call printNewLine
0403A6             0678*  
0403A6 21 2C 05 04 0679*      ld hl,str_bcu
0403AA CD 77 00 04 0680*      call printString
0403AE 2A A2 05 04 0681*      ld hl,(ubc)
0403B2 CD 97 00 04 0682*      call printHex24
0403B6 CD 8C 00 04 0683*      call printNewLine
0403BA             0684*  
0403BA 21 31 05 04 0685*      ld hl,str_deu
0403BE CD 77 00 04 0686*      call printString
0403C2 2A A5 05 04 0687*      ld hl,(ude)
0403C6 CD 97 00 04 0688*      call printHex24
0403CA CD 8C 00 04 0689*      call printNewLine
0403CE             0690*  
0403CE 21 36 05 04 0691*      ld hl,str_ixu
0403D2 CD 77 00 04 0692*      call printString
0403D6 2A A8 05 04 0693*      ld hl,(uix)
0403DA CD 97 00 04 0694*      call printHex24
0403DE CD 8C 00 04 0695*      call printNewLine
0403E2             0696*  
0403E2 21 3B 05 04 0697*      ld hl,str_iyu
0403E6 CD 77 00 04 0698*      call printString
0403EA 2A AB 05 04 0699*      ld hl,(uiy)
0403EE CD 97 00 04 0700*      call printHex24
0403F2 CD 8C 00 04 0701*      call printNewLine
0403F6             0702*  
0403F6             0703*      ; call vsync
0403F6             0704*  
0403F6 CD 8C 00 04 0705*      call printNewLine
0403FA             0706*  
0403FA             0707*  ; check for right shift key and quit if pressed
0403FA             0708*  	MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0709*  @stayhere:
0403FE             0710*  ; 7 RightShift
0403FE DD CB 00 76 0711*      bit 6,(ix+0)
040402 20 02       0712*      jr nz,@RightShift
040404 18 F8       0713*      jr @stayhere
040406             0714*  @RightShift:
040406 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0716*      ld a,%10000000
04040C             0717*      ; call multiPurposeDelay
04040C             0718*  
04040C             0719*  ; restore everything
04040C 2A 9F 05 04 0720*      ld hl, (uhl)
040410 ED 4B A2 05 0721*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0722*      ld de, (ude)
       04          
04041A DD 2A A8 05 0723*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0724*      ld iy, (uiy)
       04          
040424 F1          0725*      pop af
040425             0726*  ; all done
040425 C9          0727*      ret
040426             0728*  
040426             0729*  ; print registers to screen in hexidecimal format
040426             0730*  ; inputs: none
040426             0731*  ; outputs: values of every register printed to screen
040426             0732*  ;    values of each register in global scratch memory
040426             0733*  ; destroys: nothing
040426             0734*  dumpRegistersHex:
040426             0735*  ; store everything in scratch
040426 22 9F 05 04 0736*      ld (uhl),hl
04042A ED 43 A2 05 0737*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0738*      ld (ude),de
       04          
040434 DD 22 A8 05 0739*      ld (uix),ix
       04          
040439 FD 22 AB 05 0740*      ld (uiy),iy
       04          
04043E F5          0741*      push af ; fml
04043F E1          0742*      pop hl  ; thanks, zilog
040440 22 9C 05 04 0743*      ld (uaf),hl
040444 F5          0744*      push af ; dammit
040445             0745*  
040445             0746*  ; home the cursor
040445             0747*      ; call vdu_home_cursor
040445             0748*      ; call printNewLine
040445             0749*  
040445             0750*  ; print each register
040445 21 22 05 04 0751*      ld hl,str_afu
040449 CD 77 00 04 0752*      call printString
04044D 2A 9C 05 04 0753*      ld hl,(uaf)
040451 CD 97 00 04 0754*      call printHex24
040455             0755*      ; call printNewLine
040455             0756*  
040455 21 27 05 04 0757*      ld hl,str_hlu
040459 CD 77 00 04 0758*      call printString
04045D 2A 9F 05 04 0759*      ld hl,(uhl)
040461 CD 97 00 04 0760*      call printHex24
040465             0761*      ; call printNewLine
040465             0762*  
040465 21 2C 05 04 0763*      ld hl,str_bcu
040469 CD 77 00 04 0764*      call printString
04046D 2A A2 05 04 0765*      ld hl,(ubc)
040471 CD 97 00 04 0766*      call printHex24
040475             0767*      ; call printNewLine
040475             0768*  
040475 21 31 05 04 0769*      ld hl,str_deu
040479 CD 77 00 04 0770*      call printString
04047D 2A A5 05 04 0771*      ld hl,(ude)
040481 CD 97 00 04 0772*      call printHex24
040485             0773*      ; call printNewLine
040485             0774*  
040485 21 36 05 04 0775*      ld hl,str_ixu
040489 CD 77 00 04 0776*      call printString
04048D 2A A8 05 04 0777*      ld hl,(uix)
040491 CD 97 00 04 0778*      call printHex24
040495             0779*      ; call printNewLine
040495             0780*  
040495 21 3B 05 04 0781*      ld hl,str_iyu
040499 CD 77 00 04 0782*      call printString
04049D 2A AB 05 04 0783*      ld hl,(uiy)
0404A1 CD 97 00 04 0784*      call printHex24
0404A5             0785*      ; call printNewLine
0404A5             0786*  
0404A5             0787*      ; call vdu_vblank
0404A5             0788*  
0404A5 CD 8C 00 04 0789*      call printNewLine
0404A9             0790*  ; restore everything
0404A9 2A 9F 05 04 0791*      ld hl, (uhl)
0404AD ED 4B A2 05 0792*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0793*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0794*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0795*      ld iy, (uiy)
       04          
0404C1 F1          0796*      pop af
0404C2             0797*  ; all done
0404C2 C9          0798*      ret
0404C3             0799*  
0404C3             0800*  dumpRegistersHexPrime:
0404C3 D9          0801*      exx
0404C4 08          0802*      ex af,af'
0404C5 CD 26 04 04 0803*      call dumpRegistersHex
0404C9 08          0804*      ex af,af'
0404CA D9          0805*      exx
0404CB C9          0806*      ret
0404CC             0807*  
0404CC             0808*  ; additionally dump prime registers
0404CC             0809*  ; inputs: none
0404CC             0810*  ; outputs: values of every register printed to screen
0404CC             0811*  ; destroys: nothing
0404CC             0812*  dumpRegistersHexAll:
0404CC CD 26 04 04 0813*      call dumpRegistersHex
0404D0 08          0814*      ex af,af'
0404D1 D9          0815*      exx
0404D2 CD 26 04 04 0816*      call dumpRegistersHex
0404D6 08          0817*      ex af,af'
0404D7 D9          0818*      exx
0404D8 C9          0819*      ret
0404D9             0820*  
0404D9             0821*  ; print hlu to screen in hexidecimal format
0404D9             0822*  ; inputs: none
0404D9             0823*  ; destroys: nothing
0404D9             0824*  print_hex_hl:
0404D9 F5          0825*      push af
0404DA E5          0826*      push hl
0404DB 21 27 05 04 0827*      ld hl,str_hlu
0404DF CD 77 00 04 0828*      call printString
0404E3 E1          0829*      pop hl
0404E4 E5          0830*      push hl
0404E5 CD 97 00 04 0831*      call printHex24
0404E9 3E 20       0832*      ld a,' '
0404EB 5B D7       0833*      rst.lil 10h
0404ED E1          0834*      pop hl
0404EE F1          0835*      pop af
0404EF C9          0836*      ret
0404F0             0837*  
0404F0             0838*  ; print bcu to screen in hexidecimal format
0404F0             0839*  ; inputs: none
0404F0             0840*  ; destroys: nothing
0404F0             0841*  print_hex_bc:
0404F0 F5          0842*      push af
0404F1 E5          0843*      push hl
0404F2 C5          0844*      push bc
0404F3 21 2C 05 04 0845*      ld hl,str_bcu
0404F7 CD 77 00 04 0846*      call printString
0404FB E1          0847*      pop hl
0404FC E5          0848*      push hl
0404FD CD 97 00 04 0849*      call printHex24
040501 3E 20       0850*      ld a,' '
040503 5B D7       0851*      rst.lil 10h
040505 C1          0852*      pop bc
040506 E1          0853*      pop hl
040507 F1          0854*      pop af
040508 C9          0855*      ret
040509             0856*  
040509             0857*  ; print deu to screen in hexidecimal format
040509             0858*  ; inputs: none
040509             0859*  ; destroys: nothing
040509             0860*  print_hex_de:
040509 F5          0861*      push af
04050A E5          0862*      push hl
04050B D5          0863*      push de
04050C 21 31 05 04 0864*      ld hl,str_deu
040510 CD 77 00 04 0865*      call printString
040514 E1          0866*      pop hl
040515 E5          0867*      push hl
040516 CD 97 00 04 0868*      call printHex24
04051A 3E 20       0869*      ld a,' '
04051C 5B D7       0870*      rst.lil 10h
04051E D1          0871*      pop de
04051F E1          0872*      pop hl
040520 F1          0873*      pop af
040521 C9          0874*      ret
040522             0875*  
040522 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
040540             0882*  
040540             0883*  ; print udeuhl to screen in hexidecimal format
040540             0884*  ; inputs: none
040540             0885*  ; outputs: concatenated hexidecimal udeuhl
040540             0886*  ; destroys: nothing
040540             0887*  dumpUDEUHLHex:
040540             0888*  ; store everything in scratch
040540 22 9F 05 04 0889*      ld (uhl),hl
040544 ED 43 A2 05 0890*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0891*      ld (ude),de
       04          
04054E DD 22 A8 05 0892*      ld (uix),ix
       04          
040553 FD 22 AB 05 0893*      ld (uiy),iy
       04          
040558 F5          0894*      push af
040559             0895*  
040559             0896*  ; print each register
040559             0897*  
040559 21 93 05 04 0898*      ld hl,str_udeuhl
04055D CD 77 00 04 0899*      call printString
040561 2A A5 05 04 0900*      ld hl,(ude)
040565 CD 97 00 04 0901*      call printHex24
040569 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
04056B 5B D7       0903*  	rst.lil 10h
04056D 2A 9F 05 04 0904*      ld hl,(uhl)
040571 CD 97 00 04 0905*      call printHex24
040575 CD 8C 00 04 0906*      call printNewLine
040579             0907*  
040579             0908*  ; restore everything
040579 2A 9F 05 04 0909*      ld hl, (uhl)
04057D ED 4B A2 05 0910*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0911*      ld de, (ude)
       04          
040587 DD 2A A8 05 0912*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0913*      ld iy, (uiy)
       04          
040591 F1          0914*      pop af
040592             0915*  ; all done
040592 C9          0916*      ret
040593             0917*  
040593 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0919*  
04059C             0920*  ; global scratch memory for registers
04059C 00 00 00    0921*  uaf: dl 0
04059F 00 00 00    0922*  uhl: dl 0
0405A2 00 00 00    0923*  ubc: dl 0
0405A5 00 00 00    0924*  ude: dl 0
0405A8 00 00 00    0925*  uix: dl 0
0405AB 00 00 00    0926*  uiy: dl 0
0405AE 00 00 00    0927*  usp: dl 0
0405B1 00 00 00    0928*  upc: dl 0
0405B4             0929*  
0405B4             0930*  ; inputs: whatever is in the flags register
0405B4             0931*  ; outputs: binary representation of flags
0405B4             0932*  ;          with a header so we know which is what
0405B4             0933*  ; destroys: nothing
0405B4             0934*  ; preserves: everything
0405B4             0935*  dumpFlags:
0405B4             0936*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0937*      push af ; this is so we can send it back unharmed
0405B5 F5          0938*      push af ; this is so we can pop it to hl
0405B6             0939*  ; store everything in scratch
0405B6 22 9F 05 04 0940*      ld (uhl),hl
0405BA ED 43 A2 05 0941*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0942*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0943*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0944*      ld (uiy),iy
       04          
0405CE             0945*  ; next we print the header
0405CE 21 FA 05 04 0946*      ld hl,@header
0405D2 CD 77 00 04 0947*      call printString
0405D6 E1          0948*      pop hl ; flags are now in l
0405D7 7D          0949*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0950*      call printBin8
0405DC CD 8C 00 04 0951*  	call printNewLine
0405E0             0952*  ; restore everything
0405E0 2A 9F 05 04 0953*      ld hl, (uhl)
0405E4 ED 4B A2 05 0954*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0955*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0956*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0957*      ld iy, (uiy)
       04          
0405F8 F1          0958*      pop af ; send her home the way she came
0405F9 C9          0959*      ret
0405FA             0960*  ; Bit 7 (S): Sign flag
0405FA             0961*  ; Bit 6 (Z): Zero flag
0405FA             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0963*  ; Bit 4 (H): Half Carry flag
0405FA             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0965*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0966*  ; Bit 1 (N): Subtract flag
0405FA             0967*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0969*  
040605             0970*  ; set all the bits in the flag register
040605             0971*  ; more of an academic exercise than anything useful
040605             0972*  ; inputs; none
040605             0973*  ; outputs; a=0,f=255
040605             0974*  ; destroys: flags, hl
040605             0975*  ; preserves: a, because why not
040605             0976*  setAllFlags:
040605 21 FF 00 00 0977*      ld hl,255
040609 67          0978*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0979*      push hl
04060B F1          0980*      pop af
04060C C9          0981*      ret
04060D             0982*  
04060D             0983*  ; reset all the bits in the flag register
04060D             0984*  ; unlike its inverse counterpart, this may actually be useful
04060D             0985*  ; inputs; none
04060D             0986*  ; outputs; a=0,f=0
04060D             0987*  ; destroys: flags, hl
04060D             0988*  ; preserves: a, because why not
04060D             0989*  resetAllFlags:
04060D 21 00 00 00 0990*      ld hl,0
040611 67          0991*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0992*      push hl
040613 F1          0993*      pop af
040614 C9          0994*      ret
040615             0995*  
040615             0996*  ; wait until user presses a key
040615             0997*  ; inputs: none
040615             0998*  ; outputs: ascii code of key pressed in a
040615             0999*  ; destroys: af,ix
040615             1000*  waitKeypress:
040615             1001*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1002*      ret
04061A             1003*  
04061A             1004*  ; print bytes from an address to the screen in hexidecimal format
04061A             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1006*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1007*  ; destroys: nothing
04061A             1008*  dumpMemoryHex:
04061A             1009*  ; save registers to the stack
04061A C5          1010*      push bc
04061B E5          1011*      push hl
04061C F5          1012*      push af
04061D             1013*  
04061D             1014*  ; print the address and separator
04061D CD 97 00 04 1015*      call printHex24
040621 3E 3A       1016*      ld a,':'
040623 5B D7       1017*      rst.lil 10h
040625 3E 20       1018*      ld a,' '
040627 5B D7       1019*      rst.lil 10h
040629             1020*  
040629             1021*  ; set b to be our loop counter
040629 F1          1022*      pop af
04062A 47          1023*      ld b,a
04062B E1          1024*      pop hl
04062C E5          1025*      push hl
04062D F5          1026*      push af
04062E             1027*  @loop:
04062E             1028*  ; print the byte
04062E 7E          1029*      ld a,(hl)
04062F CD A5 00 04 1030*      call printHex8
040633             1031*  ; print a space
040633 3E 20       1032*      ld a,' '
040635 5B D7       1033*      rst.lil 10h
040637 23          1034*      inc hl
040638 10 F4       1035*      djnz @loop
04063A CD 8C 00 04 1036*      call printNewLine
04063E             1037*  
04063E             1038*  ; restore everything
04063E F1          1039*      pop af
04063F E1          1040*      pop hl
040640 C1          1041*      pop bc
040641             1042*  
040641             1043*  ; all done
040641 C9          1044*      ret
040642             1045*  
040642             1046*  
040642             1047*  ; print bytes from an address to the screen in binary format
040642             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1049*  ; outputs: values of each byte printed to screen separated by spaces
040642             1050*  ; destroys: nothing
040642             1051*  dumpMemoryBin:
040642             1052*  ; save all registers to the stack
040642 F5          1053*      push af
040643 C5          1054*      push bc
040644 D5          1055*      push de
040645 E5          1056*      push hl
040646 DD E5       1057*      push ix
040648 FD E5       1058*      push iy
04064A             1059*  
04064A             1060*  ; set b to be our loop counter
04064A 47          1061*      ld b,a
04064B             1062*  @loop:
04064B             1063*  ; print the byte
04064B 7E          1064*      ld a,(hl)
04064C E5          1065*      push hl
04064D C5          1066*      push bc
04064E CD 15 03 04 1067*      call printBin8
040652 C1          1068*      pop bc
040653             1069*  ; print a space
040653 3E 20       1070*      ld a,' '
040655 5B D7       1071*      rst.lil 10h
040657 E1          1072*      pop hl
040658 23          1073*      inc hl
040659 10 F0       1074*      djnz @loop
04065B CD 8C 00 04 1075*      call printNewLine
04065F             1076*  
04065F             1077*  ; restore everything
04065F FD E1       1078*      pop iy
040661 DD E1       1079*      pop ix
040663 E1          1080*      pop hl
040664 D1          1081*      pop de
040665 C1          1082*      pop bc
040666 F1          1083*      pop af
040667             1084*  ; all done
040667 C9          1085*      ret
040668             1086*  
040668             1087*  ; print bytes from an address to the screen in binary format
040668             1088*  ; with the bits of each byte in reverse order (lsb first)
040668             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1090*  ; outputs: values of each byte printed to screen separated by spaces
040668             1091*  ; destroys: nothing
040668             1092*  dumpMemoryBinRev:
040668             1093*  ; save all registers to the stack
040668 F5          1094*      push af
040669 C5          1095*      push bc
04066A D5          1096*      push de
04066B E5          1097*      push hl
04066C DD E5       1098*      push ix
04066E FD E5       1099*      push iy
040670             1100*  
040670             1101*  ; set b to be our loop counter
040670 47          1102*      ld b,a
040671             1103*  @loop:
040671             1104*  ; print the byte
040671 7E          1105*      ld a,(hl)
040672 E5          1106*      push hl
040673 C5          1107*      push bc
040674 CD 3A 03 04 1108*      call printBin8Rev
040678 C1          1109*      pop bc
040679             1110*  ; print a space
040679 3E 20       1111*      ld a,' '
04067B 5B D7       1112*      rst.lil 10h
04067D E1          1113*      pop hl
04067E 23          1114*      inc hl
04067F 10 F0       1115*      djnz @loop
040681 CD 8C 00 04 1116*      call printNewLine
040685             1117*  
040685             1118*  ; restore everything
040685 FD E1       1119*      pop iy
040687 DD E1       1120*      pop ix
040689 E1          1121*      pop hl
04068A D1          1122*      pop de
04068B C1          1123*      pop bc
04068C F1          1124*      pop af
04068D             1125*  ; all done
04068D C9          1126*      ret
04068E             0045       include "vdu.inc"
04068E             0001*  
04068E             0002*  ; VDU 30: Home cursor
04068E             0003*  vdu_home_cursor:
04068E 3E 1E       0004*      ld a,30
040690 5B D7       0005*  	rst.lil $10
040692 C9          0006*  	ret
040693             0007*  
040693             0008*  vdu_cursor_on:
040693 21 9E 06 04 0009*  	ld hl,@cmd
040697 01 03 00 00 0010*  	ld bc,@end-@cmd
04069B 5B DF       0011*  	rst.lil $18
04069D C9          0012*  	ret
04069E             0013*  @cmd:
04069E 17 01 01    0014*  	db 23,1,1
0406A1             0015*  @end:
0406A1             0016*  
0406A1             0017*  vdu_cursor_off:
0406A1 21 AC 06 04 0018*  	ld hl,@cmd
0406A5 01 03 00 00 0019*  	ld bc,@end-@cmd
0406A9 5B DF       0020*  	rst.lil $18
0406AB C9          0021*  	ret
0406AC             0022*  @cmd:
0406AC 17 01 00    0023*  	db 23,1,0
0406AF             0024*  @end:
0406AF             0025*  
0406AF             0026*  ; VDU 5: Write text at graphics cursor
0406AF             0027*  ; inputs: a is the character to write to the screen
0406AF             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0406AF             0029*  ; outputs: see the name of the function
0406AF             0030*  ; destroys: a, hl, bc
0406AF             0031*  vdu_char_to_gfx_cursor:
0406AF 32 BF 06 04 0032*  	ld (@arg),a
0406B3 21 BE 06 04 0033*  	ld hl,@cmd
0406B7 01 02 00 00 0034*  	ld bc,@end-@cmd
0406BB 5B DF       0035*  	rst.lil $18
0406BD C9          0036*  	ret
0406BE 05          0037*  @cmd: db 5
0406BF 00          0038*  @arg: db 0
0406C0             0039*  @end:
0406C0             0040*  ; VDU 9: Move cursor forward one character
0406C0             0041*  vdu_cursor_forward:
0406C0 3E 09       0042*      ld a,9
0406C2 5B D7       0043*  	rst.lil $10
0406C4 C9          0044*  	ret
0406C5             0045*  
0406C5             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0406C5             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0406C5             0048*  vdu_move_cursor:
0406C5 ED 43 D6 06 0049*      ld (@x0),bc
       04          
0406CA 21 D5 06 04 0050*  	ld hl,@cmd
0406CE 01 03 00 00 0051*  	ld bc,@end-@cmd
0406D2 5B DF       0052*  	rst.lil $18
0406D4 C9          0053*  	ret
0406D5 1F          0054*  @cmd: 	db 31
0406D6 00          0055*  @x0:	db 0
0406D7 00          0056*  @y0: 	db 0
0406D8 00          0057*  @end: 	db 0 ; padding
0406D9             0058*  
0406D9             0059*  ; VDU 12: Clear text area (CLS)
0406D9             0060*  vdu_cls:
0406D9 3E 0C       0061*      ld a,12
0406DB 5B D7       0062*  	rst.lil $10
0406DD C9          0063*  	ret
0406DE             0064*  
0406DE             0065*  vdu_flip:
0406DE 21 E9 06 04 0066*  	ld hl,@cmd
0406E2 01 03 00 00 0067*  	ld bc,@end-@cmd
0406E6 5B DF       0068*  	rst.lil $18
0406E8 C9          0069*  	ret
0406E9 17 00 C3    0070*  @cmd: db 23,0,0xC3
0406EC             0071*  @end:
0406EC             0072*  
0406EC             0073*  ; VDU 16: Clear graphics area (CLG)
0406EC             0074*  vdu_clg:
0406EC 3E 10       0075*      ld a,16
0406EE 5B D7       0076*  	rst.lil $10
0406F0 C9          0077*  	ret
0406F1             0078*  
0406F1             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0406F1             0080*  ; VDU 23, 7: Scrolling
0406F1             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0406F1             0082*  ; inputs: a, extent; l, direction; h; speed
0406F1             0083*  vdu_scroll_down:
0406F1 32 06 07 04 0084*  	ld (@extent),a
0406F5 22 07 07 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0406F9 21 04 07 04 0086*  	ld hl,@cmd
0406FD 01 05 00 00 0087*  	ld bc,@end-@cmd
040701 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
040703 C9          0089*  	ret
040704 17 07       0090*  @cmd:       db 23,7
040706 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
040707 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
040708 00          0093*  @speed:     db 0x00 ; pixels
040709 00          0094*  @end:		db 0x00 ; padding
04070A             0095*  
04070A             0096*  ; COLOUR MODES
04070A             0097*  ; Mode	Effect
04070A             0098*  ; 0	Set on-screen pixel to target colour value
04070A             0099*  ; 1	OR value with the on-screen pixel
04070A             0100*  ; 2	AND value with the on-screen pixel
04070A             0101*  ; 3	XOR value with the on-screen pixel
04070A             0102*  ; 4	Invert the on-screen pixel
04070A             0103*  ; 5	No operation
04070A             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
04070A             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
04070A             0106*  
04070A             0107*  ; VDU 17, colour: Define text colour (COLOUR)
04070A             0108*  vdu_colour_text:
04070A 32 1A 07 04 0109*  	ld (@arg),a
04070E 21 19 07 04 0110*  	ld hl,@cmd
040712 01 02 00 00 0111*  	ld bc,@end-@cmd
040716 5B DF       0112*  	rst.lil $18
040718 C9          0113*  	ret
040719 11          0114*  @cmd: db 17
04071A 00          0115*  @arg: db 0
04071B             0116*  @end:
04071B             0117*  
04071B             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04071B             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04071B             0120*  vdu_gcol:
04071B 32 30 07 04 0121*  	ld (@mode),a
04071F 79          0122*      ld a,c
040720 32 31 07 04 0123*      ld (@col),a
040724 21 2F 07 04 0124*  	ld hl,@cmd
040728 01 03 00 00 0125*  	ld bc,@end-@cmd
04072C 5B DF       0126*  	rst.lil $18
04072E C9          0127*  	ret
04072F 12          0128*  @cmd:  db 18
040730 00          0129*  @mode: db 0
040731 00          0130*  @col:  db 0
040732             0131*  @end:
040732             0132*  
040732             0133*  
040732             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
040732             0135*  ; MIND THE LITTLE-ENDIANESS
040732             0136*  ; inputs: c=left,b=bottom,e=right,d=top
040732             0137*  ; outputs; nothing
040732             0138*  ; destroys: a might make it out alive
040732             0139*  vdu_set_txt_viewport:
040732 ED 43 48 07 0140*      ld (@lb),bc
       04          
040737 ED 53 4A 07 0141*  	ld (@rt),de
       04          
04073C 21 47 07 04 0142*  	ld hl,@cmd
040740 01 05 00 00 0143*  	ld bc,@end-@cmd
040744 5B DF       0144*  	rst.lil $18
040746 C9          0145*  	ret
040747 1C          0146*  @cmd:   db 28 ; set text viewport command
040748 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
04074A 00 00       0148*  @rt: 	dw 0x0000 ; set by de
04074C 00          0149*  @end:   db 0x00	  ; padding
04074D             0150*  
04074D             0151*  ; Wait for VBLANK interrupt
04074D             0152*  vdu_vblank:
04074D DD E5       0153*      PUSH 	IX
04074F             0154*  	MOSCALL	mos_sysvars
04074F 3E 08       0001*M 			LD	A, function
040751 5B CF       0002*M 			RST.LIL	08h
040753 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
040756             0156*  @wait:
040756 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
040759 28 FB       0158*      JR	Z, @wait
04075B DD E1       0159*      POP	IX
04075D C9          0160*      RET
04075E             0161*  
04075E             0162*  ; VDU 29, x; y;: Set graphics origin
04075E             0163*  ; This command sets the graphics origin.
04075E             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04075E             0165*  ; inputs: bc=x0,de=y0
04075E             0166*  ; outputs; nothing
04075E             0167*  ; destroys: a might make it out alive
04075E             0168*  vdu_set_gfx_origin:
04075E ED 43 74 07 0169*      ld (@x0),bc
       04          
040763 ED 53 76 07 0170*      ld (@y0),de
       04          
040768 21 73 07 04 0171*      ld hl,@cmd
04076C 01 05 00 00 0172*      ld bc,@end-@cmd
040770 5B DF       0173*      rst.lil $18
040772 C9          0174*      ret
040773 1D          0175*  @cmd:   db 29 ; set graphics origin command
040774 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
040776 00 00       0177*  @y0: 	dw 0x0000 ; set by de
040778 00          0178*  @end:   db 0x00	  ; padding
040779             0179*  
040779             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040779             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
040779             0182*  ; 	because we have turned off logical screen scaling
040779             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040779             0184*  ; outputs; nothing
040779             0185*  ; destroys: a might make it out alive
040779             0186*  vdu_set_gfx_viewport:
040779 ED 43 99 07 0187*      ld (@x0),bc
       04          
04077E FD 22 9B 07 0188*      ld (@y1),iy
       04          
040783 DD 22 9D 07 0189*  	ld (@x1),ix
       04          
040788 ED 53 9F 07 0190*  	ld (@y0),de
       04          
04078D 21 98 07 04 0191*  	ld hl,@cmd
040791 01 09 00 00 0192*  	ld bc,@end-@cmd
040795 5B DF       0193*  	rst.lil $18
040797 C9          0194*  	ret
040798 18          0195*  @cmd:   db 24 ; set graphics viewport command
040799 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
04079B 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
04079D 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
04079F 00 00       0199*  @y0: 	dw 0x0000 ; set by de
0407A1 00          0200*  @end:   db 0x00	  ; padding
0407A2             0201*  
0407A2             0202*  ; SCREEN MODES
0407A2             0203*  ; ===============================
0407A2             0204*  ; Mode  Horz  Vert  Cols  Refresh
0407A2             0205*  ; ---   ----  ----  ----  -------
0407A2             0206*  ; 11    320   240   2     60hz
0407A2             0207*  ; 139   320   240   2     60hz
0407A2             0208*  ; 23    512   384   2     60hz
0407A2             0209*  ; 151   512   384   2     60hz
0407A2             0210*  ; 6     640   240   2     60hz
0407A2             0211*  ; 134   640   240   2     60hz
0407A2             0212*  ; 2     640   480   2     60hz
0407A2             0213*  ; 130   640   480   2     60hz
0407A2             0214*  ; 17    800   600   2     60hz
0407A2             0215*  ; 145   800   600   2     60hz
0407A2             0216*  ; 18    1024  768   2     60hz
0407A2             0217*  ; 146   1024  768   2     60hz
0407A2             0218*  ; ---   ----  ----  ----  -------
0407A2             0219*  ; 10    320   240   4     60hz
0407A2             0220*  ; 138   320   240   4     60hz
0407A2             0221*  ; 22    512   384   4     60hz
0407A2             0222*  ; 150   512   384   4     60hz
0407A2             0223*  ; 5     640   240   4     60hz
0407A2             0224*  ; 133   640   240   4     60hz
0407A2             0225*  ; 1     640   480   4     60hz
0407A2             0226*  ; 129   640   480   4     60hz
0407A2             0227*  ; 16    800   600   4     60hz
0407A2             0228*  ; 19    1024  768   4     60hz
0407A2             0229*  ; ---   ----  ----  ----  -------
0407A2             0230*  ; 9     320   240   16    60hz
0407A2             0231*  ; 137   320   240   16    60hz
0407A2             0232*  ; 21    512   384   16    60hz
0407A2             0233*  ; 149   512   384   16    60hz
0407A2             0234*  ; 4     640   240   16    60hz
0407A2             0235*  ; 132   640   240   16    60hz
0407A2             0236*  ; 0     640   480   16    60hz
0407A2             0237*  ; 7     n/a   n/a   16    60hz
0407A2             0238*  ; ---   ----  ----  ----  -------
0407A2             0239*  ; 8     320   240   64    60hz
0407A2             0240*  ; 136   320   240   64    60hz
0407A2             0241*  ; 20    512   384   64    60hz
0407A2             0242*  ; 3     640   240   64    60hz
0407A2             0243*  ; ---   ----  ----  ----  -------
0407A2             0244*  vdu_set_screen_mode:
0407A2 32 B2 07 04 0245*  	ld (@arg),a
0407A6 21 B1 07 04 0246*  	ld hl,@cmd
0407AA 01 02 00 00 0247*  	ld bc,@end-@cmd
0407AE 5B DF       0248*  	rst.lil $18
0407B0 C9          0249*  	ret
0407B1 16          0250*  @cmd: db 22 ; set screen mode
0407B2 00          0251*  @arg: db 0  ; screen mode parameter
0407B3             0252*  @end:
0407B3             0253*  
0407B3             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0407B3             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0407B3             0256*  ; note: default setting on boot is scaling ON
0407B3             0257*  vdu_set_scaling:
0407B3 32 C5 07 04 0258*  	ld (@arg),a
0407B7 21 C2 07 04 0259*  	ld hl,@cmd
0407BB 01 04 00 00 0260*  	ld bc,@end-@cmd
0407BF 5B DF       0261*  	rst.lil $18
0407C1 C9          0262*  	ret
0407C2 17 00 C0    0263*  @cmd: db 23,0,0xC0
0407C5 00          0264*  @arg: db 0  ; scaling on/off
0407C6             0265*  @end:
0407C6             0266*  
0407C6             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0407C6             0268*  ; inputs: hl=bufferId
0407C6             0269*  vdu_buff_select:
0407C6 22 D8 07 04 0270*  	ld (@bufferId),hl
0407CA 21 D5 07 04 0271*  	ld hl,@cmd
0407CE 01 05 00 00 0272*  	ld bc,@end-@cmd
0407D2 5B DF       0273*  	rst.lil $18
0407D4 C9          0274*  	ret
0407D5 17 1B 20    0275*  @cmd: db 23,27,0x20
0407D8 00 00       0276*  @bufferId: dw 0x0000
0407DA 00          0277*  @end: db 0x00 ; padding
0407DB             0278*  
0407DB             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0407DB             0280*  ; inputs: a=format; bc=width; de=height
0407DB             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0407DB             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0407DB             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0407DB             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0407DB             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0407DB             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
0407DB             0287*  vdu_bmp_create:
0407DB ED 43 F7 07 0288*      ld (@width),bc
       04          
0407E0 ED 53 F9 07 0289*      ld (@height),de
       04          
0407E5 32 FB 07 04 0290*      ld (@fmt),a
0407E9 21 F4 07 04 0291*  	ld hl,@cmd
0407ED 01 08 00 00 0292*  	ld bc,@end-@cmd
0407F1 5B DF       0293*  	rst.lil $18
0407F3 C9          0294*  	ret
0407F4 17 1B 21    0295*  @cmd:       db 23,27,0x21
0407F7 00 00       0296*  @width:     dw 0x0000
0407F9 00 00       0297*  @height:    dw 0x0000
0407FB 00          0298*  @fmt:       db 0x00
0407FC             0299*  @end:
0407FC             0300*  
0407FC             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0407FC             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0407FC             0303*  vdu_load_img_rgba2_to_8:
0407FC             0304*  ; backup the target buffer id and image dimensions
0407FC E5          0305*      push hl
0407FD D5          0306*      push de
0407FE C5          0307*      push bc
0407FF             0308*  ; load the rgba2 image to working buffer 65534
0407FF 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
040803 CD 06 09 04 0310*  	call vdu_load_buffer_from_file
040807             0311*  ; restore the image dimensions and target buffer id
040807 C1          0312*      pop bc
040808 D1          0313*      pop de
040809 E1          0314*      pop hl
04080A             0315*  ; fall through to vdu_rgba2_to_8
04080A             0316*  
04080A             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04080A             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04080A             0319*  ; the "expand bitmap" command is:
04080A             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04080A             0321*  ; and then to reverse the byte order to fix endian-ness:
04080A             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04080A             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04080A             0324*  ; VDU 23,27,&20,targetBufferID%;
04080A             0325*  ; VDU 23,27,&21,width%;height%;0
04080A             0326*  ; -------------------------------------------------------------------
04080A             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
04080A             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04080A             0329*  vdu_rgba2_to_8:
04080A             0330*  ; load the image dimensions and buffer id parameters
04080A ED 43 66 08 0331*      ld (@width),bc
       04          
04080F ED 53 68 08 0332*      ld (@height),de
       04          
040814 22 4B 08 04 0333*      ld (@bufferId0),hl
040818 22 58 08 04 0334*      ld (@bufferId2),hl
04081C 22 61 08 04 0335*      ld (@bufferId1),hl
040820             0336*  ; clean up bytes that got stomped on by the ID loads
040820 3E 48       0337*      ld a,0x48
040822 32 4D 08 04 0338*      ld (@bufferId0+2),a
040826 3E 17       0339*      ld a,23
040828 32 63 08 04 0340*      ld (@bufferId1+2),a
04082C 3E 18       0341*      ld a,24
04082E 32 5A 08 04 0342*      ld (@bufferId2+2),a
040832 AF          0343*      xor a
040833 32 6A 08 04 0344*      ld (@height+2),a
040837             0345*  ; send the vdu command strings
040837 21 42 08 04 0346*      ld hl,@beg
04083B 01 29 00 00 0347*      ld bc,@end-@beg
04083F 5B DF       0348*      rst.lil $18
040841 C9          0349*      ret
040842             0350*  @beg:
040842             0351*  ; Command 14: Consolidate blocks in a buffer
040842             0352*  ; VDU 23, 0, &A0, bufferId; 14
040842 17 00 A0    0353*      db 23,0,0xA0
040845 FE FF       0354*      dw 65534 ; workingBufferId
040847 0E          0355*      db 14 ; consolidate blocks
040848             0356*  ; the "expand bitmap" command is:
040848             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040848 17 00 A0    0358*      db 23,0,0xA0
04084B 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04084D 48          0360*      db 0x48 ; given as decimal command 72 in the docs
04084E 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04084F FE FF       0362*      dw 65534 ; sourceBufferId
040851 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040855             0364*  ; reverse the byte order to fix endian-ness:
040855             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
040855             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040855             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040855 17 00 A0    0368*      db 23,0,0xA0
040858 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04085A 18          0370*      db 24 ; reverse byte order
04085B 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04085C 04 00       0372*      dw 4 ; size (4 bytes)
04085E             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04085E             0374*  ; VDU 23,27,&20,targetBufferID%;
04085E 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
040861 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
040863             0377*  ; VDU 23,27,&21,width%;height%;0
040863 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
040866 00 00       0379*  @width: dw 0x0000
040868 00 00       0380*  @height: dw 0x0000
04086A 00          0381*      db 0x00 ; rgba8888 format
04086B             0382*  @end:
04086B             0383*  
04086B             0384*  ; scratch variables
04086B 00 00 00    0385*  bufferId0: dl 0x000000
04086E 00 00 00    0386*  bufferId1: dl 0x000000
040871             0387*  
040871             0388*  ; load a vdu buffer from local memory
040871             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040871             0390*  vdu_load_buffer:
040871 ED 43 9A 08 0391*      ld (@length),bc
       04          
040876 D5          0392*      push de ; save data pointer
040877             0393*  ; send the vdu command string
040877 7D          0394*      ld a,l
040878 32 97 08 04 0395*      ld (@bufferId),a
04087C 7C          0396*      ld a,h
04087D 32 98 08 04 0397*      ld (@bufferId+1),a
040881 21 94 08 04 0398*      ld hl,@cmd
040885 01 08 00 00 0399*      ld bc,@end-@cmd
040889 5B DF       0400*      rst.lil $18
04088B             0401*  ; send the buffer data
04088B E1          0402*      pop hl ; pointer to data
04088C ED 4B 9A 08 0403*      ld bc,(@length)
       04          
040891 5B DF       0404*      rst.lil $18 ; send it
040893 C9          0405*      ret
040894             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040894 17 00 A0    0407*  @cmd:       db 23,0,0xA0
040897 00 00       0408*  @bufferId:	dw 0x0000
040899 00          0409*  		    db 0 ; load buffer
04089A 00 00       0410*  @length:	dw 0x0000
04089C 00          0411*  @end: db 0 ; padding
04089D             0412*  
04089D             0413*  ; clear a buffer
04089D             0414*  ; inputs: hl = bufferId
04089D             0415*  vdu_clear_buffer:
04089D 7D          0416*      ld a,l
04089E 32 B5 08 04 0417*      ld (@bufferId),a
0408A2 7C          0418*      ld a,h
0408A3 32 B6 08 04 0419*      ld (@bufferId+1),a
0408A7 21 B2 08 04 0420*      ld hl,@cmd
0408AB 01 06 00 00 0421*      ld bc,@end-@cmd
0408AF 5B DF       0422*      rst.lil $18
0408B1 C9          0423*      ret
0408B2 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0408B5 00 00       0425*  @bufferId:	dw 0x0000
0408B7 02          0426*  		    db 2 ; clear buffer
0408B8             0427*  @end:
0408B8             0428*  
0408B8             0429*  vdu_clear_all_buffers:
0408B8             0430*  ; clear all buffers
0408B8 21 C3 08 04 0431*      ld hl,@beg
0408BC 01 06 00 00 0432*      ld bc,@end-@beg
0408C0 5B DF       0433*      rst.lil $18
0408C2 C9          0434*      ret
0408C3 17 00 A0    0435*  @beg: db 23,0,$A0
0408C6 FF FF       0436*        dw -1 ; clear all buffers
0408C8 02          0437*        db 2  ; command 2: clear a buffer
0408C9             0438*  @end:
0408C9             0439*  
0408C9             0440*  ; Command 14: Consolidate blocks in a buffer
0408C9             0441*  vdu_consolidate_buffer:
0408C9             0442*  ; set parameters for vdu call
0408C9 7D          0443*      ld a,l
0408CA 32 E1 08 04 0444*      ld (@bufferId),a
0408CE 7C          0445*      ld a,h
0408CF 32 E2 08 04 0446*      ld (@bufferId+1),a
0408D3 21 DE 08 04 0447*      ld hl,@beg
0408D7 01 06 00 00 0448*      ld bc,@end-@beg
0408DB 5B DF       0449*      rst.lil $18
0408DD C9          0450*      ret
0408DE             0451*  ; VDU 23, 0, &A0, bufferId; 14
0408DE 17 00 A0    0452*  @beg: db 23,0,0xA0
0408E1 00 00       0453*  @bufferId: dw 0x0000
0408E3 0E          0454*             db 14
0408E4             0455*  @end:
0408E4             0456*  
0408E4             0457*  ; load an image file to a buffer and make it a bitmap
0408E4             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0408E4             0459*  vdu_load_img:
0408E4             0460*  ; back up image type and dimension parameters
0408E4 22 6B 08 04 0461*      ld (bufferId0),hl
0408E8 F5          0462*      push af
0408E9 C5          0463*  	push bc
0408EA D5          0464*  	push de
0408EB             0465*  ; load the image
0408EB CD 06 09 04 0466*  	call vdu_load_buffer_from_file
0408EF             0467*  ; now make it a bitmap
0408EF 2A 6B 08 04 0468*      ld hl,(bufferId0)
0408F3 CD C9 08 04 0469*      call vdu_consolidate_buffer
0408F7 2A 6B 08 04 0470*      ld hl,(bufferId0)
0408FB CD C6 07 04 0471*      call vdu_buff_select
0408FF D1          0472*  	pop de ; image height
040900 C1          0473*  	pop bc ; image width
040901 F1          0474*  	pop af ; image type
040902 C3 DB 07 04 0475*  	jp vdu_bmp_create ; will return to caller from there
040906             0476*  
040906             0477*  ; inputs: hl = bufferId; iy = pointer to filename
040906             0478*  vdu_load_buffer_from_file:
040906 22 6B 08 04 0479*      ld (bufferId0),hl
04090A             0480*  
04090A             0481*  ; clear target buffer
04090A CD 9D 08 04 0482*      call vdu_clear_buffer
04090E             0483*  
04090E             0484*  ; open the file in read mode
04090E             0485*  ; Open a file
04090E             0486*  ; HLU: Filename
04090E             0487*  ;   C: Mode
04090E             0488*  ; Returns:
04090E             0489*  ;   A: Filehandle, or 0 if couldn't open
04090E FD E5       0490*  	push iy ; pointer to filename
040910 E1          0491*  	pop hl
040911 0E 01       0492*  	ld c,fa_read
040913             0493*      MOSCALL mos_fopen
040913 3E 0A       0001*M 			LD	A, function
040915 5B CF       0002*M 			RST.LIL	08h
040917 32 52 09 04 0494*      ld (@filehandle),a
04091B             0495*  
04091B             0496*  @read_file:
04091B             0497*  ; Read a block of data from a file
04091B             0498*  ;   C: Filehandle
04091B             0499*  ; HLU: Pointer to where to write the data to
04091B             0500*  ; DEU: Number of bytes to read
04091B             0501*  ; Returns:
04091B             0502*  ; DEU: Number of bytes read
04091B 3A 52 09 04 0503*      ld a,(@filehandle)
04091F 4F          0504*      ld c,a
040920 21 00 E0 B7 0505*      ld hl,filedata
040924 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
040928             0507*      MOSCALL mos_fread
040928 3E 1A       0001*M 			LD	A, function
04092A 5B CF       0002*M 			RST.LIL	08h
04092C             0508*  
04092C             0509*  ; ; DEBUG: print chunk size
04092C             0510*  ;     push de
04092C             0511*  ;     pop hl
04092C             0512*  ;     call printDec
04092C             0513*  ;     call printNewLine
04092C             0514*  
04092C             0515*  ; test de for zero bytes read
04092C 21 00 00 00 0516*      ld hl,0
040930 AF          0517*      xor a ; clear carry
040931 ED 52       0518*      sbc hl,de
040933 CA 49 09 04 0519*      jp z,@close_file
040937             0520*  
040937             0521*  ; load a vdu buffer from local memory
040937             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040937 2A 6B 08 04 0523*      ld hl,(bufferId0)
04093B D5          0524*      push de ; chunksize
04093C C1          0525*      pop bc
04093D 11 00 E0 B7 0526*      ld de,filedata
040941 CD 71 08 04 0527*      call vdu_load_buffer
040945             0528*  
040945             0529*  ; ; print progress breadcrumbs
040945             0530*  ;     ld a,'.'
040945             0531*  ;     rst.lil 10h
040945             0532*  
040945             0533*  ; read the next block
040945 C3 1B 09 04 0534*      jp @read_file
040949             0535*  
040949             0536*  ; close the file
040949             0537*  @close_file:
040949 3A 52 09 04 0538*      ld a,(@filehandle)
04094D             0539*      MOSCALL mos_fclose
04094D 3E 0B       0001*M 			LD	A, function
04094F 5B CF       0002*M 			RST.LIL	08h
040951 C9          0540*      ret ; vdu_load_buffer_from_file
040952             0541*  
040952 00          0542*  @filehandle: db 0 ; file handle
040953 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
040956             0544*  
040956 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
040959             0546*  
040959             0547*  ; File information structure (FILINFO)
040959             0548*  @filinfo:
040959 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04095D 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04095F 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040961 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040962 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04096F 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040A6F             0046   	include "maths.inc"
040A6F             0001*  ; test the sign of HL
040A6F             0002*  ; inputs: HL obviously
040A6F             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040A6F             0004*  ; destroys: flags
040A6F             0005*      MACRO sign_hlu
040A6F             0006*          add hl,de
040A6F             0007*          or a
040A6F             0008*          sbc hl,de
040A6F             0009*      ENDMACRO
040A6F             0010*  
040A6F             0011*  
040A6F             0012*  ;------------------------------------------------------------------------
040A6F             0013*  ; Scratch area for calculations
040A6F             0014*  ;------------------------------------------------------------------------
040A6F 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
040A72 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
040A75             0017*  
040A75             0018*  ; absolute value of hlu
040A75             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040A75             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040A75             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040A75             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040A75             0023*  ; destroys: a
040A75             0024*  hlu_abs:
040A75 19          0025*      add hl,de
040A76 B7          0026*      or a
040A77 ED 52       0027*      sbc hl,de
040A79 FA 7E 0A 04 0028*      jp m,@is_neg
040A7D C9          0029*      ret         ; hlu is positive or zero so we're done
040A7E             0030*  @is_neg:
040A7E F5          0031*      push af     ; otherwise, save current flags for return
040A7F CD 85 0A 04 0032*      call neg_hlu ; negate hlu
040A83 F1          0033*      pop af      ; get back flags
040A84 C9          0034*      ret
040A85             0035*  
040A85             0036*  ; flip the sign of hlu
040A85             0037*  ; inputs: hlu
040A85             0038*  ; returns: 0-hlu, flags set appropriately for the result:
040A85             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
040A85             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
040A85             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
040A85             0042*  ; destroys a
040A85             0043*  neg_hlu:
040A85 D5          0044*      push de     ; save de
040A86 EB          0045*      ex de,hl    ; put hl into de
040A87 21 00 00 00 0046*      ld hl,0     ; clear hl
040A8B AF          0047*      xor a       ; clear carry
040A8C ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
040A8E D1          0049*      pop de      ; get de back
040A8F C9          0050*      ret         ; easy peasy
040A90             0051*  
040A90             0052*  ;------------------------------------------------------------------------
040A90             0053*  ; divide hlu by 2, inspired by above
040A90             0054*  ;------------------------------------------------------------------------
040A90             0055*  hlu_div2:
040A90 22 6F 0A 04 0056*  	ld		(scratch1),hl
040A94 21 71 0A 04 0057*  	ld		hl,scratch1+2
040A98 CB 1E       0058*  	rr		(hl)
040A9A 2B          0059*  	dec		hl
040A9B CB 1E       0060*  	rr		(hl)
040A9D 2B          0061*  	dec		hl
040A9E CB 1E       0062*  	rr		(hl)
040AA0 23          0063*  	inc		hl
040AA1 23          0064*  	inc		hl
040AA2 2A 6F 0A 04 0065*      ld hl,(scratch1)
040AA6 C9          0066*      ret
040AA7             0067*  
040AA7             0068*  ; this is my little hack to divide by 16
040AA7             0069*  hlu_div16:
040AA7 AF          0070*      xor a
040AA8 29          0071*      add hl,hl
040AA9 17          0072*      rla
040AAA 29          0073*      add hl,hl
040AAB 17          0074*      rla
040AAC 29          0075*      add hl,hl
040AAD 17          0076*      rla
040AAE 29          0077*      add hl,hl
040AAF 17          0078*      rla
040AB0 22 BD 0A 04 0079*      ld (@scratch),hl
040AB4 32 C0 0A 04 0080*      ld (@scratch+3),a
040AB8 2A BE 0A 04 0081*      ld hl,(@scratch+1)
040ABC C9          0082*      ret
040ABD             0083*  @scratch: ds 4
040AC1             0084*  
040AC1             0085*  ; hlu signed division by 256
040AC1             0086*  ; returns: hlu / 256
040AC1             0087*  ; destroys: af
040AC1             0088*  hlu_sdiv256:
040AC1 AF          0089*      xor a ; assume hl is positive
040AC2 22 D8 0A 04 0090*      ld (@buffer),hl
040AC6             0091*      sign_hlu
040AC6 19          0001*M         add hl,de
040AC7 B7          0002*M         or a
040AC8 ED 52       0003*M         sbc hl,de
040ACA F2 CF 0A 04 0092*      jp p,@hl_pos
040ACE 3D          0093*      dec a
040ACF             0094*  @hl_pos:
040ACF 32 DB 0A 04 0095*      ld (@buffer+3),a
040AD3 2A D9 0A 04 0096*      ld hl,(@buffer+1)
040AD7 C9          0097*      ret
040AD8             0098*  @buffer: ds 4
040ADC             0099*  
040ADC             0100*  ; hlu 1 byte right shift, unsigned
040ADC             0101*  ; returns: hlu / 256, fractional portion in a
040ADC             0102*  ; destroys: af
040ADC             0103*  hlu_udiv256:
040ADC AF          0104*  	xor a
040ADD 32 EE 0A 04 0105*  	ld (@buffer+3),a
040AE1 7D          0106*  	ld a,l ; save the fractional portion
040AE2 22 EB 0A 04 0107*  	ld (@buffer),hl
040AE6 2A EC 0A 04 0108*  	ld hl,(@buffer+1)
040AEA C9          0109*  	ret
040AEB             0110*  @buffer: ds 4
040AEF             0111*  
040AEF             0112*      MACRO hlu_mul256
040AEF             0113*          add hl,hl ; * 2
040AEF             0114*          add hl,hl ; * 4
040AEF             0115*          add hl,hl ; * 8
040AEF             0116*          add hl,hl ; * 16
040AEF             0117*          add hl,hl ; * 32
040AEF             0118*          add hl,hl ; * 64
040AEF             0119*          add hl,hl ; * 128
040AEF             0120*          add hl,hl ; * 256
040AEF             0121*      ENDMACRO
040AEF             0122*  
040AEF             0123*  ; compute the modulo of hlu by deu
040AEF             0124*  ; outputs: hlu = hlu % deu
040AEF             0125*  ; destroys: f, hl
040AEF             0126*  hlu_mod:
040AEF B7          0127*  	or a ; clear carry
040AF0             0128*  @loop:
040AF0 ED 52       0129*      sbc hl,de
040AF2 DA FA 0A 04 0130*      jp c, @end
040AF6 C3 F0 0A 04 0131*      jp @loop
040AFA             0132*  @end:
040AFA 19          0133*      add hl,de
040AFB C9          0134*  	ret
040AFC             0135*  
040AFC             0136*  
040AFC 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
040B00 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040B04             0139*  
040B04             0140*  ; set bcd values in a scratch memory address from registers bcde
040B04             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040B04             0142*  ; destroys ; hl
040B04             0143*  set_bcd:
040B04 73          0144*      ld (hl),e
040B05 23          0145*      inc hl
040B06 72          0146*      ld (hl),d
040B07 23          0147*      inc hl
040B08 71          0148*      ld (hl),c
040B09 23          0149*      inc hl
040B0A 70          0150*      ld (hl),b
040B0B C9          0151*      ret
040B0C             0152*  
040B0C             0153*  ; load bcd values from a scratch memory address to bcde
040B0C             0154*  ; input: hl; scratch address
040B0C             0155*  ; output: bcde; 8-place bcd number
040B0C             0156*  ; destroys: hl
040B0C             0157*  get_bcd:
040B0C 5E          0158*      ld e,(hl)
040B0D 23          0159*      inc hl
040B0E 56          0160*      ld d,(hl)
040B0F 23          0161*      inc hl
040B10 4E          0162*      ld c,(hl)
040B11 23          0163*      inc hl
040B12 46          0164*      ld b,(hl)
040B13 C9          0165*      ret
040B14             0166*  
040B14             0167*  ; BCD addition
040B14             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B14             0169*  ;       a is the number of bytes holding each number (number of places/2)
040B14             0170*  ; outputs: (hl) + (de) --> (hl)
040B14             0171*  ; destroys: a,b,de,hl
040B14             0172*  add_bcd:
040B14 47          0173*      ld b,a ; loop counter
040B15 AF          0174*      xor a ; reset a, clear carry flag
040B16             0175*  adcec:
040B16 1A          0176*      ld a,(de) ; addend to acc
040B17 8E          0177*      adc a,(hl) ; add (hl) to acc
040B18 27          0178*      daa ; adjust result to bcd
040B19 77          0179*      ld (hl),a ; store result
040B1A 23          0180*      inc hl ; advance memory pointers
040B1B 13          0181*      inc de
040B1C 10 F8       0182*      djnz adcec ; loop until b == 0
040B1E C9          0183*      ret
040B1F             0184*  
040B1F             0185*  ; BCD subtraction
040B1F             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040B1F             0187*  ;       a is the number of bytes holding each number (number of places/2)
040B1F             0188*  ; outputs: (hl) - (de) --> (hl)
040B1F             0189*  ; destroys: a,b,de,hl
040B1F             0190*  sub_bcd:
040B1F 47          0191*      ld b,a ; loop counter
040B20 AF          0192*      xor a ; reset a,clear carry flag
040B21             0193*  subdec:
040B21 1A          0194*      ld a,(de) ; subtrahend to acc
040B22 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040B23 27          0196*      daa ; adjust result to bcd
040B24 77          0197*      ld (hl),a ; store result
040B25 23          0198*      inc hl ; advance memory pointers
040B26 13          0199*      inc de
040B27 10 F8       0200*      djnz subdec ; loop until b == 0
040B29 C9          0201*      ret
040B2A             0202*  
040B2A             0203*  ; http://www.z80.info/pseudo-random.txt
040B2A             0204*  rand_8:
040B2A C5          0205*      push bc
040B2B 3A 3E 0B 04 0206*      ld a,(r_seed)
040B2F 4F          0207*      ld c,a
040B30             0208*  
040B30 0F          0209*      rrca ; multiply by 32
040B31 0F          0210*      rrca
040B32 0F          0211*      rrca
040B33 EE 1F       0212*      xor 0x1f
040B35             0213*  
040B35 81          0214*      add a,c
040B36 DE FF       0215*      sbc a,255 ; carry
040B38             0216*  
040B38 32 3E 0B 04 0217*      ld (r_seed),a
040B3C C1          0218*      pop bc
040B3D C9          0219*      ret
040B3E 50          0220*  r_seed: defb $50
040B3F             0047   	include "trig24fast.inc"
040B3F             0001*  
040B3F             0002*  ; convert signed angles from a 360 to 256 degree circle
040B3F             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040B3F             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
040B3F             0005*  ; destroys: TODO
040B3F             0006*  deg_360_to_256:
040B3F D5          0007*  	push de ; preserve de
040B40             0008*  ; make angle positive and store sign flag
040B40 CD 75 0A 04 0009*  	call hlu_abs
040B44 F5          0010*  	push af
040B45             0011*  ; multiply by 256 first to keep precision
040B45             0012*  	hlu_mul256 ; uh.l = uh.l * 256
040B45 29          0001*M         add hl,hl ; * 2
040B46 29          0002*M         add hl,hl ; * 4
040B47 29          0003*M         add hl,hl ; * 8
040B48 29          0004*M         add hl,hl ; * 16
040B49 29          0005*M         add hl,hl ; * 32
040B4A 29          0006*M         add hl,hl ; * 64
040B4B 29          0007*M         add hl,hl ; * 128
040B4C 29          0008*M         add hl,hl ; * 256
040B4D             0013*  ; divide uh.l by 360
040B4D 11 68 01 00 0014*  	ld de,360
040B51 CD 1E 16 04 0015*  	call udiv24 ; ud.e = degrees / 360
040B55 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
040B56             0017*  ; restore sign flag and adjust output accordingly
040B56 F1          0018*  	pop af
040B57 F2 5F 0B 04 0019*  	jp p,@pos ; positive number
040B5B CD 85 0A 04 0020*  	call neg_hlu
040B5F             0021*  @pos:
040B5F             0022*  ; restore de and return uh.l as the result
040B5F D1          0023*  	pop de
040B60 C9          0024*  	ret
040B61             0025*  
040B61             0026*  ; fixed 16.8 routine
040B61             0027*  ; cos(uh.l) --> uh.l
040B61             0028*  ; destroys: f, hl
040B61             0029*  cos168:
040B61 D5          0030*      push de ; preserve de
040B62             0031*  ; for cos we simply increment the angle by 90 degrees
040B62             0032*  ; or 0x004000 in 16.8 degrees256
040B62             0033*  ; which makes it a sin problem
040B62 11 00 40 00 0034*      ld de,0x004000
040B66 19          0035*      add hl,de ; modulo 256 happens below
040B67 D1          0036*      pop de ; restore de
040B68             0037*  ; fall through to sin168
040B68             0038*  
040B68             0039*  ; ---------------------
040B68             0040*  ; fixed 16.8 routine
040B68             0041*  ; sin(uh.l) --> uh.l
040B68             0042*  ; destroys: f, hl
040B68             0043*  sin168:
040B68 D5          0044*  	push de
040B69             0045*  ; handle negative angles appropriately
040B69 CD 75 0A 04 0046*  	call hlu_abs
040B6D F2 76 0B 04 0047*  	jp p,@F
040B71 11 00 00 FF 0048*  	ld de,-256*256
040B75 19          0049*  	add hl,de
040B76             0050*  @@:
040B76 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
040B78 ED 6C       0052*      mlt hl
040B7A 11 CF 0D 04 0053*      ld de,sin_lut_168 ; grab the lut address
040B7E 19          0054*      add hl,de ; bump hl by the index
040B7F ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
040B81 D1          0056*      pop de
040B82 C9          0057*      ret
040B83             0058*  
040B83             0059*  ; 16.8 fixed inputs / outputs
040B83             0060*  ; takes: uh.l as angle in degrees 256
040B83             0061*  ;        ud.e as radius
040B83             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040B83             0063*  ;        displacements from origin (0,0)
040B83             0064*  ; destroys: everything except indexes
040B83             0065*  polar_to_cartesian:
040B83             0066*  ; back up input parameters
040B83 22 B2 0B 04 0067*      ld (@angle), hl
040B87 ED 53 B5 0B 0068*      ld (@radius), de
       04          
040B8C             0069*  ; compute dx = sin(uh.l) * ud.e
040B8C CD 68 0B 04 0070*      call sin168 ; uh.l = sin(uh.l)
040B90 ED 5B B5 0B 0071*  	ld de,(@radius)
       04          
040B95 CD 93 15 04 0072*  	call smul168 ; uh.l = dx
040B99 E5          0073*      push hl
040B9A             0074*  ; compute dy = -cos(uh.l) * ud.e
040B9A 2A B2 0B 04 0075*      ld hl,(@angle)
040B9E CD 61 0B 04 0076*      call cos168 ; uh.l = cos(uh.l)
040BA2 ED 5B B5 0B 0077*      ld de,(@radius)
       04          
040BA7 CD 93 15 04 0078*      call smul168    ; uh.l = dy
040BAB CD 85 0A 04 0079*      call neg_hlu ; invert dy for screen coords convention
040BAF EB          0080*      ex de,hl       ; de = dy for output
040BB0 C1          0081*      pop bc          ; bc = dx for output
040BB1             0082*  ; ; DEBUG
040BB1             0083*  ; 	call vdu_home_cursor
040BB1             0084*  ; 	call print_s168_hl
040BB1             0085*  ; 	call print_s168_bc
040BB1             0086*  ; 	call print_s168_de
040BB1             0087*  ; ; END DEBUG
040BB1             0088*  ; and out
040BB1 C9          0089*      ret
040BB2             0090*  @angle: ds 3
040BB5             0091*  @radius: ds 3
040BB8             0092*  
040BB8             0093*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BB8             0094*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BB8             0095*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040BB8             0096*  ;         also populates scratch locations dx168 and dy168
040BB8             0097*  ; destroys: a,hl,bc,de
040BB8             0098*  dxy168:
040BB8             0099*  ; compute dx = x1-x0
040BB8 AF          0100*      xor a ; clear carry
040BB9 DD E5       0101*      push ix ; move ix to hl via the stack
040BBB E1          0102*      pop hl ; hl = x1
040BBC ED 42       0103*      sbc hl,bc ; hl = dx
040BBE 22 13 0C 04 0104*      ld (dx168),hl ; dx to scratch
040BC2             0105*  ; compute dy = y1-y0
040BC2 AF          0106*      xor a ; clear carry
040BC3 FD E5       0107*      push iy ; move iy to hl via the stack
040BC5 E1          0108*      pop hl ; hl = y1
040BC6 ED 52       0109*      sbc hl,de ; hl = dy
040BC8 22 19 0C 04 0110*      ld (dy168),hl ; dy to scratch
040BCC             0111*  ; populate output registers and return
040BCC EB          0112*      ex de,hl        ; ud.e = dy
040BCD ED 4B 13 0C 0113*      ld bc,(dx168)   ; ub.c = dx
       04          
040BD2 C9          0114*      ret
040BD3             0115*  
040BD3             0116*  ; compute the euclidian distance between two cartesian coordinates
040BD3             0117*  ; using the formula d = sqrt(dx^2+dy^2
040BD3             0118*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040BD3             0119*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040BD3             0120*  ; output; uh.l is the 16.8 fixed format distance
040BD3             0121*  ;       dx168/y are the 16.8 fixed format dx and dy
040BD3             0122*  ; destroys: a,hl,bc,de
040BD3             0123*  distance168:
040BD3             0124*  ; compute dx = x1-x0
040BD3 AF          0125*      xor a ; clear carry
040BD4 DD E5       0126*      push ix ; move ix to hl via the stack
040BD6 E1          0127*      pop hl ; hl = x1
040BD7 ED 42       0128*      sbc hl,bc ; hl = dx
040BD9 22 13 0C 04 0129*      ld (dx168),hl ; dx to scratch
040BDD             0130*  ; ; test dx for overflow
040BDD             0131*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040BDD             0132*  ; 	ex de,hl
040BDD             0133*  ; 	sbc hl,de ; test for overflow
040BDD             0134*  ; 	push af ; carry indicates overflow
040BDD             0135*  ; compute dy = y1-y0
040BDD AF          0136*      xor a ; clear carry
040BDE FD E5       0137*      push iy ; move iy to hl via the stack
040BE0 E1          0138*      pop hl ; hl = y1
040BE1 ED 52       0139*      sbc hl,de ; hl = dy
040BE3 22 19 0C 04 0140*      ld (dy168),hl ; dy to scratch
040BE7             0141*  ; ; test dy for overflow
040BE7             0142*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040BE7             0143*  ; 	ex de,hl
040BE7             0144*  ; 	sbc hl,de ; test for overflow
040BE7             0145*  ; 	push af ; carry indicates overflow
040BE7             0146*  ; compute dy^2
040BE7 2A 19 0C 04 0147*  	ld hl,(dy168)
040BEB CD 75 0A 04 0148*      call hlu_abs  ; make dy positive so we can use unsigned multiply
040BEF             0149*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040BEF E5          0150*      push hl ; load hl/2 to bc via the stack
040BF0 C1          0151*      pop bc ; bc = dy/2
040BF1 EB          0152*      ex de,hl ; de = dy/2
040BF2 CD 8B 15 04 0153*      call umul168 ; uh.l = dy^2/2
040BF6 E5          0154*      push hl ; dy^2/2 to the stack
040BF7             0155*  ; compute dx^2
040BF7 2A 13 0C 04 0156*      ld hl,(dx168) ; get back dx
040BFB CD 75 0A 04 0157*      call hlu_abs  ; make dx positive so we can use unsigned multiply
040BFF             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040BFF E5          0159*      push hl ; load hl/2 to bc via the stack
040C00 C1          0160*      pop bc ; bc = dx/2
040C01 EB          0161*      ex de,hl ; de = dx/2
040C02 CD 8B 15 04 0162*      call umul168 ; uh.l = dx^2/2
040C06             0163*  ; commpute dy^2+dx^2
040C06 D1          0164*      pop de ; get back dx^2/2
040C07 19          0165*      add hl,de ; hl = dx^2/2+dy^2/2
040C08             0166*  ; compute sqrt(dx^2/2+dy^2/2)
040C08 CD E4 0C 04 0167*      call sqrt168 ; uh.l = distance/2
040C0C             0168*      ; add hl,hl ; hl = distance
040C0C             0169*  ; ; check for overflow
040C0C             0170*  ; 	pop af ; get back the overflow flags
040C0C             0171*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040C0C             0172*  ; 	ld b,a ; save the overflow flag
040C0C             0173*  ; 	pop af ; get back the overflow flags
040C0C             0174*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040C0C             0175*  ; 	add a,b ; if a != 0 then we had overflow
040C0C             0176*  ;     ret z ; no overflow we're done
040C0C             0177*  ; @overflow:
040C0C             0178*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
040C0C C9          0179*  	ret
040C0D             0180*  @scratch: ds 6
040C13             0181*  dx168: ds 6
040C19             0182*  dy168: ds 6
040C1F             0183*  
040C1F             0184*  ; atan2_(ub.c,ud.e) --> uh.l
040C1F             0185*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040C1F             0186*  ;   whether inputs are integers or fractional doesn't matter
040C1F             0187*  ;   so long as the sign bit of the upper byte is correct
040C1F             0188*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040C1F             0189*  ; angles are COMPASS HEADINGS based on
040C1F             0190*  ; screen coordinate conventions,where the y axis is flipped
040C1F             0191*  ; #E0 315      0       45 #20
040C1F             0192*  ;        -x,-y | +x,-y
040C1F             0193*  ; #C0 270------+------ 90 #40
040C1F             0194*  ;        -x,+y | +x,+y
040C1F             0195*  ; #A0 225   180 #80   135 #60
040C1F             0196*  atan2_168fast:
040C1F             0197*  ; get signs and make everything positive
040C1F             0198*  ; get abs(x) and store its original sign
040C1F C5          0199*      push bc
040C20 E1          0200*      pop hl
040C21 CD 75 0A 04 0201*      call hlu_abs ; if x was negative this also sets the sign flag
040C25 E5          0202*      push hl ; store abs(x)
040C26 C1          0203*      pop bc ; bc = abs(x)
040C27 F5          0204*      push af ; store sign of x
040C28             0205*  ; get abs(y) and store its original sign
040C28 EB          0206*      ex de,hl ; hl = y
040C29 CD 75 0A 04 0207*      call hlu_abs ; if y was negative this also sets the sign flag
040C2D EB          0208*      ex de,hl ; de = abs(y)
040C2E F5          0209*      push af ; store sign of y
040C2F             0210*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040C2F             0211*  ; this ensures that our lookup value is between 0 and 1 inclusive
040C2F AF          0212*      xor a ; clear the carry flag
040C30 D5          0213*      push de
040C31 E1          0214*      pop hl
040C32 ED 42       0215*      sbc hl,bc
040C34 F5          0216*      push af ; save sign of de - bc
040C35 F2 3E 0C 04 0217*      jp p,@1 ; bc <= de, so we skip ahead
040C39             0218*  ; otherwise we swap bc and de
040C39 C5          0219*      push bc
040C3A E1          0220*      pop hl
040C3B EB          0221*      ex de,hl
040C3C E5          0222*      push hl
040C3D C1          0223*      pop bc
040C3E             0224*  @1:
040C3E             0225*  ; ; DEBUG
040C3E             0226*  ;     call vdu_home_cursor
040C3E             0227*  ;     call print_s168_hl
040C3E             0228*  ;     call print_s168_bc
040C3E             0229*  ;     call print_s168_de
040C3E             0230*  ; ; END DEBUG
040C3E             0231*  ; ; DEBUG
040C3E             0232*  ; 	call vdu_home_cursor
040C3E             0233*  ; 	call dumpRegistersHex
040C3E             0234*  ; ; END DEBUG
040C3E             0235*  ; now we're ready to snag our preliminary result
040C3E C5          0236*  	push bc
040C3F E1          0237*  	pop hl
040C40 CD AE 0C 04 0238*      call atan_168fast ; uh.l comes back with prelim result
040C44             0239*  ; ; DEBUG
040C44             0240*  ;     call vdu_home_cursor
040C44             0241*  ;     call print_s168_hl
040C44             0242*  ;     call print_s168_bc
040C44             0243*  ;     call print_s168_de
040C44             0244*  ; ; END DEBUG
040C44             0245*  ; now we adjust uh.l based on sign of de - bc
040C44 F1          0246*      pop af
040C45 F2 51 0C 04 0247*      jp p,@2 ; bc <= de,so we skip ahead
040C49 EB          0248*      ex de,hl
040C4A 21 00 40 00 0249*      ld hl,0x004000 ; 90 degrees
040C4E AF          0250*      xor a ; clear the carry flag
040C4F ED 52       0251*      sbc hl,de ; subtract result from 90 degrees
040C51             0252*      ; ld de,0 ; prep to clear hlu
040C51             0253*      ; ld d,h
040C51             0254*      ; ld e,l
040C51             0255*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
040C51             0256*      ; fall through
040C51             0257*  @2:
040C51             0258*  ; now the fun part of adjusting the result
040C51             0259*  ; based on which quadrant (x,y) is in
040C51             0260*  ; #E0 315      0       45 #20
040C51             0261*  ;        -x,-y | +x,-y
040C51             0262*  ; #C0 270------+------ 90 #40
040C51             0263*  ;        -x,+y | +x,+y
040C51             0264*  ; #A0 225   180 #80   135 #60
040C51 F1          0265*      pop af ; sign of y
040C52 CA 8F 0C 04 0266*      jp z,@y_zero
040C56 F2 6F 0C 04 0267*      jp p,@y_pos
040C5A             0268*  ; y neg,check x
040C5A F1          0269*      pop af ; sign of x
040C5B CA 69 0C 04 0270*      jp z,@y_neg_x_zero
040C5F F2 6E 0C 04 0271*      jp p,@y_neg_x_pos
040C63             0272*  ; y neg,x neg
040C63             0273*  ; angle is 270-360
040C63             0274*  ; negating the intermediate does the trick
040C63 CD 85 0A 04 0275*      call neg_hlu
040C67 18 31       0276*      jr @zero_hlu
040C69             0277*  
040C69             0278*  @y_neg_x_zero:
040C69             0279*  ; y neg,x zero
040C69             0280*  ; angle is 0
040C69 21 00 00 00 0281*      ld hl,0
040C6D C9          0282*      ret
040C6E             0283*  @y_neg_x_pos:
040C6E             0284*  ; y neg,x pos
040C6E             0285*  ; angle is 0 to 90
040C6E             0286*  ; so we're good
040C6E C9          0287*      ret
040C6F             0288*  
040C6F             0289*  @y_pos:
040C6F F1          0290*      pop af ; sign of x
040C70 CA 7F 0C 04 0291*      jp z,@y_pos_x_zero
040C74 F2 84 0C 04 0292*      jp p,@y_pos_x_pos
040C78             0293*  ; y pos,x neg
040C78             0294*  ; angle is 180-270
040C78             0295*  ; so we add 180 to intermediate
040C78 11 00 80 00 0296*      ld de,0x008000
040C7C 19          0297*      add hl,de
040C7D 18 1B       0298*      jr @zero_hlu
040C7F             0299*  @y_pos_x_zero:
040C7F             0300*  ; y pos,x zero
040C7F             0301*  ; angle is 180
040C7F 21 00 80 00 0302*      ld hl,0x008000
040C83 C9          0303*      ret
040C84             0304*  @y_pos_x_pos:
040C84             0305*  ; y pos,x pos
040C84             0306*  ; angle is 90-180
040C84             0307*  ; neg the intermediate and add 180 degrees
040C84 CD 85 0A 04 0308*      call neg_hlu
040C88 11 00 80 00 0309*      ld de,0x008000
040C8C 19          0310*      add hl,de
040C8D 18 0B       0311*      jr @zero_hlu
040C8F             0312*  
040C8F             0313*  @y_zero:
040C8F F1          0314*      pop af ; sign of x
040C90 FA 95 0C 04 0315*      jp m,@y_zero_x_neg
040C94             0316*  ; y zero,x pos
040C94             0317*  ; angle is 90,nothing to do
040C94 C9          0318*      ret
040C95             0319*  @y_zero_x_neg:
040C95             0320*  ; y zero ,x neg
040C95             0321*  ; angle is 270
040C95 21 00 C0 00 0322*      ld hl,0x00C000
040C99 C9          0323*      ret
040C9A             0324*  @zero_hlu:
040C9A AF          0325*      xor a
040C9B 22 A8 0C 04 0326*      ld (@scratch),hl
040C9F 32 AA 0C 04 0327*      ld (@scratch+2),a
040CA3 2A A8 0C 04 0328*      ld hl,(@scratch)
040CA7 C9          0329*      ret
040CA8             0330*  @scratch: ds 6
040CAE             0331*  
040CAE             0332*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040CAE             0333*  ; output: uh.l is the 16.8 fixed format angle
040CAE             0334*  ; destroys: a,hl,bc,de
040CAE             0335*  ; the following note was written by github copilot:
040CAE             0336*  ; note: this routine is a bit of a hack
040CAE             0337*  ;      but it works
040CAE             0338*  ;      and it's fast
040CAE             0339*  ;      and it's small
040CAE             0340*  ;      and it's accurate
040CAE             0341*  ;      and it's easy to understand
040CAE             0342*  ;      and it's easy to modify
040CAE             0343*  ;      and it's easy to use
040CAE             0344*  ;      and it's easy to remember
040CAE             0345*  ;      and it's easy to love
040CAE             0346*  ;      and it's easy to hate
040CAE             0347*  ;      and it's easy to ignore
040CAE             0348*  ;      and it's easy to forget
040CAE             0349*  ;      and it's easy to remember
040CAE             0350*  ;      and it's easy to forget
040CAE             0351*  ;      and it's easy to remember
040CAE             0352*  ;      (ok the bot is stuck in a loop)
040CAE             0353*  ; REAL NOTE: only works for angles from 0 to 45 degrees
040CAE             0354*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
040CAE             0355*  atan_168fast:
040CAE             0356*  ; because we use compass headings instead of geometric angles
040CAE             0357*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040CAE             0358*  ; we can do faster unsigned division here because we know dx and dy are positive
040CAE             0359*  ; ; DEBUG
040CAE             0360*  ;     call vdu_home_cursor
040CAE             0361*  ;     call print_s168_hl
040CAE             0362*  ;     call print_s168_de
040CAE             0363*  ; ; END DEBUG
040CAE CD B6 15 04 0364*  	call udiv168 ; ud.e = dx/dy
040CB2 EB          0365*  	ex de,hl ; uh.l = dx/dy
040CB3             0366*  ; ; DEBUG
040CB3             0367*  ; ; 	call vdu_home_cursor
040CB3             0368*  ; 	call printNewLine
040CB3             0369*  ; 	call dumpRegistersHex
040CB3             0370*  ; ; ; END DEBUG
040CB3             0371*  ; ; DEBUG
040CB3             0372*  ;     call print_s168_hl
040CB3             0373*  ; ; END DEBUG
040CB3             0374*  ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
040CB3             0375*  ; test uh.l for 0
040CB3 19          0376*      add hl,de
040CB4 B7          0377*      or a
040CB5 ED 52       0378*      sbc hl,de
040CB7 28 26       0379*      jr z,@is_zero
040CB9             0380*  ; test uh.l for 1
040CB9 AF          0381*      xor a ; clear carry
040CBA EB          0382*      ex de,hl
040CBB 21 00 01 00 0383*      ld hl,0x000100 ; 1 in 16.8 fixed format
040CBF ED 52       0384*      sbc hl,de
040CC1 28 17       0385*      jr z,@is_45
040CC3 EB          0386*  	ex de,hl
040CC4             0387*  ; END TODO
040CC4             0388*  
040CC4             0389*  ; no special cases so we move on
040CC4             0390*  ; l contains the fractional portion of tan(uh.l)
040CC4             0391*  ; we multiply it by three to get our lookup table index
040CC4             0392*  ; ; DEBUG
040CC4             0393*  ; 	call vdu_home_cursor
040CC4             0394*  ; 	call dumpRegistersHex
040CC4             0395*  ; ; END DEBUG
040CC4 26 03       0396*      ld h,3
040CC6 ED 6C       0397*      mlt hl ; gosh that is handy
040CC8 11 00 00 00 0398*      ld de,0 ; clear deu
040CCC 54          0399*      ld d,h ; copy hl to de
040CCD 5D          0400*      ld e,l ; de contains our index
040CCE 21 D2 10 04 0401*      ld hl,atan_lut_168 ; grab the lut address
040CD2 19          0402*      add hl,de ; bump hl by the index
040CD3             0403*  ; DEBUG
040CD3 CD 26 04 04 0404*  	call dumpRegistersHex
040CD7             0405*  ; END DEBUG
040CD7             0406*  
040CD7 ED 27       0407*      ld hl,(hl) ; don't try this on a z80!
040CD9 C9          0408*      ret ; and out
040CDA             0409*  @is_45:
040CDA 21 00 20 00 0410*      ld hl,0x002000 ; 45 degrees decimal
040CDE C9          0411*      ret
040CDF             0412*  ; for the case tan(0)
040CDF             0413*  @is_zero:
040CDF 21 00 00 00 0414*      ld hl,0x000000
040CE3 C9          0415*      ret
040CE4             0416*  
040CE4             0417*  
040CE4             0418*  ; Expects  ADL mode
040CE4             0419*  ; Inputs:  UH.L
040CE4             0420*  ; Outputs: UH.L is the 16.8 square root
040CE4             0421*  ;          UD.E is the difference inputHL-DE^2
040CE4             0422*  ;          c flag reset
040CE4             0423*  sqrt168:
040CE4 CD EE 0C 04 0424*      call sqrt24
040CE8 EB          0425*      ex de,hl
040CE9 29          0426*      add hl,hl
040CEA 29          0427*      add hl,hl
040CEB 29          0428*      add hl,hl
040CEC 29          0429*      add hl,hl
040CED C9          0430*      ret
040CEE             0431*  
040CEE             0432*  ; Expects  ADL mode
040CEE             0433*  ; Inputs:  HL
040CEE             0434*  ; Outputs: DE is the integer square root
040CEE             0435*  ;          HL is the difference inputHL-DE^2
040CEE             0436*  ;          c flag reset
040CEE             0437*  sqrt24:
040CEE AF          0438*      xor a
040CEF 45          0439*      ld b,l
040CF0 C5          0440*      push bc
040CF1 47          0441*      ld b,a
040CF2 57          0442*      ld d,a
040CF3 4F          0443*      ld c,a
040CF4 6F          0444*      ld l,a
040CF5 5F          0445*      ld e,a
040CF6             0446*  
040CF6             0447*      ;Iteration 1
040CF6 29          0448*      add hl,hl
040CF7 CB 11       0449*      rl c
040CF9 29          0450*      add hl,hl
040CFA CB 11       0451*      rl c
040CFC 91          0452*      sub c
040CFD 30 04       0453*      jr nc,$+6
040CFF 1C          0454*      inc e
040D00 1C          0455*      inc e
040D01 2F          0456*      cpl
040D02 4F          0457*      ld c,a
040D03             0458*  
040D03             0459*      ;Iteration 2
040D03 29          0460*      add hl,hl
040D04 CB 11       0461*      rl c
040D06 29          0462*      add hl,hl
040D07 CB 11       0463*      rl c
040D09 CB 13       0464*      rl e
040D0B 7B          0465*      ld a,e
040D0C 91          0466*      sub c
040D0D 30 04       0467*      jr nc,$+6
040D0F 1C          0468*      inc e
040D10 1C          0469*      inc e
040D11 2F          0470*      cpl
040D12 4F          0471*      ld c,a
040D13             0472*  
040D13             0473*      ;Iteration 3
040D13 29          0474*      add hl,hl
040D14 CB 11       0475*      rl c
040D16 29          0476*      add hl,hl
040D17 CB 11       0477*      rl c
040D19 CB 13       0478*      rl e
040D1B 7B          0479*      ld a,e
040D1C 91          0480*      sub c
040D1D 30 04       0481*      jr nc,$+6
040D1F 1C          0482*      inc e
040D20 1C          0483*      inc e
040D21 2F          0484*      cpl
040D22 4F          0485*      ld c,a
040D23             0486*  
040D23             0487*      ;Iteration 4
040D23 29          0488*      add hl,hl
040D24 CB 11       0489*      rl c
040D26 29          0490*      add hl,hl
040D27 CB 11       0491*      rl c
040D29 CB 13       0492*      rl e
040D2B 7B          0493*      ld a,e
040D2C 91          0494*      sub c
040D2D 30 04       0495*      jr nc,$+6
040D2F 1C          0496*      inc e
040D30 1C          0497*      inc e
040D31 2F          0498*      cpl
040D32 4F          0499*      ld c,a
040D33             0500*  
040D33             0501*      ;Iteration 5
040D33 29          0502*      add hl,hl
040D34 CB 11       0503*      rl c
040D36 29          0504*      add hl,hl
040D37 CB 11       0505*      rl c
040D39 CB 13       0506*      rl e
040D3B 7B          0507*      ld a,e
040D3C 91          0508*      sub c
040D3D 30 04       0509*      jr nc,$+6
040D3F 1C          0510*      inc e
040D40 1C          0511*      inc e
040D41 2F          0512*      cpl
040D42 4F          0513*      ld c,a
040D43             0514*  
040D43             0515*      ;Iteration 6
040D43 29          0516*      add hl,hl
040D44 CB 11       0517*      rl c
040D46 29          0518*      add hl,hl
040D47 CB 11       0519*      rl c
040D49 CB 13       0520*      rl e
040D4B 7B          0521*      ld a,e
040D4C 91          0522*      sub c
040D4D 30 04       0523*      jr nc,$+6
040D4F 1C          0524*      inc e
040D50 1C          0525*      inc e
040D51 2F          0526*      cpl
040D52 4F          0527*      ld c,a
040D53             0528*  
040D53             0529*      ;Iteration 7
040D53 29          0530*      add hl,hl
040D54 CB 11       0531*      rl c
040D56 29          0532*      add hl,hl
040D57 CB 11       0533*      rl c
040D59 CB 10       0534*      rl b
040D5B EB          0535*      ex de,hl
040D5C 29          0536*      add hl,hl
040D5D E5          0537*      push hl
040D5E ED 42       0538*      sbc hl,bc
040D60 30 06       0539*      jr nc,$+8
040D62 7C          0540*      ld a,h
040D63 2F          0541*      cpl
040D64 47          0542*      ld b,a
040D65 7D          0543*      ld a,l
040D66 2F          0544*      cpl
040D67 4F          0545*      ld c,a
040D68 E1          0546*      pop hl
040D69 30 02       0547*      jr nc,$+4
040D6B 23          0548*      inc hl
040D6C 23          0549*      inc hl
040D6D EB          0550*      ex de,hl
040D6E             0551*  
040D6E             0552*      ;Iteration 8
040D6E 29          0553*      add hl,hl
040D6F 69          0554*      ld l,c
040D70 60          0555*      ld h,b
040D71 ED 6A       0556*      adc hl,hl
040D73 ED 6A       0557*      adc hl,hl
040D75 EB          0558*      ex de,hl
040D76 29          0559*      add hl,hl
040D77 ED 52       0560*      sbc hl,de
040D79 19          0561*      add hl,de
040D7A EB          0562*      ex de,hl
040D7B 30 04       0563*      jr nc,$+6
040D7D ED 52       0564*      sbc hl,de
040D7F 13          0565*      inc de
040D80 13          0566*      inc de
040D81             0567*  
040D81             0568*      ;Iteration 9
040D81 F1          0569*      pop af
040D82 17          0570*      rla
040D83 ED 6A       0571*      adc hl,hl
040D85 17          0572*      rla
040D86 ED 6A       0573*      adc hl,hl
040D88 EB          0574*      ex de,hl
040D89 29          0575*      add hl,hl
040D8A ED 52       0576*      sbc hl,de
040D8C 19          0577*      add hl,de
040D8D EB          0578*      ex de,hl
040D8E 30 04       0579*      jr nc,$+6
040D90 ED 52       0580*      sbc hl,de
040D92 13          0581*      inc de
040D93 13          0582*      inc de
040D94             0583*  
040D94             0584*      ;Iteration 10
040D94 17          0585*      rla
040D95 ED 6A       0586*      adc hl,hl
040D97 17          0587*      rla
040D98 ED 6A       0588*      adc hl,hl
040D9A EB          0589*      ex de,hl
040D9B 29          0590*      add hl,hl
040D9C ED 52       0591*      sbc hl,de
040D9E 19          0592*      add hl,de
040D9F EB          0593*      ex de,hl
040DA0 30 04       0594*      jr nc,$+6
040DA2 ED 52       0595*      sbc hl,de
040DA4 13          0596*      inc de
040DA5 13          0597*      inc de
040DA6             0598*  
040DA6             0599*      ;Iteration 11
040DA6 17          0600*      rla
040DA7 ED 6A       0601*      adc hl,hl
040DA9 17          0602*      rla
040DAA ED 6A       0603*      adc hl,hl
040DAC EB          0604*      ex de,hl
040DAD 29          0605*      add hl,hl
040DAE ED 52       0606*      sbc hl,de
040DB0 19          0607*      add hl,de
040DB1 EB          0608*      ex de,hl
040DB2 30 04       0609*      jr nc,$+6
040DB4 ED 52       0610*      sbc hl,de
040DB6 13          0611*      inc de
040DB7 13          0612*      inc de
040DB8             0613*  
040DB8             0614*      ;Iteration 11
040DB8 17          0615*      rla
040DB9 ED 6A       0616*      adc hl,hl
040DBB 17          0617*      rla
040DBC ED 6A       0618*      adc hl,hl
040DBE EB          0619*      ex de,hl
040DBF 29          0620*      add hl,hl
040DC0 ED 52       0621*      sbc hl,de
040DC2 19          0622*      add hl,de
040DC3 EB          0623*      ex de,hl
040DC4 30 04       0624*      jr nc,$+6
040DC6 ED 52       0625*      sbc hl,de
040DC8 13          0626*      inc de
040DC9 13          0627*      inc de
040DCA             0628*  
040DCA CB 1A       0629*      rr d
040DCC CB 1B       0630*      rr e
040DCE C9          0631*      ret
040DCF             0632*  
040DCF             0633*  sin_lut_168:
040DCF 00 00 00    0634*  	dl 0x000000 ; 0.000 00, 0.000
040DD2 06 00 00    0635*  	dl 0x000006 ; 1.406 01, 0.025
040DD5 0C 00 00    0636*  	dl 0x00000C ; 2.813 02, 0.049
040DD8 12 00 00    0637*  	dl 0x000012 ; 4.219 03, 0.074
040DDB 19 00 00    0638*  	dl 0x000019 ; 5.625 04, 0.098
040DDE 1F 00 00    0639*  	dl 0x00001F ; 7.031 05, 0.122
040DE1 25 00 00    0640*  	dl 0x000025 ; 8.438 06, 0.147
040DE4 2B 00 00    0641*  	dl 0x00002B ; 9.844 07, 0.171
040DE7 31 00 00    0642*  	dl 0x000031 ; 11.250 08, 0.195
040DEA 38 00 00    0643*  	dl 0x000038 ; 12.656 09, 0.219
040DED 3E 00 00    0644*  	dl 0x00003E ; 14.063 0A, 0.243
040DF0 44 00 00    0645*  	dl 0x000044 ; 15.469 0B, 0.267
040DF3 4A 00 00    0646*  	dl 0x00004A ; 16.875 0C, 0.290
040DF6 50 00 00    0647*  	dl 0x000050 ; 18.281 0D, 0.314
040DF9 56 00 00    0648*  	dl 0x000056 ; 19.688 0E, 0.337
040DFC 5C 00 00    0649*  	dl 0x00005C ; 21.094 0F, 0.360
040DFF 61 00 00    0650*  	dl 0x000061 ; 22.500 10, 0.383
040E02 67 00 00    0651*  	dl 0x000067 ; 23.906 11, 0.405
040E05 6D 00 00    0652*  	dl 0x00006D ; 25.313 12, 0.428
040E08 73 00 00    0653*  	dl 0x000073 ; 26.719 13, 0.450
040E0B 78 00 00    0654*  	dl 0x000078 ; 28.125 14, 0.471
040E0E 7E 00 00    0655*  	dl 0x00007E ; 29.531 15, 0.493
040E11 83 00 00    0656*  	dl 0x000083 ; 30.938 16, 0.514
040E14 88 00 00    0657*  	dl 0x000088 ; 32.344 17, 0.535
040E17 8E 00 00    0658*  	dl 0x00008E ; 33.750 18, 0.556
040E1A 93 00 00    0659*  	dl 0x000093 ; 35.156 19, 0.576
040E1D 98 00 00    0660*  	dl 0x000098 ; 36.563 1A, 0.596
040E20 9D 00 00    0661*  	dl 0x00009D ; 37.969 1B, 0.615
040E23 A2 00 00    0662*  	dl 0x0000A2 ; 39.375 1C, 0.634
040E26 A7 00 00    0663*  	dl 0x0000A7 ; 40.781 1D, 0.653
040E29 AB 00 00    0664*  	dl 0x0000AB ; 42.188 1E, 0.672
040E2C B0 00 00    0665*  	dl 0x0000B0 ; 43.594 1F, 0.690
040E2F B5 00 00    0666*  	dl 0x0000B5 ; 45.000 20, 0.707
040E32 B9 00 00    0667*  	dl 0x0000B9 ; 46.406 21, 0.724
040E35 BD 00 00    0668*  	dl 0x0000BD ; 47.813 22, 0.741
040E38 C1 00 00    0669*  	dl 0x0000C1 ; 49.219 23, 0.757
040E3B C5 00 00    0670*  	dl 0x0000C5 ; 50.625 24, 0.773
040E3E C9 00 00    0671*  	dl 0x0000C9 ; 52.031 25, 0.788
040E41 CD 00 00    0672*  	dl 0x0000CD ; 53.438 26, 0.803
040E44 D1 00 00    0673*  	dl 0x0000D1 ; 54.844 27, 0.818
040E47 D4 00 00    0674*  	dl 0x0000D4 ; 56.250 28, 0.831
040E4A D8 00 00    0675*  	dl 0x0000D8 ; 57.656 29, 0.845
040E4D DB 00 00    0676*  	dl 0x0000DB ; 59.063 2A, 0.858
040E50 DE 00 00    0677*  	dl 0x0000DE ; 60.469 2B, 0.870
040E53 E1 00 00    0678*  	dl 0x0000E1 ; 61.875 2C, 0.882
040E56 E4 00 00    0679*  	dl 0x0000E4 ; 63.281 2D, 0.893
040E59 E7 00 00    0680*  	dl 0x0000E7 ; 64.688 2E, 0.904
040E5C EA 00 00    0681*  	dl 0x0000EA ; 66.094 2F, 0.914
040E5F EC 00 00    0682*  	dl 0x0000EC ; 67.500 30, 0.924
040E62 EE 00 00    0683*  	dl 0x0000EE ; 68.906 31, 0.933
040E65 F1 00 00    0684*  	dl 0x0000F1 ; 70.313 32, 0.942
040E68 F3 00 00    0685*  	dl 0x0000F3 ; 71.719 33, 0.950
040E6B F4 00 00    0686*  	dl 0x0000F4 ; 73.125 34, 0.957
040E6E F6 00 00    0687*  	dl 0x0000F6 ; 74.531 35, 0.964
040E71 F8 00 00    0688*  	dl 0x0000F8 ; 75.938 36, 0.970
040E74 F9 00 00    0689*  	dl 0x0000F9 ; 77.344 37, 0.976
040E77 FB 00 00    0690*  	dl 0x0000FB ; 78.750 38, 0.981
040E7A FC 00 00    0691*  	dl 0x0000FC ; 80.156 39, 0.985
040E7D FD 00 00    0692*  	dl 0x0000FD ; 81.563 3A, 0.989
040E80 FE 00 00    0693*  	dl 0x0000FE ; 82.969 3B, 0.992
040E83 FE 00 00    0694*  	dl 0x0000FE ; 84.375 3C, 0.995
040E86 FF 00 00    0695*  	dl 0x0000FF ; 85.781 3D, 0.997
040E89 FF 00 00    0696*  	dl 0x0000FF ; 87.188 3E, 0.999
040E8C FF 00 00    0697*  	dl 0x0000FF ; 88.594 3F, 1.000
040E8F 00 01 00    0698*  	dl 0x000100 ; 90.000 40, 1.000
040E92 FF 00 00    0699*  	dl 0x0000FF ; 91.406 41, 1.000
040E95 FF 00 00    0700*  	dl 0x0000FF ; 92.813 42, 0.999
040E98 FF 00 00    0701*  	dl 0x0000FF ; 94.219 43, 0.997
040E9B FE 00 00    0702*  	dl 0x0000FE ; 95.625 44, 0.995
040E9E FE 00 00    0703*  	dl 0x0000FE ; 97.031 45, 0.992
040EA1 FD 00 00    0704*  	dl 0x0000FD ; 98.438 46, 0.989
040EA4 FC 00 00    0705*  	dl 0x0000FC ; 99.844 47, 0.985
040EA7 FB 00 00    0706*  	dl 0x0000FB ; 101.250 48, 0.981
040EAA F9 00 00    0707*  	dl 0x0000F9 ; 102.656 49, 0.976
040EAD F8 00 00    0708*  	dl 0x0000F8 ; 104.063 4A, 0.970
040EB0 F6 00 00    0709*  	dl 0x0000F6 ; 105.469 4B, 0.964
040EB3 F4 00 00    0710*  	dl 0x0000F4 ; 106.875 4C, 0.957
040EB6 F3 00 00    0711*  	dl 0x0000F3 ; 108.281 4D, 0.950
040EB9 F1 00 00    0712*  	dl 0x0000F1 ; 109.688 4E, 0.942
040EBC EE 00 00    0713*  	dl 0x0000EE ; 111.094 4F, 0.933
040EBF EC 00 00    0714*  	dl 0x0000EC ; 112.500 50, 0.924
040EC2 EA 00 00    0715*  	dl 0x0000EA ; 113.906 51, 0.914
040EC5 E7 00 00    0716*  	dl 0x0000E7 ; 115.313 52, 0.904
040EC8 E4 00 00    0717*  	dl 0x0000E4 ; 116.719 53, 0.893
040ECB E1 00 00    0718*  	dl 0x0000E1 ; 118.125 54, 0.882
040ECE DE 00 00    0719*  	dl 0x0000DE ; 119.531 55, 0.870
040ED1 DB 00 00    0720*  	dl 0x0000DB ; 120.938 56, 0.858
040ED4 D8 00 00    0721*  	dl 0x0000D8 ; 122.344 57, 0.845
040ED7 D4 00 00    0722*  	dl 0x0000D4 ; 123.750 58, 0.831
040EDA D1 00 00    0723*  	dl 0x0000D1 ; 125.156 59, 0.818
040EDD CD 00 00    0724*  	dl 0x0000CD ; 126.563 5A, 0.803
040EE0 C9 00 00    0725*  	dl 0x0000C9 ; 127.969 5B, 0.788
040EE3 C5 00 00    0726*  	dl 0x0000C5 ; 129.375 5C, 0.773
040EE6 C1 00 00    0727*  	dl 0x0000C1 ; 130.781 5D, 0.757
040EE9 BD 00 00    0728*  	dl 0x0000BD ; 132.188 5E, 0.741
040EEC B9 00 00    0729*  	dl 0x0000B9 ; 133.594 5F, 0.724
040EEF B5 00 00    0730*  	dl 0x0000B5 ; 135.000 60, 0.707
040EF2 B0 00 00    0731*  	dl 0x0000B0 ; 136.406 61, 0.690
040EF5 AB 00 00    0732*  	dl 0x0000AB ; 137.813 62, 0.672
040EF8 A7 00 00    0733*  	dl 0x0000A7 ; 139.219 63, 0.653
040EFB A2 00 00    0734*  	dl 0x0000A2 ; 140.625 64, 0.634
040EFE 9D 00 00    0735*  	dl 0x00009D ; 142.031 65, 0.615
040F01 98 00 00    0736*  	dl 0x000098 ; 143.438 66, 0.596
040F04 93 00 00    0737*  	dl 0x000093 ; 144.844 67, 0.576
040F07 8E 00 00    0738*  	dl 0x00008E ; 146.250 68, 0.556
040F0A 88 00 00    0739*  	dl 0x000088 ; 147.656 69, 0.535
040F0D 83 00 00    0740*  	dl 0x000083 ; 149.063 6A, 0.514
040F10 7E 00 00    0741*  	dl 0x00007E ; 150.469 6B, 0.493
040F13 78 00 00    0742*  	dl 0x000078 ; 151.875 6C, 0.471
040F16 73 00 00    0743*  	dl 0x000073 ; 153.281 6D, 0.450
040F19 6D 00 00    0744*  	dl 0x00006D ; 154.688 6E, 0.428
040F1C 67 00 00    0745*  	dl 0x000067 ; 156.094 6F, 0.405
040F1F 61 00 00    0746*  	dl 0x000061 ; 157.500 70, 0.383
040F22 5C 00 00    0747*  	dl 0x00005C ; 158.906 71, 0.360
040F25 56 00 00    0748*  	dl 0x000056 ; 160.313 72, 0.337
040F28 50 00 00    0749*  	dl 0x000050 ; 161.719 73, 0.314
040F2B 4A 00 00    0750*  	dl 0x00004A ; 163.125 74, 0.290
040F2E 44 00 00    0751*  	dl 0x000044 ; 164.531 75, 0.267
040F31 3E 00 00    0752*  	dl 0x00003E ; 165.938 76, 0.243
040F34 38 00 00    0753*  	dl 0x000038 ; 167.344 77, 0.219
040F37 31 00 00    0754*  	dl 0x000031 ; 168.750 78, 0.195
040F3A 2B 00 00    0755*  	dl 0x00002B ; 170.156 79, 0.171
040F3D 25 00 00    0756*  	dl 0x000025 ; 171.563 7A, 0.147
040F40 1F 00 00    0757*  	dl 0x00001F ; 172.969 7B, 0.122
040F43 19 00 00    0758*  	dl 0x000019 ; 174.375 7C, 0.098
040F46 12 00 00    0759*  	dl 0x000012 ; 175.781 7D, 0.074
040F49 0C 00 00    0760*  	dl 0x00000C ; 177.188 7E, 0.049
040F4C 06 00 00    0761*  	dl 0x000006 ; 178.594 7F, 0.025
040F4F 00 00 00    0762*  	dl 0x000000 ; 180.000 80, 0.000
040F52 FA FF FF    0763*  	dl 0xFFFFFA ; 181.406 81, -0.025
040F55 F4 FF FF    0764*  	dl 0xFFFFF4 ; 182.813 82, -0.049
040F58 EE FF FF    0765*  	dl 0xFFFFEE ; 184.219 83, -0.074
040F5B E7 FF FF    0766*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040F5E E1 FF FF    0767*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040F61 DB FF FF    0768*  	dl 0xFFFFDB ; 188.438 86, -0.147
040F64 D5 FF FF    0769*  	dl 0xFFFFD5 ; 189.844 87, -0.171
040F67 CF FF FF    0770*  	dl 0xFFFFCF ; 191.250 88, -0.195
040F6A C8 FF FF    0771*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040F6D C2 FF FF    0772*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040F70 BC FF FF    0773*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040F73 B6 FF FF    0774*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040F76 B0 FF FF    0775*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
040F79 AA FF FF    0776*  	dl 0xFFFFAA ; 199.688 8E, -0.337
040F7C A4 FF FF    0777*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040F7F 9F FF FF    0778*  	dl 0xFFFF9F ; 202.500 90, -0.383
040F82 99 FF FF    0779*  	dl 0xFFFF99 ; 203.906 91, -0.405
040F85 93 FF FF    0780*  	dl 0xFFFF93 ; 205.313 92, -0.428
040F88 8D FF FF    0781*  	dl 0xFFFF8D ; 206.719 93, -0.450
040F8B 88 FF FF    0782*  	dl 0xFFFF88 ; 208.125 94, -0.471
040F8E 82 FF FF    0783*  	dl 0xFFFF82 ; 209.531 95, -0.493
040F91 7D FF FF    0784*  	dl 0xFFFF7D ; 210.938 96, -0.514
040F94 78 FF FF    0785*  	dl 0xFFFF78 ; 212.344 97, -0.535
040F97 72 FF FF    0786*  	dl 0xFFFF72 ; 213.750 98, -0.556
040F9A 6D FF FF    0787*  	dl 0xFFFF6D ; 215.156 99, -0.576
040F9D 68 FF FF    0788*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040FA0 63 FF FF    0789*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040FA3 5E FF FF    0790*  	dl 0xFFFF5E ; 219.375 9C, -0.634
040FA6 59 FF FF    0791*  	dl 0xFFFF59 ; 220.781 9D, -0.653
040FA9 55 FF FF    0792*  	dl 0xFFFF55 ; 222.188 9E, -0.672
040FAC 50 FF FF    0793*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040FAF 4B FF FF    0794*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040FB2 47 FF FF    0795*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040FB5 43 FF FF    0796*  	dl 0xFFFF43 ; 227.813 A2, -0.741
040FB8 3F FF FF    0797*  	dl 0xFFFF3F ; 229.219 A3, -0.757
040FBB 3B FF FF    0798*  	dl 0xFFFF3B ; 230.625 A4, -0.773
040FBE 37 FF FF    0799*  	dl 0xFFFF37 ; 232.031 A5, -0.788
040FC1 33 FF FF    0800*  	dl 0xFFFF33 ; 233.438 A6, -0.803
040FC4 2F FF FF    0801*  	dl 0xFFFF2F ; 234.844 A7, -0.818
040FC7 2C FF FF    0802*  	dl 0xFFFF2C ; 236.250 A8, -0.831
040FCA 28 FF FF    0803*  	dl 0xFFFF28 ; 237.656 A9, -0.845
040FCD 25 FF FF    0804*  	dl 0xFFFF25 ; 239.063 AA, -0.858
040FD0 22 FF FF    0805*  	dl 0xFFFF22 ; 240.469 AB, -0.870
040FD3 1F FF FF    0806*  	dl 0xFFFF1F ; 241.875 AC, -0.882
040FD6 1C FF FF    0807*  	dl 0xFFFF1C ; 243.281 AD, -0.893
040FD9 19 FF FF    0808*  	dl 0xFFFF19 ; 244.688 AE, -0.904
040FDC 16 FF FF    0809*  	dl 0xFFFF16 ; 246.094 AF, -0.914
040FDF 14 FF FF    0810*  	dl 0xFFFF14 ; 247.500 B0, -0.924
040FE2 12 FF FF    0811*  	dl 0xFFFF12 ; 248.906 B1, -0.933
040FE5 0F FF FF    0812*  	dl 0xFFFF0F ; 250.313 B2, -0.942
040FE8 0D FF FF    0813*  	dl 0xFFFF0D ; 251.719 B3, -0.950
040FEB 0C FF FF    0814*  	dl 0xFFFF0C ; 253.125 B4, -0.957
040FEE 0A FF FF    0815*  	dl 0xFFFF0A ; 254.531 B5, -0.964
040FF1 08 FF FF    0816*  	dl 0xFFFF08 ; 255.938 B6, -0.970
040FF4 07 FF FF    0817*  	dl 0xFFFF07 ; 257.344 B7, -0.976
040FF7 05 FF FF    0818*  	dl 0xFFFF05 ; 258.750 B8, -0.981
040FFA 04 FF FF    0819*  	dl 0xFFFF04 ; 260.156 B9, -0.985
040FFD 03 FF FF    0820*  	dl 0xFFFF03 ; 261.563 BA, -0.989
041000 02 FF FF    0821*  	dl 0xFFFF02 ; 262.969 BB, -0.992
041003 02 FF FF    0822*  	dl 0xFFFF02 ; 264.375 BC, -0.995
041006 01 FF FF    0823*  	dl 0xFFFF01 ; 265.781 BD, -0.997
041009 01 FF FF    0824*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04100C 01 FF FF    0825*  	dl 0xFFFF01 ; 268.594 BF, -1.000
04100F 00 FF FF    0826*  	dl 0xFFFF00 ; 270.000 C0, -1.000
041012 01 FF FF    0827*  	dl 0xFFFF01 ; 271.406 C1, -1.000
041015 01 FF FF    0828*  	dl 0xFFFF01 ; 272.813 C2, -0.999
041018 01 FF FF    0829*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04101B 02 FF FF    0830*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04101E 02 FF FF    0831*  	dl 0xFFFF02 ; 277.031 C5, -0.992
041021 03 FF FF    0832*  	dl 0xFFFF03 ; 278.438 C6, -0.989
041024 04 FF FF    0833*  	dl 0xFFFF04 ; 279.844 C7, -0.985
041027 05 FF FF    0834*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04102A 07 FF FF    0835*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04102D 08 FF FF    0836*  	dl 0xFFFF08 ; 284.063 CA, -0.970
041030 0A FF FF    0837*  	dl 0xFFFF0A ; 285.469 CB, -0.964
041033 0C FF FF    0838*  	dl 0xFFFF0C ; 286.875 CC, -0.957
041036 0D FF FF    0839*  	dl 0xFFFF0D ; 288.281 CD, -0.950
041039 0F FF FF    0840*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04103C 12 FF FF    0841*  	dl 0xFFFF12 ; 291.094 CF, -0.933
04103F 14 FF FF    0842*  	dl 0xFFFF14 ; 292.500 D0, -0.924
041042 16 FF FF    0843*  	dl 0xFFFF16 ; 293.906 D1, -0.914
041045 19 FF FF    0844*  	dl 0xFFFF19 ; 295.313 D2, -0.904
041048 1C FF FF    0845*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04104B 1F FF FF    0846*  	dl 0xFFFF1F ; 298.125 D4, -0.882
04104E 22 FF FF    0847*  	dl 0xFFFF22 ; 299.531 D5, -0.870
041051 25 FF FF    0848*  	dl 0xFFFF25 ; 300.938 D6, -0.858
041054 28 FF FF    0849*  	dl 0xFFFF28 ; 302.344 D7, -0.845
041057 2C FF FF    0850*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04105A 2F FF FF    0851*  	dl 0xFFFF2F ; 305.156 D9, -0.818
04105D 33 FF FF    0852*  	dl 0xFFFF33 ; 306.563 DA, -0.803
041060 37 FF FF    0853*  	dl 0xFFFF37 ; 307.969 DB, -0.788
041063 3B FF FF    0854*  	dl 0xFFFF3B ; 309.375 DC, -0.773
041066 3F FF FF    0855*  	dl 0xFFFF3F ; 310.781 DD, -0.757
041069 43 FF FF    0856*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04106C 47 FF FF    0857*  	dl 0xFFFF47 ; 313.594 DF, -0.724
04106F 4B FF FF    0858*  	dl 0xFFFF4B ; 315.000 E0, -0.707
041072 50 FF FF    0859*  	dl 0xFFFF50 ; 316.406 E1, -0.690
041075 55 FF FF    0860*  	dl 0xFFFF55 ; 317.813 E2, -0.672
041078 59 FF FF    0861*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04107B 5E FF FF    0862*  	dl 0xFFFF5E ; 320.625 E4, -0.634
04107E 63 FF FF    0863*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041081 68 FF FF    0864*  	dl 0xFFFF68 ; 323.438 E6, -0.596
041084 6D FF FF    0865*  	dl 0xFFFF6D ; 324.844 E7, -0.576
041087 72 FF FF    0866*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04108A 78 FF FF    0867*  	dl 0xFFFF78 ; 327.656 E9, -0.535
04108D 7D FF FF    0868*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041090 82 FF FF    0869*  	dl 0xFFFF82 ; 330.469 EB, -0.493
041093 88 FF FF    0870*  	dl 0xFFFF88 ; 331.875 EC, -0.471
041096 8D FF FF    0871*  	dl 0xFFFF8D ; 333.281 ED, -0.450
041099 93 FF FF    0872*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04109C 99 FF FF    0873*  	dl 0xFFFF99 ; 336.094 EF, -0.405
04109F 9F FF FF    0874*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0410A2 A4 FF FF    0875*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0410A5 AA FF FF    0876*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0410A8 B0 FF FF    0877*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0410AB B6 FF FF    0878*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0410AE BC FF FF    0879*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0410B1 C2 FF FF    0880*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0410B4 C8 FF FF    0881*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0410B7 CF FF FF    0882*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0410BA D5 FF FF    0883*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0410BD DB FF FF    0884*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0410C0 E1 FF FF    0885*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0410C3 E7 FF FF    0886*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0410C6 EE FF FF    0887*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0410C9 F4 FF FF    0888*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0410CC FA FF FF    0889*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0410CF 00 00 00    0890*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0410D2             0891*  
0410D2             0892*  atan_lut_168:
0410D2 00 00 00    0893*  	dl 0x000000 ; 000000, 0.000
0410D5 28 00 00    0894*  	dl 0x000028 ; 000001, 0.224
0410D8 51 00 00    0895*  	dl 0x000051 ; 000002, 0.448
0410DB 7A 00 00    0896*  	dl 0x00007A ; 000003, 0.671
0410DE A2 00 00    0897*  	dl 0x0000A2 ; 000004, 0.895
0410E1 CB 00 00    0898*  	dl 0x0000CB ; 000005, 1.119
0410E4 F4 00 00    0899*  	dl 0x0000F4 ; 000006, 1.343
0410E7 1D 01 00    0900*  	dl 0x00011D ; 000007, 1.566
0410EA 45 01 00    0901*  	dl 0x000145 ; 000008, 1.790
0410ED 6E 01 00    0902*  	dl 0x00016E ; 000009, 2.013
0410F0 97 01 00    0903*  	dl 0x000197 ; 00000A, 2.237
0410F3 BF 01 00    0904*  	dl 0x0001BF ; 00000B, 2.460
0410F6 E8 01 00    0905*  	dl 0x0001E8 ; 00000C, 2.684
0410F9 11 02 00    0906*  	dl 0x000211 ; 00000D, 2.907
0410FC 39 02 00    0907*  	dl 0x000239 ; 00000E, 3.130
0410FF 62 02 00    0908*  	dl 0x000262 ; 00000F, 3.353
041102 8B 02 00    0909*  	dl 0x00028B ; 000010, 3.576
041105 B3 02 00    0910*  	dl 0x0002B3 ; 000011, 3.799
041108 DC 02 00    0911*  	dl 0x0002DC ; 000012, 4.022
04110B 04 03 00    0912*  	dl 0x000304 ; 000013, 4.245
04110E 2D 03 00    0913*  	dl 0x00032D ; 000014, 4.467
041111 55 03 00    0914*  	dl 0x000355 ; 000015, 4.690
041114 7E 03 00    0915*  	dl 0x00037E ; 000016, 4.912
041117 A6 03 00    0916*  	dl 0x0003A6 ; 000017, 5.134
04111A CE 03 00    0917*  	dl 0x0003CE ; 000018, 5.356
04111D F7 03 00    0918*  	dl 0x0003F7 ; 000019, 5.578
041120 1F 04 00    0919*  	dl 0x00041F ; 00001A, 5.799
041123 48 04 00    0920*  	dl 0x000448 ; 00001B, 6.021
041126 70 04 00    0921*  	dl 0x000470 ; 00001C, 6.242
041129 98 04 00    0922*  	dl 0x000498 ; 00001D, 6.463
04112C C0 04 00    0923*  	dl 0x0004C0 ; 00001E, 6.684
04112F E8 04 00    0924*  	dl 0x0004E8 ; 00001F, 6.905
041132 11 05 00    0925*  	dl 0x000511 ; 000020, 7.125
041135 39 05 00    0926*  	dl 0x000539 ; 000021, 7.345
041138 61 05 00    0927*  	dl 0x000561 ; 000022, 7.565
04113B 89 05 00    0928*  	dl 0x000589 ; 000023, 7.785
04113E B1 05 00    0929*  	dl 0x0005B1 ; 000024, 8.005
041141 D9 05 00    0930*  	dl 0x0005D9 ; 000025, 8.224
041144 01 06 00    0931*  	dl 0x000601 ; 000026, 8.443
041147 28 06 00    0932*  	dl 0x000628 ; 000027, 8.662
04114A 50 06 00    0933*  	dl 0x000650 ; 000028, 8.881
04114D 78 06 00    0934*  	dl 0x000678 ; 000029, 9.099
041150 A0 06 00    0935*  	dl 0x0006A0 ; 00002A, 9.317
041153 C7 06 00    0936*  	dl 0x0006C7 ; 00002B, 9.535
041156 EF 06 00    0937*  	dl 0x0006EF ; 00002C, 9.752
041159 16 07 00    0938*  	dl 0x000716 ; 00002D, 9.970
04115C 3E 07 00    0939*  	dl 0x00073E ; 00002E, 10.187
04115F 65 07 00    0940*  	dl 0x000765 ; 00002F, 10.403
041162 8D 07 00    0941*  	dl 0x00078D ; 000030, 10.620
041165 B4 07 00    0942*  	dl 0x0007B4 ; 000031, 10.836
041168 DB 07 00    0943*  	dl 0x0007DB ; 000032, 11.051
04116B 03 08 00    0944*  	dl 0x000803 ; 000033, 11.267
04116E 2A 08 00    0945*  	dl 0x00082A ; 000034, 11.482
041171 51 08 00    0946*  	dl 0x000851 ; 000035, 11.697
041174 78 08 00    0947*  	dl 0x000878 ; 000036, 11.911
041177 9F 08 00    0948*  	dl 0x00089F ; 000037, 12.125
04117A C6 08 00    0949*  	dl 0x0008C6 ; 000038, 12.339
04117D ED 08 00    0950*  	dl 0x0008ED ; 000039, 12.553
041180 13 09 00    0951*  	dl 0x000913 ; 00003A, 12.766
041183 3A 09 00    0952*  	dl 0x00093A ; 00003B, 12.978
041186 61 09 00    0953*  	dl 0x000961 ; 00003C, 13.191
041189 87 09 00    0954*  	dl 0x000987 ; 00003D, 13.403
04118C AE 09 00    0955*  	dl 0x0009AE ; 00003E, 13.614
04118F D4 09 00    0956*  	dl 0x0009D4 ; 00003F, 13.825
041192 FB 09 00    0957*  	dl 0x0009FB ; 000040, 14.036
041195 21 0A 00    0958*  	dl 0x000A21 ; 000041, 14.247
041198 47 0A 00    0959*  	dl 0x000A47 ; 000042, 14.457
04119B 6D 0A 00    0960*  	dl 0x000A6D ; 000043, 14.666
04119E 94 0A 00    0961*  	dl 0x000A94 ; 000044, 14.876
0411A1 BA 0A 00    0962*  	dl 0x000ABA ; 000045, 15.085
0411A4 E0 0A 00    0963*  	dl 0x000AE0 ; 000046, 15.293
0411A7 05 0B 00    0964*  	dl 0x000B05 ; 000047, 15.501
0411AA 2B 0B 00    0965*  	dl 0x000B2B ; 000048, 15.709
0411AD 51 0B 00    0966*  	dl 0x000B51 ; 000049, 15.916
0411B0 77 0B 00    0967*  	dl 0x000B77 ; 00004A, 16.123
0411B3 9C 0B 00    0968*  	dl 0x000B9C ; 00004B, 16.329
0411B6 C2 0B 00    0969*  	dl 0x000BC2 ; 00004C, 16.535
0411B9 E7 0B 00    0970*  	dl 0x000BE7 ; 00004D, 16.740
0411BC 0C 0C 00    0971*  	dl 0x000C0C ; 00004E, 16.945
0411BF 32 0C 00    0972*  	dl 0x000C32 ; 00004F, 17.150
0411C2 57 0C 00    0973*  	dl 0x000C57 ; 000050, 17.354
0411C5 7C 0C 00    0974*  	dl 0x000C7C ; 000051, 17.558
0411C8 A1 0C 00    0975*  	dl 0x000CA1 ; 000052, 17.761
0411CB C6 0C 00    0976*  	dl 0x000CC6 ; 000053, 17.964
0411CE EB 0C 00    0977*  	dl 0x000CEB ; 000054, 18.166
0411D1 0F 0D 00    0978*  	dl 0x000D0F ; 000055, 18.368
0411D4 34 0D 00    0979*  	dl 0x000D34 ; 000056, 18.569
0411D7 58 0D 00    0980*  	dl 0x000D58 ; 000057, 18.770
0411DA 7D 0D 00    0981*  	dl 0x000D7D ; 000058, 18.970
0411DD A1 0D 00    0982*  	dl 0x000DA1 ; 000059, 19.170
0411E0 C6 0D 00    0983*  	dl 0x000DC6 ; 00005A, 19.370
0411E3 EA 0D 00    0984*  	dl 0x000DEA ; 00005B, 19.569
0411E6 0E 0E 00    0985*  	dl 0x000E0E ; 00005C, 19.767
0411E9 32 0E 00    0986*  	dl 0x000E32 ; 00005D, 19.965
0411EC 56 0E 00    0987*  	dl 0x000E56 ; 00005E, 20.163
0411EF 7A 0E 00    0988*  	dl 0x000E7A ; 00005F, 20.360
0411F2 9E 0E 00    0989*  	dl 0x000E9E ; 000060, 20.556
0411F5 C1 0E 00    0990*  	dl 0x000EC1 ; 000061, 20.752
0411F8 E5 0E 00    0991*  	dl 0x000EE5 ; 000062, 20.947
0411FB 08 0F 00    0992*  	dl 0x000F08 ; 000063, 21.142
0411FE 2C 0F 00    0993*  	dl 0x000F2C ; 000064, 21.337
041201 4F 0F 00    0994*  	dl 0x000F4F ; 000065, 21.531
041204 72 0F 00    0995*  	dl 0x000F72 ; 000066, 21.724
041207 95 0F 00    0996*  	dl 0x000F95 ; 000067, 21.917
04120A B8 0F 00    0997*  	dl 0x000FB8 ; 000068, 22.109
04120D DB 0F 00    0998*  	dl 0x000FDB ; 000069, 22.301
041210 FE 0F 00    0999*  	dl 0x000FFE ; 00006A, 22.493
041213 21 10 00    1000*  	dl 0x001021 ; 00006B, 22.683
041216 44 10 00    1001*  	dl 0x001044 ; 00006C, 22.874
041219 66 10 00    1002*  	dl 0x001066 ; 00006D, 23.063
04121C 89 10 00    1003*  	dl 0x001089 ; 00006E, 23.253
04121F AB 10 00    1004*  	dl 0x0010AB ; 00006F, 23.441
041222 CD 10 00    1005*  	dl 0x0010CD ; 000070, 23.629
041225 EF 10 00    1006*  	dl 0x0010EF ; 000071, 23.817
041228 11 11 00    1007*  	dl 0x001111 ; 000072, 24.004
04122B 33 11 00    1008*  	dl 0x001133 ; 000073, 24.191
04122E 55 11 00    1009*  	dl 0x001155 ; 000074, 24.376
041231 77 11 00    1010*  	dl 0x001177 ; 000075, 24.562
041234 99 11 00    1011*  	dl 0x001199 ; 000076, 24.747
041237 BA 11 00    1012*  	dl 0x0011BA ; 000077, 24.931
04123A DC 11 00    1013*  	dl 0x0011DC ; 000078, 25.115
04123D FD 11 00    1014*  	dl 0x0011FD ; 000079, 25.298
041240 1E 12 00    1015*  	dl 0x00121E ; 00007A, 25.481
041243 3F 12 00    1016*  	dl 0x00123F ; 00007B, 25.663
041246 60 12 00    1017*  	dl 0x001260 ; 00007C, 25.844
041249 81 12 00    1018*  	dl 0x001281 ; 00007D, 26.025
04124C A2 12 00    1019*  	dl 0x0012A2 ; 00007E, 26.206
04124F C3 12 00    1020*  	dl 0x0012C3 ; 00007F, 26.386
041252 E4 12 00    1021*  	dl 0x0012E4 ; 000080, 26.565
041255 04 13 00    1022*  	dl 0x001304 ; 000081, 26.744
041258 25 13 00    1023*  	dl 0x001325 ; 000082, 26.922
04125B 45 13 00    1024*  	dl 0x001345 ; 000083, 27.100
04125E 65 13 00    1025*  	dl 0x001365 ; 000084, 27.277
041261 85 13 00    1026*  	dl 0x001385 ; 000085, 27.453
041264 A5 13 00    1027*  	dl 0x0013A5 ; 000086, 27.629
041267 C5 13 00    1028*  	dl 0x0013C5 ; 000087, 27.805
04126A E5 13 00    1029*  	dl 0x0013E5 ; 000088, 27.979
04126D 05 14 00    1030*  	dl 0x001405 ; 000089, 28.154
041270 24 14 00    1031*  	dl 0x001424 ; 00008A, 28.327
041273 44 14 00    1032*  	dl 0x001444 ; 00008B, 28.501
041276 63 14 00    1033*  	dl 0x001463 ; 00008C, 28.673
041279 83 14 00    1034*  	dl 0x001483 ; 00008D, 28.845
04127C A2 14 00    1035*  	dl 0x0014A2 ; 00008E, 29.017
04127F C1 14 00    1036*  	dl 0x0014C1 ; 00008F, 29.187
041282 E0 14 00    1037*  	dl 0x0014E0 ; 000090, 29.358
041285 FF 14 00    1038*  	dl 0x0014FF ; 000091, 29.527
041288 1E 15 00    1039*  	dl 0x00151E ; 000092, 29.697
04128B 3C 15 00    1040*  	dl 0x00153C ; 000093, 29.865
04128E 5B 15 00    1041*  	dl 0x00155B ; 000094, 30.033
041291 79 15 00    1042*  	dl 0x001579 ; 000095, 30.201
041294 98 15 00    1043*  	dl 0x001598 ; 000096, 30.368
041297 B6 15 00    1044*  	dl 0x0015B6 ; 000097, 30.534
04129A D4 15 00    1045*  	dl 0x0015D4 ; 000098, 30.700
04129D F2 15 00    1046*  	dl 0x0015F2 ; 000099, 30.865
0412A0 10 16 00    1047*  	dl 0x001610 ; 00009A, 31.030
0412A3 2E 16 00    1048*  	dl 0x00162E ; 00009B, 31.194
0412A6 4C 16 00    1049*  	dl 0x00164C ; 00009C, 31.357
0412A9 6A 16 00    1050*  	dl 0x00166A ; 00009D, 31.520
0412AC 87 16 00    1051*  	dl 0x001687 ; 00009E, 31.682
0412AF A5 16 00    1052*  	dl 0x0016A5 ; 00009F, 31.844
0412B2 C2 16 00    1053*  	dl 0x0016C2 ; 0000A0, 32.005
0412B5 DF 16 00    1054*  	dl 0x0016DF ; 0000A1, 32.166
0412B8 FC 16 00    1055*  	dl 0x0016FC ; 0000A2, 32.326
0412BB 19 17 00    1056*  	dl 0x001719 ; 0000A3, 32.486
0412BE 36 17 00    1057*  	dl 0x001736 ; 0000A4, 32.645
0412C1 53 17 00    1058*  	dl 0x001753 ; 0000A5, 32.803
0412C4 70 17 00    1059*  	dl 0x001770 ; 0000A6, 32.961
0412C7 8C 17 00    1060*  	dl 0x00178C ; 0000A7, 33.118
0412CA A9 17 00    1061*  	dl 0x0017A9 ; 0000A8, 33.275
0412CD C5 17 00    1062*  	dl 0x0017C5 ; 0000A9, 33.431
0412D0 E2 17 00    1063*  	dl 0x0017E2 ; 0000AA, 33.587
0412D3 FE 17 00    1064*  	dl 0x0017FE ; 0000AB, 33.742
0412D6 1A 18 00    1065*  	dl 0x00181A ; 0000AC, 33.896
0412D9 36 18 00    1066*  	dl 0x001836 ; 0000AD, 34.050
0412DC 52 18 00    1067*  	dl 0x001852 ; 0000AE, 34.203
0412DF 6E 18 00    1068*  	dl 0x00186E ; 0000AF, 34.356
0412E2 8A 18 00    1069*  	dl 0x00188A ; 0000B0, 34.509
0412E5 A5 18 00    1070*  	dl 0x0018A5 ; 0000B1, 34.660
0412E8 C1 18 00    1071*  	dl 0x0018C1 ; 0000B2, 34.811
0412EB DC 18 00    1072*  	dl 0x0018DC ; 0000B3, 34.962
0412EE F7 18 00    1073*  	dl 0x0018F7 ; 0000B4, 35.112
0412F1 13 19 00    1074*  	dl 0x001913 ; 0000B5, 35.262
0412F4 2E 19 00    1075*  	dl 0x00192E ; 0000B6, 35.410
0412F7 49 19 00    1076*  	dl 0x001949 ; 0000B7, 35.559
0412FA 64 19 00    1077*  	dl 0x001964 ; 0000B8, 35.707
0412FD 7F 19 00    1078*  	dl 0x00197F ; 0000B9, 35.854
041300 99 19 00    1079*  	dl 0x001999 ; 0000BA, 36.001
041303 B4 19 00    1080*  	dl 0x0019B4 ; 0000BB, 36.147
041306 CE 19 00    1081*  	dl 0x0019CE ; 0000BC, 36.293
041309 E9 19 00    1082*  	dl 0x0019E9 ; 0000BD, 36.438
04130C 03 1A 00    1083*  	dl 0x001A03 ; 0000BE, 36.582
04130F 1D 1A 00    1084*  	dl 0x001A1D ; 0000BF, 36.726
041312 37 1A 00    1085*  	dl 0x001A37 ; 0000C0, 36.870
041315 51 1A 00    1086*  	dl 0x001A51 ; 0000C1, 37.013
041318 6B 1A 00    1087*  	dl 0x001A6B ; 0000C2, 37.155
04131B 85 1A 00    1088*  	dl 0x001A85 ; 0000C3, 37.297
04131E 9F 1A 00    1089*  	dl 0x001A9F ; 0000C4, 37.439
041321 B9 1A 00    1090*  	dl 0x001AB9 ; 0000C5, 37.579
041324 D2 1A 00    1091*  	dl 0x001AD2 ; 0000C6, 37.720
041327 EC 1A 00    1092*  	dl 0x001AEC ; 0000C7, 37.859
04132A 05 1B 00    1093*  	dl 0x001B05 ; 0000C8, 37.999
04132D 1E 1B 00    1094*  	dl 0x001B1E ; 0000C9, 38.137
041330 37 1B 00    1095*  	dl 0x001B37 ; 0000CA, 38.276
041333 50 1B 00    1096*  	dl 0x001B50 ; 0000CB, 38.413
041336 69 1B 00    1097*  	dl 0x001B69 ; 0000CC, 38.550
041339 82 1B 00    1098*  	dl 0x001B82 ; 0000CD, 38.687
04133C 9B 1B 00    1099*  	dl 0x001B9B ; 0000CE, 38.823
04133F B4 1B 00    1100*  	dl 0x001BB4 ; 0000CF, 38.959
041342 CC 1B 00    1101*  	dl 0x001BCC ; 0000D0, 39.094
041345 E5 1B 00    1102*  	dl 0x001BE5 ; 0000D1, 39.228
041348 FD 1B 00    1103*  	dl 0x001BFD ; 0000D2, 39.362
04134B 16 1C 00    1104*  	dl 0x001C16 ; 0000D3, 39.496
04134E 2E 1C 00    1105*  	dl 0x001C2E ; 0000D4, 39.629
041351 46 1C 00    1106*  	dl 0x001C46 ; 0000D5, 39.762
041354 5E 1C 00    1107*  	dl 0x001C5E ; 0000D6, 39.894
041357 76 1C 00    1108*  	dl 0x001C76 ; 0000D7, 40.025
04135A 8E 1C 00    1109*  	dl 0x001C8E ; 0000D8, 40.156
04135D A5 1C 00    1110*  	dl 0x001CA5 ; 0000D9, 40.286
041360 BD 1C 00    1111*  	dl 0x001CBD ; 0000DA, 40.416
041363 D5 1C 00    1112*  	dl 0x001CD5 ; 0000DB, 40.546
041366 EC 1C 00    1113*  	dl 0x001CEC ; 0000DC, 40.675
041369 04 1D 00    1114*  	dl 0x001D04 ; 0000DD, 40.803
04136C 1B 1D 00    1115*  	dl 0x001D1B ; 0000DE, 40.931
04136F 32 1D 00    1116*  	dl 0x001D32 ; 0000DF, 41.059
041372 49 1D 00    1117*  	dl 0x001D49 ; 0000E0, 41.186
041375 60 1D 00    1118*  	dl 0x001D60 ; 0000E1, 41.312
041378 77 1D 00    1119*  	dl 0x001D77 ; 0000E2, 41.438
04137B 8E 1D 00    1120*  	dl 0x001D8E ; 0000E3, 41.564
04137E A5 1D 00    1121*  	dl 0x001DA5 ; 0000E4, 41.689
041381 BB 1D 00    1122*  	dl 0x001DBB ; 0000E5, 41.814
041384 D2 1D 00    1123*  	dl 0x001DD2 ; 0000E6, 41.938
041387 E9 1D 00    1124*  	dl 0x001DE9 ; 0000E7, 42.061
04138A FF 1D 00    1125*  	dl 0x001DFF ; 0000E8, 42.184
04138D 15 1E 00    1126*  	dl 0x001E15 ; 0000E9, 42.307
041390 2C 1E 00    1127*  	dl 0x001E2C ; 0000EA, 42.429
041393 42 1E 00    1128*  	dl 0x001E42 ; 0000EB, 42.551
041396 58 1E 00    1129*  	dl 0x001E58 ; 0000EC, 42.672
041399 6E 1E 00    1130*  	dl 0x001E6E ; 0000ED, 42.793
04139C 84 1E 00    1131*  	dl 0x001E84 ; 0000EE, 42.913
04139F 99 1E 00    1132*  	dl 0x001E99 ; 0000EF, 43.033
0413A2 AF 1E 00    1133*  	dl 0x001EAF ; 0000F0, 43.152
0413A5 C5 1E 00    1134*  	dl 0x001EC5 ; 0000F1, 43.271
0413A8 DA 1E 00    1135*  	dl 0x001EDA ; 0000F2, 43.390
0413AB F0 1E 00    1136*  	dl 0x001EF0 ; 0000F3, 43.508
0413AE 05 1F 00    1137*  	dl 0x001F05 ; 0000F4, 43.625
0413B1 1B 1F 00    1138*  	dl 0x001F1B ; 0000F5, 43.742
0413B4 30 1F 00    1139*  	dl 0x001F30 ; 0000F6, 43.859
0413B7 45 1F 00    1140*  	dl 0x001F45 ; 0000F7, 43.975
0413BA 5A 1F 00    1141*  	dl 0x001F5A ; 0000F8, 44.091
0413BD 6F 1F 00    1142*  	dl 0x001F6F ; 0000F9, 44.206
0413C0 84 1F 00    1143*  	dl 0x001F84 ; 0000FA, 44.321
0413C3 99 1F 00    1144*  	dl 0x001F99 ; 0000FB, 44.435
0413C6 AD 1F 00    1145*  	dl 0x001FAD ; 0000FC, 44.549
0413C9 C2 1F 00    1146*  	dl 0x001FC2 ; 0000FD, 44.662
0413CC D7 1F 00    1147*  	dl 0x001FD7 ; 0000FE, 44.775
0413CF EB 1F 00    1148*  	dl 0x001FEB ; 0000FF, 44.888
0413D2 00 20 00    1149*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0413D5             0048   	include "fixed24.inc"
0413D5             0001*  arith24uaf: ds 6
0413DB             0002*  arith24uhl: ds 6
0413E1             0003*  arith24ubc: ds 6
0413E7             0004*  arith24ude: ds 6
0413ED             0005*  arith24uix: ds 6
0413F3             0006*  arith24uiy: ds 6
0413F9             0007*  arith24usp: ds 6
0413FF             0008*  arith24upc: ds 6
041405             0009*  
041405             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
041405             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
041405             0012*  ; inputs: hlu = 24-bit number to shift
041405             0013*  ;         a = signed number of bits to shift
041405             0014*  ;         ix = output buffer address
041405             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
041405             0016*  shift_hlu:
041405 C5          0017*      push bc ; preserve
041406 47          0018*      ld b,a            ; store shift value in b for later
041407             0019*  
041407             0020*  ; Initialize DE to zero and clear output buffer
041407 11 00 00 00 0021*      ld de, 0
04140B DD 1F FD    0022*      ld (ix-3), de
04140E DD 1F 03    0023*      ld (ix+3), de
041411             0024*  
041411             0025*  ; Get absolute value of a and save its original sign
041411 B7          0026*      or a
041412 F5          0027*      push af ; save sign flag
041413 F2 19 14 04 0028*      jp p,@F ; If a is positive do nothing
041417 ED 44       0029*      neg ; If a is negative, negate it
041419             0030*  @@:
041419             0031*  
041419             0032*  ; Write abs(HLU) to the output buffer and save its original sign
041419 CD 75 0A 04 0033*      call hlu_abs
04141D F5          0034*      push af ; save sign of HLU
04141E DD 2F 00    0035*      ld (ix), hl
041421             0036*  
041421             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
041421 78          0038*      ld a,b            ; Restore original shift value into 'a'
041422 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
041424 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
041426 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
041428 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
041429             0043*  
041429             0044*  ; Calculate remainder of a (original shift) mod 8
041429 E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
04142B 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
04142C 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
041430             0048*  
041430             0049*      ; call dumpRegistersHex ; DEBUG
041430             0050*  
041430             0051*  ; Get back the original sign of the byte shift
041430 F1          0052*      pop af            ; Restore sign flag
041431 F2 3F 14 04 0053*      jp p,@F           ; If a was positive, we're done
041435 79          0054*      ld a,c            ; 'a' now holds the number of whole bytes to shift
041436 ED 44       0055*      neg               ; Negate the number of whole bytes to shift
041438 3D          0056*      dec a             ; Subtract 1 because that's just how this works
041439 4F          0057*      ld c,a            ; 'c' now holds the number of whole bytes to shift
04143A 1B          0058*      dec de            ; DE = -1 to make the signed addition below work
04143B 3E 08       0059*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
04143D 90          0060*      sub b
04143E 47          0061*      ld b,a            ; b is the number of bits to shift back up
04143F             0062*  
04143F             0063*      ; call dumpRegistersHex ; DEBUG
04143F             0064*  
04143F             0065*  @@:
04143F             0066*  
04143F             0067*  ; Add the byte offset to the base address of output buffer
04143F 59          0068*      ld e,c            ; DEU and D were properly signed above
041440 DD 19       0069*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
041442             0070*  
041442             0071*      ; call dumpRegistersHex ; DEBUG
041442             0072*  
041442             0073*  ; Read the byte-aligned result into HL and shift in the required number of bits
041442 DD 27 00    0074*      ld hl,(ix)        ; Byte-aligned result
041445             0075*  
041445 CD 26 04 04 0076*      call dumpRegistersHex ; DEBUG
041449             0077*  
041449             0078*  ; Check whether we're already byte-aligned
041449 AF          0079*      xor a
04144A B0          0080*      or b
04144B 28 10       0081*      jr z,@end         ; If no bits to shift, we're done
04144D             0082*  
04144D             0083*  ; Otherwise shiften zee bitzen
04144D DD 7E FF    0084*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
041450             0085*  @loop:
041450 07          0086*      rlca              ; One bit to carry
041451             0087*  
041451 CD B4 05 04 0088*      call dumpFlags ; DEBUG
041455             0089*  
041455 ED 6A       0090*      adc hl,hl         ; Shift the carry into the result
041457             0091*  
041457 CD 26 04 04 0092*      call dumpRegistersHex ; DEBUG
04145B             0093*  
04145B 10 F3       0094*      djnz @loop        ; Loop until all bits are shifted up
04145D             0095*  
04145D             0096*  @end:
04145D             0097*  
04145D CD 26 04 04 0098*      call dumpRegistersHex ; DEBUG
041461             0099*  
041461             0100*  ; get back HLU's original sign and negate if necessary
041461 F1          0101*      pop af
041462 F2 6A 14 04 0102*      jp p,@F
041466 CD 85 0A 04 0103*      call neg_hlu
04146A             0104*  @@:
04146A             0105*  ; return the result
04146A DD 2F 00    0106*      ld (ix),hl        ; Store the shifted result
04146D C1          0107*      pop bc              ; Restore BC
04146E C9          0108*      ret
04146F             0109*  
04146F             0110*  ; operation: UHL * UDE --> UHL
04146F             0111*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
04146F             0112*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
04146F             0113*  ; inputs: hl = 24-bit number, de = 24-bit number,
04146F             0114*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
04146F             0115*  ; outputs: umulfxout = 48-bit intermediate
04146F             0116*  ; destroys: af, hl, bc, de
04146F             0117*  umulfx:
04146F DD E5       0118*      push ix ; preserve
041471 F5          0119*      push af ; need later
041472             0120*  
041472             0121*  ; do the multiplication
041472 CD 33 15 04 0122*      call umul24x24
041476             0123*      ; DEBUG
041476 21 C8 14 04 0124*      ld hl,umulfxout ; point to output buffer
04147A 3E 06       0125*      ld a,6 ; 6 bytes to print
04147C CD 1A 06 04 0126*      call dumpMemoryHex ; print the result
041480             0127*      ; END DEBUG
041480             0128*  
041480             0129*  ; shift the result to the required output precision
041480 78          0130*      ld a,b
041481 81          0131*      add a,c ; a is left shift from the multiplication
041482 C1          0132*      pop bc ; b is the output precision (was a)
041483 90          0133*      sub b ; a is the net shift of the output
041484             0134*  
041484             0135*  ; Get absolute value of a and save its original sign
041484 B7          0136*      or a
041485 F5          0137*      push af ; save sign flag
041486 F2 8C 14 04 0138*      jp p,@F ; If a is positive do nothing
04148A ED 44       0139*      neg ; If a is negative, negate it
04148C             0140*  @@:
04148C             0141*  
04148C             0142*  ; Divide a by 8 to get the whole byte shift and bit remainder
04148C 47          0143*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
04148D CB 3F       0144*      srl a             ; a = a / 2 (shift right 1 bit)
04148F CB 3F       0145*      srl a             ; a = a / 4 (shift right another bit)
041491 CB 3F       0146*      srl a             ; a = a / 8 (final shift for division by 8)
041493 4F          0147*      ld c,a            ; c holds the number of whole bytes to shift
041494             0148*  
041494             0149*  ; Calculate remainder of a (original shift) mod 8
041494 78          0150*      ld a,b            ; Restore original shift value into 'a'
041495 E6 07       0151*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
041497 47          0152*      ld b,a            ; 'b' now holds the number of bits to shift back up
041498 11 00 00 00 0153*      ld de,0           ; Clear deu for computing the offset address later
04149C             0154*  
04149C             0155*      ; call dumpRegistersHex ; DEBUG
04149C             0156*  
04149C             0157*  ; Get back the original sign of the byte shift
04149C F1          0158*      pop af            ; Restore sign flag
04149D F2 AB 14 04 0159*      jp p,@F           ; If a was positive, we're done
0414A1 79          0160*      ld a,c            ; 'a' now holds the number of whole bytes to shift
0414A2 ED 44       0161*      neg               ; Negate the number of whole bytes to shift
0414A4 3D          0162*      dec a             ; Subtract 1 because that's just how this works
0414A5 4F          0163*      ld c,a            ; 'c' now holds the number of whole bytes to shift
0414A6 1B          0164*      dec de            ; DE = -1 to make the signed addition below work
0414A7 3E 08       0165*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0414A9 90          0166*      sub b
0414AA 47          0167*      ld b,a            ; b is the number of bits to shift back up
0414AB             0168*  
0414AB             0169*      ; call dumpRegistersHex ; DEBUG
0414AB             0170*  
0414AB             0171*  @@:
0414AB             0172*  
0414AB             0173*  ; Add the byte offset to the base address of umulfxout
0414AB 59          0174*      ld e,c            ; DEU and D were properly signed above
0414AC DD 21 C8 14 0175*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
0414B1 DD 19       0176*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
0414B3             0177*  
0414B3             0178*      ; call dumpRegistersHex ; DEBUG
0414B3             0179*  
0414B3             0180*  ; Read the byte-aligned result into HL and shift in the required number of bits
0414B3 DD 27 00    0181*      ld hl,(ix)        ; Byte-aligned result
0414B6 DD 7E FF    0182*      ld a,(ix-1)       ; One byte below
0414B9             0183*  
0414B9             0184*  ; Check whether we're already byte-aligned
0414B9 AF          0185*      xor a
0414BA B0          0186*      or b
0414BB 28 05       0187*      jr z,@end         ; If no bits to shift, we're done
0414BD             0188*  
0414BD             0189*  ; Otherwise shiften zee bitzen
0414BD             0190*  @loop:
0414BD             0191*  
0414BD             0192*      ; call dumpRegistersHex ; DEBUG
0414BD             0193*  
0414BD 07          0194*      rlca              ; One bit to carry
0414BE ED 6A       0195*      adc hl,hl         ; Shift the carry into the result
0414C0             0196*  
0414C0 10 FB       0197*      djnz @loop        ; Loop until all bits are shifted up
0414C2             0198*  
0414C2             0199*  @end:
0414C2             0200*  ; return the result
0414C2 DD E1       0201*      pop ix ; restore
0414C4 C9          0202*      ret
0414C5             0203*  
0414C5 00 00 00    0204*      dl 0 ; padding
0414C8 00 00 00 00 0205*  umulfxout: blkb 6,0
       00 00       
0414CE 00 00 00    0206*      dl 0 ; padding
0414D1             0207*  
0414D1             0208*  ; operation: UHL * UDE --> UHL
0414D1             0209*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
0414D1             0210*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0414D1             0211*  ; inputs: hl = 24-bit number, de = 24-bit number,
0414D1             0212*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0414D1             0213*  ; outputs: umulfxout = 48-bit intermediate
0414D1             0214*  ; destroys: af, hl, bc, de
0414D1             0215*  smulfx:
0414D1             0216*  ; make everything positive and store sign flags
0414D1 CD 75 0A 04 0217*  	call hlu_abs
0414D5 F5          0218*  	push af
0414D6 EB          0219*  	ex de,hl
0414D7 CD 75 0A 04 0220*  	call hlu_abs
0414DB EB          0221*  	ex de,hl
0414DC F5          0222*  	push af
0414DD             0223*  ; do the division
0414DD CD 6F 14 04 0224*      call umulfx ; hl = product
0414E1             0225*  ; adjust sign of result
0414E1 F1          0226*  	pop af ; sign de
0414E2 FA ED 14 04 0227*  	jp m,@de_neg
0414E6 F1          0228*  	pop af ; sign hl
0414E7 F0          0229*  	ret p ; both positive, nothing to do
0414E8             0230*  @hl_neg:
0414E8 CD 85 0A 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
0414EC C9          0232*      ret
0414ED             0233*  @de_neg:
0414ED F1          0234*  	pop af
0414EE F8          0235*  	ret m ; both negative, nothing to do
0414EF CD 85 0A 04 0236*  	call neg_hlu ; result is negative
0414F3 C9          0237*  	ret
0414F4             0238*  
0414F4             0239*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0414F4             0240*  ; uses EZ80 MLT instruction for speed
0414F4             0241*  ; operation: UHL * A --> UHL
0414F4             0242*  ; destroys: AF, HL
0414F4             0243*  smul24x8:
0414F4             0244*  ; make hl positive and store sign flag
0414F4 CD 75 0A 04 0245*  	call hlu_abs
0414F8 F5          0246*  	push af
0414F9             0247*  ; do the division
0414F9 CD 04 15 04 0248*      call umul24x8 ; hl = product
0414FD             0249*  ; adjust sign of result
0414FD F1          0250*  	pop af ; sign de
0414FE F0          0251*  	ret p ; hl was positive, nothing to do
0414FF CD 85 0A 04 0252*  	call neg_hlu ; result is negative
041503 C9          0253*  	ret
041504             0254*  
041504             0255*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
041504             0256*  ; uses EZ80 MLT instruction for speed
041504             0257*  ; operation: UHL * A --> AUHL
041504             0258*  ; destroys: AF, HL
041504             0259*  umul24x8:
041504 D5          0260*  	push de ; preserve de
041505             0261*  ; low byte
041505 5D          0262*  	ld e,l
041506 57          0263*  	ld d,a
041507 ED 5C       0264*  	mlt de
041509 6B          0265*  	ld l,e ; product low byte
04150A 08          0266*  	ex af,af' ; save multiplier
04150B 7A          0267*  	ld a,d ; carry
04150C 08          0268*  	ex af,af' ; save carry, restore multiplier
04150D             0269*  ; high byte
04150D 5C          0270*  	ld e,h
04150E 57          0271*  	ld d,a
04150F ED 5C       0272*  	mlt de
041511 08          0273*  	ex af,af' ; save multiplier, restore carry
041512 83          0274*  	add a,e ; add carry
041513 67          0275*  	ld h,a ; product middle byte
041514 7A          0276*  	ld a,d ; carry
041515 08          0277*  	ex af,af' ; save carry, restore multiplier
041516             0278*  ; upper byte
041516 E5          0279*  	push hl
041517 33          0280*  	inc sp
041518 D1          0281*  	pop de ; d = hlu
041519 3B          0282*  	dec sp
04151A 5F          0283*  	ld e,a
04151B ED 5C       0284*  	mlt de
04151D 08          0285*  	ex af,af' ; restore carry
04151E 8B          0286*  	adc a,e ; add carry
04151F 22 30 15 04 0287*      ld (@scratch),hl ; 7 cycles
041523 32 32 15 04 0288*      ld (@scratch+2),a ; 5 cycles
041527 2A 30 15 04 0289*      ld hl,(@scratch) ; 7 cycles
04152B             0290*  ; highest byte
04152B 3E 00       0291*  	ld a,0 ; preserve carry flag
04152D 8A          0292*  	adc a,d ; product highest byte
04152E D1          0293*  	pop de ; restore de
04152F C9          0294*  	ret
041530             0295*  @scratch: ds 3
041533             0296*  
041533             0297*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
041533             0298*  ; operation: UHL * UDE --> umulfxout
041533             0299*  umul24x24:
041533 FD 21 C8 14 0300*  	ld iy,umulfxout ; point to output buffer
       04          
041538 C5          0301*  	push bc
041539 01 00 00 00 0302*  	ld bc,0
04153D FD 0F 00    0303*  	ld (iy),bc
041540 FD 0F 03    0304*  	ld (iy+3),bc
041543 C1          0305*  	pop bc
041544             0306*  
041544             0307*  ; STEP 1: UHL * E
041544 7B          0308*  	ld a,e
041545 E5          0309*  	push hl
041546 CD 04 15 04 0310*  	call umul24x8
04154A FD 2F 00    0311*  	ld (iy+0),hl
04154D FD 77 03    0312*  	ld (iy+3),a
041550             0313*  
041550             0314*  ; STEP 2: UHL * D
041550 E1          0315*  	pop hl
041551 E5          0316*  	push hl
041552 7A          0317*  	ld a,d
041553 CD 04 15 04 0318*  	call umul24x8
041557 CD 64 15 04 0319*  	call @accumulate
04155B             0320*  
04155B             0321*  ; STEP 3: UHL * DEU
04155B E1          0322*  	pop hl
04155C D5          0323*  	push de
04155D 33          0324*  	inc sp
04155E F1          0325*  	pop af
04155F 3B          0326*  	dec sp
041560 CD 04 15 04 0327*  	call umul24x8
041564             0328*  
041564             0329*  @accumulate:
041564 FD 23       0330*  	inc iy
041566             0331*  ; highest byte of product to carry
041566 FD 77 03    0332*  	ld (iy+3),a
041569             0333*  ; low byte of product
041569 7D          0334*  	ld a,l
04156A FD 86 00    0335*  	add a,(iy+0)
04156D FD 77 00    0336*  	ld (iy+0),a
041570             0337*  ; high byte of product
041570 7C          0338*  	ld a,h
041571 FD 8E 01    0339*  	adc a,(iy+1)
041574 FD 77 01    0340*  	ld (iy+1),a
041577             0341*  ; uppper byte of product
041577 E5          0342*  	push hl
041578 33          0343*  	inc sp
041579 E1          0344*  	pop hl
04157A 3B          0345*  	dec sp
04157B 7C          0346*  	ld a,h
04157C FD 8E 02    0347*  	adc a,(iy+2)
04157F FD 77 02    0348*  	ld (iy+2),a
041582             0349*  ; carry
041582 3E 00       0350*  	ld a,0 ; preserve flags
041584 FD 8E 03    0351*  	adc a,(iy+3)
041587 FD 77 03    0352*  	ld (iy+3),a
04158A C9          0353*  	ret
04158B             0354*  
04158B             0355*  ; UH.L = UH.L*UD.E (unsigned)
04158B             0356*  umul168:
04158B CD 33 15 04 0357*  	call umul24x24
04158F FD 27 FF    0358*  	ld hl,(iy-1)
041592 C9          0359*  	ret
041593             0360*  
041593             0361*  ; UH.L * UD.E --> UH.L (signed)
041593             0362*  smul168:
041593             0363*  ; make everything positive and store sign flags
041593 CD 75 0A 04 0364*  	call hlu_abs
041597 F5          0365*  	push af
041598 EB          0366*  	ex de,hl
041599 CD 75 0A 04 0367*  	call hlu_abs
04159D EB          0368*  	ex de,hl
04159E F5          0369*  	push af
04159F             0370*  ; do the division
04159F CD 8B 15 04 0371*      call umul168 ; hl = product
0415A3             0372*  ; adjust sign of result
0415A3 F1          0373*  	pop af ; sign de
0415A4 FA AF 15 04 0374*  	jp m,@de_neg
0415A8 F1          0375*  	pop af ; sign hl
0415A9 F0          0376*  	ret p ; both positive, nothing to do
0415AA             0377*  @hl_neg:
0415AA CD 85 0A 04 0378*      call neg_hlu ; de pos, hl neg, result is negative
0415AE C9          0379*      ret
0415AF             0380*  @de_neg:
0415AF F1          0381*  	pop af
0415B0 F8          0382*  	ret m ; both negative, nothing to do
0415B1 CD 85 0A 04 0383*  	call neg_hlu ; result is negative
0415B5 C9          0384*  	ret
0415B6             0385*  
0415B6             0386*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0415B6             0387*  ; perform unsigned division of 16.8 fixed place values
0415B6             0388*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0415B6             0389*  udiv168:
0415B6             0390*  ; back up divisor
0415B6 ED 53 ED 15 0391*  	ld (@ude),de
       04          
0415BB             0392*  ; get the 16-bit integer part of the quotient
0415BB CD 1E 16 04 0393*      call udiv24 ; de = quotient, hl = remainder
0415BF             0394*  ; load quotient to upper three bytes of output
0415BF ED 53 F4 15 0395*      ld (div168_out+1),de
       04          
0415C4             0396*  @div256:
0415C4             0397*  ; multiply remainder by 256
0415C4             0398*  	hlu_mul256
0415C4 29          0001*M         add hl,hl ; * 2
0415C5 29          0002*M         add hl,hl ; * 4
0415C6 29          0003*M         add hl,hl ; * 8
0415C7 29          0004*M         add hl,hl ; * 16
0415C8 29          0005*M         add hl,hl ; * 32
0415C9 29          0006*M         add hl,hl ; * 64
0415CA 29          0007*M         add hl,hl ; * 128
0415CB 29          0008*M         add hl,hl ; * 256
0415CC             0399*  ; skip fractional computation if remainder is zero
0415CC             0400*      sign_hlu
0415CC 19          0001*M         add hl,de
0415CD B7          0002*M         or a
0415CE ED 52       0003*M         sbc hl,de
0415D0 20 03       0401*      jr nz,@div_frac
0415D2 AF          0402*      xor a
0415D3 18 0A       0403*      jr @write_frac
0415D5             0404*  ; now divide the shifted remainder by the divisor
0415D5             0405*  @div_frac:
0415D5 ED 5B ED 15 0406*  	ld de,(@ude) ; get back divisor
       04          
0415DA CD 1E 16 04 0407*      call udiv24 ; de = quotient, hl = remainder
0415DE             0408*  ; load low byte of quotient to low byte of output
0415DE 7B          0409*      ld a,e
0415DF             0410*  @write_frac:
0415DF 32 F3 15 04 0411*      ld (div168_out),a
0415E3             0412*  ; load de with return value
0415E3 ED 5B F3 15 0413*      ld de,(div168_out)
       04          
0415E8             0414*  ; load a with any overflow
0415E8 3A F6 15 04 0415*      ld a,(div168_out+3)
0415EC C9          0416*      ret ; ud.e is the 16.8 result
0415ED             0417*  @ude: ds 6
0415F3             0418*  div168_out: ds 4 ; the extra byte is for overflow
0415F7             0419*  
0415F7             0420*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0415F7             0421*  ; perform signed division of 16.8 fixed place values
0415F7             0422*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0415F7             0423*  sdiv168:
0415F7             0424*  ; make everything positive and store sign flags
0415F7 CD 75 0A 04 0425*  	call hlu_abs
0415FB F5          0426*  	push af
0415FC EB          0427*  	ex de,hl
0415FD CD 75 0A 04 0428*  	call hlu_abs
041601 EB          0429*  	ex de,hl
041602 F5          0430*  	push af
041603             0431*  ; do the division
041603 CD B6 15 04 0432*      call udiv168 ; de = quotient, hl = remainder
041607             0433*  ; adjust sign of result
041607 F1          0434*  	pop af ; sign de
041608 FA 15 16 04 0435*  	jp m,@de_neg
04160C F1          0436*  	pop af ; sign hl
04160D F0          0437*  	ret p ; both positive, nothing to do
04160E             0438*  @hl_neg:
04160E EB          0439*      ex de,hl ; hl = quotient, de = remainder
04160F CD 85 0A 04 0440*      call neg_hlu ; de pos, hl neg, result is negative
041613 EB          0441*      ex de,hl ; de = negated quotient, hl = remainder
041614 C9          0442*      ret
041615             0443*  @de_neg:
041615 F1          0444*  	pop af
041616 F8          0445*  	ret m ; both negative, nothing to do
041617 EB          0446*      ex de,hl ; hl = quotient, de = remainder
041618 CD 85 0A 04 0447*  	call neg_hlu ; result is negative
04161C EB          0448*      ex de,hl ; de = negated quotient, hl = remainder
04161D C9          0449*  	ret
04161E             0450*  
04161E             0451*  ;------------------------------------------------------------------------
04161E             0452*  ;  arith24.asm
04161E             0453*  ;  24-bit ez80 arithmetic routines
04161E             0454*  ;  Copyright (c) Shawn Sijnstra 2024
04161E             0455*  ;  MIT license
04161E             0456*  ;
04161E             0457*  ;  This library was created as a tool to help make ez80
04161E             0458*  ;  24-bit native assembly routines for simple mathematical problems
04161E             0459*  ;  more widely available.
04161E             0460*  ;
04161E             0461*  ;------------------------------------------------------------------------
04161E             0462*  ;
04161E             0463*  ;------------------------------------------------------------------------
04161E             0464*  ; udiv24
04161E             0465*  ; Unsigned 24-bit division
04161E             0466*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04161E             0467*  ;
04161E             0468*  ; Uses AF BC DE HL
04161E             0469*  ; Uses Restoring Division algorithm
04161E             0470*  ;------------------------------------------------------------------------
04161E             0471*  
04161E             0472*  udiv24:
04161E E5          0473*  	push	hl
04161F C1          0474*  	pop		bc	;move dividend to BCU
041620 21 00 00 00 0475*  	ld		hl,0	;result
041624 A7          0476*  	and		a
041625 ED 52       0477*  	sbc		hl,de	;test for div by 0
041627 C8          0478*  	ret		z		;it's zero, carry flag is clear
041628 19          0479*  	add		hl,de	;HL is 0 again
041629 3E 18       0480*  	ld		a,24	;number of loops through.
04162B             0481*  udiv1:
04162B C5          0482*  	push	bc	;complicated way of doing this because of lack of access to top bits
04162C E3          0483*  	ex		(sp),hl
04162D 37          0484*  	scf
04162E ED 6A       0485*  	adc	hl,hl
041630 E3          0486*  	ex	(sp),hl
041631 C1          0487*  	pop	bc		;we now have bc = (bc * 2) + 1
041632             0488*  
041632 ED 6A       0489*  	adc	hl,hl
041634 A7          0490*  	and	a		;is this the bug
041635 ED 52       0491*  	sbc	hl,de
041637 30 02       0492*  	jr	nc,udiv2
041639 19          0493*  	add	hl,de
04163A             0494*  ;	dec	c
04163A 0B          0495*  	dec	bc
04163B             0496*  udiv2:
04163B 3D          0497*  	dec	a
04163C 20 ED       0498*  	jr	nz,udiv1
04163E 37          0499*  	scf		;flag used for div0 error
04163F C5          0500*  	push	bc
041640 D1          0501*  	pop		de	;remainder
041641 C9          0502*  	ret
041642             0049   	include "files.inc"
041642             0001*  ; load to onboard 8k sram
041642             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
041642             0050   
041642             0051   ; --- INITIALIZATION ---
041642             0052   init:
041642 C9          0053       ret
041643             0054   
041643             0055   ; --- MAIN PROGRAM ---
041643             0056   main:
041643 CD D9 06 04 0057       call vdu_cls
041647             0058   
041647             0059   ; testing atan2_168fast
041647             0060       ; call printNewLine
041647 01 00 01 00 0061       ld bc,256*1
04164B 11 00 FF FF 0062       ld de,256*-1
04164F CD 1F 0C 04 0063       call atan2_168fast
041653 CD 98 02 04 0064       call print_s168_hl
041657 CD 8C 00 04 0065       call printNewLine
04165B C9          0066       ret
04165C             0067   
04165C             0068   ; testing division
04165C 21 01 00 00 0069       ld hl,1
041660 11 02 00 00 0070       ld de,2
041664 CD B6 15 04 0071       call udiv168
041668 CD 26 04 04 0072       call dumpRegistersHex
04166C CD 98 02 04 0073       call print_s168_hl
041670 CD B6 02 04 0074       call print_s168_de
041674 CD 8C 00 04 0075       call printNewLine
041678 C9          0076       ret
041679             0077   
041679             0078   ; testing trig
041679 11 00 61 00 0079       ld de,0x006100 ; 97
04167D 21 71 7C 00 0080       ld hl,0x007C71 ; 124.444444444444444444
041681             0081   
041681 D5          0082       push de
041682 E5          0083       push hl
041683             0084   
041683 CD 68 0B 04 0085       call sin168
041687 CD 98 02 04 0086       call print_s168_hl
04168B CD 8C 00 04 0087       call printNewLine
04168F             0088   
04168F E1          0089       pop hl
041690 E5          0090       push hl
041691             0091   
041691 CD 61 0B 04 0092       call cos168
041695 CD 98 02 04 0093       call print_s168_hl
041699 CD 8C 00 04 0094       call printNewLine
04169D             0095   
04169D E1          0096       pop hl
04169E D1          0097       pop de
04169F             0098   
04169F CD 83 0B 04 0099       call polar_to_cartesian
0416A3 CD A5 02 04 0100       call print_s168_bc
0416A7 CD B6 02 04 0101       call print_s168_de
0416AB CD 98 02 04 0102       call print_s168_hl
0416AF CD 8C 00 04 0103       call printNewLine
0416B3             0104   
0416B3 C9          0105       ret
