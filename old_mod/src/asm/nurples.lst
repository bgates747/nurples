PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD FC 42 04 0030   	call	init			; Initialization code
040050 CD AC 43 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04167A             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
04167A             0033*  
04167A             0034*  ; pointer to top address of current record, initialized to table_base
04167A E2 15 04    0035*  table_pointer: dl table_base
04167D             0036*  ; how many active sprites
04167D 00          0037*  table_active_sprites: db 0x00
04167E             0038*  ; flag indicating collision with screen edge
04167E             0039*  ; uses orientation codes to specify which edge(s)
04167E 00          0040*  sprite_screen_edge: db #00
04167F             0041*  ; next sprite id to use
04167F 00          0042*  sprite_next_id: db 0
041680             0043*  
041680             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041680             0045*  ; integer coordinates are all that are needed for collision calculations
041680 00          0046*  collision_x: db 0x00
041681 00          0047*  collision_y: db 0x00
041682 00          0048*  collision_dim_x: db 0x00
041683 00          0049*  collision_dim_y: db 0x00
041684             0050*  
041684             0051*  ; scratch variables
041684 00          0052*  x: db 0x00 ; 8-bit signed integer
041685 00          0053*  y: db 0x00 ; 8-bit signed integer
041686 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041689 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04168C 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04168F 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041692 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041695 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041698             0060*  
041698             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041698 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04169B 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04169E 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
0416A1             0065*  
0416A1             0066*  ; gets the next available sprite id
0416A1             0067*  ; inputs; none
0416A1             0068*  ; returns: if new sprite available, a = sprite id,
0416A1             0069*  ;           ix pointing to new sprite vars, carry set
0416A1             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
0416A1             0071*  ; destroys: a,b,hl,ix
0416A1             0072*  ; affects: bumps table_active_sprites by one
0416A1             0073*  table_get_next_id:
0416A1 DD 21 E2 15 0074*      ld ix,table_base
       04          
0416A6 11 26 00 00 0075*      ld de,table_bytes_per_record
0416AA 06 04       0076*      ld b,table_max_records
0416AC             0077*  @loop:
0416AC DD 7E 01    0078*      ld a,(ix+sprite_type)
0416AF A7          0079*      and a
0416B0 28 06       0080*      jr z,@found
0416B2 DD 19       0081*      add ix,de
0416B4 10 F6       0082*      djnz @loop
0416B6             0083*  @notfound:
0416B6 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
0416B7 C9          0085*      ret
0416B8             0086*  @found:
0416B8             0087*  ; bump number of active sprites
0416B8 21 7D 16 04 0088*      ld hl,table_active_sprites
0416BC 34          0089*      inc (hl)
0416BD             0090*  ; return sprite id
0416BD 3E 04       0091*      ld a,table_max_records
0416BF 90          0092*      sub b
0416C0 32 7F 16 04 0093*      ld (sprite_next_id),a
0416C4 37          0094*      scf ; sets carry flag indicating we found a free sprite
0416C5 C9          0095*      ret ; done
0416C6             0096*  
0416C6             0097*  ; deactivate the sprite with the given id
0416C6             0098*  ; inputs: a = sprite id
0416C6             0099*  ; outputs: nothing
0416C6             0100*  ; destroys: a,ix,de
0416C6             0101*  ; affects: decrements table_active_sprites by one
0416C6             0102*  table_deactivate_sprite:
0416C6 F5          0103*      push af ; save sprite id bc we need it later
0416C7 CD C9 1F 04 0104*      call vdu_sprite_select
0416CB CD 4D 20 04 0105*      call vdu_sprite_hide
0416CF F1          0106*      pop af ; restore sprite id
0416D0 11 00 00 00 0107*      ld de,0 ; clear deu
0416D4 57          0108*      ld d,a
0416D5 1E 26       0109*      ld e,table_bytes_per_record
0416D7 ED 5C       0110*      mlt de
0416D9 DD 21 E2 15 0111*      ld ix,table_base
       04          
0416DE DD 19       0112*      add ix,de
0416E0 AF          0113*      xor a
0416E1 DD 77 01    0114*      ld (ix+sprite_type),a
0416E4 DD 21 7D 16 0115*      ld ix,table_active_sprites
       04          
0416E9 DD 35 00    0116*      dec (ix)
0416EC C9          0117*      ret
0416ED             0118*  
0416ED             0119*  sprites_init:
0416ED             0120*  ; initialize sprites
0416ED CD F5 20 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0416F1 AF          0122*  	xor a
0416F2             0123*  @sprite_loop:
0416F2 F5          0124*  	push af
0416F3 CD C9 1F 04 0125*  	call vdu_sprite_select
0416F7 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0416FB CD 16 21 04 0127*  	call vdu_sprite_add_buff
0416FF F1          0128*  	pop af
041700 3C          0129*  	inc a
041701 FE 05       0130*  	cp table_max_records+1 ; tack on sprites for player and laser
041703 20 ED       0131*  	jr nz,@sprite_loop
041705 3C          0132*  	inc a
041706 CD FD 1F 04 0133*  	call vdu_sprite_activate
04170A             0134*  
04170A             0135*  ; define player sprite
04170A 3A BA 2C 04 0136*  	ld a,(player_id)
04170E CD C9 1F 04 0137*  	call vdu_sprite_select
041712 CD DC 1F 04 0138*  	call vdu_sprite_clear_frames
041716 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
04171A 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
04171E             0141*  @sprite_player_loop:
04171E C5          0142*  	push bc
04171F E5          0143*  	push hl
041720 CD 16 21 04 0144*  	call vdu_sprite_add_buff
041724 E1          0145*  	pop hl
041725 23          0146*  	inc hl
041726 C1          0147*  	pop bc
041727 10 F5       0148*  	djnz @sprite_player_loop
041729 CD 3F 20 04 0149*  	call vdu_sprite_show
04172D             0150*  
04172D             0151*  ; all done
04172D C9          0152*      ret
04172E             0050   ; API includes
04172E             0051       include "mos_api.inc"
04172E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04172E             0002*  ; Title:	AGON MOS - API for user projects
04172E             0003*  ; Author:	Dean Belfield
04172E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04172E             0005*  ;			Added MOS error codes for return in HL
04172E             0006*  ; Created:	03/08/2022
04172E             0007*  ; Last Updated:	10/08/2023
04172E             0008*  ;
04172E             0009*  ; Modinfo:
04172E             0010*  ; 05/08/2022:	Added mos_feof
04172E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04172E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04172E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04172E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04172E             0015*  ; 13/10/2022:	Added mos_oscli
04172E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04172E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04172E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04172E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04172E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04172E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04172E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04172E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04172E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04172E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04172E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04172E             0027*  ; 03/08/2023:	Added mos_setkbvector
04172E             0028*  ; 10/08/2023:	Added mos_getkbmap
04172E             0029*  
04172E             0030*  ; VDP control (VDU 23, 0, n)
04172E             0031*  ;
04172E             0032*  vdp_gp:				EQU 80h
04172E             0033*  vdp_keycode:		EQU 81h
04172E             0034*  vdp_cursor:			EQU	82h
04172E             0035*  vdp_scrchar:		EQU	83h
04172E             0036*  vdp_scrpixel:		EQU	84h
04172E             0037*  vdp_audio:			EQU	85h
04172E             0038*  vdp_mode:			EQU	86h
04172E             0039*  vdp_rtc:			EQU	87h
04172E             0040*  vdp_keystate:		EQU	88h
04172E             0041*  vdp_logicalcoords:	EQU	C0h
04172E             0042*  vdp_terminalmode:	EQU	FFh
04172E             0043*  
04172E             0044*  ; MOS high level functions
04172E             0045*  ;
04172E             0046*  mos_getkey:			EQU	00h
04172E             0047*  mos_load:			EQU	01h
04172E             0048*  mos_save:			EQU	02h
04172E             0049*  mos_cd:				EQU	03h
04172E             0050*  mos_dir:			EQU	04h
04172E             0051*  mos_del:			EQU	05h
04172E             0052*  mos_ren:			EQU	06h
04172E             0053*  mos_mkdir:			EQU	07h
04172E             0054*  mos_sysvars:		EQU	08h
04172E             0055*  mos_editline:		EQU	09h
04172E             0056*  mos_fopen:			EQU	0Ah
04172E             0057*  mos_fclose:			EQU	0Bh
04172E             0058*  mos_fgetc:			EQU	0Ch
04172E             0059*  mos_fputc:			EQU	0Dh
04172E             0060*  mos_feof:			EQU	0Eh
04172E             0061*  mos_getError:		EQU	0Fh
04172E             0062*  mos_oscli:			EQU	10h
04172E             0063*  mos_copy:			EQU	11h
04172E             0064*  mos_getrtc:			EQU	12h
04172E             0065*  mos_setrtc:			EQU	13h
04172E             0066*  mos_setintvector:	EQU	14h
04172E             0067*  mos_uopen:			EQU	15h
04172E             0068*  mos_uclose:			EQU	16h
04172E             0069*  mos_ugetc:			EQU	17h
04172E             0070*  mos_uputc:			EQU	18h
04172E             0071*  mos_getfil:			EQU	19h
04172E             0072*  mos_fread:			EQU	1Ah
04172E             0073*  mos_fwrite:			EQU	1Bh
04172E             0074*  mos_flseek:			EQU	1Ch
04172E             0075*  mos_setkbvector:	EQU	1Dh
04172E             0076*  mos_getkbmap:		EQU	1Eh
04172E             0077*  
04172E             0078*  ; MOS program exit codes
04172E             0079*  ;
04172E             0080*  EXIT_OK:				EQU  0;	"OK",
04172E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04172E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04172E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04172E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04172E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04172E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04172E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04172E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04172E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04172E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04172E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04172E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04172E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04172E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04172E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04172E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04172E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04172E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04172E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04172E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04172E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04172E             0102*  ; FatFS file access functions
04172E             0103*  ;
04172E             0104*  ffs_fopen:			EQU	80h
04172E             0105*  ffs_fclose:			EQU	81h
04172E             0106*  ffs_fread:			EQU	82h
04172E             0107*  ffs_fwrite:			EQU	83h
04172E             0108*  ffs_flseek:			EQU	84h
04172E             0109*  ffs_ftruncate:		EQU	85h
04172E             0110*  ffs_fsync:			EQU	86h
04172E             0111*  ffs_fforward:		EQU	87h
04172E             0112*  ffs_fexpand:		EQU	88h
04172E             0113*  ffs_fgets:			EQU	89h
04172E             0114*  ffs_fputc:			EQU	8Ah
04172E             0115*  ffs_fputs:			EQU	8Bh
04172E             0116*  ffs_fprintf:		EQU	8Ch
04172E             0117*  ffs_ftell:			EQU	8Dh
04172E             0118*  ffs_feof:			EQU	8Eh
04172E             0119*  ffs_fsize:			EQU	8Fh
04172E             0120*  ffs_ferror:			EQU	90h
04172E             0121*  
04172E             0122*  ; FatFS directory access functions
04172E             0123*  ;
04172E             0124*  ffs_dopen:			EQU	91h
04172E             0125*  ffs_dclose:			EQU	92h
04172E             0126*  ffs_dread:			EQU	93h
04172E             0127*  ffs_dfindfirst:		EQU	94h
04172E             0128*  ffs_dfindnext:		EQU	95h
04172E             0129*  
04172E             0130*  ; FatFS file and directory management functions
04172E             0131*  ;
04172E             0132*  ffs_stat:			EQU	96h
04172E             0133*  ffs_unlink:			EQU	97h
04172E             0134*  ffs_rename:			EQU	98h
04172E             0135*  ffs_chmod:			EQU	99h
04172E             0136*  ffs_utime:			EQU	9Ah
04172E             0137*  ffs_mkdir:			EQU	9Bh
04172E             0138*  ffs_chdir:			EQU	9Ch
04172E             0139*  ffs_chdrive:		EQU	9Dh
04172E             0140*  ffs_getcwd:			EQU	9Eh
04172E             0141*  
04172E             0142*  ; FatFS volume management and system configuration functions
04172E             0143*  ;
04172E             0144*  ffs_mount:			EQU	9Fh
04172E             0145*  ffs_mkfs:			EQU	A0h
04172E             0146*  ffs_fdisk:			EQU	A1h
04172E             0147*  ffs_getfree:		EQU	A2h
04172E             0148*  ffs_getlabel:		EQU	A3h
04172E             0149*  ffs_setlabel:		EQU	A4h
04172E             0150*  ffs_setcp:			EQU	A5h
04172E             0151*  
04172E             0152*  ; File access modes
04172E             0153*  ;
04172E             0154*  fa_read:			EQU	01h
04172E             0155*  fa_write:			EQU	02h
04172E             0156*  fa_open_existing:	EQU	00h
04172E             0157*  fa_create_new:		EQU	04h
04172E             0158*  fa_create_always:	EQU	08h
04172E             0159*  fa_open_always:		EQU	10h
04172E             0160*  fa_open_append:		EQU	30h
04172E             0161*  
04172E             0162*  ; System variable indexes for api_sysvars
04172E             0163*  ; Index into _sysvars in globals.inc
04172E             0164*  ;
04172E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04172E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04172E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04172E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04172E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04172E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04172E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04172E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04172E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04172E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04172E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04172E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04172E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04172E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04172E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04172E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04172E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04172E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04172E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04172E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04172E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04172E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04172E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04172E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04172E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04172E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04172E             0191*  
04172E             0192*  ; Flags for the VPD protocol
04172E             0193*  ;
04172E             0194*  vdp_pflag_cursor:		EQU	00000001b
04172E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04172E             0196*  vdp_pflag_point:		EQU	00000100b
04172E             0197*  vdp_pflag_audio:		EQU	00001000b
04172E             0198*  vdp_pflag_mode:			EQU	00010000b
04172E             0199*  vdp_pflag_rtc:			EQU	00100000b
04172E             0200*  
04172E             0201*  ;
04172E             0202*  ; FatFS structures
04172E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04172E             0204*  ;
04172E             0205*  ; Object ID and allocation information (FFOBJID)
04172E             0206*  ;
04172E             0207*  ; Indexes into FFOBJID structure
04172E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04172E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04172E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04172E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04172E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04172E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04172E             0214*  ;
04172E             0215*  ; File object structure (FIL)
04172E             0216*  ;
04172E             0217*  ; Indexes into FIL structure
04172E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04172E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04172E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04172E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04172E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04172E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04172E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04172E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04172E             0226*  ;
04172E             0227*  ; Directory object structure (DIR)
04172E             0228*  ; Indexes into DIR structure
04172E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04172E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04172E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04172E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04172E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04172E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04172E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04172E             0236*  ;
04172E             0237*  ; File information structure (FILINFO)
04172E             0238*  ;
04172E             0239*  ; Indexes into FILINFO structure
04172E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04172E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04172E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04172E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04172E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04172E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04172E             0246*  ;
04172E             0247*  ; Macro for calling the API
04172E             0248*  ; Parameters:
04172E             0249*  ; - function: One of the function numbers listed above
04172E             0250*  ;
04172E             0251*  	MACRO	MOSCALL	function
04172E             0252*  			LD	A, function
04172E             0253*  			RST.LIL	08h
04172E             0254*  	ENDMACRO
04172E             0052       include "functions.inc"
04172E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04172E             0002*  ; Print a zero-terminated string
04172E             0003*  ; HL: Pointer to string
04172E             0004*  printString:
04172E C5          0005*  	PUSH	BC
04172F 01 00 00 00 0006*  	LD		BC,0
041733 3E 00       0007*  	LD 	 	A,0
041735 5B DF       0008*  	RST.LIL 18h
041737 C1          0009*  	POP		BC
041738 C9          0010*  	RET
041739             0011*  ; print a VDU sequence
041739             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
041739             0013*  sendVDUsequence:
041739 C5          0014*  	PUSH	BC
04173A 01 00 00 00 0015*  	LD		BC, 0
04173E 4E          0016*  	LD		C, (HL)
04173F 5B DF       0017*  	RST.LIL	18h
041741 C1          0018*  	POP		BC
041742 C9          0019*  	RET
041743             0020*  ; Print Newline sequence to VDP
041743             0021*  printNewLine:
041743 3E 0D       0022*  	LD	A, '\r'
041745 5B D7       0023*  	RST.LIL 10h
041747 3E 0A       0024*  	LD	A, '\n'
041749 5B D7       0025*  	RST.LIL 10h
04174B C9          0026*  	RET
04174C             0027*  ; Print a 24-bit HEX number
04174C             0028*  ; HLU: Number to print
04174C             0029*  printHex24:
04174C E5          0030*  	PUSH	HL
04174D 21 02 00 00 0031*  	LD		HL, 2
041751 39          0032*  	ADD		HL, SP
041752 7E          0033*  	LD		A, (HL)
041753 E1          0034*  	POP		HL
041754 CD 5E 17 04 0035*  	CALL	printHex8
041758             0036*  ; Print a 16-bit HEX number
041758             0037*  ; HL: Number to print
041758             0038*  printHex16:
041758 7C          0039*  	LD		A,H
041759 CD 5E 17 04 0040*  	CALL	printHex8
04175D 7D          0041*  	LD		A,L
04175E             0042*  ; Print an 8-bit HEX number
04175E             0043*  ; A: Number to print
04175E             0044*  printHex8:
04175E 4F          0045*  	LD		C,A
04175F 1F          0046*  	RRA
041760 1F          0047*  	RRA
041761 1F          0048*  	RRA
041762 1F          0049*  	RRA
041763 CD 68 17 04 0050*  	CALL	@F
041767 79          0051*  	LD		A,C
041768             0052*  @@:
041768 E6 0F       0053*  	AND		0Fh
04176A C6 90       0054*  	ADD		A,90h
04176C 27          0055*  	DAA
04176D CE 40       0056*  	ADC		A,40h
04176F 27          0057*  	DAA
041770 5B D7       0058*  	RST.LIL	10h
041772 C9          0059*  	RET
041773             0060*  
041773             0061*  ; Print a 0x HEX prefix
041773             0062*  DisplayHexPrefix:
041773 3E 30       0063*  	LD	A, '0'
041775 5B D7       0064*  	RST.LIL 10h
041777 3E 78       0065*  	LD	A, 'x'
041779 5B D7       0066*  	RST.LIL 10h
04177B C9          0067*  	RET
04177C             0068*  
04177C             0069*  
04177C             0070*  ; Prints the right justified decimal value in HL without leading zeroes
04177C             0071*  ; HL : Value to print
04177C             0072*  printDec:
04177C 11 A0 17 04 0073*  	LD	 DE, _printDecBuffer
041780 CD A9 17 04 0074*  	CALL Num2String
041784             0075*  ; BEGIN MY CODE
041784             0076*  ; replace leading zeroes with spaces
041784 21 A0 17 04 0077*      LD	 HL, _printDecBuffer
041788 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
04178A             0079*  @loop:
04178A 7E          0080*      LD	 A, (HL)
04178B FE 30       0081*      CP	 '0'
04178D C2 9B 17 04 0082*      JP	 NZ, @done
041791 3E 20       0083*      LD   A, ' '
041793 77          0084*      LD	 (HL), A
041794 23          0085*      INC	 HL
041795 CD 59 1B 04 0086*      CALL vdu_cursor_forward
041799 10 EF       0087*      DJNZ @loop
04179B             0088*  @done:
04179B             0089*  ; END MY CODE
04179B             0090*  	; LD	 HL, _printDecBuffer
04179B CD 2E 17 04 0091*  	CALL printString
04179F C9          0092*  	RET
0417A0 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0417A9             0094*  
0417A9             0095*  ; This routine converts the value from HL into it's ASCII representation,
0417A9             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0417A9             0097*  ; so it will allways be 8 characters length
0417A9             0098*  ; HL : Value to convert to string
0417A9             0099*  ; DE : pointer to buffer, at least 8 byte + 0
0417A9             0100*  Num2String:
0417A9 01 80 69 67 0101*  	LD	 BC,-10000000
0417AD CD E0 17 04 0102*  	CALL OneDigit
0417B1 01 C0 BD F0 0103*  	LD	 BC,-1000000
0417B5 CD E0 17 04 0104*  	CALL OneDigit
0417B9 01 60 79 FE 0105*  	LD	 BC,-100000
0417BD CD E0 17 04 0106*  	CALL OneDigit
0417C1 01 F0 D8 FF 0107*  	LD   BC,-10000
0417C5 CD E0 17 04 0108*  	CALL OneDigit
0417C9 01 18 FC FF 0109*  	LD   BC,-1000
0417CD CD E0 17 04 0110*  	CALL OneDigit
0417D1 01 9C FF FF 0111*  	LD   BC,-100
0417D5 CD E0 17 04 0112*  	CALL OneDigit
0417D9 0E F6       0113*  	LD   C,-10
0417DB CD E0 17 04 0114*  	CALL OneDigit
0417DF 48          0115*  	LD   C,B
0417E0             0116*  OneDigit:
0417E0 3E 2F       0117*  	LD   A,'0'-1
0417E2             0118*  DivideMe:
0417E2 3C          0119*  	INC  A
0417E3 09          0120*  	ADD  HL,BC
0417E4 38 FC       0121*  	JR   C,DivideMe
0417E6 ED 42       0122*  	SBC  HL,BC
0417E8 12          0123*  	LD   (DE),A
0417E9 13          0124*  	INC  DE
0417EA C9          0125*  	RET
0417EB             0126*  
0417EB             0127*  
0417EB             0128*  ; #### new functions added by Brandon R. Gates ####
0417EB             0129*  
0417EB             0130*  ; print the binary representation of the 8-bit value in a
0417EB             0131*  ; destroys a, hl, bc
0417EB             0132*  printBin8:
0417EB 06 08       0133*      ld b,8      ; loop counter for 8 bits
0417ED 21 08 18 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
0417F1             0135*                  ; (which will be the high bit of the value in a)
0417F1             0136*  @loop:
0417F1 07          0137*      rlca ; put the next highest bit into carry
0417F2 38 04       0138*      jr c,@one
0417F4 36 30       0139*      ld (hl),'0'
0417F6 18 02       0140*      jr @next_bit
0417F8             0141*  @one:
0417F8 36 31       0142*      ld (hl),'1'
0417FA             0143*  @next_bit:
0417FA 23          0144*      inc hl
0417FB 10 F4       0145*      djnz @loop
0417FD             0146*  ; print it
0417FD 21 08 18 04 0147*  	ld hl,@cmd
041801 01 08 00 00 0148*  	ld bc,@end-@cmd
041805 5B DF       0149*  	rst.lil $18
041807 C9          0150*  	ret
041808             0151*  @cmd: ds 8 ; eight bytes for eight bits
041810             0152*  @end:
041810             0153*  
041810             0154*  ; print the binary representation of the 8-bit value in a
041810             0155*  ; in reverse order (lsb first)
041810             0156*  ; destroys a, hl, bc
041810             0157*  printBin8Rev:
041810 06 08       0158*      ld b,8      ; loop counter for 8 bits
041812 21 2D 18 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
041816             0160*                  ; (which will be the high bit of the value in a)
041816             0161*  @loop:
041816 0F          0162*      rrca ; put the next lowest bit into carry
041817 38 04       0163*      jr c,@one
041819 36 30       0164*      ld (hl),'0'
04181B 18 02       0165*      jr @next_bit
04181D             0166*  @one:
04181D 36 31       0167*      ld (hl),'1'
04181F             0168*  @next_bit:
04181F 23          0169*      inc hl
041820 10 F4       0170*      djnz @loop
041822             0171*  ; print it
041822 21 2D 18 04 0172*  	ld hl,@cmd
041826 01 08 00 00 0173*  	ld bc,@end-@cmd
04182A 5B DF       0174*  	rst.lil $18
04182C C9          0175*  	ret
04182D             0176*  @cmd: ds 8 ; eight bytes for eight bits
041835             0177*  @end:
041835             0178*  
041835             0179*  ; print registers to screen in hexidecimal format
041835             0180*  ; inputs: none
041835             0181*  ; outputs: values of every register printed to screen
041835             0182*  ;    values of each register in global scratch memory
041835             0183*  ; destroys: nothing
041835             0184*  stepRegistersHex:
041835             0185*  ; store everything in scratch
041835 22 34 1A 04 0186*      ld (uhl),hl
041839 ED 43 37 1A 0187*      ld (ubc),bc
       04          
04183E ED 53 3A 1A 0188*      ld (ude),de
       04          
041843 DD 22 3D 1A 0189*      ld (uix),ix
       04          
041848 FD 22 40 1A 0190*      ld (uiy),iy
       04          
04184D F5          0191*      push af ; fml
04184E E1          0192*      pop hl  ; thanks, zilog
04184F 22 31 1A 04 0193*      ld (uaf),hl
041853 F5          0194*      push af ; dammit
041854             0195*  
041854             0196*  ; home the cursor
041854 CD 27 1B 04 0197*      call vdu_home_cursor
041858             0198*  
041858             0199*  ; print each register
041858 21 BD 19 04 0200*      ld hl,str_afu
04185C CD 2E 17 04 0201*      call printString
041860 2A 31 1A 04 0202*      ld hl,(uaf)
041864 CD 4C 17 04 0203*      call printHex24
041868 CD 43 17 04 0204*      call printNewLine
04186C             0205*  
04186C 21 C1 19 04 0206*      ld hl,str_hlu
041870 CD 2E 17 04 0207*      call printString
041874 2A 34 1A 04 0208*      ld hl,(uhl)
041878 CD 4C 17 04 0209*      call printHex24
04187C CD 43 17 04 0210*      call printNewLine
041880             0211*  
041880 21 C5 19 04 0212*      ld hl,str_bcu
041884 CD 2E 17 04 0213*      call printString
041888 2A 37 1A 04 0214*      ld hl,(ubc)
04188C CD 4C 17 04 0215*      call printHex24
041890 CD 43 17 04 0216*      call printNewLine
041894             0217*  
041894 21 C9 19 04 0218*      ld hl,str_deu
041898 CD 2E 17 04 0219*      call printString
04189C 2A 3A 1A 04 0220*      ld hl,(ude)
0418A0 CD 4C 17 04 0221*      call printHex24
0418A4 CD 43 17 04 0222*      call printNewLine
0418A8             0223*  
0418A8 21 CD 19 04 0224*      ld hl,str_ixu
0418AC CD 2E 17 04 0225*      call printString
0418B0 2A 3D 1A 04 0226*      ld hl,(uix)
0418B4 CD 4C 17 04 0227*      call printHex24
0418B8 CD 43 17 04 0228*      call printNewLine
0418BC             0229*  
0418BC 21 D1 19 04 0230*      ld hl,str_iyu
0418C0 CD 2E 17 04 0231*      call printString
0418C4 2A 40 1A 04 0232*      ld hl,(uiy)
0418C8 CD 4C 17 04 0233*      call printHex24
0418CC CD 43 17 04 0234*      call printNewLine
0418D0             0235*  
0418D0             0236*      ; call vdu_vblank
0418D0             0237*  
0418D0 CD 43 17 04 0238*      call printNewLine
0418D4             0239*  
0418D4             0240*  ; check for right shift key and quit if pressed
0418D4             0241*  	MOSCALL mos_getkbmap
0418D4 3E 1E       0001*M 			LD	A, function
0418D6 5B CF       0002*M 			RST.LIL	08h
0418D8             0242*  @stayhere:
0418D8             0243*  ; 7 RightShift
0418D8 DD CB 00 76 0244*      bit 6,(ix+0)
0418DC 20 02       0245*      jr nz,@RightShift
0418DE 18 F8       0246*      jr @stayhere
0418E0             0247*  @RightShift:
0418E0 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
0418E4 3E 80       0249*      ld a,%10000000
0418E6 CD 53 32 04 0250*      call multiPurposeDelay
0418EA             0251*  
0418EA             0252*  ; restore everything
0418EA 2A 34 1A 04 0253*      ld hl, (uhl)
0418EE ED 4B 37 1A 0254*      ld bc, (ubc)
       04          
0418F3 ED 5B 3A 1A 0255*      ld de, (ude)
       04          
0418F8 DD 2A 3D 1A 0256*      ld ix, (uix)
       04          
0418FD FD 2A 40 1A 0257*      ld iy, (uiy)
       04          
041902 F1          0258*      pop af
041903             0259*  ; all done
041903 C9          0260*      ret
041904             0261*  
041904             0262*  ; print registers to screen in hexidecimal format
041904             0263*  ; inputs: none
041904             0264*  ; outputs: values of every register printed to screen
041904             0265*  ;    values of each register in global scratch memory
041904             0266*  ; destroys: nothing
041904             0267*  dumpRegistersHex:
041904             0268*  ; store everything in scratch
041904 22 34 1A 04 0269*      ld (uhl),hl
041908 ED 43 37 1A 0270*      ld (ubc),bc
       04          
04190D ED 53 3A 1A 0271*      ld (ude),de
       04          
041912 DD 22 3D 1A 0272*      ld (uix),ix
       04          
041917 FD 22 40 1A 0273*      ld (uiy),iy
       04          
04191C F5          0274*      push af ; fml
04191D E1          0275*      pop hl  ; thanks, zilog
04191E 22 31 1A 04 0276*      ld (uaf),hl
041922 F5          0277*      push af ; dammit
041923             0278*  
041923             0279*  ; home the cursor
041923 CD 27 1B 04 0280*      call vdu_home_cursor
041927             0281*  
041927             0282*  ; print each register
041927 21 BD 19 04 0283*      ld hl,str_afu
04192B CD 2E 17 04 0284*      call printString
04192F 2A 31 1A 04 0285*      ld hl,(uaf)
041933 CD 4C 17 04 0286*      call printHex24
041937 CD 43 17 04 0287*      call printNewLine
04193B             0288*  
04193B 21 C1 19 04 0289*      ld hl,str_hlu
04193F CD 2E 17 04 0290*      call printString
041943 2A 34 1A 04 0291*      ld hl,(uhl)
041947 CD 4C 17 04 0292*      call printHex24
04194B CD 43 17 04 0293*      call printNewLine
04194F             0294*  
04194F 21 C5 19 04 0295*      ld hl,str_bcu
041953 CD 2E 17 04 0296*      call printString
041957 2A 37 1A 04 0297*      ld hl,(ubc)
04195B CD 4C 17 04 0298*      call printHex24
04195F CD 43 17 04 0299*      call printNewLine
041963             0300*  
041963 21 C9 19 04 0301*      ld hl,str_deu
041967 CD 2E 17 04 0302*      call printString
04196B 2A 3A 1A 04 0303*      ld hl,(ude)
04196F CD 4C 17 04 0304*      call printHex24
041973 CD 43 17 04 0305*      call printNewLine
041977             0306*  
041977 21 CD 19 04 0307*      ld hl,str_ixu
04197B CD 2E 17 04 0308*      call printString
04197F 2A 3D 1A 04 0309*      ld hl,(uix)
041983 CD 4C 17 04 0310*      call printHex24
041987 CD 43 17 04 0311*      call printNewLine
04198B             0312*  
04198B 21 D1 19 04 0313*      ld hl,str_iyu
04198F CD 2E 17 04 0314*      call printString
041993 2A 40 1A 04 0315*      ld hl,(uiy)
041997 CD 4C 17 04 0316*      call printHex24
04199B CD 43 17 04 0317*      call printNewLine
04199F             0318*  
04199F             0319*      ; call vdu_vblank
04199F             0320*  
04199F CD 43 17 04 0321*      call printNewLine
0419A3             0322*  ; restore everything
0419A3 2A 34 1A 04 0323*      ld hl, (uhl)
0419A7 ED 4B 37 1A 0324*      ld bc, (ubc)
       04          
0419AC ED 5B 3A 1A 0325*      ld de, (ude)
       04          
0419B1 DD 2A 3D 1A 0326*      ld ix, (uix)
       04          
0419B6 FD 2A 40 1A 0327*      ld iy, (uiy)
       04          
0419BB F1          0328*      pop af
0419BC             0329*  ; all done
0419BC C9          0330*      ret
0419BD             0331*  
0419BD 61 66 3D 00 0332*  str_afu: db "af=",0
0419C1 68 6C 3D 00 0333*  str_hlu: db "hl=",0
0419C5 62 63 3D 00 0334*  str_bcu: db "bc=",0
0419C9 64 65 3D 00 0335*  str_deu: db "de=",0
0419CD 69 78 3D 00 0336*  str_ixu: db "ix=",0
0419D1 69 79 3D 00 0337*  str_iyu: db "iy=",0
0419D5             0338*  
0419D5             0339*  ; print udeuhl to screen in hexidecimal format
0419D5             0340*  ; inputs: none
0419D5             0341*  ; outputs: concatenated hexidecimal udeuhl
0419D5             0342*  ; destroys: nothing
0419D5             0343*  dumpUDEUHLHex:
0419D5             0344*  ; store everything in scratch
0419D5 22 34 1A 04 0345*      ld (uhl),hl
0419D9 ED 43 37 1A 0346*      ld (ubc),bc
       04          
0419DE ED 53 3A 1A 0347*      ld (ude),de
       04          
0419E3 DD 22 3D 1A 0348*      ld (uix),ix
       04          
0419E8 FD 22 40 1A 0349*      ld (uiy),iy
       04          
0419ED F5          0350*      push af
0419EE             0351*  
0419EE             0352*  ; print each register
0419EE             0353*  
0419EE 21 28 1A 04 0354*      ld hl,str_udeuhl
0419F2 CD 2E 17 04 0355*      call printString
0419F6 2A 3A 1A 04 0356*      ld hl,(ude)
0419FA CD 4C 17 04 0357*      call printHex24
0419FE 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
041A00 5B D7       0359*  	rst.lil 10h
041A02 2A 34 1A 04 0360*      ld hl,(uhl)
041A06 CD 4C 17 04 0361*      call printHex24
041A0A CD 43 17 04 0362*      call printNewLine
041A0E             0363*  
041A0E             0364*  ; restore everything
041A0E 2A 34 1A 04 0365*      ld hl, (uhl)
041A12 ED 4B 37 1A 0366*      ld bc, (ubc)
       04          
041A17 ED 5B 3A 1A 0367*      ld de, (ude)
       04          
041A1C DD 2A 3D 1A 0368*      ld ix, (uix)
       04          
041A21 FD 2A 40 1A 0369*      ld iy, (uiy)
       04          
041A26 F1          0370*      pop af
041A27             0371*  ; all done
041A27 C9          0372*      ret
041A28             0373*  
041A28 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041A31             0375*  
041A31             0376*  ; global scratch memory for registers
041A31 00 00 00    0377*  uaf: dl 0
041A34 00 00 00    0378*  uhl: dl 0
041A37 00 00 00    0379*  ubc: dl 0
041A3A 00 00 00    0380*  ude: dl 0
041A3D 00 00 00    0381*  uix: dl 0
041A40 00 00 00    0382*  uiy: dl 0
041A43 00 00 00    0383*  usp: dl 0
041A46 00 00 00    0384*  upc: dl 0
041A49             0385*  
041A49             0386*  ; inputs: whatever is in the flags register
041A49             0387*  ; outputs: binary representation of flags
041A49             0388*  ;          with a header so we know which is what
041A49             0389*  ; destroys: nothing
041A49             0390*  ; preserves: everything
041A49             0391*  dumpFlags:
041A49             0392*  ; first we curse zilog for not giving direct access to flags
041A49 F5          0393*      push af ; this is so we can send it back unharmed
041A4A F5          0394*      push af ; this is so we can pop it to hl
041A4B             0395*  ; store everything in scratch
041A4B 22 34 1A 04 0396*      ld (uhl),hl
041A4F ED 43 37 1A 0397*      ld (ubc),bc
       04          
041A54 ED 53 3A 1A 0398*      ld (ude),de
       04          
041A59 DD 22 3D 1A 0399*      ld (uix),ix
       04          
041A5E FD 22 40 1A 0400*      ld (uiy),iy
       04          
041A63             0401*  ; next we print the header
041A63 21 8F 1A 04 0402*      ld hl,@header
041A67 CD 2E 17 04 0403*      call printString
041A6B E1          0404*      pop hl ; flags are now in l
041A6C 7D          0405*      ld a,l ; flags are now in a
041A6D CD EB 17 04 0406*      call printBin8
041A71 CD 43 17 04 0407*  	call printNewLine
041A75             0408*  ; restore everything
041A75 2A 34 1A 04 0409*      ld hl, (uhl)
041A79 ED 4B 37 1A 0410*      ld bc, (ubc)
       04          
041A7E ED 5B 3A 1A 0411*      ld de, (ude)
       04          
041A83 DD 2A 3D 1A 0412*      ld ix, (uix)
       04          
041A88 FD 2A 40 1A 0413*      ld iy, (uiy)
       04          
041A8D F1          0414*      pop af ; send her home the way she came
041A8E C9          0415*      ret
041A8F             0416*  ; Bit 7 (S): Sign flag
041A8F             0417*  ; Bit 6 (Z): Zero flag
041A8F             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041A8F             0419*  ; Bit 4 (H): Half Carry flag
041A8F             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041A8F             0421*  ; Bit 2 (PV): Parity/Overflow flag
041A8F             0422*  ; Bit 1 (N): Subtract flag
041A8F             0423*  ; Bit 0 (C): Carry flag
041A8F 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041A9A             0425*  
041A9A             0426*  ; set all the bits in the flag register
041A9A             0427*  ; more of an academic exercise than anything useful
041A9A             0428*  ; inputs; none
041A9A             0429*  ; outputs; a=0,f=255
041A9A             0430*  ; destroys: flags, hl
041A9A             0431*  ; preserves: a, because why not
041A9A             0432*  setAllFlags:
041A9A 21 FF 00 00 0433*      ld hl,255
041A9E 67          0434*      ld h,a ; four cycles to preserve a is cheap
041A9F E5          0435*      push hl
041AA0 F1          0436*      pop af
041AA1 C9          0437*      ret
041AA2             0438*  
041AA2             0439*  ; reset all the bits in the flag register
041AA2             0440*  ; unlike its inverse counterpart, this may actually be useful
041AA2             0441*  ; inputs; none
041AA2             0442*  ; outputs; a=0,f=0
041AA2             0443*  ; destroys: flags, hl
041AA2             0444*  ; preserves: a, because why not
041AA2             0445*  resetAllFlags:
041AA2 21 00 00 00 0446*      ld hl,0
041AA6 67          0447*      ld h,a ; four cycles to preserve a is cheap
041AA7 E5          0448*      push hl
041AA8 F1          0449*      pop af
041AA9 C9          0450*      ret
041AAA             0451*  
041AAA             0452*  ; wait until user presses a key
041AAA             0453*  ; inputs: none
041AAA             0454*  ; outputs: none
041AAA             0455*  ; destroys: af,ix
041AAA             0456*  waitKeypress:
041AAA             0457*      MOSCALL mos_sysvars
041AAA 3E 08       0001*M 			LD	A, function
041AAC 5B CF       0002*M 			RST.LIL	08h
041AAE AF          0458*      xor a ; zero out any prior keypresses
041AAF DD 77 05    0459*      ld (ix+sysvar_keyascii),a
041AB2             0460*  @loop:
041AB2 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
041AB5 A7          0462*      and a
041AB6 C0          0463*      ret nz
041AB7 18 F9       0464*      jr @loop
041AB9             0465*  
041AB9             0466*  
041AB9             0467*  ; print bytes from an address to the screen in hexidecimal format
041AB9             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041AB9             0469*  ; outputs: values of each byte printed to screen separated by spaces
041AB9             0470*  ; destroys: nothing
041AB9             0471*  dumpMemoryHex:
041AB9             0472*  ; save all registers to the stack
041AB9 F5          0473*      push af
041ABA C5          0474*      push bc
041ABB D5          0475*      push de
041ABC E5          0476*      push hl
041ABD DD E5       0477*      push ix
041ABF FD E5       0478*      push iy
041AC1             0479*  
041AC1             0480*  ; set b to be our loop counter
041AC1 47          0481*      ld b,a
041AC2             0482*  @loop:
041AC2             0483*  ; print the byte
041AC2 7E          0484*      ld a,(hl)
041AC3 CD 5E 17 04 0485*      call printHex8
041AC7             0486*  ; print a space
041AC7 3E 20       0487*      ld a,' '
041AC9 5B D7       0488*      rst.lil 10h
041ACB 23          0489*      inc hl
041ACC 10 F4       0490*      djnz @loop
041ACE CD 43 17 04 0491*      call printNewLine
041AD2             0492*  
041AD2             0493*  ; restore everything
041AD2 FD E1       0494*      pop iy
041AD4 DD E1       0495*      pop ix
041AD6 E1          0496*      pop hl
041AD7 D1          0497*      pop de
041AD8 C1          0498*      pop bc
041AD9 F1          0499*      pop af
041ADA             0500*  ; all done
041ADA C9          0501*      ret
041ADB             0502*  
041ADB             0503*  
041ADB             0504*  ; print bytes from an address to the screen in binary format
041ADB             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041ADB             0506*  ; outputs: values of each byte printed to screen separated by spaces
041ADB             0507*  ; destroys: nothing
041ADB             0508*  dumpMemoryBin:
041ADB             0509*  ; save all registers to the stack
041ADB F5          0510*      push af
041ADC C5          0511*      push bc
041ADD D5          0512*      push de
041ADE E5          0513*      push hl
041ADF DD E5       0514*      push ix
041AE1 FD E5       0515*      push iy
041AE3             0516*  
041AE3             0517*  ; set b to be our loop counter
041AE3 47          0518*      ld b,a
041AE4             0519*  @loop:
041AE4             0520*  ; print the byte
041AE4 7E          0521*      ld a,(hl)
041AE5 E5          0522*      push hl
041AE6 C5          0523*      push bc
041AE7 CD EB 17 04 0524*      call printBin8
041AEB C1          0525*      pop bc
041AEC             0526*  ; print a space
041AEC 3E 20       0527*      ld a,' '
041AEE 5B D7       0528*      rst.lil 10h
041AF0 E1          0529*      pop hl
041AF1 23          0530*      inc hl
041AF2 10 F0       0531*      djnz @loop
041AF4 CD 43 17 04 0532*      call printNewLine
041AF8             0533*  
041AF8             0534*  ; restore everything
041AF8 FD E1       0535*      pop iy
041AFA DD E1       0536*      pop ix
041AFC E1          0537*      pop hl
041AFD D1          0538*      pop de
041AFE C1          0539*      pop bc
041AFF F1          0540*      pop af
041B00             0541*  ; all done
041B00 C9          0542*      ret
041B01             0543*  
041B01             0544*  ; print bytes from an address to the screen in binary format
041B01             0545*  ; with the bits of each byte in reverse order (lsb first)
041B01             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041B01             0547*  ; outputs: values of each byte printed to screen separated by spaces
041B01             0548*  ; destroys: nothing
041B01             0549*  dumpMemoryBinRev:
041B01             0550*  ; save all registers to the stack
041B01 F5          0551*      push af
041B02 C5          0552*      push bc
041B03 D5          0553*      push de
041B04 E5          0554*      push hl
041B05 DD E5       0555*      push ix
041B07 FD E5       0556*      push iy
041B09             0557*  
041B09             0558*  ; set b to be our loop counter
041B09 47          0559*      ld b,a
041B0A             0560*  @loop:
041B0A             0561*  ; print the byte
041B0A 7E          0562*      ld a,(hl)
041B0B E5          0563*      push hl
041B0C C5          0564*      push bc
041B0D CD 10 18 04 0565*      call printBin8Rev
041B11 C1          0566*      pop bc
041B12             0567*  ; print a space
041B12 3E 20       0568*      ld a,' '
041B14 5B D7       0569*      rst.lil 10h
041B16 E1          0570*      pop hl
041B17 23          0571*      inc hl
041B18 10 F0       0572*      djnz @loop
041B1A CD 43 17 04 0573*      call printNewLine
041B1E             0574*  
041B1E             0575*  ; restore everything
041B1E FD E1       0576*      pop iy
041B20 DD E1       0577*      pop ix
041B22 E1          0578*      pop hl
041B23 D1          0579*      pop de
041B24 C1          0580*      pop bc
041B25 F1          0581*      pop af
041B26             0582*  ; all done
041B26 C9          0583*      ret
041B27             0053       include "vdu.inc"
041B27             0001*  
041B27             0002*  ; VDU 30: Home cursor
041B27             0003*  vdu_home_cursor:
041B27 3E 1E       0004*      ld a,30
041B29 5B D7       0005*  	rst.lil $10
041B2B C9          0006*  	ret
041B2C             0007*  
041B2C             0008*  vdu_cursor_on:
041B2C 21 37 1B 04 0009*  	ld hl,@cmd
041B30 01 03 00 00 0010*  	ld bc,@end-@cmd
041B34 5B DF       0011*  	rst.lil $18
041B36 C9          0012*  	ret
041B37             0013*  @cmd:
041B37 17 01 01    0014*  	db 23,1,1
041B3A             0015*  @end:
041B3A             0016*  
041B3A             0017*  vdu_cursor_off:
041B3A 21 45 1B 04 0018*  	ld hl,@cmd
041B3E 01 03 00 00 0019*  	ld bc,@end-@cmd
041B42 5B DF       0020*  	rst.lil $18
041B44 C9          0021*  	ret
041B45             0022*  @cmd:
041B45 17 01 00    0023*  	db 23,1,0
041B48             0024*  @end:
041B48             0025*  
041B48             0026*  ; VDU 5: Write text at graphics cursor
041B48             0027*  ; inputs: a is the character to write to the screen
041B48             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041B48             0029*  ; outputs: see the name of the function
041B48             0030*  ; destroys: a, hl, bc
041B48             0031*  vdu_char_to_gfx_cursor:
041B48 32 58 1B 04 0032*  	ld (@arg),a
041B4C 21 57 1B 04 0033*  	ld hl,@cmd
041B50 01 02 00 00 0034*  	ld bc,@end-@cmd
041B54 5B DF       0035*  	rst.lil $18
041B56 C9          0036*  	ret
041B57 05          0037*  @cmd: db 5
041B58 00          0038*  @arg: db 0
041B59             0039*  @end:
041B59             0040*  ; VDU 9: Move cursor forward one character
041B59             0041*  vdu_cursor_forward:
041B59 3E 09       0042*      ld a,9
041B5B 5B D7       0043*  	rst.lil $10
041B5D C9          0044*  	ret
041B5E             0045*  
041B5E             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041B5E             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041B5E             0048*  vdu_move_cursor:
041B5E ED 43 6F 1B 0049*      ld (@x0),bc
       04          
041B63 21 6E 1B 04 0050*  	ld hl,@cmd
041B67 01 03 00 00 0051*  	ld bc,@end-@cmd
041B6B 5B DF       0052*  	rst.lil $18
041B6D C9          0053*  	ret
041B6E 1F          0054*  @cmd: 	db 31
041B6F 00          0055*  @x0:	db 0
041B70 00          0056*  @y0: 	db 0
041B71 00          0057*  @end: 	db 0 ; padding
041B72             0058*  
041B72             0059*  ; VDU 12: Clear text area (CLS)
041B72             0060*  vdu_cls:
041B72 3E 0C       0061*      ld a,12
041B74 5B D7       0062*  	rst.lil $10
041B76 C9          0063*  	ret
041B77             0064*  
041B77             0065*  vdu_flip:
041B77 21 82 1B 04 0066*  	ld hl,@cmd
041B7B 01 03 00 00 0067*  	ld bc,@end-@cmd
041B7F 5B DF       0068*  	rst.lil $18
041B81 C9          0069*  	ret
041B82 17 00 C3    0070*  @cmd: db 23,0,0xC3
041B85             0071*  @end:
041B85             0072*  
041B85             0073*  ; VDU 16: Clear graphics area (CLG)
041B85             0074*  vdu_clg:
041B85 3E 10       0075*      ld a,16
041B87 5B D7       0076*  	rst.lil $10
041B89 C9          0077*  	ret
041B8A             0078*  
041B8A             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041B8A             0080*  ; VDU 23, 7: Scrolling
041B8A             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041B8A             0082*  ; inputs: a, extent; l, direction; h; speed
041B8A             0083*  vdu_scroll_down:
041B8A 32 9F 1B 04 0084*  	ld (@extent),a
041B8E 22 A0 1B 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041B92 21 9D 1B 04 0086*  	ld hl,@cmd
041B96 01 05 00 00 0087*  	ld bc,@end-@cmd
041B9A 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041B9C C9          0089*  	ret
041B9D 17 07       0090*  @cmd:       db 23,7
041B9F 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041BA0 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041BA1 00          0093*  @speed:     db 0x00 ; pixels
041BA2 00          0094*  @end:		db 0x00 ; padding
041BA3             0095*  
041BA3             0096*  ; COLOUR MODES
041BA3             0097*  ; Mode	Effect
041BA3             0098*  ; 0	Set on-screen pixel to target colour value
041BA3             0099*  ; 1	OR value with the on-screen pixel
041BA3             0100*  ; 2	AND value with the on-screen pixel
041BA3             0101*  ; 3	XOR value with the on-screen pixel
041BA3             0102*  ; 4	Invert the on-screen pixel
041BA3             0103*  ; 5	No operation
041BA3             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041BA3             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041BA3             0106*  
041BA3             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041BA3             0108*  vdu_colour_text:
041BA3 32 B3 1B 04 0109*  	ld (@arg),a
041BA7 21 B2 1B 04 0110*  	ld hl,@cmd
041BAB 01 02 00 00 0111*  	ld bc,@end-@cmd
041BAF 5B DF       0112*  	rst.lil $18
041BB1 C9          0113*  	ret
041BB2 11          0114*  @cmd: db 17
041BB3 00          0115*  @arg: db 0
041BB4             0116*  @end:
041BB4             0117*  
041BB4             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041BB4             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041BB4             0120*  vdu_gcol:
041BB4 32 C9 1B 04 0121*  	ld (@mode),a
041BB8 79          0122*      ld a,c
041BB9 32 CA 1B 04 0123*      ld (@col),a
041BBD 21 C8 1B 04 0124*  	ld hl,@cmd
041BC1 01 03 00 00 0125*  	ld bc,@end-@cmd
041BC5 5B DF       0126*  	rst.lil $18
041BC7 C9          0127*  	ret
041BC8 12          0128*  @cmd:  db 18
041BC9 00          0129*  @mode: db 0
041BCA 00          0130*  @col:  db 0
041BCB             0131*  @end:
041BCB             0132*  
041BCB             0133*  
041BCB             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041BCB             0135*  ; MIND THE LITTLE-ENDIANESS
041BCB             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041BCB             0137*  ; outputs; nothing
041BCB             0138*  ; destroys: a might make it out alive
041BCB             0139*  vdu_set_txt_viewport:
041BCB ED 43 E1 1B 0140*      ld (@lb),bc
       04          
041BD0 ED 53 E3 1B 0141*  	ld (@rt),de
       04          
041BD5 21 E0 1B 04 0142*  	ld hl,@cmd
041BD9 01 05 00 00 0143*  	ld bc,@end-@cmd
041BDD 5B DF       0144*  	rst.lil $18
041BDF C9          0145*  	ret
041BE0 1C          0146*  @cmd:   db 28 ; set text viewport command
041BE1 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041BE3 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041BE5 00          0149*  @end:   db 0x00	  ; padding
041BE6             0150*  
041BE6             0151*  ; Wait for VBLANK interrupt
041BE6             0152*  vdu_vblank:
041BE6 DD E5       0153*      PUSH 	IX
041BE8             0154*  	MOSCALL	mos_sysvars
041BE8 3E 08       0001*M 			LD	A, function
041BEA 5B CF       0002*M 			RST.LIL	08h
041BEC DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041BEF             0156*  @wait:
041BEF DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041BF2 28 FB       0158*      JR	Z, @wait
041BF4 DD E1       0159*      POP	IX
041BF6 C9          0160*      RET
041BF7             0161*  
041BF7             0162*  ; VDU 29, x; y;: Set graphics origin
041BF7             0163*  ; This command sets the graphics origin.
041BF7             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041BF7             0165*  ; inputs: bc=x0,de=y0
041BF7             0166*  ; outputs; nothing
041BF7             0167*  ; destroys: a might make it out alive
041BF7             0168*  vdu_set_gfx_origin:
041BF7 ED 43 0D 1C 0169*      ld (@x0),bc
       04          
041BFC ED 53 0F 1C 0170*      ld (@y0),de
       04          
041C01 21 0C 1C 04 0171*      ld hl,@cmd
041C05 01 05 00 00 0172*      ld bc,@end-@cmd
041C09 5B DF       0173*      rst.lil $18
041C0B C9          0174*      ret
041C0C 1D          0175*  @cmd:   db 29 ; set graphics origin command
041C0D 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041C0F 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041C11 00          0178*  @end:   db 0x00	  ; padding
041C12             0179*  
041C12             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041C12             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041C12             0182*  ; 	because we have turned off logical screen scaling
041C12             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041C12             0184*  ; outputs; nothing
041C12             0185*  ; destroys: a might make it out alive
041C12             0186*  vdu_set_gfx_viewport:
041C12 ED 43 32 1C 0187*      ld (@x0),bc
       04          
041C17 FD 22 34 1C 0188*      ld (@y1),iy
       04          
041C1C DD 22 36 1C 0189*  	ld (@x1),ix
       04          
041C21 ED 53 38 1C 0190*  	ld (@y0),de
       04          
041C26 21 31 1C 04 0191*  	ld hl,@cmd
041C2A 01 09 00 00 0192*  	ld bc,@end-@cmd
041C2E 5B DF       0193*  	rst.lil $18
041C30 C9          0194*  	ret
041C31 18          0195*  @cmd:   db 24 ; set graphics viewport command
041C32 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041C34 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041C36 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041C38 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041C3A 00          0200*  @end:   db 0x00	  ; padding
041C3B             0201*  
041C3B             0202*  ; SCREEN MODES
041C3B             0203*  ; ===============================
041C3B             0204*  ; Mode  Horz  Vert  Cols  Refresh
041C3B             0205*  ; ---   ----  ----  ----  -------
041C3B             0206*  ; 11    320   240   2     60hz
041C3B             0207*  ; 139   320   240   2     60hz
041C3B             0208*  ; 23    512   384   2     60hz
041C3B             0209*  ; 151   512   384   2     60hz
041C3B             0210*  ; 6     640   240   2     60hz
041C3B             0211*  ; 134   640   240   2     60hz
041C3B             0212*  ; 2     640   480   2     60hz
041C3B             0213*  ; 130   640   480   2     60hz
041C3B             0214*  ; 17    800   600   2     60hz
041C3B             0215*  ; 145   800   600   2     60hz
041C3B             0216*  ; 18    1024  768   2     60hz
041C3B             0217*  ; 146   1024  768   2     60hz
041C3B             0218*  ; ---   ----  ----  ----  -------
041C3B             0219*  ; 10    320   240   4     60hz
041C3B             0220*  ; 138   320   240   4     60hz
041C3B             0221*  ; 22    512   384   4     60hz
041C3B             0222*  ; 150   512   384   4     60hz
041C3B             0223*  ; 5     640   240   4     60hz
041C3B             0224*  ; 133   640   240   4     60hz
041C3B             0225*  ; 1     640   480   4     60hz
041C3B             0226*  ; 129   640   480   4     60hz
041C3B             0227*  ; 16    800   600   4     60hz
041C3B             0228*  ; 19    1024  768   4     60hz
041C3B             0229*  ; ---   ----  ----  ----  -------
041C3B             0230*  ; 9     320   240   16    60hz
041C3B             0231*  ; 137   320   240   16    60hz
041C3B             0232*  ; 21    512   384   16    60hz
041C3B             0233*  ; 149   512   384   16    60hz
041C3B             0234*  ; 4     640   240   16    60hz
041C3B             0235*  ; 132   640   240   16    60hz
041C3B             0236*  ; 0     640   480   16    60hz
041C3B             0237*  ; 7     n/a   n/a   16    60hz
041C3B             0238*  ; ---   ----  ----  ----  -------
041C3B             0239*  ; 8     320   240   64    60hz
041C3B             0240*  ; 136   320   240   64    60hz
041C3B             0241*  ; 20    512   384   64    60hz
041C3B             0242*  ; 3     640   240   64    60hz
041C3B             0243*  ; ---   ----  ----  ----  -------
041C3B             0244*  vdu_set_screen_mode:
041C3B 32 4B 1C 04 0245*  	ld (@arg),a
041C3F 21 4A 1C 04 0246*  	ld hl,@cmd
041C43 01 02 00 00 0247*  	ld bc,@end-@cmd
041C47 5B DF       0248*  	rst.lil $18
041C49 C9          0249*  	ret
041C4A 16          0250*  @cmd: db 22 ; set screen mode
041C4B 00          0251*  @arg: db 0  ; screen mode parameter
041C4C             0252*  @end:
041C4C             0253*  
041C4C             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041C4C             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041C4C             0256*  ; note: default setting on boot is scaling ON
041C4C             0257*  vdu_set_scaling:
041C4C 32 5E 1C 04 0258*  	ld (@arg),a
041C50 21 5B 1C 04 0259*  	ld hl,@cmd
041C54 01 04 00 00 0260*  	ld bc,@end-@cmd
041C58 5B DF       0261*  	rst.lil $18
041C5A C9          0262*  	ret
041C5B 17 00 C0    0263*  @cmd: db 23,0,0xC0
041C5E 00          0264*  @arg: db 0  ; scaling on/off
041C5F             0265*  @end:
041C5F             0266*  
041C5F             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041C5F             0268*  ; inputs: hl=bufferId
041C5F             0269*  vdu_buff_select:
041C5F 22 71 1C 04 0270*  	ld (@bufferId),hl
041C63 21 6E 1C 04 0271*  	ld hl,@cmd
041C67 01 05 00 00 0272*  	ld bc,@end-@cmd
041C6B 5B DF       0273*  	rst.lil $18
041C6D C9          0274*  	ret
041C6E 17 1B 20    0275*  @cmd: db 23,27,0x20
041C71 00 00       0276*  @bufferId: dw 0x0000
041C73 00          0277*  @end: db 0x00 ; padding
041C74             0278*  
041C74             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041C74             0280*  ; inputs: a=format; bc=width; de=height
041C74             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041C74             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041C74             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041C74             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041C74             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041C74             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041C74             0287*  vdu_bmp_create:
041C74 ED 43 90 1C 0288*      ld (@width),bc
       04          
041C79 ED 53 92 1C 0289*      ld (@height),de
       04          
041C7E 32 94 1C 04 0290*      ld (@fmt),a
041C82 21 8D 1C 04 0291*  	ld hl,@cmd
041C86 01 08 00 00 0292*  	ld bc,@end-@cmd
041C8A 5B DF       0293*  	rst.lil $18
041C8C C9          0294*  	ret
041C8D 17 1B 21    0295*  @cmd:       db 23,27,0x21
041C90 00 00       0296*  @width:     dw 0x0000
041C92 00 00       0297*  @height:    dw 0x0000
041C94 00          0298*  @fmt:       db 0x00
041C95             0299*  @end:
041C95             0300*  
041C95             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041C95             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041C95             0303*  vdu_load_img_rgba2_to_8:
041C95             0304*  ; backup the target buffer id and image dimensions
041C95 E5          0305*      push hl
041C96 D5          0306*      push de
041C97 C5          0307*      push bc
041C98             0308*  ; load the rgba2 image to working buffer 65534
041C98 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041C9C CD 9F 1D 04 0310*  	call vdu_load_buffer_from_file
041CA0             0311*  ; restore the image dimensions and target buffer id
041CA0 C1          0312*      pop bc
041CA1 D1          0313*      pop de
041CA2 E1          0314*      pop hl
041CA3             0315*  ; fall through to vdu_rgba2_to_8
041CA3             0316*  
041CA3             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041CA3             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041CA3             0319*  ; the "expand bitmap" command is:
041CA3             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CA3             0321*  ; and then to reverse the byte order to fix endian-ness:
041CA3             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CA3             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CA3             0324*  ; VDU 23,27,&20,targetBufferID%;
041CA3             0325*  ; VDU 23,27,&21,width%;height%;0
041CA3             0326*  ; -------------------------------------------------------------------
041CA3             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041CA3             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041CA3             0329*  vdu_rgba2_to_8:
041CA3             0330*  ; load the image dimensions and buffer id parameters
041CA3 ED 43 FF 1C 0331*      ld (@width),bc
       04          
041CA8 ED 53 01 1D 0332*      ld (@height),de
       04          
041CAD 22 E4 1C 04 0333*      ld (@bufferId0),hl
041CB1 22 F1 1C 04 0334*      ld (@bufferId2),hl
041CB5 22 FA 1C 04 0335*      ld (@bufferId1),hl
041CB9             0336*  ; clean up bytes that got stomped on by the ID loads
041CB9 3E 48       0337*      ld a,0x48
041CBB 32 E6 1C 04 0338*      ld (@bufferId0+2),a
041CBF 3E 17       0339*      ld a,23
041CC1 32 FC 1C 04 0340*      ld (@bufferId1+2),a
041CC5 3E 18       0341*      ld a,24
041CC7 32 F3 1C 04 0342*      ld (@bufferId2+2),a
041CCB AF          0343*      xor a
041CCC 32 03 1D 04 0344*      ld (@height+2),a
041CD0             0345*  ; send the vdu command strings
041CD0 21 DB 1C 04 0346*      ld hl,@beg
041CD4 01 29 00 00 0347*      ld bc,@end-@beg
041CD8 5B DF       0348*      rst.lil $18
041CDA C9          0349*      ret
041CDB             0350*  @beg:
041CDB             0351*  ; Command 14: Consolidate blocks in a buffer
041CDB             0352*  ; VDU 23, 0, &A0, bufferId; 14
041CDB 17 00 A0    0353*      db 23,0,0xA0
041CDE FE FF       0354*      dw 65534 ; workingBufferId
041CE0 0E          0355*      db 14 ; consolidate blocks
041CE1             0356*  ; the "expand bitmap" command is:
041CE1             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CE1 17 00 A0    0358*      db 23,0,0xA0
041CE4 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041CE6 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041CE7 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041CE8 FE FF       0362*      dw 65534 ; sourceBufferId
041CEA 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041CEE             0364*  ; reverse the byte order to fix endian-ness:
041CEE             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041CEE             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041CEE             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CEE 17 00 A0    0368*      db 23,0,0xA0
041CF1 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041CF3 18          0370*      db 24 ; reverse byte order
041CF4 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041CF5 04 00       0372*      dw 4 ; size (4 bytes)
041CF7             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CF7             0374*  ; VDU 23,27,&20,targetBufferID%;
041CF7 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041CFA 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041CFC             0377*  ; VDU 23,27,&21,width%;height%;0
041CFC 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041CFF 00 00       0379*  @width: dw 0x0000
041D01 00 00       0380*  @height: dw 0x0000
041D03 00          0381*      db 0x00 ; rgba8888 format
041D04             0382*  @end:
041D04             0383*  
041D04             0384*  ; scratch variables
041D04 00 00 00    0385*  bufferId0: dl 0x000000
041D07 00 00 00    0386*  bufferId1: dl 0x000000
041D0A             0387*  
041D0A             0388*  ; load a vdu buffer from local memory
041D0A             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041D0A             0390*  vdu_load_buffer:
041D0A ED 43 33 1D 0391*      ld (@length),bc
       04          
041D0F D5          0392*      push de ; save data pointer
041D10             0393*  ; send the vdu command string
041D10 7D          0394*      ld a,l
041D11 32 30 1D 04 0395*      ld (@bufferId),a
041D15 7C          0396*      ld a,h
041D16 32 31 1D 04 0397*      ld (@bufferId+1),a
041D1A 21 2D 1D 04 0398*      ld hl,@cmd
041D1E 01 08 00 00 0399*      ld bc,@end-@cmd
041D22 5B DF       0400*      rst.lil $18
041D24             0401*  ; send the buffer data
041D24 E1          0402*      pop hl ; pointer to data
041D25 ED 4B 33 1D 0403*      ld bc,(@length)
       04          
041D2A 5B DF       0404*      rst.lil $18 ; send it
041D2C C9          0405*      ret
041D2D             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D2D 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041D30 00 00       0408*  @bufferId:	dw 0x0000
041D32 00          0409*  		    db 0 ; load buffer
041D33 00 00       0410*  @length:	dw 0x0000
041D35 00          0411*  @end: db 0 ; padding
041D36             0412*  
041D36             0413*  ; clear a buffer
041D36             0414*  ; inputs: hl = bufferId
041D36             0415*  vdu_clear_buffer:
041D36 7D          0416*      ld a,l
041D37 32 4E 1D 04 0417*      ld (@bufferId),a
041D3B 7C          0418*      ld a,h
041D3C 32 4F 1D 04 0419*      ld (@bufferId+1),a
041D40 21 4B 1D 04 0420*      ld hl,@cmd
041D44 01 06 00 00 0421*      ld bc,@end-@cmd
041D48 5B DF       0422*      rst.lil $18
041D4A C9          0423*      ret
041D4B 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041D4E 00 00       0425*  @bufferId:	dw 0x0000
041D50 02          0426*  		    db 2 ; clear buffer
041D51             0427*  @end:
041D51             0428*  
041D51             0429*  vdu_clear_all_buffers:
041D51             0430*  ; clear all buffers
041D51 21 5C 1D 04 0431*      ld hl,@beg
041D55 01 06 00 00 0432*      ld bc,@end-@beg
041D59 5B DF       0433*      rst.lil $18
041D5B C9          0434*      ret
041D5C 17 00 A0    0435*  @beg: db 23,0,$A0
041D5F FF FF       0436*        dw -1 ; clear all buffers
041D61 02          0437*        db 2  ; command 2: clear a buffer
041D62             0438*  @end:
041D62             0439*  
041D62             0440*  ; Command 14: Consolidate blocks in a buffer
041D62             0441*  vdu_consolidate_buffer:
041D62             0442*  ; set parameters for vdu call
041D62 7D          0443*      ld a,l
041D63 32 7A 1D 04 0444*      ld (@bufferId),a
041D67 7C          0445*      ld a,h
041D68 32 7B 1D 04 0446*      ld (@bufferId+1),a
041D6C 21 77 1D 04 0447*      ld hl,@beg
041D70 01 06 00 00 0448*      ld bc,@end-@beg
041D74 5B DF       0449*      rst.lil $18
041D76 C9          0450*      ret
041D77             0451*  ; VDU 23, 0, &A0, bufferId; 14
041D77 17 00 A0    0452*  @beg: db 23,0,0xA0
041D7A 00 00       0453*  @bufferId: dw 0x0000
041D7C 0E          0454*             db 14
041D7D             0455*  @end:
041D7D             0456*  
041D7D             0457*  ; load an image file to a buffer and make it a bitmap
041D7D             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041D7D             0459*  vdu_load_img:
041D7D             0460*  ; back up image type and dimension parameters
041D7D 22 04 1D 04 0461*      ld (bufferId0),hl
041D81 F5          0462*      push af
041D82 C5          0463*  	push bc
041D83 D5          0464*  	push de
041D84             0465*  ; load the image
041D84 CD 9F 1D 04 0466*  	call vdu_load_buffer_from_file
041D88             0467*  ; now make it a bitmap
041D88 2A 04 1D 04 0468*      ld hl,(bufferId0)
041D8C CD 62 1D 04 0469*      call vdu_consolidate_buffer
041D90 2A 04 1D 04 0470*      ld hl,(bufferId0)
041D94 CD 5F 1C 04 0471*      call vdu_buff_select
041D98 D1          0472*  	pop de ; image height
041D99 C1          0473*  	pop bc ; image width
041D9A F1          0474*  	pop af ; image type
041D9B C3 74 1C 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041D9F             0476*  
041D9F             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041D9F             0478*  vdu_load_buffer_from_file:
041D9F 22 04 1D 04 0479*      ld (bufferId0),hl
041DA3             0480*  
041DA3             0481*  ; clear target buffer
041DA3 CD 36 1D 04 0482*      call vdu_clear_buffer
041DA7             0483*  
041DA7             0484*  ; open the file in read mode
041DA7             0485*  ; Open a file
041DA7             0486*  ; HLU: Filename
041DA7             0487*  ;   C: Mode
041DA7             0488*  ; Returns:
041DA7             0489*  ;   A: Filehandle, or 0 if couldn't open
041DA7 FD E5       0490*  	push iy ; pointer to filename
041DA9 E1          0491*  	pop hl
041DAA 0E 01       0492*  	ld c,fa_read
041DAC             0493*      MOSCALL mos_fopen
041DAC 3E 0A       0001*M 			LD	A, function
041DAE 5B CF       0002*M 			RST.LIL	08h
041DB0 32 EB 1D 04 0494*      ld (@filehandle),a
041DB4             0495*  
041DB4             0496*  @read_file:
041DB4             0497*  ; Read a block of data from a file
041DB4             0498*  ;   C: Filehandle
041DB4             0499*  ; HLU: Pointer to where to write the data to
041DB4             0500*  ; DEU: Number of bytes to read
041DB4             0501*  ; Returns:
041DB4             0502*  ; DEU: Number of bytes read
041DB4 3A EB 1D 04 0503*      ld a,(@filehandle)
041DB8 4F          0504*      ld c,a
041DB9 21 00 E0 B7 0505*      ld hl,filedata
041DBD 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041DC1             0507*      MOSCALL mos_fread
041DC1 3E 1A       0001*M 			LD	A, function
041DC3 5B CF       0002*M 			RST.LIL	08h
041DC5             0508*  
041DC5             0509*  ; ; DEBUG: print chunk size
041DC5             0510*  ;     push de
041DC5             0511*  ;     pop hl
041DC5             0512*  ;     call printDec
041DC5             0513*  ;     call printNewLine
041DC5             0514*  
041DC5             0515*  ; test de for zero bytes read
041DC5 21 00 00 00 0516*      ld hl,0
041DC9 AF          0517*      xor a ; clear carry
041DCA ED 52       0518*      sbc hl,de
041DCC CA E2 1D 04 0519*      jp z,@close_file
041DD0             0520*  
041DD0             0521*  ; load a vdu buffer from local memory
041DD0             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041DD0 2A 04 1D 04 0523*      ld hl,(bufferId0)
041DD4 D5          0524*      push de ; chunksize
041DD5 C1          0525*      pop bc
041DD6 11 00 E0 B7 0526*      ld de,filedata
041DDA CD 0A 1D 04 0527*      call vdu_load_buffer
041DDE             0528*  
041DDE             0529*  ; ; print progress breadcrumbs
041DDE             0530*  ;     ld a,'.'
041DDE             0531*  ;     rst.lil 10h
041DDE             0532*  
041DDE             0533*  ; read the next block
041DDE C3 B4 1D 04 0534*      jp @read_file
041DE2             0535*  
041DE2             0536*  ; close the file
041DE2             0537*  @close_file:
041DE2 3A EB 1D 04 0538*      ld a,(@filehandle)
041DE6             0539*      MOSCALL mos_fclose
041DE6 3E 0B       0001*M 			LD	A, function
041DE8 5B CF       0002*M 			RST.LIL	08h
041DEA C9          0540*      ret ; vdu_load_buffer_from_file
041DEB             0541*  
041DEB 00          0542*  @filehandle: db 0 ; file handle
041DEC 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
041DEF             0544*  
041DEF 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
041DF2             0546*  
041DF2             0547*  ; File information structure (FILINFO)
041DF2             0548*  @filinfo:
041DF2 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041DF6 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041DF8 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041DFA 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041DFB 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041E08 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041F08             0054       include "vdu_buff.inc"
041F08             0001*  ; VDP Buffered Commands API
041F08             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
041F08             0003*  
041F08             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F08             0005*  ; This command is used to store a data block (a sequence of bytes)
041F08             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
041F08             0007*  ; It could be a sequence of VDU commands which can be executed
041F08             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
041F08             0009*  ; When used for a sequence of VDU commands, this effectively
041F08             0010*  ; allows for functions or stored procedures to be created.
041F08             0011*  
041F08             0012*  ; This is the most common command to use to send data to the VDP.
041F08             0013*  ; Typically you will call command 2 first to ensure that the
041F08             0014*  ; buffer is empty, and then make a series of calls to this command
041F08             0015*  ; to send data to the buffer.
041F08             0016*  
041F08             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
041F08             0018*  ; write to. Writing to the same buffer ID multiple times will add
041F08             0019*  ; new blocks to that buffer. This allows a buffer to be built up
041F08             0020*  ; over time, essentially allowing for a command to be sent across
041F08             0021*  ; to the VDP in multiple separate packets.
041F08             0022*  
041F08             0023*  ; Whilst the length of an individual block added using this command
041F08             0024*  ; is restricted to 65535 bytes (as the largest value that can be
041F08             0025*  ; sent in a 16-bit number) the total size of a buffer is not
041F08             0026*  ; restricted to this size, as multiple blocks can be added to a
041F08             0027*  ; buffer. Given how long it takes to send data to the VDP it is
041F08             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
041F08             0029*  ; data or less at a time.
041F08             0030*  
041F08             0031*  ; As writing to a single buffer ID is cumulative with this command,
041F08             0032*  ; care should be taken to ensure that the buffer is cleared out
041F08             0033*  ; before writing to it.
041F08             0034*  
041F08             0035*  ; When building up a complex sequence of commands it is often
041F08             0036*  ; advisable to use multiple blocks within a buffer. Typically
041F08             0037*  ; this is easier to code, as otherwise working out exactly how
041F08             0038*  ; many bytes long a command sequence is can be can be onerously
041F08             0039*  ; difficult. It is also easier to modify a command sequences that
041F08             0040*  ; are broken up into multiple blocks.
041F08             0041*  
041F08             0042*  ; As mentioned above it is advisable to send large pieces of data,
041F08             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
041F08             0044*  ; each packet of data sent to a buffer, the user can then perform
041F08             0045*  ; other operations, such as updating the screen to indicate
041F08             0046*  ; progress. This allows for long-running operations to be performed
041F08             0047*  ; without blocking the screen, and larger amounts of data to be
041F08             0048*  ; transferred over to the VDP than may otherwise be practical given
041F08             0049*  ; the limitations of the eZ80.
041F08             0050*  
041F08             0051*  ; If a buffer ID of 65535 is used then this command will be
041F08             0052*  ; ignored, and the data discarded. This is because this buffer ID
041F08             0053*  ; is reserved for special functions.
041F08             0054*  
041F08             0055*  ; Using buffers for bitmaps
041F08             0056*  
041F08             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
041F08             0058*  ; they cannot be used if they are spread over multiple blocks.
041F08             0059*  ; To use a bitmap its data must be in a single contiguous block,
041F08             0060*  ; and this is achieved by using the “consolidate” command &0E.
041F08             0061*  
041F08             0062*  ; Once you have a block that is ready to be used for a bitmap,
041F08             0063*  ; the buffer must be selected, and then a bitmap created for that
041F08             0064*  ; buffer using the bitmap and sprites API. This is done with the
041F08             0065*  ; following commands:
041F08             0066*  
041F08             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
041F08             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
041F08             0069*  
041F08             0070*  ; Until the “create bitmap” call has been made the buffer cannot
041F08             0071*  ; be used as a bitmap. That is because the system needs to
041F08             0072*  ; understand the dimensions of the bitmap, as well as the format
041F08             0073*  ; of the data. Usually this only needs to be done once. The format
041F08             0074*  ; is given as an 8-bit value, with the following values supported:
041F08             0075*  ; Value 	Type 	Description
041F08             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
041F08             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
041F08             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
041F08             0079*  
041F08             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
041F08             0081*  ; and these are automatically stored in buffers numbered 64000-64255
041F08             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
041F08             0083*  ; simply a matter of adding 64000. All bitmaps created with that
041F08             0084*  ; API will be RGBA8888 format.
041F08             0085*  
041F08             0086*  ; There is one other additional call added to the bitmap and
041F08             0087*  ; sprites API, which allows for bitmaps referenced with a
041F08             0088*  ; buffer ID to be added to sprites. This is done with the
041F08             0089*  ; following command:
041F08             0090*  
041F08             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
041F08             0092*  
041F08             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
041F08             0094*  
041F08             0095*  ; It should be noted that it is possible to modify the buffer
041F08             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
041F08             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
041F08             0098*  ; can allow you to do things such as changing colours in a bitmap,
041F08             0099*  ; or flipping an image horizontally or vertically. This will even
041F08             0100*  ; work on bitmaps that are being used inside sprites.
041F08             0101*  
041F08             0102*  ; Using commands targetting a buffer that create new blocks,
041F08             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
041F08             0104*  ; and remove it from use.
041F08             0105*  
041F08             0106*  ; Using buffers for sound samples
041F08             0107*  
041F08             0108*  ; Much like with bitmaps, it is advisable to send samples over
041F08             0109*  ; to the VDP in multiple blocks for the same reasons.
041F08             0110*  
041F08             0111*  ; In contrast to bitmaps, the sound system can play back samples
041F08             0112*  ; that are spread over multiple blocks, so there is no need to
041F08             0113*  ; consolidate buffers. As a result of this, the sample playback
041F08             0114*  ; system is also more tolerant of modifications being made to
041F08             0115*  ; the buffer after a sample has been created from it, even if
041F08             0116*  ; the sample is currently playing. It should be noted that
041F08             0117*  ; splitting a buffer may result in unexpected behaviour if
041F08             0118*  ; the sample is currently playing, such as skipping to other
041F08             0119*  ; parts of the sample.
041F08             0120*  
041F08             0121*  ; Once you have a buffer that contains block(s) that are ready
041F08             0122*  ; to be used for a sound sample, the following command must be
041F08             0123*  ; used to indicate that a sample should be created from that buffer:
041F08             0124*  
041F08             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
041F08             0126*  
041F08             0127*  ; The format parameter is an 8-bit value that indicates the
041F08             0128*  ; format of the sample data. The following values are supported:
041F08             0129*  ; Value 	Description
041F08             0130*  ; 0 	8-bit signed, 16KHz
041F08             0131*  ; 1 	8-bit unsigned, 16KHz
041F08             0132*  
041F08             0133*  ; Once a sample has been created in this way, the sample can
041F08             0134*  ; be selected for use on a channel using the following command:
041F08             0135*  
041F08             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
041F08             0137*  
041F08             0138*  ; Samples uploaded using the existing “load sample” command
041F08             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
041F08             0140*  ; are also stored in buffers automatically. A sample number using this system is in
041F08             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
041F08             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
041F08             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
041F08             0144*  ; buffer 64257, and so on.
041F08             0145*  ; Command 1: Call a buffer
041F08             0146*  
041F08             0147*  ; VDU 23, 0 &A0, bufferId; 1
041F08             0148*  
041F08             0149*  ; This command will attempt to execute all of the commands
041F08             0150*  ; stored in the buffer with the given ID. If the buffer does
041F08             0151*  ; not exist, or is empty, then this command will do nothing.
041F08             0152*  
041F08             0153*  ; Essentially, this command passes the contents of the buffer
041F08             0154*  ; to the VDP’s VDU command processor system, and executes them
041F08             0155*  ; as if they were sent directly to the VDP.
041F08             0156*  
041F08             0157*  ; As noted against command 0, it is possible to build up a
041F08             0158*  ; buffer over time by sending across multiple commands to write
041F08             0159*  ; to the same buffer ID. When calling a buffer with multiple
041F08             0160*  ; blocks, the blocks are executed in order.
041F08             0161*  
041F08             0162*  ; Care should be taken when using this command within a buffer,
041F08             0163*  ; as it is possible to create an infinite loop. For instance,
041F08             0164*  ; if a buffer contains a command to call itself, then this will
041F08             0165*  ; result in an infinite loop. This will cause the VDP to hang,
041F08             0166*  ; and the only way to recover from this is to reset the VDP.
041F08             0167*  
041F08             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
041F08             0169*  ; to be executed. This can be useful for creating loops within
041F08             0170*  ; a buffer. It will be ignored if used outside of a buffered
041F08             0171*  ; command sequence.
041F08             0172*  
041F08             0173*  ; Command 2: Clear a buffer
041F08             0174*  ; VDU 23, 0 &A0, bufferId; 2
041F08             0175*  
041F08             0176*  ; This command will clear the buffer with the given ID. If
041F08             0177*  ; the buffer does not exist then this command will do nothing.
041F08             0178*  
041F08             0179*  ; Please note that this clears out all of the blocks sent to
041F08             0180*  ; a buffer via command 0, not just the last one. i.e. if you
041F08             0181*  ; have built up a buffer over time by sending multiple commands
041F08             0182*  ; to write to the same buffer ID, this command will clear out
041F08             0183*  ; all of those commands.
041F08             0184*  
041F08             0185*  ; Calling this command with a bufferId value of -1 (65535) will
041F08             0186*  ; clear out all buffers.
041F08             0187*  
041F08             0188*  ; Command 3: Create a writeable buffer
041F08             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
041F08             0190*  ; This command will create a new writeable buffer with the given
041F08             0191*  ; ID. If a buffer with the given ID already exists then this
041F08             0192*  ; command will do nothing. This command is primarily intended
041F08             0193*  ; for use to create a buffer that can be used to capture output
041F08             0194*  ; using the “set output stream” command (see below), or to store
041F08             0195*  ; data that can be used for other commands.
041F08             0196*  
041F08             0197*  ; It is generally quite rare that you will want to use this
041F08             0198*  ; command. Typically you will instead want to use command 0
041F08             0199*  ; to write data to a buffer. It is not necessary to use this
041F08             0200*  ; command before using command 0, and indeed doing so will
041F08             0201*  ; lead to errors as you will end up with two blocks in the
041F08             0202*  ; buffer, the first of which will be empty. If you do wish
041F08             0203*  ; to use this command to create a buffer for data and then
041F08             0204*  ; write to it, you would need to use operation 2 of command 5,
041F08             0205*  ; the “set” operation in the “buffer adjust” command, to set a
041F08             0206*  ; sequence of bytes in the buffer to the data you want to write.
041F08             0207*  ; This is not recommended, as it is much easier to just use
041F08             0208*  ; command 0 to write a data block to a buffer.
041F08             0209*  
041F08             0210*  ; This new buffer will be a single empty single block upon
041F08             0211*  ; creation, containing zeros.
041F08             0212*  
041F08             0213*  ; The length parameter is a 16-bit integer that specifies
041F08             0214*  ; the maximum size of the buffer. This is the maximum number
041F08             0215*  ; of bytes that can be stored in the buffer. If the buffer
041F08             0216*  ; is full then no more data can be written to it, and subsequent
041F08             0217*  ; writes will be ignored.
041F08             0218*  
041F08             0219*  ; After creating a buffer with this command it is possible to
041F08             0220*  ; use command 0 to write further blocks to the buffer, however
041F08             0221*  ; this is probably not advisable.
041F08             0222*  
041F08             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
041F08             0224*  ; values have special meanings for writable buffers. See command 4.
041F08             0225*  
041F08             0226*  ; Command 4: Set output stream to a buffer
041F08             0227*  ; VDU 23, 0 &A0, bufferId; 4
041F08             0228*  
041F08             0229*  ; Sets then current output stream to the buffer with the given ID.
041F08             0230*  ; With two exceptions, noted below, this needs to be a writable
041F08             0231*  ; buffer created with command 3. If the buffer does not exist,
041F08             0232*  ; or the first block within the buffer is not writable, then
041F08             0233*  ; this command will do nothing.
041F08             0234*  
041F08             0235*  ; Following this command, any subsequent VDU commands that send
041F08             0236*  ; response packets will have those packets written to the specified
041F08             0237*  ; output buffer. This allows the user to capture the response
041F08             0238*  ; packets from a command sent to the VDP.
041F08             0239*  
041F08             0240*  ; By default, the output stream (for the main VDU command processor)
041F08             0241*  ; is the communications channel from the VDP to MOS running on the
041F08             0242*  ; eZ80.
041F08             0243*  
041F08             0244*  ; Passing a buffer ID of -1 (65535) to this command will
041F08             0245*  ; remove/detach the output buffer. From that point onwards,
041F08             0246*  ; any subsequent VDU commands that send response packets will
041F08             0247*  ; have those responses discarded/ignored.
041F08             0248*  
041F08             0249*  ; Passing a buffer ID of 0 to this command will set the output
041F08             0250*  ; buffer back to its original value for the current command stream.
041F08             0251*  ; Typically that will be the communications channel from the VDP to
041F08             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
041F08             0253*  ; call has been made.
041F08             0254*  
041F08             0255*  ; When used inside a buffered command sequence, this command will
041F08             0256*  ; only affect the output stream for that sequence of commands, and
041F08             0257*  ; any other buffered command sequences that are called from within
041F08             0258*  ; that sequence. Once the buffered command sequence has completed,
041F08             0259*  ; the output stream will effectively be reset to its original value.
041F08             0260*  
041F08             0261*  ; It is strongly recommended to only use this command from within a
041F08             0262*  ; buffered command sequence. Whilst it is possible to use this
041F08             0263*  ; command from within a normal VDU command sequence, it is not
041F08             0264*  ; recommended as it may cause unexpected behaviour. If you do use
041F08             0265*  ; it in that context, it is very important to remember to restore
041F08             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
041F08             0267*  ; future, this command may be disabled from being used outside of
041F08             0268*  ; a buffered command sequence.)
041F08             0269*  
041F08             0270*  ; At present, writable buffers can only be written to until the end
041F08             0271*  ; of the buffer has been reached; once that happens no more data
041F08             0272*  ; will be written to the buffer. It is not currently possible to
041F08             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
041F08             0274*  ; that the buffer is large enough to capture all of the data that
041F08             0275*  ; is expected to be written to it. The only current way to “rewind”
041F08             0276*  ; an output stream would be to clear the buffer and create a new
041F08             0277*  ; one, and then call set output stream again with the newly created
041F08             0278*  ; buffer.
041F08             0279*  
041F08             0280*  ; Command 5: Adjust buffer contents
041F08             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041F08             0282*  
041F08             0283*  ; This command will adjust the contents of a buffer, at a given
041F08             0284*  ; offset. The exact nature of the adjustment will depend on the
041F08             0285*  ; operation used.
041F08             0286*  
041F08             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
041F08             0288*  ; the contents of the current buffer. This will only work if this
041F08             0289*  ; command is used within a buffered command sequence, otherwise the
041F08             0290*  ; command will not do anything.
041F08             0291*  
041F08             0292*  ; The basic set of adjustment operations are as follows:
041F08             0293*  ; Operation 	Description
041F08             0294*  ; 0 	NOT
041F08             0295*  ; 1 	Negate
041F08             0296*  ; 2 	Set value
041F08             0297*  ; 3 	Add
041F08             0298*  ; 4 	Add with carry
041F08             0299*  ; 5 	AND
041F08             0300*  ; 6 	OR
041F08             0301*  ; 7 	XOR
041F08             0302*  
041F08             0303*  ; All of these operations will modify a byte found at the given
041F08             0304*  ; offset in the buffer. The only exception to that is the “Add with
041F08             0305*  ; carry” operation, which will also store the “carry” value in the
041F08             0306*  ; byte at the next offset. With the exception of NOT and Negate,
041F08             0307*  ; each command requires an operand value to be specified.
041F08             0308*  
041F08             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
041F08             0310*  ; need to use the NOT operation, and so the following command would
041F08             0311*  ; be used:
041F08             0312*  
041F08             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
041F08             0314*  
041F08             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
041F08             0316*  ; to use the Add operation, and so the following command would be
041F08             0317*  ; used:
041F08             0318*  
041F08             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
041F08             0320*  
041F08             0321*  ; When using add with carry, the carry value is stored in the byte
041F08             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
041F08             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
041F08             0324*  ; you would need to use the Add with carry operation, and so the
041F08             0325*  ; following command would be used:
041F08             0326*  
041F08             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
041F08             0328*  
041F08             0329*  ; Advanced operations
041F08             0330*  
041F08             0331*  ; Whilst these operations are useful, they are not particularly
041F08             0332*  ; powerful as they only operate one one byte at a time, with a
041F08             0333*  ; fixed operand value, and potentially cannot reach all bytes in
041F08             0334*  ; a buffer. To address this, the API supports a number of advanced
041F08             0335*  ; operations.
041F08             0336*  
041F08             0337*  ; The operation value used is an 8-bit value that can have bits
041F08             0338*  ; set to modify the behaviour of the operation. The following bits
041F08             0339*  ; are defined:
041F08             0340*  ; Bit 	Description
041F08             0341*  ; &10 	Use “advanced” offsets
041F08             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041F08             0343*  ; &40 	Multiple target values should be adjusted
041F08             0344*  ; &80 	Multiple operand values should be used
041F08             0345*  
041F08             0346*  ; These bits can be combined together to modify the behaviour of
041F08             0347*  ; the operation.
041F08             0348*  
041F08             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
041F08             0350*  ; offset one byte at a time. When either of the “multiple” variants
041F08             0351*  ; are used, a 16-bit count must be provided to indicate how many
041F08             0352*  ; bytes should be altered.
041F08             0353*  
041F08             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
041F08             0355*  ; order, which can allow for buffers that are larger than 64kb
041F08             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
041F08             0357*  ; the 16-bit value immediately following the offset is used as a
041F08             0358*  ; block index number, and the remaining 23-bits of the offset value
041F08             0359*  ; are used as an offset within that block. When the “advanced”
041F08             0360*  ; offset mode bit has been set then all offsets associated with
041F08             0361*  ; this command must be sent as advanced offsets.
041F08             0362*  
041F08             0363*  ; The “buffer-fetched value” mode allows for the operand value to
041F08             0364*  ; be fetched from a buffer. The operand sent as part of the
041F08             0365*  ; command in this case is a pair of 16-bit values giving the
041F08             0366*  ; buffer ID and offset to indicate where the actual operand value
041F08             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
041F08             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
041F08             0369*  ; used inside a buffered command sequence. If the advanced offset
041F08             0370*  ; mode is used, then the operand value is an advanced offset value.
041F08             0371*  
041F08             0372*  ; The “multiple target values” mode allows for multiple bytes to
041F08             0373*  ; be adjusted at once. When this mode is used, the count value
041F08             0374*  ; must be provided to indicate how many bytes should be adjusted.
041F08             0375*  ; Unless the “multiple operand values” mode is also used, the
041F08             0376*  ; operand value is used for all bytes adjusted.
041F08             0377*  
041F08             0378*  ; The “multiple operand values” mode allows for multiple operand
041F08             0379*  ; values to be used. When this mode is used, the count value must
041F08             0380*  ; be provided to indicate how many operand values should be used.
041F08             0381*  ; This can allow, for instance, to add together several bytes in a
041F08             0382*  ; buffer. When this mode is used in conjunction with the “multiple
041F08             0383*  ; target values” mode, the number of operand values must match the
041F08             0384*  ; number of target values, and the operation happens one byte at a
041F08             0385*  ; time.
041F08             0386*  
041F08             0387*  ; Some examples of advanced operations are as follows:
041F08             0388*  
041F08             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
041F08             0390*  
041F08             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
041F08             0392*  
041F08             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
041F08             0394*  ; modifier (&40).
041F08             0395*  
041F08             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
041F08             0397*  
041F08             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
041F08             0399*  
041F08             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
041F08             0401*  
041F08             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
041F08             0403*  
041F08             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
041F08             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
041F08             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
041F08             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
041F08             0408*  ; in little-endian order. As the top bit of the offset is set, this
041F08             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
041F08             0410*  ; Finally the value to write is sent, 42.
041F08             0411*  
041F08             0412*  ; An operation like this could be used to set the position as part
041F08             0413*  ; of a draw command.
041F08             0414*  
041F08             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
041F08             0416*  ; values 1, 2, 3, 4, 5:
041F08             0417*  
041F08             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
041F08             0419*  ; offset 12 (set it to 0)
041F08             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
041F08             0421*  
041F08             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
041F08             0423*  ; 7 bytes in buffer 4 starting at offset 42:
041F08             0424*  
041F08             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
041F08             0426*  
041F08             0427*  ; As we are working on a little-endian system, integers longer
041F08             0428*  ; than one byte are sent with their least significant byte first.
041F08             0429*  ; This means that the add with carry operation can be used to add
041F08             0430*  ; together integers of any size, so long as they are the same size.
041F08             0431*  ; To do this, both the “multiple target values” and “multiple
041F08             0432*  ; operand values” modes must be used.
041F08             0433*  
041F08             0434*  ; The following commands will add together a 16-bit, 24-bit,
041F08             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
041F08             0436*  ; in buffer 3 starting at offset 12, and all using the operand
041F08             0437*  ; value of 42:
041F08             0438*  
041F08             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
041F08             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
041F08             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
041F08             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
041F08             0443*  
041F08             0444*  ; Take note of how the operand value is padded out with zeros
041F08             0445*  ; to match the size of the target value. 42; is used as a base
041F08             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
041F08             0447*  ; 16-bits to pad it out to the required size. The “carry” value
041F08             0448*  ; will be stored at the next offset in the target buffer after
041F08             0449*  ; the complete target value. So for a 16-bit value, the carry
041F08             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
041F08             0451*  ; at offset 15, and so on.
041F08             0452*  
041F08             0453*  ; Command 6: Conditionally call a buffer
041F08             0454*  
041F08             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041F08             0456*  
041F08             0457*  ; This command will conditionally call a buffer if the condition
041F08             0458*  ; operation passes. This command works in a similar manner to the
041F08             0459*  ; “Adjust buffer contents” command.
041F08             0460*  
041F08             0461*  ; With this command a buffer ID of 65535 (-1) is always
041F08             0462*  ; interpretted as “current buffer”, and so can only be used
041F08             0463*  ; within a buffered command sequence. If used outside of a
041F08             0464*  ; buffered command sequence then this command will do nothing.
041F08             0465*  
041F08             0466*  ; The basic set of condition operations are as follows:
041F08             0467*  ; Operation 	Description
041F08             0468*  ; 0 	Exists (value is non-zero)
041F08             0469*  ; 1 	Not exists (value is zero)
041F08             0470*  ; 2 	Equal
041F08             0471*  ; 3 	Not equal
041F08             0472*  ; 4 	Less than
041F08             0473*  ; 5 	Greater than
041F08             0474*  ; 6 	Less than or equal
041F08             0475*  ; 7 	Greater than or equal
041F08             0476*  ; 8 	AND
041F08             0477*  ; 9 	OR
041F08             0478*  
041F08             0479*  ; The value that is being checked is fetched from the specified
041F08             0480*  ; check buffer ID and offset. With the exception of “Exists” and
041F08             0481*  ; “Not exists”, each command requires an operand value to be
041F08             0482*  ; specified to check against.
041F08             0483*  
041F08             0484*  ; The operation value used is an 8-bit value that can have bits
041F08             0485*  ; set to modify the behaviour of the operation. The following bits
041F08             0486*  ; are defined:
041F08             0487*  ; Bit value 	Description
041F08             0488*  ; &10 	Use advanced offsets
041F08             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041F08             0490*  
041F08             0491*  ; These modifiers can be combined together to modify the behaviour
041F08             0492*  ; of the operation.
041F08             0493*  
041F08             0494*  ; At this time, unlike with the “adjust” command, multiple target
041F08             0495*  ; values and multiple operand values are not supported. All
041F08             0496*  ; comparisons are therefore only conducted on single 8-bit values.
041F08             0497*  ; (If comparisons of 16-bit values are required, multiple calls
041F08             0498*  ; can be combined.) Support for them may be added in the future.
041F08             0499*  
041F08             0500*  ; The AND and OR operations are logical operations, and so the
041F08             0501*  ; operand value is used as a boolean value. Any non-zero value is
041F08             0502*  ; considered to be true, and zero is considered to be false. These
041F08             0503*  ; operations therefore are most useful when used with buffer-fetched
041F08             0504*  ; operand values (operations &28, &29, &38 and &39).
041F08             0505*  
041F08             0506*  ; Some examples of condition operations are as follows:
041F08             0507*  
041F08             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
041F08             0509*  ; (is non-zero):
041F08             0510*  
041F08             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041F08             0512*  
041F08             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
041F08             0514*  ; exist (is zero):
041F08             0515*  
041F08             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041F08             0517*  
041F08             0518*  ; Combining the above two examples is effectively equivalent to
041F08             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
041F08             0520*  
041F08             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041F08             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041F08             0523*  
041F08             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
041F08             0525*  
041F08             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
041F08             0527*  
041F08             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
041F08             0529*  ; the value in buffer 2 at offset 8:
041F08             0530*  
041F08             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
041F08             0532*  
041F08             0533*  ; Command 7: Jump to a buffer
041F08             0534*  
041F08             0535*  ; VDU 23, 0, &A0, bufferId; 7
041F08             0536*  
041F08             0537*  ; This command will jump to the buffer with the given ID. If
041F08             0538*  ; the buffer does not exist, or is empty, then this command will
041F08             0539*  ; do nothing.
041F08             0540*  
041F08             0541*  ; This essentially works the same as the call command (command 1),
041F08             0542*  ;  except that it does not return to the caller. This command is
041F08             0543*  ;  therefore useful for creating loops.
041F08             0544*  
041F08             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
041F08             0546*  ; treated as a “jump to end of current buffer”. This will return
041F08             0547*  ; execution to the caller, and can be useful for exiting a loop.
041F08             0548*  
041F08             0549*  ; ## Command 8: Conditional Jump to a buffer
041F08             0550*  
041F08             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041F08             0552*  
041F08             0553*  ; This command operates in a similar manner to the “Conditionally
041F08             0554*  ; call a buffer” command (command 6), except that it will jump to
041F08             0555*  ; the buffer if the condition operation passes.
041F08             0556*  
041F08             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
041F08             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
041F08             0559*  ; Command 9: Jump to an offset in a buffer
041F08             0560*  
041F08             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041F08             0562*  
041F08             0563*  ; This command will jump to the given offset in the buffer with the
041F08             0564*  ; given ID. If the buffer does not exist, or is empty, then this
041F08             0565*  ; command will do nothing.
041F08             0566*  
041F08             0567*  ; The offset in this command is always an “advanced” offset, given
041F08             0568*  ; as a 24-bit value in little-endian order. As with other uses of
041F08             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
041F08             0570*  ; offset value, a block number must also be provided.
041F08             0571*  
041F08             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
041F08             0573*  ; meaning “jump within current buffer”. This can be useful for
041F08             0574*  ; creating loops within a buffer, or when building up command
041F08             0575*  ; sequences that may be copied across multiple buffers.
041F08             0576*  
041F08             0577*  ; Jumping to an offset that is beyond the end of the buffer is
041F08             0578*  ; equivalent to jumping to the end of the buffer.
041F08             0579*  ; Command 10: Conditional jump to an offset in a buffer
041F08             0580*  
041F08             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041F08             0582*  
041F08             0583*  ; A conditional jump with an offset works in a similar manner to
041F08             0584*  ; the “Conditional call a buffer” command (command 6), except that
041F08             0585*  ; it will jump to the given offset in the buffer if the condition
041F08             0586*  ; operation passes.
041F08             0587*  
041F08             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
041F08             0589*  ; the offset in this command is always an “advanced” offset, given
041F08             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
041F08             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
041F08             0592*  ; treated as meaning “jump within current buffer”.
041F08             0593*  ; Command 11: Call buffer with an offset
041F08             0594*  
041F08             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041F08             0596*  
041F08             0597*  ; Works just like “Call a buffer” (command 1), except that it also
041F08             0598*  ; accepts an advanced offset.
041F08             0599*  
041F08             0600*  ; Command 12: Conditional call buffer with an offset
041F08             0601*  
041F08             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
041F08             0603*  
041F08             0604*  ; Works just like the “Conditional call a buffer” command
041F08             0605*  ; (command 6), except that it also accepts an advanced offset.
041F08             0606*  
041F08             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
041F08             0608*  
041F08             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
041F08             0610*  
041F08             0611*  ; This command will copy the contents of multiple buffers into a
041F08             0612*  ; single buffer. The buffers to copy from are specified as a list
041F08             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
041F08             0614*  ; buffers are copied in the order they are specified.
041F08             0615*  
041F08             0616*  ; This is a block-wise copy, so the blocks from the source buffers
041F08             0617*  ; are copied into the target buffer. The blocks are copied in the
041F08             0618*  ; order they are found in the source buffers.
041F08             0619*  
041F08             0620*  ; The target buffer will be overwritten with the contents of the
041F08             0621*  ; source buffers. This will not be done however until after all the
041F08             0622*  ; data has been gathered and copied. The target buffer can therefore
041F08             0623*  ; included in the list of the source buffers.
041F08             0624*  
041F08             0625*  ; If a source buffer that does not exist is specified, or a source
041F08             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
041F08             0627*  
041F08             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
041F08             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
041F08             0630*  ; copied multiple times into the target buffer.
041F08             0631*  
041F08             0632*  ; If there is insufficient memory available on the VDP to complete
041F08             0633*  ; this command then it will fail, and the target buffer will be
041F08             0634*  ; left unchanged.
041F08             0635*  
041F08             0636*  
041F08             0637*  ; Command 14: Consolidate blocks in a buffer
041F08             0638*  
041F08             0639*  ; VDU 23, 0, &A0, bufferId; 14
041F08             0640*  
041F08             0641*  ; Takes all the blocks in a buffer and consolidates them into a
041F08             0642*  ; single block. This is useful for bitmaps, as it allows for a
041F08             0643*  ; bitmap to be built up over time in multiple blocks, and then
041F08             0644*  ; consolidated into a single block for use as a bitmap.
041F08             0645*  
041F08             0646*  ; If there is insufficient memory available on the VDP to complete
041F08             0647*  ; this command then it will fail, and the buffer will be left
041F08             0648*  ; unchanged.
041F08             0649*  
041F08             0650*  ; Command 15: Split a buffer into multiple blocks
041F08             0651*  
041F08             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
041F08             0653*  
041F08             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
041F08             0655*  ; is a 16-bit integer that specifies the target size of each block.
041F08             0656*  ; If the source data is not a multiple of the block size then the
041F08             0657*  ; last block will be smaller than the specified block size.
041F08             0658*  
041F08             0659*  ; If this command is used on a buffer that is already split into
041F08             0660*  ; multiple blocks, then the blocks will be consolidated first,
041F08             0661*  ; and then re-split into the new block size.
041F08             0662*  
041F08             0663*  ; If there is insufficient memory available on the VDP to complete
041F08             0664*  ; this command then it will fail, and the buffer will be left
041F08             0665*  ; unchanged.
041F08             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
041F08             0667*  ; multiple buffers
041F08             0668*  
041F08             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0670*  
041F08             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
041F08             0672*  ; then spreads the resultant blocks across the target buffers.
041F08             0673*  ; The target buffers are specified as a list of buffer IDs,
041F08             0674*  ; terminated by a buffer ID of -1 (65535).
041F08             0675*  
041F08             0676*  ; The blocks are spread across the target buffers in the order
041F08             0677*  ; they are specified, and the spread will loop around the buffers
041F08             0678*  ; until all the blocks have been distributed. The target buffers
041F08             0679*  ; will be cleared out before the blocks are spread across them.
041F08             0680*  
041F08             0681*  ; What this means is that if the source buffer is, let’s say,
041F08             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
041F08             0683*  ; then we will end up with 10 blocks. If we then spread those
041F08             0684*  ; blocks across 3 target buffers, then the first buffer will
041F08             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
041F08             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
041F08             0687*  ; blocks 3, 6 and 9.
041F08             0688*  
041F08             0689*  ; This command attempts to ensure that, in the event of
041F08             0690*  ; insufficient memory being available on the VDP to complete
041F08             0691*  ; the command, it will leave the targets as they were before
041F08             0692*  ; the command was executed. However this may not always be
041F08             0693*  ; possible. The first step of this command is to consolidate
041F08             0694*  ; the source buffer into a single block, and this may fail from
041F08             0695*  ; insufficient memory. If that happens then all the buffers will
041F08             0696*  ; be left as they were. After this however the target buffers
041F08             0697*  ; will be cleared. If there is insufficient memory to successfully
041F08             0698*  ; split the buffer into multiple blocks then the call will exit,
041F08             0699*  ; and the target buffers will be left empty.
041F08             0700*  ; Command 17: Split a buffer and spread across blocks, starting
041F08             0701*  ; at target buffer ID
041F08             0702*  
041F08             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
041F08             0704*  
041F08             0705*  ; As per the above two commands, this will split a buffer into
041F08             0706*  ; multiple blocks. It will then spread the blocks across buffers
041F08             0707*  ; starting at the target buffer ID, incrementing the target buffer
041F08             0708*  ; ID until all the blocks have been distributed.
041F08             0709*  
041F08             0710*  ; Target blocks will be cleared before a block is stored in them.
041F08             0711*  ; Each target will contain a single block. The exception to this
041F08             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
041F08             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
041F08             0714*  ; will be placed into buffer 65534.
041F08             0715*  
041F08             0716*  ; With this command if there is insufficient memory available on
041F08             0717*  ; the VDP to complete the command then it will fail, and the target
041F08             0718*  ; buffers will be left unchanged.
041F08             0719*  
041F08             0720*  ; Command 18: Split a buffer into blocks by width
041F08             0721*  
041F08             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
041F08             0723*  
041F08             0724*  ; This command splits a buffer into a given number of blocks by
041F08             0725*  ; first of all splitting the buffer into blocks of a given width
041F08             0726*  ; (number of bytes), and then consolidating those blocks into the
041F08             0727*  ; given number of blocks.
041F08             0728*  
041F08             0729*  ; This is useful for splitting a bitmap into a number of separate
041F08             0730*  ; columns, which can then be manipulated individually. This can be
041F08             0731*  ; useful for dealing with sprite sheets.
041F08             0732*  ; Command 19: Split by width into blocks and spread across target
041F08             0733*  ; buffers
041F08             0734*  
041F08             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0736*  
041F08             0737*  ; This command essentially operates the same as command 18, but the
041F08             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
041F08             0739*  
041F08             0740*  ; Command 20: Split by width into blocks and spread across blocks
041F08             0741*  ; starting at target buffer ID
041F08             0742*  
041F08             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
041F08             0744*  
041F08             0745*  ; This command essentially operates the same as command 18, but
041F08             0746*  ; the generated blocks are spread across blocks starting at the
041F08             0747*  ; target buffer ID, as per command 17.
041F08             0748*  
041F08             0749*  ; Command 21: Spread blocks from a buffer across multiple target
041F08             0750*  ; buffers
041F08             0751*  
041F08             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0753*  
041F08             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
041F08             0755*  ; The target buffers are specified as a list of buffer IDs,
041F08             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
041F08             0757*  ; across the target buffers in the order they are specified, and
041F08             0758*  ; the spread will loop around the buffers until all the blocks have
041F08             0759*  ; been distributed.
041F08             0760*  
041F08             0761*  ; It should be noted that this command does not copy the blocks,
041F08             0762*  ; and nor does it move them. Unless the source buffer has been
041F08             0763*  ; included in the list of targets, it will remain completely
041F08             0764*  ; intact. The blocks distributed across the target buffers will
041F08             0765*  ; point to the same memory as the blocks in the source buffer.
041F08             0766*  ; Operations to modify data in the source buffer will also modify
041F08             0767*  ; the data in the target buffers. Clearing the source buffer
041F08             0768*  ; however will not clear the target buffers.
041F08             0769*  
041F08             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
041F08             0771*  ; at target buffer ID
041F08             0772*  
041F08             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
041F08             0774*  
041F08             0775*  ; Spreads the blocks from a buffer across blocks starting at
041F08             0776*  ; the target buffer ID.
041F08             0777*  
041F08             0778*  ; This essentially works the same as command 21, and the same
041F08             0779*  ; notes about copying and moving blocks apply. Blocks are spread
041F08             0780*  ; in the same manner as commands 17 and 20.
041F08             0781*  
041F08             0782*  ; Command 23: Reverse the order of blocks in a buffer
041F08             0783*  
041F08             0784*  ; VDU 23, 0, &A0, bufferId; 23
041F08             0785*  
041F08             0786*  ; Reverses the order of the blocks in a buffer.
041F08             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
041F08             0788*  
041F08             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041F08             0790*  
041F08             0791*  ; Reverses the order of the data within the blocks of a buffer.
041F08             0792*  ; The options parameter is an 8-bit value that can have bits set
041F08             0793*  ; to modify the behaviour of the operation. The following bits
041F08             0794*  ; are defined:
041F08             0795*  ; Bit value 	Description
041F08             0796*  ; 1 	Values are 16-bits in size
041F08             0797*  ; 2 	Values are 32-bits in size
041F08             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
041F08             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
041F08             0800*  ; 8 	Reverse blocks
041F08             0801*  
041F08             0802*  ; These modifiers can be combined together to modify the behaviour
041F08             0803*  ; of the operation.
041F08             0804*  
041F08             0805*  ; If no value size is set in the options (i.e. the value of the
041F08             0806*  ; bottom two bits of the options is zero) then the value size is
041F08             0807*  ; assumed to be 8-bits.
041F08             0808*  
041F08             0809*  ; It is probably easiest to understand what this operation is
041F08             0810*  ; capable of by going through some examples of how it can be used
041F08             0811*  ; to manipulate bitmaps. The VDP supports two different formats
041F08             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
041F08             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
041F08             0814*  ; pixel.
041F08             0815*  
041F08             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
041F08             0817*  ; degrees, which can be done by just reversing the order of
041F08             0818*  ; bytes in the buffer:
041F08             0819*  
041F08             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
041F08             0821*  
041F08             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
041F08             0823*  ; little more complex, as each pixel is made up of 4 bytes.
041F08             0824*  ; However with this command it is still a simple operation, as
041F08             0825*  ; we can just reverse the order of the 32-bit values that make
041F08             0826*  ; up the bitmap by using an options value of 2:
041F08             0827*  
041F08             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
041F08             0829*  
041F08             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
041F08             0831*  ; the order of rows of pixels. To do this we can set a custom
041F08             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
041F08             0833*  ; bitmap we can just set a custom value size to our bitmap width:
041F08             0834*  
041F08             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
041F08             0836*  
041F08             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
041F08             0838*  ; our width by 4:
041F08             0839*  
041F08             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
041F08             0841*  
041F08             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
041F08             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
041F08             0844*  ; just set a custom chunk size to our bitmap width:
041F08             0845*  
041F08             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
041F08             0847*  
041F08             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
041F08             0849*  ; 32-bit values as well as a custom chunk size:
041F08             0850*  
041F08             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
041F08             0852*  
041F08             0853*  ; Command 25: Copy blocks from multiple buffers by reference
041F08             0854*  
041F08             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
041F08             0856*  
041F08             0857*  ; This command is essentially a version of command 13 that copies
041F08             0858*  ; blocks by reference rather than by value. The parameters for
041F08             0859*  ; this command are the same as for command 13, and the same rules
041F08             0860*  ; apply.
041F08             0861*  
041F08             0862*  ; If the target buffer is included in the list of source buffers
041F08             0863*  ; then it will be skipped to prevent a reference loop.
041F08             0864*  
041F08             0865*  ; Copying by reference means that the blocks in the target buffer
041F08             0866*  ; will point to the same memory as the blocks in the source
041F08             0867*  ; buffers. Operations to modify data blocks in the source buffers
041F08             0868*  ; will therefore also modify those blocks in the target buffer.
041F08             0869*  ; Clearing the source buffers will not clear the target buffer -
041F08             0870*  ; it will still point to the original data blocks. Data blocks
041F08             0871*  ; are only freed from memory when no buffers are left with any
041F08             0872*  ; references to them.
041F08             0873*  
041F08             0874*  ; Buffers that get consolidated become new blocks, so will lose
041F08             0875*  ; their links to the original blocks, thus after a “consolidate”
041F08             0876*  ; operation modifications to the original blocks will no longer be
041F08             0877*  ; reflected in the consolidated buffer.
041F08             0878*  
041F08             0879*  ; This command is useful to construct a single buffer from multiple
041F08             0880*  ; sources without the copy overhead, which can be costly. For
041F08             0881*  ; example, this can be useful for constructing a bitmap from
041F08             0882*  ; multiple constituent parts before consolidating it into a
041F08             0883*  ; single block. In such an example, using command 13 instead
041F08             0884*  ; would first make a copy of the contents of the source buffers,
041F08             0885*  ; and then consolidate them into a single block. Using this
041F08             0886*  ; command does not make that first copy, and so would be faster.
041F08             0887*  
041F08             0888*  ; This command is also useful for creating multiple buffers that
041F08             0889*  ; all point to the same data.
041F08             0890*  
041F08             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
041F08             0892*  
041F08             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
041F08             0055       include "vdu_plot.inc"
041F08             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F08             0002*  ; PLOT code 	(Decimal) 	Effect
041F08             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
041F08             0004*  plot_sl_both: equ 0x00
041F08             0005*  
041F08             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
041F08             0007*  plot_sl_first: equ 0x08
041F08             0008*  
041F08             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041F08             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041F08             0011*  
041F08             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
041F08             0013*  plot_sl_last: equ 0x20
041F08             0014*  
041F08             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
041F08             0016*  plot_sl_none: equ 0x28
041F08             0017*  
041F08             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041F08             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041F08             0020*  
041F08             0021*  ; &40-&47 	64-71 	Point plot
041F08             0022*  plot_pt: equ 0x40
041F08             0023*  
041F08             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041F08             0025*  plot_lf_lr_non_bg: equ 0x48
041F08             0026*  
041F08             0027*  ; &50-&57 	80-87 	Triangle fill
041F08             0028*  plot_tf: equ 0x50
041F08             0029*  
041F08             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
041F08             0031*  plot_lf_r_bg: equ 0x58
041F08             0032*  
041F08             0033*  ; &60-&67 	96-103 	Rectangle fill
041F08             0034*  plot_rf: equ 0x60
041F08             0035*  
041F08             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041F08             0037*  plot_lf_lr_fg: equ 0x60
041F08             0038*  
041F08             0039*  ; &70-&77 	112-119 	Parallelogram fill
041F08             0040*  plot_pf: equ 0x70
041F08             0041*  
041F08             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041F08             0043*  plot_lf_r_non_fg: equ 0x78
041F08             0044*  
041F08             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
041F08             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041F08             0047*  
041F08             0048*  ; &90-&97 	144-151 	Circle outline
041F08             0049*  plot_co: equ 0x90
041F08             0050*  
041F08             0051*  ; &98-&9F 	152-159 	Circle fill
041F08             0052*  plot_cf: equ 0x98
041F08             0053*  
041F08             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
041F08             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
041F08             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
041F08             0057*  
041F08             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
041F08             0059*  plot_rcm: equ 0xB8
041F08             0060*  
041F08             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041F08             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041F08             0063*  ; &D0-&D7 	208-215 	Not defined
041F08             0064*  ; &D8-&DF 	216-223 	Not defined
041F08             0065*  ; &E0-&E7 	224-231 	Not defined
041F08             0066*  
041F08             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
041F08             0068*  plot_bmp: equ 0xE8
041F08             0069*  
041F08             0070*  ; &F0-&F7 	240-247 	Not defined
041F08             0071*  ; &F8-&FF 	248-255 	Not defined
041F08             0072*  
041F08             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041F08             0074*  ; Agon Console8 VDP 2.2.0
041F08             0075*  
041F08             0076*  ; Within each group of eight plot codes, the effects are as follows:
041F08             0077*  ; Plot code 	Effect
041F08             0078*  ; 0 	Move relative
041F08             0079*  mv_rel: equ 0
041F08             0080*  
041F08             0081*  ; 1 	Plot relative in current foreground colour
041F08             0082*  dr_rel_fg: equ 1
041F08             0083*  
041F08             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
041F08             0085*  ; 3 	Plot relative in current background colour
041F08             0086*  dr_rel_bg: equ 3
041F08             0087*  
041F08             0088*  ; 4 	Move absolute
041F08             0089*  mv_abs: equ 4
041F08             0090*  
041F08             0091*  ; 5 	Plot absolute in current foreground colour
041F08             0092*  dr_abs_fg: equ 5
041F08             0093*  
041F08             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
041F08             0095*  ; 7 	Plot absolute in current background colour
041F08             0096*  dr_abs_bg: equ 7
041F08             0097*  
041F08             0098*  ; Codes 0-3 use the position data provided as part of the command
041F08             0099*  ; as a relative position, adding the position given to the current
041F08             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
041F08             0101*  ; as part of the command as an absolute position, setting the current
041F08             0102*  ; graphical cursor position to the position given.
041F08             0103*  
041F08             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041F08             0105*  ; current pixel colour. These operations cannot currently be supported
041F08             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
041F08             0107*  ; supported. Support for these codes may be added in a future version
041F08             0108*  ; of the VDP firmware.
041F08             0109*  
041F08             0110*  ; 16 colour palette constants
041F08             0111*  c_black: equ 0
041F08             0112*  c_red_dk: equ 1
041F08             0113*  c_green_dk: equ 2
041F08             0114*  c_yellow_dk: equ 3
041F08             0115*  c_blue_dk: equ 4
041F08             0116*  c_magenta_dk: equ 5
041F08             0117*  c_cyan_dk: equ 6
041F08             0118*  c_grey: equ 7
041F08             0119*  c_grey_dk: equ 8
041F08             0120*  c_red: equ 9
041F08             0121*  c_green: equ 10
041F08             0122*  c_yellow: equ 11
041F08             0123*  c_blue: equ 12
041F08             0124*  c_magenta: equ 13
041F08             0125*  c_cyan: equ 14
041F08             0126*  c_white: equ 15
041F08             0127*  
041F08             0128*  ; VDU 25, mode, x; y;: PLOT command
041F08             0129*  ; inputs: a=mode, bc=x0, de=y0
041F08             0130*  vdu_plot:
041F08 32 22 1F 04 0131*      ld (@mode),a
041F0C ED 43 23 1F 0132*      ld (@x0),bc
       04          
041F11 ED 53 25 1F 0133*      ld (@y0),de
       04          
041F16 21 21 1F 04 0134*  	ld hl,@cmd
041F1A 01 06 00 00 0135*  	ld bc,@end-@cmd
041F1E 5B DF       0136*  	rst.lil $18
041F20 C9          0137*  	ret
041F21 19          0138*  @cmd:   db 25
041F22 00          0139*  @mode:  db 0
041F23 00 00       0140*  @x0: 	dw 0
041F25 00 00       0141*  @y0: 	dw 0
041F27 00          0142*  @end:   db 0 ; extra byte to soak up deu
041F28             0143*  
041F28             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F28             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
041F28             0146*  ; VDU 25, mode, x; y;: PLOT command
041F28             0147*  ; inputs: bc=x0, de=y0
041F28             0148*  ; prerequisites: vdu_buff_select
041F28             0149*  vdu_plot_bmp:
041F28 ED 43 3F 1F 0150*      ld (@x0),bc
       04          
041F2D ED 53 41 1F 0151*      ld (@y0),de
       04          
041F32 21 3D 1F 04 0152*  	ld hl,@cmd
041F36 01 06 00 00 0153*  	ld bc,@end-@cmd
041F3A 5B DF       0154*  	rst.lil $18
041F3C C9          0155*  	ret
041F3D 19          0156*  @cmd:   db 25
041F3E ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041F3F 00 00       0158*  @x0: 	dw 0x0000
041F41 00 00       0159*  @y0: 	dw 0x0000
041F43 00          0160*  @end:   db 0x00 ; padding
041F44             0161*  
041F44             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F44             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
041F44             0164*  ; VDU 25, mode, x; y;: PLOT command
041F44             0165*  ; inputs: bc=x0, de=y0
041F44             0166*  ; USING 16.8 FIXED POINT COORDINATES
041F44             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041F44             0168*  ;   the fractional portiion of the inputs are truncated
041F44             0169*  ;   leaving only the 16-bit integer portion
041F44             0170*  ; prerequisites: vdu_buff_select
041F44             0171*  vdu_plot_bmp168:
041F44             0172*  ; populate in the reverse of normal to keep the
041F44             0173*  ; inputs from stomping on each other
041F44 ED 53 62 1F 0174*      ld (@y0-1),de
       04          
041F49 ED 43 60 1F 0175*      ld (@x0-1),bc
       04          
041F4E 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041F50 32 60 1F 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041F54 21 5F 1F 04 0178*  	ld hl,@cmd
041F58 01 06 00 00 0179*  	ld bc,@end-@cmd
041F5C 5B DF       0180*  	rst.lil $18
041F5E C9          0181*  	ret
041F5F 19          0182*  @cmd:   db 25
041F60 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041F61 00 00       0184*  @x0: 	dw 0x0000
041F63 00 00       0185*  @y0: 	dw 0x0000
041F65             0186*  @end:  ; no padding required b/c we shifted de right
041F65             0187*  
041F65             0188*  ; draw a filled rectangle
041F65             0189*  vdu_plot_rf:
041F65 ED 43 8C 1F 0190*      ld (@x0),bc
       04          
041F6A ED 53 8E 1F 0191*      ld (@y0),de
       04          
041F6F DD 22 92 1F 0192*      ld (@x1),ix
       04          
041F74 FD 22 94 1F 0193*      ld (@y1),iy
       04          
041F79 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041F7B 32 90 1F 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F7F 21 8A 1F 04 0196*  	ld hl,@cmd0
041F83 01 0C 00 00 0197*  	ld bc,@end-@cmd0
041F87 5B DF       0198*  	rst.lil $18
041F89 C9          0199*      ret
041F8A 19          0200*  @cmd0:  db 25 ; plot
041F8B 04          0201*  @arg0:  db plot_sl_both+mv_abs
041F8C 00 00       0202*  @x0:    dw 0x0000
041F8E 00 00       0203*  @y0:    dw 0x0000
041F90 19          0204*  @cmd1:  db 25 ; plot
041F91 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041F92 00 00       0206*  @x1:    dw 0x0000
041F94 00 00       0207*  @y1:    dw 0x0000
041F96 00          0208*  @end:   db 0x00 ; padding
041F97             0209*  
041F97             0210*  ; draw a filled circle
041F97             0211*  vdu_plot_cf:
041F97 ED 43 BE 1F 0212*      ld (@x0),bc
       04          
041F9C ED 53 C0 1F 0213*      ld (@y0),de
       04          
041FA1 DD 22 C4 1F 0214*      ld (@x1),ix
       04          
041FA6 FD 22 C6 1F 0215*      ld (@y1),iy
       04          
041FAB 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041FAD 32 C2 1F 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041FB1 21 BC 1F 04 0218*  	ld hl,@cmd0
041FB5 01 0C 00 00 0219*  	ld bc,@end-@cmd0
041FB9 5B DF       0220*  	rst.lil $18
041FBB C9          0221*      ret
041FBC 19          0222*  @cmd0:  db 25 ; plot
041FBD 04          0223*  @arg0:  db plot_sl_both+mv_abs
041FBE 00 00       0224*  @x0:    dw 0x0000
041FC0 00 00       0225*  @y0:    dw 0x0000
041FC2 19          0226*  @cmd1:  db 25 ; plot
041FC3 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
041FC4 00 00       0228*  @x1:    dw 0x0000
041FC6 00 00       0229*  @y1:    dw 0x0000
041FC8 00          0230*  @end:   db 0x00 ; padding
041FC9             0056   	include "vdu_sprites.inc"
041FC9             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041FC9             0002*  ; the VDP can support up to 256 sprites. They must be defined
041FC9             0003*  ; contiguously, and so the first sprite is sprite 0.
041FC9             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041FC9             0005*  ; Once a selection of sprites have been defined, you can activate
041FC9             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
041FC9             0007*  ; of sprites to activate. This will activate the first n sprites,
041FC9             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041FC9             0009*  
041FC9             0010*  ; A single sprite can have multiple "frames", referring to
041FC9             0011*  ; different bitmaps.
041FC9             0012*  ; (These bitmaps do not need to be the same size.)
041FC9             0013*  ; This allows a sprite to include an animation sequence,
041FC9             0014*  ; which can be stepped through one frame at a time, or picked
041FC9             0015*  ; in any order.
041FC9             0016*  
041FC9             0017*  ; Any format of bitmap can be used as a sprite frame. It should
041FC9             0018*  ; be noted however that "native" format bitmaps are not
041FC9             0019*  ; recommended for use as sprite frames, as they cannot get
041FC9             0020*  ; erased from the screen. (As noted above, the "native" bitmap
041FC9             0021*  ; format is not really intended for general use.) This is part
041FC9             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041FC9             0023*  ; screen are now stored in RGBA2222 format.
041FC9             0024*  
041FC9             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
041FC9             0026*  ; and then later shown again.
041FC9             0027*  
041FC9             0028*  ; Moving sprites around the screen is done by changing the
041FC9             0029*  ; position of the sprite. This can be done either by setting
041FC9             0030*  ; the absolute position of the sprite, or by moving the sprite
041FC9             0031*  ; by a given number of pixels. (Sprites are positioned using
041FC9             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
041FC9             0033*  ; In the current sprite system, sprites will not update their
041FC9             0034*  ; position on-screen until either another drawing operation is
041FC9             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
041FC9             0036*  
041FC9             0037*  ; VDU 23, 27, 4, n: Select sprite n
041FC9             0038*  ; inputs: a is the 8-bit sprite id
041FC9             0039*  vdu_sprite_select:
041FC9 32 DB 1F 04 0040*      ld (@sprite),a
041FCD 21 D8 1F 04 0041*      ld hl,@cmd
041FD1 01 04 00 00 0042*      ld bc,@end-@cmd
041FD5 5B DF       0043*      rst.lil $18
041FD7 C9          0044*      ret
041FD8 17 1B 04    0045*  @cmd:    db 23,27,4
041FDB 00          0046*  @sprite: db 0x00
041FDC             0047*  @end:
041FDC             0048*  
041FDC             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
041FDC             0050*  ; inputs: none
041FDC             0051*  ; prerequisites: vdu_sprite_select
041FDC             0052*  vdu_sprite_clear_frames:
041FDC 21 E7 1F 04 0053*      ld hl,@cmd
041FE0 01 03 00 00 0054*      ld bc,@end-@cmd
041FE4 5B DF       0055*      rst.lil $18
041FE6 C9          0056*      ret
041FE7 17 1B 05    0057*  @cmd: db 23,27,5
041FEA             0058*  @end:
041FEA             0059*  
041FEA             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
041FEA             0061*  ; inputs: a is the 8-bit bitmap number
041FEA             0062*  ; prerequisites: vdu_sprite_select
041FEA             0063*  vdu_sprite_add_bmp:
041FEA 32 FC 1F 04 0064*      ld (@bmp),a
041FEE 21 F9 1F 04 0065*      ld hl,@cmd
041FF2 01 04 00 00 0066*      ld bc,@end-@cmd
041FF6 5B DF       0067*      rst.lil $18
041FF8 C9          0068*      ret
041FF9 17 1B 06    0069*  @cmd: db 23,27,6
041FFC 00          0070*  @bmp: db 0x00
041FFD             0071*  @end:
041FFD             0072*  
041FFD             0073*  ; VDU 23, 27, 7, n: Activate n sprites
041FFD             0074*  ; inputs: a is the number of sprites to activate
041FFD             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
041FFD             0076*  vdu_sprite_activate:
041FFD 32 0F 20 04 0077*      ld (@num),a
042001 21 0C 20 04 0078*      ld hl,@cmd
042005 01 04 00 00 0079*      ld bc,@end-@cmd
042009 5B DF       0080*      rst.lil $18
04200B C9          0081*      ret
04200C 17 1B 07    0082*  @cmd: db 23,27,7
04200F 00          0083*  @num: db 0x00
042010             0084*  @end:
042010             0085*  
042010             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
042010             0087*  ; inputs: none
042010             0088*  ; prerequisites: vdu_sprite_select
042010             0089*  vdu_sprite_next_frame:
042010 21 1B 20 04 0090*      ld hl,@cmd
042014 01 03 00 00 0091*      ld bc,@end-@cmd
042018 5B DF       0092*      rst.lil $18
04201A C9          0093*      ret
04201B 17 1B 08    0094*  @cmd: db 23,27,8
04201E             0095*  @end:
04201E             0096*  
04201E             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04201E             0098*  ; inputs: none
04201E             0099*  ; prerequisites: vdu_sprite_select
04201E             0100*  vdu_sprite_prev_frame:
04201E 21 29 20 04 0101*      ld hl,@cmd
042022 01 03 00 00 0102*      ld bc,@end-@cmd
042026 5B DF       0103*      rst.lil $18
042028 C9          0104*      ret
042029 17 1B 09    0105*  @cmd: db 23,27,9
04202C             0106*  @end:
04202C             0107*  
04202C             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
04202C             0109*  ; inputs: a is frame number to select
04202C             0110*  ; prerequisites: vdu_sprite_select
04202C             0111*  vdu_sprite_select_frame:
04202C 32 3E 20 04 0112*      ld (@frame),a
042030 21 3B 20 04 0113*      ld hl,@cmd
042034 01 04 00 00 0114*      ld bc,@end-@cmd
042038 5B DF       0115*      rst.lil $18
04203A C9          0116*      ret
04203B 17 1B 0A    0117*  @cmd:    db 23,27,10
04203E 00          0118*  @frame:  db 0x00
04203F             0119*  @end:
04203F             0120*  
04203F             0121*  ; VDU 23, 27, 11: Show current sprite
04203F             0122*  ; inputs: none
04203F             0123*  ; prerequisites: vdu_sprite_select
04203F             0124*  vdu_sprite_show:
04203F 21 4A 20 04 0125*      ld hl,@cmd
042043 01 03 00 00 0126*      ld bc,@end-@cmd
042047 5B DF       0127*      rst.lil $18
042049 C9          0128*      ret
04204A 17 1B 0B    0129*  @cmd: db 23,27,11
04204D             0130*  @end:
04204D             0131*  
04204D             0132*  ; VDU 23, 27, 12: Hide current sprite
04204D             0133*  ; inputs: none
04204D             0134*  ; prerequisites: vdu_sprite_select
04204D             0135*  vdu_sprite_hide:
04204D 21 58 20 04 0136*      ld hl,@cmd
042051 01 03 00 00 0137*      ld bc,@end-@cmd
042055 5B DF       0138*      rst.lil $18
042057 C9          0139*      ret
042058 17 1B 0C    0140*  @cmd: db 23,27,12
04205B             0141*  @end:
04205B             0142*  
04205B             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04205B             0144*  ; inputs: bc is x coordinate, de is y coordinate
04205B             0145*  ; prerequisites: vdu_sprite_select
04205B             0146*  vdu_sprite_move_abs:
04205B ED 43 73 20 0147*      ld (@xpos),bc
       04          
042060 ED 53 75 20 0148*      ld (@ypos),de
       04          
042065 21 70 20 04 0149*      ld hl,@cmd
042069 01 07 00 00 0150*      ld bc,@end-@cmd
04206D 5B DF       0151*      rst.lil $18
04206F C9          0152*      ret
042070 17 1B 0D    0153*  @cmd:  db 23,27,13
042073 00 00       0154*  @xpos: dw 0x0000
042075 00 00       0155*  @ypos: dw 0x0000
042077 00          0156*  @end:  db 0x00 ; padding
042078             0157*  
042078             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042078             0159*  ; inputs: bc is x coordinate, de is y coordinate
042078             0160*  ; prerequisites: vdu_sprite_select
042078             0161*  vdu_sprite_move_rel:
042078 ED 43 90 20 0162*      ld (@dx),bc
       04          
04207D ED 53 92 20 0163*      ld (@dy),de
       04          
042082 21 8D 20 04 0164*      ld hl,@cmd
042086 01 07 00 00 0165*      ld bc,@end-@cmd
04208A 5B DF       0166*      rst.lil $18
04208C C9          0167*      ret
04208D 17 1B 0E    0168*  @cmd: db 23,27,14
042090 00 00       0169*  @dx:  dw 0x0000
042092 00 00       0170*  @dy:  dw 0x0000
042094 00          0171*  @end: db 0x00 ; padding
042095             0172*  
042095             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042095             0174*  ; USING 16.8 FIXED POINT COORDINATES
042095             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042095             0176*  ;   the fractional portiion of the inputs are truncated
042095             0177*  ;   leaving only the 16-bit integer portion
042095             0178*  ; prerequisites: vdu_sprite_select
042095             0179*  vdu_sprite_move_abs168:
042095             0180*  ; populate in the reverse of normal to keep the
042095             0181*  ; inputs from stomping on each other
042095 ED 53 B4 20 0182*      ld (@ypos-1),de
       04          
04209A ED 43 B2 20 0183*      ld (@xpos-1),bc
       04          
04209F 3E 0D       0184*      ld a,13       ; restore the final byte of the command
0420A1 32 B2 20 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
0420A5 21 B0 20 04 0186*      ld hl,@cmd
0420A9 01 07 00 00 0187*      ld bc,@end-@cmd
0420AD 5B DF       0188*      rst.lil $18
0420AF C9          0189*      ret
0420B0 17 1B 0D    0190*  @cmd:  db 23,27,13
0420B3 00 00       0191*  @xpos: dw 0x0000
0420B5 00 00       0192*  @ypos: dw 0x0000
0420B7             0193*  @end:  ; no padding required b/c we shifted de right
0420B7             0194*  
0420B7             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0420B7             0196*  ; USING 16.8 FIXED POINT COORDINATES
0420B7             0197*  ; inputs: ub.c is dx, ud.e is dy
0420B7             0198*  ;   the fractional portiion of the inputs are truncated
0420B7             0199*  ;   leaving only the 16-bit integer portion
0420B7             0200*  ; prerequisites: vdu_sprite_select
0420B7             0201*  vdu_sprite_move_rel168:
0420B7             0202*  ; populate in the reverse of normal to keep the
0420B7             0203*  ; inputs from stomping on each other
0420B7 ED 53 D6 20 0204*      ld (@dy-1),de
       04          
0420BC ED 43 D4 20 0205*      ld (@dx-1),bc
       04          
0420C1 3E 0E       0206*      ld a,14       ; restore the final byte of the command
0420C3 32 D4 20 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
0420C7 21 D2 20 04 0208*      ld hl,@cmd
0420CB 01 07 00 00 0209*      ld bc,@end-@cmd
0420CF 5B DF       0210*      rst.lil $18
0420D1 C9          0211*      ret
0420D2 17 1B 0E    0212*  @cmd:  db 23,27,14
0420D5 00 00       0213*  @dx: dw 0x0000
0420D7 00 00       0214*  @dy: dw 0x0000
0420D9             0215*  @end:  ; no padding required b/c we shifted de right
0420D9             0216*  
0420D9             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
0420D9             0218*  ; inputs: none
0420D9             0219*  vdu_sprite_update:
0420D9 21 E4 20 04 0220*      ld hl,@cmd
0420DD 01 03 00 00 0221*      ld bc,@end-@cmd
0420E1 5B DF       0222*      rst.lil $18
0420E3 C9          0223*      ret
0420E4 17 1B 0F    0224*  @cmd: db 23,27,15
0420E7             0225*  @end:
0420E7             0226*  
0420E7             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0420E7             0228*  ; inputs: none
0420E7             0229*  vdu_sprite_bmp_reset:
0420E7 21 F2 20 04 0230*      ld hl,@cmd
0420EB 01 03 00 00 0231*      ld bc,@end-@cmd
0420EF 5B DF       0232*      rst.lil $18
0420F1 C9          0233*      ret
0420F2 17 1B 10    0234*  @cmd: db 23,27,16
0420F5             0235*  @end:
0420F5             0236*  
0420F5             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0420F5             0238*  ; inputs: none
0420F5             0239*  vdu_sprite_reset:
0420F5 21 00 21 04 0240*      ld hl,@cmd
0420F9 01 03 00 00 0241*      ld bc,@end-@cmd
0420FD 5B DF       0242*      rst.lil $18
0420FF C9          0243*      ret
042100 17 1B 11    0244*  @cmd: db 23,27,17
042103             0245*  @end:
042103             0246*  
042103             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042103             0248*  ; inputs: a is the GCOL paint mode
042103             0249*  ; prerequisites: vdu_sprite_select
042103             0250*  vdu_sprite_set_gcol:
042103 32 15 21 04 0251*      ld (@mode),a
042107 21 12 21 04 0252*      ld hl,@cmd
04210B 01 04 00 00 0253*      ld bc,@end-@cmd
04210F 5B DF       0254*      rst.lil $18
042111 C9          0255*      ret
042112 17 1B 12    0256*  @cmd:  db 23,27,18
042115 00          0257*  @mode: db 0x00
042116             0258*  @end:
042116             0259*  
042116             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
042116             0261*  ; inputs: hl=bufferId
042116             0262*  ; prerequisites: vdu_sprite_select
042116             0263*  vdu_sprite_add_buff:
042116 22 28 21 04 0264*      ld (@bufferId),hl
04211A 21 25 21 04 0265*      ld hl,@cmd
04211E 01 05 00 00 0266*      ld bc,@end-@cmd
042122 5B DF       0267*      rst.lil $18
042124 C9          0268*      ret
042125 17 1B 26    0269*  @cmd:      db 23,27,0x26
042128 00 00       0270*  @bufferId: dw 0x0000
04212A 00          0271*  @end:      db 0x00 ; padding
04212B             0057   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
04212B             0058   	include "maths.inc"
04212B             0001*  ; test the sign of HL
04212B             0002*  ; inputs: HL obviously
04212B             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04212B             0004*  ; destroys: flags
04212B             0005*      MACRO sign_hlu
04212B             0006*          add hl,de
04212B             0007*          or a
04212B             0008*          sbc hl,de
04212B             0009*      ENDMACRO
04212B             0010*  
04212B             0011*  
04212B             0012*  ;------------------------------------------------------------------------
04212B             0013*  ; Scratch area for calculations
04212B             0014*  ;------------------------------------------------------------------------
04212B 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
04212E 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
042131             0017*  
042131             0018*  ; absolute value of hlu
042131             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
042131             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
042131             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
042131             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
042131             0023*  ; destroys: a
042131             0024*  hlu_abs:
042131 19          0025*      add hl,de
042132 B7          0026*      or a
042133 ED 52       0027*      sbc hl,de
042135 FA 3A 21 04 0028*      jp m,@is_neg
042139 C9          0029*      ret         ; hlu is positive or zero so we're done
04213A             0030*  @is_neg:
04213A F5          0031*      push af     ; otherwise, save current flags for return
04213B CD 41 21 04 0032*      call neg_hlu ; negate hlu
04213F F1          0033*      pop af      ; get back flags
042140 C9          0034*      ret
042141             0035*  
042141             0036*  ; flip the sign of hlu
042141             0037*  ; inputs: hlu
042141             0038*  ; returns: 0-hlu, flags set appropriately for the result:
042141             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
042141             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
042141             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
042141             0042*  ; destroys a
042141             0043*  neg_hlu:
042141 D5          0044*      push de     ; save de
042142 EB          0045*      ex de,hl    ; put hl into de
042143 21 00 00 00 0046*      ld hl,0     ; clear hl
042147 AF          0047*      xor a       ; clear carry
042148 ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
04214A D1          0049*      pop de      ; get de back
04214B C9          0050*      ret         ; easy peasy
04214C             0051*  
04214C             0052*  ;------------------------------------------------------------------------
04214C             0053*  ; divide hlu by 2, inspired by above
04214C             0054*  ;------------------------------------------------------------------------
04214C             0055*  hlu_div2:
04214C 22 2B 21 04 0056*  	ld		(scratch1),hl
042150 21 2D 21 04 0057*  	ld		hl,scratch1+2
042154 CB 1E       0058*  	rr		(hl)
042156 2B          0059*  	dec		hl
042157 CB 1E       0060*  	rr		(hl)
042159 2B          0061*  	dec		hl
04215A CB 1E       0062*  	rr		(hl)
04215C 23          0063*  	inc		hl
04215D 23          0064*  	inc		hl
04215E 2A 2B 21 04 0065*      ld hl,(scratch1)
042162 C9          0066*      ret
042163             0067*  
042163             0068*  ; this is my little hack to divide by 16
042163             0069*  hlu_div16:
042163 AF          0070*      xor a
042164 29          0071*      add hl,hl
042165 17          0072*      rla
042166 29          0073*      add hl,hl
042167 17          0074*      rla
042168 29          0075*      add hl,hl
042169 17          0076*      rla
04216A 29          0077*      add hl,hl
04216B 17          0078*      rla
04216C 22 79 21 04 0079*      ld (@scratch),hl
042170 32 7C 21 04 0080*      ld (@scratch+3),a
042174 2A 7A 21 04 0081*      ld hl,(@scratch+1)
042178 C9          0082*      ret
042179             0083*  @scratch: ds 4
04217D             0084*  
04217D             0085*  ; hlu signed division by 256
04217D             0086*  ; returns: hlu / 256
04217D             0087*  ; destroys: af
04217D             0088*  hlu_sdiv256:
04217D AF          0089*      xor a ; assume hl is positive
04217E 22 94 21 04 0090*      ld (@buffer),hl
042182             0091*      sign_hlu
042182 19          0001*M         add hl,de
042183 B7          0002*M         or a
042184 ED 52       0003*M         sbc hl,de
042186 F2 8B 21 04 0092*      jp p,@hl_pos
04218A 3D          0093*      dec a
04218B             0094*  @hl_pos:
04218B 32 97 21 04 0095*      ld (@buffer+3),a
04218F 2A 95 21 04 0096*      ld hl,(@buffer+1)
042193 C9          0097*      ret
042194             0098*  @buffer: ds 4
042198             0099*  
042198             0100*  ; hlu 1 byte right shift, unsigned
042198             0101*  ; returns: hlu / 256, fractional portion in a
042198             0102*  ; destroys: af
042198             0103*  hlu_udiv256:
042198 AF          0104*  	xor a
042199 32 AA 21 04 0105*  	ld (@buffer+3),a
04219D 7D          0106*  	ld a,l ; save the fractional portion
04219E 22 A7 21 04 0107*  	ld (@buffer),hl
0421A2 2A A8 21 04 0108*  	ld hl,(@buffer+1)
0421A6 C9          0109*  	ret
0421A7             0110*  @buffer: ds 4
0421AB             0111*  
0421AB             0112*      MACRO hlu_mul256
0421AB             0113*          add hl,hl ; * 2
0421AB             0114*          add hl,hl ; * 4
0421AB             0115*          add hl,hl ; * 8
0421AB             0116*          add hl,hl ; * 16
0421AB             0117*          add hl,hl ; * 32
0421AB             0118*          add hl,hl ; * 64
0421AB             0119*          add hl,hl ; * 128
0421AB             0120*          add hl,hl ; * 256
0421AB             0121*      ENDMACRO
0421AB             0122*  
0421AB             0123*  ; compute the modulo of hlu by deu
0421AB             0124*  ; outputs: hlu = hlu % deu
0421AB             0125*  ; destroys: f, hl
0421AB             0126*  hlu_mod:
0421AB B7          0127*  	or a ; clear carry
0421AC             0128*  @loop:
0421AC ED 52       0129*      sbc hl,de
0421AE DA B6 21 04 0130*      jp c, @end
0421B2 C3 AC 21 04 0131*      jp @loop
0421B6             0132*  @end:
0421B6 19          0133*      add hl,de
0421B7 C9          0134*  	ret
0421B8             0135*  
0421B8             0136*  
0421B8 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
0421BC 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
0421C0             0139*  
0421C0             0140*  ; set bcd values in a scratch memory address from registers bcde
0421C0             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
0421C0             0142*  ; destroys ; hl
0421C0             0143*  set_bcd:
0421C0 73          0144*      ld (hl),e
0421C1 23          0145*      inc hl
0421C2 72          0146*      ld (hl),d
0421C3 23          0147*      inc hl
0421C4 71          0148*      ld (hl),c
0421C5 23          0149*      inc hl
0421C6 70          0150*      ld (hl),b
0421C7 C9          0151*      ret
0421C8             0152*  
0421C8             0153*  ; load bcd values from a scratch memory address to bcde
0421C8             0154*  ; input: hl; scratch address
0421C8             0155*  ; output: bcde; 8-place bcd number
0421C8             0156*  ; destroys: hl
0421C8             0157*  get_bcd:
0421C8 5E          0158*      ld e,(hl)
0421C9 23          0159*      inc hl
0421CA 56          0160*      ld d,(hl)
0421CB 23          0161*      inc hl
0421CC 4E          0162*      ld c,(hl)
0421CD 23          0163*      inc hl
0421CE 46          0164*      ld b,(hl)
0421CF C9          0165*      ret
0421D0             0166*  
0421D0             0167*  ; BCD addition
0421D0             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0421D0             0169*  ;       a is the number of bytes holding each number (number of places/2)
0421D0             0170*  ; outputs: (hl) + (de) --> (hl)
0421D0             0171*  ; destroys: a,b,de,hl
0421D0             0172*  add_bcd:
0421D0 47          0173*      ld b,a ; loop counter
0421D1 AF          0174*      xor a ; reset a, clear carry flag
0421D2             0175*  adcec:
0421D2 1A          0176*      ld a,(de) ; addend to acc
0421D3 8E          0177*      adc a,(hl) ; add (hl) to acc
0421D4 27          0178*      daa ; adjust result to bcd
0421D5 77          0179*      ld (hl),a ; store result
0421D6 23          0180*      inc hl ; advance memory pointers
0421D7 13          0181*      inc de
0421D8 10 F8       0182*      djnz adcec ; loop until b == 0
0421DA C9          0183*      ret
0421DB             0184*  
0421DB             0185*  ; BCD subtraction
0421DB             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0421DB             0187*  ;       a is the number of bytes holding each number (number of places/2)
0421DB             0188*  ; outputs: (hl) - (de) --> (hl)
0421DB             0189*  ; destroys: a,b,de,hl
0421DB             0190*  sub_bcd:
0421DB 47          0191*      ld b,a ; loop counter
0421DC AF          0192*      xor a ; reset a,clear carry flag
0421DD             0193*  subdec:
0421DD 1A          0194*      ld a,(de) ; subtrahend to acc
0421DE 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0421DF 27          0196*      daa ; adjust result to bcd
0421E0 77          0197*      ld (hl),a ; store result
0421E1 23          0198*      inc hl ; advance memory pointers
0421E2 13          0199*      inc de
0421E3 10 F8       0200*      djnz subdec ; loop until b == 0
0421E5 C9          0201*      ret
0421E6             0202*  
0421E6             0203*  ; http://www.z80.info/pseudo-random.txt
0421E6             0204*  rand_8:
0421E6 C5          0205*      push bc
0421E7 3A FA 21 04 0206*      ld a,(r_seed)
0421EB 4F          0207*      ld c,a
0421EC             0208*  
0421EC 0F          0209*      rrca ; multiply by 32
0421ED 0F          0210*      rrca
0421EE 0F          0211*      rrca
0421EF EE 1F       0212*      xor 0x1f
0421F1             0213*  
0421F1 81          0214*      add a,c
0421F2 DE FF       0215*      sbc a,255 ; carry
0421F4             0216*  
0421F4 32 FA 21 04 0217*      ld (r_seed),a
0421F8 C1          0218*      pop bc
0421F9 C9          0219*      ret
0421FA 50          0220*  r_seed: defb $50
0421FB             0059   	include "maths24.inc"
0421FB             0001*  ; 16.8 fixed inputs / outputs
0421FB             0002*  ; takes: uh.l as angle in degrees 256
0421FB             0003*  ;        ud.e as radius
0421FB             0004*  ; returns ub.c as dx, ud.e as dy
0421FB             0005*  ;        displacements from origin (0,0)
0421FB             0006*  ; destroys: everything except indexes
0421FB             0007*  polar_to_cartesian:
0421FB             0008*  ; back up input parameters
0421FB 22 34 1A 04 0009*      ld (uhl),hl
0421FF ED 53 3A 1A 0010*      ld (ude),de
       04          
042204             0011*  ; compute dx = sin(uh.l) * ud.e
042204 CD 33 22 04 0012*      call sin168
042208 E5          0013*      push hl
042209 C1          0014*      pop bc ; ub.c = sin(uh.l)
04220A ED 5B 3A 1A 0015*  	ld de,(ude) ; get radius back
       04          
04220F CD 05 2C 04 0016*  	call smul168 ; uh.l = ub.c * ud.e = dx
042213 E5          0017*      push hl ; store dx for output
042214             0018*  ; compute dy = -cos(uh.l) * ud.e
042214 2A 34 1A 04 0019*      ld hl,(uhl)
042218 CD 2E 22 04 0020*      call cos168
04221C CD 41 21 04 0021*  	call neg_hlu ; invert dy for screen coords convention
042220 E5          0022*      push hl
042221 C1          0023*      pop bc ; ub.c = -cos(uh.l)
042222 ED 5B 3A 1A 0024*      ld de,(ude) ; get radius back
       04          
042227 CD 05 2C 04 0025*      call smul168 ; uh.l = ub.c * ud.e = dy
04222B EB          0026*      ex de,hl    ; de = dy for output
04222C C1          0027*      pop bc      ; bc = dx for output
04222D             0028*  ; and out
04222D C9          0029*      ret
04222E             0030*  
04222E             0031*  ; fixed 16.8 routine
04222E             0032*  ; cos(uh.l) --> uh.l
04222E             0033*  ; destroys: de
04222E             0034*  cos168:
04222E             0035*  ; for cos we simply increment the angle by 90 degrees
04222E             0036*  ; or 0x004000 in 16.8 degrees256
04222E             0037*  ; which makes it a sin problem
04222E 11 00 40 00 0038*      ld de,0x004000
042232 19          0039*      add hl,de ; modulo 256 happens below
042233             0040*  ; fall through to sin168
042233             0041*  ; ---------------------
042233             0042*  ; fixed 16.8 routine
042233             0043*  ; sin(uh.l) --> uh.l
042233             0044*  ; destroys: de
042233             0045*  sin168:
042233             0046*  ; h contains the integer portion of our angle
042233             0047*  ; we multiply it by three to get our lookup table index
042233 2E 03       0048*      ld l,3
042235 ED 6C       0049*      mlt hl ; gosh that is handy
042237 11 00 00 00 0050*      ld de,0 ; clear deu
04223B 54          0051*      ld d,h ; copy hl to de
04223C 5D          0052*      ld e,l ; de contains our index
04223D 21 44 24 04 0053*      ld hl,sin_lut_168 ; grab the lut address
042241 19          0054*      add hl,de ; bump hl by the index
042242 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
042244 C9          0056*      ret ; and out
042245             0057*  
042245             0058*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042245             0059*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042245             0060*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042245             0061*  ;         also populates scratch locations dx168 and dy168
042245             0062*  ; destroys: a,hl,bc,de
042245             0063*  dxy168:
042245             0064*  ; compute dx = x1-x0
042245 AF          0065*      xor a ; clear carry
042246 DD E5       0066*      push ix ; move ix to hl via the stack
042248 E1          0067*      pop hl ; hl = x1
042249 ED 42       0068*      sbc hl,bc ; hl = dx
04224B 22 A0 22 04 0069*      ld (dx168),hl ; dx to scratch
04224F             0070*  ; compute dy = y1-y0
04224F AF          0071*      xor a ; clear carry
042250 FD E5       0072*      push iy ; move iy to hl via the stack
042252 E1          0073*      pop hl ; hl = y1
042253 ED 52       0074*      sbc hl,de ; hl = dy
042255 22 A6 22 04 0075*      ld (dy168),hl ; dy to scratch
042259             0076*  ; populate output registers and return
042259 EB          0077*      ex de,hl        ; ud.e = dy
04225A ED 4B A0 22 0078*      ld bc,(dx168)   ; ub.c = dx
       04          
04225F C9          0079*      ret
042260             0080*  
042260             0081*  ; compute the euclidian distance between two cartesian coordinates
042260             0082*  ; using the formula d = sqrt(dx^2+dy^2
042260             0083*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042260             0084*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042260             0085*  ; output; uh.l is the 16.8 fixed format distance
042260             0086*  ;       dx168/y are the 16.8 fixed format dx and dy
042260             0087*  ; destroys: a,hl,bc,de
042260             0088*  distance168:
042260             0089*  ; compute dx = x1-x0
042260 AF          0090*      xor a ; clear carry
042261 DD E5       0091*      push ix ; move ix to hl via the stack
042263 E1          0092*      pop hl ; hl = x1
042264 ED 42       0093*      sbc hl,bc ; hl = dx
042266 22 A0 22 04 0094*      ld (dx168),hl ; dx to scratch
04226A             0095*  ; ; test dx for overflow
04226A             0096*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
04226A             0097*  ; 	ex de,hl
04226A             0098*  ; 	sbc hl,de ; test for overflow
04226A             0099*  ; 	push af ; carry indicates overflow
04226A             0100*  ; compute dy = y1-y0
04226A AF          0101*      xor a ; clear carry
04226B FD E5       0102*      push iy ; move iy to hl via the stack
04226D E1          0103*      pop hl ; hl = y1
04226E ED 52       0104*      sbc hl,de ; hl = dy
042270 22 A6 22 04 0105*      ld (dy168),hl ; dy to scratch
042274             0106*  ; ; test dy for overflow
042274             0107*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
042274             0108*  ; 	ex de,hl
042274             0109*  ; 	sbc hl,de ; test for overflow
042274             0110*  ; 	push af ; carry indicates overflow
042274             0111*  ; compute dy^2
042274 2A A6 22 04 0112*  	ld hl,(dy168)
042278 CD 31 21 04 0113*      call hlu_abs  ; make dy positive so we can use unsigned multiply
04227C             0114*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04227C E5          0115*      push hl ; load hl/2 to bc via the stack
04227D C1          0116*      pop bc ; bc = dy/2
04227E EB          0117*      ex de,hl ; de = dy/2
04227F CD FD 2B 04 0118*      call umul168 ; uh.l = dy^2/2
042283 E5          0119*      push hl ; dy^2/2 to the stack
042284             0120*  ; compute dx^2
042284 2A A0 22 04 0121*      ld hl,(dx168) ; get back dx
042288 CD 31 21 04 0122*      call hlu_abs  ; make dx positive so we can use unsigned multiply
04228C             0123*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04228C E5          0124*      push hl ; load hl/2 to bc via the stack
04228D C1          0125*      pop bc ; bc = dx/2
04228E EB          0126*      ex de,hl ; de = dx/2
04228F CD FD 2B 04 0127*      call umul168 ; uh.l = dx^2/2
042293             0128*  ; commpute dy^2+dx^2
042293 D1          0129*      pop de ; get back dx^2/2
042294 19          0130*      add hl,de ; hl = dx^2/2+dy^2/2
042295             0131*  ; compute sqrt(dx^2/2+dy^2/2)
042295 CD 59 23 04 0132*      call sqrt168 ; uh.l = distance/2
042299             0133*      ; add hl,hl ; hl = distance
042299             0134*  ; ; check for overflow
042299             0135*  ; 	pop af ; get back the overflow flags
042299             0136*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042299             0137*  ; 	ld b,a ; save the overflow flag
042299             0138*  ; 	pop af ; get back the overflow flags
042299             0139*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042299             0140*  ; 	add a,b ; if a != 0 then we had overflow
042299             0141*  ;     ret z ; no overflow we're done
042299             0142*  ; @overflow:
042299             0143*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
042299 C9          0144*  	ret
04229A             0145*  @scratch: ds 6
0422A0             0146*  dx168: ds 6
0422A6             0147*  dy168: ds 6
0422AC             0148*  
0422AC             0149*  ; atan2(ub.c,ud.e) --> uh.l
0422AC             0150*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0422AC             0151*  ;   whether inputs are integers or fractional doesn't matter
0422AC             0152*  ;   so long as the sign bit of the upper byte is correct
0422AC             0153*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0422AC             0154*  ; angles are COMPASS HEADINGS based on
0422AC             0155*  ; screen coordinate conventions,where the y axis is flipped
0422AC             0156*  ; #E0 315      0       45 #20
0422AC             0157*  ;        -x,-y | +x,-y
0422AC             0158*  ; #C0 270------+------ 90 #40
0422AC             0159*  ;        -x,+y | +x,+y
0422AC             0160*  ; #A0 225   180 #80   135 #60
0422AC             0161*  atan2_168game:
0422AC             0162*  ; get signs and make everything positive
0422AC             0163*  ; get abs(x) and store its original sign
0422AC C5          0164*      push bc
0422AD E1          0165*      pop hl
0422AE CD 31 21 04 0166*      call hlu_abs ; if x was negative this also sets the sign flag
0422B2 E5          0167*      push hl ; store abs(x)
0422B3 C1          0168*      pop bc ; bc = abs(x)
0422B4 F5          0169*      push af ; store sign of x
0422B5             0170*  ; get abs(y) and store its original sign
0422B5 EB          0171*      ex de,hl ; hl = y
0422B6 CD 31 21 04 0172*      call hlu_abs ; if y was negative this also sets the sign flag
0422BA EB          0173*      ex de,hl ; de = abs(y)
0422BB F5          0174*      push af ; store sign of y
0422BC             0175*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0422BC             0176*  ; this ensures that our lookup value is between 0 and 1 inclusive
0422BC AF          0177*      xor a ; clear the carry flag
0422BD D5          0178*      push de
0422BE E1          0179*      pop hl
0422BF ED 42       0180*      sbc hl,bc
0422C1 F5          0181*      push af ; save sign of de - bc
0422C2 F2 CB 22 04 0182*      jp p,@1 ; bc <= de, so we skip ahead
0422C6             0183*  ; otherwise we swap bc and de
0422C6 C5          0184*      push bc
0422C7 E1          0185*      pop hl
0422C8 EB          0186*      ex de,hl
0422C9 E5          0187*      push hl
0422CA C1          0188*      pop bc
0422CB             0189*  @1:
0422CB             0190*  ; now we're ready to snag our preliminary result
0422CB CD 39 23 04 0191*      call atan_168game ; uh.l comes back with prelim result
0422CF             0192*  ; now we adjust uh.l based on sign of de - bc
0422CF F1          0193*      pop af
0422D0 F2 DC 22 04 0194*      jp p,@2 ; bc <= de,so we skip ahead
0422D4 EB          0195*      ex de,hl
0422D5 21 00 40 00 0196*      ld hl,0x004000 ; 90 degrees
0422D9 AF          0197*      xor a ; clear the carry flag
0422DA ED 52       0198*      sbc hl,de ; subtract result from 90 degrees
0422DC             0199*      ; ld de,0 ; prep to clear hlu
0422DC             0200*      ; ld d,h
0422DC             0201*      ; ld e,l
0422DC             0202*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0422DC             0203*      ; fall through
0422DC             0204*  @2:
0422DC             0205*  ; now the fun part of adjusting the result
0422DC             0206*  ; based on which quadrant (x,y) is in
0422DC             0207*  ; #E0 315      0       45 #20
0422DC             0208*  ;        -x,-y | +x,-y
0422DC             0209*  ; #C0 270------+------ 90 #40
0422DC             0210*  ;        -x,+y | +x,+y
0422DC             0211*  ; #A0 225   180 #80   135 #60
0422DC F1          0212*      pop af ; sign of y
0422DD CA 1A 23 04 0213*      jp z,@y_zero
0422E1 F2 FA 22 04 0214*      jp p,@y_pos
0422E5             0215*  ; y neg,check x
0422E5 F1          0216*      pop af ; sign of x
0422E6 CA F4 22 04 0217*      jp z,@y_neg_x_zero
0422EA F2 F9 22 04 0218*      jp p,@y_neg_x_pos
0422EE             0219*  ; y neg,x neg
0422EE             0220*  ; angle is 270-360
0422EE             0221*  ; negating the intermediate does the trick
0422EE CD 41 21 04 0222*      call neg_hlu
0422F2 18 31       0223*      jr @zero_hlu
0422F4             0224*  
0422F4             0225*  @y_neg_x_zero:
0422F4             0226*  ; y neg,x zero
0422F4             0227*  ; angle is 0
0422F4 21 00 00 00 0228*      ld hl,0
0422F8 C9          0229*      ret
0422F9             0230*  @y_neg_x_pos:
0422F9             0231*  ; y neg,x pos
0422F9             0232*  ; angle is 0 to 90
0422F9             0233*  ; so we're good
0422F9 C9          0234*      ret
0422FA             0235*  
0422FA             0236*  @y_pos:
0422FA F1          0237*      pop af ; sign of x
0422FB CA 0A 23 04 0238*      jp z,@y_pos_x_zero
0422FF F2 0F 23 04 0239*      jp p,@y_pos_x_pos
042303             0240*  ; y pos,x neg
042303             0241*  ; angle is 180-270
042303             0242*  ; so we add 180 to intermediate
042303 11 00 80 00 0243*      ld de,0x008000
042307 19          0244*      add hl,de
042308 18 1B       0245*      jr @zero_hlu
04230A             0246*  @y_pos_x_zero:
04230A             0247*  ; y pos,x zero
04230A             0248*  ; angle is 180
04230A 21 00 80 00 0249*      ld hl,0x008000
04230E C9          0250*      ret
04230F             0251*  @y_pos_x_pos:
04230F             0252*  ; y pos,x pos
04230F             0253*  ; angle is 90-180
04230F             0254*  ; neg the intermediate and add 180 degrees
04230F CD 41 21 04 0255*      call neg_hlu
042313 11 00 80 00 0256*      ld de,0x008000
042317 19          0257*      add hl,de
042318 18 0B       0258*      jr @zero_hlu
04231A             0259*  
04231A             0260*  @y_zero:
04231A F1          0261*      pop af ; sign of x
04231B FA 20 23 04 0262*      jp m,@y_zero_x_neg
04231F             0263*  ; y zero,x pos
04231F             0264*  ; angle is 90,nothing to do
04231F C9          0265*      ret
042320             0266*  @y_zero_x_neg:
042320             0267*  ; y zero ,x neg
042320             0268*  ; angle is 270
042320 21 00 C0 00 0269*      ld hl,0x00C000
042324 C9          0270*      ret
042325             0271*  @zero_hlu:
042325 AF          0272*      xor a
042326 22 33 23 04 0273*      ld (@scratch),hl
04232A 32 35 23 04 0274*      ld (@scratch+2),a
04232E 2A 33 23 04 0275*      ld hl,(@scratch)
042332 C9          0276*      ret
042333             0277*  @scratch: ds 6
042339             0278*  
042339             0279*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042339             0280*  ; output: uh.l is the 16.8 fixed format angle
042339             0281*  ; destroys: a,hl,bc,de
042339             0282*  ; the following note was written by github copilot:
042339             0283*  ; note: this routine is a bit of a hack
042339             0284*  ;      but it works
042339             0285*  ;      and it's fast
042339             0286*  ;      and it's small
042339             0287*  ;      and it's accurate
042339             0288*  ;      and it's easy to understand
042339             0289*  ;      and it's easy to modify
042339             0290*  ;      and it's easy to use
042339             0291*  ;      and it's easy to remember
042339             0292*  ;      and it's easy to love
042339             0293*  ;      and it's easy to hate
042339             0294*  ;      and it's easy to ignore
042339             0295*  ;      and it's easy to forget
042339             0296*  ;      and it's easy to remember
042339             0297*  ;      and it's easy to forget
042339             0298*  ;      and it's easy to remember
042339             0299*  ;      (ok the bot is stuck in a loop)
042339             0300*  ; REAL NOTE: only works for angles from 0 to 45 degrees
042339             0301*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
042339             0302*  atan_168game:
042339             0303*  ; because we use compass headings instead of geometric angles
042339             0304*  ; we compute dx/dy which is 1/tan(theta) in the maths world
042339             0305*  ; we can do faster unsigned division here because we know dx and dy are positive
042339 CD 28 2C 04 0306*  	call udiv168 ; uh.l = dx/dy
04233D             0307*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
04233D             0308*  ; ; test uh.l for 0
04233D             0309*  ;     add hl,de
04233D             0310*  ;     or a
04233D             0311*  ;     sbc hl,de
04233D             0312*  ;     jr z,@is_zero
04233D             0313*  ; ; test uh.l for 1
04233D             0314*  ;     xor a ; clear carry
04233D             0315*  ;     ex de,hl
04233D             0316*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
04233D             0317*  ;     sbc hl,de
04233D             0318*  ;     jr z,@is_45
04233D             0319*  ; ; END TODO
04233D             0320*  
04233D             0321*  ; no special cases so we move on
04233D             0322*  ; l contains the fractional portion of tan(uh.l)
04233D             0323*  ; we multiply it by three to get our lookup table index
04233D 26 03       0324*      ld h,3
04233F ED 6C       0325*      mlt hl ; gosh that is handy
042341 11 00 00 00 0326*      ld de,0 ; clear deu
042345 54          0327*      ld d,h ; copy hl to de
042346 5D          0328*      ld e,l ; de contains our index
042347 21 44 27 04 0329*      ld hl,atan_lut_168 ; grab the lut address
04234B 19          0330*      add hl,de ; bump hl by the index
04234C ED 27       0331*      ld hl,(hl) ; don't try this on a z80!
04234E C9          0332*      ret ; and out
04234F             0333*  @is_45:
04234F 21 00 20 00 0334*      ld hl,0x002000 ; 45 degrees decimal
042353 C9          0335*      ret
042354             0336*  ; for the case tan(0)
042354             0337*  @is_zero:
042354 21 00 00 00 0338*      ld hl,0x000000
042358 C9          0339*      ret
042359             0340*  
042359             0341*  ; Expects  ADL mode
042359             0342*  ; Inputs:  UH.L
042359             0343*  ; Outputs: UH.L is the 16.8 square root
042359             0344*  ;          UD.E is the difference inputHL-DE^2
042359             0345*  ;          c flag reset
042359             0346*  sqrt168:
042359 CD 63 23 04 0347*      call sqrt24
04235D EB          0348*      ex de,hl
04235E 29          0349*      add hl,hl
04235F 29          0350*      add hl,hl
042360 29          0351*      add hl,hl
042361 29          0352*      add hl,hl
042362 C9          0353*      ret
042363             0354*  
042363             0355*  ; Expects  ADL mode
042363             0356*  ; Inputs:  HL
042363             0357*  ; Outputs: DE is the integer square root
042363             0358*  ;          HL is the difference inputHL-DE^2
042363             0359*  ;          c flag reset
042363             0360*  sqrt24:
042363 AF          0361*      xor a
042364 45          0362*      ld b,l
042365 C5          0363*      push bc
042366 47          0364*      ld b,a
042367 57          0365*      ld d,a
042368 4F          0366*      ld c,a
042369 6F          0367*      ld l,a
04236A 5F          0368*      ld e,a
04236B             0369*  
04236B             0370*      ;Iteration 1
04236B 29          0371*      add hl,hl
04236C CB 11       0372*      rl c
04236E 29          0373*      add hl,hl
04236F CB 11       0374*      rl c
042371 91          0375*      sub c
042372 30 04       0376*      jr nc,$+6
042374 1C          0377*      inc e
042375 1C          0378*      inc e
042376 2F          0379*      cpl
042377 4F          0380*      ld c,a
042378             0381*  
042378             0382*      ;Iteration 2
042378 29          0383*      add hl,hl
042379 CB 11       0384*      rl c
04237B 29          0385*      add hl,hl
04237C CB 11       0386*      rl c
04237E CB 13       0387*      rl e
042380 7B          0388*      ld a,e
042381 91          0389*      sub c
042382 30 04       0390*      jr nc,$+6
042384 1C          0391*      inc e
042385 1C          0392*      inc e
042386 2F          0393*      cpl
042387 4F          0394*      ld c,a
042388             0395*  
042388             0396*      ;Iteration 3
042388 29          0397*      add hl,hl
042389 CB 11       0398*      rl c
04238B 29          0399*      add hl,hl
04238C CB 11       0400*      rl c
04238E CB 13       0401*      rl e
042390 7B          0402*      ld a,e
042391 91          0403*      sub c
042392 30 04       0404*      jr nc,$+6
042394 1C          0405*      inc e
042395 1C          0406*      inc e
042396 2F          0407*      cpl
042397 4F          0408*      ld c,a
042398             0409*  
042398             0410*      ;Iteration 4
042398 29          0411*      add hl,hl
042399 CB 11       0412*      rl c
04239B 29          0413*      add hl,hl
04239C CB 11       0414*      rl c
04239E CB 13       0415*      rl e
0423A0 7B          0416*      ld a,e
0423A1 91          0417*      sub c
0423A2 30 04       0418*      jr nc,$+6
0423A4 1C          0419*      inc e
0423A5 1C          0420*      inc e
0423A6 2F          0421*      cpl
0423A7 4F          0422*      ld c,a
0423A8             0423*  
0423A8             0424*      ;Iteration 5
0423A8 29          0425*      add hl,hl
0423A9 CB 11       0426*      rl c
0423AB 29          0427*      add hl,hl
0423AC CB 11       0428*      rl c
0423AE CB 13       0429*      rl e
0423B0 7B          0430*      ld a,e
0423B1 91          0431*      sub c
0423B2 30 04       0432*      jr nc,$+6
0423B4 1C          0433*      inc e
0423B5 1C          0434*      inc e
0423B6 2F          0435*      cpl
0423B7 4F          0436*      ld c,a
0423B8             0437*  
0423B8             0438*      ;Iteration 6
0423B8 29          0439*      add hl,hl
0423B9 CB 11       0440*      rl c
0423BB 29          0441*      add hl,hl
0423BC CB 11       0442*      rl c
0423BE CB 13       0443*      rl e
0423C0 7B          0444*      ld a,e
0423C1 91          0445*      sub c
0423C2 30 04       0446*      jr nc,$+6
0423C4 1C          0447*      inc e
0423C5 1C          0448*      inc e
0423C6 2F          0449*      cpl
0423C7 4F          0450*      ld c,a
0423C8             0451*  
0423C8             0452*      ;Iteration 7
0423C8 29          0453*      add hl,hl
0423C9 CB 11       0454*      rl c
0423CB 29          0455*      add hl,hl
0423CC CB 11       0456*      rl c
0423CE CB 10       0457*      rl b
0423D0 EB          0458*      ex de,hl
0423D1 29          0459*      add hl,hl
0423D2 E5          0460*      push hl
0423D3 ED 42       0461*      sbc hl,bc
0423D5 30 06       0462*      jr nc,$+8
0423D7 7C          0463*      ld a,h
0423D8 2F          0464*      cpl
0423D9 47          0465*      ld b,a
0423DA 7D          0466*      ld a,l
0423DB 2F          0467*      cpl
0423DC 4F          0468*      ld c,a
0423DD E1          0469*      pop hl
0423DE 30 02       0470*      jr nc,$+4
0423E0 23          0471*      inc hl
0423E1 23          0472*      inc hl
0423E2 EB          0473*      ex de,hl
0423E3             0474*  
0423E3             0475*      ;Iteration 8
0423E3 29          0476*      add hl,hl
0423E4 69          0477*      ld l,c
0423E5 60          0478*      ld h,b
0423E6 ED 6A       0479*      adc hl,hl
0423E8 ED 6A       0480*      adc hl,hl
0423EA EB          0481*      ex de,hl
0423EB 29          0482*      add hl,hl
0423EC ED 52       0483*      sbc hl,de
0423EE 19          0484*      add hl,de
0423EF EB          0485*      ex de,hl
0423F0 30 04       0486*      jr nc,$+6
0423F2 ED 52       0487*      sbc hl,de
0423F4 13          0488*      inc de
0423F5 13          0489*      inc de
0423F6             0490*  
0423F6             0491*      ;Iteration 9
0423F6 F1          0492*      pop af
0423F7 17          0493*      rla
0423F8 ED 6A       0494*      adc hl,hl
0423FA 17          0495*      rla
0423FB ED 6A       0496*      adc hl,hl
0423FD EB          0497*      ex de,hl
0423FE 29          0498*      add hl,hl
0423FF ED 52       0499*      sbc hl,de
042401 19          0500*      add hl,de
042402 EB          0501*      ex de,hl
042403 30 04       0502*      jr nc,$+6
042405 ED 52       0503*      sbc hl,de
042407 13          0504*      inc de
042408 13          0505*      inc de
042409             0506*  
042409             0507*      ;Iteration 10
042409 17          0508*      rla
04240A ED 6A       0509*      adc hl,hl
04240C 17          0510*      rla
04240D ED 6A       0511*      adc hl,hl
04240F EB          0512*      ex de,hl
042410 29          0513*      add hl,hl
042411 ED 52       0514*      sbc hl,de
042413 19          0515*      add hl,de
042414 EB          0516*      ex de,hl
042415 30 04       0517*      jr nc,$+6
042417 ED 52       0518*      sbc hl,de
042419 13          0519*      inc de
04241A 13          0520*      inc de
04241B             0521*  
04241B             0522*      ;Iteration 11
04241B 17          0523*      rla
04241C ED 6A       0524*      adc hl,hl
04241E 17          0525*      rla
04241F ED 6A       0526*      adc hl,hl
042421 EB          0527*      ex de,hl
042422 29          0528*      add hl,hl
042423 ED 52       0529*      sbc hl,de
042425 19          0530*      add hl,de
042426 EB          0531*      ex de,hl
042427 30 04       0532*      jr nc,$+6
042429 ED 52       0533*      sbc hl,de
04242B 13          0534*      inc de
04242C 13          0535*      inc de
04242D             0536*  
04242D             0537*      ;Iteration 11
04242D 17          0538*      rla
04242E ED 6A       0539*      adc hl,hl
042430 17          0540*      rla
042431 ED 6A       0541*      adc hl,hl
042433 EB          0542*      ex de,hl
042434 29          0543*      add hl,hl
042435 ED 52       0544*      sbc hl,de
042437 19          0545*      add hl,de
042438 EB          0546*      ex de,hl
042439 30 04       0547*      jr nc,$+6
04243B ED 52       0548*      sbc hl,de
04243D 13          0549*      inc de
04243E 13          0550*      inc de
04243F             0551*  
04243F CB 1A       0552*      rr d
042441 CB 1B       0553*      rr e
042443 C9          0554*      ret
042444             0555*  
042444             0556*  sin_lut_168:
042444 00 00 00    0557*  	dl 0x000000 ; 0.000 00, 0.000
042447 06 00 00    0558*  	dl 0x000006 ; 1.406 01, 0.025
04244A 0C 00 00    0559*  	dl 0x00000C ; 2.813 02, 0.049
04244D 12 00 00    0560*  	dl 0x000012 ; 4.219 03, 0.074
042450 19 00 00    0561*  	dl 0x000019 ; 5.625 04, 0.098
042453 1F 00 00    0562*  	dl 0x00001F ; 7.031 05, 0.122
042456 25 00 00    0563*  	dl 0x000025 ; 8.438 06, 0.147
042459 2B 00 00    0564*  	dl 0x00002B ; 9.844 07, 0.171
04245C 31 00 00    0565*  	dl 0x000031 ; 11.250 08, 0.195
04245F 38 00 00    0566*  	dl 0x000038 ; 12.656 09, 0.219
042462 3E 00 00    0567*  	dl 0x00003E ; 14.063 0A, 0.243
042465 44 00 00    0568*  	dl 0x000044 ; 15.469 0B, 0.267
042468 4A 00 00    0569*  	dl 0x00004A ; 16.875 0C, 0.290
04246B 50 00 00    0570*  	dl 0x000050 ; 18.281 0D, 0.314
04246E 56 00 00    0571*  	dl 0x000056 ; 19.688 0E, 0.337
042471 5C 00 00    0572*  	dl 0x00005C ; 21.094 0F, 0.360
042474 61 00 00    0573*  	dl 0x000061 ; 22.500 10, 0.383
042477 67 00 00    0574*  	dl 0x000067 ; 23.906 11, 0.405
04247A 6D 00 00    0575*  	dl 0x00006D ; 25.313 12, 0.428
04247D 73 00 00    0576*  	dl 0x000073 ; 26.719 13, 0.450
042480 78 00 00    0577*  	dl 0x000078 ; 28.125 14, 0.471
042483 7E 00 00    0578*  	dl 0x00007E ; 29.531 15, 0.493
042486 83 00 00    0579*  	dl 0x000083 ; 30.938 16, 0.514
042489 88 00 00    0580*  	dl 0x000088 ; 32.344 17, 0.535
04248C 8E 00 00    0581*  	dl 0x00008E ; 33.750 18, 0.556
04248F 93 00 00    0582*  	dl 0x000093 ; 35.156 19, 0.576
042492 98 00 00    0583*  	dl 0x000098 ; 36.563 1A, 0.596
042495 9D 00 00    0584*  	dl 0x00009D ; 37.969 1B, 0.615
042498 A2 00 00    0585*  	dl 0x0000A2 ; 39.375 1C, 0.634
04249B A7 00 00    0586*  	dl 0x0000A7 ; 40.781 1D, 0.653
04249E AB 00 00    0587*  	dl 0x0000AB ; 42.188 1E, 0.672
0424A1 B0 00 00    0588*  	dl 0x0000B0 ; 43.594 1F, 0.690
0424A4 B5 00 00    0589*  	dl 0x0000B5 ; 45.000 20, 0.707
0424A7 B9 00 00    0590*  	dl 0x0000B9 ; 46.406 21, 0.724
0424AA BD 00 00    0591*  	dl 0x0000BD ; 47.813 22, 0.741
0424AD C1 00 00    0592*  	dl 0x0000C1 ; 49.219 23, 0.757
0424B0 C5 00 00    0593*  	dl 0x0000C5 ; 50.625 24, 0.773
0424B3 C9 00 00    0594*  	dl 0x0000C9 ; 52.031 25, 0.788
0424B6 CD 00 00    0595*  	dl 0x0000CD ; 53.438 26, 0.803
0424B9 D1 00 00    0596*  	dl 0x0000D1 ; 54.844 27, 0.818
0424BC D4 00 00    0597*  	dl 0x0000D4 ; 56.250 28, 0.831
0424BF D8 00 00    0598*  	dl 0x0000D8 ; 57.656 29, 0.845
0424C2 DB 00 00    0599*  	dl 0x0000DB ; 59.063 2A, 0.858
0424C5 DE 00 00    0600*  	dl 0x0000DE ; 60.469 2B, 0.870
0424C8 E1 00 00    0601*  	dl 0x0000E1 ; 61.875 2C, 0.882
0424CB E4 00 00    0602*  	dl 0x0000E4 ; 63.281 2D, 0.893
0424CE E7 00 00    0603*  	dl 0x0000E7 ; 64.688 2E, 0.904
0424D1 EA 00 00    0604*  	dl 0x0000EA ; 66.094 2F, 0.914
0424D4 EC 00 00    0605*  	dl 0x0000EC ; 67.500 30, 0.924
0424D7 EE 00 00    0606*  	dl 0x0000EE ; 68.906 31, 0.933
0424DA F1 00 00    0607*  	dl 0x0000F1 ; 70.313 32, 0.942
0424DD F3 00 00    0608*  	dl 0x0000F3 ; 71.719 33, 0.950
0424E0 F4 00 00    0609*  	dl 0x0000F4 ; 73.125 34, 0.957
0424E3 F6 00 00    0610*  	dl 0x0000F6 ; 74.531 35, 0.964
0424E6 F8 00 00    0611*  	dl 0x0000F8 ; 75.938 36, 0.970
0424E9 F9 00 00    0612*  	dl 0x0000F9 ; 77.344 37, 0.976
0424EC FB 00 00    0613*  	dl 0x0000FB ; 78.750 38, 0.981
0424EF FC 00 00    0614*  	dl 0x0000FC ; 80.156 39, 0.985
0424F2 FD 00 00    0615*  	dl 0x0000FD ; 81.563 3A, 0.989
0424F5 FE 00 00    0616*  	dl 0x0000FE ; 82.969 3B, 0.992
0424F8 FE 00 00    0617*  	dl 0x0000FE ; 84.375 3C, 0.995
0424FB FF 00 00    0618*  	dl 0x0000FF ; 85.781 3D, 0.997
0424FE FF 00 00    0619*  	dl 0x0000FF ; 87.188 3E, 0.999
042501 FF 00 00    0620*  	dl 0x0000FF ; 88.594 3F, 1.000
042504 00 01 00    0621*  	dl 0x000100 ; 90.000 40, 1.000
042507 FF 00 00    0622*  	dl 0x0000FF ; 91.406 41, 1.000
04250A FF 00 00    0623*  	dl 0x0000FF ; 92.813 42, 0.999
04250D FF 00 00    0624*  	dl 0x0000FF ; 94.219 43, 0.997
042510 FE 00 00    0625*  	dl 0x0000FE ; 95.625 44, 0.995
042513 FE 00 00    0626*  	dl 0x0000FE ; 97.031 45, 0.992
042516 FD 00 00    0627*  	dl 0x0000FD ; 98.438 46, 0.989
042519 FC 00 00    0628*  	dl 0x0000FC ; 99.844 47, 0.985
04251C FB 00 00    0629*  	dl 0x0000FB ; 101.250 48, 0.981
04251F F9 00 00    0630*  	dl 0x0000F9 ; 102.656 49, 0.976
042522 F8 00 00    0631*  	dl 0x0000F8 ; 104.063 4A, 0.970
042525 F6 00 00    0632*  	dl 0x0000F6 ; 105.469 4B, 0.964
042528 F4 00 00    0633*  	dl 0x0000F4 ; 106.875 4C, 0.957
04252B F3 00 00    0634*  	dl 0x0000F3 ; 108.281 4D, 0.950
04252E F1 00 00    0635*  	dl 0x0000F1 ; 109.688 4E, 0.942
042531 EE 00 00    0636*  	dl 0x0000EE ; 111.094 4F, 0.933
042534 EC 00 00    0637*  	dl 0x0000EC ; 112.500 50, 0.924
042537 EA 00 00    0638*  	dl 0x0000EA ; 113.906 51, 0.914
04253A E7 00 00    0639*  	dl 0x0000E7 ; 115.313 52, 0.904
04253D E4 00 00    0640*  	dl 0x0000E4 ; 116.719 53, 0.893
042540 E1 00 00    0641*  	dl 0x0000E1 ; 118.125 54, 0.882
042543 DE 00 00    0642*  	dl 0x0000DE ; 119.531 55, 0.870
042546 DB 00 00    0643*  	dl 0x0000DB ; 120.938 56, 0.858
042549 D8 00 00    0644*  	dl 0x0000D8 ; 122.344 57, 0.845
04254C D4 00 00    0645*  	dl 0x0000D4 ; 123.750 58, 0.831
04254F D1 00 00    0646*  	dl 0x0000D1 ; 125.156 59, 0.818
042552 CD 00 00    0647*  	dl 0x0000CD ; 126.563 5A, 0.803
042555 C9 00 00    0648*  	dl 0x0000C9 ; 127.969 5B, 0.788
042558 C5 00 00    0649*  	dl 0x0000C5 ; 129.375 5C, 0.773
04255B C1 00 00    0650*  	dl 0x0000C1 ; 130.781 5D, 0.757
04255E BD 00 00    0651*  	dl 0x0000BD ; 132.188 5E, 0.741
042561 B9 00 00    0652*  	dl 0x0000B9 ; 133.594 5F, 0.724
042564 B5 00 00    0653*  	dl 0x0000B5 ; 135.000 60, 0.707
042567 B0 00 00    0654*  	dl 0x0000B0 ; 136.406 61, 0.690
04256A AB 00 00    0655*  	dl 0x0000AB ; 137.813 62, 0.672
04256D A7 00 00    0656*  	dl 0x0000A7 ; 139.219 63, 0.653
042570 A2 00 00    0657*  	dl 0x0000A2 ; 140.625 64, 0.634
042573 9D 00 00    0658*  	dl 0x00009D ; 142.031 65, 0.615
042576 98 00 00    0659*  	dl 0x000098 ; 143.438 66, 0.596
042579 93 00 00    0660*  	dl 0x000093 ; 144.844 67, 0.576
04257C 8E 00 00    0661*  	dl 0x00008E ; 146.250 68, 0.556
04257F 88 00 00    0662*  	dl 0x000088 ; 147.656 69, 0.535
042582 83 00 00    0663*  	dl 0x000083 ; 149.063 6A, 0.514
042585 7E 00 00    0664*  	dl 0x00007E ; 150.469 6B, 0.493
042588 78 00 00    0665*  	dl 0x000078 ; 151.875 6C, 0.471
04258B 73 00 00    0666*  	dl 0x000073 ; 153.281 6D, 0.450
04258E 6D 00 00    0667*  	dl 0x00006D ; 154.688 6E, 0.428
042591 67 00 00    0668*  	dl 0x000067 ; 156.094 6F, 0.405
042594 61 00 00    0669*  	dl 0x000061 ; 157.500 70, 0.383
042597 5C 00 00    0670*  	dl 0x00005C ; 158.906 71, 0.360
04259A 56 00 00    0671*  	dl 0x000056 ; 160.313 72, 0.337
04259D 50 00 00    0672*  	dl 0x000050 ; 161.719 73, 0.314
0425A0 4A 00 00    0673*  	dl 0x00004A ; 163.125 74, 0.290
0425A3 44 00 00    0674*  	dl 0x000044 ; 164.531 75, 0.267
0425A6 3E 00 00    0675*  	dl 0x00003E ; 165.938 76, 0.243
0425A9 38 00 00    0676*  	dl 0x000038 ; 167.344 77, 0.219
0425AC 31 00 00    0677*  	dl 0x000031 ; 168.750 78, 0.195
0425AF 2B 00 00    0678*  	dl 0x00002B ; 170.156 79, 0.171
0425B2 25 00 00    0679*  	dl 0x000025 ; 171.563 7A, 0.147
0425B5 1F 00 00    0680*  	dl 0x00001F ; 172.969 7B, 0.122
0425B8 19 00 00    0681*  	dl 0x000019 ; 174.375 7C, 0.098
0425BB 12 00 00    0682*  	dl 0x000012 ; 175.781 7D, 0.074
0425BE 0C 00 00    0683*  	dl 0x00000C ; 177.188 7E, 0.049
0425C1 06 00 00    0684*  	dl 0x000006 ; 178.594 7F, 0.025
0425C4 00 00 00    0685*  	dl 0x000000 ; 180.000 80, 0.000
0425C7 FA FF FF    0686*  	dl 0xFFFFFA ; 181.406 81, -0.025
0425CA F4 FF FF    0687*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0425CD EE FF FF    0688*  	dl 0xFFFFEE ; 184.219 83, -0.074
0425D0 E7 FF FF    0689*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0425D3 E1 FF FF    0690*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0425D6 DB FF FF    0691*  	dl 0xFFFFDB ; 188.438 86, -0.147
0425D9 D5 FF FF    0692*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0425DC CF FF FF    0693*  	dl 0xFFFFCF ; 191.250 88, -0.195
0425DF C8 FF FF    0694*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0425E2 C2 FF FF    0695*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0425E5 BC FF FF    0696*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0425E8 B6 FF FF    0697*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0425EB B0 FF FF    0698*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0425EE AA FF FF    0699*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0425F1 A4 FF FF    0700*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0425F4 9F FF FF    0701*  	dl 0xFFFF9F ; 202.500 90, -0.383
0425F7 99 FF FF    0702*  	dl 0xFFFF99 ; 203.906 91, -0.405
0425FA 93 FF FF    0703*  	dl 0xFFFF93 ; 205.313 92, -0.428
0425FD 8D FF FF    0704*  	dl 0xFFFF8D ; 206.719 93, -0.450
042600 88 FF FF    0705*  	dl 0xFFFF88 ; 208.125 94, -0.471
042603 82 FF FF    0706*  	dl 0xFFFF82 ; 209.531 95, -0.493
042606 7D FF FF    0707*  	dl 0xFFFF7D ; 210.938 96, -0.514
042609 78 FF FF    0708*  	dl 0xFFFF78 ; 212.344 97, -0.535
04260C 72 FF FF    0709*  	dl 0xFFFF72 ; 213.750 98, -0.556
04260F 6D FF FF    0710*  	dl 0xFFFF6D ; 215.156 99, -0.576
042612 68 FF FF    0711*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042615 63 FF FF    0712*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042618 5E FF FF    0713*  	dl 0xFFFF5E ; 219.375 9C, -0.634
04261B 59 FF FF    0714*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04261E 55 FF FF    0715*  	dl 0xFFFF55 ; 222.188 9E, -0.672
042621 50 FF FF    0716*  	dl 0xFFFF50 ; 223.594 9F, -0.690
042624 4B FF FF    0717*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042627 47 FF FF    0718*  	dl 0xFFFF47 ; 226.406 A1, -0.724
04262A 43 FF FF    0719*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04262D 3F FF FF    0720*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042630 3B FF FF    0721*  	dl 0xFFFF3B ; 230.625 A4, -0.773
042633 37 FF FF    0722*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042636 33 FF FF    0723*  	dl 0xFFFF33 ; 233.438 A6, -0.803
042639 2F FF FF    0724*  	dl 0xFFFF2F ; 234.844 A7, -0.818
04263C 2C FF FF    0725*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04263F 28 FF FF    0726*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042642 25 FF FF    0727*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042645 22 FF FF    0728*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042648 1F FF FF    0729*  	dl 0xFFFF1F ; 241.875 AC, -0.882
04264B 1C FF FF    0730*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04264E 19 FF FF    0731*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042651 16 FF FF    0732*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042654 14 FF FF    0733*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042657 12 FF FF    0734*  	dl 0xFFFF12 ; 248.906 B1, -0.933
04265A 0F FF FF    0735*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04265D 0D FF FF    0736*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042660 0C FF FF    0737*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042663 0A FF FF    0738*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042666 08 FF FF    0739*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042669 07 FF FF    0740*  	dl 0xFFFF07 ; 257.344 B7, -0.976
04266C 05 FF FF    0741*  	dl 0xFFFF05 ; 258.750 B8, -0.981
04266F 04 FF FF    0742*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042672 03 FF FF    0743*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042675 02 FF FF    0744*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042678 02 FF FF    0745*  	dl 0xFFFF02 ; 264.375 BC, -0.995
04267B 01 FF FF    0746*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04267E 01 FF FF    0747*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042681 01 FF FF    0748*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042684 00 FF FF    0749*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042687 01 FF FF    0750*  	dl 0xFFFF01 ; 271.406 C1, -1.000
04268A 01 FF FF    0751*  	dl 0xFFFF01 ; 272.813 C2, -0.999
04268D 01 FF FF    0752*  	dl 0xFFFF01 ; 274.219 C3, -0.997
042690 02 FF FF    0753*  	dl 0xFFFF02 ; 275.625 C4, -0.995
042693 02 FF FF    0754*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042696 03 FF FF    0755*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042699 04 FF FF    0756*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04269C 05 FF FF    0757*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04269F 07 FF FF    0758*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0426A2 08 FF FF    0759*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0426A5 0A FF FF    0760*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0426A8 0C FF FF    0761*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0426AB 0D FF FF    0762*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0426AE 0F FF FF    0763*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0426B1 12 FF FF    0764*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0426B4 14 FF FF    0765*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0426B7 16 FF FF    0766*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0426BA 19 FF FF    0767*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0426BD 1C FF FF    0768*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0426C0 1F FF FF    0769*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0426C3 22 FF FF    0770*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0426C6 25 FF FF    0771*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0426C9 28 FF FF    0772*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0426CC 2C FF FF    0773*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0426CF 2F FF FF    0774*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0426D2 33 FF FF    0775*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0426D5 37 FF FF    0776*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0426D8 3B FF FF    0777*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0426DB 3F FF FF    0778*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0426DE 43 FF FF    0779*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0426E1 47 FF FF    0780*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0426E4 4B FF FF    0781*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0426E7 50 FF FF    0782*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0426EA 55 FF FF    0783*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0426ED 59 FF FF    0784*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0426F0 5E FF FF    0785*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0426F3 63 FF FF    0786*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0426F6 68 FF FF    0787*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0426F9 6D FF FF    0788*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0426FC 72 FF FF    0789*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0426FF 78 FF FF    0790*  	dl 0xFFFF78 ; 327.656 E9, -0.535
042702 7D FF FF    0791*  	dl 0xFFFF7D ; 329.063 EA, -0.514
042705 82 FF FF    0792*  	dl 0xFFFF82 ; 330.469 EB, -0.493
042708 88 FF FF    0793*  	dl 0xFFFF88 ; 331.875 EC, -0.471
04270B 8D FF FF    0794*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04270E 93 FF FF    0795*  	dl 0xFFFF93 ; 334.688 EE, -0.428
042711 99 FF FF    0796*  	dl 0xFFFF99 ; 336.094 EF, -0.405
042714 9F FF FF    0797*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042717 A4 FF FF    0798*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
04271A AA FF FF    0799*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04271D B0 FF FF    0800*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042720 B6 FF FF    0801*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
042723 BC FF FF    0802*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042726 C2 FF FF    0803*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042729 C8 FF FF    0804*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04272C CF FF FF    0805*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04272F D5 FF FF    0806*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
042732 DB FF FF    0807*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042735 E1 FF FF    0808*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
042738 E7 FF FF    0809*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
04273B EE FF FF    0810*  	dl 0xFFFFEE ; 355.781 FD, -0.074
04273E F4 FF FF    0811*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042741 FA FF FF    0812*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042744             0813*  
042744             0814*  atan_lut_168:
042744 00 00 00    0815*  	dl 0x000000 ; 000000, 0.000
042747 28 00 00    0816*  	dl 0x000028 ; 000001, 0.224
04274A 51 00 00    0817*  	dl 0x000051 ; 000002, 0.448
04274D 7A 00 00    0818*  	dl 0x00007A ; 000003, 0.671
042750 A2 00 00    0819*  	dl 0x0000A2 ; 000004, 0.895
042753 CB 00 00    0820*  	dl 0x0000CB ; 000005, 1.119
042756 F4 00 00    0821*  	dl 0x0000F4 ; 000006, 1.343
042759 1D 01 00    0822*  	dl 0x00011D ; 000007, 1.566
04275C 45 01 00    0823*  	dl 0x000145 ; 000008, 1.790
04275F 6E 01 00    0824*  	dl 0x00016E ; 000009, 2.013
042762 97 01 00    0825*  	dl 0x000197 ; 00000A, 2.237
042765 BF 01 00    0826*  	dl 0x0001BF ; 00000B, 2.460
042768 E8 01 00    0827*  	dl 0x0001E8 ; 00000C, 2.684
04276B 11 02 00    0828*  	dl 0x000211 ; 00000D, 2.907
04276E 39 02 00    0829*  	dl 0x000239 ; 00000E, 3.130
042771 62 02 00    0830*  	dl 0x000262 ; 00000F, 3.353
042774 8B 02 00    0831*  	dl 0x00028B ; 000010, 3.576
042777 B3 02 00    0832*  	dl 0x0002B3 ; 000011, 3.799
04277A DC 02 00    0833*  	dl 0x0002DC ; 000012, 4.022
04277D 04 03 00    0834*  	dl 0x000304 ; 000013, 4.245
042780 2D 03 00    0835*  	dl 0x00032D ; 000014, 4.467
042783 55 03 00    0836*  	dl 0x000355 ; 000015, 4.690
042786 7E 03 00    0837*  	dl 0x00037E ; 000016, 4.912
042789 A6 03 00    0838*  	dl 0x0003A6 ; 000017, 5.134
04278C CE 03 00    0839*  	dl 0x0003CE ; 000018, 5.356
04278F F7 03 00    0840*  	dl 0x0003F7 ; 000019, 5.578
042792 1F 04 00    0841*  	dl 0x00041F ; 00001A, 5.799
042795 48 04 00    0842*  	dl 0x000448 ; 00001B, 6.021
042798 70 04 00    0843*  	dl 0x000470 ; 00001C, 6.242
04279B 98 04 00    0844*  	dl 0x000498 ; 00001D, 6.463
04279E C0 04 00    0845*  	dl 0x0004C0 ; 00001E, 6.684
0427A1 E8 04 00    0846*  	dl 0x0004E8 ; 00001F, 6.905
0427A4 11 05 00    0847*  	dl 0x000511 ; 000020, 7.125
0427A7 39 05 00    0848*  	dl 0x000539 ; 000021, 7.345
0427AA 61 05 00    0849*  	dl 0x000561 ; 000022, 7.565
0427AD 89 05 00    0850*  	dl 0x000589 ; 000023, 7.785
0427B0 B1 05 00    0851*  	dl 0x0005B1 ; 000024, 8.005
0427B3 D9 05 00    0852*  	dl 0x0005D9 ; 000025, 8.224
0427B6 01 06 00    0853*  	dl 0x000601 ; 000026, 8.443
0427B9 28 06 00    0854*  	dl 0x000628 ; 000027, 8.662
0427BC 50 06 00    0855*  	dl 0x000650 ; 000028, 8.881
0427BF 78 06 00    0856*  	dl 0x000678 ; 000029, 9.099
0427C2 A0 06 00    0857*  	dl 0x0006A0 ; 00002A, 9.317
0427C5 C7 06 00    0858*  	dl 0x0006C7 ; 00002B, 9.535
0427C8 EF 06 00    0859*  	dl 0x0006EF ; 00002C, 9.752
0427CB 16 07 00    0860*  	dl 0x000716 ; 00002D, 9.970
0427CE 3E 07 00    0861*  	dl 0x00073E ; 00002E, 10.187
0427D1 65 07 00    0862*  	dl 0x000765 ; 00002F, 10.403
0427D4 8D 07 00    0863*  	dl 0x00078D ; 000030, 10.620
0427D7 B4 07 00    0864*  	dl 0x0007B4 ; 000031, 10.836
0427DA DB 07 00    0865*  	dl 0x0007DB ; 000032, 11.051
0427DD 03 08 00    0866*  	dl 0x000803 ; 000033, 11.267
0427E0 2A 08 00    0867*  	dl 0x00082A ; 000034, 11.482
0427E3 51 08 00    0868*  	dl 0x000851 ; 000035, 11.697
0427E6 78 08 00    0869*  	dl 0x000878 ; 000036, 11.911
0427E9 9F 08 00    0870*  	dl 0x00089F ; 000037, 12.125
0427EC C6 08 00    0871*  	dl 0x0008C6 ; 000038, 12.339
0427EF ED 08 00    0872*  	dl 0x0008ED ; 000039, 12.553
0427F2 13 09 00    0873*  	dl 0x000913 ; 00003A, 12.766
0427F5 3A 09 00    0874*  	dl 0x00093A ; 00003B, 12.978
0427F8 61 09 00    0875*  	dl 0x000961 ; 00003C, 13.191
0427FB 87 09 00    0876*  	dl 0x000987 ; 00003D, 13.403
0427FE AE 09 00    0877*  	dl 0x0009AE ; 00003E, 13.614
042801 D4 09 00    0878*  	dl 0x0009D4 ; 00003F, 13.825
042804 FB 09 00    0879*  	dl 0x0009FB ; 000040, 14.036
042807 21 0A 00    0880*  	dl 0x000A21 ; 000041, 14.247
04280A 47 0A 00    0881*  	dl 0x000A47 ; 000042, 14.457
04280D 6D 0A 00    0882*  	dl 0x000A6D ; 000043, 14.666
042810 94 0A 00    0883*  	dl 0x000A94 ; 000044, 14.876
042813 BA 0A 00    0884*  	dl 0x000ABA ; 000045, 15.085
042816 E0 0A 00    0885*  	dl 0x000AE0 ; 000046, 15.293
042819 05 0B 00    0886*  	dl 0x000B05 ; 000047, 15.501
04281C 2B 0B 00    0887*  	dl 0x000B2B ; 000048, 15.709
04281F 51 0B 00    0888*  	dl 0x000B51 ; 000049, 15.916
042822 77 0B 00    0889*  	dl 0x000B77 ; 00004A, 16.123
042825 9C 0B 00    0890*  	dl 0x000B9C ; 00004B, 16.329
042828 C2 0B 00    0891*  	dl 0x000BC2 ; 00004C, 16.535
04282B E7 0B 00    0892*  	dl 0x000BE7 ; 00004D, 16.740
04282E 0C 0C 00    0893*  	dl 0x000C0C ; 00004E, 16.945
042831 32 0C 00    0894*  	dl 0x000C32 ; 00004F, 17.150
042834 57 0C 00    0895*  	dl 0x000C57 ; 000050, 17.354
042837 7C 0C 00    0896*  	dl 0x000C7C ; 000051, 17.558
04283A A1 0C 00    0897*  	dl 0x000CA1 ; 000052, 17.761
04283D C6 0C 00    0898*  	dl 0x000CC6 ; 000053, 17.964
042840 EB 0C 00    0899*  	dl 0x000CEB ; 000054, 18.166
042843 0F 0D 00    0900*  	dl 0x000D0F ; 000055, 18.368
042846 34 0D 00    0901*  	dl 0x000D34 ; 000056, 18.569
042849 58 0D 00    0902*  	dl 0x000D58 ; 000057, 18.770
04284C 7D 0D 00    0903*  	dl 0x000D7D ; 000058, 18.970
04284F A1 0D 00    0904*  	dl 0x000DA1 ; 000059, 19.170
042852 C6 0D 00    0905*  	dl 0x000DC6 ; 00005A, 19.370
042855 EA 0D 00    0906*  	dl 0x000DEA ; 00005B, 19.569
042858 0E 0E 00    0907*  	dl 0x000E0E ; 00005C, 19.767
04285B 32 0E 00    0908*  	dl 0x000E32 ; 00005D, 19.965
04285E 56 0E 00    0909*  	dl 0x000E56 ; 00005E, 20.163
042861 7A 0E 00    0910*  	dl 0x000E7A ; 00005F, 20.360
042864 9E 0E 00    0911*  	dl 0x000E9E ; 000060, 20.556
042867 C1 0E 00    0912*  	dl 0x000EC1 ; 000061, 20.752
04286A E5 0E 00    0913*  	dl 0x000EE5 ; 000062, 20.947
04286D 08 0F 00    0914*  	dl 0x000F08 ; 000063, 21.142
042870 2C 0F 00    0915*  	dl 0x000F2C ; 000064, 21.337
042873 4F 0F 00    0916*  	dl 0x000F4F ; 000065, 21.531
042876 72 0F 00    0917*  	dl 0x000F72 ; 000066, 21.724
042879 95 0F 00    0918*  	dl 0x000F95 ; 000067, 21.917
04287C B8 0F 00    0919*  	dl 0x000FB8 ; 000068, 22.109
04287F DB 0F 00    0920*  	dl 0x000FDB ; 000069, 22.301
042882 FE 0F 00    0921*  	dl 0x000FFE ; 00006A, 22.493
042885 21 10 00    0922*  	dl 0x001021 ; 00006B, 22.683
042888 44 10 00    0923*  	dl 0x001044 ; 00006C, 22.874
04288B 66 10 00    0924*  	dl 0x001066 ; 00006D, 23.063
04288E 89 10 00    0925*  	dl 0x001089 ; 00006E, 23.253
042891 AB 10 00    0926*  	dl 0x0010AB ; 00006F, 23.441
042894 CD 10 00    0927*  	dl 0x0010CD ; 000070, 23.629
042897 EF 10 00    0928*  	dl 0x0010EF ; 000071, 23.817
04289A 11 11 00    0929*  	dl 0x001111 ; 000072, 24.004
04289D 33 11 00    0930*  	dl 0x001133 ; 000073, 24.191
0428A0 55 11 00    0931*  	dl 0x001155 ; 000074, 24.376
0428A3 77 11 00    0932*  	dl 0x001177 ; 000075, 24.562
0428A6 99 11 00    0933*  	dl 0x001199 ; 000076, 24.747
0428A9 BA 11 00    0934*  	dl 0x0011BA ; 000077, 24.931
0428AC DC 11 00    0935*  	dl 0x0011DC ; 000078, 25.115
0428AF FD 11 00    0936*  	dl 0x0011FD ; 000079, 25.298
0428B2 1E 12 00    0937*  	dl 0x00121E ; 00007A, 25.481
0428B5 3F 12 00    0938*  	dl 0x00123F ; 00007B, 25.663
0428B8 60 12 00    0939*  	dl 0x001260 ; 00007C, 25.844
0428BB 81 12 00    0940*  	dl 0x001281 ; 00007D, 26.025
0428BE A2 12 00    0941*  	dl 0x0012A2 ; 00007E, 26.206
0428C1 C3 12 00    0942*  	dl 0x0012C3 ; 00007F, 26.386
0428C4 E4 12 00    0943*  	dl 0x0012E4 ; 000080, 26.565
0428C7 04 13 00    0944*  	dl 0x001304 ; 000081, 26.744
0428CA 25 13 00    0945*  	dl 0x001325 ; 000082, 26.922
0428CD 45 13 00    0946*  	dl 0x001345 ; 000083, 27.100
0428D0 65 13 00    0947*  	dl 0x001365 ; 000084, 27.277
0428D3 85 13 00    0948*  	dl 0x001385 ; 000085, 27.453
0428D6 A5 13 00    0949*  	dl 0x0013A5 ; 000086, 27.629
0428D9 C5 13 00    0950*  	dl 0x0013C5 ; 000087, 27.805
0428DC E5 13 00    0951*  	dl 0x0013E5 ; 000088, 27.979
0428DF 05 14 00    0952*  	dl 0x001405 ; 000089, 28.154
0428E2 24 14 00    0953*  	dl 0x001424 ; 00008A, 28.327
0428E5 44 14 00    0954*  	dl 0x001444 ; 00008B, 28.501
0428E8 63 14 00    0955*  	dl 0x001463 ; 00008C, 28.673
0428EB 83 14 00    0956*  	dl 0x001483 ; 00008D, 28.845
0428EE A2 14 00    0957*  	dl 0x0014A2 ; 00008E, 29.017
0428F1 C1 14 00    0958*  	dl 0x0014C1 ; 00008F, 29.187
0428F4 E0 14 00    0959*  	dl 0x0014E0 ; 000090, 29.358
0428F7 FF 14 00    0960*  	dl 0x0014FF ; 000091, 29.527
0428FA 1E 15 00    0961*  	dl 0x00151E ; 000092, 29.697
0428FD 3C 15 00    0962*  	dl 0x00153C ; 000093, 29.865
042900 5B 15 00    0963*  	dl 0x00155B ; 000094, 30.033
042903 79 15 00    0964*  	dl 0x001579 ; 000095, 30.201
042906 98 15 00    0965*  	dl 0x001598 ; 000096, 30.368
042909 B6 15 00    0966*  	dl 0x0015B6 ; 000097, 30.534
04290C D4 15 00    0967*  	dl 0x0015D4 ; 000098, 30.700
04290F F2 15 00    0968*  	dl 0x0015F2 ; 000099, 30.865
042912 10 16 00    0969*  	dl 0x001610 ; 00009A, 31.030
042915 2E 16 00    0970*  	dl 0x00162E ; 00009B, 31.194
042918 4C 16 00    0971*  	dl 0x00164C ; 00009C, 31.357
04291B 6A 16 00    0972*  	dl 0x00166A ; 00009D, 31.520
04291E 87 16 00    0973*  	dl 0x001687 ; 00009E, 31.682
042921 A5 16 00    0974*  	dl 0x0016A5 ; 00009F, 31.844
042924 C2 16 00    0975*  	dl 0x0016C2 ; 0000A0, 32.005
042927 DF 16 00    0976*  	dl 0x0016DF ; 0000A1, 32.166
04292A FC 16 00    0977*  	dl 0x0016FC ; 0000A2, 32.326
04292D 19 17 00    0978*  	dl 0x001719 ; 0000A3, 32.486
042930 36 17 00    0979*  	dl 0x001736 ; 0000A4, 32.645
042933 53 17 00    0980*  	dl 0x001753 ; 0000A5, 32.803
042936 70 17 00    0981*  	dl 0x001770 ; 0000A6, 32.961
042939 8C 17 00    0982*  	dl 0x00178C ; 0000A7, 33.118
04293C A9 17 00    0983*  	dl 0x0017A9 ; 0000A8, 33.275
04293F C5 17 00    0984*  	dl 0x0017C5 ; 0000A9, 33.431
042942 E2 17 00    0985*  	dl 0x0017E2 ; 0000AA, 33.587
042945 FE 17 00    0986*  	dl 0x0017FE ; 0000AB, 33.742
042948 1A 18 00    0987*  	dl 0x00181A ; 0000AC, 33.896
04294B 36 18 00    0988*  	dl 0x001836 ; 0000AD, 34.050
04294E 52 18 00    0989*  	dl 0x001852 ; 0000AE, 34.203
042951 6E 18 00    0990*  	dl 0x00186E ; 0000AF, 34.356
042954 8A 18 00    0991*  	dl 0x00188A ; 0000B0, 34.509
042957 A5 18 00    0992*  	dl 0x0018A5 ; 0000B1, 34.660
04295A C1 18 00    0993*  	dl 0x0018C1 ; 0000B2, 34.811
04295D DC 18 00    0994*  	dl 0x0018DC ; 0000B3, 34.962
042960 F7 18 00    0995*  	dl 0x0018F7 ; 0000B4, 35.112
042963 13 19 00    0996*  	dl 0x001913 ; 0000B5, 35.262
042966 2E 19 00    0997*  	dl 0x00192E ; 0000B6, 35.410
042969 49 19 00    0998*  	dl 0x001949 ; 0000B7, 35.559
04296C 64 19 00    0999*  	dl 0x001964 ; 0000B8, 35.707
04296F 7F 19 00    1000*  	dl 0x00197F ; 0000B9, 35.854
042972 99 19 00    1001*  	dl 0x001999 ; 0000BA, 36.001
042975 B4 19 00    1002*  	dl 0x0019B4 ; 0000BB, 36.147
042978 CE 19 00    1003*  	dl 0x0019CE ; 0000BC, 36.293
04297B E9 19 00    1004*  	dl 0x0019E9 ; 0000BD, 36.438
04297E 03 1A 00    1005*  	dl 0x001A03 ; 0000BE, 36.582
042981 1D 1A 00    1006*  	dl 0x001A1D ; 0000BF, 36.726
042984 37 1A 00    1007*  	dl 0x001A37 ; 0000C0, 36.870
042987 51 1A 00    1008*  	dl 0x001A51 ; 0000C1, 37.013
04298A 6B 1A 00    1009*  	dl 0x001A6B ; 0000C2, 37.155
04298D 85 1A 00    1010*  	dl 0x001A85 ; 0000C3, 37.297
042990 9F 1A 00    1011*  	dl 0x001A9F ; 0000C4, 37.439
042993 B9 1A 00    1012*  	dl 0x001AB9 ; 0000C5, 37.579
042996 D2 1A 00    1013*  	dl 0x001AD2 ; 0000C6, 37.720
042999 EC 1A 00    1014*  	dl 0x001AEC ; 0000C7, 37.859
04299C 05 1B 00    1015*  	dl 0x001B05 ; 0000C8, 37.999
04299F 1E 1B 00    1016*  	dl 0x001B1E ; 0000C9, 38.137
0429A2 37 1B 00    1017*  	dl 0x001B37 ; 0000CA, 38.276
0429A5 50 1B 00    1018*  	dl 0x001B50 ; 0000CB, 38.413
0429A8 69 1B 00    1019*  	dl 0x001B69 ; 0000CC, 38.550
0429AB 82 1B 00    1020*  	dl 0x001B82 ; 0000CD, 38.687
0429AE 9B 1B 00    1021*  	dl 0x001B9B ; 0000CE, 38.823
0429B1 B4 1B 00    1022*  	dl 0x001BB4 ; 0000CF, 38.959
0429B4 CC 1B 00    1023*  	dl 0x001BCC ; 0000D0, 39.094
0429B7 E5 1B 00    1024*  	dl 0x001BE5 ; 0000D1, 39.228
0429BA FD 1B 00    1025*  	dl 0x001BFD ; 0000D2, 39.362
0429BD 16 1C 00    1026*  	dl 0x001C16 ; 0000D3, 39.496
0429C0 2E 1C 00    1027*  	dl 0x001C2E ; 0000D4, 39.629
0429C3 46 1C 00    1028*  	dl 0x001C46 ; 0000D5, 39.762
0429C6 5E 1C 00    1029*  	dl 0x001C5E ; 0000D6, 39.894
0429C9 76 1C 00    1030*  	dl 0x001C76 ; 0000D7, 40.025
0429CC 8E 1C 00    1031*  	dl 0x001C8E ; 0000D8, 40.156
0429CF A5 1C 00    1032*  	dl 0x001CA5 ; 0000D9, 40.286
0429D2 BD 1C 00    1033*  	dl 0x001CBD ; 0000DA, 40.416
0429D5 D5 1C 00    1034*  	dl 0x001CD5 ; 0000DB, 40.546
0429D8 EC 1C 00    1035*  	dl 0x001CEC ; 0000DC, 40.675
0429DB 04 1D 00    1036*  	dl 0x001D04 ; 0000DD, 40.803
0429DE 1B 1D 00    1037*  	dl 0x001D1B ; 0000DE, 40.931
0429E1 32 1D 00    1038*  	dl 0x001D32 ; 0000DF, 41.059
0429E4 49 1D 00    1039*  	dl 0x001D49 ; 0000E0, 41.186
0429E7 60 1D 00    1040*  	dl 0x001D60 ; 0000E1, 41.312
0429EA 77 1D 00    1041*  	dl 0x001D77 ; 0000E2, 41.438
0429ED 8E 1D 00    1042*  	dl 0x001D8E ; 0000E3, 41.564
0429F0 A5 1D 00    1043*  	dl 0x001DA5 ; 0000E4, 41.689
0429F3 BB 1D 00    1044*  	dl 0x001DBB ; 0000E5, 41.814
0429F6 D2 1D 00    1045*  	dl 0x001DD2 ; 0000E6, 41.938
0429F9 E9 1D 00    1046*  	dl 0x001DE9 ; 0000E7, 42.061
0429FC FF 1D 00    1047*  	dl 0x001DFF ; 0000E8, 42.184
0429FF 15 1E 00    1048*  	dl 0x001E15 ; 0000E9, 42.307
042A02 2C 1E 00    1049*  	dl 0x001E2C ; 0000EA, 42.429
042A05 42 1E 00    1050*  	dl 0x001E42 ; 0000EB, 42.551
042A08 58 1E 00    1051*  	dl 0x001E58 ; 0000EC, 42.672
042A0B 6E 1E 00    1052*  	dl 0x001E6E ; 0000ED, 42.793
042A0E 84 1E 00    1053*  	dl 0x001E84 ; 0000EE, 42.913
042A11 99 1E 00    1054*  	dl 0x001E99 ; 0000EF, 43.033
042A14 AF 1E 00    1055*  	dl 0x001EAF ; 0000F0, 43.152
042A17 C5 1E 00    1056*  	dl 0x001EC5 ; 0000F1, 43.271
042A1A DA 1E 00    1057*  	dl 0x001EDA ; 0000F2, 43.390
042A1D F0 1E 00    1058*  	dl 0x001EF0 ; 0000F3, 43.508
042A20 05 1F 00    1059*  	dl 0x001F05 ; 0000F4, 43.625
042A23 1B 1F 00    1060*  	dl 0x001F1B ; 0000F5, 43.742
042A26 30 1F 00    1061*  	dl 0x001F30 ; 0000F6, 43.859
042A29 45 1F 00    1062*  	dl 0x001F45 ; 0000F7, 43.975
042A2C 5A 1F 00    1063*  	dl 0x001F5A ; 0000F8, 44.091
042A2F 6F 1F 00    1064*  	dl 0x001F6F ; 0000F9, 44.206
042A32 84 1F 00    1065*  	dl 0x001F84 ; 0000FA, 44.321
042A35 99 1F 00    1066*  	dl 0x001F99 ; 0000FB, 44.435
042A38 AD 1F 00    1067*  	dl 0x001FAD ; 0000FC, 44.549
042A3B C2 1F 00    1068*  	dl 0x001FC2 ; 0000FD, 44.662
042A3E D7 1F 00    1069*  	dl 0x001FD7 ; 0000FE, 44.775
042A41 EB 1F 00    1070*  	dl 0x001FEB ; 0000FF, 44.888
042A44 00 20 00    1071*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042A47             0060   	include "fixed24.inc"
042A47             0001*  arith24uaf: ds 6
042A4D             0002*  arith24uhl: ds 6
042A53             0003*  arith24ubc: ds 6
042A59             0004*  arith24ude: ds 6
042A5F             0005*  arith24uix: ds 6
042A65             0006*  arith24uiy: ds 6
042A6B             0007*  arith24usp: ds 6
042A71             0008*  arith24upc: ds 6
042A77             0009*  
042A77             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042A77             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042A77             0012*  ; inputs: hlu = 24-bit number to shift
042A77             0013*  ;         a = signed number of bits to shift
042A77             0014*  ;         ix = output buffer address
042A77             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042A77             0016*  shift_hlu:
042A77 C5          0017*      push bc ; preserve
042A78 47          0018*      ld b,a            ; store shift value in b for later
042A79             0019*  
042A79             0020*  ; Initialize DE to zero and clear output buffer
042A79 11 00 00 00 0021*      ld de, 0
042A7D DD 1F FD    0022*      ld (ix-3), de
042A80 DD 1F 03    0023*      ld (ix+3), de
042A83             0024*  
042A83             0025*  ; Get absolute value of a and save its original sign
042A83 B7          0026*      or a
042A84 F5          0027*      push af ; save sign flag
042A85 F2 8B 2A 04 0028*      jp p,@F ; If a is positive do nothing
042A89 ED 44       0029*      neg ; If a is negative, negate it
042A8B             0030*  @@:
042A8B             0031*  
042A8B             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042A8B CD 31 21 04 0033*      call hlu_abs
042A8F F5          0034*      push af ; save sign of HLU
042A90 DD 2F 00    0035*      ld (ix), hl
042A93             0036*  
042A93             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042A93 78          0038*      ld a,b            ; Restore original shift value into 'a'
042A94 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042A96 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042A98 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042A9A 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042A9B             0043*  
042A9B             0044*  ; Calculate remainder of a (original shift) mod 8
042A9B E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042A9D 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042A9E 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042AA2             0048*  
042AA2             0049*      ; call dumpRegistersHex ; DEBUG
042AA2             0050*  
042AA2             0051*  ; Get back the original sign of the byte shift
042AA2 F1          0052*      pop af            ; Restore sign flag
042AA3 F2 B1 2A 04 0053*      jp p,@F           ; If a was positive, we're done
042AA7 79          0054*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042AA8 ED 44       0055*      neg               ; Negate the number of whole bytes to shift
042AAA 3D          0056*      dec a             ; Subtract 1 because that's just how this works
042AAB 4F          0057*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042AAC 1B          0058*      dec de            ; DE = -1 to make the signed addition below work
042AAD 3E 08       0059*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042AAF 90          0060*      sub b
042AB0 47          0061*      ld b,a            ; b is the number of bits to shift back up
042AB1             0062*  
042AB1             0063*      ; call dumpRegistersHex ; DEBUG
042AB1             0064*  
042AB1             0065*  @@:
042AB1             0066*  
042AB1             0067*  ; Add the byte offset to the base address of output buffer
042AB1 59          0068*      ld e,c            ; DEU and D were properly signed above
042AB2 DD 19       0069*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042AB4             0070*  
042AB4             0071*      ; call dumpRegistersHex ; DEBUG
042AB4             0072*  
042AB4             0073*  ; Read the byte-aligned result into HL and shift in the required number of bits
042AB4 DD 27 00    0074*      ld hl,(ix)        ; Byte-aligned result
042AB7             0075*  
042AB7 CD 04 19 04 0076*      call dumpRegistersHex ; DEBUG
042ABB             0077*  
042ABB             0078*  ; Check whether we're already byte-aligned
042ABB AF          0079*      xor a
042ABC B0          0080*      or b
042ABD 28 10       0081*      jr z,@end         ; If no bits to shift, we're done
042ABF             0082*  
042ABF             0083*  ; Otherwise shiften zee bitzen
042ABF DD 7E FF    0084*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042AC2             0085*  @loop:
042AC2 07          0086*      rlca              ; One bit to carry
042AC3             0087*  
042AC3 CD 49 1A 04 0088*      call dumpFlags ; DEBUG
042AC7             0089*  
042AC7 ED 6A       0090*      adc hl,hl         ; Shift the carry into the result
042AC9             0091*  
042AC9 CD 04 19 04 0092*      call dumpRegistersHex ; DEBUG
042ACD             0093*  
042ACD 10 F3       0094*      djnz @loop        ; Loop until all bits are shifted up
042ACF             0095*  
042ACF             0096*  @end:
042ACF             0097*  
042ACF CD 04 19 04 0098*      call dumpRegistersHex ; DEBUG
042AD3             0099*  
042AD3             0100*  ; get back HLU's original sign and negate if necessary
042AD3 F1          0101*      pop af
042AD4 F2 DC 2A 04 0102*      jp p,@F
042AD8 CD 41 21 04 0103*      call neg_hlu
042ADC             0104*  @@:
042ADC             0105*  ; return the result
042ADC DD 2F 00    0106*      ld (ix),hl        ; Store the shifted result
042ADF C1          0107*      pop bc              ; Restore BC
042AE0 C9          0108*      ret
042AE1             0109*  
042AE1             0110*  ; operation: UHL * UDE --> UHL
042AE1             0111*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042AE1             0112*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042AE1             0113*  ; inputs: hl = 24-bit number, de = 24-bit number,
042AE1             0114*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042AE1             0115*  ; outputs: umulfxout = 48-bit intermediate
042AE1             0116*  ; destroys: af, hl, bc, de
042AE1             0117*  umulfx:
042AE1 DD E5       0118*      push ix ; preserve
042AE3 F5          0119*      push af ; need later
042AE4             0120*  
042AE4             0121*  ; do the multiplication
042AE4 CD A5 2B 04 0122*      call umul24x24
042AE8             0123*      ; DEBUG
042AE8 21 3A 2B 04 0124*      ld hl,umulfxout ; point to output buffer
042AEC 3E 06       0125*      ld a,6 ; 6 bytes to print
042AEE CD B9 1A 04 0126*      call dumpMemoryHex ; print the result
042AF2             0127*      ; END DEBUG
042AF2             0128*  
042AF2             0129*  ; shift the result to the required output precision
042AF2 78          0130*      ld a,b
042AF3 81          0131*      add a,c ; a is left shift from the multiplication
042AF4 C1          0132*      pop bc ; b is the output precision (was a)
042AF5 90          0133*      sub b ; a is the net shift of the output
042AF6             0134*  
042AF6             0135*  ; Get absolute value of a and save its original sign
042AF6 B7          0136*      or a
042AF7 F5          0137*      push af ; save sign flag
042AF8 F2 FE 2A 04 0138*      jp p,@F ; If a is positive do nothing
042AFC ED 44       0139*      neg ; If a is negative, negate it
042AFE             0140*  @@:
042AFE             0141*  
042AFE             0142*  ; Divide a by 8 to get the whole byte shift and bit remainder
042AFE 47          0143*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042AFF CB 3F       0144*      srl a             ; a = a / 2 (shift right 1 bit)
042B01 CB 3F       0145*      srl a             ; a = a / 4 (shift right another bit)
042B03 CB 3F       0146*      srl a             ; a = a / 8 (final shift for division by 8)
042B05 4F          0147*      ld c,a            ; c holds the number of whole bytes to shift
042B06             0148*  
042B06             0149*  ; Calculate remainder of a (original shift) mod 8
042B06 78          0150*      ld a,b            ; Restore original shift value into 'a'
042B07 E6 07       0151*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042B09 47          0152*      ld b,a            ; 'b' now holds the number of bits to shift back up
042B0A 11 00 00 00 0153*      ld de,0           ; Clear deu for computing the offset address later
042B0E             0154*  
042B0E             0155*      ; call dumpRegistersHex ; DEBUG
042B0E             0156*  
042B0E             0157*  ; Get back the original sign of the byte shift
042B0E F1          0158*      pop af            ; Restore sign flag
042B0F F2 1D 2B 04 0159*      jp p,@F           ; If a was positive, we're done
042B13 79          0160*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042B14 ED 44       0161*      neg               ; Negate the number of whole bytes to shift
042B16 3D          0162*      dec a             ; Subtract 1 because that's just how this works
042B17 4F          0163*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042B18 1B          0164*      dec de            ; DE = -1 to make the signed addition below work
042B19 3E 08       0165*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042B1B 90          0166*      sub b
042B1C 47          0167*      ld b,a            ; b is the number of bits to shift back up
042B1D             0168*  
042B1D             0169*      ; call dumpRegistersHex ; DEBUG
042B1D             0170*  
042B1D             0171*  @@:
042B1D             0172*  
042B1D             0173*  ; Add the byte offset to the base address of umulfxout
042B1D 59          0174*      ld e,c            ; DEU and D were properly signed above
042B1E DD 21 3A 2B 0175*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042B23 DD 19       0176*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042B25             0177*  
042B25             0178*      ; call dumpRegistersHex ; DEBUG
042B25             0179*  
042B25             0180*  ; Read the byte-aligned result into HL and shift in the required number of bits
042B25 DD 27 00    0181*      ld hl,(ix)        ; Byte-aligned result
042B28 DD 7E FF    0182*      ld a,(ix-1)       ; One byte below
042B2B             0183*  
042B2B             0184*  ; Check whether we're already byte-aligned
042B2B AF          0185*      xor a
042B2C B0          0186*      or b
042B2D 28 05       0187*      jr z,@end         ; If no bits to shift, we're done
042B2F             0188*  
042B2F             0189*  ; Otherwise shiften zee bitzen
042B2F             0190*  @loop:
042B2F             0191*  
042B2F             0192*      ; call dumpRegistersHex ; DEBUG
042B2F             0193*  
042B2F 07          0194*      rlca              ; One bit to carry
042B30 ED 6A       0195*      adc hl,hl         ; Shift the carry into the result
042B32             0196*  
042B32 10 FB       0197*      djnz @loop        ; Loop until all bits are shifted up
042B34             0198*  
042B34             0199*  @end:
042B34             0200*  ; return the result
042B34 DD E1       0201*      pop ix ; restore
042B36 C9          0202*      ret
042B37             0203*  
042B37 00 00 00    0204*      dl 0 ; padding
042B3A 00 00 00 00 0205*  umulfxout: blkb 6,0
       00 00       
042B40 00 00 00    0206*      dl 0 ; padding
042B43             0207*  
042B43             0208*  ; operation: UHL * UDE --> UHL
042B43             0209*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042B43             0210*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042B43             0211*  ; inputs: hl = 24-bit number, de = 24-bit number,
042B43             0212*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042B43             0213*  ; outputs: umulfxout = 48-bit intermediate
042B43             0214*  ; destroys: af, hl, bc, de
042B43             0215*  smulfx:
042B43             0216*  ; make everything positive and store sign flags
042B43 CD 31 21 04 0217*  	call hlu_abs
042B47 F5          0218*  	push af
042B48 EB          0219*  	ex de,hl
042B49 CD 31 21 04 0220*  	call hlu_abs
042B4D EB          0221*  	ex de,hl
042B4E F5          0222*  	push af
042B4F             0223*  ; do the division
042B4F CD E1 2A 04 0224*      call umulfx ; hl = product
042B53             0225*  ; adjust sign of result
042B53 F1          0226*  	pop af ; sign de
042B54 FA 5F 2B 04 0227*  	jp m,@de_neg
042B58 F1          0228*  	pop af ; sign hl
042B59 F0          0229*  	ret p ; both positive, nothing to do
042B5A             0230*  @hl_neg:
042B5A CD 41 21 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
042B5E C9          0232*      ret
042B5F             0233*  @de_neg:
042B5F F1          0234*  	pop af
042B60 F8          0235*  	ret m ; both negative, nothing to do
042B61 CD 41 21 04 0236*  	call neg_hlu ; result is negative
042B65 C9          0237*  	ret
042B66             0238*  
042B66             0239*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042B66             0240*  ; uses EZ80 MLT instruction for speed
042B66             0241*  ; operation: UHL * A --> UHL
042B66             0242*  ; destroys: AF, HL
042B66             0243*  smul24x8:
042B66             0244*  ; make hl positive and store sign flag
042B66 CD 31 21 04 0245*  	call hlu_abs
042B6A F5          0246*  	push af
042B6B             0247*  ; do the division
042B6B CD 76 2B 04 0248*      call umul24x8 ; hl = product
042B6F             0249*  ; adjust sign of result
042B6F F1          0250*  	pop af ; sign de
042B70 F0          0251*  	ret p ; hl was positive, nothing to do
042B71 CD 41 21 04 0252*  	call neg_hlu ; result is negative
042B75 C9          0253*  	ret
042B76             0254*  
042B76             0255*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042B76             0256*  ; uses EZ80 MLT instruction for speed
042B76             0257*  ; operation: UHL * A --> AUHL
042B76             0258*  ; destroys: AF, HL
042B76             0259*  umul24x8:
042B76 D5          0260*  	push de ; preserve de
042B77             0261*  ; low byte
042B77 5D          0262*  	ld e,l
042B78 57          0263*  	ld d,a
042B79 ED 5C       0264*  	mlt de
042B7B 6B          0265*  	ld l,e ; product low byte
042B7C 08          0266*  	ex af,af' ; save multiplier
042B7D 7A          0267*  	ld a,d ; carry
042B7E 08          0268*  	ex af,af' ; save carry, restore multiplier
042B7F             0269*  ; high byte
042B7F 5C          0270*  	ld e,h
042B80 57          0271*  	ld d,a
042B81 ED 5C       0272*  	mlt de
042B83 08          0273*  	ex af,af' ; save multiplier, restore carry
042B84 83          0274*  	add a,e ; add carry
042B85 67          0275*  	ld h,a ; product middle byte
042B86 7A          0276*  	ld a,d ; carry
042B87 08          0277*  	ex af,af' ; save carry, restore multiplier
042B88             0278*  ; upper byte
042B88 E5          0279*  	push hl
042B89 33          0280*  	inc sp
042B8A D1          0281*  	pop de ; d = hlu
042B8B 3B          0282*  	dec sp
042B8C 5F          0283*  	ld e,a
042B8D ED 5C       0284*  	mlt de
042B8F 08          0285*  	ex af,af' ; restore carry
042B90 8B          0286*  	adc a,e ; add carry
042B91 22 A2 2B 04 0287*      ld (@scratch),hl ; 7 cycles
042B95 32 A4 2B 04 0288*      ld (@scratch+2),a ; 5 cycles
042B99 2A A2 2B 04 0289*      ld hl,(@scratch) ; 7 cycles
042B9D             0290*  ; highest byte
042B9D 3E 00       0291*  	ld a,0 ; preserve carry flag
042B9F 8A          0292*  	adc a,d ; product highest byte
042BA0 D1          0293*  	pop de ; restore de
042BA1 C9          0294*  	ret
042BA2             0295*  @scratch: ds 3
042BA5             0296*  
042BA5             0297*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042BA5             0298*  ; operation: UHL * UDE --> umulfxout
042BA5             0299*  umul24x24:
042BA5 FD 21 3A 2B 0300*  	ld iy,umulfxout ; point to output buffer
       04          
042BAA C5          0301*  	push bc
042BAB 01 00 00 00 0302*  	ld bc,0
042BAF FD 0F 00    0303*  	ld (iy),bc
042BB2 FD 0F 03    0304*  	ld (iy+3),bc
042BB5 C1          0305*  	pop bc
042BB6             0306*  
042BB6             0307*  ; STEP 1: UHL * E
042BB6 7B          0308*  	ld a,e
042BB7 E5          0309*  	push hl
042BB8 CD 76 2B 04 0310*  	call umul24x8
042BBC FD 2F 00    0311*  	ld (iy+0),hl
042BBF FD 77 03    0312*  	ld (iy+3),a
042BC2             0313*  
042BC2             0314*  ; STEP 2: UHL * D
042BC2 E1          0315*  	pop hl
042BC3 E5          0316*  	push hl
042BC4 7A          0317*  	ld a,d
042BC5 CD 76 2B 04 0318*  	call umul24x8
042BC9 CD D6 2B 04 0319*  	call @accumulate
042BCD             0320*  
042BCD             0321*  ; STEP 3: UHL * DEU
042BCD E1          0322*  	pop hl
042BCE D5          0323*  	push de
042BCF 33          0324*  	inc sp
042BD0 F1          0325*  	pop af
042BD1 3B          0326*  	dec sp
042BD2 CD 76 2B 04 0327*  	call umul24x8
042BD6             0328*  
042BD6             0329*  @accumulate:
042BD6 FD 23       0330*  	inc iy
042BD8             0331*  ; highest byte of product to carry
042BD8 FD 77 03    0332*  	ld (iy+3),a
042BDB             0333*  ; low byte of product
042BDB 7D          0334*  	ld a,l
042BDC FD 86 00    0335*  	add a,(iy+0)
042BDF FD 77 00    0336*  	ld (iy+0),a
042BE2             0337*  ; high byte of product
042BE2 7C          0338*  	ld a,h
042BE3 FD 8E 01    0339*  	adc a,(iy+1)
042BE6 FD 77 01    0340*  	ld (iy+1),a
042BE9             0341*  ; uppper byte of product
042BE9 E5          0342*  	push hl
042BEA 33          0343*  	inc sp
042BEB E1          0344*  	pop hl
042BEC 3B          0345*  	dec sp
042BED 7C          0346*  	ld a,h
042BEE FD 8E 02    0347*  	adc a,(iy+2)
042BF1 FD 77 02    0348*  	ld (iy+2),a
042BF4             0349*  ; carry
042BF4 3E 00       0350*  	ld a,0 ; preserve flags
042BF6 FD 8E 03    0351*  	adc a,(iy+3)
042BF9 FD 77 03    0352*  	ld (iy+3),a
042BFC C9          0353*  	ret
042BFD             0354*  
042BFD             0355*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
042BFD             0356*  umul168:
042BFD CD A5 2B 04 0357*  	call umul24x24
042C01 FD 27 FF    0358*  	ld hl,(iy-1)
042C04 C9          0359*  	ret
042C05             0360*  
042C05             0361*  ; smul168:	UH.L * UD.E --> UH.L (signed)
042C05             0362*  smul168:
042C05             0363*  ; make everything positive and store sign flags
042C05 CD 31 21 04 0364*  	call hlu_abs
042C09 F5          0365*  	push af
042C0A EB          0366*  	ex de,hl
042C0B CD 31 21 04 0367*  	call hlu_abs
042C0F EB          0368*  	ex de,hl
042C10 F5          0369*  	push af
042C11             0370*  ; do the division
042C11 CD FD 2B 04 0371*      call umul168 ; hl = product
042C15             0372*  ; adjust sign of result
042C15 F1          0373*  	pop af ; sign de
042C16 FA 21 2C 04 0374*  	jp m,@de_neg
042C1A F1          0375*  	pop af ; sign hl
042C1B F0          0376*  	ret p ; both positive, nothing to do
042C1C             0377*  @hl_neg:
042C1C CD 41 21 04 0378*      call neg_hlu ; de pos, hl neg, result is negative
042C20 C9          0379*      ret
042C21             0380*  @de_neg:
042C21 F1          0381*  	pop af
042C22 F8          0382*  	ret m ; both negative, nothing to do
042C23 CD 41 21 04 0383*  	call neg_hlu ; result is negative
042C27 C9          0384*  	ret
042C28             0385*  
042C28             0386*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
042C28             0387*  ; perform unsigned division of 16.8 fixed place values
042C28             0388*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
042C28             0389*  udiv168:
042C28             0390*  ; back up divisor
042C28 ED 53 5F 2C 0391*  	ld (@ude),de
       04          
042C2D             0392*  ; get the 16-bit integer part of the quotient
042C2D CD 90 2C 04 0393*      call udiv24 ; de = quotient, hl = remainder
042C31             0394*  ; load quotient to upper three bytes of output
042C31 ED 53 66 2C 0395*      ld (div168_out+1),de
       04          
042C36             0396*  @div256:
042C36             0397*  ; multiply remainder by 256
042C36             0398*  	hlu_mul256
042C36 29          0001*M         add hl,hl ; * 2
042C37 29          0002*M         add hl,hl ; * 4
042C38 29          0003*M         add hl,hl ; * 8
042C39 29          0004*M         add hl,hl ; * 16
042C3A 29          0005*M         add hl,hl ; * 32
042C3B 29          0006*M         add hl,hl ; * 64
042C3C 29          0007*M         add hl,hl ; * 128
042C3D 29          0008*M         add hl,hl ; * 256
042C3E             0399*  ; skip fractional computation if remainder is zero
042C3E             0400*      sign_hlu
042C3E 19          0001*M         add hl,de
042C3F B7          0002*M         or a
042C40 ED 52       0003*M         sbc hl,de
042C42 20 03       0401*      jr nz,@div_frac
042C44 AF          0402*      xor a
042C45 18 0A       0403*      jr @write_frac
042C47             0404*  ; now divide the shifted remainder by the divisor
042C47             0405*  @div_frac:
042C47 ED 5B 5F 2C 0406*  	ld de,(@ude) ; get back divisor
       04          
042C4C CD 90 2C 04 0407*      call udiv24 ; de = quotient, hl = remainder
042C50             0408*  ; load low byte of quotient to low byte of output
042C50 7B          0409*      ld a,e
042C51             0410*  @write_frac:
042C51 32 65 2C 04 0411*      ld (div168_out),a
042C55             0412*  ; load de with return value
042C55 ED 5B 65 2C 0413*      ld de,(div168_out)
       04          
042C5A             0414*  ; load a with any overflow
042C5A 3A 68 2C 04 0415*      ld a,(div168_out+3)
042C5E C9          0416*      ret ; ud.e is the 16.8 result
042C5F             0417*  @ude: ds 6
042C65             0418*  div168_out: ds 4 ; the extra byte is for overflow
042C69             0419*  
042C69             0420*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
042C69             0421*  ; perform signed division of 16.8 fixed place values
042C69             0422*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
042C69             0423*  sdiv168:
042C69             0424*  ; make everything positive and store sign flags
042C69 CD 31 21 04 0425*  	call hlu_abs
042C6D F5          0426*  	push af
042C6E EB          0427*  	ex de,hl
042C6F CD 31 21 04 0428*  	call hlu_abs
042C73 EB          0429*  	ex de,hl
042C74 F5          0430*  	push af
042C75             0431*  ; do the division
042C75 CD 28 2C 04 0432*      call udiv168 ; de = quotient, hl = remainder
042C79             0433*  ; adjust sign of result
042C79 F1          0434*  	pop af ; sign de
042C7A FA 87 2C 04 0435*  	jp m,@de_neg
042C7E F1          0436*  	pop af ; sign hl
042C7F F0          0437*  	ret p ; both positive, nothing to do
042C80             0438*  @hl_neg:
042C80 EB          0439*      ex de,hl ; hl = quotient, de = remainder
042C81 CD 41 21 04 0440*      call neg_hlu ; de pos, hl neg, result is negative
042C85 EB          0441*      ex de,hl ; de = negated quotient, hl = remainder
042C86 C9          0442*      ret
042C87             0443*  @de_neg:
042C87 F1          0444*  	pop af
042C88 F8          0445*  	ret m ; both negative, nothing to do
042C89 EB          0446*      ex de,hl ; hl = quotient, de = remainder
042C8A CD 41 21 04 0447*  	call neg_hlu ; result is negative
042C8E EB          0448*      ex de,hl ; de = negated quotient, hl = remainder
042C8F C9          0449*  	ret
042C90             0450*  
042C90             0451*  ;------------------------------------------------------------------------
042C90             0452*  ;  arith24.asm
042C90             0453*  ;  24-bit ez80 arithmetic routines
042C90             0454*  ;  Copyright (c) Shawn Sijnstra 2024
042C90             0455*  ;  MIT license
042C90             0456*  ;
042C90             0457*  ;  This library was created as a tool to help make ez80
042C90             0458*  ;  24-bit native assembly routines for simple mathematical problems
042C90             0459*  ;  more widely available.
042C90             0460*  ;
042C90             0461*  ;------------------------------------------------------------------------
042C90             0462*  ;
042C90             0463*  ;------------------------------------------------------------------------
042C90             0464*  ; udiv24
042C90             0465*  ; Unsigned 24-bit division
042C90             0466*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
042C90             0467*  ;
042C90             0468*  ; Uses AF BC DE HL
042C90             0469*  ; Uses Restoring Division algorithm
042C90             0470*  ;------------------------------------------------------------------------
042C90             0471*  
042C90             0472*  udiv24:
042C90 E5          0473*  	push	hl
042C91 C1          0474*  	pop		bc	;move dividend to BCU
042C92 21 00 00 00 0475*  	ld		hl,0	;result
042C96 A7          0476*  	and		a
042C97 ED 52       0477*  	sbc		hl,de	;test for div by 0
042C99 C8          0478*  	ret		z		;it's zero, carry flag is clear
042C9A 19          0479*  	add		hl,de	;HL is 0 again
042C9B 3E 18       0480*  	ld		a,24	;number of loops through.
042C9D             0481*  udiv1:
042C9D C5          0482*  	push	bc	;complicated way of doing this because of lack of access to top bits
042C9E E3          0483*  	ex		(sp),hl
042C9F 37          0484*  	scf
042CA0 ED 6A       0485*  	adc	hl,hl
042CA2 E3          0486*  	ex	(sp),hl
042CA3 C1          0487*  	pop	bc		;we now have bc = (bc * 2) + 1
042CA4             0488*  
042CA4 ED 6A       0489*  	adc	hl,hl
042CA6 A7          0490*  	and	a		;is this the bug
042CA7 ED 52       0491*  	sbc	hl,de
042CA9 30 02       0492*  	jr	nc,udiv2
042CAB 19          0493*  	add	hl,de
042CAC             0494*  ;	dec	c
042CAC 0B          0495*  	dec	bc
042CAD             0496*  udiv2:
042CAD 3D          0497*  	dec	a
042CAE 20 ED       0498*  	jr	nz,udiv1
042CB0 37          0499*  	scf		;flag used for div0 error
042CB1 C5          0500*  	push	bc
042CB2 D1          0501*  	pop		de	;remainder
042CB3 C9          0502*  	ret
042CB4             0061   ; App-specific includes
042CB4             0062   	include "player.inc"
042CB4             0001*  ; ######## GAME STATE VARIABLES #######
042CB4             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042CB4 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042CB7             0004*  ; player current shields,binary
042CB7             0005*  ; when < 0 player splodes
042CB7             0006*  ; restores to player_max_shields when new ship spawns
042CB7 10          0007*  player_shields: db 16 ; binary
042CB8             0008*  ; max player shields,binary
042CB8             0009*  ; can increase with power-ups (todo)
042CB8 10          0010*  player_max_shields: db 16 ; binary
042CB9             0011*  ; when reaches zero,game ends
042CB9             0012*  ; can increase based on TODO
042CB9 03          0013*  player_ships: db 0x03 ; binary
042CBA             0014*  
042CBA             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042CBA             0016*  ; uses the same offsets from its table base as the main sprite table:
042CBA             0017*  player_start_variables: ; label marking beginning of table
042CBA 04          0018*  player_id:               db table_max_records
042CBB 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042CBC 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042CBF 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042CC2 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042CC3 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042CC4 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042CC5 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042CC8 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042CCB 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042CCE 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042CD1 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042CD4 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042CD7 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042CDA 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042CDB 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042CDC 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042CDD 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042CDE 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042CDF 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042CE0             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042CE0             0039*  
042CE0             0040*  ; set initial player position
042CE0             0041*  ; inputs: none,everything is hardcoded
042CE0             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042CE0             0043*  ; destroys: a
042CE0             0044*  player_init:
042CE0 3A BA 2C 04 0045*  	ld a,(player_id)
042CE4 CD C9 1F 04 0046*  	call vdu_sprite_select
042CE8 CD DC 1F 04 0047*      call vdu_sprite_clear_frames
042CEC 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042CF0 CD 16 21 04 0049*      call vdu_sprite_add_buff
042CF4 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042CF8 CD 16 21 04 0051*      call vdu_sprite_add_buff
042CFC 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042D00 CD 16 21 04 0053*      call vdu_sprite_add_buff
042D04 01 00 00 00 0054*      ld bc,0
042D08 ED 43 C5 2C 0055*      ld (player_x),bc
       04          
042D0D 11 00 DF 00 0056*      ld de,0x00DF00
042D11 ED 53 C8 2C 0057*      ld (player_y),de
       04          
042D16 CD 95 20 04 0058*      call vdu_sprite_move_abs168
042D1A CD 3F 20 04 0059*      call vdu_sprite_show
042D1E C9          0060*      ret
042D1F             0061*  
042D1F             0062*  ; process player keyboard input, set player bitmap
042D1F             0063*  ; velocities and draw player bitmap at updated coordinates
042D1F             0064*  ; Inputs: player_x/y set at desired position
042D1F             0065*  ; Returns: player bitmap drawn at updated position
042D1F             0066*  ; Destroys: probably everything except maybe iy
042D1F             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042D1F             0068*  ; TODO: requires sprite implementation
042D1F             0069*  player_input:
042D1F             0070*  ; reset player component velocities to zero as the default
042D1F 21 00 00 00 0071*  	ld hl,0
042D23 22 CB 2C 04 0072*  	ld (player_xvel),hl
042D27 22 CE 2C 04 0073*  	ld (player_yvel),hl
042D2B             0074*  ; make ship the active sprite
042D2B 3A BA 2C 04 0075*      ld a,(player_id)
042D2F CD C9 1F 04 0076*      call vdu_sprite_select
042D33             0077*  ; check for keypresses and branch accordingly
042D33             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042D33             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042D33 3E 1E       0001*M 			LD	A, function
042D35 5B CF       0002*M 			RST.LIL	08h
042D37             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042D37             0081*  ; this handles the case where two opposing movement keys
042D37             0082*  ; are down simultaneously (velocities will net to zero)
042D37             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042D37             0084*  ; it also allows movement and action keys to be detected simultaneously
042D37             0085*  ; so we can walk and chew gum at the same time
042D37 3E 01       0086*      ld a,1 ; set ship's default animation to center
042D39             0087*          ; if left and right are both down a will net to
042D39             0088*  
042D39             0089*  @left:
042D39 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042D3D 28 0E       0091*      jr z,@right
042D3F 2A CB 2C 04 0092*      ld hl,(player_xvel)
042D43 01 00 FD FF 0093*      ld bc,-speed_player
042D47 09          0094*      add hl,bc
042D48 22 CB 2C 04 0095*      ld (player_xvel),hl
042D4C 3D          0096*      dec a ; set ship's animation to left
042D4D             0097*  @right:
042D4D DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042D51 28 0E       0099*  	jr z,@up
042D53 2A CB 2C 04 0100*      ld hl,(player_xvel)
042D57 01 00 03 00 0101*      ld bc,speed_player
042D5B 09          0102*      add hl,bc
042D5C 22 CB 2C 04 0103*      ld (player_xvel),hl
042D60 3C          0104*      inc a ; set ship's animation to right
042D61             0105*  @up:
042D61 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042D65 28 0D       0107*  	jr z,@down
042D67 2A CE 2C 04 0108*      ld hl,(player_yvel)
042D6B 01 00 FD FF 0109*      ld bc,-speed_player
042D6F 09          0110*      add hl,bc
042D70 22 CE 2C 04 0111*      ld (player_yvel),hl
042D74             0112*  @down:
042D74 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042D78 28 0D       0114*  	jr z,@done_keyboard
042D7A 2A CE 2C 04 0115*      ld hl,(player_yvel)
042D7E 01 00 03 00 0116*      ld bc,speed_player
042D82 09          0117*      add hl,bc
042D83 22 CE 2C 04 0118*      ld (player_yvel),hl
042D87             0119*  @done_keyboard:
042D87             0120*  ; move player sprite according to velocities set by keypresses
042D87 2A CB 2C 04 0121*      ld hl,(player_xvel)
042D8B             0122*  ; compute new x position
042D8B ED 5B C5 2C 0123*      ld de,(player_x)
       04          
042D90 19          0124*      add hl,de ; hl = player_x + player_xvel
042D91             0125*      ; check for horizontal screen edge collisions
042D91             0126*      ; and adjust coordinate as necessary
042D91             0127*  ; TODO: make this work using 24-bit registers
042D91             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042D91             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042D91             0130*      ; ld a,8 ; set x to leftmost allowable position
042D91             0131*  ; @check_right:
042D91             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042D91             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042D91             0134*  ;     ld a,248 ; set x to rightmost allowable position
042D91             0135*  @x_ok:
042D91             0136*  ; save the updated drawing coordinate
042D91 22 C5 2C 04 0137*      ld (player_x),hl
042D95             0138*  ;compute new y position
042D95 2A C8 2C 04 0139*      ld hl,(player_y)
042D99 ED 5B CE 2C 0140*      ld de,(player_yvel)
       04          
042D9E 19          0141*      add hl,de ; hl = player_y + player_yvel
042D9F             0142*  ; TODO: make this work using 24-bit registers
042D9F             0143*  ;     ; check for vertical screen edge collisions
042D9F             0144*  ;     ; and adjust coordinate as necessary
042D9F             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042D9F             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042D9F             0147*  ;     ld a,8 ; set y to topmost allowable position
042D9F             0148*  ; @check_top:
042D9F             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042D9F             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042D9F             0151*  ;     ld a,232 ; set y to bottommost allowable position
042D9F             0152*  @y_ok:
042D9F 22 C8 2C 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042DA3             0154*  ; a should land here loaded with the correct frame
042DA3 CD 2C 20 04 0155*      call vdu_sprite_select_frame
042DA7             0156*  ; draw player at updated position
042DA7 ED 4B C5 2C 0157*      ld bc,(player_x)
       04          
042DAC ED 5B C8 2C 0158*  	ld de,(player_y)
       04          
042DB1             0159*  
042DB1             0160*      ; call dumpRegistersHex
042DB1             0161*  
042DB1 CD 95 20 04 0162*  	call vdu_sprite_move_abs168
042DB5             0163*  
042DB5             0164*  ; end player_input
042DB5 C9          0165*  	ret
042DB6             0166*  
042DB6             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042DB6             0168*  ; ; INSTEAD OF FRACTIONAL
042DB6             0169*  ; ; ----------------------------------------------------------------
042DB6             0170*  ; ; process player keyboard input, set player bitmap
042DB6             0171*  ; ; velocities and draw player bitmap at updated coordinates
042DB6             0172*  ; ; Inputs: player_x/y set at desired position
042DB6             0173*  ; ; Returns: player bitmap drawn at updated position
042DB6             0174*  ; ; Destroys: probably everything except maybe iy
042DB6             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042DB6             0176*  ; ; TODO: requires sprite implementation
042DB6             0177*  ; player_input:
042DB6             0178*  ; ; reset player component velocities to zero as the default
042DB6             0179*  ; 	ld hl,0
042DB6             0180*  ; 	ld (player_xvel),hl
042DB6             0181*  ; 	ld (player_yvel),hl
042DB6             0182*  ; ; check for keypresses and branch accordingly
042DB6             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042DB6             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042DB6             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042DB6             0186*  ; ; this handles the case where two opposing movement keys
042DB6             0187*  ; ; are down simultaneously (velocities will net to zero)
042DB6             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042DB6             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042DB6             0190*  ; ; so we can walk and chew gum at the same time
042DB6             0191*  ; @left:
042DB6             0192*  ;     bit 1,(ix+3) ; keycode 26
042DB6             0193*  ;     jr z,@right
042DB6             0194*  ;     ld hl,(player_xvel)
042DB6             0195*  ;     ld bc,-3
042DB6             0196*  ;     add hl,bc
042DB6             0197*  ;     ld (player_xvel),hl
042DB6             0198*  ; @right:
042DB6             0199*  ;     bit 1,(ix+15) ; keycode 122
042DB6             0200*  ; 	jr z,@up
042DB6             0201*  ;     ld hl,(player_xvel)
042DB6             0202*  ;     ld bc,3
042DB6             0203*  ;     add hl,bc
042DB6             0204*  ;     ld (player_xvel),hl
042DB6             0205*  ; @up:
042DB6             0206*  ;     bit 1,(ix+7) ; keycode 58
042DB6             0207*  ; 	jr z,@down
042DB6             0208*  ;     ld hl,(player_yvel)
042DB6             0209*  ;     ld bc,-3
042DB6             0210*  ;     add hl,bc
042DB6             0211*  ;     ld (player_yvel),hl
042DB6             0212*  ; @down:
042DB6             0213*  ;     bit 1,(ix+5) ; keycode 42
042DB6             0214*  ; 	jr z,@done_keyboard
042DB6             0215*  ;     ld hl,(player_yvel)
042DB6             0216*  ;     ld bc,3
042DB6             0217*  ;     add hl,bc
042DB6             0218*  ;     ld (player_yvel),hl
042DB6             0219*  ; @done_keyboard:
042DB6             0220*  ; ; move player sprite according to velocities set by keypresses
042DB6             0221*  ;     ld hl,(player_xvel)
042DB6             0222*  ; ; compute new x position
042DB6             0223*  ;     ld de,(player_x)
042DB6             0224*  ;     add hl,de ; hl = player_x + player_xvel
042DB6             0225*  ;     ; check for horizontal screen edge collisions
042DB6             0226*  ;     ; and adjust coordinate as necessary
042DB6             0227*  ; ; TODO: make this work using 24-bit registers
042DB6             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042DB6             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042DB6             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042DB6             0231*  ; ; @check_right:
042DB6             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042DB6             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042DB6             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042DB6             0235*  ; @x_ok:
042DB6             0236*  ;     ; save the updated drawing coordinate
042DB6             0237*  ;     ld (player_x),hl
042DB6             0238*  ; ;compute new y position
042DB6             0239*  ;     ld hl,(player_y)
042DB6             0240*  ;     ld de,(player_yvel)
042DB6             0241*  ;     add hl,de ; hl = player_y + player_yvel
042DB6             0242*  ; ; TODO: make this work using 24-bit registers
042DB6             0243*  ; ;     ; check for vertical screen edge collisions
042DB6             0244*  ; ;     ; and adjust coordinate as necessary
042DB6             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042DB6             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042DB6             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042DB6             0248*  ; ; @check_top:
042DB6             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042DB6             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042DB6             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042DB6             0252*  ; @y_ok:
042DB6             0253*  ;     ld (player_y),hl
042DB6             0254*  ; ; draw player at updated position
042DB6             0255*  ;     ld a,(player_id)
042DB6             0256*  ;     call vdu_sprite_select
042DB6             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042DB6             0258*  ;     call get_sign_hlu ; to set the proper animation
042DB6             0259*  ;     add a,1 ; ...
042DB6             0260*  ;     call vdu_sprite_select_frame
042DB6             0261*  ;     ld bc,(player_x)
042DB6             0262*  ; 	ld de,(player_y)
042DB6             0263*  ; 	call vdu_sprite_move_abs
042DB6             0264*  ; ; end player_input
042DB6             0265*  ; 	ret
042DB6             0266*  
042DB6             0267*  
042DB6             0268*  ; ###################################################################
042DB6             0269*  ; TODO: the below is all stuff from the original code we need to port
042DB6             0270*  ; ###################################################################
042DB6             0271*  
042DB6             0272*  ; kill_player:
042DB6             0273*  ; ; set player status to dead
042DB6             0274*  ;     xor a; sets all player flags to zero
042DB6             0275*  ;     ld (player_collisions),a
042DB6             0276*  ; ; deduct a ship from the inventory
042DB6             0277*  ;     ld a,(player_ships)
042DB6             0278*  ;     dec a
042DB6             0279*  ;     ld (player_ships),a
042DB6             0280*  ; ; are we out of ships?
042DB6             0281*  ;     jp z,game_over
042DB6             0282*  ; ; wait a few ticks
042DB6             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042DB6             0284*  ;     ld (player_move_timer),a
042DB6             0285*  ; kill_player_loop:
042DB6             0286*  ;     call vdu_vblank
042DB6             0287*  ;     ld a,(player_move_timer)
042DB6             0288*  ;     dec a
042DB6             0289*  ;     ld (player_move_timer),a
042DB6             0290*  ;     jr nz,kill_player_loop
042DB6             0291*  ;     call player_init ; player respawn if timer zero
042DB6             0292*  ;     ret ; and out
042DB6             0293*  
042DB6             0294*  
042DB6             0295*  ; player_move:
042DB6             0296*  ; ; begin setting player to active sprite
042DB6             0297*  ;     ld hl,player
042DB6             0298*  ;     ld (sprite_base_bufferId),hl
042DB6             0299*  ;     ld hl,0 ; north
042DB6             0300*  ;     ld (sprite_heading),hl
042DB6             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042DB6             0302*  ;     ld (sprite_animation),a
042DB6             0303*  ;     ; we set position here for the time being as a default
042DB6             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042DB6             0305*  ;     ld hl,(player_x)
042DB6             0306*  ;     ld (sprite_x),hl
042DB6             0307*  ;     ld hl,(player_y)
042DB6             0308*  ;     ld (sprite_y),hl
042DB6             0309*  ; ; did we just die?
042DB6             0310*  ;     ld a,(player_collisions)
042DB6             0311*  ;     and %00000010 ; zero flag will be set if not dead
042DB6             0312*  ;     jr z,player_not_dead
042DB6             0313*  ; ; yes we died
042DB6             0314*  ;     call kill_player
042DB6             0315*  ;     ret ; done
042DB6             0316*  ; ; yay we didn't die
042DB6             0317*  ; player_not_dead:
042DB6             0318*  ; ; set player movements to zero by default
042DB6             0319*  ;     ld hl,0
042DB6             0320*  ;     ld (player_xvel),hl
042DB6             0321*  ;     ld (player_yvel),hl
042DB6             0322*  ; ; do we move it?
042DB6             0323*  ;     in a,(#82) ; keyboard
042DB6             0324*  ;     or a ; if zero,don't move
042DB6             0325*  ;     jr z,player_draw
042DB6             0326*  ; ; move it
042DB6             0327*  ;     call player_move_calc
042DB6             0328*  ; player_draw:
042DB6             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042DB6             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042DB6             0331*  ; player_move_done:
042DB6             0332*  ;     ; write updated x,y coordinates back to player table
042DB6             0333*  ;     ld hl,(sprite_x)
042DB6             0334*  ;     ld (player_x),hl
042DB6             0335*  ;     ld hl,(sprite_y)
042DB6             0336*  ;     ld (player_y),hl
042DB6             0337*  ;     ret
042DB6             0063   	include "tiles.inc"
042DB6             0001*  ; ######### TILES #########
042DB6             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042DB6             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042DB6 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042DB9 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042DBA             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042DBA 00          0007*  cur_level: db 0
042DBB             0008*  num_levels: equ 2 ; number of levels,duh
042DBB             0009*  
042DBB             0010*  ; lookup table for level definitions
042DBB E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042DC1             0012*  
042DC1             0013*  ; tiles_bufferId: dl 0
042DC1 00 00 00    0014*  tiles_x_plot: dl 0
042DC4 F1 FF FF    0015*  tiles_y_plot: dl -15
042DC7             0016*  
042DC7             0017*  
042DC7             0018*  tiles_plot:
042DC7             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042DC7             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042DC7             0021*  ; ;       but don't want
042DC7             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042DC7             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042DC7             0024*  ; 	ld bc,0 ; leftmost x-coord
042DC7             0025*  ; 	ld de,0 ; topmost y-coord
042DC7             0026*  ; 	ld ix,255 ; rightmost x-coord
042DC7             0027*  ; 	ld iy,1 ; bottommost y-coord
042DC7             0028*  ; 	call vdu_set_gfx_viewport
042DC7             0029*  
042DC7 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042DCB 22 C1 2D 04 0031*      ld (tiles_x_plot),hl
042DCF 2A B6 2D 04 0032*      ld hl,(tiles_row_defs)
042DD3 06 10       0033*  	ld b,16 ; loop counter
042DD5             0034*  @loop:
042DD5 C5          0035*  	push bc ; save the loop counter
042DD6             0036*  ; read the tile defintion for the current column
042DD6 7E          0037*      ld a,(hl) ; a has tile definition
042DD7 E5          0038*      push hl  ; save pointer to tile definition
042DD8 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042DDC 6F          0040*      ld l,a ; l is tile defintion
042DDD 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042DDF CD 5F 1C 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042DE3             0043*  
042DE3             0044*  ; plot the active bitmap
042DE3 ED 4B C1 2D 0045*      ld bc,(tiles_x_plot)
       04          
042DE8 ED 5B C4 2D 0046*      ld de,(tiles_y_plot)
       04          
042DED CD 28 1F 04 0047*      call vdu_plot_bmp
042DF1             0048*  
042DF1             0049*  ; bump x-coords the width of one tile and save it
042DF1 2A C1 2D 04 0050*      ld hl,(tiles_x_plot)
042DF5 01 10 00 00 0051*      ld bc,16
042DF9 09          0052*      add hl,bc
042DFA 22 C1 2D 04 0053*      ld (tiles_x_plot),hl
042DFE             0054*  
042DFE             0055*  ; prepare to loop to next column
042DFE E1          0056*      pop hl ; get back pointer to tile def
042DFF 23          0057*      inc hl ; bump it to the next column
042E00 C1          0058*  	pop bc ; snag our loop counter
042E01 10 D2       0059*      djnz @loop
042E03             0060*  
042E03             0061*  ; increment tiles plotting y-coordinate
042E03             0062*  ; when it hits zero, we go to next row of tiles in the map
042E03             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042E03 DD 21 C4 2D 0064*  	ld ix,tiles_y_plot
       04          
042E08 DD 34 00    0065*  	inc (ix)
042E0B C0          0066*  	ret nz
042E0C             0067*  
042E0C             0068*  ; time to bump tiles_row_defs to next row
042E0C             0069*  ; (hl was already there at the end of the loop)
042E0C 22 B6 2D 04 0070*      ld (tiles_row_defs),hl
042E10             0071*  
042E10             0072*  ; reset coords to plot next row of tiles
042E10 21 00 00 00 0073*      ld hl,0
042E14 22 C1 2D 04 0074*      ld (tiles_x_plot),hl
042E18 21 F1 FF FF 0075*      ld hl,-15
042E1C 22 C4 2D 04 0076*      ld (tiles_y_plot),hl
042E20             0077*  
042E20             0078*  ; decrement tiles row counter
042E20 21 B9 2D 04 0079*      ld hl,tiles_row
042E24 35          0080*      dec (hl)
042E25 C0          0081*      ret nz
042E26             0082*  
042E26             0083*  ; queue up next level
042E26 3A BA 2D 04 0084*      ld a,(cur_level)
042E2A FE 01       0085*      cp num_levels-1
042E2C 20 02       0086*      jr nz,@inc_level
042E2E 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
042E30             0088*  
042E30             0089*  @inc_level:
042E30 3C          0090*      inc a
042E31 32 BA 2D 04 0091*      ld (cur_level),a
042E35             0092*  
042E35             0093*  ; increase the number of enemy sprites
042E35 3A 7C 2E 04 0094*      ld a,(max_enemy_sprites)
042E39 3C          0095*      inc a
042E3A FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
042E3C 28 04       0097*      jr z,init_level
042E3E 32 7C 2E 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
042E42             0099*  ; fall through to init_level
042E42             0100*  
042E42             0101*  init_level:
042E42             0102*  ; look up address of level's tile defintion
042E42 21 BB 2D 04 0103*      ld hl,tiles_levels
042E46 3A BA 2D 04 0104*      ld a,(cur_level)
042E4A 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
042E4E 57          0106*      ld d,a
042E4F 1E 03       0107*      ld e,3
042E51 ED 5C       0108*      mlt de
042E53 19          0109*      add hl,de
042E54 ED 37       0110*      ld ix,(hl)
042E56 DD 22 B6 2D 0111*      ld (tiles_row_defs),ix
       04          
042E5B             0112*  
042E5B             0113*  ; set tiles_row counter
042E5B DD 7E 00    0114*      ld a,(ix)
042E5E 32 B9 2D 04 0115*      ld (tiles_row),a
042E62 DD 23       0116*      inc ix ; now ix points first element of first row tile def
042E64 DD 22 B6 2D 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
042E69 C9          0118*      ret
042E6A             0119*  
042E6A             0120*  
042E6A             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
042E6A             0122*  ; dt_is_active:
042E6A             0123*  ; ; a lands here containing a tile index in the low nibble
042E6A             0124*  ; ; we test the values for the tiles which are active
042E6A             0125*  ;     cp #07
042E6A             0126*  ;     call z,ld_act_landing_pad
042E6A             0127*  ;     cp #08
042E6A             0128*  ;     call z,ld_act_laser_turret
042E6A             0129*  ;     ; fall through
042E6A             0130*  ;     ret
042E6A             0131*  
042E6A             0132*  ; ; some tiles become active sprites,so we load those here
042E6A             0133*  ; ; sprite_x/y have already been loaded
042E6A             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
042E6A             0135*  ; ; we don't want sprite drawn to background like other tiles
042E6A             0136*  ; ; so this routine only adds them to the sprite table
042E6A             0137*  ; dt_ld_act:
042E6A             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
042E6A             0139*  ;     ld (sprite_y+1),a ; just the integer part
042E6A             0140*  ;     ld (sprite_base_bufferId),hl
042E6A             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042E6A             0142*  ;     call table_add_record
042E6A             0143*  ;     call sprite_variables_from_stack
042E6A             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
042E6A             0145*  ;     ret ; and back
042E6A             0146*  
042E6A             0147*  ; ld_act_landing_pad:
042E6A             0148*  ;     call sprite_variables_to_stack
042E6A             0149*  
042E6A             0150*  ;     ld hl,move_landing_pad
042E6A             0151*  ;     ld (sprite_move_program),hl
042E6A             0152*  
042E6A             0153*  ;     xor a
042E6A             0154*  ;     ld (sprite_animation),a ; animation 0
042E6A             0155*  
042E6A             0156*  ;     call rand_8     ; snag a random number
042E6A             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042E6A             0158*  ;     add a,64 ; range is now 64-127
042E6A             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042E6A             0160*  
042E6A             0161*  ;     ld a,%10 ; collides with laser but not player
042E6A             0162*  ;     ld (iy+sprite_collisions),a
042E6A             0163*  
042E6A             0164*  ;     ld a,#05 ; BCD
042E6A             0165*  ;     ld (sprite_points),a
042E6A             0166*  ;     ld a,0 ; binary
042E6A             0167*  ;     ld (sprite_shield_damage),a
042E6A             0168*  
042E6A             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
042E6A             0170*  ;     jr dt_ld_act
042E6A             0171*  
042E6A             0172*  ; ld_act_laser_turret:
042E6A             0173*  ;     call sprite_variables_to_stack
042E6A             0174*  
042E6A             0175*  ;     ld hl,move_laser_turret
042E6A             0176*  ;     ld (sprite_move_program),hl
042E6A             0177*  
042E6A             0178*  ;     xor a
042E6A             0179*  ;     ld (sprite_animation),a
042E6A             0180*  ;     ld (sprite_move_step),a
042E6A             0181*  
042E6A             0182*  ;     call rand_8     ; snag a random number
042E6A             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042E6A             0184*  ;     add a,64 ; range is now 64-127
042E6A             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042E6A             0186*  
042E6A             0187*  ;     ld a,%10 ; collides with laser but not player
042E6A             0188*  ;     ld (iy+sprite_collisions),a
042E6A             0189*  
042E6A             0190*  ;     ld a,#10 ; BCD
042E6A             0191*  ;     ld (sprite_points),a
042E6A             0192*  ;     ld a,0 ; binary
042E6A             0193*  ;     ld (sprite_shield_damage),a
042E6A             0194*  
042E6A             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
042E6A             0196*  ;     jp dt_ld_act
042E6A             0197*  
042E6A             0198*  
042E6A             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
042E6A             0200*  ; deletes sprites from table when they wrap around to top of screen
042E6A             0201*  move_active_tiles:
042E6A             0202*  ; get current position
042E6A 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
042E6E 3C          0204*      inc a
042E6F             0205*  ; are we at the bottom of the screen?
042E6F 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
042E71             0207*  ; otherwise kill sprite
042E71 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
042E73 FD 77 08    0209*      ld (iy+sprite_collisions),a
042E76 C9          0210*      ret ; debug
042E77             0211*  move_active_tiles_draw_sprite:
042E77 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
042E7B             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042E7B             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
042E7B C9          0215*      ret ; and done
042E7C             0064   	include "enemies.inc"
042E7C 10          0001*  max_enemy_sprites: db 16
042E7D             0002*  
042E7D             0003*  ; sprite_type
042E7D             0004*  enemy_dead: equ 0
042E7D             0005*  enemy_small: equ 1
042E7D             0006*  enemy_medium: equ 2
042E7D             0007*  enemy_large: equ 3
042E7D             0008*  landing_pad: equ 4
042E7D             0009*  laser_turret: equ 5
042E7D             0010*  fireballs: equ 6
042E7D             0011*  explosion: equ 7
042E7D             0012*  
042E7D             0013*  
042E7D             0014*  respawn_countdown:
042E7D 2A 9E 2E 04 0015*      ld hl,(respawn_timer)
042E81 2B          0016*      dec hl
042E82 22 9E 2E 04 0017*      ld (respawn_timer),hl
042E86             0018*  ; check hl for zero
042E86 19          0019*      add hl,de
042E87 B7          0020*      or a
042E88 ED 52       0021*      sbc hl,de
042E8A C0          0022*      ret nz
042E8B 06 04       0023*      ld b,table_max_records
042E8D             0024*  @respawn_loop:
042E8D C5          0025*      push bc
042E8E CD 8F 2F 04 0026*      call enemy_init_from_landing_pad
042E92 C1          0027*      pop bc
042E93 10 F8       0028*      djnz @respawn_loop
042E95 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
042E99 22 9E 2E 04 0030*      ld (respawn_timer),hl
042E9D C9          0031*      ret
042E9E 3C 00 00    0032*  respawn_timer: dl 1*60
042EA1             0033*  
042EA1             0034*  move_enemies:
042EA1             0035*  ; are there any active enemies or explosions?
042EA1 21 00 00 00 0036*      ld hl,0
042EA5 3A 7D 16 04 0037*      ld a,(table_active_sprites)
042EA9 6F          0038*      ld l,a
042EAA             0039*      ; call dumpRegistersHex
042EAA A7          0040*      and a ; will be zero if no alive enemies or explosions
042EAB             0041*      ; ret z ; so nothing to do but go back
042EAB             0042*      ; ld hl,(respawn_timer)
042EAB             0043*      ; call dumpRegistersHex
042EAB 20 05       0044*      jr nz,move_enemies_do
042EAD CD 7D 2E 04 0045*      call respawn_countdown
042EB1 C9          0046*      ret
042EB2             0047*  move_enemies_do:
042EB2             0048*  ; initialize pointers and loop counter
042EB2 FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
042EB7 06 04       0050*      ld b,table_max_records ; loop counter
042EB9             0051*  move_enemies_loop:
042EB9 FD 22 7A 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
042EBE C5          0053*      push bc ; backup loop counter
042EBF             0054*  ; check sprite_type to see if sprite is active
042EBF FD 7E 01    0055*      ld a,(iy+sprite_type)
042EC2 A7          0056*      and a ; if zero, sprite is dead
042EC3 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
042EC5             0058*  ; otherwise we prepare to move the sprite
042EC5 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
042EC8 CD C9 1F 04 0060*      call vdu_sprite_select ; select sprite
042ECC FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
042ECF E9          0062*      jp (hl)  ; ... and jump to it
042ED0             0063*  ; we always jp back here from behavior subroutines
042ED0             0064*  move_enemies_loop_return:
042ED0 FD 2A 7A 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
042ED5             0066*  ; now we check results of all the moves
042ED5 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
042ED8 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
042EDA FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
042EDD 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
042EDF CD C6 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
042EE3 AF          0072*      xor a ; zero a so that we can ...
042EE4 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
042EE7 18 0A       0074*      jr move_enemies_next_record ; and to the next record
042EE9             0075*  move_enemies_draw_sprite:
042EE9             0076*  ; if we got here sprite will have already been activated
042EE9             0077*  ; so all we need to do is set its coordinates and draw it
042EE9 FD 07 0B    0078*      ld bc,(iy+sprite_x)
042EEC FD 17 0E    0079*      ld de,(iy+sprite_y)
042EEF CD 95 20 04 0080*      call vdu_sprite_move_abs168
042EF3             0081*  ; fall through to next record
042EF3             0082*  move_enemies_next_record:
042EF3 11 26 00 00 0083*      ld de,table_bytes_per_record
042EF7 FD 19       0084*      add iy,de ; point to next record
042EF9 AF          0085*      xor a ; clears carry flag
042EFA 32 7E 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
042EFE C1          0087*      pop bc ; get back our loop counter
042EFF 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
042F01 C9          0089*      ret ; and we're out
042F02             0090*  
042F02             0091*  en_nav_zigzag_start:
042F02 FD 2A 7A 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F07 CD E6 21 04 0093*      call rand_8
042F0B E6 3F       0094*      and %00111111 ; limit it to 64
042F0D CB DF       0095*      set 3,a ; make sure it's at least 8
042F0F FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
042F12             0097*      ; fall through to en_nav_zigzag
042F12             0098*  en_nav_zigzag:
042F12 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
042F15 3D          0100*      dec a
042F16 FD 77 22    0101*      ld (iy+sprite_move_timer),a
042F19 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
042F1B             0103*      ; otherwise flip direction and restart timer
042F1B FD 7E 23    0104*      ld a,(iy+sprite_move_step)
042F1E EE 01       0105*      xor %1 ; flips bit one
042F20 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
042F23 20 09       0107*      jr nz,en_nav_zigzag_right
042F25             0108*  ;otherwise zag left
042F25 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
042F29 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
042F2C 18 D4       0111*      jr en_nav_zigzag_start
042F2E             0112*  en_nav_zigzag_right:
042F2E 21 00 60 00 0113*      ld hl,0x006000; southeast heading
042F32 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
042F35 18 CB       0115*      jr en_nav_zigzag_start
042F37             0116*  en_nav_zigzag_no_switch:
042F37             0117*      ; ld a,(sprite_orientation)
042F37 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
042F3A 18 13       0119*      jr en_nav_computevelocities
042F3C             0120*  
042F3C             0121*  ; contains the logic for how to move the enemy
042F3C             0122*  ; and then does the moving
042F3C             0123*  ; inputs: a fully-populated active sprite table
042F3C             0124*  ;         player position variables
042F3C             0125*  ; destroys: everything except index registers
042F3C             0126*  ; outputs: moving enemies
042F3C             0127*  en_nav:
042F3C             0128*  ; set velocity and orientation by player's relative location
042F3C             0129*  ; move enemies y-axis
042F3C             0130*  ; where is player relative to us?
042F3C CD 12 30 04 0131*      call orientation_to_player
042F40             0132*  ;    h.l 16.8 fixed angle256 to player
042F40             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042F40             0134*  ; is player above or below us?
042F40 ED 53 3A 1A 0135*      ld (ude),de ; dy
       04          
042F45 3A 3C 1A 04 0136*      ld a,(ude+2) ; deu
042F49 17          0137*      rla ; shift sign bit into carry
042F4A 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
042F4C             0139*  ; player is even or above,so home in on current heading
042F4C FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
042F4F             0141*  
042F4F             0142*  ; we land here from zig-zag program so as not to
042F4F             0143*  ; redundantly save orientation and heading
042F4F             0144*  en_nav_computevelocities:
042F4F             0145*  ; set x/y component velocities based on bearing to player
042F4F FD 2A 7A 16 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F54 E5          0147*      push hl ; we need it back to set rotation frame
042F55 FD 17 17    0148*      ld de,(iy+sprite_vel)
042F58 CD FB 21 04 0149*      call polar_to_cartesian
042F5C FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
042F5F FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
042F62             0152*  ; change the animation frame to match heading
042F62             0153*  ; by dividng the heading by 8
042F62 E1          0154*      pop hl ; get back Heading
042F63 7C          0155*      ld a,h
042F64 CB 3F       0156*      srl a
042F66 CB 3F       0157*      srl a
042F68 CB 3F       0158*      srl a
042F6A CD 2C 20 04 0159*      call vdu_sprite_select_frame
042F6E             0160*  ; update sprite position
042F6E             0161*  move_enemy_sprite:
042F6E FD 27 0B    0162*      ld hl,(iy+sprite_x)
042F71 FD 17 11    0163*      ld de,(iy+sprite_xvel)
042F74 19          0164*      add hl,de
042F75 FD 2F 0B    0165*      ld (iy+sprite_x),hl
042F78             0166*  
042F78 FD 27 0E    0167*      ld hl,(iy+sprite_y)
042F7B FD 17 14    0168*      ld de,(iy+sprite_yvel)
042F7E 19          0169*      add hl,de
042F7F FD 2F 0E    0170*      ld (iy+sprite_y),hl
042F82 C9          0171*      ret
042F83             0172*  
042F83             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
042F83             0174*  ; move_enemy_sprite:
042F83             0175*  ; ; x-axis movement first
042F83             0176*  ;     ld hl,(iy+sprite_x)
042F83             0177*  ;     push hl ; save pre-move position
042F83             0178*  ;     pop bc ; to detect screen edge collision
042F83             0179*  ;     ld de,(iy+sprite_xvel)
042F83             0180*  ;     add hl,de ;compute new x position
042F83             0181*  ;     ld (iy+sprite_x),hl ; store it
042F83             0182*  ;     and a ; clear the carry flag
042F83             0183*  ;     sbc hl,bc ; test which direction was our movement
042F83             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
042F83             0185*  ;     jp p,@move_right ; sign positive means moved right
042F83             0186*  ; @move_left: ; otherwise we moved left
042F83             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
042F83             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
042F83             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
042F83             0190*  ;     ld a,#20 ; west
042F83             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F83             0192*  ;     jr @move_y
042F83             0193*  ; @move_right:
042F83             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
042F83             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042F83             0196*  ;     ld l,0x00
042F83             0197*  ;     ld a,(iy+sprite_dim_x)
042F83             0198*  ;     ld h,a
042F83             0199*  ;     ld a,0x00
042F83             0200*  ;     sub h
042F83             0201*  ;     ld h,a
042F83             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
042F83             0203*  ;     ld a,0x02 ; east
042F83             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F83             0205*  ; @move_y:
042F83             0206*  ;     ld hl,(iy+sprite_y)
042F83             0207*  ;     ld b,h ; save pre-move position
042F83             0208*  ;     ld c,l ; to detect screen edge collision
042F83             0209*  ;     ld de,(iy+sprite_yvel)
042F83             0210*  ;     add hl,de ;compute new y position
042F83             0211*  ;     ld (iy+sprite_y),hl ; store it
042F83             0212*  ;     and a ; clear the carry flag
042F83             0213*  ;     sbc hl,bc ; test which direction was our movement
042F83             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
042F83             0215*  ;     jp p,@move_dn ; sign positive means moved down
042F83             0216*  ; @move_up:
042F83             0217*  ;     add hl,bc ; get back new y position
042F83             0218*  ;     ld de,0x5000 ; top edge of visible screen
042F83             0219*  ;     and a ; clear the carry flag
042F83             0220*  ;     sbc hl,de
042F83             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
042F83             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
042F83             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
042F83             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042F83             0225*  ;     or 0x80 ; north
042F83             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F83             0227*  ;     jr @move_ret
042F83             0228*  ; @move_dn:
042F83             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
042F83             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042F83             0231*  ;     ld l,0x00
042F83             0232*  ;     ld a,(iy+sprite_dim_y)
042F83             0233*  ;     ld h,a
042F83             0234*  ;     ld a,0x00
042F83             0235*  ;     sub h
042F83             0236*  ;     ld h,a
042F83             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
042F83             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042F83             0239*  ;     or 0x08 ; south
042F83             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F83             0241*  ; @move_ret:
042F83             0242*  ;     ret
042F83             0243*  
042F83             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
042F83             0245*  ; ; each sprite in the table must have one of these defined
042F83             0246*  ; ; but they need not be unique to a particular sprite
042F83             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
042F83             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
042F83             0249*  ; ; but they can call anything they want between those two endpoints
042F83             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
042F83             0251*  
042F83             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
042F83             0253*  ;     jp move_enemies_loop_return
042F83             0254*  
042F83             0255*  ; move_explosion:
042F83             0256*  ;     call animate_explosion
042F83             0257*  ;     jp move_enemies_loop_return
042F83             0258*  
042F83             0259*  move_enemy_small:
042F83 CD 3C 2F 04 0260*      call en_nav
042F87 CD AE 30 04 0261*      call check_collisions
042F8B C3 D0 2E 04 0262*      jp move_enemies_loop_return
042F8F             0263*  
042F8F             0264*  ; move_enemy_medium:
042F8F             0265*  ;     call en_nav
042F8F             0266*  ;     call check_collisions
042F8F             0267*  ;     jp move_enemies_loop_return
042F8F             0268*  
042F8F             0269*  ; move_enemy_large:
042F8F             0270*  ;     call en_nav
042F8F             0271*  ;     call check_collisions
042F8F             0272*  ;     jp move_enemies_loop_return
042F8F             0273*  
042F8F             0274*  ; move_landing_pad:
042F8F             0275*  ;     call move_active_tiles
042F8F             0276*  ;     call check_collisions
042F8F             0277*  ; ; is it time to launch an enemy?
042F8F             0278*  ;     ld hl,sprite_move_timer
042F8F             0279*  ;     dec (hl)
042F8F             0280*  ;     jp nz,move_enemies_loop_return
042F8F             0281*  ;     call enemy_init_from_landing_pad
042F8F             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
042F8F             0283*  ;     call rand_8     ; snag a random number
042F8F             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042F8F             0285*  ;     add a,64 ; range is now 64-127
042F8F             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042F8F             0287*  ;     jp move_enemies_loop_return
042F8F             0288*  
042F8F             0289*  enemy_init_from_landing_pad:
042F8F             0290*  ; get next available spriteId
042F8F CD A1 16 04 0291*      call table_get_next_id
042F93 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
042F94             0293*  ; ix comes back with the pointer to the new sprite variables
042F94 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
042F96             0295*  ; a comes back with the spriteId of the new sprite
042F96 32 EC 2F 04 0296*      ld (@id),a
042F9A             0297*  ; initialize the new sprite
042F9A CD C9 1F 04 0298*      call vdu_sprite_select
042F9E CD DC 1F 04 0299*      call vdu_sprite_clear_frames
042FA2 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
042FA6 06 20       0301*      ld b,32
042FA8             0302*  @load_frames:
042FA8 C5          0303*      push bc
042FA9 E5          0304*      push hl
042FAA CD 16 21 04 0305*      call vdu_sprite_add_buff
042FAE E1          0306*      pop hl
042FAF 23          0307*      inc hl
042FB0 C1          0308*      pop bc
042FB1 10 F5       0309*      djnz @load_frames
042FB3             0310*  ; copy coordinates of active sprite to new sprite
042FB3 FD 2A 7A 16 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042FB8             0312*      ; ld hl,(iy+sprite_x)
042FB8             0313*  	; ld hl,0x008000 ; debug
042FB8             0314*  
042FB8 CD E6 21 04 0315*      call rand_8
042FBC 21 00 00 00 0316*      ld hl,0
042FC0 67          0317*      ld h,a
042FC1             0318*  
042FC1 22 F7 2F 04 0319*      ld (@x),hl
042FC5             0320*      ; ld hl,(iy+sprite_y)
042FC5             0321*      ; ld hl,0x002000 ; debug
042FC5             0322*  
042FC5 CD E6 21 04 0323*      call rand_8
042FC9 21 00 00 00 0324*      ld hl,0
042FCD 67          0325*      ld h,a
042FCE             0326*  
042FCE 22 FA 2F 04 0327*      ld (@y),hl
042FD2 CD E6 21 04 0328*      call rand_8
042FD6 E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
042FD8 32 0F 30 04 0330*      ld (@move_step),a
042FDC             0331*  ; now copy to the table
042FDC 21 EC 2F 04 0332*      ld hl,@id ; address to copy from
042FE0 D1          0333*      pop de ; address to copy to (was ix)
042FE1 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
042FE5 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
042FE7             0336*  ; finally, make the new sprite visible
042FE7 CD 3F 20 04 0337*      call vdu_sprite_show
042FEB C9          0338*      ret
042FEC 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
042FED 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
042FEE 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
042FF1 83 2F 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
042FF4 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
042FF5 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
042FF6 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
042FF7 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
042FFA 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042FFD 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043000 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043003 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
043006 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043009 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
04300C 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
04300D 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
04300E 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
04300F 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
043010 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
043011 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
043012             0359*  
043012             0360*  ; move_laser_turret:
043012             0361*  ; ; compute orientation to player
043012             0362*  ;     call orientation_to_player
043012             0363*  ; ; h.l 8.8 fixed angle256 to player
043012             0364*  ; ; bc and de as signed 16-bit integers
043012             0365*  ; ; representing delta-x/y *to* target respectively
043012             0366*  ;     ld (Bearing_t),hl
043012             0367*  ;     ld hl,0x0400
043012             0368*  ;     ld (Vp),hl
043012             0369*  ;     call targeting_computer
043012             0370*  ;     ld (sprite_heading),hl ; store bearing to player
043012             0371*  ; ; is it time to launch a fireball?
043012             0372*  ;     ld hl,sprite_move_timer
043012             0373*  ;     dec (hl)
043012             0374*  ;     jp nz,move_laser_turret_boilerplate
043012             0375*  ;     call fireballs_init
043012             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
043012             0377*  ;     call rand_8     ; snag a random number
043012             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043012             0379*  ;     add a,64 ; range is now 64-127
043012             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043012             0381*  ; move_laser_turret_boilerplate:
043012             0382*  ;     call move_active_tiles
043012             0383*  ;     call check_collisions
043012             0384*  ;     jp move_enemies_loop_return
043012             0385*  
043012             0386*  ; fireballs_init:
043012             0387*  ;     call sprite_variables_to_stack
043012             0388*  
043012             0389*  ;     ld hl,fireballs
043012             0390*  ;     ld (sprite_base_bufferId),hl
043012             0391*  
043012             0392*  ;     ld hl,move_fireballs
043012             0393*  ;     ld (sprite_move_program),hl
043012             0394*  
043012             0395*  ;     ld a,%11 ; collides with laser and player
043012             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
043012             0397*  ;     ld (iy+sprite_collisions),a
043012             0398*  
043012             0399*  ;     ld hl,(Vp)
043012             0400*  ;     ld (sprite_vel),hl
043012             0401*  ;     ld hl,(Vp_x)
043012             0402*  ;     ld (sprite_xvel),hl
043012             0403*  ;     ld hl,(Vp_y)
043012             0404*  ;     inc h ; account for ground movement
043012             0405*  ;     ld (sprite_yvel),hl
043012             0406*  
043012             0407*  ;     xor a ; zero a
043012             0408*  ;     ld (sprite_animation),a
043012             0409*  ;     ld (sprite_move_step),a
043012             0410*  ;     ld (sprite_move_timer),a
043012             0411*  
043012             0412*  ;     ld a,6 ; 1/10th of a second timer
043012             0413*  ;     ld (sprite_animation_timer),a
043012             0414*  
043012             0415*  ;     ld a,0x00 ; BCD
043012             0416*  ;     ld (sprite_points),a
043012             0417*  ;     ld a,1 ; binary
043012             0418*  ;     ld (sprite_shield_damage),a
043012             0419*  
043012             0420*  ;     call table_add_record ; plops that on the sprite stack for later
043012             0421*  ;     call sprite_variables_from_stack ; come back to where we started
043012             0422*  ;     ret
043012             0423*  
043012             0424*  ; move_fireballs:
043012             0425*  ;     call move_enemy_sprite ; move sprite
043012             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
043012             0427*  ;     and a ; if zero we're still within screen bounds
043012             0428*  ;     jr z,move_fireballs_alive
043012             0429*  ; ; otherwise kill sprite
043012             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
043012             0431*  ;     ld (iy+sprite_collisions),a
043012             0432*  ;     jp move_enemies_loop_return
043012             0433*  ; move_fireballs_alive:
043012             0434*  ;     ld a,(sprite_animation_timer)
043012             0435*  ;     dec a
043012             0436*  ;     ld (sprite_animation_timer),a
043012             0437*  ;     jr nz,move_fireballs_draw
043012             0438*  ;     ld a,(sprite_animation)
043012             0439*  ;     xor %1
043012             0440*  ;     ld (sprite_animation),a
043012             0441*  ;     ld a,6 ; 1/10th of a second timer
043012             0442*  ;     ld (sprite_animation_timer),a
043012             0443*  ;     ; fall through
043012             0444*  
043012             0445*  ; move_fireballs_draw:
043012             0446*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043012             0447*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043012             0448*  ;     call check_collisions
043012             0449*  ;     jp move_enemies_loop_return
043012             0450*  
043012             0451*  ; compute orientation to player
043012             0452*  ; based on relative positions
043012             0453*  ; returns: h.l 16.8 fixed angle256 to player
043012             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
043012             0455*  ;    representing delta-x/y *to* target respectively
043012             0456*  orientation_to_player:
043012 FD 2A 7A 16 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043017 FD E5       0458*      push iy ; so we can send it back intact
043019 FD 07 0B    0459*      ld bc,(iy+sprite_x)
04301C FD 17 0E    0460*      ld de,(iy+sprite_y)
04301F DD 2A C5 2C 0461*      ld ix,(player_x)
       04          
043024 FD 2A C8 2C 0462*      ld iy,(player_y)
       04          
043029 CD 45 22 04 0463*      call dxy168
04302D CD AC 22 04 0464*      call atan2_168game
043031 ED 4B A0 22 0465*      ld bc,(dx168)
       04          
043036 ED 5B A6 22 0466*      ld de,(dy168)
       04          
04303B FD E1       0467*      pop iy ; restore table pointer
04303D C9          0468*      ret
04303E             0469*  
04303E             0470*  
04303E             0471*  ; targeting_computer scratch variables
04303E 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
043040 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
043042 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
043044 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
043046 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
043048 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
04304A 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
04304C 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
04304E             0480*  
04304E             0481*  
04304E             0482*  ; ; Inputs:   see scratch variables
04304E             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
04304E             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
04304E             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
04304E             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
04304E             0487*  ; targeting_computer:
04304E             0488*  ; ; compute target velocity from x,y component velocities
04304E             0489*  ;     ld bc,(player_xvel)
04304E             0490*  ;     ld de,(player_yvel)
04304E             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
04304E             0492*  
04304E             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
04304E             0494*  ;     ld (Heading_t),bc
04304E             0495*  ;     ld (Vt),de
04304E             0496*  
04304E             0497*  ; ; compute Heading_t-Bearing_t
04304E             0498*  ;     ld h,b
04304E             0499*  ;     ld l,c
04304E             0500*  ;     ld bc,(Bearing_t)
04304E             0501*  ;     and a ; clear carry
04304E             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
04304E             0503*  
04304E             0504*  ; ; compute sin(Heading_t-Bearing_t)
04304E             0505*  ;     ld b,h
04304E             0506*  ;     ld c,l
04304E             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
04304E             0508*  
04304E             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
04304E             0510*  ;     ex de,hl
04304E             0511*  ;     ld bc,(Vt)
04304E             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
04304E             0513*  
04304E             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
04304E             0515*  ;     ld b,h
04304E             0516*  ;     ld c,l
04304E             0517*  ;     ld de,(Vp)
04304E             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
04304E             0519*  ; ; answer is in radians, convert to degrees256
04304E             0520*  ;     ex de,hl
04304E             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
04304E             0522*  ;     call BC_Mul_DE_88
04304E             0523*  
04304E             0524*  ; ; add lead angle to target bearing
04304E             0525*  ;     ld de,(Bearing_t)
04304E             0526*  ;     add hl,de ; h.l=lead angle+target bearing
04304E             0527*  ;     push hl
04304E             0528*  
04304E             0529*  ; ; compute component projectile velocities
04304E             0530*  ;     ld b,h
04304E             0531*  ;     ld c,l
04304E             0532*  ;     ld de,(Vp)
04304E             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
04304E             0534*  
04304E             0535*  ;     ld (Vp_x),bc
04304E             0536*  ;     ld (Vp_y),de
04304E             0537*  ;     pop hl ; h.l=lead angle+target bearing
04304E             0538*  ;     ret
04304E             0539*  
04304E             0540*  ; this routine vanquishes the enemy sprite
04304E             0541*  ; and replaces it with an animated explosion
04304E             0542*  ; we jump here instead of call because
04304E             0543*  ; we want to return to differing locations in the loop
04304E             0544*  ; depending on whether we're still sploding
04304E             0545*  ; destroys: everything except index registers
04304E             0546*  ; returns: an incandescent ball of debris and gas
04304E             0547*  kill_nurple:
04304E             0548*  ; ; tally up points
04304E             0549*  ;     ld bc,0
04304E             0550*  ;     ld a,(sprite_points)
04304E             0551*  ;     ld e,a
04304E             0552*  ;     ld d,0
04304E             0553*  ;     ld hl,add_bcd_arg2
04304E             0554*  ;     call set_bcd
04304E             0555*  ;     ld hl,player_score
04304E             0556*  ;     ld de,add_bcd_arg2
04304E             0557*  ;     ld a,3 ; number of bytes to add
04304E             0558*  ;     call add_bcd
04304E             0559*  ; ; initialize explosion
04304E             0560*  ; init_explosion:
04304E             0561*  ;     ld hl,explosion
04304E             0562*  ;     ld (sprite_base_bufferId),hl
04304E             0563*  ;     ld hl,move_explosion
04304E             0564*  ;     ld (sprite_move_program),hl
04304E             0565*  ;     ld a,%00000000 ; collides with nothing
04304E             0566*  ;     ld (iy+sprite_collisions),a
04304E             0567*  ;     ld hl,0 ; north
04304E             0568*  ;     ld (sprite_heading),hl
04304E             0569*  ;     ld a,0x04 ; will decrement to 03
04304E             0570*  ;     ld (sprite_animation),a
04304E             0571*  ;     ld a,0x07 ; 7/60th of a second timer
04304E             0572*  ;     ld (sprite_animation_timer),a
04304E             0573*  ;     xor a
04304E             0574*  ;     ld (sprite_move_timer),a
04304E             0575*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04304E             0576*  ; ; fall through to next_explosion
04304E             0577*  ; next_explosion:
04304E             0578*  ;     ld a,(sprite_animation)
04304E             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
04304E             0580*  ;     jp m,done_explosion
04304E             0581*  ;     ld (sprite_animation),a
04304E             0582*  ;     ld a,0x7 ; 7/60th of a second timer
04304E             0583*  ;     ld (sprite_animation_timer),a
04304E             0584*  ; ; fall through to animate_explosion
04304E             0585*  ; animate_explosion:
04304E             0586*  ;     ld hl,sprite_y+1
04304E             0587*  ;     inc (hl) ; move explosion down 1 pixel
04304E             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
04304E             0589*  ;     ld hl,sprite_animation_timer
04304E             0590*  ;     dec (hl) ; if timer is zero,we do next animation
04304E             0591*  ;     jr z,next_explosion
04304E             0592*  ;     ;otherwise we fall through to draw the current one
04304E             0593*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04304E             0594*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04304E             0595*  ;     ret ; now we go back to caller
04304E             0596*  ; done_explosion:
04304E 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
043050 FD 2A 7A 16 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
043055 FD 77 08    0599*      ld (iy+sprite_collisions),a
043058 C9          0600*      ret ; now we go back to caller
043059             0601*  
043059             0602*  ; game_over:
043059             0603*  ;     jp new_game
043059             0604*  
043059             0605*  ; it's presumed we've already checked that laser is alive
043059             0606*  collision_enemy_with_laser:
043059 DD 2A E6 30 0607*      ld ix,(laser_x)
       04          
04305E FD 2A E9 30 0608*      ld iy,(laser_y)
       04          
043063 3A E4 30 04 0609*      ld a,(laser_dim_x)
043067 CB 2F       0610*      sra a ; divide by 2
043069 F5          0611*      push af ; we need this later
04306A             0612*      ; ld de,0
04306A             0613*      ; ld d,a
04306A             0614*      ; add ix,de
04306A             0615*      ; add iy,de
04306A 18 11       0616*      jr collision_enemy
04306C             0617*  
04306C             0618*  ; it's presumed we've already checked that player is alive
04306C             0619*  collision_enemy_with_player:
04306C DD 2A C5 2C 0620*      ld ix,(player_x)
       04          
043071 FD 2A C8 2C 0621*      ld iy,(player_y)
       04          
043076 3A C3 2C 04 0622*      ld a,(player_dim_x)
04307A             0623*  
04307A             0624*      ; call dumpRegistersHex
04307A             0625*  
04307A CB 2F       0626*      sra a ; divide by 2
04307C F5          0627*      push af ; we need this later
04307D             0628*      ; ld de,0
04307D             0629*      ; ld d,a
04307D             0630*      ; add ix,de
04307D             0631*      ; add iy,de
04307D             0632*      ; fall through to collision_enemy
04307D             0633*  
04307D             0634*  ; compute the distance between the two sprites' centers
04307D             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
04307D             0636*  collision_enemy:
04307D             0637*  ; back up iy because we need it as the sprite table pointer
04307D FD E5       0638*      push iy
04307F FD 2A 7A 16 0639*      ld iy,(table_pointer)
       04          
043084 FD 27 0B    0640*      ld hl,(iy+sprite_x)
043087 FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
04308A CB 2F       0642*      sra a
04308C F5          0643*      push af ; we need this later
04308D             0644*      ; ld de,0
04308D             0645*      ; ld d,a
04308D             0646*      ; add hl,de
04308D E5          0647*      push hl
04308E C1          0648*      pop bc ; bc = x0
04308F FD 27 0E    0649*      ld hl,(iy+sprite_y)
043092 FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
043095             0651*      ; sra a
043095             0652*      ; ld de,0
043095             0653*      ; ld d,a
043095             0654*      ; add hl,de
043095 EB          0655*      ex de,hl ; de = y0
043096 F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
043097 FD E1       0657*      pop iy
043099 F5          0658*      push af
04309A             0659*  
04309A             0660*      ; call dumpRegistersHex
04309A             0661*  
04309A CD 60 22 04 0662*      call distance168
04309E             0663*      ; CALL dumpRegistersHex
04309E             0664*  ; ; subtract sum of radii from distance between centers
04309E             0665*  ;     ld de,0
04309E             0666*  ;     pop af ; radius of enemy sprite
04309E             0667*  ;     ld e,a
04309E             0668*  ;     pop af ; radius of player or laser sprite
04309E             0669*  ;     add a,e
04309E             0670*  ;     ld e,a
04309E             0671*  ;     and a ; clear carry
04309E             0672*  ;     sbc hl,de
04309E             0673*  ;     jr c,collision_enemy_is
04309E             0674*  ;     xor a
04309E             0675*  ;     ret
04309E             0676*  ; temp fix TODO: remove this
04309E F1          0677*      pop af
04309F F1          0678*      pop af
0430A0 11 00 10 00 0679*      ld de,16*256
0430A4 A7          0680*      and a
0430A5 ED 52       0681*      sbc hl,de
0430A7 38 02       0682*      jr c,collision_enemy_is
0430A9 AF          0683*      xor a
0430AA             0684*      ; call dumpRegistersHex
0430AA C9          0685*      ret
0430AB             0686*  collision_enemy_is:
0430AB AF          0687*      xor a
0430AC 3C          0688*      inc a
0430AD             0689*      ; call dumpRegistersHex
0430AD C9          0690*      ret
0430AE             0691*  
0430AE             0692*  ; ; looks up what enemy sprite collides with
0430AE             0693*  ; ; detects collisions
0430AE             0694*  ; ; and sets things to sploding accordingly
0430AE             0695*  ; check_collisions:
0430AE             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
0430AE             0697*  ;     and a ; if this is zero,
0430AE             0698*  ;     ret z ; there's nothing to do
0430AE             0699*  ;     and %01 ; do we collide with player?
0430AE             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
0430AE             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
0430AE             0702*  ;     and a ; was there a collision?
0430AE             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
0430AE             0704*  ; ; yes collision with player
0430AE             0705*  ;     ; deduct shield damage
0430AE             0706*  ;     ld hl,sprite_shield_damage
0430AE             0707*  ;     ld a,(player_shields)
0430AE             0708*  ;     sub (hl)
0430AE             0709*  ;     ld (player_shields),a
0430AE             0710*  ; ; if shields >= 0,player survives
0430AE             0711*  ;     jp p,check_collisions_kill_nurple
0430AE             0712*  ; ; otherwise update player status so it will die
0430AE             0713*  ;     ld a,(player_collisions)
0430AE             0714*  ;     or %10 ; sets bit 1,meaning player just died
0430AE             0715*  ;     ld (player_collisions),a
0430AE             0716*  ;     ; fall through
0430AE             0717*  ; check_collisions_kill_nurple:
0430AE             0718*  ; ; kill enemy and replace with explosion
0430AE             0719*  ;     call kill_nurple
0430AE             0720*  ;     ret ; and out
0430AE             0721*  
0430AE             0722*  check_collisions:
0430AE CD 6C 30 04 0723*      call collision_enemy_with_player ; did we hit the player?
0430B2 A7          0724*      and a ; was there a collision?
0430B3 C8          0725*      ret z ; if not,we're done
0430B4 CD 4E 30 04 0726*      call kill_nurple ; otherwise kill enemy
0430B8 C9          0727*      ret
0430B9             0728*  
0430B9             0729*  ; did we hit the laser?
0430B9             0730*  move_enemies_laser:
0430B9 FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0430BC E6 02       0732*      and %10 ; do we even collide with laser?
0430BE C8          0733*      ret z ; if not,we're out
0430BF 3A E3 30 04 0734*      ld a,(laser_collisions) ; is laser alive?
0430C3 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
0430C5 C8          0736*      ret z ; so we're out
0430C6 CD 59 30 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
0430CA A7          0738*      and a ; was there a collision?
0430CB C8          0739*      ret z ; if not,we're done
0430CC             0740*  ; otherwise we mark laser for termination and kill enemy
0430CC             0741*  ; update laser status so it will die
0430CC 3A E3 30 04 0742*      ld a,(laser_collisions)
0430D0 F6 02       0743*      or %10 ; bit 1 set means laser just died
0430D2 32 E3 30 04 0744*      ld (laser_collisions),a
0430D6 CD 4E 30 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
0430DA C9          0746*      ret ; we're outta' here
0430DB             0065   	include "laser.inc"
0430DB             0001*  ; ##### LASER SPRITE PARAMETERS #####
0430DB             0002*  ; uses the same offsets from its table base as the main sprite table:
0430DB             0003*  laser_start_variables: ; label marking beginning of table
0430DB 05          0004*  laser_id:               db table_max_records+1
0430DC 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
0430DD 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0430E0 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0430E3 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0430E4 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0430E5 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0430E6 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0430E9 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0430EC 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0430EF 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0430F2 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
0430F5 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0430F8 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
0430FB 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
0430FC 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
0430FD 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
0430FE 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
0430FF 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
043100 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
043101             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
043101             0025*  
043101             0026*  ; laser_control:
043101             0027*  ; ; is laser already active?
043101             0028*  ;     ld a,(laser_collisions)
043101             0029*  ;     and %00000001 ; bit zero is lit if laser is active
043101             0030*  ;     jr nz,laser_move ; move laser if not zero
043101             0031*  ; ; otherwise check if laser fired
043101             0032*  ;     in a,(#82) ; keyboard
043101             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
043101             0034*  ;     ret z ; go back if laser not fired
043101             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
043101             0036*  ; ; set laser status to active (set bit 0)
043101             0037*  ;     ld a,%1
043101             0038*  ;     ld (laser_collisions),a
043101             0039*  ; ; initialize laser position
043101             0040*  ;     ld a,(player_x+1) ; we only need the integer part
043101             0041*  ;     ; add a,6 ; horizontal center with player sprite
043101             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
043101             0043*  ;     ld a,(player_y+1) ; we only need the integer part
043101             0044*  ;     add a,-6 ; set laser y a few pixels above player
043101             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
043101             0046*  ;     ; fall through to laser_move
043101             0047*  
043101             0048*  ; laser_move:
043101             0049*  ; ; begin setting laser to active sprite
043101             0050*  ;     ld hl,lasers
043101             0051*  ;     ld (sprite_base_bufferId),hl
043101             0052*  ;     ld hl,0 ; north
043101             0053*  ;     ld (sprite_heading),hl
043101             0054*  ;     xor a ; laser has no animations yet :-(
043101             0055*  ;     ld (sprite_animation),a
043101             0056*  ;     ; we set position here for the time being as a default
043101             0057*  ;     ; in case the laser is flagged for deletion
043101             0058*  ;     ; load sprite_x with laser x position (we do y further down)
043101             0059*  ;     ld hl,(laser_x)
043101             0060*  ;     ld (sprite_x),hl
043101             0061*  ; ; did laser just die?
043101             0062*  ;     ld a,(laser_collisions)
043101             0063*  ;     bit 1,a ; z if laser didn't just die
043101             0064*  ;     jr z,laser_not_dead_yet
043101             0065*  ; ; yes laser died
043101             0066*  ;     call kill_laser
043101             0067*  ;     ret ; done
043101             0068*  ; laser_not_dead_yet:
043101             0069*  ; ; draw it
043101             0070*  ; ; update laser y position
043101             0071*  ;     ld hl,(laser_y) ; grab laser y position
043101             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
043101             0073*  ;     add hl,de ; add y velocity to y pos
043101             0074*  ;     ld (sprite_y),hl ; update laser y position
043101             0075*  ;     ld (laser_y),hl ; update laser y position
043101             0076*  ; ; are we at top of screen?
043101             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
043101             0078*  ;     sub h ; no carry if above threshold
043101             0079*  ;     jr c,finally_draw_the_frikken_laser
043101             0080*  ;     ; if at top of screen,laser dies
043101             0081*  ;     call kill_laser
043101             0082*  ;     ret
043101             0083*  ; ; otherwise,finally draw the frikken laser
043101             0084*  ; finally_draw_the_frikken_laser:
043101             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043101             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043101             0087*  ; ; all done
043101             0088*  ;     ret
043101             0089*  
043101             0090*  ; kill_laser:
043101             0091*  ; ; update status to inactive
043101             0092*  ;     xor a ; zero out a
043101             0093*  ;     ld (laser_collisions),a
043101             0094*  ;     ret
043101             0066   	include "timer.inc"
043101             0001*  ; Table 32. Timer Control Registers
043101             0002*  ; this constant is the base address of the timer control registers
043101             0003*  ; each timer takes three bytes:
043101             0004*  ;   0: control register
043101             0005*  ;   1: low byte of timer reset value
043101             0006*  ;   2: high byte of timer reset value
043101             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043101             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043101             0009*  TMR_CTL:     equ 80h
043101             0010*  
043101             0011*  ; Timer Control Register Bit Definitions
043101             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043101             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043101             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043101             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043101             0016*                              ; the TMRx_CTL register is read.
043101             0017*  
043101             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043101             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043101             0020*  
043101             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043101             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043101             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043101             0024*                              ; written to the counter when the end-of-count value is reached.
043101             0025*  
043101             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043101             0027*  CLK_DIV_256:  equ %00001100 ;
043101             0028*  CLK_DIV_64:   equ %00001000 ;
043101             0029*  CLK_DIV_16:   equ %00000100 ;
043101             0030*  CLK_DIV_4:    equ %00000000 ;
043101             0031*  
043101             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043101             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043101             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043101             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043101             0036*                              ; programmer must ensure that this bit is set to 1 each time
043101             0037*                              ; SINGLE-PASS mode is used.
043101             0038*  
043101             0039*  ; disable/enable the programmable reload timer
043101             0040*  PRT_EN_0:     equ %00000000 ;
043101             0041*  PRT_EN_1:     equ %00000001 ;
043101             0042*  
043101             0043*  ; Table 37. Timer Input Source Select Register
043101             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043101             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043101             0046*  ;   00: System clock / CLK_DIV
043101             0047*  ;   01: RTC / CLK_DIV
043101             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043101             0049*  ;   10: GPIO port B pin 1.
043101             0050*  ;   11: GPIO port B pin 1.
043101             0051*  TMR_ISS:   equ 92h ; register address
043101             0052*  
043101             0053*  ; Table 51. Real-Time Clock Control Register
043101             0054*  RTC_CTRL: equ EDh ; register address
043101             0055*  
043101             0056*  ; alarm interrupt disable/enable
043101             0057*  RTC_ALARM_0:    equ %00000000
043101             0058*  RTC_ALARM_1:    equ %10000000
043101             0059*  
043101             0060*  ; interrupt on alarm disable/enable
043101             0061*  RTC_INT_ENT_0:  equ %00000000
043101             0062*  RTC_INT_ENT_1:  equ %01000000
043101             0063*  
043101             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043101             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043101             0066*  
043101             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043101             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043101             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043101             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043101             0071*  
043101             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043101             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043101             0074*  
043101             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043101             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043101             0077*  
043101             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043101             0079*                                  ; RTC counter is enabled.
043101             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043101             0081*                                  ; RTC counter is disabled.
043101             0082*  
043101             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043101             0084*  
043101             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043101             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043101 00 00 00    0087*  prt_reload: dl 0x000000
043104             0088*  
043104             0089*  ; set PRT timer
043104             0090*  prt_set:
043104 21 00 00 00 0091*      ld hl,0
043108 22 52 31 04 0092*      ld (prt_irq_counter),hl
04310C 2A 01 31 04 0093*      ld hl,(prt_reload)
043110 ED 29 84    0094*      out0 ($84),l
043113 ED 21 85    0095*  	out0 ($85),h
043116             0096*  ; disable timer
043116 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043118 ED 39 83    0098*  	out0 ($83),a
04311B             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04311B 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04311D ED 39 83    0101*  	out0 ($83),a
043120 C9          0102*      ret
043121             0103*  
043121             0104*  ; ===============================================
043121             0105*  ; PRT Timer Interrupt Handling
043121             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
043121             0107*  ; -----------------------------------------------
043121             0108*  prt_irq_init:
043121             0109*      ; set up interrupt vector table 2
043121 21 00 00 00 0110*  	ld hl,0
043125 3A 0C 01 00 0111*  	ld a,($10c)
043129 6F          0112*  	ld l,a
04312A 3A 0D 01 00 0113*  	ld a,($10d)
04312E 67          0114*  	ld h,a
04312F             0115*  
04312F             0116*  	; skip over CALL ($c3)
04312F 23          0117*  	inc hl
043130             0118*  	; load address of jump into vector table 2 (in ram)
043130 ED 27       0119*  	ld hl,(hl)
043132             0120*  
043132             0121*  	; write CALL prt_irq_handler to vector table 2
043132 3E C3       0122*  	ld a,$c3
043134 77          0123*  	ld (hl),a
043135 23          0124*  	inc hl
043136 11 3D 31 04 0125*  	ld de,prt_irq_handler
04313A ED 1F       0126*  	ld (hl),de
04313C             0127*  
04313C C9          0128*      ret
04313D             0129*  
04313D             0130*  prt_irq_handler:
04313D F3          0131*  	di
04313E F5          0132*  	push af
04313F E5          0133*      push hl
043140 ED 38 83    0134*  	in0 a,($83)
043143 2A 52 31 04 0135*  	ld hl,(prt_irq_counter)
043147 23          0136*  	inc hl
043148 22 52 31 04 0137*  	ld (prt_irq_counter),hl
04314C E1          0138*      pop hl
04314D F1          0139*  	pop af
04314E FB          0140*  	ei
04314F 5B ED 4D    0141*  	reti.l
043152             0142*  
043152             0143*  prt_irq_counter:
043152 00 00 00    0144*  	.dl 0
043155             0145*  prt_irq_counter_saved:
043155 00 00 00    0146*      .dl 0
043158             0147*  
043158             0148*  prt_loop_reset:
043158 E5          0149*      push hl
043159 21 00 00 00 0150*  	ld hl,0
04315D 22 52 31 04 0151*  	ld (prt_irq_counter),hl
043161 22 C3 31 04 0152*      ld (prt_loop_counter),hl
043165 22 C6 31 04 0153*      ld (prt_loops),hl
043169 CD 04 31 04 0154*      call prt_set
04316D E1          0155*      pop hl
04316E C9          0156*      ret
04316F             0157*  
04316F             0158*  prt_loop_start:
04316F E5          0159*      push hl
043170 21 00 00 00 0160*  	ld hl,0
043174 22 52 31 04 0161*  	ld (prt_irq_counter),hl
043178 E1          0162*      pop hl
043179 C9          0163*      ret
04317A             0164*  
04317A             0165*  prt_loop_stop:
04317A E5          0166*      push hl
04317B D5          0167*      push de
04317C 2A 52 31 04 0168*      ld hl,(prt_irq_counter)
043180 ED 5B C3 31 0169*      ld de,(prt_loop_counter)
       04          
043185 19          0170*      add hl,de
043186 22 C3 31 04 0171*      ld (prt_loop_counter),hl
04318A 21 00 00 00 0172*      ld hl,0
04318E 22 52 31 04 0173*      ld (prt_irq_counter),hl
043192 2A C6 31 04 0174*      ld hl,(prt_loops)
043196 23          0175*      inc hl
043197 22 C6 31 04 0176*      ld (prt_loops),hl
04319B D1          0177*      pop de
04319C E1          0178*      pop hl
04319D C9          0179*      ret
04319E             0180*  
04319E             0181*  ; inputs: bc = y,x text coordinates to print
04319E             0182*  prt_loop_print:
04319E F5          0183*      push af
04319F E5          0184*      push hl
0431A0 C5          0185*      push bc
0431A1 D5          0186*      push de
0431A2 DD E5       0187*      push ix
0431A4 FD E5       0188*      push iy
0431A6 CD 5E 1B 04 0189*      call vdu_move_cursor
0431AA             0190*  
0431AA 2A C3 31 04 0191*      ld hl,(prt_loop_counter)
0431AE CD 7C 17 04 0192*      call printDec
0431B2             0193*  
0431B2 2A C6 31 04 0194*      ld hl,(prt_loops)
0431B6 CD 7C 17 04 0195*      call printDec
0431BA             0196*  
0431BA FD E1       0197*      pop iy
0431BC DD E1       0198*      pop ix
0431BE D1          0199*      pop de
0431BF C1          0200*      pop bc
0431C0 E1          0201*      pop hl
0431C1 F1          0202*      pop af
0431C2 C9          0203*      ret
0431C3             0204*  
0431C3             0205*  prt_loop_counter:
0431C3 00 00 00    0206*      .dl 0
0431C6             0207*  prt_loops:
0431C6 00 00 00    0208*      .dl 0
0431C9             0209*  
0431C9             0210*  ; ===============================================
0431C9             0211*  ; Timer functions
0431C9             0212*  ; -----------------------------------------------
0431C9             0213*  ; set a countdown timer
0431C9             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0431C9             0215*  ; returns: hl = current time
0431C9             0216*  tmr_set:
0431C9 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0431CC             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0431CC 3E 08       0001*M 			LD	A, function
0431CE 5B CF       0002*M 			RST.LIL	08h
0431D0 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0431D3 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0431D6 C9          0221*      ret
0431D7             0222*  
0431D7             0223*  ; gets time remaining on a countdown timer
0431D7             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0431D7             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0431D7             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0431D7             0227*  tmr_get:
0431D7             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0431D7 3E 08       0001*M 			LD	A, function
0431D9 5B CF       0002*M 			RST.LIL	08h
0431DB DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0431DE FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0431E1 AF          0231*      xor a                   ; clear carry
0431E2 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0431E4 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0431E7 AF          0234*      xor a                   ; clear carry
0431E8 ED 5A       0235*      adc hl,de               ; hl = time remaining
0431EA             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0431EA C9          0237*      ret
0431EB             0238*  
0431EB             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0431F1             0240*  
0431F1 00 00 00    0241*  timestamp_now: dl 0
0431F4 00 00 00    0242*  timestamp_old: dl 0
0431F7 00 00 00    0243*  timestamp_chg: dl 0
0431FA             0244*  
0431FA             0245*  ; update the global timestamp from the system clock
0431FA             0246*  ; inputs: none
0431FA             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0431FA             0248*  ;          de = current time
0431FA             0249*  ;          ix = pointer to syvars table
0431FA             0250*  ; destroys: af,hl,de,ix
0431FA             0251*  timestamp_tick:
0431FA ED 5B F1 31 0252*      ld de,(timestamp_now)   ; get previous time
       04          
0431FF ED 53 F4 31 0253*      ld (timestamp_old),de   ; save previous time
       04          
043204             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043204 3E 08       0001*M 			LD	A, function
043206 5B CF       0002*M 			RST.LIL	08h
043208 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
04320B 22 F1 31 04 0256*      ld (timestamp_now),hl   ; save current time
04320F AF          0257*      xor a                   ; clear carry
043210 ED 52       0258*      sbc hl,de               ; hl = time elapsed
043212 22 F7 31 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043216 C9          0260*      ret
043217             0261*  
043217             0262*  ; set a countdown timer
043217             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043217             0264*  ; requires: timestamp_tick to be called at least once before this function
043217             0265*  ; returns: hl = current time
043217             0266*  ; destroys: hl
043217             0267*  timestamp_tmr_set:
043217 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
04321A 2A F1 31 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
04321E FD 2F 00    0270*      ld (iy+0),hl            ; set start time
043221 C9          0271*      ret
043222             0272*  
043222             0273*  ; gets time remaining on a countdown timer following the global timestamp
043222             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043222             0275*  ; requires: timestamp_tick to be called at least once before this function
043222             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043222             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
043222             0278*  ; destroys: af,hl,de
043222             0279*  timestamp_tmr_get:
043222 ED 5B F1 31 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043227 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
04322A AF          0282*      xor a                   ; clear carry
04322B ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04322D FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
043230 AF          0285*      xor a                   ; clear carry
043231 ED 5A       0286*      adc hl,de               ; hl = time remaining
043233             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043233 C9          0288*      ret
043234             0289*  
043234             0290*  ; set a stopwatch
043234             0291*  ; returns: hl = start time
043234             0292*  ; destroys: hl,ix
043234             0293*  stopwatch_set:
043234             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043234 3E 08       0001*M 			LD	A, function
043236 5B CF       0002*M 			RST.LIL	08h
043238 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
04323B 22 50 32 04 0296*      ld (stopwatch_started),hl            ; set start time
04323F C9          0297*      ret
043240             0298*  
043240             0299*  ; gets time elapsed on a stopwatch
043240             0300*  ; returns: hl = time elapsed in 1/120ths of a second
043240             0301*  ; destroys: af,hl,de,ix
043240             0302*  stopwatch_get:
043240             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
043240 3E 08       0001*M 			LD	A, function
043242 5B CF       0002*M 			RST.LIL	08h
043244 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043247 ED 5B 50 32 0305*      ld de,(stopwatch_started)            ; get start time
       04          
04324C AF          0306*      xor a                   ; clear carry
04324D ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04324F C9          0308*      ret
043250             0309*  
043250             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043253             0311*  
043253             0312*  ; ------------------
043253             0313*  ; delay routine
043253             0314*  ; Author: Richard Turrnidge
043253             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043253             0316*  ; routine waits a fixed time,then returns
043253             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043253             0318*  ; eg. ld A,00000100b
043253             0319*  
043253             0320*  multiPurposeDelay:
043253 F5          0321*      push af
043254 C5          0322*      push bc
043255 DD E5       0323*      push ix
043257 47          0324*      ld b,a
043258 3E 08       0325*      ld a,$08
04325A 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
04325C             0327*  
04325C             0328*  waitLoop:
04325C             0329*  
04325C DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04325F             0331*  
04325F             0332*                                  ;   we check if bit set is same as last time we checked.
04325F             0333*                                  ;   bit 0 - don't use
04325F             0334*                                  ;   bit 1 - changes 64 times per second
04325F             0335*                                  ;   bit 2 - changes 32 times per second
04325F             0336*                                  ;   bit 3 - changes 16 times per second
04325F             0337*  
04325F             0338*                                  ;   bit 4 - changes 8 times per second
04325F             0339*                                  ;   bit 5 - changes 4 times per second
04325F             0340*                                  ;   bit 6 - changes 2 times per second
04325F             0341*                                  ;   bit 7 - changes 1 times per second
04325F A0          0342*      and b
043260 4F          0343*      ld c,a
043261 3A 72 32 04 0344*      ld a,(oldTimeStamp)
043265 B9          0345*      cp c                        ; is A same as last value?
043266 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043268 79          0347*      ld a,c
043269 32 72 32 04 0348*      ld (oldTimeStamp),a        ; set new value
04326D             0349*  
04326D DD E1       0350*      pop ix
04326F C1          0351*      pop bc
043270 F1          0352*      pop af
043271 C9          0353*      ret
043272             0354*  
043272 00          0355*  oldTimeStamp:   .db 00h
043273             0067   
043273             0068   ; new includes
043273             0069   	include "images.inc"
043273             0001*  image_type: equ 0
043273             0002*  image_width: equ image_type+3
043273             0003*  image_height: equ image_width+3
043273             0004*  image_filesize: equ image_height+3
043273             0005*  image_filename: equ image_filesize+3
043273             0006*  image_bufferId: equ image_filename+3
043273             0007*  image_record_size: equ image_bufferId+3
043273             0008*  
043273 00 00 00    0009*  cur_image_list: dl 0
043276 00 00 00    0010*  cur_file_idx: dl 0
043279 00 00 00    0011*  cur_filename: dl 0
04327C 00 00 00    0012*  cur_buffer_id: dl 0
04327F             0013*  
04327F             0014*  load_ui_images:
04327F             0015*  ; initialize image loading variables
04327F 21 00 00 00 0016*  	ld hl,0
043283 22 76 32 04 0017*  	ld (cur_file_idx),hl
043287 21 61 42 04 0018*  	ld hl,ui_image_list
04328B 22 73 32 04 0019*  	ld (cur_image_list),hl
04328F             0020*  ; load images
04328F 06 02       0021*  	ld b,ui_num_images
043291             0022*  @loop:
043291 C5          0023*  	push bc
043292 CD F4 32 04 0024*  	call load_next_image
043296 C1          0025*  	pop bc
043297 10 F8       0026*  	djnz @loop
043299 C9          0027*  	ret
04329A             0028*  
04329A             0029*  load_sprite_images:
04329A             0030*  ; initialize image loading variables
04329A 21 00 00 00 0031*  	ld hl,0
04329E 22 76 32 04 0032*  	ld (cur_file_idx),hl
0432A2 21 85 33 04 0033*  	ld hl,sprites_image_list
0432A6 22 73 32 04 0034*  	ld (cur_image_list),hl
0432AA 01 59 00 00 0035*  	ld bc,sprites_num_images
0432AE             0036*  ; load images
0432AE CD B3 32 04 0037*  	call img_load_main
0432B2 C9          0038*  	ret
0432B3             0039*  
0432B3             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0432B3             0041*  img_load_main:
0432B3 AF          0042*  	xor a
0432B4 32 76 32 04 0043*      ld (cur_file_idx),a
0432B8             0044*  
0432B8             0045*  img_load_main_loop:
0432B8             0046*  ; back up loop counter
0432B8 C5          0047*      push bc
0432B9             0048*  
0432B9             0049*  ; load the next image
0432B9 CD F4 32 04 0050*      call load_next_image
0432BD             0051*  
0432BD             0052*  ; plot the background
0432BD CD 72 1B 04 0053*  	call vdu_cls
0432C1 21 00 00 00 0054*      ld hl,BUF_SPLASH_BG
0432C5 CD 5F 1C 04 0055*      call vdu_buff_select
0432C9 01 00 00 00 0056*      ld bc,0
0432CD 11 00 00 00 0057*      ld de,0
0432D1 CD 28 1F 04 0058*      call vdu_plot_bmp
0432D5             0059*  
0432D5             0060*  ; ; draw the most recently loaded image
0432D5             0061*  ; 	ld hl,(cur_buffer_id)
0432D5             0062*  ; 	call vdu_buff_select
0432D5             0063*  ; 	ld bc,0
0432D5             0064*  ; 	ld de,0
0432D5             0065*  ; 	call vdu_plot_bmp
0432D5             0066*  
0432D5             0067*  ; move logo
0432D5 CD 54 33 04 0068*  	call move_logo
0432D9             0069*  
0432D9             0070*  ; print current filename
0432D9 2A 79 32 04 0071*  	ld hl,(cur_filename)
0432DD CD 2E 17 04 0072*  	call printString
0432E1             0073*  
0432E1             0074*  ; flip the framebuffer
0432E1 CD 77 1B 04 0075*  	call vdu_flip
0432E5             0076*  
0432E5             0077*  ; decrement loop counter
0432E5 C1          0078*      pop bc
0432E6 0B          0079*  	dec bc
0432E7 79          0080*      ld a,c
0432E8 B7          0081*      or a
0432E9 C2 B8 32 04 0082*      jp nz,img_load_main_loop
0432ED 78          0083*      ld a,b
0432EE B7          0084*      or a
0432EF C2 B8 32 04 0085*      jp nz,img_load_main_loop
0432F3 C9          0086*      ret
0432F4             0087*  
0432F4             0088*  load_next_image:
0432F4 16 12       0089*      ld d,image_record_size
0432F6 3A 76 32 04 0090*  	ld a,(cur_file_idx)
0432FA 5F          0091*  	ld e,a
0432FB ED 5C       0092*      mlt de
0432FD FD 2A 73 32 0093*      ld iy,(cur_image_list)
       04          
043302 FD 19       0094*      add iy,de
043304             0095*  
043304 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
043307 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
04330A FD 17 06    0098*      ld de,(iy+image_height) ; get image height
04330D FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
043310 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
043313 22 7C 32 04 0101*  	ld (cur_buffer_id),hl
043317 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
04331A FD 22 79 32 0103*  	ld (cur_filename),iy
       04          
04331F CD 7D 1D 04 0104*      call vdu_load_img
043323 FD 21 76 32 0105*      ld iy,cur_file_idx
       04          
043328 FD 34 00    0106*  	inc (iy)
04332B C9          0107*  	ret
04332C             0108*  
04332C             0109*  img_load_init:
04332C             0110*  ; initialize logo's position parameters
04332C 21 00 00 00 0111*  	ld hl,0
043330 22 79 33 04 0112*  	ld (logo_xvel),hl
043334 22 7C 33 04 0113*  	ld (logo_xpos),hl
043338             0114*  ; begin 16.8 maths to determine logo's y position and velocity
043338 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
04333C 22 82 33 04 0116*  	ld (logo_ypos),hl
043340 EB          0117*  	ex de,hl
043341 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
043345 19          0119*  	add hl,de ; distance for logo to travel
043346 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
04334A CD 69 2C 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
04334E ED 53 7F 33 0122*  	ld (logo_yvel),de
       04          
043353             0123*  ; all done
043353 C9          0124*      ret
043354             0125*  
043354             0126*  move_logo:
043354             0127*  ; activate logo bitmap
043354 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
043358 CD 5F 1C 04 0129*  	call vdu_buff_select
04335C             0130*  ; update position based on velocity parameters
04335C 2A 82 33 04 0131*  	ld hl,(logo_ypos)
043360 ED 5B 7F 33 0132*  	ld de,(logo_yvel)
       04          
043365 19          0133*  	add hl,de
043366 22 82 33 04 0134*  	ld (logo_ypos),hl
04336A             0135*  ; draw logo
04336A ED 4B 7C 33 0136*  	ld bc,(logo_xpos)
       04          
04336F ED 5B 82 33 0137*  	ld de,(logo_ypos)
       04          
043374 CD 44 1F 04 0138*  	call vdu_plot_bmp168
043378 C9          0139*  	ret
043379             0140*  
043379 00 00 00    0141*  logo_xvel: dl 0
04337C 00 00 00    0142*  logo_xpos: dl 0
04337F             0143*  
04337F 00 00 00    0144*  logo_yvel: dl 0
043382 00 00 00    0145*  logo_ypos: dl 0
043385             0070   	include "images_sprites.inc"
043385             0001*  ; Generated by make_images.py
043385             0002*  
043385             0003*  sprites_num_images: equ 89
043385             0004*  
043385             0005*  ; buffer_ids:
043385             0006*  BUF_0TILE_EMPTY: equ 256
043385             0007*  BUF_1TILE_CROSS: equ 257
043385             0008*  BUF_2TILE_HORIZ: equ 258
043385             0009*  BUF_3TILE_VERT: equ 259
043385             0010*  BUF_4TILE_SQUARE: equ 260
043385             0011*  BUF_5TILE_CIRCLE: equ 261
043385             0012*  BUF_6TILE_PAD: equ 262
043385             0013*  BUF_7TILE_TURRET: equ 263
043385             0014*  BUF_CIRCLE: equ 264
043385             0015*  BUF_CRATER: equ 265
043385             0016*  BUF_EXPLOSION_A: equ 266
043385             0017*  BUF_EXPLOSION_B: equ 267
043385             0018*  BUF_EXPLOSION_C: equ 268
043385             0019*  BUF_EXPLOSION_D: equ 269
043385             0020*  BUF_EXPLOSION_E: equ 270
043385             0021*  BUF_FIREBALL_A: equ 271
043385             0022*  BUF_FIREBALL_B: equ 272
043385             0023*  BUF_LASER_A: equ 273
043385             0024*  BUF_LASER_B: equ 274
043385             0025*  BUF_PAD: equ 275
043385             0026*  BUF_SEEKER_000: equ 276
043385             0027*  BUF_SEEKER_008: equ 277
043385             0028*  BUF_SEEKER_016: equ 278
043385             0029*  BUF_SEEKER_024: equ 279
043385             0030*  BUF_SEEKER_032: equ 280
043385             0031*  BUF_SEEKER_040: equ 281
043385             0032*  BUF_SEEKER_048: equ 282
043385             0033*  BUF_SEEKER_056: equ 283
043385             0034*  BUF_SEEKER_064: equ 284
043385             0035*  BUF_SEEKER_072: equ 285
043385             0036*  BUF_SEEKER_080: equ 286
043385             0037*  BUF_SEEKER_088: equ 287
043385             0038*  BUF_SEEKER_096: equ 288
043385             0039*  BUF_SEEKER_104: equ 289
043385             0040*  BUF_SEEKER_112: equ 290
043385             0041*  BUF_SEEKER_120: equ 291
043385             0042*  BUF_SEEKER_128: equ 292
043385             0043*  BUF_SEEKER_136: equ 293
043385             0044*  BUF_SEEKER_144: equ 294
043385             0045*  BUF_SEEKER_152: equ 295
043385             0046*  BUF_SEEKER_160: equ 296
043385             0047*  BUF_SEEKER_168: equ 297
043385             0048*  BUF_SEEKER_176: equ 298
043385             0049*  BUF_SEEKER_184: equ 299
043385             0050*  BUF_SEEKER_192: equ 300
043385             0051*  BUF_SEEKER_200: equ 301
043385             0052*  BUF_SEEKER_208: equ 302
043385             0053*  BUF_SEEKER_216: equ 303
043385             0054*  BUF_SEEKER_224: equ 304
043385             0055*  BUF_SEEKER_232: equ 305
043385             0056*  BUF_SEEKER_240: equ 306
043385             0057*  BUF_SEEKER_248: equ 307
043385             0058*  BUF_SHIP_0L: equ 308
043385             0059*  BUF_SHIP_1C: equ 309
043385             0060*  BUF_SHIP_2R: equ 310
043385             0061*  BUF_SHIP_SMALL: equ 311
043385             0062*  BUF_STAR: equ 312
043385             0063*  BUF_TURRET_000: equ 313
043385             0064*  BUF_TURRET_008: equ 314
043385             0065*  BUF_TURRET_016: equ 315
043385             0066*  BUF_TURRET_024: equ 316
043385             0067*  BUF_TURRET_032: equ 317
043385             0068*  BUF_TURRET_040: equ 318
043385             0069*  BUF_TURRET_048: equ 319
043385             0070*  BUF_TURRET_056: equ 320
043385             0071*  BUF_TURRET_064: equ 321
043385             0072*  BUF_TURRET_072: equ 322
043385             0073*  BUF_TURRET_080: equ 323
043385             0074*  BUF_TURRET_088: equ 324
043385             0075*  BUF_TURRET_096: equ 325
043385             0076*  BUF_TURRET_104: equ 326
043385             0077*  BUF_TURRET_112: equ 327
043385             0078*  BUF_TURRET_120: equ 328
043385             0079*  BUF_TURRET_128: equ 329
043385             0080*  BUF_TURRET_136: equ 330
043385             0081*  BUF_TURRET_144: equ 331
043385             0082*  BUF_TURRET_152: equ 332
043385             0083*  BUF_TURRET_160: equ 333
043385             0084*  BUF_TURRET_168: equ 334
043385             0085*  BUF_TURRET_176: equ 335
043385             0086*  BUF_TURRET_184: equ 336
043385             0087*  BUF_TURRET_192: equ 337
043385             0088*  BUF_TURRET_200: equ 338
043385             0089*  BUF_TURRET_208: equ 339
043385             0090*  BUF_TURRET_216: equ 340
043385             0091*  BUF_TURRET_224: equ 341
043385             0092*  BUF_TURRET_232: equ 342
043385             0093*  BUF_TURRET_240: equ 343
043385             0094*  BUF_TURRET_248: equ 344
043385             0095*  
043385             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
043385 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       C7 39 04 00 
       01 00       
043397 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       E1 39 04 01 
       01 00       
0433A9 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       FB 39 04 02 
       01 00       
0433BB 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       15 3A 04 03 
       01 00       
0433CD 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       2E 3A 04 04 
       01 00       
0433DF 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       49 3A 04 05 
       01 00       
0433F1 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       64 3A 04 06 
       01 00       
043403 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       7C 3A 04 07 
       01 00       
043415 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       97 3A 04 08 
       01 00       
043427 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       AC 3A 04 09 
       01 00       
043439 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       C1 3A 04 0A 
       01 00       
04344B 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       DB 3A 04 0B 
       01 00       
04345D 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       F5 3A 04 0C 
       01 00       
04346F 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       0F 3B 04 0D 
       01 00       
043481 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       29 3B 04 0E 
       01 00       
043493 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       43 3B 04 0F 
       01 00       
0434A5 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       5C 3B 04 10 
       01 00       
0434B7 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       75 3B 04 11 
       01 00       
0434C9 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       8B 3B 04 12 
       01 00       
0434DB 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       A1 3B 04 13 
       01 00       
0434ED 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       B3 3B 04 14 
       01 00       
0434FF 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       CC 3B 04 15 
       01 00       
043511 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       E5 3B 04 16 
       01 00       
043523 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       FE 3B 04 17 
       01 00       
043535 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       17 3C 04 18 
       01 00       
043547 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       30 3C 04 19 
       01 00       
043559 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       49 3C 04 1A 
       01 00       
04356B 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       62 3C 04 1B 
       01 00       
04357D 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       7B 3C 04 1C 
       01 00       
04358F 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       94 3C 04 1D 
       01 00       
0435A1 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       AD 3C 04 1E 
       01 00       
0435B3 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       C6 3C 04 1F 
       01 00       
0435C5 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       DF 3C 04 20 
       01 00       
0435D7 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       F8 3C 04 21 
       01 00       
0435E9 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       11 3D 04 22 
       01 00       
0435FB 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       2A 3D 04 23 
       01 00       
04360D 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       43 3D 04 24 
       01 00       
04361F 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       5C 3D 04 25 
       01 00       
043631 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       75 3D 04 26 
       01 00       
043643 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       8E 3D 04 27 
       01 00       
043655 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       A7 3D 04 28 
       01 00       
043667 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       C0 3D 04 29 
       01 00       
043679 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       D9 3D 04 2A 
       01 00       
04368B 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       F2 3D 04 2B 
       01 00       
04369D 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       0B 3E 04 2C 
       01 00       
0436AF 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       24 3E 04 2D 
       01 00       
0436C1 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       3D 3E 04 2E 
       01 00       
0436D3 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       56 3E 04 2F 
       01 00       
0436E5 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       6F 3E 04 30 
       01 00       
0436F7 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       88 3E 04 31 
       01 00       
043709 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       A1 3E 04 32 
       01 00       
04371B 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       BA 3E 04 33 
       01 00       
04372D 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       D3 3E 04 34 
       01 00       
04373F 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       E9 3E 04 35 
       01 00       
043751 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       FF 3E 04 36 
       01 00       
043763 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       15 3F 04 37 
       01 00       
043775 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       2E 3F 04 38 
       01 00       
043787 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       41 3F 04 39 
       01 00       
043799 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       5A 3F 04 3A 
       01 00       
0437AB 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       73 3F 04 3B 
       01 00       
0437BD 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       8C 3F 04 3C 
       01 00       
0437CF 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       A5 3F 04 3D 
       01 00       
0437E1 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       BE 3F 04 3E 
       01 00       
0437F3 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       D7 3F 04 3F 
       01 00       
043805 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       F0 3F 04 40 
       01 00       
043817 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       09 40 04 41 
       01 00       
043829 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       22 40 04 42 
       01 00       
04383B 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       3B 40 04 43 
       01 00       
04384D 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       54 40 04 44 
       01 00       
04385F 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       6D 40 04 45 
       01 00       
043871 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       86 40 04 46 
       01 00       
043883 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       9F 40 04 47 
       01 00       
043895 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       B8 40 04 48 
       01 00       
0438A7 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       D1 40 04 49 
       01 00       
0438B9 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       EA 40 04 4A 
       01 00       
0438CB 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       03 41 04 4B 
       01 00       
0438DD 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       1C 41 04 4C 
       01 00       
0438EF 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       35 41 04 4D 
       01 00       
043901 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       4E 41 04 4E 
       01 00       
043913 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       67 41 04 4F 
       01 00       
043925 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       80 41 04 50 
       01 00       
043937 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       99 41 04 51 
       01 00       
043949 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       B2 41 04 52 
       01 00       
04395B 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       CB 41 04 53 
       01 00       
04396D 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       E4 41 04 54 
       01 00       
04397F 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       FD 41 04 55 
       01 00       
043991 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       16 42 04 56 
       01 00       
0439A3 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       2F 42 04 57 
       01 00       
0439B5 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       48 42 04 58 
       01 00       
0439C7             0186*  
0439C7             0187*  ; files_list: ; filename:
0439C7 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
0439E1 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
0439FB 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043A15 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043A2E 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043A49 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043A64 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043A7C 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043A97 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043AAC 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043AC1 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043ADB 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043AF5 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043B0F 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043B29 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043B43 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043B5C 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043B75 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043B8B 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043BA1 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043BB3 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043BCC 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043BE5 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043BFE 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043C17 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043C30 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043C49 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043C62 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043C7B 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043C94 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043CAD 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043CC6 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043CDF 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043CF8 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043D11 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043D2A 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043D43 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043D5C 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043D75 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043D8E 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043DA7 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043DC0 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043DD9 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043DF2 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043E0B 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043E24 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
043E3D 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
043E56 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
043E6F 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
043E88 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
043EA1 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
043EBA 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
043ED3 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
043EE9 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
043EFF 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
043F15 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
043F2E 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
043F41 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043F5A 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043F73 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043F8C 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043FA5 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043FBE 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043FD7 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043FF0 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
044009 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
044022 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
04403B 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
044054 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04406D 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
044086 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
04409F 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0440B8 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
0440D1 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
0440EA 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
044103 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
04411C 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
044135 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
04414E 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
044167 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044180 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044199 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0441B2 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0441CB 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
0441E4 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0441FD 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
044216 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
04422F 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
044248 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044261             0071   	include "images_ui.inc"
044261             0001*  ; Generated by make_images.py
044261             0002*  
044261             0003*  ui_num_images: equ 2
044261             0004*  
044261             0005*  ; buffer_ids:
044261             0006*  BUF_SPLASH_BG: equ 0
044261             0007*  BUF_SPLASH_LOGO: equ 1
044261             0008*  
044261             0009*  ui_image_list: ; type; width; height; filename; bufferId:
044261 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       85 42 04 00 
       00 00       
044273 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       98 42 04 01 
       00 00       
044285             0012*  
044285             0013*  ; files_list: ; filename:
044285 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
044298 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
0442AD             0072   	include "files.inc"
0442AD             0001*  ; load to onboard 8k sram
0442AD             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0442AD             0073   
0442AD 57 65 6C 63 0074   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
0442C8 4C 6F 61 64 0075   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
0442D3 4C 6F 61 64 0076   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0442E1 50 72 65 73 0077   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0442FC             0078   
0442FC             0079   init:
0442FC             0080   ; clear all buffers
0442FC CD 51 1D 04 0081       call vdu_clear_all_buffers
044300             0082   
044300             0083   ; set up the display
044300 3E 88       0084       ld a,8+128 ; 136   320   240   64    60hz double-buffered
044302 CD 3B 1C 04 0085       call vdu_set_screen_mode
044306 AF          0086       xor a
044307 CD 4C 1C 04 0087       call vdu_set_scaling
04430B             0088   
04430B             0089   ; ; enable additional audio channels
04430B             0090   ; 	call vdu_enable_channels
04430B             0091   
04430B             0092   ; set text background color
04430B 3E 84       0093   	ld a,4 + 128
04430D CD A3 1B 04 0094   	call vdu_colour_text
044311             0095   
044311             0096   ; set text foreground color
044311 3E 2F       0097   	ld a,47 ; aaaaff lavenderish
044313 CD A3 1B 04 0098   	call vdu_colour_text
044317             0099   
044317             0100   ; set gfx bg color
044317 AF          0101   	xor a ; plotting mode 0
044318 0E 84       0102   	ld c,4+128 ; dark blue bg
04431A CD B4 1B 04 0103   	call vdu_gcol
04431E CD 85 1B 04 0104   	call vdu_clg
044322             0105   
044322             0106   ; set the cursor off
044322 CD 3A 1B 04 0107   	call vdu_cursor_off
044326             0108   
044326             0109   ; VDU 28, left, bottom, right, top: Set text viewport **
044326             0110   ; MIND THE LITTLE-ENDIANESS
044326             0111   ; inputs: c=left,b=bottom,e=right,d=top
044326 0E 00       0112   	ld c,0 ; left
044328 16 1D       0113   	ld d,29 ; top
04432A 1E 27       0114   	ld e,39 ; right
04432C 06 1D       0115   	ld b,29; bottom
04432E CD CB 1B 04 0116   	call vdu_set_txt_viewport
044332             0117   
044332             0118   ; print loading ui message
044332 21 C8 42 04 0119   	ld hl,loading_ui
044336 CD 2E 17 04 0120   	call printString
04433A CD 77 1B 04 0121   	call vdu_flip
04433E             0122   
04433E             0123   ; load UI images
04433E CD 7F 32 04 0124   	call load_ui_images
044342             0125   
044342             0126   ; ; load fonts ; TODO
044342             0127   ; 	call load_font_rc
044342             0128   
044342             0129   ; load sprites
044342 CD 2C 33 04 0130   	call img_load_init ; sets up the animated load screen
044346 CD 9A 32 04 0131   	call load_sprite_images
04434A             0132   
04434A             0133   ; ; load sound effects ; TODO
04434A             0134   ; 	ld bc,SFX_num_buffers
04434A             0135   ; 	ld hl,SFX_buffer_id_lut
04434A             0136   ; 	ld (cur_buffer_id_lut),hl
04434A             0137   ; 	ld hl,SFX_load_routines_table
04434A             0138   ; 	ld (cur_load_jump_table),hl
04434A             0139   ; 	call sfx_load_main
04434A             0140   
04434A             0141   ; print loading complete message and wait for user keypress
04434A CD 72 1B 04 0142   	call vdu_cls
04434E 21 E1 42 04 0143   	ld hl,loading_complete
044352 CD 2E 17 04 0144   	call printString
044356 CD 77 1B 04 0145   	call vdu_flip
04435A CD AA 1A 04 0146   	call waitKeypress
04435E             0147   
04435E             0148   ; set up display for gameplay
04435E 3E 08       0149       ld a,8
044360 CD 3B 1C 04 0150       call vdu_set_screen_mode
044364 AF          0151       xor a
044365 CD 4C 1C 04 0152       call vdu_set_scaling
044369 01 20 00 00 0153   	ld bc,32
04436D 11 10 00 00 0154   	ld de,16
044371 CD F7 1B 04 0155   	call vdu_set_gfx_origin
044375 CD 3A 1B 04 0156   	call vdu_cursor_off
044379             0157   ; set gfx viewport to scrolling window
044379 01 00 00 00 0158   	ld bc,0
04437D 11 00 00 00 0159   	ld de,0
044381 DD 21 FF 00 0160   	ld ix,255
       00          
044386 FD 21 DF 00 0161   	ld iy,239-16
       00          
04438B CD 12 1C 04 0162   	call vdu_set_gfx_viewport
04438F             0163   
04438F C9          0164   	ret
044390             0165   
044390             0166   new_game:
044390             0167   ; initialize sprites
044390 CD ED 16 04 0168   	call sprites_init
044394             0169   
044394             0170   ; initialize the first level
044394 AF          0171   	xor a
044395 32 BA 2D 04 0172   	ld (cur_level),a
044399 CD 42 2E 04 0173   	call init_level
04439D             0174   
04439D             0175   ; initialize player
04439D CD E0 2C 04 0176   	call player_init
0443A1             0177   
0443A1             0178   ; spawn an enemy sprite
0443A1 06 04       0179   	ld b,table_max_records
0443A3             0180   @spawn_enemy_loop:
0443A3 C5          0181   	push bc
0443A4 CD 8F 2F 04 0182   	call enemy_init_from_landing_pad
0443A8 C1          0183   	pop bc
0443A9 10 F8       0184   	djnz @spawn_enemy_loop
0443AB             0185   
0443AB C9          0186   	ret
0443AC             0187   
0443AC             0188   ; ; ###### INITIALIZE GAME #######
0443AC             0189   ; ; clear the screen
0443AC             0190   ;     ld a,3
0443AC             0191   ;     out (81h),a
0443AC             0192   
0443AC             0193   ; ; reset the sprite table
0443AC             0194   ;     xor a
0443AC             0195   ;     ld (table_active_sprites),a
0443AC             0196   ;     ld hl,table_limit
0443AC             0197   ;     ld (table_base),hl
0443AC             0198   ;     ld (table_pointer),hl
0443AC             0199   
0443AC             0200   ; ; draw a starfield over the entire screen
0443AC             0201   ;     ld b,#50 ; first row of visible screen
0443AC             0202   ; new_game_draw_stars_loop:
0443AC             0203   ;     push bc
0443AC             0204   ;     call draw_stars
0443AC             0205   ;     pop bc
0443AC             0206   ;     ld a,#10
0443AC             0207   ;     add a,b
0443AC             0208   ;     ld b,a
0443AC             0209   ;     jr nz,new_game_draw_stars_loop
0443AC             0210   
0443AC             0211   ; ; ; print a welcome message
0443AC             0212   ; ;     ld de,msg_welcome
0443AC             0213   ; ;     ld hl,#581C
0443AC             0214   ; ;     ld c,218 ; a bright pastel purple d677e3
0443AC             0215   ; ;     call print_string
0443AC             0216   
0443AC             0217   ; ; push all that to frame buffer
0443AC             0218   ;     ld a,#01 ; send video to frame buffer
0443AC             0219   ;     out (81h),a
0443AC             0220   
0443AC             0221   ; ; reset score, lives, shields
0443AC             0222   ;     xor a
0443AC             0223   ;     ld hl,player_score
0443AC             0224   ;     ld (hl),a ; player_score 0
0443AC             0225   ;     inc hl
0443AC             0226   ;     ld (hl),a ; player_score 1
0443AC             0227   ;     inc hl
0443AC             0228   ;     ld (hl),a ; player_score 3
0443AC             0229   ;     inc hl
0443AC             0230   ;     ld a,16
0443AC             0231   ;     ld (hl),a ; player_shields
0443AC             0232   ;     inc hl
0443AC             0233   ;     ld (hl),a ; player_max_shields
0443AC             0234   ;     inc hl
0443AC             0235   ;     ld a,3
0443AC             0236   ;     ld (hl),a ; player_ships
0443AC             0237   ;     inc hl
0443AC             0238   
0443AC             0239   ; ; initialize first level
0443AC             0240   ;     ld a,1 ; levels are zero-based, so this will wrap around
0443AC             0241   ;     ld (cur_level),a
0443AC             0242   ;     ld a,3 ; set max enemy sprites to easy street
0443AC             0243   ;     ; ld a,64 ; DEBUG: BRING IT
0443AC             0244   ;     ld (max_enemy_sprites),a
0443AC             0245   ;     call dt_next_level
0443AC             0246   ;     call dt
0443AC             0247   
0443AC             0248   ; ; spawn our intrepid hero
0443AC             0249   ;     call player_init
0443AC             0250   
0443AC             0251   ; ; #### BEGIN GAME VARIABLES ####
0443AC             0252   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
0443AC             0253   speed_player: equ 0x000300 ; 3 pixels per frame
0443AC             0254   
0443AC             0255   main:
0443AC             0256   ; start a new game
0443AC CD 90 43 04 0257   	call new_game
0443B0             0258   
0443B0             0259   main_loop:
0443B0             0260   ; move the background down one pixel
0443B0 3E 02       0261   	ld a,2 ; current gfx viewport
0443B2 2E 02       0262   	ld l,2 ; direction=down
0443B4 26 01       0263   	ld h,1 ; speed=1 px
0443B6 CD 8A 1B 04 0264   	call vdu_scroll_down
0443BA             0265   
0443BA             0266   ; scroll tiles
0443BA CD C7 2D 04 0267   	call tiles_plot
0443BE             0268   
0443BE             0269   ; get player input and update sprite position
0443BE CD 1F 2D 04 0270   	call player_input
0443C2             0271   
0443C2             0272   ; move enemies
0443C2 CD A1 2E 04 0273   	call move_enemies
0443C6             0274   
0443C6             0275   ; wait for the next vblank mitigate flicker and for loop timing
0443C6 CD E6 1B 04 0276   	call vdu_vblank
0443CA             0277   
0443CA             0278   ; poll keyboard
0443CA 3E 08       0279       ld a, $08                           ; code to send to MOS
0443CC 5B CF       0280       rst.lil $08                         ; get IX pointer to System Variables
0443CE             0281   
0443CE DD 7E 05    0282       ld a, (ix + $05)                    ; get ASCII code of key pressed
0443D1 FE 1B       0283       cp 27                               ; check if 27 (ascii code for ESC)
0443D3 CA DB 43 04 0284       jp z, main_end                     ; if pressed, jump to exit
0443D7             0285   
0443D7 C3 B0 43 04 0286       jp main_loop
0443DB             0287   
0443DB             0288   main_end:
0443DB CD 2C 1B 04 0289       call vdu_cursor_on
0443DF C9          0290   	ret
0443E0             0291   
0443E0             0292   
0443E0             0293   ; ; #### BEGIN GAME MAIN LOOP ####
0443E0             0294   ; main_loop:
0443E0             0295   ; ; ; debug: start execution counter
0443E0             0296   ; ;     ld a,1
0443E0             0297   ; ;     out (#e0),a ; start counting instructions
0443E0             0298   
0443E0             0299   ; ; refresh background from frame buffer
0443E0             0300   ;     ld a,#02
0443E0             0301   ;     out (81h),a
0443E0             0302   ;     call move_background ; now move it
0443E0             0303   ;     ld a,#01
0443E0             0304   ;     out (81h),a ; save it back to buffer
0443E0             0305   ; ; do all the things
0443E0             0306   ;     call move_enemies
0443E0             0307   ;     call player_move
0443E0             0308   ;     call laser_control
0443E0             0309   ;     call print_score
0443E0             0310   ;     call draw_shields
0443E0             0311   ;     call draw_lives
0443E0             0312   ; ; ; debug: stop execution counter and print results
0443E0             0313   ; ;     ld a,0
0443E0             0314   ; ;     out (#e0),a ; stop counting instructions
0443E0             0315   
0443E0             0316   ; ; ; debug: start execution counter
0443E0             0317   ; ;     ld a,1
0443E0             0318   ; ;     out (#e0),a ; start counting instructions
0443E0             0319   
0443E0             0320   ;     call vdu_vblank
0443E0             0321   ; ; ; debug: stop execution counter and print results
0443E0             0322   ; ;     ld a,0
0443E0             0323   ; ;     out (#e0),a ; stop counting instructions
0443E0             0324   
0443E0             0325   ;     jr main_loop
0443E0             0326   ; #### END GAME MAIN LOOP ####
0443E0             0327   
0443E0             0328   ; draws the player's shields level
0443E0             0329   ; draw_shields:
0443E0             0330   ; TODO: Agonize this routine
0443E0             0331   ; ; prep the loop to draw the bars
0443E0             0332   ;     ld a,(player_shields) ; snag shields
0443E0             0333   ;     and a
0443E0             0334   ;     ret z ; don't draw if zero shields
0443E0             0335   ; ; set loop counter and drawing position
0443E0             0336   ;     ld b,a ; loop counter
0443E0             0337   ;     ld hl,#5300+48+12
0443E0             0338   ; ; set color based on bars remaining
0443E0             0339   ;     ld c,103 ; bright green 28fe0a
0443E0             0340   ;     cp 9
0443E0             0341   ;     jp p,draw_shields_loop
0443E0             0342   ;     ld c,74 ; bright yellow eafe5b
0443E0             0343   ;     cp 3
0443E0             0344   ;     jp p,draw_shields_loop
0443E0             0345   ;     ld c,28 ; bright red fe0a0a
0443E0             0346   ; draw_shields_loop:
0443E0             0347   ;     push bc ; yup,outta
0443E0             0348   ;     push hl ; registers again
0443E0             0349   ;     ; ld a,#A8 ; ▀,168
0443E0             0350   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
0443E0             0351   ;     ; call draw_char
0443E0             0352   ;     call draw_num ; we nuked draw_char for the time being
0443E0             0353   ;     pop hl
0443E0             0354   ;     ld a,8
0443E0             0355   ;     add a,l
0443E0             0356   ;     ld l,a
0443E0             0357   ;     pop bc
0443E0             0358   ;     djnz draw_shields_loop
0443E0             0359       ; ret
0443E0             0360   
0443E0             0361   ; prints the player's score
0443E0             0362   ; print_score:
0443E0             0363   ; TODO: Agonize this
0443E0             0364   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0443E0             0365   ;     ld c,42 ; dark orange b74400
0443E0             0366   ;     ld hl,#5200+1+8+6*6
0443E0             0367   ;     ld a,3 ; print 6 bdc digits
0443E0             0368   ;     ld de,player_score
0443E0             0369   ;     call print_num
0443E0             0370   
0443E0             0371   ;     ld c,58 ; golden yellow fec10a
0443E0             0372   ;     ld hl,#5100+8+6*6
0443E0             0373   ;     ld a,3 ; print 6 bdc digits
0443E0             0374   ;     ld de,player_score
0443E0             0375   ;     call print_num
0443E0             0376       ; ret
0443E0             0377   
0443E0             0378   ; draw_lives:
0443E0             0379   ;     ld hl,player_small ; make small yellow ship the active sprite
0443E0             0380   ;     ld (sprite_base_bufferId),hl
0443E0             0381   ;     ; ld a,#80 ; northern orientation
0443E0             0382   ;     ; ld (sprite_orientation),a
0443E0             0383   ;     ld hl,0 ; north
0443E0             0384   ;     ld (sprite_heading),hl
0443E0             0385   ;     xor a
0443E0             0386   ;     ld (sprite_animation),a
0443E0             0387   ;     ld a,#56 ; top of visible screen
0443E0             0388   ;     ld (sprite_y+1),a
0443E0             0389   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0443E0             0390   ;     ld a,(player_ships)
0443E0             0391   ;     dec a ; we draw one fewer ships than lives
0443E0             0392   ;     ret z ; nothing to draw here, move along
0443E0             0393   ;     ld b,a ; loop counter
0443E0             0394   ;     ld a,256-16 ; initial x position
0443E0             0395   ; draw_lives_loop:
0443E0             0396   ;     ld (sprite_x+1),a
0443E0             0397   ;     push af
0443E0             0398   ;     push bc
0443E0             0399   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0443E0             0400   ;     pop bc
0443E0             0401   ;     pop af
0443E0             0402   ;     sub 10
0443E0             0403   ;     djnz draw_lives_loop
0443E0             0404   ;     ret
