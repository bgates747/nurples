PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD D3 44 04 0030   	call	init			; Initialization code
040050 CD 83 45 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 1 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
041608             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041608             0033*  
041608             0034*  ; pointer to top address of current record, initialized to table_base
041608 E2 15 04    0035*  table_pointer: dl table_base
04160B             0036*  ; how many active sprites
04160B 00          0037*  table_active_sprites: db 0x00
04160C             0038*  ; flag indicating collision with screen edge
04160C             0039*  ; uses orientation codes to specify which edge(s)
04160C 00          0040*  sprite_screen_edge: db #00
04160D             0041*  ; next sprite id to use
04160D 00          0042*  sprite_next_id: db 0
04160E             0043*  
04160E             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
04160E             0045*  ; integer coordinates are all that are needed for collision calculations
04160E 00          0046*  collision_x: db 0x00
04160F 00          0047*  collision_y: db 0x00
041610 00          0048*  collision_dim_x: db 0x00
041611 00          0049*  collision_dim_y: db 0x00
041612             0050*  
041612             0051*  ; scratch variables
041612 00          0052*  x: db 0x00 ; 8-bit signed integer
041613 00          0053*  y: db 0x00 ; 8-bit signed integer
041614 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041617 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04161A 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04161D 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041620 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041623 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041626             0060*  
041626             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041626 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041629 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162C 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162F             0065*  
04162F             0066*  ; gets the next available sprite id
04162F             0067*  ; inputs; none
04162F             0068*  ; returns: if new sprite available, a = sprite id,
04162F             0069*  ;           ix pointing to new sprite vars, carry set
04162F             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
04162F             0071*  ; destroys: a,b,hl,ix
04162F             0072*  ; affects: bumps table_active_sprites by one
04162F             0073*  table_get_next_id:
04162F DD 21 E2 15 0074*      ld ix,table_base
       04          
041634 11 26 00 00 0075*      ld de,table_bytes_per_record
041638 06 01       0076*      ld b,table_max_records
04163A             0077*  @loop:
04163A DD 7E 01    0078*      ld a,(ix+sprite_type)
04163D A7          0079*      and a
04163E 28 06       0080*      jr z,@found
041640 DD 19       0081*      add ix,de
041642 10 F6       0082*      djnz @loop
041644             0083*  @notfound:
041644 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
041645 C9          0085*      ret
041646             0086*  @found:
041646             0087*  ; bump number of active sprites
041646 21 0B 16 04 0088*      ld hl,table_active_sprites
04164A 34          0089*      inc (hl)
04164B             0090*  ; return sprite id
04164B 3E 01       0091*      ld a,table_max_records
04164D 90          0092*      sub b
04164E 32 0D 16 04 0093*      ld (sprite_next_id),a
041652 37          0094*      scf ; sets carry flag indicating we found a free sprite
041653 C9          0095*      ret ; done
041654             0096*  
041654             0097*  ; deactivate the sprite with the given id
041654             0098*  ; inputs: a = sprite id
041654             0099*  ; outputs: nothing
041654             0100*  ; destroys: a,ix,de
041654             0101*  ; affects: decrements table_active_sprites by one
041654             0102*  table_deactivate_sprite:
041654 F5          0103*      push af ; save sprite id bc we need it later
041655 CD 8C 21 04 0104*      call vdu_sprite_select
041659 CD 10 22 04 0105*      call vdu_sprite_hide
04165D F1          0106*      pop af ; restore sprite id
04165E 11 00 00 00 0107*      ld de,0 ; clear deu
041662 57          0108*      ld d,a
041663 1E 26       0109*      ld e,table_bytes_per_record
041665 ED 5C       0110*      mlt de
041667 DD 21 E2 15 0111*      ld ix,table_base
       04          
04166C DD 19       0112*      add ix,de
04166E AF          0113*      xor a
04166F DD 77 01    0114*      ld (ix+sprite_type),a
041672 DD 21 0B 16 0115*      ld ix,table_active_sprites
       04          
041677 DD 35 00    0116*      dec (ix)
04167A C9          0117*      ret
04167B             0118*  
04167B             0119*  sprites_init:
04167B             0120*  ; initialize sprites
04167B CD B8 22 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
04167F AF          0122*  	xor a
041680             0123*  @sprite_loop:
041680 F5          0124*  	push af
041681 CD 8C 21 04 0125*  	call vdu_sprite_select
041685 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
041689 CD D9 22 04 0127*  	call vdu_sprite_add_buff
04168D F1          0128*  	pop af
04168E 3C          0129*  	inc a
04168F FE 02       0130*  	cp table_max_records+1 ; tack on sprites for player and laser
041691 20 ED       0131*  	jr nz,@sprite_loop
041693 3C          0132*  	inc a
041694 CD C0 21 04 0133*  	call vdu_sprite_activate
041698             0134*  
041698             0135*  ; define player sprite
041698 3A B5 2E 04 0136*  	ld a,(player_id)
04169C CD 8C 21 04 0137*  	call vdu_sprite_select
0416A0 CD 9F 21 04 0138*  	call vdu_sprite_clear_frames
0416A4 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0416A8 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0416AC             0141*  @sprite_player_loop:
0416AC C5          0142*  	push bc
0416AD E5          0143*  	push hl
0416AE CD D9 22 04 0144*  	call vdu_sprite_add_buff
0416B2 E1          0145*  	pop hl
0416B3 23          0146*  	inc hl
0416B4 C1          0147*  	pop bc
0416B5 10 F5       0148*  	djnz @sprite_player_loop
0416B7 CD 02 22 04 0149*  	call vdu_sprite_show
0416BB             0150*  
0416BB             0151*  ; all done
0416BB C9          0152*      ret
0416BC             0050   ; API includes
0416BC             0051       include "mos_api.inc"
0416BC             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0416BC             0002*  ; Title:	AGON MOS - API for user projects
0416BC             0003*  ; Author:	Dean Belfield
0416BC             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0416BC             0005*  ;			Added MOS error codes for return in HL
0416BC             0006*  ; Created:	03/08/2022
0416BC             0007*  ; Last Updated:	10/08/2023
0416BC             0008*  ;
0416BC             0009*  ; Modinfo:
0416BC             0010*  ; 05/08/2022:	Added mos_feof
0416BC             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0416BC             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0416BC             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0416BC             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0416BC             0015*  ; 13/10/2022:	Added mos_oscli
0416BC             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0416BC             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0416BC             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0416BC             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0416BC             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0416BC             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0416BC             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0416BC             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0416BC             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0416BC             0025*  ; 19/05/2023:	Added sysvar_scrMode
0416BC             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0416BC             0027*  ; 03/08/2023:	Added mos_setkbvector
0416BC             0028*  ; 10/08/2023:	Added mos_getkbmap
0416BC             0029*  
0416BC             0030*  ; VDP control (VDU 23, 0, n)
0416BC             0031*  ;
0416BC             0032*  vdp_gp:				EQU 80h
0416BC             0033*  vdp_keycode:		EQU 81h
0416BC             0034*  vdp_cursor:			EQU	82h
0416BC             0035*  vdp_scrchar:		EQU	83h
0416BC             0036*  vdp_scrpixel:		EQU	84h
0416BC             0037*  vdp_audio:			EQU	85h
0416BC             0038*  vdp_mode:			EQU	86h
0416BC             0039*  vdp_rtc:			EQU	87h
0416BC             0040*  vdp_keystate:		EQU	88h
0416BC             0041*  vdp_logicalcoords:	EQU	C0h
0416BC             0042*  vdp_terminalmode:	EQU	FFh
0416BC             0043*  
0416BC             0044*  ; MOS high level functions
0416BC             0045*  ;
0416BC             0046*  mos_getkey:			EQU	00h
0416BC             0047*  mos_load:			EQU	01h
0416BC             0048*  mos_save:			EQU	02h
0416BC             0049*  mos_cd:				EQU	03h
0416BC             0050*  mos_dir:			EQU	04h
0416BC             0051*  mos_del:			EQU	05h
0416BC             0052*  mos_ren:			EQU	06h
0416BC             0053*  mos_mkdir:			EQU	07h
0416BC             0054*  mos_sysvars:		EQU	08h
0416BC             0055*  mos_editline:		EQU	09h
0416BC             0056*  mos_fopen:			EQU	0Ah
0416BC             0057*  mos_fclose:			EQU	0Bh
0416BC             0058*  mos_fgetc:			EQU	0Ch
0416BC             0059*  mos_fputc:			EQU	0Dh
0416BC             0060*  mos_feof:			EQU	0Eh
0416BC             0061*  mos_getError:		EQU	0Fh
0416BC             0062*  mos_oscli:			EQU	10h
0416BC             0063*  mos_copy:			EQU	11h
0416BC             0064*  mos_getrtc:			EQU	12h
0416BC             0065*  mos_setrtc:			EQU	13h
0416BC             0066*  mos_setintvector:	EQU	14h
0416BC             0067*  mos_uopen:			EQU	15h
0416BC             0068*  mos_uclose:			EQU	16h
0416BC             0069*  mos_ugetc:			EQU	17h
0416BC             0070*  mos_uputc:			EQU	18h
0416BC             0071*  mos_getfil:			EQU	19h
0416BC             0072*  mos_fread:			EQU	1Ah
0416BC             0073*  mos_fwrite:			EQU	1Bh
0416BC             0074*  mos_flseek:			EQU	1Ch
0416BC             0075*  mos_setkbvector:	EQU	1Dh
0416BC             0076*  mos_getkbmap:		EQU	1Eh
0416BC             0077*  
0416BC             0078*  ; MOS program exit codes
0416BC             0079*  ;
0416BC             0080*  EXIT_OK:				EQU  0;	"OK",
0416BC             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0416BC             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0416BC             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0416BC             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0416BC             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0416BC             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0416BC             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0416BC             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0416BC             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0416BC             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0416BC             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0416BC             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0416BC             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0416BC             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0416BC             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0416BC             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0416BC             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0416BC             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0416BC             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0416BC             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0416BC             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0416BC             0102*  ; FatFS file access functions
0416BC             0103*  ;
0416BC             0104*  ffs_fopen:			EQU	80h
0416BC             0105*  ffs_fclose:			EQU	81h
0416BC             0106*  ffs_fread:			EQU	82h
0416BC             0107*  ffs_fwrite:			EQU	83h
0416BC             0108*  ffs_flseek:			EQU	84h
0416BC             0109*  ffs_ftruncate:		EQU	85h
0416BC             0110*  ffs_fsync:			EQU	86h
0416BC             0111*  ffs_fforward:		EQU	87h
0416BC             0112*  ffs_fexpand:		EQU	88h
0416BC             0113*  ffs_fgets:			EQU	89h
0416BC             0114*  ffs_fputc:			EQU	8Ah
0416BC             0115*  ffs_fputs:			EQU	8Bh
0416BC             0116*  ffs_fprintf:		EQU	8Ch
0416BC             0117*  ffs_ftell:			EQU	8Dh
0416BC             0118*  ffs_feof:			EQU	8Eh
0416BC             0119*  ffs_fsize:			EQU	8Fh
0416BC             0120*  ffs_ferror:			EQU	90h
0416BC             0121*  
0416BC             0122*  ; FatFS directory access functions
0416BC             0123*  ;
0416BC             0124*  ffs_dopen:			EQU	91h
0416BC             0125*  ffs_dclose:			EQU	92h
0416BC             0126*  ffs_dread:			EQU	93h
0416BC             0127*  ffs_dfindfirst:		EQU	94h
0416BC             0128*  ffs_dfindnext:		EQU	95h
0416BC             0129*  
0416BC             0130*  ; FatFS file and directory management functions
0416BC             0131*  ;
0416BC             0132*  ffs_stat:			EQU	96h
0416BC             0133*  ffs_unlink:			EQU	97h
0416BC             0134*  ffs_rename:			EQU	98h
0416BC             0135*  ffs_chmod:			EQU	99h
0416BC             0136*  ffs_utime:			EQU	9Ah
0416BC             0137*  ffs_mkdir:			EQU	9Bh
0416BC             0138*  ffs_chdir:			EQU	9Ch
0416BC             0139*  ffs_chdrive:		EQU	9Dh
0416BC             0140*  ffs_getcwd:			EQU	9Eh
0416BC             0141*  
0416BC             0142*  ; FatFS volume management and system configuration functions
0416BC             0143*  ;
0416BC             0144*  ffs_mount:			EQU	9Fh
0416BC             0145*  ffs_mkfs:			EQU	A0h
0416BC             0146*  ffs_fdisk:			EQU	A1h
0416BC             0147*  ffs_getfree:		EQU	A2h
0416BC             0148*  ffs_getlabel:		EQU	A3h
0416BC             0149*  ffs_setlabel:		EQU	A4h
0416BC             0150*  ffs_setcp:			EQU	A5h
0416BC             0151*  
0416BC             0152*  ; File access modes
0416BC             0153*  ;
0416BC             0154*  fa_read:			EQU	01h
0416BC             0155*  fa_write:			EQU	02h
0416BC             0156*  fa_open_existing:	EQU	00h
0416BC             0157*  fa_create_new:		EQU	04h
0416BC             0158*  fa_create_always:	EQU	08h
0416BC             0159*  fa_open_always:		EQU	10h
0416BC             0160*  fa_open_append:		EQU	30h
0416BC             0161*  
0416BC             0162*  ; System variable indexes for api_sysvars
0416BC             0163*  ; Index into _sysvars in globals.inc
0416BC             0164*  ;
0416BC             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0416BC             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0416BC             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0416BC             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0416BC             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0416BC             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0416BC             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0416BC             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0416BC             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0416BC             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0416BC             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0416BC             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0416BC             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0416BC             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0416BC             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0416BC             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0416BC             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0416BC             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0416BC             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0416BC             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0416BC             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0416BC             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0416BC             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0416BC             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0416BC             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0416BC             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0416BC             0191*  
0416BC             0192*  ; Flags for the VPD protocol
0416BC             0193*  ;
0416BC             0194*  vdp_pflag_cursor:		EQU	00000001b
0416BC             0195*  vdp_pflag_scrchar:		EQU	00000010b
0416BC             0196*  vdp_pflag_point:		EQU	00000100b
0416BC             0197*  vdp_pflag_audio:		EQU	00001000b
0416BC             0198*  vdp_pflag_mode:			EQU	00010000b
0416BC             0199*  vdp_pflag_rtc:			EQU	00100000b
0416BC             0200*  
0416BC             0201*  ;
0416BC             0202*  ; FatFS structures
0416BC             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0416BC             0204*  ;
0416BC             0205*  ; Object ID and allocation information (FFOBJID)
0416BC             0206*  ;
0416BC             0207*  ; Indexes into FFOBJID structure
0416BC             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0416BC             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0416BC             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0416BC             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0416BC             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0416BC             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0416BC             0214*  ;
0416BC             0215*  ; File object structure (FIL)
0416BC             0216*  ;
0416BC             0217*  ; Indexes into FIL structure
0416BC             0218*  fil_obj:		EQU 0	; 15: Object identifier
0416BC             0219*  fil_flag:		EQU	15 	;  1: File status flags
0416BC             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0416BC             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0416BC             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0416BC             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0416BC             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0416BC             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0416BC             0226*  ;
0416BC             0227*  ; Directory object structure (DIR)
0416BC             0228*  ; Indexes into DIR structure
0416BC             0229*  dir_obj:		EQU  0	; 15: Object identifier
0416BC             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0416BC             0231*  dir_clust:		EQU	19	;  4: Current cluster
0416BC             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0416BC             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0416BC             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0416BC             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0416BC             0236*  ;
0416BC             0237*  ; File information structure (FILINFO)
0416BC             0238*  ;
0416BC             0239*  ; Indexes into FILINFO structure
0416BC             0240*  filinfo_fsize:		EQU 0	;   4: File size
0416BC             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0416BC             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0416BC             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0416BC             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0416BC             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0416BC             0246*  ;
0416BC             0247*  ; Macro for calling the API
0416BC             0248*  ; Parameters:
0416BC             0249*  ; - function: One of the function numbers listed above
0416BC             0250*  ;
0416BC             0251*  	MACRO	MOSCALL	function
0416BC             0252*  			LD	A, function
0416BC             0253*  			RST.LIL	08h
0416BC             0254*  	ENDMACRO
0416BC             0052       include "functions.inc"
0416BC             0001*  
0416BC             0002*      MACRO printChar char
0416BC             0003*          LD A, char
0416BC             0004*          RST.LIL 10h
0416BC             0005*      ENDMACRO
0416BC             0006*  
0416BC             0007*  ; Simulated call to subroutine at HL
0416BC             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0416BC             0009*  ; outputs: whatever the subroutine does, including HL and BC
0416BC             0010*  ; destroys: only what the subroutine does, but always BC
0416BC             0011*      MACRO callHL
0416BC             0012*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0013*          push bc       ; which constitutes the return address
0416BC             0014*          jp   (hl)     ; Jump to the address in HL
0416BC             0015*      ENDMACRO
0416BC             0016*  
0416BC             0017*  ; Simulated call to subroutine at IX
0416BC             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0416BC             0019*  ; outputs: whatever the subroutine does, including IX and BC
0416BC             0020*  ; destroys: only what the subroutine does, but always BC
0416BC             0021*      MACRO callIX
0416BC             0022*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0023*          push bc       ; which constitutes the return address
0416BC             0024*          jp   (ix)     ; Jump to the address in IX
0416BC             0025*      ENDMACRO
0416BC             0026*  
0416BC             0027*  ; Simulated call to soubroutinte at IY
0416BC             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0416BC             0029*  ; outputs: whatever the subroutine does, including IY and BC
0416BC             0030*  ; destroys: only what the subroutine does, but always BC
0416BC             0031*      MACRO callIY
0416BC             0032*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0033*          push bc       ; which constitutes the return address
0416BC             0034*          jp   (iy)     ; Jump to the address in IY
0416BC             0035*      ENDMACRO
0416BC             0036*  
0416BC             0037*  ; put the value in HLU into the accumulator
0416BC             0038*  ; destroys: af
0416BC             0039*      MACRO HLU_TO_A
0416BC             0040*          push hl ; 4 cycles
0416BC             0041*          inc sp ; 1 cycle
0416BC             0042*          pop af  ; 4 cycles
0416BC             0043*          dec sp ; 1 cycle
0416BC             0044*                 ; 10 cycles total
0416BC             0045*      ENDMACRO
0416BC             0046*  
0416BC             0047*  A_TO_HLU:
0416BC             0048*      ; call is 7 cycles
0416BC 22 C9 16 04 0049*      ld (@scratch),hl ; 7 cycles
0416C0 32 CB 16 04 0050*      ld (@scratch+2),a ; 5 cycles
0416C4 2A C9 16 04 0051*      ld hl,(@scratch) ; 7 cycles
0416C8 C9          0052*      ret ; 6 cycles
0416C9             0053*          ; 25 cycles total
0416C9 00 00 00    0054*  @scratch: dl 0
0416CC             0055*  
0416CC             0056*      ; TODO: implement this
0416CC             0057*      ; MACRO A_TO_HLU
0416CC             0058*      ;     push.s af
0416CC             0059*      ;     inc sp
0416CC             0060*      ;     push.s hl
0416CC             0061*      ;     pop hl
0416CC             0062*      ;     inc sp
0416CC             0063*      ;     inc sp
0416CC             0064*      ; ENDMACRO
0416CC             0065*  
0416CC             0066*      MACRO PUSH_ALL
0416CC             0067*          ex af,af'
0416CC             0068*          exx
0416CC             0069*          push af
0416CC             0070*          push hl
0416CC             0071*          push bc
0416CC             0072*          push de
0416CC             0073*  
0416CC             0074*          ex af,af'
0416CC             0075*          exx
0416CC             0076*          push af
0416CC             0077*          push hl
0416CC             0078*          push bc
0416CC             0079*          push de
0416CC             0080*          push ix
0416CC             0081*          push iy
0416CC             0082*      ENDMACRO
0416CC             0083*  
0416CC             0084*      MACRO POP_ALL
0416CC             0085*          pop iy
0416CC             0086*          pop ix
0416CC             0087*          pop de
0416CC             0088*          pop bc
0416CC             0089*          pop hl
0416CC             0090*          pop af
0416CC             0091*          ex af,af'
0416CC             0092*          exx
0416CC             0093*  
0416CC             0094*          pop de
0416CC             0095*          pop bc
0416CC             0096*          pop hl
0416CC             0097*          pop af
0416CC             0098*          ex af,af'
0416CC             0099*          exx
0416CC             0100*      ENDMACRO
0416CC             0101*  
0416CC             0102*  ; Print a zero-terminated string inline with code, e.g.:
0416CC             0103*  ;
0416CC             0104*  ;    call printInline
0416CC             0105*  ;    ASCIZ "Hello, world!\r\n"
0416CC             0106*  ;
0416CC             0107*  ; Destroys: HL,AF
0416CC             0108*  printInline:
0416CC E1          0109*      pop hl ; get the return address = pointer to start of string
0416CD CD D3 16 04 0110*      call printString ; HL advances to end of string
0416D1 E5          0111*      push hl ; restore the return address = pointer to end of string
0416D2 C9          0112*      ret
0416D3             0113*  
0416D3             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0416D3             0115*  ; Print a zero-terminated string
0416D3             0116*  ; HL: Pointer to string
0416D3             0117*  printString:
0416D3 C5          0118*  	PUSH	BC
0416D4 01 00 00 00 0119*  	LD		BC,0
0416D8 3E 00       0120*  	LD 	 	A,0
0416DA 5B DF       0121*  	RST.LIL 18h
0416DC C1          0122*  	POP		BC
0416DD C9          0123*  	RET
0416DE             0124*  ; print a VDU sequence
0416DE             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0416DE             0126*  sendVDUsequence:
0416DE C5          0127*  	PUSH	BC
0416DF 01 00 00 00 0128*  	LD		BC, 0
0416E3 4E          0129*  	LD		C, (HL)
0416E4 5B DF       0130*  	RST.LIL	18h
0416E6 C1          0131*  	POP		BC
0416E7 C9          0132*  	RET
0416E8             0133*  ; Print Newline sequence to VDP
0416E8             0134*  printNewLine:
0416E8 F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
0416E9 3E 0D       0136*  	LD	A, '\r'
0416EB 5B D7       0137*  	RST.LIL 10h
0416ED 3E 0A       0138*  	LD	A, '\n'
0416EF 5B D7       0139*  	RST.LIL 10h
0416F1 F1          0140*      pop af
0416F2 C9          0141*  	RET
0416F3             0142*  
0416F3             0143*  ; Print a 24-bit HEX number
0416F3             0144*  ; HLU: Number to print
0416F3             0145*  printHex24:
0416F3             0146*      HLU_TO_A
0416F3 E5          0001*M         push hl ; 4 cycles
0416F4 33          0002*M         inc sp ; 1 cycle
0416F5 F1          0003*M         pop af  ; 4 cycles
0416F6 3B          0004*M         dec sp ; 1 cycle
0416F7             0005*M                ; 10 cycles total
0416F7 CD 01 17 04 0147*  	CALL	printHex8
0416FB             0148*  ; Print a 16-bit HEX number
0416FB             0149*  ; HL: Number to print
0416FB             0150*  printHex16:
0416FB 7C          0151*  	LD		A,H
0416FC CD 01 17 04 0152*  	CALL	printHex8
041700 7D          0153*  	LD		A,L
041701             0154*  ; Print an 8-bit HEX number
041701             0155*  ; A: Number to print
041701             0156*  printHex8:
041701 4F          0157*  	LD		C,A
041702 1F          0158*  	RRA
041703 1F          0159*  	RRA
041704 1F          0160*  	RRA
041705 1F          0161*  	RRA
041706 CD 0B 17 04 0162*  	CALL	@F
04170A 79          0163*  	LD		A,C
04170B             0164*  @@:
04170B E6 0F       0165*  	AND		0Fh
04170D C6 90       0166*  	ADD		A,90h
04170F 27          0167*  	DAA
041710 CE 40       0168*  	ADC		A,40h
041712 27          0169*  	DAA
041713 5B D7       0170*  	RST.LIL	10h
041715 C9          0171*  	RET
041716             0172*  
041716             0173*  printHexA:
041716 F5          0174*      push af
041717 C5          0175*      push bc
041718 CD 01 17 04 0176*      call printHex8
04171C 3E 20       0177*      ld a,' '
04171E 5B D7       0178*      rst.lil 10h
041720 C1          0179*      pop bc
041721 F1          0180*      pop af
041722 C9          0181*      ret
041723             0182*  
041723             0183*  printHexHL:
041723 F5          0184*      push af
041724 C5          0185*      push bc
041725 CD FB 16 04 0186*      call printHex16
041729 3E 20       0187*      ld a,' '
04172B 5B D7       0188*      rst.lil 10h
04172D C1          0189*      pop bc
04172E F1          0190*      pop af
04172F C9          0191*      ret
041730             0192*  
041730             0193*  printHexUHL:
041730 F5          0194*      push af
041731 C5          0195*      push bc
041732 CD F3 16 04 0196*      call printHex24
041736 3E 20       0197*      ld a,' '
041738 5B D7       0198*      rst.lil 10h
04173A C1          0199*      pop bc
04173B F1          0200*      pop af
04173C C9          0201*      ret
04173D             0202*  
04173D             0203*  printHexAUHL:
04173D F5          0204*      push af
04173E C5          0205*      push bc
04173F CD 01 17 04 0206*      call printHex8
041743 3E 2E       0207*      ld a,'.'
041745 5B D7       0208*      rst.lil 10h
041747 CD F3 16 04 0209*      call printHex24
04174B 3E 20       0210*      ld a,' '
04174D 5B D7       0211*      rst.lil 10h
04174F C1          0212*      pop bc
041750 F1          0213*      pop af
041751 C9          0214*      ret
041752             0215*  
041752             0216*  printHexABHL:
041752             0217*  ; preserve registers
041752 C5          0218*      push bc ; b will be ok c will not
041753 F5          0219*      push af ; will get totally destroyed
041754             0220*  ; print a
041754 CD 01 17 04 0221*      call printHex8
041758             0222*  ; print b
041758 78          0223*      ld a,b
041759 CD 01 17 04 0224*      call printHex8
04175D             0225*  ; print hl
04175D CD FB 16 04 0226*      call printHex16
041761             0227*  ; restore registers
041761 F1          0228*      pop af
041762 C1          0229*      pop bc
041763 C9          0230*      ret
041764             0231*  
041764             0232*  printHexBHL:
041764             0233*  ; preserve registers
041764 C5          0234*      push bc ; b will be ok c will not
041765 F5          0235*      push af ; will get totally destroyed
041766             0236*  ; print b
041766 78          0237*      ld a,b
041767 CD 01 17 04 0238*      call printHex8
04176B             0239*  ; print hl
04176B CD FB 16 04 0240*      call printHex16
04176F             0241*  ; restore registers
04176F F1          0242*      pop af
041770 C1          0243*      pop bc
041771 C9          0244*      ret
041772             0245*  
041772             0246*  printHexCDE:
041772             0247*  ; preserve registers
041772 C5          0248*      push bc ; b will be ok c will not
041773 F5          0249*      push af ; will get totally destroyed
041774             0250*  ; print c
041774 79          0251*      ld a,c
041775 CD 01 17 04 0252*      call printHex8
041779             0253*  ; print de
041779 EB          0254*      ex de,hl
04177A CD FB 16 04 0255*      call printHex16
04177E EB          0256*      ex de,hl
04177F             0257*  ; restore registers
04177F F1          0258*      pop af
041780 C1          0259*      pop bc
041781 C9          0260*      ret
041782             0261*  
041782             0262*  printHexUIX:
041782             0263*  ; store everything in scratch
041782 22 FB 1B 04 0264*      ld (uhl),hl
041786 ED 43 FE 1B 0265*      ld (ubc),bc
       04          
04178B ED 53 01 1C 0266*      ld (ude),de
       04          
041790 DD 22 04 1C 0267*      ld (uix),ix
       04          
041795 FD 22 07 1C 0268*      ld (uiy),iy
       04          
04179A F5          0269*      push af ; fml
04179B             0270*  
04179B 21 92 1B 04 0271*      ld hl,str_ixu
04179F CD D3 16 04 0272*      call printString
0417A3 2A 04 1C 04 0273*      ld hl,(uix)
0417A7 CD F3 16 04 0274*      call printHex24
0417AB CD E8 16 04 0275*      call printNewLine
0417AF             0276*  
0417AF             0277*  ; restore everything
0417AF 2A FB 1B 04 0278*      ld hl, (uhl)
0417B3 ED 4B FE 1B 0279*      ld bc, (ubc)
       04          
0417B8 ED 5B 01 1C 0280*      ld de, (ude)
       04          
0417BD DD 2A 04 1C 0281*      ld ix, (uix)
       04          
0417C2 FD 2A 07 1C 0282*      ld iy, (uiy)
       04          
0417C7 F1          0283*      pop af
0417C8             0284*  ; all done
0417C8 C9          0285*      ret
0417C9             0286*  
0417C9             0287*  ; Print a 0x HEX prefix
0417C9             0288*  DisplayHexPrefix:
0417C9 3E 30       0289*  	LD	A, '0'
0417CB 5B D7       0290*  	RST.LIL 10h
0417CD 3E 78       0291*  	LD	A, 'x'
0417CF 5B D7       0292*  	RST.LIL 10h
0417D1 C9          0293*  	RET
0417D2             0294*  
0417D2             0295*      MACRO printDecBC
0417D2             0296*          push hl
0417D2             0297*          push bc
0417D2             0298*          pop hl
0417D2             0299*          call printDec
0417D2             0300*          pop hl
0417D2             0301*      ENDMACRO
0417D2             0302*  
0417D2             0303*      MACRO printDecDE
0417D2             0304*          push hl
0417D2             0305*          push de
0417D2             0306*          pop hl
0417D2             0307*          call printDec
0417D2             0308*          pop hl
0417D2             0309*      ENDMACRO
0417D2             0310*  
0417D2             0311*      MACRO printDecHL
0417D2             0312*          call printDec
0417D2             0313*      ENDMACRO
0417D2             0314*  
0417D2             0315*      MACRO printDecIX
0417D2             0316*          push hl
0417D2             0317*          push ix
0417D2             0318*          pop hl
0417D2             0319*          call printDec
0417D2             0320*          pop hl
0417D2             0321*      ENDMACRO
0417D2             0322*  
0417D2             0323*      MACRO printDecIY
0417D2             0324*          push hl
0417D2             0325*          push iy
0417D2             0326*          pop hl
0417D2             0327*          call printDec
0417D2             0328*          pop hl
0417D2             0329*      ENDMACRO
0417D2             0330*  
0417D2             0331*  
0417D2             0332*  ; Prints the right justified decimal value in HL without leading zeroes
0417D2             0333*  ; HL : Value to print
0417D2             0334*  ; preserves all registers and flags
0417D2             0335*  printDec:
0417D2             0336*  ; BEGIN MY CODE
0417D2             0337*  ; back up all the things
0417D2 F5          0338*      push af
0417D3 C5          0339*      push bc
0417D4 D5          0340*      push de
0417D5 E5          0341*      push hl
0417D6             0342*  ; END MY CODE
0417D6 11 FE 17 04 0343*  	LD	 DE, _printDecBuffer
0417DA CD 0E 18 04 0344*  	CALL u24_to_ascii
0417DE             0345*  ; BEGIN MY CODE
0417DE             0346*  ; replace leading zeroes with spaces
0417DE 21 FE 17 04 0347*      LD	 HL, _printDecBuffer
0417E2 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0417E4             0349*  @loop:
0417E4 7E          0350*      LD	 A, (HL)
0417E5 FE 30       0351*      CP	 '0'
0417E7 C2 F1 17 04 0352*      JP	 NZ, @done
0417EB 3E 20       0353*      LD   A, ' '
0417ED 77          0354*      LD	 (HL), A
0417EE 23          0355*      INC	 HL
0417EF             0356*      ; CALL vdu_cursor_forward
0417EF 10 F3       0357*      DJNZ @loop
0417F1             0358*  @done:
0417F1             0359*  ; END MY CODE
0417F1 21 FE 17 04 0360*  	LD	 HL, _printDecBuffer
0417F5 CD D3 16 04 0361*  	CALL printString
0417F9             0362*  ; BEGIN MY CODE
0417F9             0363*  ; restore all the things
0417F9 E1          0364*      pop hl
0417FA D1          0365*      pop de
0417FB C1          0366*      pop bc
0417FC F1          0367*      pop af
0417FD             0368*  ; END MY CODE
0417FD C9          0369*  	RET
0417FE 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04180E             0371*  
04180E             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
04180E             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
04180E             0374*  ; so it will allways be 8 characters length
04180E             0375*  ; HL : Value to convert to string
04180E             0376*  ; DE : pointer to buffer, at least 8 byte + 0
04180E             0377*  u24_to_ascii:
04180E 01 80 69 67 0378*  	LD	 BC,-10000000
041812 CD 45 18 04 0379*  	CALL @one_digit
041816 01 C0 BD F0 0380*  	LD	 BC,-1000000
04181A CD 45 18 04 0381*  	CALL @one_digit
04181E 01 60 79 FE 0382*  	LD	 BC,-100000
041822 CD 45 18 04 0383*  	CALL @one_digit
041826 01 F0 D8 FF 0384*  	LD   BC,-10000
04182A CD 45 18 04 0385*  	CALL @one_digit
04182E 01 18 FC FF 0386*  	LD   BC,-1000
041832 CD 45 18 04 0387*  	CALL @one_digit
041836 01 9C FF FF 0388*  	LD   BC,-100
04183A CD 45 18 04 0389*  	CALL @one_digit
04183E 0E F6       0390*  	LD   C,-10
041840 CD 45 18 04 0391*  	CALL @one_digit
041844 48          0392*  	LD   C,B
041845             0393*  @one_digit:
041845 3E 2F       0394*  	LD   A,'0'-1
041847             0395*  @divide_me:
041847 3C          0396*  	INC  A
041848 09          0397*  	ADD  HL,BC
041849 38 FC       0398*  	JR   C,@divide_me
04184B ED 42       0399*  	SBC  HL,BC
04184D 12          0400*  	LD   (DE),A
04184E 13          0401*  	INC  DE
04184F C9          0402*  	RET
041850             0403*  
041850             0404*  print_u24:
041850 D5          0405*      push de
041851 E5          0406*      push hl
041852 11 FE 17 04 0407*      ld de,_printDecBuffer
041856 CD 0E 18 04 0408*      call u24_to_ascii
04185A 21 FE 17 04 0409*      ld hl,_printDecBuffer
04185E CD D3 16 04 0410*      call printString
041862 3E 20       0411*      ld a,' '
041864 5B D7       0412*      rst.lil 10h
041866 E1          0413*      pop hl
041867 D1          0414*      pop de
041868 C9          0415*      ret
041869             0416*  
041869             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
041869             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
041869             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
041869             0420*  u168_to_ascii:
041869             0421*  ; add a leading space to make room for sign flag if needed
041869 3E 20       0422*      ld a,' '
04186B 12          0423*      ld (de),a
04186C 13          0424*      inc de
04186D             0425*  ; Convert integer part
04186D E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
04186E CD 5B 23 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
041872 01 F0 D8 FF 0428*      ld   bc, -10000
041876 CD 99 18 04 0429*      call @one_int
04187A 01 18 FC FF 0430*      ld   bc, -1000
04187E CD 99 18 04 0431*      call @one_int
041882 01 9C FF FF 0432*      ld   bc, -100
041886 CD 99 18 04 0433*      call @one_int
04188A 0E F6       0434*      ld   c, -10
04188C CD 99 18 04 0435*      call @one_int
041890 48          0436*      ld   c, b
041891 CD 99 18 04 0437*      call @one_int
041895 C3 A4 18 04 0438*      jp   @frac            ; Jump to fractional part conversion
041899             0439*  @one_int:
041899 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04189B             0441*  @divide_me:
04189B 3C          0442*      inc  a
04189C 09          0443*      add  hl, bc           ; Accumulate until overflow
04189D 38 FC       0444*      jr   c, @divide_me
04189F ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
0418A1 12          0446*      ld   (de), a          ; Store ASCII digit
0418A2 13          0447*      inc  de
0418A3 C9          0448*      ret
0418A4             0449*  ; Convert fractional part
0418A4             0450*  @frac:
0418A4 3E 2E       0451*      ld   a, '.'           ; Decimal point
0418A6 12          0452*      ld   (de), a
0418A7 13          0453*      inc  de
0418A8 E1          0454*      pop  hl               ; Restore HL with original fraction
0418A9 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
0418AB             0456*  @frac_loop:
0418AB 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
0418AD ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0418AF 3E 30       0459*      ld   a, '0'
0418B1 84          0460*      add  a, h             ; Convert integer part to ASCII
0418B2 12          0461*      ld   (de), a
0418B3 13          0462*      inc  de
0418B4 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
0418B6             0464*  ; Add null terminator
0418B6 AF          0465*      xor  a                ; Null terminator
0418B7 12          0466*      ld   (de), a
0418B8 C9          0467*      ret
0418B9             0468*  
0418B9             0469*  print_u168:
0418B9 D5          0470*      push de
0418BA E5          0471*      push hl
0418BB 11 FE 17 04 0472*      ld de,_printDecBuffer
0418BF CD 69 18 04 0473*      call u168_to_ascii
0418C3 21 FE 17 04 0474*      ld hl,_printDecBuffer
0418C7 CD D3 16 04 0475*      call printString
0418CB E1          0476*      pop hl
0418CC D1          0477*      pop de
0418CD C9          0478*      ret
0418CE             0479*  
0418CE             0480*  ; signed version of u168_to_ascii
0418CE             0481*  s168_to_ascii:
0418CE D5          0482*      push de ; save starting address of buffer
0418CF CD F4 22 04 0483*      call hlu_abs
0418D3 F5          0484*      push af ; save sign flag
0418D4 CD 69 18 04 0485*      call u168_to_ascii
0418D8 F1          0486*      pop af ; restore sign flag
0418D9 D1          0487*      pop de ; restore starting address of buffer
0418DA F0          0488*      ret p ; hlu was positive so nothing to do
0418DB 3E 2D       0489*      ld a,'-'
0418DD 12          0490*      ld (de),a
0418DE C9          0491*      ret
0418DF             0492*  
0418DF             0493*  print_s168:
0418DF D5          0494*      push de
0418E0 E5          0495*      push hl
0418E1 11 FE 17 04 0496*      ld de,_printDecBuffer
0418E5 CD CE 18 04 0497*      call s168_to_ascii
0418E9 21 FE 17 04 0498*      ld hl,_printDecBuffer
0418ED CD D3 16 04 0499*      call printString
0418F1 E1          0500*      pop hl
0418F2 D1          0501*      pop de
0418F3 C9          0502*      ret
0418F4             0503*  
0418F4             0504*  print_s168_hl:
0418F4 F5          0505*      push af
0418F5 E5          0506*      push hl
0418F6 CD DF 18 04 0507*      call print_s168
0418FA 3E 20       0508*      ld a,' '
0418FC 5B D7       0509*      rst.lil 10h
0418FE E1          0510*      pop hl
0418FF F1          0511*      pop af
041900 C9          0512*      ret
041901             0513*  
041901             0514*  print_s168_bc:
041901 F5          0515*      push af
041902 C5          0516*      push bc
041903 E5          0517*      push hl
041904 C5          0518*      push bc
041905 E1          0519*      pop hl
041906 CD DF 18 04 0520*      call print_s168
04190A 3E 20       0521*      ld a,' '
04190C 5B D7       0522*      rst.lil 10h
04190E E1          0523*      pop hl
04190F C1          0524*      pop bc
041910 F1          0525*      pop af
041911 C9          0526*      ret
041912             0527*  
041912             0528*  print_s168_de:
041912 F5          0529*      push af
041913 D5          0530*      push de
041914 E5          0531*      push hl
041915 EB          0532*      ex de,hl
041916 CD DF 18 04 0533*      call print_s168
04191A 3E 20       0534*      ld a,' '
04191C 5B D7       0535*      rst.lil 10h
04191E E1          0536*      pop hl
04191F D1          0537*      pop de
041920 F1          0538*      pop af
041921 C9          0539*      ret
041922             0540*  
041922             0541*  print_s168_hl_bc_de:
041922 F5          0542*      push af
041923 C5          0543*      push bc
041924 D5          0544*      push de
041925 E5          0545*      push hl
041926 CD DF 18 04 0546*      call print_s168
04192A 3E 20       0547*      ld a,' '
04192C 5B D7       0548*      rst.lil 10h
04192E C5          0549*      push bc
04192F E1          0550*      pop hl
041930 CD DF 18 04 0551*      call print_s168
041934 3E 20       0552*      ld a,' '
041936 5B D7       0553*      rst.lil 10h
041938 EB          0554*      ex de,hl
041939 CD DF 18 04 0555*      call print_s168
04193D 3E 20       0556*      ld a,' '
04193F 5B D7       0557*      rst.lil 10h
041941 E1          0558*      pop hl
041942 D1          0559*      pop de
041943 C1          0560*      pop bc
041944 F1          0561*      pop af
041945 C9          0562*      ret
041946             0563*  
041946             0564*  print_s168_bc_de:
041946 F5          0565*      push af
041947 C5          0566*      push bc
041948 D5          0567*      push de
041949 C5          0568*      push bc
04194A E1          0569*      pop hl
04194B CD DF 18 04 0570*      call print_s168
04194F 3E 20       0571*      ld a,' '
041951 5B D7       0572*      rst.lil 10h
041953 EB          0573*      ex de,hl
041954 CD DF 18 04 0574*      call print_s168
041958 3E 20       0575*      ld a,' '
04195A 5B D7       0576*      rst.lil 10h
04195C E1          0577*      pop hl
04195D D1          0578*      pop de
04195E C1          0579*      pop bc
04195F F1          0580*      pop af
041960 C9          0581*      ret
041961             0582*  
041961             0583*  print_s168_a:
041961 F5          0584*      push af
041962 C5          0585*      push bc
041963 E5          0586*      push hl
041964 21 00 00 00 0587*      ld hl,0
041968 6F          0588*      ld l,a
041969 CD F4 18 04 0589*      call print_s168_hl
04196D E1          0590*      pop hl
04196E C1          0591*      pop bc
04196F F1          0592*      pop af
041970 C9          0593*      ret
041971             0594*  
041971             0595*  ; #### new functions added by Brandon R. Gates ####
041971             0596*  
041971             0597*  ; print the binary representation of the 8-bit value in a
041971             0598*  ; destroys a, hl, bc
041971             0599*  printBin8:
041971 06 08       0600*      ld b,8      ; loop counter for 8 bits
041973 21 8E 19 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
041977             0602*                  ; (which will be the high bit of the value in a)
041977             0603*  @loop:
041977 07          0604*      rlca ; put the next highest bit into carry
041978 38 04       0605*      jr c,@one
04197A 36 30       0606*      ld (hl),'0'
04197C 18 02       0607*      jr @next_bit
04197E             0608*  @one:
04197E 36 31       0609*      ld (hl),'1'
041980             0610*  @next_bit:
041980 23          0611*      inc hl
041981 10 F4       0612*      djnz @loop
041983             0613*  ; print it
041983 21 8E 19 04 0614*  	ld hl,@cmd
041987 01 08 00 00 0615*  	ld bc,@end-@cmd
04198B 5B DF       0616*  	rst.lil $18
04198D C9          0617*  	ret
04198E             0618*  @cmd: ds 8 ; eight bytes for eight bits
041996             0619*  @end:
041996             0620*  
041996             0621*  ; print the binary representation of the 8-bit value in a
041996             0622*  ; in reverse order (lsb first)
041996             0623*  ; destroys a, hl, bc
041996             0624*  printBin8Rev:
041996 06 08       0625*      ld b,8      ; loop counter for 8 bits
041998 21 B3 19 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
04199C             0627*                  ; (which will be the high bit of the value in a)
04199C             0628*  @loop:
04199C 0F          0629*      rrca ; put the next lowest bit into carry
04199D 38 04       0630*      jr c,@one
04199F 36 30       0631*      ld (hl),'0'
0419A1 18 02       0632*      jr @next_bit
0419A3             0633*  @one:
0419A3 36 31       0634*      ld (hl),'1'
0419A5             0635*  @next_bit:
0419A5 23          0636*      inc hl
0419A6 10 F4       0637*      djnz @loop
0419A8             0638*  ; print it
0419A8 21 B3 19 04 0639*  	ld hl,@cmd
0419AC 01 08 00 00 0640*  	ld bc,@end-@cmd
0419B0 5B DF       0641*  	rst.lil $18
0419B2 C9          0642*  	ret
0419B3             0643*  @cmd: ds 8 ; eight bytes for eight bits
0419BB             0644*  @end:
0419BB             0645*  
0419BB             0646*  ; print registers to screen in hexidecimal format
0419BB             0647*  ; inputs: none
0419BB             0648*  ; outputs: values of every register printed to screen
0419BB             0649*  ;    values of each register in global scratch memory
0419BB             0650*  ; destroys: nothing
0419BB             0651*  stepRegistersHex:
0419BB             0652*  ; store everything in scratch
0419BB 22 FB 1B 04 0653*      ld (uhl),hl
0419BF ED 43 FE 1B 0654*      ld (ubc),bc
       04          
0419C4 ED 53 01 1C 0655*      ld (ude),de
       04          
0419C9 DD 22 04 1C 0656*      ld (uix),ix
       04          
0419CE FD 22 07 1C 0657*      ld (uiy),iy
       04          
0419D3 F5          0658*      push af ; fml
0419D4 E1          0659*      pop hl  ; thanks, zilog
0419D5 22 F8 1B 04 0660*      ld (uaf),hl
0419D9 F5          0661*      push af ; dammit
0419DA             0662*  
0419DA             0663*  ; home the cursor
0419DA             0664*      ; call vdu_home_cursor
0419DA             0665*  
0419DA             0666*  ; print each register
0419DA 21 7E 1B 04 0667*      ld hl,str_afu
0419DE CD D3 16 04 0668*      call printString
0419E2 2A F8 1B 04 0669*      ld hl,(uaf)
0419E6 CD F3 16 04 0670*      call printHex24
0419EA CD E8 16 04 0671*      call printNewLine
0419EE             0672*  
0419EE 21 83 1B 04 0673*      ld hl,str_hlu
0419F2 CD D3 16 04 0674*      call printString
0419F6 2A FB 1B 04 0675*      ld hl,(uhl)
0419FA CD F3 16 04 0676*      call printHex24
0419FE CD E8 16 04 0677*      call printNewLine
041A02             0678*  
041A02 21 88 1B 04 0679*      ld hl,str_bcu
041A06 CD D3 16 04 0680*      call printString
041A0A 2A FE 1B 04 0681*      ld hl,(ubc)
041A0E CD F3 16 04 0682*      call printHex24
041A12 CD E8 16 04 0683*      call printNewLine
041A16             0684*  
041A16 21 8D 1B 04 0685*      ld hl,str_deu
041A1A CD D3 16 04 0686*      call printString
041A1E 2A 01 1C 04 0687*      ld hl,(ude)
041A22 CD F3 16 04 0688*      call printHex24
041A26 CD E8 16 04 0689*      call printNewLine
041A2A             0690*  
041A2A 21 92 1B 04 0691*      ld hl,str_ixu
041A2E CD D3 16 04 0692*      call printString
041A32 2A 04 1C 04 0693*      ld hl,(uix)
041A36 CD F3 16 04 0694*      call printHex24
041A3A CD E8 16 04 0695*      call printNewLine
041A3E             0696*  
041A3E 21 97 1B 04 0697*      ld hl,str_iyu
041A42 CD D3 16 04 0698*      call printString
041A46 2A 07 1C 04 0699*      ld hl,(uiy)
041A4A CD F3 16 04 0700*      call printHex24
041A4E CD E8 16 04 0701*      call printNewLine
041A52             0702*  
041A52             0703*      ; call vsync
041A52             0704*  
041A52 CD E8 16 04 0705*      call printNewLine
041A56             0706*  
041A56             0707*  ; check for right shift key and quit if pressed
041A56             0708*  	MOSCALL mos_getkbmap
041A56 3E 1E       0001*M 			LD	A, function
041A58 5B CF       0002*M 			RST.LIL	08h
041A5A             0709*  @stayhere:
041A5A             0710*  ; 7 RightShift
041A5A DD CB 00 76 0711*      bit 6,(ix+0)
041A5E 20 02       0712*      jr nz,@RightShift
041A60 18 F8       0713*      jr @stayhere
041A62             0714*  @RightShift:
041A62 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
041A66 3E 80       0716*      ld a,%10000000
041A68             0717*      ; call multiPurposeDelay
041A68             0718*  
041A68             0719*  ; restore everything
041A68 2A FB 1B 04 0720*      ld hl, (uhl)
041A6C ED 4B FE 1B 0721*      ld bc, (ubc)
       04          
041A71 ED 5B 01 1C 0722*      ld de, (ude)
       04          
041A76 DD 2A 04 1C 0723*      ld ix, (uix)
       04          
041A7B FD 2A 07 1C 0724*      ld iy, (uiy)
       04          
041A80 F1          0725*      pop af
041A81             0726*  ; all done
041A81 C9          0727*      ret
041A82             0728*  
041A82             0729*  ; print registers to screen in hexidecimal format
041A82             0730*  ; inputs: none
041A82             0731*  ; outputs: values of every register printed to screen
041A82             0732*  ;    values of each register in global scratch memory
041A82             0733*  ; destroys: nothing
041A82             0734*  dumpRegistersHex:
041A82             0735*  ; store everything in scratch
041A82 22 FB 1B 04 0736*      ld (uhl),hl
041A86 ED 43 FE 1B 0737*      ld (ubc),bc
       04          
041A8B ED 53 01 1C 0738*      ld (ude),de
       04          
041A90 DD 22 04 1C 0739*      ld (uix),ix
       04          
041A95 FD 22 07 1C 0740*      ld (uiy),iy
       04          
041A9A F5          0741*      push af ; fml
041A9B E1          0742*      pop hl  ; thanks, zilog
041A9C 22 F8 1B 04 0743*      ld (uaf),hl
041AA0 F5          0744*      push af ; dammit
041AA1             0745*  
041AA1             0746*  ; home the cursor
041AA1             0747*      ; call vdu_home_cursor
041AA1             0748*      ; call printNewLine
041AA1             0749*  
041AA1             0750*  ; print each register
041AA1 21 7E 1B 04 0751*      ld hl,str_afu
041AA5 CD D3 16 04 0752*      call printString
041AA9 2A F8 1B 04 0753*      ld hl,(uaf)
041AAD CD F3 16 04 0754*      call printHex24
041AB1             0755*      ; call printNewLine
041AB1             0756*  
041AB1 21 83 1B 04 0757*      ld hl,str_hlu
041AB5 CD D3 16 04 0758*      call printString
041AB9 2A FB 1B 04 0759*      ld hl,(uhl)
041ABD CD F3 16 04 0760*      call printHex24
041AC1             0761*      ; call printNewLine
041AC1             0762*  
041AC1 21 88 1B 04 0763*      ld hl,str_bcu
041AC5 CD D3 16 04 0764*      call printString
041AC9 2A FE 1B 04 0765*      ld hl,(ubc)
041ACD CD F3 16 04 0766*      call printHex24
041AD1             0767*      ; call printNewLine
041AD1             0768*  
041AD1 21 8D 1B 04 0769*      ld hl,str_deu
041AD5 CD D3 16 04 0770*      call printString
041AD9 2A 01 1C 04 0771*      ld hl,(ude)
041ADD CD F3 16 04 0772*      call printHex24
041AE1             0773*      ; call printNewLine
041AE1             0774*  
041AE1 21 92 1B 04 0775*      ld hl,str_ixu
041AE5 CD D3 16 04 0776*      call printString
041AE9 2A 04 1C 04 0777*      ld hl,(uix)
041AED CD F3 16 04 0778*      call printHex24
041AF1             0779*      ; call printNewLine
041AF1             0780*  
041AF1 21 97 1B 04 0781*      ld hl,str_iyu
041AF5 CD D3 16 04 0782*      call printString
041AF9 2A 07 1C 04 0783*      ld hl,(uiy)
041AFD CD F3 16 04 0784*      call printHex24
041B01             0785*      ; call printNewLine
041B01             0786*  
041B01             0787*      ; call vdu_vblank
041B01             0788*  
041B01 CD E8 16 04 0789*      call printNewLine
041B05             0790*  ; restore everything
041B05 2A FB 1B 04 0791*      ld hl, (uhl)
041B09 ED 4B FE 1B 0792*      ld bc, (ubc)
       04          
041B0E ED 5B 01 1C 0793*      ld de, (ude)
       04          
041B13 DD 2A 04 1C 0794*      ld ix, (uix)
       04          
041B18 FD 2A 07 1C 0795*      ld iy, (uiy)
       04          
041B1D F1          0796*      pop af
041B1E             0797*  ; all done
041B1E C9          0798*      ret
041B1F             0799*  
041B1F             0800*  dumpRegistersHexPrime:
041B1F D9          0801*      exx
041B20 08          0802*      ex af,af'
041B21 CD 82 1A 04 0803*      call dumpRegistersHex
041B25 08          0804*      ex af,af'
041B26 D9          0805*      exx
041B27 C9          0806*      ret
041B28             0807*  
041B28             0808*  ; additionally dump prime registers
041B28             0809*  ; inputs: none
041B28             0810*  ; outputs: values of every register printed to screen
041B28             0811*  ; destroys: nothing
041B28             0812*  dumpRegistersHexAll:
041B28 CD 82 1A 04 0813*      call dumpRegistersHex
041B2C 08          0814*      ex af,af'
041B2D D9          0815*      exx
041B2E CD 82 1A 04 0816*      call dumpRegistersHex
041B32 08          0817*      ex af,af'
041B33 D9          0818*      exx
041B34 C9          0819*      ret
041B35             0820*  
041B35             0821*  ; print hlu to screen in hexidecimal format
041B35             0822*  ; inputs: none
041B35             0823*  ; destroys: nothing
041B35             0824*  print_hex_hl:
041B35 F5          0825*      push af
041B36 E5          0826*      push hl
041B37 21 83 1B 04 0827*      ld hl,str_hlu
041B3B CD D3 16 04 0828*      call printString
041B3F E1          0829*      pop hl
041B40 E5          0830*      push hl
041B41 CD F3 16 04 0831*      call printHex24
041B45 3E 20       0832*      ld a,' '
041B47 5B D7       0833*      rst.lil 10h
041B49 E1          0834*      pop hl
041B4A F1          0835*      pop af
041B4B C9          0836*      ret
041B4C             0837*  
041B4C             0838*  ; print bcu to screen in hexidecimal format
041B4C             0839*  ; inputs: none
041B4C             0840*  ; destroys: nothing
041B4C             0841*  print_hex_bc:
041B4C F5          0842*      push af
041B4D E5          0843*      push hl
041B4E C5          0844*      push bc
041B4F 21 88 1B 04 0845*      ld hl,str_bcu
041B53 CD D3 16 04 0846*      call printString
041B57 E1          0847*      pop hl
041B58 E5          0848*      push hl
041B59 CD F3 16 04 0849*      call printHex24
041B5D 3E 20       0850*      ld a,' '
041B5F 5B D7       0851*      rst.lil 10h
041B61 C1          0852*      pop bc
041B62 E1          0853*      pop hl
041B63 F1          0854*      pop af
041B64 C9          0855*      ret
041B65             0856*  
041B65             0857*  ; print deu to screen in hexidecimal format
041B65             0858*  ; inputs: none
041B65             0859*  ; destroys: nothing
041B65             0860*  print_hex_de:
041B65 F5          0861*      push af
041B66 E5          0862*      push hl
041B67 D5          0863*      push de
041B68 21 8D 1B 04 0864*      ld hl,str_deu
041B6C CD D3 16 04 0865*      call printString
041B70 E1          0866*      pop hl
041B71 E5          0867*      push hl
041B72 CD F3 16 04 0868*      call printHex24
041B76 3E 20       0869*      ld a,' '
041B78 5B D7       0870*      rst.lil 10h
041B7A D1          0871*      pop de
041B7B E1          0872*      pop hl
041B7C F1          0873*      pop af
041B7D C9          0874*      ret
041B7E             0875*  
041B7E 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
041B83 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
041B88 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
041B8D 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
041B92 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
041B97 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
041B9C             0882*  
041B9C             0883*  ; print udeuhl to screen in hexidecimal format
041B9C             0884*  ; inputs: none
041B9C             0885*  ; outputs: concatenated hexidecimal udeuhl
041B9C             0886*  ; destroys: nothing
041B9C             0887*  dumpUDEUHLHex:
041B9C             0888*  ; store everything in scratch
041B9C 22 FB 1B 04 0889*      ld (uhl),hl
041BA0 ED 43 FE 1B 0890*      ld (ubc),bc
       04          
041BA5 ED 53 01 1C 0891*      ld (ude),de
       04          
041BAA DD 22 04 1C 0892*      ld (uix),ix
       04          
041BAF FD 22 07 1C 0893*      ld (uiy),iy
       04          
041BB4 F5          0894*      push af
041BB5             0895*  
041BB5             0896*  ; print each register
041BB5             0897*  
041BB5 21 EF 1B 04 0898*      ld hl,str_udeuhl
041BB9 CD D3 16 04 0899*      call printString
041BBD 2A 01 1C 04 0900*      ld hl,(ude)
041BC1 CD F3 16 04 0901*      call printHex24
041BC5 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
041BC7 5B D7       0903*  	rst.lil 10h
041BC9 2A FB 1B 04 0904*      ld hl,(uhl)
041BCD CD F3 16 04 0905*      call printHex24
041BD1 CD E8 16 04 0906*      call printNewLine
041BD5             0907*  
041BD5             0908*  ; restore everything
041BD5 2A FB 1B 04 0909*      ld hl, (uhl)
041BD9 ED 4B FE 1B 0910*      ld bc, (ubc)
       04          
041BDE ED 5B 01 1C 0911*      ld de, (ude)
       04          
041BE3 DD 2A 04 1C 0912*      ld ix, (uix)
       04          
041BE8 FD 2A 07 1C 0913*      ld iy, (uiy)
       04          
041BED F1          0914*      pop af
041BEE             0915*  ; all done
041BEE C9          0916*      ret
041BEF             0917*  
041BEF 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041BF8             0919*  
041BF8             0920*  ; global scratch memory for registers
041BF8 00 00 00    0921*  uaf: dl 0
041BFB 00 00 00    0922*  uhl: dl 0
041BFE 00 00 00    0923*  ubc: dl 0
041C01 00 00 00    0924*  ude: dl 0
041C04 00 00 00    0925*  uix: dl 0
041C07 00 00 00    0926*  uiy: dl 0
041C0A 00 00 00    0927*  usp: dl 0
041C0D 00 00 00    0928*  upc: dl 0
041C10             0929*  
041C10             0930*  ; inputs: whatever is in the flags register
041C10             0931*  ; outputs: binary representation of flags
041C10             0932*  ;          with a header so we know which is what
041C10             0933*  ; destroys: nothing
041C10             0934*  ; preserves: everything
041C10             0935*  dumpFlags:
041C10             0936*  ; first we curse zilog for not giving direct access to flags
041C10 F5          0937*      push af ; this is so we can send it back unharmed
041C11 F5          0938*      push af ; this is so we can pop it to hl
041C12             0939*  ; store everything in scratch
041C12 22 FB 1B 04 0940*      ld (uhl),hl
041C16 ED 43 FE 1B 0941*      ld (ubc),bc
       04          
041C1B ED 53 01 1C 0942*      ld (ude),de
       04          
041C20 DD 22 04 1C 0943*      ld (uix),ix
       04          
041C25 FD 22 07 1C 0944*      ld (uiy),iy
       04          
041C2A             0945*  ; next we print the header
041C2A 21 56 1C 04 0946*      ld hl,@header
041C2E CD D3 16 04 0947*      call printString
041C32 E1          0948*      pop hl ; flags are now in l
041C33 7D          0949*      ld a,l ; flags are now in a
041C34 CD 71 19 04 0950*      call printBin8
041C38 CD E8 16 04 0951*  	call printNewLine
041C3C             0952*  ; restore everything
041C3C 2A FB 1B 04 0953*      ld hl, (uhl)
041C40 ED 4B FE 1B 0954*      ld bc, (ubc)
       04          
041C45 ED 5B 01 1C 0955*      ld de, (ude)
       04          
041C4A DD 2A 04 1C 0956*      ld ix, (uix)
       04          
041C4F FD 2A 07 1C 0957*      ld iy, (uiy)
       04          
041C54 F1          0958*      pop af ; send her home the way she came
041C55 C9          0959*      ret
041C56             0960*  ; Bit 7 (S): Sign flag
041C56             0961*  ; Bit 6 (Z): Zero flag
041C56             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041C56             0963*  ; Bit 4 (H): Half Carry flag
041C56             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041C56             0965*  ; Bit 2 (PV): Parity/Overflow flag
041C56             0966*  ; Bit 1 (N): Subtract flag
041C56             0967*  ; Bit 0 (C): Carry flag
041C56 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041C61             0969*  
041C61             0970*  ; set all the bits in the flag register
041C61             0971*  ; more of an academic exercise than anything useful
041C61             0972*  ; inputs; none
041C61             0973*  ; outputs; a=0,f=255
041C61             0974*  ; destroys: flags, hl
041C61             0975*  ; preserves: a, because why not
041C61             0976*  setAllFlags:
041C61 21 FF 00 00 0977*      ld hl,255
041C65 67          0978*      ld h,a ; four cycles to preserve a is cheap
041C66 E5          0979*      push hl
041C67 F1          0980*      pop af
041C68 C9          0981*      ret
041C69             0982*  
041C69             0983*  ; reset all the bits in the flag register
041C69             0984*  ; unlike its inverse counterpart, this may actually be useful
041C69             0985*  ; inputs; none
041C69             0986*  ; outputs; a=0,f=0
041C69             0987*  ; destroys: flags, hl
041C69             0988*  ; preserves: a, because why not
041C69             0989*  resetAllFlags:
041C69 21 00 00 00 0990*      ld hl,0
041C6D 67          0991*      ld h,a ; four cycles to preserve a is cheap
041C6E E5          0992*      push hl
041C6F F1          0993*      pop af
041C70 C9          0994*      ret
041C71             0995*  
041C71             0996*  ; wait until user presses a key
041C71             0997*  ; inputs: none
041C71             0998*  ; outputs: ascii code of key pressed in a
041C71             0999*  ; destroys: af,ix
041C71             1000*  waitKeypress:
041C71             1001*      MOSCALL mos_getkey
041C71 3E 00       0001*M 			LD	A, function
041C73 5B CF       0002*M 			RST.LIL	08h
041C75 C9          1002*      ret
041C76             1003*  
041C76             1004*  ; print bytes from an address to the screen in hexidecimal format
041C76             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041C76             1006*  ; outputs: values of each byte printed to screen separated by spaces
041C76             1007*  ; destroys: nothing
041C76             1008*  dumpMemoryHex:
041C76             1009*  ; save registers to the stack
041C76 C5          1010*      push bc
041C77 E5          1011*      push hl
041C78 F5          1012*      push af
041C79             1013*  
041C79             1014*  ; print the address and separator
041C79 CD F3 16 04 1015*      call printHex24
041C7D 3E 3A       1016*      ld a,':'
041C7F 5B D7       1017*      rst.lil 10h
041C81 3E 20       1018*      ld a,' '
041C83 5B D7       1019*      rst.lil 10h
041C85             1020*  
041C85             1021*  ; set b to be our loop counter
041C85 F1          1022*      pop af
041C86 47          1023*      ld b,a
041C87 E1          1024*      pop hl
041C88 E5          1025*      push hl
041C89 F5          1026*      push af
041C8A             1027*  @loop:
041C8A             1028*  ; print the byte
041C8A 7E          1029*      ld a,(hl)
041C8B CD 01 17 04 1030*      call printHex8
041C8F             1031*  ; print a space
041C8F 3E 20       1032*      ld a,' '
041C91 5B D7       1033*      rst.lil 10h
041C93 23          1034*      inc hl
041C94 10 F4       1035*      djnz @loop
041C96 CD E8 16 04 1036*      call printNewLine
041C9A             1037*  
041C9A             1038*  ; restore everything
041C9A F1          1039*      pop af
041C9B E1          1040*      pop hl
041C9C C1          1041*      pop bc
041C9D             1042*  
041C9D             1043*  ; all done
041C9D C9          1044*      ret
041C9E             1045*  
041C9E             1046*  
041C9E             1047*  ; print bytes from an address to the screen in binary format
041C9E             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041C9E             1049*  ; outputs: values of each byte printed to screen separated by spaces
041C9E             1050*  ; destroys: nothing
041C9E             1051*  dumpMemoryBin:
041C9E             1052*  ; save all registers to the stack
041C9E F5          1053*      push af
041C9F C5          1054*      push bc
041CA0 D5          1055*      push de
041CA1 E5          1056*      push hl
041CA2 DD E5       1057*      push ix
041CA4 FD E5       1058*      push iy
041CA6             1059*  
041CA6             1060*  ; set b to be our loop counter
041CA6 47          1061*      ld b,a
041CA7             1062*  @loop:
041CA7             1063*  ; print the byte
041CA7 7E          1064*      ld a,(hl)
041CA8 E5          1065*      push hl
041CA9 C5          1066*      push bc
041CAA CD 71 19 04 1067*      call printBin8
041CAE C1          1068*      pop bc
041CAF             1069*  ; print a space
041CAF 3E 20       1070*      ld a,' '
041CB1 5B D7       1071*      rst.lil 10h
041CB3 E1          1072*      pop hl
041CB4 23          1073*      inc hl
041CB5 10 F0       1074*      djnz @loop
041CB7 CD E8 16 04 1075*      call printNewLine
041CBB             1076*  
041CBB             1077*  ; restore everything
041CBB FD E1       1078*      pop iy
041CBD DD E1       1079*      pop ix
041CBF E1          1080*      pop hl
041CC0 D1          1081*      pop de
041CC1 C1          1082*      pop bc
041CC2 F1          1083*      pop af
041CC3             1084*  ; all done
041CC3 C9          1085*      ret
041CC4             1086*  
041CC4             1087*  ; print bytes from an address to the screen in binary format
041CC4             1088*  ; with the bits of each byte in reverse order (lsb first)
041CC4             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041CC4             1090*  ; outputs: values of each byte printed to screen separated by spaces
041CC4             1091*  ; destroys: nothing
041CC4             1092*  dumpMemoryBinRev:
041CC4             1093*  ; save all registers to the stack
041CC4 F5          1094*      push af
041CC5 C5          1095*      push bc
041CC6 D5          1096*      push de
041CC7 E5          1097*      push hl
041CC8 DD E5       1098*      push ix
041CCA FD E5       1099*      push iy
041CCC             1100*  
041CCC             1101*  ; set b to be our loop counter
041CCC 47          1102*      ld b,a
041CCD             1103*  @loop:
041CCD             1104*  ; print the byte
041CCD 7E          1105*      ld a,(hl)
041CCE E5          1106*      push hl
041CCF C5          1107*      push bc
041CD0 CD 96 19 04 1108*      call printBin8Rev
041CD4 C1          1109*      pop bc
041CD5             1110*  ; print a space
041CD5 3E 20       1111*      ld a,' '
041CD7 5B D7       1112*      rst.lil 10h
041CD9 E1          1113*      pop hl
041CDA 23          1114*      inc hl
041CDB 10 F0       1115*      djnz @loop
041CDD CD E8 16 04 1116*      call printNewLine
041CE1             1117*  
041CE1             1118*  ; restore everything
041CE1 FD E1       1119*      pop iy
041CE3 DD E1       1120*      pop ix
041CE5 E1          1121*      pop hl
041CE6 D1          1122*      pop de
041CE7 C1          1123*      pop bc
041CE8 F1          1124*      pop af
041CE9             1125*  ; all done
041CE9 C9          1126*      ret
041CEA             0053       include "vdu.inc"
041CEA             0001*  
041CEA             0002*  ; VDU 30: Home cursor
041CEA             0003*  vdu_home_cursor:
041CEA 3E 1E       0004*      ld a,30
041CEC 5B D7       0005*  	rst.lil $10
041CEE C9          0006*  	ret
041CEF             0007*  
041CEF             0008*  vdu_cursor_on:
041CEF 21 FA 1C 04 0009*  	ld hl,@cmd
041CF3 01 03 00 00 0010*  	ld bc,@end-@cmd
041CF7 5B DF       0011*  	rst.lil $18
041CF9 C9          0012*  	ret
041CFA             0013*  @cmd:
041CFA 17 01 01    0014*  	db 23,1,1
041CFD             0015*  @end:
041CFD             0016*  
041CFD             0017*  vdu_cursor_off:
041CFD 21 08 1D 04 0018*  	ld hl,@cmd
041D01 01 03 00 00 0019*  	ld bc,@end-@cmd
041D05 5B DF       0020*  	rst.lil $18
041D07 C9          0021*  	ret
041D08             0022*  @cmd:
041D08 17 01 00    0023*  	db 23,1,0
041D0B             0024*  @end:
041D0B             0025*  
041D0B             0026*  ; VDU 5: Write text at graphics cursor
041D0B             0027*  ; inputs: a is the character to write to the screen
041D0B             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041D0B             0029*  ; outputs: see the name of the function
041D0B             0030*  ; destroys: a, hl, bc
041D0B             0031*  vdu_char_to_gfx_cursor:
041D0B 32 1B 1D 04 0032*  	ld (@arg),a
041D0F 21 1A 1D 04 0033*  	ld hl,@cmd
041D13 01 02 00 00 0034*  	ld bc,@end-@cmd
041D17 5B DF       0035*  	rst.lil $18
041D19 C9          0036*  	ret
041D1A 05          0037*  @cmd: db 5
041D1B 00          0038*  @arg: db 0
041D1C             0039*  @end:
041D1C             0040*  ; VDU 9: Move cursor forward one character
041D1C             0041*  vdu_cursor_forward:
041D1C 3E 09       0042*      ld a,9
041D1E 5B D7       0043*  	rst.lil $10
041D20 C9          0044*  	ret
041D21             0045*  
041D21             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041D21             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041D21             0048*  vdu_move_cursor:
041D21 ED 43 32 1D 0049*      ld (@x0),bc
       04          
041D26 21 31 1D 04 0050*  	ld hl,@cmd
041D2A 01 03 00 00 0051*  	ld bc,@end-@cmd
041D2E 5B DF       0052*  	rst.lil $18
041D30 C9          0053*  	ret
041D31 1F          0054*  @cmd: 	db 31
041D32 00          0055*  @x0:	db 0
041D33 00          0056*  @y0: 	db 0
041D34 00          0057*  @end: 	db 0 ; padding
041D35             0058*  
041D35             0059*  ; VDU 12: Clear text area (CLS)
041D35             0060*  vdu_cls:
041D35 3E 0C       0061*      ld a,12
041D37 5B D7       0062*  	rst.lil $10
041D39 C9          0063*  	ret
041D3A             0064*  
041D3A             0065*  vdu_flip:
041D3A 21 45 1D 04 0066*  	ld hl,@cmd
041D3E 01 03 00 00 0067*  	ld bc,@end-@cmd
041D42 5B DF       0068*  	rst.lil $18
041D44 C9          0069*  	ret
041D45 17 00 C3    0070*  @cmd: db 23,0,0xC3
041D48             0071*  @end:
041D48             0072*  
041D48             0073*  ; VDU 16: Clear graphics area (CLG)
041D48             0074*  vdu_clg:
041D48 3E 10       0075*      ld a,16
041D4A 5B D7       0076*  	rst.lil $10
041D4C C9          0077*  	ret
041D4D             0078*  
041D4D             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041D4D             0080*  ; VDU 23, 7: Scrolling
041D4D             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041D4D             0082*  ; inputs: a, extent; l, direction; h; speed
041D4D             0083*  vdu_scroll_down:
041D4D 32 62 1D 04 0084*  	ld (@extent),a
041D51 22 63 1D 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041D55 21 60 1D 04 0086*  	ld hl,@cmd
041D59 01 05 00 00 0087*  	ld bc,@end-@cmd
041D5D 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041D5F C9          0089*  	ret
041D60 17 07       0090*  @cmd:       db 23,7
041D62 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041D63 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041D64 00          0093*  @speed:     db 0x00 ; pixels
041D65 00          0094*  @end:		db 0x00 ; padding
041D66             0095*  
041D66             0096*  ; COLOUR MODES
041D66             0097*  ; Mode	Effect
041D66             0098*  ; 0	Set on-screen pixel to target colour value
041D66             0099*  ; 1	OR value with the on-screen pixel
041D66             0100*  ; 2	AND value with the on-screen pixel
041D66             0101*  ; 3	XOR value with the on-screen pixel
041D66             0102*  ; 4	Invert the on-screen pixel
041D66             0103*  ; 5	No operation
041D66             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041D66             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041D66             0106*  
041D66             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041D66             0108*  vdu_colour_text:
041D66 32 76 1D 04 0109*  	ld (@arg),a
041D6A 21 75 1D 04 0110*  	ld hl,@cmd
041D6E 01 02 00 00 0111*  	ld bc,@end-@cmd
041D72 5B DF       0112*  	rst.lil $18
041D74 C9          0113*  	ret
041D75 11          0114*  @cmd: db 17
041D76 00          0115*  @arg: db 0
041D77             0116*  @end:
041D77             0117*  
041D77             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041D77             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041D77             0120*  vdu_gcol:
041D77 32 8C 1D 04 0121*  	ld (@mode),a
041D7B 79          0122*      ld a,c
041D7C 32 8D 1D 04 0123*      ld (@col),a
041D80 21 8B 1D 04 0124*  	ld hl,@cmd
041D84 01 03 00 00 0125*  	ld bc,@end-@cmd
041D88 5B DF       0126*  	rst.lil $18
041D8A C9          0127*  	ret
041D8B 12          0128*  @cmd:  db 18
041D8C 00          0129*  @mode: db 0
041D8D 00          0130*  @col:  db 0
041D8E             0131*  @end:
041D8E             0132*  
041D8E             0133*  
041D8E             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041D8E             0135*  ; MIND THE LITTLE-ENDIANESS
041D8E             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041D8E             0137*  ; outputs; nothing
041D8E             0138*  ; destroys: a might make it out alive
041D8E             0139*  vdu_set_txt_viewport:
041D8E ED 43 A4 1D 0140*      ld (@lb),bc
       04          
041D93 ED 53 A6 1D 0141*  	ld (@rt),de
       04          
041D98 21 A3 1D 04 0142*  	ld hl,@cmd
041D9C 01 05 00 00 0143*  	ld bc,@end-@cmd
041DA0 5B DF       0144*  	rst.lil $18
041DA2 C9          0145*  	ret
041DA3 1C          0146*  @cmd:   db 28 ; set text viewport command
041DA4 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041DA6 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041DA8 00          0149*  @end:   db 0x00	  ; padding
041DA9             0150*  
041DA9             0151*  ; Wait for VBLANK interrupt
041DA9             0152*  vdu_vblank:
041DA9 DD E5       0153*      PUSH 	IX
041DAB             0154*  	MOSCALL	mos_sysvars
041DAB 3E 08       0001*M 			LD	A, function
041DAD 5B CF       0002*M 			RST.LIL	08h
041DAF DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041DB2             0156*  @wait:
041DB2 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041DB5 28 FB       0158*      JR	Z, @wait
041DB7 DD E1       0159*      POP	IX
041DB9 C9          0160*      RET
041DBA             0161*  
041DBA             0162*  ; VDU 29, x; y;: Set graphics origin
041DBA             0163*  ; This command sets the graphics origin.
041DBA             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041DBA             0165*  ; inputs: bc=x0,de=y0
041DBA             0166*  ; outputs; nothing
041DBA             0167*  ; destroys: a might make it out alive
041DBA             0168*  vdu_set_gfx_origin:
041DBA ED 43 D0 1D 0169*      ld (@x0),bc
       04          
041DBF ED 53 D2 1D 0170*      ld (@y0),de
       04          
041DC4 21 CF 1D 04 0171*      ld hl,@cmd
041DC8 01 05 00 00 0172*      ld bc,@end-@cmd
041DCC 5B DF       0173*      rst.lil $18
041DCE C9          0174*      ret
041DCF 1D          0175*  @cmd:   db 29 ; set graphics origin command
041DD0 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041DD2 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041DD4 00          0178*  @end:   db 0x00	  ; padding
041DD5             0179*  
041DD5             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041DD5             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041DD5             0182*  ; 	because we have turned off logical screen scaling
041DD5             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041DD5             0184*  ; outputs; nothing
041DD5             0185*  ; destroys: a might make it out alive
041DD5             0186*  vdu_set_gfx_viewport:
041DD5 ED 43 F5 1D 0187*      ld (@x0),bc
       04          
041DDA FD 22 F7 1D 0188*      ld (@y1),iy
       04          
041DDF DD 22 F9 1D 0189*  	ld (@x1),ix
       04          
041DE4 ED 53 FB 1D 0190*  	ld (@y0),de
       04          
041DE9 21 F4 1D 04 0191*  	ld hl,@cmd
041DED 01 09 00 00 0192*  	ld bc,@end-@cmd
041DF1 5B DF       0193*  	rst.lil $18
041DF3 C9          0194*  	ret
041DF4 18          0195*  @cmd:   db 24 ; set graphics viewport command
041DF5 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041DF7 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041DF9 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041DFB 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041DFD 00          0200*  @end:   db 0x00	  ; padding
041DFE             0201*  
041DFE             0202*  ; SCREEN MODES
041DFE             0203*  ; ===============================
041DFE             0204*  ; Mode  Horz  Vert  Cols  Refresh
041DFE             0205*  ; ---   ----  ----  ----  -------
041DFE             0206*  ; 11    320   240   2     60hz
041DFE             0207*  ; 139   320   240   2     60hz
041DFE             0208*  ; 23    512   384   2     60hz
041DFE             0209*  ; 151   512   384   2     60hz
041DFE             0210*  ; 6     640   240   2     60hz
041DFE             0211*  ; 134   640   240   2     60hz
041DFE             0212*  ; 2     640   480   2     60hz
041DFE             0213*  ; 130   640   480   2     60hz
041DFE             0214*  ; 17    800   600   2     60hz
041DFE             0215*  ; 145   800   600   2     60hz
041DFE             0216*  ; 18    1024  768   2     60hz
041DFE             0217*  ; 146   1024  768   2     60hz
041DFE             0218*  ; ---   ----  ----  ----  -------
041DFE             0219*  ; 10    320   240   4     60hz
041DFE             0220*  ; 138   320   240   4     60hz
041DFE             0221*  ; 22    512   384   4     60hz
041DFE             0222*  ; 150   512   384   4     60hz
041DFE             0223*  ; 5     640   240   4     60hz
041DFE             0224*  ; 133   640   240   4     60hz
041DFE             0225*  ; 1     640   480   4     60hz
041DFE             0226*  ; 129   640   480   4     60hz
041DFE             0227*  ; 16    800   600   4     60hz
041DFE             0228*  ; 19    1024  768   4     60hz
041DFE             0229*  ; ---   ----  ----  ----  -------
041DFE             0230*  ; 9     320   240   16    60hz
041DFE             0231*  ; 137   320   240   16    60hz
041DFE             0232*  ; 21    512   384   16    60hz
041DFE             0233*  ; 149   512   384   16    60hz
041DFE             0234*  ; 4     640   240   16    60hz
041DFE             0235*  ; 132   640   240   16    60hz
041DFE             0236*  ; 0     640   480   16    60hz
041DFE             0237*  ; 7     n/a   n/a   16    60hz
041DFE             0238*  ; ---   ----  ----  ----  -------
041DFE             0239*  ; 8     320   240   64    60hz
041DFE             0240*  ; 136   320   240   64    60hz
041DFE             0241*  ; 20    512   384   64    60hz
041DFE             0242*  ; 3     640   240   64    60hz
041DFE             0243*  ; ---   ----  ----  ----  -------
041DFE             0244*  vdu_set_screen_mode:
041DFE 32 0E 1E 04 0245*  	ld (@arg),a
041E02 21 0D 1E 04 0246*  	ld hl,@cmd
041E06 01 02 00 00 0247*  	ld bc,@end-@cmd
041E0A 5B DF       0248*  	rst.lil $18
041E0C C9          0249*  	ret
041E0D 16          0250*  @cmd: db 22 ; set screen mode
041E0E 00          0251*  @arg: db 0  ; screen mode parameter
041E0F             0252*  @end:
041E0F             0253*  
041E0F             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041E0F             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041E0F             0256*  ; note: default setting on boot is scaling ON
041E0F             0257*  vdu_set_scaling:
041E0F 32 21 1E 04 0258*  	ld (@arg),a
041E13 21 1E 1E 04 0259*  	ld hl,@cmd
041E17 01 04 00 00 0260*  	ld bc,@end-@cmd
041E1B 5B DF       0261*  	rst.lil $18
041E1D C9          0262*  	ret
041E1E 17 00 C0    0263*  @cmd: db 23,0,0xC0
041E21 00          0264*  @arg: db 0  ; scaling on/off
041E22             0265*  @end:
041E22             0266*  
041E22             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041E22             0268*  ; inputs: hl=bufferId
041E22             0269*  vdu_buff_select:
041E22 22 34 1E 04 0270*  	ld (@bufferId),hl
041E26 21 31 1E 04 0271*  	ld hl,@cmd
041E2A 01 05 00 00 0272*  	ld bc,@end-@cmd
041E2E 5B DF       0273*  	rst.lil $18
041E30 C9          0274*  	ret
041E31 17 1B 20    0275*  @cmd: db 23,27,0x20
041E34 00 00       0276*  @bufferId: dw 0x0000
041E36 00          0277*  @end: db 0x00 ; padding
041E37             0278*  
041E37             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041E37             0280*  ; inputs: a=format; bc=width; de=height
041E37             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041E37             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041E37             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041E37             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041E37             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041E37             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041E37             0287*  vdu_bmp_create:
041E37 ED 43 53 1E 0288*      ld (@width),bc
       04          
041E3C ED 53 55 1E 0289*      ld (@height),de
       04          
041E41 32 57 1E 04 0290*      ld (@fmt),a
041E45 21 50 1E 04 0291*  	ld hl,@cmd
041E49 01 08 00 00 0292*  	ld bc,@end-@cmd
041E4D 5B DF       0293*  	rst.lil $18
041E4F C9          0294*  	ret
041E50 17 1B 21    0295*  @cmd:       db 23,27,0x21
041E53 00 00       0296*  @width:     dw 0x0000
041E55 00 00       0297*  @height:    dw 0x0000
041E57 00          0298*  @fmt:       db 0x00
041E58             0299*  @end:
041E58             0300*  
041E58             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041E58             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041E58             0303*  vdu_load_img_rgba2_to_8:
041E58             0304*  ; backup the target buffer id and image dimensions
041E58 E5          0305*      push hl
041E59 D5          0306*      push de
041E5A C5          0307*      push bc
041E5B             0308*  ; load the rgba2 image to working buffer 65534
041E5B 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041E5F CD 62 1F 04 0310*  	call vdu_load_buffer_from_file
041E63             0311*  ; restore the image dimensions and target buffer id
041E63 C1          0312*      pop bc
041E64 D1          0313*      pop de
041E65 E1          0314*      pop hl
041E66             0315*  ; fall through to vdu_rgba2_to_8
041E66             0316*  
041E66             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041E66             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041E66             0319*  ; the "expand bitmap" command is:
041E66             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041E66             0321*  ; and then to reverse the byte order to fix endian-ness:
041E66             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041E66             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041E66             0324*  ; VDU 23,27,&20,targetBufferID%;
041E66             0325*  ; VDU 23,27,&21,width%;height%;0
041E66             0326*  ; -------------------------------------------------------------------
041E66             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041E66             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041E66             0329*  vdu_rgba2_to_8:
041E66             0330*  ; load the image dimensions and buffer id parameters
041E66 ED 43 C2 1E 0331*      ld (@width),bc
       04          
041E6B ED 53 C4 1E 0332*      ld (@height),de
       04          
041E70 22 A7 1E 04 0333*      ld (@bufferId0),hl
041E74 22 B4 1E 04 0334*      ld (@bufferId2),hl
041E78 22 BD 1E 04 0335*      ld (@bufferId1),hl
041E7C             0336*  ; clean up bytes that got stomped on by the ID loads
041E7C 3E 48       0337*      ld a,0x48
041E7E 32 A9 1E 04 0338*      ld (@bufferId0+2),a
041E82 3E 17       0339*      ld a,23
041E84 32 BF 1E 04 0340*      ld (@bufferId1+2),a
041E88 3E 18       0341*      ld a,24
041E8A 32 B6 1E 04 0342*      ld (@bufferId2+2),a
041E8E AF          0343*      xor a
041E8F 32 C6 1E 04 0344*      ld (@height+2),a
041E93             0345*  ; send the vdu command strings
041E93 21 9E 1E 04 0346*      ld hl,@beg
041E97 01 29 00 00 0347*      ld bc,@end-@beg
041E9B 5B DF       0348*      rst.lil $18
041E9D C9          0349*      ret
041E9E             0350*  @beg:
041E9E             0351*  ; Command 14: Consolidate blocks in a buffer
041E9E             0352*  ; VDU 23, 0, &A0, bufferId; 14
041E9E 17 00 A0    0353*      db 23,0,0xA0
041EA1 FE FF       0354*      dw 65534 ; workingBufferId
041EA3 0E          0355*      db 14 ; consolidate blocks
041EA4             0356*  ; the "expand bitmap" command is:
041EA4             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041EA4 17 00 A0    0358*      db 23,0,0xA0
041EA7 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041EA9 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041EAA 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041EAB FE FF       0362*      dw 65534 ; sourceBufferId
041EAD 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041EB1             0364*  ; reverse the byte order to fix endian-ness:
041EB1             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041EB1             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041EB1             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041EB1 17 00 A0    0368*      db 23,0,0xA0
041EB4 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041EB6 18          0370*      db 24 ; reverse byte order
041EB7 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041EB8 04 00       0372*      dw 4 ; size (4 bytes)
041EBA             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041EBA             0374*  ; VDU 23,27,&20,targetBufferID%;
041EBA 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041EBD 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041EBF             0377*  ; VDU 23,27,&21,width%;height%;0
041EBF 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041EC2 00 00       0379*  @width: dw 0x0000
041EC4 00 00       0380*  @height: dw 0x0000
041EC6 00          0381*      db 0x00 ; rgba8888 format
041EC7             0382*  @end:
041EC7             0383*  
041EC7             0384*  ; scratch variables
041EC7 00 00 00    0385*  bufferId0: dl 0x000000
041ECA 00 00 00    0386*  bufferId1: dl 0x000000
041ECD             0387*  
041ECD             0388*  ; load a vdu buffer from local memory
041ECD             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041ECD             0390*  vdu_load_buffer:
041ECD ED 43 F6 1E 0391*      ld (@length),bc
       04          
041ED2 D5          0392*      push de ; save data pointer
041ED3             0393*  ; send the vdu command string
041ED3 7D          0394*      ld a,l
041ED4 32 F3 1E 04 0395*      ld (@bufferId),a
041ED8 7C          0396*      ld a,h
041ED9 32 F4 1E 04 0397*      ld (@bufferId+1),a
041EDD 21 F0 1E 04 0398*      ld hl,@cmd
041EE1 01 08 00 00 0399*      ld bc,@end-@cmd
041EE5 5B DF       0400*      rst.lil $18
041EE7             0401*  ; send the buffer data
041EE7 E1          0402*      pop hl ; pointer to data
041EE8 ED 4B F6 1E 0403*      ld bc,(@length)
       04          
041EED 5B DF       0404*      rst.lil $18 ; send it
041EEF C9          0405*      ret
041EF0             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041EF0 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041EF3 00 00       0408*  @bufferId:	dw 0x0000
041EF5 00          0409*  		    db 0 ; load buffer
041EF6 00 00       0410*  @length:	dw 0x0000
041EF8 00          0411*  @end: db 0 ; padding
041EF9             0412*  
041EF9             0413*  ; clear a buffer
041EF9             0414*  ; inputs: hl = bufferId
041EF9             0415*  vdu_clear_buffer:
041EF9 7D          0416*      ld a,l
041EFA 32 11 1F 04 0417*      ld (@bufferId),a
041EFE 7C          0418*      ld a,h
041EFF 32 12 1F 04 0419*      ld (@bufferId+1),a
041F03 21 0E 1F 04 0420*      ld hl,@cmd
041F07 01 06 00 00 0421*      ld bc,@end-@cmd
041F0B 5B DF       0422*      rst.lil $18
041F0D C9          0423*      ret
041F0E 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041F11 00 00       0425*  @bufferId:	dw 0x0000
041F13 02          0426*  		    db 2 ; clear buffer
041F14             0427*  @end:
041F14             0428*  
041F14             0429*  vdu_clear_all_buffers:
041F14             0430*  ; clear all buffers
041F14 21 1F 1F 04 0431*      ld hl,@beg
041F18 01 06 00 00 0432*      ld bc,@end-@beg
041F1C 5B DF       0433*      rst.lil $18
041F1E C9          0434*      ret
041F1F 17 00 A0    0435*  @beg: db 23,0,$A0
041F22 FF FF       0436*        dw -1 ; clear all buffers
041F24 02          0437*        db 2  ; command 2: clear a buffer
041F25             0438*  @end:
041F25             0439*  
041F25             0440*  ; Command 14: Consolidate blocks in a buffer
041F25             0441*  vdu_consolidate_buffer:
041F25             0442*  ; set parameters for vdu call
041F25 7D          0443*      ld a,l
041F26 32 3D 1F 04 0444*      ld (@bufferId),a
041F2A 7C          0445*      ld a,h
041F2B 32 3E 1F 04 0446*      ld (@bufferId+1),a
041F2F 21 3A 1F 04 0447*      ld hl,@beg
041F33 01 06 00 00 0448*      ld bc,@end-@beg
041F37 5B DF       0449*      rst.lil $18
041F39 C9          0450*      ret
041F3A             0451*  ; VDU 23, 0, &A0, bufferId; 14
041F3A 17 00 A0    0452*  @beg: db 23,0,0xA0
041F3D 00 00       0453*  @bufferId: dw 0x0000
041F3F 0E          0454*             db 14
041F40             0455*  @end:
041F40             0456*  
041F40             0457*  ; load an image file to a buffer and make it a bitmap
041F40             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041F40             0459*  vdu_load_img:
041F40             0460*  ; back up image type and dimension parameters
041F40 22 C7 1E 04 0461*      ld (bufferId0),hl
041F44 F5          0462*      push af
041F45 C5          0463*  	push bc
041F46 D5          0464*  	push de
041F47             0465*  ; load the image
041F47 CD 62 1F 04 0466*  	call vdu_load_buffer_from_file
041F4B             0467*  ; now make it a bitmap
041F4B 2A C7 1E 04 0468*      ld hl,(bufferId0)
041F4F CD 25 1F 04 0469*      call vdu_consolidate_buffer
041F53 2A C7 1E 04 0470*      ld hl,(bufferId0)
041F57 CD 22 1E 04 0471*      call vdu_buff_select
041F5B D1          0472*  	pop de ; image height
041F5C C1          0473*  	pop bc ; image width
041F5D F1          0474*  	pop af ; image type
041F5E C3 37 1E 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041F62             0476*  
041F62             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041F62             0478*  vdu_load_buffer_from_file:
041F62 22 C7 1E 04 0479*      ld (bufferId0),hl
041F66             0480*  
041F66             0481*  ; clear target buffer
041F66 CD F9 1E 04 0482*      call vdu_clear_buffer
041F6A             0483*  
041F6A             0484*  ; open the file in read mode
041F6A             0485*  ; Open a file
041F6A             0486*  ; HLU: Filename
041F6A             0487*  ;   C: Mode
041F6A             0488*  ; Returns:
041F6A             0489*  ;   A: Filehandle, or 0 if couldn't open
041F6A FD E5       0490*  	push iy ; pointer to filename
041F6C E1          0491*  	pop hl
041F6D 0E 01       0492*  	ld c,fa_read
041F6F             0493*      MOSCALL mos_fopen
041F6F 3E 0A       0001*M 			LD	A, function
041F71 5B CF       0002*M 			RST.LIL	08h
041F73 32 AE 1F 04 0494*      ld (@filehandle),a
041F77             0495*  
041F77             0496*  @read_file:
041F77             0497*  ; Read a block of data from a file
041F77             0498*  ;   C: Filehandle
041F77             0499*  ; HLU: Pointer to where to write the data to
041F77             0500*  ; DEU: Number of bytes to read
041F77             0501*  ; Returns:
041F77             0502*  ; DEU: Number of bytes read
041F77 3A AE 1F 04 0503*      ld a,(@filehandle)
041F7B 4F          0504*      ld c,a
041F7C 21 00 E0 B7 0505*      ld hl,filedata
041F80 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041F84             0507*      MOSCALL mos_fread
041F84 3E 1A       0001*M 			LD	A, function
041F86 5B CF       0002*M 			RST.LIL	08h
041F88             0508*  
041F88             0509*  ; test de for zero bytes read
041F88 21 00 00 00 0510*      ld hl,0
041F8C AF          0511*      xor a ; clear carry
041F8D ED 52       0512*      sbc hl,de
041F8F CA A5 1F 04 0513*      jp z,@close_file
041F93             0514*  
041F93             0515*  ; load a vdu buffer from local memory
041F93             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041F93 2A C7 1E 04 0517*      ld hl,(bufferId0)
041F97 D5          0518*      push de ; chunksize
041F98 C1          0519*      pop bc
041F99 11 00 E0 B7 0520*      ld de,filedata
041F9D CD CD 1E 04 0521*      call vdu_load_buffer
041FA1             0522*  
041FA1             0523*  ; read the next block
041FA1 C3 77 1F 04 0524*      jp @read_file
041FA5             0525*  
041FA5             0526*  ; close the file
041FA5             0527*  @close_file:
041FA5 3A AE 1F 04 0528*      ld a,(@filehandle)
041FA9             0529*      MOSCALL mos_fclose
041FA9 3E 0B       0001*M 			LD	A, function
041FAB 5B CF       0002*M 			RST.LIL	08h
041FAD C9          0530*      ret ; vdu_load_buffer_from_file
041FAE             0531*  
041FAE 00          0532*  @filehandle: db 0 ; file handle
041FAF 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
041FB2             0534*  
041FB2 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
041FB5             0536*  
041FB5             0537*  ; File information structure (FILINFO)
041FB5             0538*  @filinfo:
041FB5 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041FB9 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041FBB 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041FBD 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041FBE 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041FCB 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0420CB             0054       include "vdu_buff.inc"
0420CB             0001*  ; VDP Buffered Commands API
0420CB             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
0420CB             0003*  
0420CB             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420CB             0005*  ; This command is used to store a data block (a sequence of bytes)
0420CB             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
0420CB             0007*  ; It could be a sequence of VDU commands which can be executed
0420CB             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
0420CB             0009*  ; When used for a sequence of VDU commands, this effectively
0420CB             0010*  ; allows for functions or stored procedures to be created.
0420CB             0011*  
0420CB             0012*  ; This is the most common command to use to send data to the VDP.
0420CB             0013*  ; Typically you will call command 2 first to ensure that the
0420CB             0014*  ; buffer is empty, and then make a series of calls to this command
0420CB             0015*  ; to send data to the buffer.
0420CB             0016*  
0420CB             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
0420CB             0018*  ; write to. Writing to the same buffer ID multiple times will add
0420CB             0019*  ; new blocks to that buffer. This allows a buffer to be built up
0420CB             0020*  ; over time, essentially allowing for a command to be sent across
0420CB             0021*  ; to the VDP in multiple separate packets.
0420CB             0022*  
0420CB             0023*  ; Whilst the length of an individual block added using this command
0420CB             0024*  ; is restricted to 65535 bytes (as the largest value that can be
0420CB             0025*  ; sent in a 16-bit number) the total size of a buffer is not
0420CB             0026*  ; restricted to this size, as multiple blocks can be added to a
0420CB             0027*  ; buffer. Given how long it takes to send data to the VDP it is
0420CB             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
0420CB             0029*  ; data or less at a time.
0420CB             0030*  
0420CB             0031*  ; As writing to a single buffer ID is cumulative with this command,
0420CB             0032*  ; care should be taken to ensure that the buffer is cleared out
0420CB             0033*  ; before writing to it.
0420CB             0034*  
0420CB             0035*  ; When building up a complex sequence of commands it is often
0420CB             0036*  ; advisable to use multiple blocks within a buffer. Typically
0420CB             0037*  ; this is easier to code, as otherwise working out exactly how
0420CB             0038*  ; many bytes long a command sequence is can be can be onerously
0420CB             0039*  ; difficult. It is also easier to modify a command sequences that
0420CB             0040*  ; are broken up into multiple blocks.
0420CB             0041*  
0420CB             0042*  ; As mentioned above it is advisable to send large pieces of data,
0420CB             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
0420CB             0044*  ; each packet of data sent to a buffer, the user can then perform
0420CB             0045*  ; other operations, such as updating the screen to indicate
0420CB             0046*  ; progress. This allows for long-running operations to be performed
0420CB             0047*  ; without blocking the screen, and larger amounts of data to be
0420CB             0048*  ; transferred over to the VDP than may otherwise be practical given
0420CB             0049*  ; the limitations of the eZ80.
0420CB             0050*  
0420CB             0051*  ; If a buffer ID of 65535 is used then this command will be
0420CB             0052*  ; ignored, and the data discarded. This is because this buffer ID
0420CB             0053*  ; is reserved for special functions.
0420CB             0054*  
0420CB             0055*  ; Using buffers for bitmaps
0420CB             0056*  
0420CB             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
0420CB             0058*  ; they cannot be used if they are spread over multiple blocks.
0420CB             0059*  ; To use a bitmap its data must be in a single contiguous block,
0420CB             0060*  ; and this is achieved by using the “consolidate” command &0E.
0420CB             0061*  
0420CB             0062*  ; Once you have a block that is ready to be used for a bitmap,
0420CB             0063*  ; the buffer must be selected, and then a bitmap created for that
0420CB             0064*  ; buffer using the bitmap and sprites API. This is done with the
0420CB             0065*  ; following commands:
0420CB             0066*  
0420CB             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
0420CB             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
0420CB             0069*  
0420CB             0070*  ; Until the “create bitmap” call has been made the buffer cannot
0420CB             0071*  ; be used as a bitmap. That is because the system needs to
0420CB             0072*  ; understand the dimensions of the bitmap, as well as the format
0420CB             0073*  ; of the data. Usually this only needs to be done once. The format
0420CB             0074*  ; is given as an 8-bit value, with the following values supported:
0420CB             0075*  ; Value 	Type 	Description
0420CB             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
0420CB             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
0420CB             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
0420CB             0079*  
0420CB             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
0420CB             0081*  ; and these are automatically stored in buffers numbered 64000-64255
0420CB             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
0420CB             0083*  ; simply a matter of adding 64000. All bitmaps created with that
0420CB             0084*  ; API will be RGBA8888 format.
0420CB             0085*  
0420CB             0086*  ; There is one other additional call added to the bitmap and
0420CB             0087*  ; sprites API, which allows for bitmaps referenced with a
0420CB             0088*  ; buffer ID to be added to sprites. This is done with the
0420CB             0089*  ; following command:
0420CB             0090*  
0420CB             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
0420CB             0092*  
0420CB             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
0420CB             0094*  
0420CB             0095*  ; It should be noted that it is possible to modify the buffer
0420CB             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
0420CB             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
0420CB             0098*  ; can allow you to do things such as changing colours in a bitmap,
0420CB             0099*  ; or flipping an image horizontally or vertically. This will even
0420CB             0100*  ; work on bitmaps that are being used inside sprites.
0420CB             0101*  
0420CB             0102*  ; Using commands targetting a buffer that create new blocks,
0420CB             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
0420CB             0104*  ; and remove it from use.
0420CB             0105*  
0420CB             0106*  ; Using buffers for sound samples
0420CB             0107*  
0420CB             0108*  ; Much like with bitmaps, it is advisable to send samples over
0420CB             0109*  ; to the VDP in multiple blocks for the same reasons.
0420CB             0110*  
0420CB             0111*  ; In contrast to bitmaps, the sound system can play back samples
0420CB             0112*  ; that are spread over multiple blocks, so there is no need to
0420CB             0113*  ; consolidate buffers. As a result of this, the sample playback
0420CB             0114*  ; system is also more tolerant of modifications being made to
0420CB             0115*  ; the buffer after a sample has been created from it, even if
0420CB             0116*  ; the sample is currently playing. It should be noted that
0420CB             0117*  ; splitting a buffer may result in unexpected behaviour if
0420CB             0118*  ; the sample is currently playing, such as skipping to other
0420CB             0119*  ; parts of the sample.
0420CB             0120*  
0420CB             0121*  ; Once you have a buffer that contains block(s) that are ready
0420CB             0122*  ; to be used for a sound sample, the following command must be
0420CB             0123*  ; used to indicate that a sample should be created from that buffer:
0420CB             0124*  
0420CB             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
0420CB             0126*  
0420CB             0127*  ; The format parameter is an 8-bit value that indicates the
0420CB             0128*  ; format of the sample data. The following values are supported:
0420CB             0129*  ; Value 	Description
0420CB             0130*  ; 0 	8-bit signed, 16KHz
0420CB             0131*  ; 1 	8-bit unsigned, 16KHz
0420CB             0132*  
0420CB             0133*  ; Once a sample has been created in this way, the sample can
0420CB             0134*  ; be selected for use on a channel using the following command:
0420CB             0135*  
0420CB             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
0420CB             0137*  
0420CB             0138*  ; Samples uploaded using the existing “load sample” command
0420CB             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
0420CB             0140*  ; are also stored in buffers automatically. A sample number using this system is in
0420CB             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
0420CB             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
0420CB             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
0420CB             0144*  ; buffer 64257, and so on.
0420CB             0145*  ; Command 1: Call a buffer
0420CB             0146*  
0420CB             0147*  ; VDU 23, 0 &A0, bufferId; 1
0420CB             0148*  
0420CB             0149*  ; This command will attempt to execute all of the commands
0420CB             0150*  ; stored in the buffer with the given ID. If the buffer does
0420CB             0151*  ; not exist, or is empty, then this command will do nothing.
0420CB             0152*  
0420CB             0153*  ; Essentially, this command passes the contents of the buffer
0420CB             0154*  ; to the VDP’s VDU command processor system, and executes them
0420CB             0155*  ; as if they were sent directly to the VDP.
0420CB             0156*  
0420CB             0157*  ; As noted against command 0, it is possible to build up a
0420CB             0158*  ; buffer over time by sending across multiple commands to write
0420CB             0159*  ; to the same buffer ID. When calling a buffer with multiple
0420CB             0160*  ; blocks, the blocks are executed in order.
0420CB             0161*  
0420CB             0162*  ; Care should be taken when using this command within a buffer,
0420CB             0163*  ; as it is possible to create an infinite loop. For instance,
0420CB             0164*  ; if a buffer contains a command to call itself, then this will
0420CB             0165*  ; result in an infinite loop. This will cause the VDP to hang,
0420CB             0166*  ; and the only way to recover from this is to reset the VDP.
0420CB             0167*  
0420CB             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
0420CB             0169*  ; to be executed. This can be useful for creating loops within
0420CB             0170*  ; a buffer. It will be ignored if used outside of a buffered
0420CB             0171*  ; command sequence.
0420CB             0172*  
0420CB             0173*  ; Command 2: Clear a buffer
0420CB             0174*  ; VDU 23, 0 &A0, bufferId; 2
0420CB             0175*  
0420CB             0176*  ; This command will clear the buffer with the given ID. If
0420CB             0177*  ; the buffer does not exist then this command will do nothing.
0420CB             0178*  
0420CB             0179*  ; Please note that this clears out all of the blocks sent to
0420CB             0180*  ; a buffer via command 0, not just the last one. i.e. if you
0420CB             0181*  ; have built up a buffer over time by sending multiple commands
0420CB             0182*  ; to write to the same buffer ID, this command will clear out
0420CB             0183*  ; all of those commands.
0420CB             0184*  
0420CB             0185*  ; Calling this command with a bufferId value of -1 (65535) will
0420CB             0186*  ; clear out all buffers.
0420CB             0187*  
0420CB             0188*  ; Command 3: Create a writeable buffer
0420CB             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
0420CB             0190*  ; This command will create a new writeable buffer with the given
0420CB             0191*  ; ID. If a buffer with the given ID already exists then this
0420CB             0192*  ; command will do nothing. This command is primarily intended
0420CB             0193*  ; for use to create a buffer that can be used to capture output
0420CB             0194*  ; using the “set output stream” command (see below), or to store
0420CB             0195*  ; data that can be used for other commands.
0420CB             0196*  
0420CB             0197*  ; It is generally quite rare that you will want to use this
0420CB             0198*  ; command. Typically you will instead want to use command 0
0420CB             0199*  ; to write data to a buffer. It is not necessary to use this
0420CB             0200*  ; command before using command 0, and indeed doing so will
0420CB             0201*  ; lead to errors as you will end up with two blocks in the
0420CB             0202*  ; buffer, the first of which will be empty. If you do wish
0420CB             0203*  ; to use this command to create a buffer for data and then
0420CB             0204*  ; write to it, you would need to use operation 2 of command 5,
0420CB             0205*  ; the “set” operation in the “buffer adjust” command, to set a
0420CB             0206*  ; sequence of bytes in the buffer to the data you want to write.
0420CB             0207*  ; This is not recommended, as it is much easier to just use
0420CB             0208*  ; command 0 to write a data block to a buffer.
0420CB             0209*  
0420CB             0210*  ; This new buffer will be a single empty single block upon
0420CB             0211*  ; creation, containing zeros.
0420CB             0212*  
0420CB             0213*  ; The length parameter is a 16-bit integer that specifies
0420CB             0214*  ; the maximum size of the buffer. This is the maximum number
0420CB             0215*  ; of bytes that can be stored in the buffer. If the buffer
0420CB             0216*  ; is full then no more data can be written to it, and subsequent
0420CB             0217*  ; writes will be ignored.
0420CB             0218*  
0420CB             0219*  ; After creating a buffer with this command it is possible to
0420CB             0220*  ; use command 0 to write further blocks to the buffer, however
0420CB             0221*  ; this is probably not advisable.
0420CB             0222*  
0420CB             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
0420CB             0224*  ; values have special meanings for writable buffers. See command 4.
0420CB             0225*  
0420CB             0226*  ; Command 4: Set output stream to a buffer
0420CB             0227*  ; VDU 23, 0 &A0, bufferId; 4
0420CB             0228*  
0420CB             0229*  ; Sets then current output stream to the buffer with the given ID.
0420CB             0230*  ; With two exceptions, noted below, this needs to be a writable
0420CB             0231*  ; buffer created with command 3. If the buffer does not exist,
0420CB             0232*  ; or the first block within the buffer is not writable, then
0420CB             0233*  ; this command will do nothing.
0420CB             0234*  
0420CB             0235*  ; Following this command, any subsequent VDU commands that send
0420CB             0236*  ; response packets will have those packets written to the specified
0420CB             0237*  ; output buffer. This allows the user to capture the response
0420CB             0238*  ; packets from a command sent to the VDP.
0420CB             0239*  
0420CB             0240*  ; By default, the output stream (for the main VDU command processor)
0420CB             0241*  ; is the communications channel from the VDP to MOS running on the
0420CB             0242*  ; eZ80.
0420CB             0243*  
0420CB             0244*  ; Passing a buffer ID of -1 (65535) to this command will
0420CB             0245*  ; remove/detach the output buffer. From that point onwards,
0420CB             0246*  ; any subsequent VDU commands that send response packets will
0420CB             0247*  ; have those responses discarded/ignored.
0420CB             0248*  
0420CB             0249*  ; Passing a buffer ID of 0 to this command will set the output
0420CB             0250*  ; buffer back to its original value for the current command stream.
0420CB             0251*  ; Typically that will be the communications channel from the VDP to
0420CB             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
0420CB             0253*  ; call has been made.
0420CB             0254*  
0420CB             0255*  ; When used inside a buffered command sequence, this command will
0420CB             0256*  ; only affect the output stream for that sequence of commands, and
0420CB             0257*  ; any other buffered command sequences that are called from within
0420CB             0258*  ; that sequence. Once the buffered command sequence has completed,
0420CB             0259*  ; the output stream will effectively be reset to its original value.
0420CB             0260*  
0420CB             0261*  ; It is strongly recommended to only use this command from within a
0420CB             0262*  ; buffered command sequence. Whilst it is possible to use this
0420CB             0263*  ; command from within a normal VDU command sequence, it is not
0420CB             0264*  ; recommended as it may cause unexpected behaviour. If you do use
0420CB             0265*  ; it in that context, it is very important to remember to restore
0420CB             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
0420CB             0267*  ; future, this command may be disabled from being used outside of
0420CB             0268*  ; a buffered command sequence.)
0420CB             0269*  
0420CB             0270*  ; At present, writable buffers can only be written to until the end
0420CB             0271*  ; of the buffer has been reached; once that happens no more data
0420CB             0272*  ; will be written to the buffer. It is not currently possible to
0420CB             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
0420CB             0274*  ; that the buffer is large enough to capture all of the data that
0420CB             0275*  ; is expected to be written to it. The only current way to “rewind”
0420CB             0276*  ; an output stream would be to clear the buffer and create a new
0420CB             0277*  ; one, and then call set output stream again with the newly created
0420CB             0278*  ; buffer.
0420CB             0279*  
0420CB             0280*  ; Command 5: Adjust buffer contents
0420CB             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
0420CB             0282*  
0420CB             0283*  ; This command will adjust the contents of a buffer, at a given
0420CB             0284*  ; offset. The exact nature of the adjustment will depend on the
0420CB             0285*  ; operation used.
0420CB             0286*  
0420CB             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
0420CB             0288*  ; the contents of the current buffer. This will only work if this
0420CB             0289*  ; command is used within a buffered command sequence, otherwise the
0420CB             0290*  ; command will not do anything.
0420CB             0291*  
0420CB             0292*  ; The basic set of adjustment operations are as follows:
0420CB             0293*  ; Operation 	Description
0420CB             0294*  ; 0 	NOT
0420CB             0295*  ; 1 	Negate
0420CB             0296*  ; 2 	Set value
0420CB             0297*  ; 3 	Add
0420CB             0298*  ; 4 	Add with carry
0420CB             0299*  ; 5 	AND
0420CB             0300*  ; 6 	OR
0420CB             0301*  ; 7 	XOR
0420CB             0302*  
0420CB             0303*  ; All of these operations will modify a byte found at the given
0420CB             0304*  ; offset in the buffer. The only exception to that is the “Add with
0420CB             0305*  ; carry” operation, which will also store the “carry” value in the
0420CB             0306*  ; byte at the next offset. With the exception of NOT and Negate,
0420CB             0307*  ; each command requires an operand value to be specified.
0420CB             0308*  
0420CB             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
0420CB             0310*  ; need to use the NOT operation, and so the following command would
0420CB             0311*  ; be used:
0420CB             0312*  
0420CB             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
0420CB             0314*  
0420CB             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
0420CB             0316*  ; to use the Add operation, and so the following command would be
0420CB             0317*  ; used:
0420CB             0318*  
0420CB             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
0420CB             0320*  
0420CB             0321*  ; When using add with carry, the carry value is stored in the byte
0420CB             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
0420CB             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
0420CB             0324*  ; you would need to use the Add with carry operation, and so the
0420CB             0325*  ; following command would be used:
0420CB             0326*  
0420CB             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
0420CB             0328*  
0420CB             0329*  ; Advanced operations
0420CB             0330*  
0420CB             0331*  ; Whilst these operations are useful, they are not particularly
0420CB             0332*  ; powerful as they only operate one one byte at a time, with a
0420CB             0333*  ; fixed operand value, and potentially cannot reach all bytes in
0420CB             0334*  ; a buffer. To address this, the API supports a number of advanced
0420CB             0335*  ; operations.
0420CB             0336*  
0420CB             0337*  ; The operation value used is an 8-bit value that can have bits
0420CB             0338*  ; set to modify the behaviour of the operation. The following bits
0420CB             0339*  ; are defined:
0420CB             0340*  ; Bit 	Description
0420CB             0341*  ; &10 	Use “advanced” offsets
0420CB             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
0420CB             0343*  ; &40 	Multiple target values should be adjusted
0420CB             0344*  ; &80 	Multiple operand values should be used
0420CB             0345*  
0420CB             0346*  ; These bits can be combined together to modify the behaviour of
0420CB             0347*  ; the operation.
0420CB             0348*  
0420CB             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
0420CB             0350*  ; offset one byte at a time. When either of the “multiple” variants
0420CB             0351*  ; are used, a 16-bit count must be provided to indicate how many
0420CB             0352*  ; bytes should be altered.
0420CB             0353*  
0420CB             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
0420CB             0355*  ; order, which can allow for buffers that are larger than 64kb
0420CB             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
0420CB             0357*  ; the 16-bit value immediately following the offset is used as a
0420CB             0358*  ; block index number, and the remaining 23-bits of the offset value
0420CB             0359*  ; are used as an offset within that block. When the “advanced”
0420CB             0360*  ; offset mode bit has been set then all offsets associated with
0420CB             0361*  ; this command must be sent as advanced offsets.
0420CB             0362*  
0420CB             0363*  ; The “buffer-fetched value” mode allows for the operand value to
0420CB             0364*  ; be fetched from a buffer. The operand sent as part of the
0420CB             0365*  ; command in this case is a pair of 16-bit values giving the
0420CB             0366*  ; buffer ID and offset to indicate where the actual operand value
0420CB             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
0420CB             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
0420CB             0369*  ; used inside a buffered command sequence. If the advanced offset
0420CB             0370*  ; mode is used, then the operand value is an advanced offset value.
0420CB             0371*  
0420CB             0372*  ; The “multiple target values” mode allows for multiple bytes to
0420CB             0373*  ; be adjusted at once. When this mode is used, the count value
0420CB             0374*  ; must be provided to indicate how many bytes should be adjusted.
0420CB             0375*  ; Unless the “multiple operand values” mode is also used, the
0420CB             0376*  ; operand value is used for all bytes adjusted.
0420CB             0377*  
0420CB             0378*  ; The “multiple operand values” mode allows for multiple operand
0420CB             0379*  ; values to be used. When this mode is used, the count value must
0420CB             0380*  ; be provided to indicate how many operand values should be used.
0420CB             0381*  ; This can allow, for instance, to add together several bytes in a
0420CB             0382*  ; buffer. When this mode is used in conjunction with the “multiple
0420CB             0383*  ; target values” mode, the number of operand values must match the
0420CB             0384*  ; number of target values, and the operation happens one byte at a
0420CB             0385*  ; time.
0420CB             0386*  
0420CB             0387*  ; Some examples of advanced operations are as follows:
0420CB             0388*  
0420CB             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
0420CB             0390*  
0420CB             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
0420CB             0392*  
0420CB             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
0420CB             0394*  ; modifier (&40).
0420CB             0395*  
0420CB             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
0420CB             0397*  
0420CB             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
0420CB             0399*  
0420CB             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
0420CB             0401*  
0420CB             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
0420CB             0403*  
0420CB             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
0420CB             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
0420CB             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
0420CB             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
0420CB             0408*  ; in little-endian order. As the top bit of the offset is set, this
0420CB             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
0420CB             0410*  ; Finally the value to write is sent, 42.
0420CB             0411*  
0420CB             0412*  ; An operation like this could be used to set the position as part
0420CB             0413*  ; of a draw command.
0420CB             0414*  
0420CB             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
0420CB             0416*  ; values 1, 2, 3, 4, 5:
0420CB             0417*  
0420CB             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
0420CB             0419*  ; offset 12 (set it to 0)
0420CB             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
0420CB             0421*  
0420CB             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
0420CB             0423*  ; 7 bytes in buffer 4 starting at offset 42:
0420CB             0424*  
0420CB             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
0420CB             0426*  
0420CB             0427*  ; As we are working on a little-endian system, integers longer
0420CB             0428*  ; than one byte are sent with their least significant byte first.
0420CB             0429*  ; This means that the add with carry operation can be used to add
0420CB             0430*  ; together integers of any size, so long as they are the same size.
0420CB             0431*  ; To do this, both the “multiple target values” and “multiple
0420CB             0432*  ; operand values” modes must be used.
0420CB             0433*  
0420CB             0434*  ; The following commands will add together a 16-bit, 24-bit,
0420CB             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
0420CB             0436*  ; in buffer 3 starting at offset 12, and all using the operand
0420CB             0437*  ; value of 42:
0420CB             0438*  
0420CB             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
0420CB             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
0420CB             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
0420CB             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
0420CB             0443*  
0420CB             0444*  ; Take note of how the operand value is padded out with zeros
0420CB             0445*  ; to match the size of the target value. 42; is used as a base
0420CB             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
0420CB             0447*  ; 16-bits to pad it out to the required size. The “carry” value
0420CB             0448*  ; will be stored at the next offset in the target buffer after
0420CB             0449*  ; the complete target value. So for a 16-bit value, the carry
0420CB             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
0420CB             0451*  ; at offset 15, and so on.
0420CB             0452*  
0420CB             0453*  ; Command 6: Conditionally call a buffer
0420CB             0454*  
0420CB             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
0420CB             0456*  
0420CB             0457*  ; This command will conditionally call a buffer if the condition
0420CB             0458*  ; operation passes. This command works in a similar manner to the
0420CB             0459*  ; “Adjust buffer contents” command.
0420CB             0460*  
0420CB             0461*  ; With this command a buffer ID of 65535 (-1) is always
0420CB             0462*  ; interpretted as “current buffer”, and so can only be used
0420CB             0463*  ; within a buffered command sequence. If used outside of a
0420CB             0464*  ; buffered command sequence then this command will do nothing.
0420CB             0465*  
0420CB             0466*  ; The basic set of condition operations are as follows:
0420CB             0467*  ; Operation 	Description
0420CB             0468*  ; 0 	Exists (value is non-zero)
0420CB             0469*  ; 1 	Not exists (value is zero)
0420CB             0470*  ; 2 	Equal
0420CB             0471*  ; 3 	Not equal
0420CB             0472*  ; 4 	Less than
0420CB             0473*  ; 5 	Greater than
0420CB             0474*  ; 6 	Less than or equal
0420CB             0475*  ; 7 	Greater than or equal
0420CB             0476*  ; 8 	AND
0420CB             0477*  ; 9 	OR
0420CB             0478*  
0420CB             0479*  ; The value that is being checked is fetched from the specified
0420CB             0480*  ; check buffer ID and offset. With the exception of “Exists” and
0420CB             0481*  ; “Not exists”, each command requires an operand value to be
0420CB             0482*  ; specified to check against.
0420CB             0483*  
0420CB             0484*  ; The operation value used is an 8-bit value that can have bits
0420CB             0485*  ; set to modify the behaviour of the operation. The following bits
0420CB             0486*  ; are defined:
0420CB             0487*  ; Bit value 	Description
0420CB             0488*  ; &10 	Use advanced offsets
0420CB             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
0420CB             0490*  
0420CB             0491*  ; These modifiers can be combined together to modify the behaviour
0420CB             0492*  ; of the operation.
0420CB             0493*  
0420CB             0494*  ; At this time, unlike with the “adjust” command, multiple target
0420CB             0495*  ; values and multiple operand values are not supported. All
0420CB             0496*  ; comparisons are therefore only conducted on single 8-bit values.
0420CB             0497*  ; (If comparisons of 16-bit values are required, multiple calls
0420CB             0498*  ; can be combined.) Support for them may be added in the future.
0420CB             0499*  
0420CB             0500*  ; The AND and OR operations are logical operations, and so the
0420CB             0501*  ; operand value is used as a boolean value. Any non-zero value is
0420CB             0502*  ; considered to be true, and zero is considered to be false. These
0420CB             0503*  ; operations therefore are most useful when used with buffer-fetched
0420CB             0504*  ; operand values (operations &28, &29, &38 and &39).
0420CB             0505*  
0420CB             0506*  ; Some examples of condition operations are as follows:
0420CB             0507*  
0420CB             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
0420CB             0509*  ; (is non-zero):
0420CB             0510*  
0420CB             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
0420CB             0512*  
0420CB             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
0420CB             0514*  ; exist (is zero):
0420CB             0515*  
0420CB             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
0420CB             0517*  
0420CB             0518*  ; Combining the above two examples is effectively equivalent to
0420CB             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
0420CB             0520*  
0420CB             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
0420CB             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
0420CB             0523*  
0420CB             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
0420CB             0525*  
0420CB             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
0420CB             0527*  
0420CB             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
0420CB             0529*  ; the value in buffer 2 at offset 8:
0420CB             0530*  
0420CB             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
0420CB             0532*  
0420CB             0533*  ; Command 7: Jump to a buffer
0420CB             0534*  
0420CB             0535*  ; VDU 23, 0, &A0, bufferId; 7
0420CB             0536*  
0420CB             0537*  ; This command will jump to the buffer with the given ID. If
0420CB             0538*  ; the buffer does not exist, or is empty, then this command will
0420CB             0539*  ; do nothing.
0420CB             0540*  
0420CB             0541*  ; This essentially works the same as the call command (command 1),
0420CB             0542*  ;  except that it does not return to the caller. This command is
0420CB             0543*  ;  therefore useful for creating loops.
0420CB             0544*  
0420CB             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
0420CB             0546*  ; treated as a “jump to end of current buffer”. This will return
0420CB             0547*  ; execution to the caller, and can be useful for exiting a loop.
0420CB             0548*  
0420CB             0549*  ; ## Command 8: Conditional Jump to a buffer
0420CB             0550*  
0420CB             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0420CB             0552*  
0420CB             0553*  ; This command operates in a similar manner to the “Conditionally
0420CB             0554*  ; call a buffer” command (command 6), except that it will jump to
0420CB             0555*  ; the buffer if the condition operation passes.
0420CB             0556*  
0420CB             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
0420CB             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
0420CB             0559*  ; Command 9: Jump to an offset in a buffer
0420CB             0560*  
0420CB             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0420CB             0562*  
0420CB             0563*  ; This command will jump to the given offset in the buffer with the
0420CB             0564*  ; given ID. If the buffer does not exist, or is empty, then this
0420CB             0565*  ; command will do nothing.
0420CB             0566*  
0420CB             0567*  ; The offset in this command is always an “advanced” offset, given
0420CB             0568*  ; as a 24-bit value in little-endian order. As with other uses of
0420CB             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
0420CB             0570*  ; offset value, a block number must also be provided.
0420CB             0571*  
0420CB             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
0420CB             0573*  ; meaning “jump within current buffer”. This can be useful for
0420CB             0574*  ; creating loops within a buffer, or when building up command
0420CB             0575*  ; sequences that may be copied across multiple buffers.
0420CB             0576*  
0420CB             0577*  ; Jumping to an offset that is beyond the end of the buffer is
0420CB             0578*  ; equivalent to jumping to the end of the buffer.
0420CB             0579*  ; Command 10: Conditional jump to an offset in a buffer
0420CB             0580*  
0420CB             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0420CB             0582*  
0420CB             0583*  ; A conditional jump with an offset works in a similar manner to
0420CB             0584*  ; the “Conditional call a buffer” command (command 6), except that
0420CB             0585*  ; it will jump to the given offset in the buffer if the condition
0420CB             0586*  ; operation passes.
0420CB             0587*  
0420CB             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
0420CB             0589*  ; the offset in this command is always an “advanced” offset, given
0420CB             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
0420CB             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
0420CB             0592*  ; treated as meaning “jump within current buffer”.
0420CB             0593*  ; Command 11: Call buffer with an offset
0420CB             0594*  
0420CB             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0420CB             0596*  
0420CB             0597*  ; Works just like “Call a buffer” (command 1), except that it also
0420CB             0598*  ; accepts an advanced offset.
0420CB             0599*  
0420CB             0600*  ; Command 12: Conditional call buffer with an offset
0420CB             0601*  
0420CB             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
0420CB             0603*  
0420CB             0604*  ; Works just like the “Conditional call a buffer” command
0420CB             0605*  ; (command 6), except that it also accepts an advanced offset.
0420CB             0606*  
0420CB             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
0420CB             0608*  
0420CB             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
0420CB             0610*  
0420CB             0611*  ; This command will copy the contents of multiple buffers into a
0420CB             0612*  ; single buffer. The buffers to copy from are specified as a list
0420CB             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
0420CB             0614*  ; buffers are copied in the order they are specified.
0420CB             0615*  
0420CB             0616*  ; This is a block-wise copy, so the blocks from the source buffers
0420CB             0617*  ; are copied into the target buffer. The blocks are copied in the
0420CB             0618*  ; order they are found in the source buffers.
0420CB             0619*  
0420CB             0620*  ; The target buffer will be overwritten with the contents of the
0420CB             0621*  ; source buffers. This will not be done however until after all the
0420CB             0622*  ; data has been gathered and copied. The target buffer can therefore
0420CB             0623*  ; included in the list of the source buffers.
0420CB             0624*  
0420CB             0625*  ; If a source buffer that does not exist is specified, or a source
0420CB             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
0420CB             0627*  
0420CB             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
0420CB             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
0420CB             0630*  ; copied multiple times into the target buffer.
0420CB             0631*  
0420CB             0632*  ; If there is insufficient memory available on the VDP to complete
0420CB             0633*  ; this command then it will fail, and the target buffer will be
0420CB             0634*  ; left unchanged.
0420CB             0635*  
0420CB             0636*  
0420CB             0637*  ; Command 14: Consolidate blocks in a buffer
0420CB             0638*  
0420CB             0639*  ; VDU 23, 0, &A0, bufferId; 14
0420CB             0640*  
0420CB             0641*  ; Takes all the blocks in a buffer and consolidates them into a
0420CB             0642*  ; single block. This is useful for bitmaps, as it allows for a
0420CB             0643*  ; bitmap to be built up over time in multiple blocks, and then
0420CB             0644*  ; consolidated into a single block for use as a bitmap.
0420CB             0645*  
0420CB             0646*  ; If there is insufficient memory available on the VDP to complete
0420CB             0647*  ; this command then it will fail, and the buffer will be left
0420CB             0648*  ; unchanged.
0420CB             0649*  
0420CB             0650*  ; Command 15: Split a buffer into multiple blocks
0420CB             0651*  
0420CB             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
0420CB             0653*  
0420CB             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
0420CB             0655*  ; is a 16-bit integer that specifies the target size of each block.
0420CB             0656*  ; If the source data is not a multiple of the block size then the
0420CB             0657*  ; last block will be smaller than the specified block size.
0420CB             0658*  
0420CB             0659*  ; If this command is used on a buffer that is already split into
0420CB             0660*  ; multiple blocks, then the blocks will be consolidated first,
0420CB             0661*  ; and then re-split into the new block size.
0420CB             0662*  
0420CB             0663*  ; If there is insufficient memory available on the VDP to complete
0420CB             0664*  ; this command then it will fail, and the buffer will be left
0420CB             0665*  ; unchanged.
0420CB             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
0420CB             0667*  ; multiple buffers
0420CB             0668*  
0420CB             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0670*  
0420CB             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
0420CB             0672*  ; then spreads the resultant blocks across the target buffers.
0420CB             0673*  ; The target buffers are specified as a list of buffer IDs,
0420CB             0674*  ; terminated by a buffer ID of -1 (65535).
0420CB             0675*  
0420CB             0676*  ; The blocks are spread across the target buffers in the order
0420CB             0677*  ; they are specified, and the spread will loop around the buffers
0420CB             0678*  ; until all the blocks have been distributed. The target buffers
0420CB             0679*  ; will be cleared out before the blocks are spread across them.
0420CB             0680*  
0420CB             0681*  ; What this means is that if the source buffer is, let’s say,
0420CB             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
0420CB             0683*  ; then we will end up with 10 blocks. If we then spread those
0420CB             0684*  ; blocks across 3 target buffers, then the first buffer will
0420CB             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
0420CB             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
0420CB             0687*  ; blocks 3, 6 and 9.
0420CB             0688*  
0420CB             0689*  ; This command attempts to ensure that, in the event of
0420CB             0690*  ; insufficient memory being available on the VDP to complete
0420CB             0691*  ; the command, it will leave the targets as they were before
0420CB             0692*  ; the command was executed. However this may not always be
0420CB             0693*  ; possible. The first step of this command is to consolidate
0420CB             0694*  ; the source buffer into a single block, and this may fail from
0420CB             0695*  ; insufficient memory. If that happens then all the buffers will
0420CB             0696*  ; be left as they were. After this however the target buffers
0420CB             0697*  ; will be cleared. If there is insufficient memory to successfully
0420CB             0698*  ; split the buffer into multiple blocks then the call will exit,
0420CB             0699*  ; and the target buffers will be left empty.
0420CB             0700*  ; Command 17: Split a buffer and spread across blocks, starting
0420CB             0701*  ; at target buffer ID
0420CB             0702*  
0420CB             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
0420CB             0704*  
0420CB             0705*  ; As per the above two commands, this will split a buffer into
0420CB             0706*  ; multiple blocks. It will then spread the blocks across buffers
0420CB             0707*  ; starting at the target buffer ID, incrementing the target buffer
0420CB             0708*  ; ID until all the blocks have been distributed.
0420CB             0709*  
0420CB             0710*  ; Target blocks will be cleared before a block is stored in them.
0420CB             0711*  ; Each target will contain a single block. The exception to this
0420CB             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
0420CB             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
0420CB             0714*  ; will be placed into buffer 65534.
0420CB             0715*  
0420CB             0716*  ; With this command if there is insufficient memory available on
0420CB             0717*  ; the VDP to complete the command then it will fail, and the target
0420CB             0718*  ; buffers will be left unchanged.
0420CB             0719*  
0420CB             0720*  ; Command 18: Split a buffer into blocks by width
0420CB             0721*  
0420CB             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
0420CB             0723*  
0420CB             0724*  ; This command splits a buffer into a given number of blocks by
0420CB             0725*  ; first of all splitting the buffer into blocks of a given width
0420CB             0726*  ; (number of bytes), and then consolidating those blocks into the
0420CB             0727*  ; given number of blocks.
0420CB             0728*  
0420CB             0729*  ; This is useful for splitting a bitmap into a number of separate
0420CB             0730*  ; columns, which can then be manipulated individually. This can be
0420CB             0731*  ; useful for dealing with sprite sheets.
0420CB             0732*  ; Command 19: Split by width into blocks and spread across target
0420CB             0733*  ; buffers
0420CB             0734*  
0420CB             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0736*  
0420CB             0737*  ; This command essentially operates the same as command 18, but the
0420CB             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
0420CB             0739*  
0420CB             0740*  ; Command 20: Split by width into blocks and spread across blocks
0420CB             0741*  ; starting at target buffer ID
0420CB             0742*  
0420CB             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
0420CB             0744*  
0420CB             0745*  ; This command essentially operates the same as command 18, but
0420CB             0746*  ; the generated blocks are spread across blocks starting at the
0420CB             0747*  ; target buffer ID, as per command 17.
0420CB             0748*  
0420CB             0749*  ; Command 21: Spread blocks from a buffer across multiple target
0420CB             0750*  ; buffers
0420CB             0751*  
0420CB             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0753*  
0420CB             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
0420CB             0755*  ; The target buffers are specified as a list of buffer IDs,
0420CB             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
0420CB             0757*  ; across the target buffers in the order they are specified, and
0420CB             0758*  ; the spread will loop around the buffers until all the blocks have
0420CB             0759*  ; been distributed.
0420CB             0760*  
0420CB             0761*  ; It should be noted that this command does not copy the blocks,
0420CB             0762*  ; and nor does it move them. Unless the source buffer has been
0420CB             0763*  ; included in the list of targets, it will remain completely
0420CB             0764*  ; intact. The blocks distributed across the target buffers will
0420CB             0765*  ; point to the same memory as the blocks in the source buffer.
0420CB             0766*  ; Operations to modify data in the source buffer will also modify
0420CB             0767*  ; the data in the target buffers. Clearing the source buffer
0420CB             0768*  ; however will not clear the target buffers.
0420CB             0769*  
0420CB             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
0420CB             0771*  ; at target buffer ID
0420CB             0772*  
0420CB             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
0420CB             0774*  
0420CB             0775*  ; Spreads the blocks from a buffer across blocks starting at
0420CB             0776*  ; the target buffer ID.
0420CB             0777*  
0420CB             0778*  ; This essentially works the same as command 21, and the same
0420CB             0779*  ; notes about copying and moving blocks apply. Blocks are spread
0420CB             0780*  ; in the same manner as commands 17 and 20.
0420CB             0781*  
0420CB             0782*  ; Command 23: Reverse the order of blocks in a buffer
0420CB             0783*  
0420CB             0784*  ; VDU 23, 0, &A0, bufferId; 23
0420CB             0785*  
0420CB             0786*  ; Reverses the order of the blocks in a buffer.
0420CB             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
0420CB             0788*  
0420CB             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0420CB             0790*  
0420CB             0791*  ; Reverses the order of the data within the blocks of a buffer.
0420CB             0792*  ; The options parameter is an 8-bit value that can have bits set
0420CB             0793*  ; to modify the behaviour of the operation. The following bits
0420CB             0794*  ; are defined:
0420CB             0795*  ; Bit value 	Description
0420CB             0796*  ; 1 	Values are 16-bits in size
0420CB             0797*  ; 2 	Values are 32-bits in size
0420CB             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
0420CB             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
0420CB             0800*  ; 8 	Reverse blocks
0420CB             0801*  
0420CB             0802*  ; These modifiers can be combined together to modify the behaviour
0420CB             0803*  ; of the operation.
0420CB             0804*  
0420CB             0805*  ; If no value size is set in the options (i.e. the value of the
0420CB             0806*  ; bottom two bits of the options is zero) then the value size is
0420CB             0807*  ; assumed to be 8-bits.
0420CB             0808*  
0420CB             0809*  ; It is probably easiest to understand what this operation is
0420CB             0810*  ; capable of by going through some examples of how it can be used
0420CB             0811*  ; to manipulate bitmaps. The VDP supports two different formats
0420CB             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
0420CB             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
0420CB             0814*  ; pixel.
0420CB             0815*  
0420CB             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
0420CB             0817*  ; degrees, which can be done by just reversing the order of
0420CB             0818*  ; bytes in the buffer:
0420CB             0819*  
0420CB             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
0420CB             0821*  
0420CB             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
0420CB             0823*  ; little more complex, as each pixel is made up of 4 bytes.
0420CB             0824*  ; However with this command it is still a simple operation, as
0420CB             0825*  ; we can just reverse the order of the 32-bit values that make
0420CB             0826*  ; up the bitmap by using an options value of 2:
0420CB             0827*  
0420CB             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
0420CB             0829*  
0420CB             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
0420CB             0831*  ; the order of rows of pixels. To do this we can set a custom
0420CB             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
0420CB             0833*  ; bitmap we can just set a custom value size to our bitmap width:
0420CB             0834*  
0420CB             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
0420CB             0836*  
0420CB             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
0420CB             0838*  ; our width by 4:
0420CB             0839*  
0420CB             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
0420CB             0841*  
0420CB             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
0420CB             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
0420CB             0844*  ; just set a custom chunk size to our bitmap width:
0420CB             0845*  
0420CB             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
0420CB             0847*  
0420CB             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
0420CB             0849*  ; 32-bit values as well as a custom chunk size:
0420CB             0850*  
0420CB             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
0420CB             0852*  
0420CB             0853*  ; Command 25: Copy blocks from multiple buffers by reference
0420CB             0854*  
0420CB             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
0420CB             0856*  
0420CB             0857*  ; This command is essentially a version of command 13 that copies
0420CB             0858*  ; blocks by reference rather than by value. The parameters for
0420CB             0859*  ; this command are the same as for command 13, and the same rules
0420CB             0860*  ; apply.
0420CB             0861*  
0420CB             0862*  ; If the target buffer is included in the list of source buffers
0420CB             0863*  ; then it will be skipped to prevent a reference loop.
0420CB             0864*  
0420CB             0865*  ; Copying by reference means that the blocks in the target buffer
0420CB             0866*  ; will point to the same memory as the blocks in the source
0420CB             0867*  ; buffers. Operations to modify data blocks in the source buffers
0420CB             0868*  ; will therefore also modify those blocks in the target buffer.
0420CB             0869*  ; Clearing the source buffers will not clear the target buffer -
0420CB             0870*  ; it will still point to the original data blocks. Data blocks
0420CB             0871*  ; are only freed from memory when no buffers are left with any
0420CB             0872*  ; references to them.
0420CB             0873*  
0420CB             0874*  ; Buffers that get consolidated become new blocks, so will lose
0420CB             0875*  ; their links to the original blocks, thus after a “consolidate”
0420CB             0876*  ; operation modifications to the original blocks will no longer be
0420CB             0877*  ; reflected in the consolidated buffer.
0420CB             0878*  
0420CB             0879*  ; This command is useful to construct a single buffer from multiple
0420CB             0880*  ; sources without the copy overhead, which can be costly. For
0420CB             0881*  ; example, this can be useful for constructing a bitmap from
0420CB             0882*  ; multiple constituent parts before consolidating it into a
0420CB             0883*  ; single block. In such an example, using command 13 instead
0420CB             0884*  ; would first make a copy of the contents of the source buffers,
0420CB             0885*  ; and then consolidate them into a single block. Using this
0420CB             0886*  ; command does not make that first copy, and so would be faster.
0420CB             0887*  
0420CB             0888*  ; This command is also useful for creating multiple buffers that
0420CB             0889*  ; all point to the same data.
0420CB             0890*  
0420CB             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
0420CB             0892*  
0420CB             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
0420CB             0055       include "vdu_plot.inc"
0420CB             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0420CB             0002*  ; PLOT code 	(Decimal) 	Effect
0420CB             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0420CB             0004*  plot_sl_both: equ 0x00
0420CB             0005*  
0420CB             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0420CB             0007*  plot_sl_first: equ 0x08
0420CB             0008*  
0420CB             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0420CB             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0420CB             0011*  
0420CB             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0420CB             0013*  plot_sl_last: equ 0x20
0420CB             0014*  
0420CB             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0420CB             0016*  plot_sl_none: equ 0x28
0420CB             0017*  
0420CB             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0420CB             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0420CB             0020*  
0420CB             0021*  ; &40-&47 	64-71 	Point plot
0420CB             0022*  plot_pt: equ 0x40
0420CB             0023*  
0420CB             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0420CB             0025*  plot_lf_lr_non_bg: equ 0x48
0420CB             0026*  
0420CB             0027*  ; &50-&57 	80-87 	Triangle fill
0420CB             0028*  plot_tf: equ 0x50
0420CB             0029*  
0420CB             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0420CB             0031*  plot_lf_r_bg: equ 0x58
0420CB             0032*  
0420CB             0033*  ; &60-&67 	96-103 	Rectangle fill
0420CB             0034*  plot_rf: equ 0x60
0420CB             0035*  
0420CB             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0420CB             0037*  plot_lf_lr_fg: equ 0x60
0420CB             0038*  
0420CB             0039*  ; &70-&77 	112-119 	Parallelogram fill
0420CB             0040*  plot_pf: equ 0x70
0420CB             0041*  
0420CB             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0420CB             0043*  plot_lf_r_non_fg: equ 0x78
0420CB             0044*  
0420CB             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0420CB             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0420CB             0047*  
0420CB             0048*  ; &90-&97 	144-151 	Circle outline
0420CB             0049*  plot_co: equ 0x90
0420CB             0050*  
0420CB             0051*  ; &98-&9F 	152-159 	Circle fill
0420CB             0052*  plot_cf: equ 0x98
0420CB             0053*  
0420CB             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0420CB             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0420CB             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0420CB             0057*  
0420CB             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0420CB             0059*  plot_rcm: equ 0xB8
0420CB             0060*  
0420CB             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0420CB             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0420CB             0063*  ; &D0-&D7 	208-215 	Not defined
0420CB             0064*  ; &D8-&DF 	216-223 	Not defined
0420CB             0065*  ; &E0-&E7 	224-231 	Not defined
0420CB             0066*  
0420CB             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0420CB             0068*  plot_bmp: equ 0xE8
0420CB             0069*  
0420CB             0070*  ; &F0-&F7 	240-247 	Not defined
0420CB             0071*  ; &F8-&FF 	248-255 	Not defined
0420CB             0072*  
0420CB             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0420CB             0074*  ; Agon Console8 VDP 2.2.0
0420CB             0075*  
0420CB             0076*  ; Within each group of eight plot codes, the effects are as follows:
0420CB             0077*  ; Plot code 	Effect
0420CB             0078*  ; 0 	Move relative
0420CB             0079*  mv_rel: equ 0
0420CB             0080*  
0420CB             0081*  ; 1 	Plot relative in current foreground colour
0420CB             0082*  dr_rel_fg: equ 1
0420CB             0083*  
0420CB             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0420CB             0085*  ; 3 	Plot relative in current background colour
0420CB             0086*  dr_rel_bg: equ 3
0420CB             0087*  
0420CB             0088*  ; 4 	Move absolute
0420CB             0089*  mv_abs: equ 4
0420CB             0090*  
0420CB             0091*  ; 5 	Plot absolute in current foreground colour
0420CB             0092*  dr_abs_fg: equ 5
0420CB             0093*  
0420CB             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0420CB             0095*  ; 7 	Plot absolute in current background colour
0420CB             0096*  dr_abs_bg: equ 7
0420CB             0097*  
0420CB             0098*  ; Codes 0-3 use the position data provided as part of the command
0420CB             0099*  ; as a relative position, adding the position given to the current
0420CB             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0420CB             0101*  ; as part of the command as an absolute position, setting the current
0420CB             0102*  ; graphical cursor position to the position given.
0420CB             0103*  
0420CB             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0420CB             0105*  ; current pixel colour. These operations cannot currently be supported
0420CB             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0420CB             0107*  ; supported. Support for these codes may be added in a future version
0420CB             0108*  ; of the VDP firmware.
0420CB             0109*  
0420CB             0110*  ; 16 colour palette constants
0420CB             0111*  c_black: equ 0
0420CB             0112*  c_red_dk: equ 1
0420CB             0113*  c_green_dk: equ 2
0420CB             0114*  c_yellow_dk: equ 3
0420CB             0115*  c_blue_dk: equ 4
0420CB             0116*  c_magenta_dk: equ 5
0420CB             0117*  c_cyan_dk: equ 6
0420CB             0118*  c_grey: equ 7
0420CB             0119*  c_grey_dk: equ 8
0420CB             0120*  c_red: equ 9
0420CB             0121*  c_green: equ 10
0420CB             0122*  c_yellow: equ 11
0420CB             0123*  c_blue: equ 12
0420CB             0124*  c_magenta: equ 13
0420CB             0125*  c_cyan: equ 14
0420CB             0126*  c_white: equ 15
0420CB             0127*  
0420CB             0128*  ; VDU 25, mode, x; y;: PLOT command
0420CB             0129*  ; inputs: a=mode, bc=x0, de=y0
0420CB             0130*  vdu_plot:
0420CB 32 E5 20 04 0131*      ld (@mode),a
0420CF ED 43 E6 20 0132*      ld (@x0),bc
       04          
0420D4 ED 53 E8 20 0133*      ld (@y0),de
       04          
0420D9 21 E4 20 04 0134*  	ld hl,@cmd
0420DD 01 06 00 00 0135*  	ld bc,@end-@cmd
0420E1 5B DF       0136*  	rst.lil $18
0420E3 C9          0137*  	ret
0420E4 19          0138*  @cmd:   db 25
0420E5 00          0139*  @mode:  db 0
0420E6 00 00       0140*  @x0: 	dw 0
0420E8 00 00       0141*  @y0: 	dw 0
0420EA 00          0142*  @end:   db 0 ; extra byte to soak up deu
0420EB             0143*  
0420EB             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0420EB             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
0420EB             0146*  ; VDU 25, mode, x; y;: PLOT command
0420EB             0147*  ; inputs: bc=x0, de=y0
0420EB             0148*  ; prerequisites: vdu_buff_select
0420EB             0149*  vdu_plot_bmp:
0420EB ED 43 02 21 0150*      ld (@x0),bc
       04          
0420F0 ED 53 04 21 0151*      ld (@y0),de
       04          
0420F5 21 00 21 04 0152*  	ld hl,@cmd
0420F9 01 06 00 00 0153*  	ld bc,@end-@cmd
0420FD 5B DF       0154*  	rst.lil $18
0420FF C9          0155*  	ret
042100 19          0156*  @cmd:   db 25
042101 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
042102 00 00       0158*  @x0: 	dw 0x0000
042104 00 00       0159*  @y0: 	dw 0x0000
042106 00          0160*  @end:   db 0x00 ; padding
042107             0161*  
042107             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042107             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
042107             0164*  ; VDU 25, mode, x; y;: PLOT command
042107             0165*  ; inputs: bc=x0, de=y0
042107             0166*  ; USING 16.8 FIXED POINT COORDINATES
042107             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042107             0168*  ;   the fractional portiion of the inputs are truncated
042107             0169*  ;   leaving only the 16-bit integer portion
042107             0170*  ; prerequisites: vdu_buff_select
042107             0171*  vdu_plot_bmp168:
042107             0172*  ; populate in the reverse of normal to keep the
042107             0173*  ; inputs from stomping on each other
042107 ED 53 25 21 0174*      ld (@y0-1),de
       04          
04210C ED 43 23 21 0175*      ld (@x0-1),bc
       04          
042111 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
042113 32 23 21 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
042117 21 22 21 04 0178*  	ld hl,@cmd
04211B 01 06 00 00 0179*  	ld bc,@end-@cmd
04211F 5B DF       0180*  	rst.lil $18
042121 C9          0181*  	ret
042122 19          0182*  @cmd:   db 25
042123 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
042124 00 00       0184*  @x0: 	dw 0x0000
042126 00 00       0185*  @y0: 	dw 0x0000
042128             0186*  @end:  ; no padding required b/c we shifted de right
042128             0187*  
042128             0188*  ; draw a filled rectangle
042128             0189*  vdu_plot_rf:
042128 ED 43 4F 21 0190*      ld (@x0),bc
       04          
04212D ED 53 51 21 0191*      ld (@y0),de
       04          
042132 DD 22 55 21 0192*      ld (@x1),ix
       04          
042137 FD 22 57 21 0193*      ld (@y1),iy
       04          
04213C 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
04213E 32 53 21 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042142 21 4D 21 04 0196*  	ld hl,@cmd0
042146 01 0C 00 00 0197*  	ld bc,@end-@cmd0
04214A 5B DF       0198*  	rst.lil $18
04214C C9          0199*      ret
04214D 19          0200*  @cmd0:  db 25 ; plot
04214E 04          0201*  @arg0:  db plot_sl_both+mv_abs
04214F 00 00       0202*  @x0:    dw 0x0000
042151 00 00       0203*  @y0:    dw 0x0000
042153 19          0204*  @cmd1:  db 25 ; plot
042154 65          0205*  @arg1:  db plot_rf+dr_abs_fg
042155 00 00       0206*  @x1:    dw 0x0000
042157 00 00       0207*  @y1:    dw 0x0000
042159 00          0208*  @end:   db 0x00 ; padding
04215A             0209*  
04215A             0210*  ; draw a filled circle
04215A             0211*  vdu_plot_cf:
04215A ED 43 81 21 0212*      ld (@x0),bc
       04          
04215F ED 53 83 21 0213*      ld (@y0),de
       04          
042164 DD 22 87 21 0214*      ld (@x1),ix
       04          
042169 FD 22 89 21 0215*      ld (@y1),iy
       04          
04216E 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
042170 32 85 21 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042174 21 7F 21 04 0218*  	ld hl,@cmd0
042178 01 0C 00 00 0219*  	ld bc,@end-@cmd0
04217C 5B DF       0220*  	rst.lil $18
04217E C9          0221*      ret
04217F 19          0222*  @cmd0:  db 25 ; plot
042180 04          0223*  @arg0:  db plot_sl_both+mv_abs
042181 00 00       0224*  @x0:    dw 0x0000
042183 00 00       0225*  @y0:    dw 0x0000
042185 19          0226*  @cmd1:  db 25 ; plot
042186 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
042187 00 00       0228*  @x1:    dw 0x0000
042189 00 00       0229*  @y1:    dw 0x0000
04218B 00          0230*  @end:   db 0x00 ; padding
04218C             0056   	include "vdu_sprites.inc"
04218C             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
04218C             0002*  ; the VDP can support up to 256 sprites. They must be defined
04218C             0003*  ; contiguously, and so the first sprite is sprite 0.
04218C             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
04218C             0005*  ; Once a selection of sprites have been defined, you can activate
04218C             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
04218C             0007*  ; of sprites to activate. This will activate the first n sprites,
04218C             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
04218C             0009*  
04218C             0010*  ; A single sprite can have multiple "frames", referring to
04218C             0011*  ; different bitmaps.
04218C             0012*  ; (These bitmaps do not need to be the same size.)
04218C             0013*  ; This allows a sprite to include an animation sequence,
04218C             0014*  ; which can be stepped through one frame at a time, or picked
04218C             0015*  ; in any order.
04218C             0016*  
04218C             0017*  ; Any format of bitmap can be used as a sprite frame. It should
04218C             0018*  ; be noted however that "native" format bitmaps are not
04218C             0019*  ; recommended for use as sprite frames, as they cannot get
04218C             0020*  ; erased from the screen. (As noted above, the "native" bitmap
04218C             0021*  ; format is not really intended for general use.) This is part
04218C             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
04218C             0023*  ; screen are now stored in RGBA2222 format.
04218C             0024*  
04218C             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
04218C             0026*  ; and then later shown again.
04218C             0027*  
04218C             0028*  ; Moving sprites around the screen is done by changing the
04218C             0029*  ; position of the sprite. This can be done either by setting
04218C             0030*  ; the absolute position of the sprite, or by moving the sprite
04218C             0031*  ; by a given number of pixels. (Sprites are positioned using
04218C             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
04218C             0033*  ; In the current sprite system, sprites will not update their
04218C             0034*  ; position on-screen until either another drawing operation is
04218C             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
04218C             0036*  
04218C             0037*  ; VDU 23, 27, 4, n: Select sprite n
04218C             0038*  ; inputs: a is the 8-bit sprite id
04218C             0039*  vdu_sprite_select:
04218C 32 9E 21 04 0040*      ld (@sprite),a
042190 21 9B 21 04 0041*      ld hl,@cmd
042194 01 04 00 00 0042*      ld bc,@end-@cmd
042198 5B DF       0043*      rst.lil $18
04219A C9          0044*      ret
04219B 17 1B 04    0045*  @cmd:    db 23,27,4
04219E 00          0046*  @sprite: db 0x00
04219F             0047*  @end:
04219F             0048*  
04219F             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
04219F             0050*  ; inputs: none
04219F             0051*  ; prerequisites: vdu_sprite_select
04219F             0052*  vdu_sprite_clear_frames:
04219F 21 AA 21 04 0053*      ld hl,@cmd
0421A3 01 03 00 00 0054*      ld bc,@end-@cmd
0421A7 5B DF       0055*      rst.lil $18
0421A9 C9          0056*      ret
0421AA 17 1B 05    0057*  @cmd: db 23,27,5
0421AD             0058*  @end:
0421AD             0059*  
0421AD             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0421AD             0061*  ; inputs: a is the 8-bit bitmap number
0421AD             0062*  ; prerequisites: vdu_sprite_select
0421AD             0063*  vdu_sprite_add_bmp:
0421AD 32 BF 21 04 0064*      ld (@bmp),a
0421B1 21 BC 21 04 0065*      ld hl,@cmd
0421B5 01 04 00 00 0066*      ld bc,@end-@cmd
0421B9 5B DF       0067*      rst.lil $18
0421BB C9          0068*      ret
0421BC 17 1B 06    0069*  @cmd: db 23,27,6
0421BF 00          0070*  @bmp: db 0x00
0421C0             0071*  @end:
0421C0             0072*  
0421C0             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0421C0             0074*  ; inputs: a is the number of sprites to activate
0421C0             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0421C0             0076*  vdu_sprite_activate:
0421C0 32 D2 21 04 0077*      ld (@num),a
0421C4 21 CF 21 04 0078*      ld hl,@cmd
0421C8 01 04 00 00 0079*      ld bc,@end-@cmd
0421CC 5B DF       0080*      rst.lil $18
0421CE C9          0081*      ret
0421CF 17 1B 07    0082*  @cmd: db 23,27,7
0421D2 00          0083*  @num: db 0x00
0421D3             0084*  @end:
0421D3             0085*  
0421D3             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
0421D3             0087*  ; inputs: none
0421D3             0088*  ; prerequisites: vdu_sprite_select
0421D3             0089*  vdu_sprite_next_frame:
0421D3 21 DE 21 04 0090*      ld hl,@cmd
0421D7 01 03 00 00 0091*      ld bc,@end-@cmd
0421DB 5B DF       0092*      rst.lil $18
0421DD C9          0093*      ret
0421DE 17 1B 08    0094*  @cmd: db 23,27,8
0421E1             0095*  @end:
0421E1             0096*  
0421E1             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
0421E1             0098*  ; inputs: none
0421E1             0099*  ; prerequisites: vdu_sprite_select
0421E1             0100*  vdu_sprite_prev_frame:
0421E1 21 EC 21 04 0101*      ld hl,@cmd
0421E5 01 03 00 00 0102*      ld bc,@end-@cmd
0421E9 5B DF       0103*      rst.lil $18
0421EB C9          0104*      ret
0421EC 17 1B 09    0105*  @cmd: db 23,27,9
0421EF             0106*  @end:
0421EF             0107*  
0421EF             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0421EF             0109*  ; inputs: a is frame number to select
0421EF             0110*  ; prerequisites: vdu_sprite_select
0421EF             0111*  vdu_sprite_select_frame:
0421EF 32 01 22 04 0112*      ld (@frame),a
0421F3 21 FE 21 04 0113*      ld hl,@cmd
0421F7 01 04 00 00 0114*      ld bc,@end-@cmd
0421FB 5B DF       0115*      rst.lil $18
0421FD C9          0116*      ret
0421FE 17 1B 0A    0117*  @cmd:    db 23,27,10
042201 00          0118*  @frame:  db 0x00
042202             0119*  @end:
042202             0120*  
042202             0121*  ; VDU 23, 27, 11: Show current sprite
042202             0122*  ; inputs: none
042202             0123*  ; prerequisites: vdu_sprite_select
042202             0124*  vdu_sprite_show:
042202 21 0D 22 04 0125*      ld hl,@cmd
042206 01 03 00 00 0126*      ld bc,@end-@cmd
04220A 5B DF       0127*      rst.lil $18
04220C C9          0128*      ret
04220D 17 1B 0B    0129*  @cmd: db 23,27,11
042210             0130*  @end:
042210             0131*  
042210             0132*  ; VDU 23, 27, 12: Hide current sprite
042210             0133*  ; inputs: none
042210             0134*  ; prerequisites: vdu_sprite_select
042210             0135*  vdu_sprite_hide:
042210 21 1B 22 04 0136*      ld hl,@cmd
042214 01 03 00 00 0137*      ld bc,@end-@cmd
042218 5B DF       0138*      rst.lil $18
04221A C9          0139*      ret
04221B 17 1B 0C    0140*  @cmd: db 23,27,12
04221E             0141*  @end:
04221E             0142*  
04221E             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04221E             0144*  ; inputs: bc is x coordinate, de is y coordinate
04221E             0145*  ; prerequisites: vdu_sprite_select
04221E             0146*  vdu_sprite_move_abs:
04221E ED 43 36 22 0147*      ld (@xpos),bc
       04          
042223 ED 53 38 22 0148*      ld (@ypos),de
       04          
042228 21 33 22 04 0149*      ld hl,@cmd
04222C 01 07 00 00 0150*      ld bc,@end-@cmd
042230 5B DF       0151*      rst.lil $18
042232 C9          0152*      ret
042233 17 1B 0D    0153*  @cmd:  db 23,27,13
042236 00 00       0154*  @xpos: dw 0x0000
042238 00 00       0155*  @ypos: dw 0x0000
04223A 00          0156*  @end:  db 0x00 ; padding
04223B             0157*  
04223B             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04223B             0159*  ; inputs: bc is x coordinate, de is y coordinate
04223B             0160*  ; prerequisites: vdu_sprite_select
04223B             0161*  vdu_sprite_move_rel:
04223B ED 43 53 22 0162*      ld (@dx),bc
       04          
042240 ED 53 55 22 0163*      ld (@dy),de
       04          
042245 21 50 22 04 0164*      ld hl,@cmd
042249 01 07 00 00 0165*      ld bc,@end-@cmd
04224D 5B DF       0166*      rst.lil $18
04224F C9          0167*      ret
042250 17 1B 0E    0168*  @cmd: db 23,27,14
042253 00 00       0169*  @dx:  dw 0x0000
042255 00 00       0170*  @dy:  dw 0x0000
042257 00          0171*  @end: db 0x00 ; padding
042258             0172*  
042258             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042258             0174*  ; USING 16.8 FIXED POINT COORDINATES
042258             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042258             0176*  ;   the fractional portiion of the inputs are truncated
042258             0177*  ;   leaving only the 16-bit integer portion
042258             0178*  ; prerequisites: vdu_sprite_select
042258             0179*  vdu_sprite_move_abs168:
042258             0180*  ; populate in the reverse of normal to keep the
042258             0181*  ; inputs from stomping on each other
042258 ED 53 77 22 0182*      ld (@ypos-1),de
       04          
04225D ED 43 75 22 0183*      ld (@xpos-1),bc
       04          
042262 3E 0D       0184*      ld a,13       ; restore the final byte of the command
042264 32 75 22 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
042268 21 73 22 04 0186*      ld hl,@cmd
04226C 01 07 00 00 0187*      ld bc,@end-@cmd
042270 5B DF       0188*      rst.lil $18
042272 C9          0189*      ret
042273 17 1B 0D    0190*  @cmd:  db 23,27,13
042276 00 00       0191*  @xpos: dw 0x0000
042278 00 00       0192*  @ypos: dw 0x0000
04227A             0193*  @end:  ; no padding required b/c we shifted de right
04227A             0194*  
04227A             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04227A             0196*  ; USING 16.8 FIXED POINT COORDINATES
04227A             0197*  ; inputs: ub.c is dx, ud.e is dy
04227A             0198*  ;   the fractional portiion of the inputs are truncated
04227A             0199*  ;   leaving only the 16-bit integer portion
04227A             0200*  ; prerequisites: vdu_sprite_select
04227A             0201*  vdu_sprite_move_rel168:
04227A             0202*  ; populate in the reverse of normal to keep the
04227A             0203*  ; inputs from stomping on each other
04227A ED 53 99 22 0204*      ld (@dy-1),de
       04          
04227F ED 43 97 22 0205*      ld (@dx-1),bc
       04          
042284 3E 0E       0206*      ld a,14       ; restore the final byte of the command
042286 32 97 22 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
04228A 21 95 22 04 0208*      ld hl,@cmd
04228E 01 07 00 00 0209*      ld bc,@end-@cmd
042292 5B DF       0210*      rst.lil $18
042294 C9          0211*      ret
042295 17 1B 0E    0212*  @cmd:  db 23,27,14
042298 00 00       0213*  @dx: dw 0x0000
04229A 00 00       0214*  @dy: dw 0x0000
04229C             0215*  @end:  ; no padding required b/c we shifted de right
04229C             0216*  
04229C             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
04229C             0218*  ; inputs: none
04229C             0219*  vdu_sprite_update:
04229C 21 A7 22 04 0220*      ld hl,@cmd
0422A0 01 03 00 00 0221*      ld bc,@end-@cmd
0422A4 5B DF       0222*      rst.lil $18
0422A6 C9          0223*      ret
0422A7 17 1B 0F    0224*  @cmd: db 23,27,15
0422AA             0225*  @end:
0422AA             0226*  
0422AA             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0422AA             0228*  ; inputs: none
0422AA             0229*  vdu_sprite_bmp_reset:
0422AA 21 B5 22 04 0230*      ld hl,@cmd
0422AE 01 03 00 00 0231*      ld bc,@end-@cmd
0422B2 5B DF       0232*      rst.lil $18
0422B4 C9          0233*      ret
0422B5 17 1B 10    0234*  @cmd: db 23,27,16
0422B8             0235*  @end:
0422B8             0236*  
0422B8             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0422B8             0238*  ; inputs: none
0422B8             0239*  vdu_sprite_reset:
0422B8 21 C3 22 04 0240*      ld hl,@cmd
0422BC 01 03 00 00 0241*      ld bc,@end-@cmd
0422C0 5B DF       0242*      rst.lil $18
0422C2 C9          0243*      ret
0422C3 17 1B 11    0244*  @cmd: db 23,27,17
0422C6             0245*  @end:
0422C6             0246*  
0422C6             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0422C6             0248*  ; inputs: a is the GCOL paint mode
0422C6             0249*  ; prerequisites: vdu_sprite_select
0422C6             0250*  vdu_sprite_set_gcol:
0422C6 32 D8 22 04 0251*      ld (@mode),a
0422CA 21 D5 22 04 0252*      ld hl,@cmd
0422CE 01 04 00 00 0253*      ld bc,@end-@cmd
0422D2 5B DF       0254*      rst.lil $18
0422D4 C9          0255*      ret
0422D5 17 1B 12    0256*  @cmd:  db 23,27,18
0422D8 00          0257*  @mode: db 0x00
0422D9             0258*  @end:
0422D9             0259*  
0422D9             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0422D9             0261*  ; inputs: hl=bufferId
0422D9             0262*  ; prerequisites: vdu_sprite_select
0422D9             0263*  vdu_sprite_add_buff:
0422D9 22 EB 22 04 0264*      ld (@bufferId),hl
0422DD 21 E8 22 04 0265*      ld hl,@cmd
0422E1 01 05 00 00 0266*      ld bc,@end-@cmd
0422E5 5B DF       0267*      rst.lil $18
0422E7 C9          0268*      ret
0422E8 17 1B 26    0269*  @cmd:      db 23,27,0x26
0422EB 00 00       0270*  @bufferId: dw 0x0000
0422ED 00          0271*  @end:      db 0x00 ; padding
0422EE             0057   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
0422EE             0058   	include "maths.inc"
0422EE             0001*  ; test the sign of HL
0422EE             0002*  ; inputs: HL obviously
0422EE             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0422EE             0004*  ; destroys: flags
0422EE             0005*      MACRO sign_hlu
0422EE             0006*          add hl,de
0422EE             0007*          or a
0422EE             0008*          sbc hl,de
0422EE             0009*      ENDMACRO
0422EE             0010*  
0422EE             0011*  
0422EE             0012*  ;------------------------------------------------------------------------
0422EE             0013*  ; Scratch area for calculations
0422EE             0014*  ;------------------------------------------------------------------------
0422EE 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
0422F1 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
0422F4             0017*  
0422F4             0018*  ; absolute value of hlu
0422F4             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0422F4             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0422F4             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0422F4             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0422F4             0023*  ; destroys: a
0422F4             0024*  hlu_abs:
0422F4 19          0025*      add hl,de
0422F5 B7          0026*      or a
0422F6 ED 52       0027*      sbc hl,de
0422F8 FA FD 22 04 0028*      jp m,@is_neg
0422FC C9          0029*      ret         ; hlu is positive or zero so we're done
0422FD             0030*  @is_neg:
0422FD F5          0031*      push af     ; otherwise, save current flags for return
0422FE CD 04 23 04 0032*      call neg_hlu ; negate hlu
042302 F1          0033*      pop af      ; get back flags
042303 C9          0034*      ret
042304             0035*  
042304             0036*  ; flip the sign of hlu
042304             0037*  ; inputs: hlu
042304             0038*  ; returns: 0-hlu, flags set appropriately for the result:
042304             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
042304             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
042304             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
042304             0042*  ; destroys a
042304             0043*  neg_hlu:
042304 D5          0044*      push de     ; save de
042305 EB          0045*      ex de,hl    ; put hl into de
042306 21 00 00 00 0046*      ld hl,0     ; clear hl
04230A AF          0047*      xor a       ; clear carry
04230B ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
04230D D1          0049*      pop de      ; get de back
04230E C9          0050*      ret         ; easy peasy
04230F             0051*  
04230F             0052*  ;------------------------------------------------------------------------
04230F             0053*  ; divide hlu by 2, inspired by above
04230F             0054*  ;------------------------------------------------------------------------
04230F             0055*  hlu_div2:
04230F 22 EE 22 04 0056*  	ld		(scratch1),hl
042313 21 F0 22 04 0057*  	ld		hl,scratch1+2
042317 CB 1E       0058*  	rr		(hl)
042319 2B          0059*  	dec		hl
04231A CB 1E       0060*  	rr		(hl)
04231C 2B          0061*  	dec		hl
04231D CB 1E       0062*  	rr		(hl)
04231F 23          0063*  	inc		hl
042320 23          0064*  	inc		hl
042321 2A EE 22 04 0065*      ld hl,(scratch1)
042325 C9          0066*      ret
042326             0067*  
042326             0068*  ; this is my little hack to divide by 16
042326             0069*  hlu_div16:
042326 AF          0070*      xor a
042327 29          0071*      add hl,hl
042328 17          0072*      rla
042329 29          0073*      add hl,hl
04232A 17          0074*      rla
04232B 29          0075*      add hl,hl
04232C 17          0076*      rla
04232D 29          0077*      add hl,hl
04232E 17          0078*      rla
04232F 22 3C 23 04 0079*      ld (@scratch),hl
042333 32 3F 23 04 0080*      ld (@scratch+3),a
042337 2A 3D 23 04 0081*      ld hl,(@scratch+1)
04233B C9          0082*      ret
04233C             0083*  @scratch: ds 4
042340             0084*  
042340             0085*  ; hlu signed division by 256
042340             0086*  ; returns: hlu / 256
042340             0087*  ; destroys: af
042340             0088*  hlu_sdiv256:
042340 AF          0089*      xor a ; assume hl is positive
042341 22 57 23 04 0090*      ld (@buffer),hl
042345             0091*      sign_hlu
042345 19          0001*M         add hl,de
042346 B7          0002*M         or a
042347 ED 52       0003*M         sbc hl,de
042349 F2 4E 23 04 0092*      jp p,@hl_pos
04234D 3D          0093*      dec a
04234E             0094*  @hl_pos:
04234E 32 5A 23 04 0095*      ld (@buffer+3),a
042352 2A 58 23 04 0096*      ld hl,(@buffer+1)
042356 C9          0097*      ret
042357             0098*  @buffer: ds 4
04235B             0099*  
04235B             0100*  ; hlu 1 byte right shift, unsigned
04235B             0101*  ; returns: hlu / 256, fractional portion in a
04235B             0102*  ; destroys: af
04235B             0103*  hlu_udiv256:
04235B AF          0104*  	xor a
04235C 32 6D 23 04 0105*  	ld (@buffer+3),a
042360 7D          0106*  	ld a,l ; save the fractional portion
042361 22 6A 23 04 0107*  	ld (@buffer),hl
042365 2A 6B 23 04 0108*  	ld hl,(@buffer+1)
042369 C9          0109*  	ret
04236A             0110*  @buffer: ds 4
04236E             0111*  
04236E             0112*      MACRO hlu_mul256
04236E             0113*          add hl,hl ; * 2
04236E             0114*          add hl,hl ; * 4
04236E             0115*          add hl,hl ; * 8
04236E             0116*          add hl,hl ; * 16
04236E             0117*          add hl,hl ; * 32
04236E             0118*          add hl,hl ; * 64
04236E             0119*          add hl,hl ; * 128
04236E             0120*          add hl,hl ; * 256
04236E             0121*      ENDMACRO
04236E             0122*  
04236E             0123*  ; compute the modulo of hlu by deu
04236E             0124*  ; outputs: hlu = hlu % deu
04236E             0125*  ; destroys: f, hl
04236E             0126*  hlu_mod:
04236E B7          0127*  	or a ; clear carry
04236F             0128*  @loop:
04236F ED 52       0129*      sbc hl,de
042371 DA 79 23 04 0130*      jp c, @end
042375 C3 6F 23 04 0131*      jp @loop
042379             0132*  @end:
042379 19          0133*      add hl,de
04237A C9          0134*  	ret
04237B             0135*  
04237B             0136*  
04237B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04237F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
042383             0139*  
042383             0140*  ; set bcd values in a scratch memory address from registers bcde
042383             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
042383             0142*  ; destroys ; hl
042383             0143*  set_bcd:
042383 73          0144*      ld (hl),e
042384 23          0145*      inc hl
042385 72          0146*      ld (hl),d
042386 23          0147*      inc hl
042387 71          0148*      ld (hl),c
042388 23          0149*      inc hl
042389 70          0150*      ld (hl),b
04238A C9          0151*      ret
04238B             0152*  
04238B             0153*  ; load bcd values from a scratch memory address to bcde
04238B             0154*  ; input: hl; scratch address
04238B             0155*  ; output: bcde; 8-place bcd number
04238B             0156*  ; destroys: hl
04238B             0157*  get_bcd:
04238B 5E          0158*      ld e,(hl)
04238C 23          0159*      inc hl
04238D 56          0160*      ld d,(hl)
04238E 23          0161*      inc hl
04238F 4E          0162*      ld c,(hl)
042390 23          0163*      inc hl
042391 46          0164*      ld b,(hl)
042392 C9          0165*      ret
042393             0166*  
042393             0167*  ; BCD addition
042393             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
042393             0169*  ;       a is the number of bytes holding each number (number of places/2)
042393             0170*  ; outputs: (hl) + (de) --> (hl)
042393             0171*  ; destroys: a,b,de,hl
042393             0172*  add_bcd:
042393 47          0173*      ld b,a ; loop counter
042394 AF          0174*      xor a ; reset a, clear carry flag
042395             0175*  adcec:
042395 1A          0176*      ld a,(de) ; addend to acc
042396 8E          0177*      adc a,(hl) ; add (hl) to acc
042397 27          0178*      daa ; adjust result to bcd
042398 77          0179*      ld (hl),a ; store result
042399 23          0180*      inc hl ; advance memory pointers
04239A 13          0181*      inc de
04239B 10 F8       0182*      djnz adcec ; loop until b == 0
04239D C9          0183*      ret
04239E             0184*  
04239E             0185*  ; BCD subtraction
04239E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04239E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04239E             0188*  ; outputs: (hl) - (de) --> (hl)
04239E             0189*  ; destroys: a,b,de,hl
04239E             0190*  sub_bcd:
04239E 47          0191*      ld b,a ; loop counter
04239F AF          0192*      xor a ; reset a,clear carry flag
0423A0             0193*  subdec:
0423A0 1A          0194*      ld a,(de) ; subtrahend to acc
0423A1 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0423A2 27          0196*      daa ; adjust result to bcd
0423A3 77          0197*      ld (hl),a ; store result
0423A4 23          0198*      inc hl ; advance memory pointers
0423A5 13          0199*      inc de
0423A6 10 F8       0200*      djnz subdec ; loop until b == 0
0423A8 C9          0201*      ret
0423A9             0202*  
0423A9             0203*  ; http://www.z80.info/pseudo-random.txt
0423A9             0204*  rand_8:
0423A9 C5          0205*      push bc
0423AA 3A BD 23 04 0206*      ld a,(r_seed)
0423AE 4F          0207*      ld c,a
0423AF             0208*  
0423AF 0F          0209*      rrca ; multiply by 32
0423B0 0F          0210*      rrca
0423B1 0F          0211*      rrca
0423B2 EE 1F       0212*      xor 0x1f
0423B4             0213*  
0423B4 81          0214*      add a,c
0423B5 DE FF       0215*      sbc a,255 ; carry
0423B7             0216*  
0423B7 32 BD 23 04 0217*      ld (r_seed),a
0423BB C1          0218*      pop bc
0423BC C9          0219*      ret
0423BD 50          0220*  r_seed: defb $50
0423BE             0059   	include "trig24fast.inc"
0423BE             0001*  
0423BE             0002*  ; convert signed angles from a 360 to 256 degree circle
0423BE             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0423BE             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0423BE             0005*  ; destroys: TODO
0423BE             0006*  deg_360_to_256:
0423BE D5          0007*  	push de ; preserve de
0423BF             0008*  ; make angle positive and store sign flag
0423BF CD F4 22 04 0009*  	call hlu_abs
0423C3 F5          0010*  	push af
0423C4             0011*  ; multiply by 256 first to keep precision
0423C4             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0423C4 29          0001*M         add hl,hl ; * 2
0423C5 29          0002*M         add hl,hl ; * 4
0423C6 29          0003*M         add hl,hl ; * 8
0423C7 29          0004*M         add hl,hl ; * 16
0423C8 29          0005*M         add hl,hl ; * 32
0423C9 29          0006*M         add hl,hl ; * 64
0423CA 29          0007*M         add hl,hl ; * 128
0423CB 29          0008*M         add hl,hl ; * 256
0423CC             0013*  ; divide uh.l by 360
0423CC 11 68 01 00 0014*  	ld de,360
0423D0 CD 8B 2E 04 0015*  	call udiv24 ; ud.e = degrees / 360
0423D4 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0423D5             0017*  ; restore sign flag and adjust output accordingly
0423D5 F1          0018*  	pop af
0423D6 F2 DE 23 04 0019*  	jp p,@pos ; positive number
0423DA CD 04 23 04 0020*  	call neg_hlu
0423DE             0021*  @pos:
0423DE             0022*  ; restore de and return uh.l as the result
0423DE D1          0023*  	pop de
0423DF C9          0024*  	ret
0423E0             0025*  
0423E0             0026*  ; fixed 16.8 routine
0423E0             0027*  ; cos(uh.l) --> uh.l
0423E0             0028*  ; destroys: f, hl
0423E0             0029*  cos168:
0423E0 D5          0030*      push de ; preserve de
0423E1             0031*  ; for cos we simply increment the angle by 90 degrees
0423E1             0032*  ; or 0x004000 in 16.8 degrees256
0423E1             0033*  ; which makes it a sin problem
0423E1 11 00 40 00 0034*      ld de,0x004000
0423E5 19          0035*      add hl,de ; modulo 256 happens below
0423E6 D1          0036*      pop de ; restore de
0423E7             0037*  ; fall through to sin168
0423E7             0038*  
0423E7             0039*  ; ---------------------
0423E7             0040*  ; fixed 16.8 routine
0423E7             0041*  ; sin(uh.l) --> uh.l
0423E7             0042*  ; destroys: f, hl
0423E7             0043*  sin168:
0423E7 D5          0044*  	push de
0423E8             0045*  ; handle negative angles appropriately
0423E8 CD F4 22 04 0046*  	call hlu_abs
0423EC F2 F5 23 04 0047*  	jp p,@F
0423F0 11 00 00 FF 0048*  	ld de,-256*256
0423F4 19          0049*  	add hl,de
0423F5             0050*  @@:
0423F5 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
0423F7 ED 6C       0052*      mlt hl
0423F9 11 56 26 04 0053*      ld de,sin_lut_168 ; grab the lut address
0423FD 19          0054*      add hl,de ; bump hl by the index
0423FE ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
042400 D1          0056*      pop de
042401 C9          0057*      ret
042402             0058*  
042402             0059*  ; 16.8 fixed inputs / outputs
042402             0060*  ; takes: uh.l as angle in degrees 256
042402             0061*  ;        ud.e as radius
042402             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
042402             0063*  ;        displacements from origin (0,0)
042402             0064*  ; destroys: everything except indexes
042402             0065*  polar_to_cartesian:
042402             0066*  ; back up input parameters
042402 22 31 24 04 0067*      ld (@angle), hl
042406 ED 53 34 24 0068*      ld (@radius), de
       04          
04240B             0069*  ; compute dx = sin(uh.l) * ud.e
04240B CD E7 23 04 0070*      call sin168 ; uh.l = sin(uh.l)
04240F ED 5B 34 24 0071*  	ld de,(@radius)
       04          
042414 CD 00 2E 04 0072*  	call smul168 ; uh.l = dx
042418 E5          0073*      push hl
042419             0074*  ; compute dy = -cos(uh.l) * ud.e
042419 2A 31 24 04 0075*      ld hl,(@angle)
04241D CD E0 23 04 0076*      call cos168 ; uh.l = cos(uh.l)
042421 ED 5B 34 24 0077*      ld de,(@radius)
       04          
042426 CD 00 2E 04 0078*      call smul168    ; uh.l = dy
04242A CD 04 23 04 0079*      call neg_hlu ; invert dy for screen coords convention
04242E EB          0080*      ex de,hl       ; de = dy for output
04242F C1          0081*      pop bc          ; bc = dx for output
042430             0082*  ; and out
042430 C9          0083*      ret
042431             0084*  @angle: ds 3
042434             0085*  @radius: ds 3
042437             0086*  
042437             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042437             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042437             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042437             0090*  ;         also populates scratch locations dx168 and dy168
042437             0091*  ; destroys: a,hl,bc,de
042437             0092*  dxy168:
042437             0093*  ; compute dx = x1-x0
042437 AF          0094*      xor a ; clear carry
042438 DD E5       0095*      push ix ; move ix to hl via the stack
04243A E1          0096*      pop hl ; hl = x1
04243B ED 42       0097*      sbc hl,bc ; hl = dx
04243D 22 52 24 04 0098*      ld (@dx168),hl ; dx to scratch
042441             0099*  ; compute dy = y1-y0
042441 AF          0100*      xor a ; clear carry
042442 FD E5       0101*      push iy ; move iy to hl via the stack
042444 E1          0102*      pop hl ; hl = y1
042445 ED 52       0103*      sbc hl,de ; hl = dy
042447 22 58 24 04 0104*      ld (@dy168),hl ; dy to scratch
04244B             0105*  ; populate output registers and return
04244B EB          0106*      ex de,hl        ; ud.e = dy
04244C ED 4B 52 24 0107*      ld bc,(@dx168)   ; ub.c = dx
       04          
042451 C9          0108*      ret
042452             0109*  @dx168: ds 6
042458             0110*  @dy168: ds 6
04245E             0111*  
04245E             0112*  ; compute the euclidian distance between two cartesian coordinates
04245E             0113*  ; using the formula d = sqrt(dx^2+dy^2
04245E             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04245E             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04245E             0116*  ; output; uh.l is the 16.8 fixed format distance
04245E             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
04245E             0118*  ; destroys: a,hl,bc,de
04245E             0119*  distance168:
04245E             0120*  ; compute dx = x1-x0
04245E AF          0121*      xor a ; clear carry
04245F DD E5       0122*      push ix ; move ix to hl via the stack
042461 E1          0123*      pop hl ; hl = x1
042462 ED 42       0124*      sbc hl,bc ; hl = dx
042464 22 9E 24 04 0125*      ld (@dx168),hl ; dx to scratch
042468             0126*  ; ; test dx for overflow
042468             0127*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
042468             0128*  ; 	ex de,hl
042468             0129*  ; 	sbc hl,de ; test for overflow
042468             0130*  ; 	push af ; carry indicates overflow
042468             0131*  ; compute dy = y1-y0
042468 AF          0132*      xor a ; clear carry
042469 FD E5       0133*      push iy ; move iy to hl via the stack
04246B E1          0134*      pop hl ; hl = y1
04246C ED 52       0135*      sbc hl,de ; hl = dy
04246E 22 A4 24 04 0136*      ld (@dy168),hl ; dy to scratch
042472             0137*  ; ; test dy for overflow
042472             0138*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
042472             0139*  ; 	ex de,hl
042472             0140*  ; 	sbc hl,de ; test for overflow
042472             0141*  ; 	push af ; carry indicates overflow
042472             0142*  ; compute dy^2
042472 2A A4 24 04 0143*  	ld hl,(@dy168)
042476 CD F4 22 04 0144*      call hlu_abs  ; make dy positive so we can use unsigned multiply
04247A             0145*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04247A E5          0146*      push hl ; load hl/2 to bc via the stack
04247B C1          0147*      pop bc ; bc = dy/2
04247C EB          0148*      ex de,hl ; de = dy/2
04247D CD F8 2D 04 0149*      call umul168 ; uh.l = dy^2/2
042481 E5          0150*      push hl ; dy^2/2 to the stack
042482             0151*  ; compute dx^2
042482 2A 9E 24 04 0152*      ld hl,(@dx168) ; get back dx
042486 CD F4 22 04 0153*      call hlu_abs  ; make dx positive so we can use unsigned multiply
04248A             0154*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04248A E5          0155*      push hl ; load hl/2 to bc via the stack
04248B C1          0156*      pop bc ; bc = dx/2
04248C EB          0157*      ex de,hl ; de = dx/2
04248D CD F8 2D 04 0158*      call umul168 ; uh.l = dx^2/2
042491             0159*  ; commpute dy^2+dx^2
042491 D1          0160*      pop de ; get back dx^2/2
042492 19          0161*      add hl,de ; hl = dx^2/2+dy^2/2
042493             0162*  ; compute sqrt(dx^2/2+dy^2/2)
042493 CD 6B 25 04 0163*      call sqrt168 ; uh.l = distance/2
042497             0164*      ; add hl,hl ; hl = distance
042497             0165*  ; ; check for overflow
042497             0166*  ; 	pop af ; get back the overflow flags
042497             0167*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042497             0168*  ; 	ld b,a ; save the overflow flag
042497             0169*  ; 	pop af ; get back the overflow flags
042497             0170*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042497             0171*  ; 	add a,b ; if a != 0 then we had overflow
042497             0172*  ;     ret z ; no overflow we're done
042497             0173*  ; @overflow:
042497             0174*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
042497 C9          0175*  	ret
042498             0176*  @scratch: ds 6
04249E             0177*  @dx168: ds 6
0424A4             0178*  @dy168: ds 6
0424AA             0179*  
0424AA             0180*  ; atan2_(ub.c,ud.e) --> uh.l
0424AA             0181*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0424AA             0182*  ;   whether inputs are integers or fractional doesn't matter
0424AA             0183*  ;   so long as the sign bit of the upper byte is correct
0424AA             0184*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0424AA             0185*  ; angles are COMPASS HEADINGS based on
0424AA             0186*  ; screen coordinate conventions,where the y axis is flipped
0424AA             0187*  ; #E0 315      0       45 #20
0424AA             0188*  ;        -x,-y | +x,-y
0424AA             0189*  ; #C0 270------+------ 90 #40
0424AA             0190*  ;        -x,+y | +x,+y
0424AA             0191*  ; #A0 225   180 #80   135 #60
0424AA             0192*  atan2_168fast:
0424AA             0193*  ; get signs and make everything positive
0424AA             0194*  ; get abs(x) and store its original sign
0424AA C5          0195*      push bc
0424AB E1          0196*      pop hl
0424AC CD F4 22 04 0197*      call hlu_abs ; if x was negative this also sets the sign flag
0424B0 E5          0198*      push hl ; store abs(x)
0424B1 C1          0199*      pop bc ; bc = abs(x)
0424B2 F5          0200*      push af ; store sign of x
0424B3             0201*  ; get abs(y) and store its original sign
0424B3 EB          0202*      ex de,hl ; hl = y
0424B4 CD F4 22 04 0203*      call hlu_abs ; if y was negative this also sets the sign flag
0424B8 EB          0204*      ex de,hl ; de = abs(y)
0424B9 F5          0205*      push af ; store sign of y
0424BA             0206*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0424BA             0207*  ; this ensures that our lookup value is between 0 and 1 inclusive
0424BA AF          0208*      xor a ; clear the carry flag
0424BB D5          0209*      push de
0424BC E1          0210*      pop hl
0424BD ED 42       0211*      sbc hl,bc
0424BF F5          0212*      push af ; save sign of de - bc
0424C0 F2 C9 24 04 0213*      jp p,@1 ; bc <= de, so we skip ahead
0424C4             0214*  ; otherwise we swap bc and de
0424C4 C5          0215*      push bc
0424C5 E1          0216*      pop hl
0424C6 EB          0217*      ex de,hl
0424C7 E5          0218*      push hl
0424C8 C1          0219*      pop bc
0424C9             0220*  @1:
0424C9             0221*  ; now we're ready to snag our preliminary result
0424C9 C5          0222*  	push bc
0424CA E1          0223*  	pop hl
0424CB CD 39 25 04 0224*      call atan_168fast ; uh.l comes back with prelim result
0424CF             0225*  ; now we adjust uh.l based on sign of de - bc
0424CF F1          0226*      pop af
0424D0 F2 DC 24 04 0227*      jp p,@2 ; bc <= de,so we skip ahead
0424D4 EB          0228*      ex de,hl
0424D5 21 00 40 00 0229*      ld hl,0x004000 ; 90 degrees
0424D9 AF          0230*      xor a ; clear the carry flag
0424DA ED 52       0231*      sbc hl,de ; subtract result from 90 degrees
0424DC             0232*  @2:
0424DC             0233*  ; now the fun part of adjusting the result
0424DC             0234*  ; based on which quadrant (x,y) is in
0424DC             0235*  ; #E0 315      0       45 #20
0424DC             0236*  ;        -x,-y | +x,-y
0424DC             0237*  ; #C0 270------+------ 90 #40
0424DC             0238*  ;        -x,+y | +x,+y
0424DC             0239*  ; #A0 225   180 #80   135 #60
0424DC F1          0240*      pop af ; sign of y
0424DD CA 1A 25 04 0241*      jp z,@y_zero
0424E1 F2 FA 24 04 0242*      jp p,@y_pos
0424E5             0243*  ; y neg,check x
0424E5 F1          0244*      pop af ; sign of x
0424E6 CA F4 24 04 0245*      jp z,@y_neg_x_zero
0424EA F2 F9 24 04 0246*      jp p,@y_neg_x_pos
0424EE             0247*  ; y neg,x neg
0424EE             0248*  ; angle is 270-360
0424EE             0249*  ; negating the intermediate does the trick
0424EE CD 04 23 04 0250*      call neg_hlu
0424F2 18 31       0251*      jr @zero_hlu
0424F4             0252*  
0424F4             0253*  @y_neg_x_zero:
0424F4             0254*  ; y neg,x zero
0424F4             0255*  ; angle is 0
0424F4 21 00 00 00 0256*      ld hl,0
0424F8 C9          0257*      ret
0424F9             0258*  @y_neg_x_pos:
0424F9             0259*  ; y neg,x pos
0424F9             0260*  ; angle is 0 to 90
0424F9             0261*  ; so we're good
0424F9 C9          0262*      ret
0424FA             0263*  
0424FA             0264*  @y_pos:
0424FA F1          0265*      pop af ; sign of x
0424FB CA 0A 25 04 0266*      jp z,@y_pos_x_zero
0424FF F2 0F 25 04 0267*      jp p,@y_pos_x_pos
042503             0268*  ; y pos,x neg
042503             0269*  ; angle is 180-270
042503             0270*  ; so we add 180 to intermediate
042503 11 00 80 00 0271*      ld de,0x008000
042507 19          0272*      add hl,de
042508 18 1B       0273*      jr @zero_hlu
04250A             0274*  @y_pos_x_zero:
04250A             0275*  ; y pos,x zero
04250A             0276*  ; angle is 180
04250A 21 00 80 00 0277*      ld hl,0x008000
04250E C9          0278*      ret
04250F             0279*  @y_pos_x_pos:
04250F             0280*  ; y pos,x pos
04250F             0281*  ; angle is 90-180
04250F             0282*  ; neg the intermediate and add 180 degrees
04250F CD 04 23 04 0283*      call neg_hlu
042513 11 00 80 00 0284*      ld de,0x008000
042517 19          0285*      add hl,de
042518 18 0B       0286*      jr @zero_hlu
04251A             0287*  
04251A             0288*  @y_zero:
04251A F1          0289*      pop af ; sign of x
04251B FA 20 25 04 0290*      jp m,@y_zero_x_neg
04251F             0291*  ; y zero,x pos
04251F             0292*  ; angle is 90,nothing to do
04251F C9          0293*      ret
042520             0294*  @y_zero_x_neg:
042520             0295*  ; y zero ,x neg
042520             0296*  ; angle is 270
042520 21 00 C0 00 0297*      ld hl,0x00C000
042524 C9          0298*      ret
042525             0299*  @zero_hlu:
042525 AF          0300*      xor a
042526 22 33 25 04 0301*      ld (@scratch),hl
04252A 32 35 25 04 0302*      ld (@scratch+2),a
04252E 2A 33 25 04 0303*      ld hl,(@scratch)
042532 C9          0304*      ret
042533             0305*  @scratch: ds 6
042539             0306*  
042539             0307*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042539             0308*  ; output: uh.l is the 16.8 fixed format angle
042539             0309*  ; destroys: a,hl,bc,de
042539             0310*  ; the following note was written by github copilot:
042539             0311*  ; note: this routine is a bit of a hack
042539             0312*  ;      but it works
042539             0313*  ;      and it's fast
042539             0314*  ;      and it's small
042539             0315*  ;      and it's accurate
042539             0316*  ;      and it's easy to understand
042539             0317*  ;      and it's easy to modify
042539             0318*  ;      and it's easy to use
042539             0319*  ;      and it's easy to remember
042539             0320*  ;      and it's easy to love
042539             0321*  ;      and it's easy to hate
042539             0322*  ;      and it's easy to ignore
042539             0323*  ;      and it's easy to forget
042539             0324*  ;      and it's easy to remember
042539             0325*  ;      and it's easy to forget
042539             0326*  ;      and it's easy to remember
042539             0327*  ;      (ok the bot is stuck in a loop)
042539             0328*  ; REAL NOTE: only works for angles from 0 to 45 degrees
042539             0329*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
042539             0330*  atan_168fast:
042539             0331*  ; because we use compass headings instead of geometric angles
042539             0332*  ; we compute dx/dy which is 1/tan(theta) in the maths world
042539             0333*  ; we can do faster unsigned division here because we know dx and dy are positive
042539 CD 23 2E 04 0334*  	call udiv168 ; ud.e = dx/dy
04253D EB          0335*  	ex de,hl ; uh.l = dx/dy
04253E             0336*  ; test uh.l for 0
04253E 19          0337*      add hl,de
04253F B7          0338*      or a
042540 ED 52       0339*      sbc hl,de
042542 28 22       0340*      jr z,@is_zero
042544             0341*  ; test uh.l for 1
042544 AF          0342*      xor a ; clear carry
042545 EB          0343*      ex de,hl
042546 21 00 01 00 0344*      ld hl,0x000100 ; 1 in 16.8 fixed format
04254A ED 52       0345*      sbc hl,de
04254C 28 13       0346*      jr z,@is_45
04254E EB          0347*  	ex de,hl
04254F             0348*  ; no special cases so we move on
04254F             0349*  ; l contains the fractional portion of tan(uh.l)
04254F             0350*  ; we multiply it by three to get our lookup table index
04254F 26 03       0351*      ld h,3
042551 ED 6C       0352*      mlt hl ; gosh that is handy
042553 11 00 00 00 0353*      ld de,0 ; clear deu
042557 54          0354*      ld d,h ; copy hl to de
042558 5D          0355*      ld e,l ; de contains our index
042559 21 59 29 04 0356*      ld hl,atan_lut_168 ; grab the lut address
04255D 19          0357*      add hl,de ; bump hl by the index
04255E ED 27       0358*      ld hl,(hl) ; don't try this on a z80!
042560 C9          0359*      ret ; and out
042561             0360*  @is_45:
042561 21 00 20 00 0361*      ld hl,0x002000 ; 45 degrees decimal
042565 C9          0362*      ret
042566             0363*  ; for the case tan(0)
042566             0364*  @is_zero:
042566 21 00 00 00 0365*      ld hl,0x000000
04256A C9          0366*      ret
04256B             0367*  
04256B             0368*  ; Expects  ADL mode
04256B             0369*  ; Inputs:  UH.L
04256B             0370*  ; Outputs: UH.L is the 16.8 square root
04256B             0371*  ;          UD.E is the difference inputHL-DE^2
04256B             0372*  ;          c flag reset
04256B             0373*  sqrt168:
04256B CD 75 25 04 0374*      call sqrt24
04256F EB          0375*      ex de,hl
042570 29          0376*      add hl,hl
042571 29          0377*      add hl,hl
042572 29          0378*      add hl,hl
042573 29          0379*      add hl,hl
042574 C9          0380*      ret
042575             0381*  
042575             0382*  ; Expects  ADL mode
042575             0383*  ; Inputs:  HL
042575             0384*  ; Outputs: DE is the integer square root
042575             0385*  ;          HL is the difference inputHL-DE^2
042575             0386*  ;          c flag reset
042575             0387*  sqrt24:
042575 AF          0388*      xor a
042576 45          0389*      ld b,l
042577 C5          0390*      push bc
042578 47          0391*      ld b,a
042579 57          0392*      ld d,a
04257A 4F          0393*      ld c,a
04257B 6F          0394*      ld l,a
04257C 5F          0395*      ld e,a
04257D             0396*  
04257D             0397*      ;Iteration 1
04257D 29          0398*      add hl,hl
04257E CB 11       0399*      rl c
042580 29          0400*      add hl,hl
042581 CB 11       0401*      rl c
042583 91          0402*      sub c
042584 30 04       0403*      jr nc,$+6
042586 1C          0404*      inc e
042587 1C          0405*      inc e
042588 2F          0406*      cpl
042589 4F          0407*      ld c,a
04258A             0408*  
04258A             0409*      ;Iteration 2
04258A 29          0410*      add hl,hl
04258B CB 11       0411*      rl c
04258D 29          0412*      add hl,hl
04258E CB 11       0413*      rl c
042590 CB 13       0414*      rl e
042592 7B          0415*      ld a,e
042593 91          0416*      sub c
042594 30 04       0417*      jr nc,$+6
042596 1C          0418*      inc e
042597 1C          0419*      inc e
042598 2F          0420*      cpl
042599 4F          0421*      ld c,a
04259A             0422*  
04259A             0423*      ;Iteration 3
04259A 29          0424*      add hl,hl
04259B CB 11       0425*      rl c
04259D 29          0426*      add hl,hl
04259E CB 11       0427*      rl c
0425A0 CB 13       0428*      rl e
0425A2 7B          0429*      ld a,e
0425A3 91          0430*      sub c
0425A4 30 04       0431*      jr nc,$+6
0425A6 1C          0432*      inc e
0425A7 1C          0433*      inc e
0425A8 2F          0434*      cpl
0425A9 4F          0435*      ld c,a
0425AA             0436*  
0425AA             0437*      ;Iteration 4
0425AA 29          0438*      add hl,hl
0425AB CB 11       0439*      rl c
0425AD 29          0440*      add hl,hl
0425AE CB 11       0441*      rl c
0425B0 CB 13       0442*      rl e
0425B2 7B          0443*      ld a,e
0425B3 91          0444*      sub c
0425B4 30 04       0445*      jr nc,$+6
0425B6 1C          0446*      inc e
0425B7 1C          0447*      inc e
0425B8 2F          0448*      cpl
0425B9 4F          0449*      ld c,a
0425BA             0450*  
0425BA             0451*      ;Iteration 5
0425BA 29          0452*      add hl,hl
0425BB CB 11       0453*      rl c
0425BD 29          0454*      add hl,hl
0425BE CB 11       0455*      rl c
0425C0 CB 13       0456*      rl e
0425C2 7B          0457*      ld a,e
0425C3 91          0458*      sub c
0425C4 30 04       0459*      jr nc,$+6
0425C6 1C          0460*      inc e
0425C7 1C          0461*      inc e
0425C8 2F          0462*      cpl
0425C9 4F          0463*      ld c,a
0425CA             0464*  
0425CA             0465*      ;Iteration 6
0425CA 29          0466*      add hl,hl
0425CB CB 11       0467*      rl c
0425CD 29          0468*      add hl,hl
0425CE CB 11       0469*      rl c
0425D0 CB 13       0470*      rl e
0425D2 7B          0471*      ld a,e
0425D3 91          0472*      sub c
0425D4 30 04       0473*      jr nc,$+6
0425D6 1C          0474*      inc e
0425D7 1C          0475*      inc e
0425D8 2F          0476*      cpl
0425D9 4F          0477*      ld c,a
0425DA             0478*  
0425DA             0479*      ;Iteration 7
0425DA 29          0480*      add hl,hl
0425DB CB 11       0481*      rl c
0425DD 29          0482*      add hl,hl
0425DE CB 11       0483*      rl c
0425E0 CB 10       0484*      rl b
0425E2 EB          0485*      ex de,hl
0425E3 29          0486*      add hl,hl
0425E4 E5          0487*      push hl
0425E5 ED 42       0488*      sbc hl,bc
0425E7 30 06       0489*      jr nc,$+8
0425E9 7C          0490*      ld a,h
0425EA 2F          0491*      cpl
0425EB 47          0492*      ld b,a
0425EC 7D          0493*      ld a,l
0425ED 2F          0494*      cpl
0425EE 4F          0495*      ld c,a
0425EF E1          0496*      pop hl
0425F0 30 02       0497*      jr nc,$+4
0425F2 23          0498*      inc hl
0425F3 23          0499*      inc hl
0425F4 EB          0500*      ex de,hl
0425F5             0501*  
0425F5             0502*      ;Iteration 8
0425F5 29          0503*      add hl,hl
0425F6 69          0504*      ld l,c
0425F7 60          0505*      ld h,b
0425F8 ED 6A       0506*      adc hl,hl
0425FA ED 6A       0507*      adc hl,hl
0425FC EB          0508*      ex de,hl
0425FD 29          0509*      add hl,hl
0425FE ED 52       0510*      sbc hl,de
042600 19          0511*      add hl,de
042601 EB          0512*      ex de,hl
042602 30 04       0513*      jr nc,$+6
042604 ED 52       0514*      sbc hl,de
042606 13          0515*      inc de
042607 13          0516*      inc de
042608             0517*  
042608             0518*      ;Iteration 9
042608 F1          0519*      pop af
042609 17          0520*      rla
04260A ED 6A       0521*      adc hl,hl
04260C 17          0522*      rla
04260D ED 6A       0523*      adc hl,hl
04260F EB          0524*      ex de,hl
042610 29          0525*      add hl,hl
042611 ED 52       0526*      sbc hl,de
042613 19          0527*      add hl,de
042614 EB          0528*      ex de,hl
042615 30 04       0529*      jr nc,$+6
042617 ED 52       0530*      sbc hl,de
042619 13          0531*      inc de
04261A 13          0532*      inc de
04261B             0533*  
04261B             0534*      ;Iteration 10
04261B 17          0535*      rla
04261C ED 6A       0536*      adc hl,hl
04261E 17          0537*      rla
04261F ED 6A       0538*      adc hl,hl
042621 EB          0539*      ex de,hl
042622 29          0540*      add hl,hl
042623 ED 52       0541*      sbc hl,de
042625 19          0542*      add hl,de
042626 EB          0543*      ex de,hl
042627 30 04       0544*      jr nc,$+6
042629 ED 52       0545*      sbc hl,de
04262B 13          0546*      inc de
04262C 13          0547*      inc de
04262D             0548*  
04262D             0549*      ;Iteration 11
04262D 17          0550*      rla
04262E ED 6A       0551*      adc hl,hl
042630 17          0552*      rla
042631 ED 6A       0553*      adc hl,hl
042633 EB          0554*      ex de,hl
042634 29          0555*      add hl,hl
042635 ED 52       0556*      sbc hl,de
042637 19          0557*      add hl,de
042638 EB          0558*      ex de,hl
042639 30 04       0559*      jr nc,$+6
04263B ED 52       0560*      sbc hl,de
04263D 13          0561*      inc de
04263E 13          0562*      inc de
04263F             0563*  
04263F             0564*      ;Iteration 11
04263F 17          0565*      rla
042640 ED 6A       0566*      adc hl,hl
042642 17          0567*      rla
042643 ED 6A       0568*      adc hl,hl
042645 EB          0569*      ex de,hl
042646 29          0570*      add hl,hl
042647 ED 52       0571*      sbc hl,de
042649 19          0572*      add hl,de
04264A EB          0573*      ex de,hl
04264B 30 04       0574*      jr nc,$+6
04264D ED 52       0575*      sbc hl,de
04264F 13          0576*      inc de
042650 13          0577*      inc de
042651             0578*  
042651 CB 1A       0579*      rr d
042653 CB 1B       0580*      rr e
042655 C9          0581*      ret
042656             0582*  
042656             0583*  sin_lut_168:
042656 00 00 00    0584*  	dl 0x000000 ; 0.000 00, 0.000
042659 06 00 00    0585*  	dl 0x000006 ; 1.406 01, 0.025
04265C 0C 00 00    0586*  	dl 0x00000C ; 2.813 02, 0.049
04265F 12 00 00    0587*  	dl 0x000012 ; 4.219 03, 0.074
042662 19 00 00    0588*  	dl 0x000019 ; 5.625 04, 0.098
042665 1F 00 00    0589*  	dl 0x00001F ; 7.031 05, 0.122
042668 25 00 00    0590*  	dl 0x000025 ; 8.438 06, 0.147
04266B 2B 00 00    0591*  	dl 0x00002B ; 9.844 07, 0.171
04266E 31 00 00    0592*  	dl 0x000031 ; 11.250 08, 0.195
042671 38 00 00    0593*  	dl 0x000038 ; 12.656 09, 0.219
042674 3E 00 00    0594*  	dl 0x00003E ; 14.063 0A, 0.243
042677 44 00 00    0595*  	dl 0x000044 ; 15.469 0B, 0.267
04267A 4A 00 00    0596*  	dl 0x00004A ; 16.875 0C, 0.290
04267D 50 00 00    0597*  	dl 0x000050 ; 18.281 0D, 0.314
042680 56 00 00    0598*  	dl 0x000056 ; 19.688 0E, 0.337
042683 5C 00 00    0599*  	dl 0x00005C ; 21.094 0F, 0.360
042686 61 00 00    0600*  	dl 0x000061 ; 22.500 10, 0.383
042689 67 00 00    0601*  	dl 0x000067 ; 23.906 11, 0.405
04268C 6D 00 00    0602*  	dl 0x00006D ; 25.313 12, 0.428
04268F 73 00 00    0603*  	dl 0x000073 ; 26.719 13, 0.450
042692 78 00 00    0604*  	dl 0x000078 ; 28.125 14, 0.471
042695 7E 00 00    0605*  	dl 0x00007E ; 29.531 15, 0.493
042698 83 00 00    0606*  	dl 0x000083 ; 30.938 16, 0.514
04269B 88 00 00    0607*  	dl 0x000088 ; 32.344 17, 0.535
04269E 8E 00 00    0608*  	dl 0x00008E ; 33.750 18, 0.556
0426A1 93 00 00    0609*  	dl 0x000093 ; 35.156 19, 0.576
0426A4 98 00 00    0610*  	dl 0x000098 ; 36.563 1A, 0.596
0426A7 9D 00 00    0611*  	dl 0x00009D ; 37.969 1B, 0.615
0426AA A2 00 00    0612*  	dl 0x0000A2 ; 39.375 1C, 0.634
0426AD A7 00 00    0613*  	dl 0x0000A7 ; 40.781 1D, 0.653
0426B0 AB 00 00    0614*  	dl 0x0000AB ; 42.188 1E, 0.672
0426B3 B0 00 00    0615*  	dl 0x0000B0 ; 43.594 1F, 0.690
0426B6 B5 00 00    0616*  	dl 0x0000B5 ; 45.000 20, 0.707
0426B9 B9 00 00    0617*  	dl 0x0000B9 ; 46.406 21, 0.724
0426BC BD 00 00    0618*  	dl 0x0000BD ; 47.813 22, 0.741
0426BF C1 00 00    0619*  	dl 0x0000C1 ; 49.219 23, 0.757
0426C2 C5 00 00    0620*  	dl 0x0000C5 ; 50.625 24, 0.773
0426C5 C9 00 00    0621*  	dl 0x0000C9 ; 52.031 25, 0.788
0426C8 CD 00 00    0622*  	dl 0x0000CD ; 53.438 26, 0.803
0426CB D1 00 00    0623*  	dl 0x0000D1 ; 54.844 27, 0.818
0426CE D4 00 00    0624*  	dl 0x0000D4 ; 56.250 28, 0.831
0426D1 D8 00 00    0625*  	dl 0x0000D8 ; 57.656 29, 0.845
0426D4 DB 00 00    0626*  	dl 0x0000DB ; 59.063 2A, 0.858
0426D7 DE 00 00    0627*  	dl 0x0000DE ; 60.469 2B, 0.870
0426DA E1 00 00    0628*  	dl 0x0000E1 ; 61.875 2C, 0.882
0426DD E4 00 00    0629*  	dl 0x0000E4 ; 63.281 2D, 0.893
0426E0 E7 00 00    0630*  	dl 0x0000E7 ; 64.688 2E, 0.904
0426E3 EA 00 00    0631*  	dl 0x0000EA ; 66.094 2F, 0.914
0426E6 EC 00 00    0632*  	dl 0x0000EC ; 67.500 30, 0.924
0426E9 EE 00 00    0633*  	dl 0x0000EE ; 68.906 31, 0.933
0426EC F1 00 00    0634*  	dl 0x0000F1 ; 70.313 32, 0.942
0426EF F3 00 00    0635*  	dl 0x0000F3 ; 71.719 33, 0.950
0426F2 F4 00 00    0636*  	dl 0x0000F4 ; 73.125 34, 0.957
0426F5 F6 00 00    0637*  	dl 0x0000F6 ; 74.531 35, 0.964
0426F8 F8 00 00    0638*  	dl 0x0000F8 ; 75.938 36, 0.970
0426FB F9 00 00    0639*  	dl 0x0000F9 ; 77.344 37, 0.976
0426FE FB 00 00    0640*  	dl 0x0000FB ; 78.750 38, 0.981
042701 FC 00 00    0641*  	dl 0x0000FC ; 80.156 39, 0.985
042704 FD 00 00    0642*  	dl 0x0000FD ; 81.563 3A, 0.989
042707 FE 00 00    0643*  	dl 0x0000FE ; 82.969 3B, 0.992
04270A FE 00 00    0644*  	dl 0x0000FE ; 84.375 3C, 0.995
04270D FF 00 00    0645*  	dl 0x0000FF ; 85.781 3D, 0.997
042710 FF 00 00    0646*  	dl 0x0000FF ; 87.188 3E, 0.999
042713 FF 00 00    0647*  	dl 0x0000FF ; 88.594 3F, 1.000
042716 00 01 00    0648*  	dl 0x000100 ; 90.000 40, 1.000
042719 FF 00 00    0649*  	dl 0x0000FF ; 91.406 41, 1.000
04271C FF 00 00    0650*  	dl 0x0000FF ; 92.813 42, 0.999
04271F FF 00 00    0651*  	dl 0x0000FF ; 94.219 43, 0.997
042722 FE 00 00    0652*  	dl 0x0000FE ; 95.625 44, 0.995
042725 FE 00 00    0653*  	dl 0x0000FE ; 97.031 45, 0.992
042728 FD 00 00    0654*  	dl 0x0000FD ; 98.438 46, 0.989
04272B FC 00 00    0655*  	dl 0x0000FC ; 99.844 47, 0.985
04272E FB 00 00    0656*  	dl 0x0000FB ; 101.250 48, 0.981
042731 F9 00 00    0657*  	dl 0x0000F9 ; 102.656 49, 0.976
042734 F8 00 00    0658*  	dl 0x0000F8 ; 104.063 4A, 0.970
042737 F6 00 00    0659*  	dl 0x0000F6 ; 105.469 4B, 0.964
04273A F4 00 00    0660*  	dl 0x0000F4 ; 106.875 4C, 0.957
04273D F3 00 00    0661*  	dl 0x0000F3 ; 108.281 4D, 0.950
042740 F1 00 00    0662*  	dl 0x0000F1 ; 109.688 4E, 0.942
042743 EE 00 00    0663*  	dl 0x0000EE ; 111.094 4F, 0.933
042746 EC 00 00    0664*  	dl 0x0000EC ; 112.500 50, 0.924
042749 EA 00 00    0665*  	dl 0x0000EA ; 113.906 51, 0.914
04274C E7 00 00    0666*  	dl 0x0000E7 ; 115.313 52, 0.904
04274F E4 00 00    0667*  	dl 0x0000E4 ; 116.719 53, 0.893
042752 E1 00 00    0668*  	dl 0x0000E1 ; 118.125 54, 0.882
042755 DE 00 00    0669*  	dl 0x0000DE ; 119.531 55, 0.870
042758 DB 00 00    0670*  	dl 0x0000DB ; 120.938 56, 0.858
04275B D8 00 00    0671*  	dl 0x0000D8 ; 122.344 57, 0.845
04275E D4 00 00    0672*  	dl 0x0000D4 ; 123.750 58, 0.831
042761 D1 00 00    0673*  	dl 0x0000D1 ; 125.156 59, 0.818
042764 CD 00 00    0674*  	dl 0x0000CD ; 126.563 5A, 0.803
042767 C9 00 00    0675*  	dl 0x0000C9 ; 127.969 5B, 0.788
04276A C5 00 00    0676*  	dl 0x0000C5 ; 129.375 5C, 0.773
04276D C1 00 00    0677*  	dl 0x0000C1 ; 130.781 5D, 0.757
042770 BD 00 00    0678*  	dl 0x0000BD ; 132.188 5E, 0.741
042773 B9 00 00    0679*  	dl 0x0000B9 ; 133.594 5F, 0.724
042776 B5 00 00    0680*  	dl 0x0000B5 ; 135.000 60, 0.707
042779 B0 00 00    0681*  	dl 0x0000B0 ; 136.406 61, 0.690
04277C AB 00 00    0682*  	dl 0x0000AB ; 137.813 62, 0.672
04277F A7 00 00    0683*  	dl 0x0000A7 ; 139.219 63, 0.653
042782 A2 00 00    0684*  	dl 0x0000A2 ; 140.625 64, 0.634
042785 9D 00 00    0685*  	dl 0x00009D ; 142.031 65, 0.615
042788 98 00 00    0686*  	dl 0x000098 ; 143.438 66, 0.596
04278B 93 00 00    0687*  	dl 0x000093 ; 144.844 67, 0.576
04278E 8E 00 00    0688*  	dl 0x00008E ; 146.250 68, 0.556
042791 88 00 00    0689*  	dl 0x000088 ; 147.656 69, 0.535
042794 83 00 00    0690*  	dl 0x000083 ; 149.063 6A, 0.514
042797 7E 00 00    0691*  	dl 0x00007E ; 150.469 6B, 0.493
04279A 78 00 00    0692*  	dl 0x000078 ; 151.875 6C, 0.471
04279D 73 00 00    0693*  	dl 0x000073 ; 153.281 6D, 0.450
0427A0 6D 00 00    0694*  	dl 0x00006D ; 154.688 6E, 0.428
0427A3 67 00 00    0695*  	dl 0x000067 ; 156.094 6F, 0.405
0427A6 61 00 00    0696*  	dl 0x000061 ; 157.500 70, 0.383
0427A9 5C 00 00    0697*  	dl 0x00005C ; 158.906 71, 0.360
0427AC 56 00 00    0698*  	dl 0x000056 ; 160.313 72, 0.337
0427AF 50 00 00    0699*  	dl 0x000050 ; 161.719 73, 0.314
0427B2 4A 00 00    0700*  	dl 0x00004A ; 163.125 74, 0.290
0427B5 44 00 00    0701*  	dl 0x000044 ; 164.531 75, 0.267
0427B8 3E 00 00    0702*  	dl 0x00003E ; 165.938 76, 0.243
0427BB 38 00 00    0703*  	dl 0x000038 ; 167.344 77, 0.219
0427BE 31 00 00    0704*  	dl 0x000031 ; 168.750 78, 0.195
0427C1 2B 00 00    0705*  	dl 0x00002B ; 170.156 79, 0.171
0427C4 25 00 00    0706*  	dl 0x000025 ; 171.563 7A, 0.147
0427C7 1F 00 00    0707*  	dl 0x00001F ; 172.969 7B, 0.122
0427CA 19 00 00    0708*  	dl 0x000019 ; 174.375 7C, 0.098
0427CD 12 00 00    0709*  	dl 0x000012 ; 175.781 7D, 0.074
0427D0 0C 00 00    0710*  	dl 0x00000C ; 177.188 7E, 0.049
0427D3 06 00 00    0711*  	dl 0x000006 ; 178.594 7F, 0.025
0427D6 00 00 00    0712*  	dl 0x000000 ; 180.000 80, 0.000
0427D9 FA FF FF    0713*  	dl 0xFFFFFA ; 181.406 81, -0.025
0427DC F4 FF FF    0714*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0427DF EE FF FF    0715*  	dl 0xFFFFEE ; 184.219 83, -0.074
0427E2 E7 FF FF    0716*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0427E5 E1 FF FF    0717*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0427E8 DB FF FF    0718*  	dl 0xFFFFDB ; 188.438 86, -0.147
0427EB D5 FF FF    0719*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0427EE CF FF FF    0720*  	dl 0xFFFFCF ; 191.250 88, -0.195
0427F1 C8 FF FF    0721*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0427F4 C2 FF FF    0722*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0427F7 BC FF FF    0723*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0427FA B6 FF FF    0724*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0427FD B0 FF FF    0725*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042800 AA FF FF    0726*  	dl 0xFFFFAA ; 199.688 8E, -0.337
042803 A4 FF FF    0727*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
042806 9F FF FF    0728*  	dl 0xFFFF9F ; 202.500 90, -0.383
042809 99 FF FF    0729*  	dl 0xFFFF99 ; 203.906 91, -0.405
04280C 93 FF FF    0730*  	dl 0xFFFF93 ; 205.313 92, -0.428
04280F 8D FF FF    0731*  	dl 0xFFFF8D ; 206.719 93, -0.450
042812 88 FF FF    0732*  	dl 0xFFFF88 ; 208.125 94, -0.471
042815 82 FF FF    0733*  	dl 0xFFFF82 ; 209.531 95, -0.493
042818 7D FF FF    0734*  	dl 0xFFFF7D ; 210.938 96, -0.514
04281B 78 FF FF    0735*  	dl 0xFFFF78 ; 212.344 97, -0.535
04281E 72 FF FF    0736*  	dl 0xFFFF72 ; 213.750 98, -0.556
042821 6D FF FF    0737*  	dl 0xFFFF6D ; 215.156 99, -0.576
042824 68 FF FF    0738*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042827 63 FF FF    0739*  	dl 0xFFFF63 ; 217.969 9B, -0.615
04282A 5E FF FF    0740*  	dl 0xFFFF5E ; 219.375 9C, -0.634
04282D 59 FF FF    0741*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042830 55 FF FF    0742*  	dl 0xFFFF55 ; 222.188 9E, -0.672
042833 50 FF FF    0743*  	dl 0xFFFF50 ; 223.594 9F, -0.690
042836 4B FF FF    0744*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042839 47 FF FF    0745*  	dl 0xFFFF47 ; 226.406 A1, -0.724
04283C 43 FF FF    0746*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04283F 3F FF FF    0747*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042842 3B FF FF    0748*  	dl 0xFFFF3B ; 230.625 A4, -0.773
042845 37 FF FF    0749*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042848 33 FF FF    0750*  	dl 0xFFFF33 ; 233.438 A6, -0.803
04284B 2F FF FF    0751*  	dl 0xFFFF2F ; 234.844 A7, -0.818
04284E 2C FF FF    0752*  	dl 0xFFFF2C ; 236.250 A8, -0.831
042851 28 FF FF    0753*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042854 25 FF FF    0754*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042857 22 FF FF    0755*  	dl 0xFFFF22 ; 240.469 AB, -0.870
04285A 1F FF FF    0756*  	dl 0xFFFF1F ; 241.875 AC, -0.882
04285D 1C FF FF    0757*  	dl 0xFFFF1C ; 243.281 AD, -0.893
042860 19 FF FF    0758*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042863 16 FF FF    0759*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042866 14 FF FF    0760*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042869 12 FF FF    0761*  	dl 0xFFFF12 ; 248.906 B1, -0.933
04286C 0F FF FF    0762*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04286F 0D FF FF    0763*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042872 0C FF FF    0764*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042875 0A FF FF    0765*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042878 08 FF FF    0766*  	dl 0xFFFF08 ; 255.938 B6, -0.970
04287B 07 FF FF    0767*  	dl 0xFFFF07 ; 257.344 B7, -0.976
04287E 05 FF FF    0768*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042881 04 FF FF    0769*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042884 03 FF FF    0770*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042887 02 FF FF    0771*  	dl 0xFFFF02 ; 262.969 BB, -0.992
04288A 02 FF FF    0772*  	dl 0xFFFF02 ; 264.375 BC, -0.995
04288D 01 FF FF    0773*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042890 01 FF FF    0774*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042893 01 FF FF    0775*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042896 00 FF FF    0776*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042899 01 FF FF    0777*  	dl 0xFFFF01 ; 271.406 C1, -1.000
04289C 01 FF FF    0778*  	dl 0xFFFF01 ; 272.813 C2, -0.999
04289F 01 FF FF    0779*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0428A2 02 FF FF    0780*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0428A5 02 FF FF    0781*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0428A8 03 FF FF    0782*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0428AB 04 FF FF    0783*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0428AE 05 FF FF    0784*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0428B1 07 FF FF    0785*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0428B4 08 FF FF    0786*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0428B7 0A FF FF    0787*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0428BA 0C FF FF    0788*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0428BD 0D FF FF    0789*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0428C0 0F FF FF    0790*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0428C3 12 FF FF    0791*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0428C6 14 FF FF    0792*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0428C9 16 FF FF    0793*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0428CC 19 FF FF    0794*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0428CF 1C FF FF    0795*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0428D2 1F FF FF    0796*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0428D5 22 FF FF    0797*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0428D8 25 FF FF    0798*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0428DB 28 FF FF    0799*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0428DE 2C FF FF    0800*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0428E1 2F FF FF    0801*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0428E4 33 FF FF    0802*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0428E7 37 FF FF    0803*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0428EA 3B FF FF    0804*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0428ED 3F FF FF    0805*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0428F0 43 FF FF    0806*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0428F3 47 FF FF    0807*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0428F6 4B FF FF    0808*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0428F9 50 FF FF    0809*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0428FC 55 FF FF    0810*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0428FF 59 FF FF    0811*  	dl 0xFFFF59 ; 319.219 E3, -0.653
042902 5E FF FF    0812*  	dl 0xFFFF5E ; 320.625 E4, -0.634
042905 63 FF FF    0813*  	dl 0xFFFF63 ; 322.031 E5, -0.615
042908 68 FF FF    0814*  	dl 0xFFFF68 ; 323.438 E6, -0.596
04290B 6D FF FF    0815*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04290E 72 FF FF    0816*  	dl 0xFFFF72 ; 326.250 E8, -0.556
042911 78 FF FF    0817*  	dl 0xFFFF78 ; 327.656 E9, -0.535
042914 7D FF FF    0818*  	dl 0xFFFF7D ; 329.063 EA, -0.514
042917 82 FF FF    0819*  	dl 0xFFFF82 ; 330.469 EB, -0.493
04291A 88 FF FF    0820*  	dl 0xFFFF88 ; 331.875 EC, -0.471
04291D 8D FF FF    0821*  	dl 0xFFFF8D ; 333.281 ED, -0.450
042920 93 FF FF    0822*  	dl 0xFFFF93 ; 334.688 EE, -0.428
042923 99 FF FF    0823*  	dl 0xFFFF99 ; 336.094 EF, -0.405
042926 9F FF FF    0824*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042929 A4 FF FF    0825*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
04292C AA FF FF    0826*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04292F B0 FF FF    0827*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042932 B6 FF FF    0828*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
042935 BC FF FF    0829*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042938 C2 FF FF    0830*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
04293B C8 FF FF    0831*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04293E CF FF FF    0832*  	dl 0xFFFFCF ; 348.750 F8, -0.195
042941 D5 FF FF    0833*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
042944 DB FF FF    0834*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042947 E1 FF FF    0835*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
04294A E7 FF FF    0836*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
04294D EE FF FF    0837*  	dl 0xFFFFEE ; 355.781 FD, -0.074
042950 F4 FF FF    0838*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042953 FA FF FF    0839*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042956 00 00 00    0840*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042959             0841*  
042959             0842*  atan_lut_168:
042959 00 00 00    0843*  	dl 0x000000 ; 000000, 0.000
04295C 28 00 00    0844*  	dl 0x000028 ; 000001, 0.224
04295F 51 00 00    0845*  	dl 0x000051 ; 000002, 0.448
042962 7A 00 00    0846*  	dl 0x00007A ; 000003, 0.671
042965 A2 00 00    0847*  	dl 0x0000A2 ; 000004, 0.895
042968 CB 00 00    0848*  	dl 0x0000CB ; 000005, 1.119
04296B F4 00 00    0849*  	dl 0x0000F4 ; 000006, 1.343
04296E 1D 01 00    0850*  	dl 0x00011D ; 000007, 1.566
042971 45 01 00    0851*  	dl 0x000145 ; 000008, 1.790
042974 6E 01 00    0852*  	dl 0x00016E ; 000009, 2.013
042977 97 01 00    0853*  	dl 0x000197 ; 00000A, 2.237
04297A BF 01 00    0854*  	dl 0x0001BF ; 00000B, 2.460
04297D E8 01 00    0855*  	dl 0x0001E8 ; 00000C, 2.684
042980 11 02 00    0856*  	dl 0x000211 ; 00000D, 2.907
042983 39 02 00    0857*  	dl 0x000239 ; 00000E, 3.130
042986 62 02 00    0858*  	dl 0x000262 ; 00000F, 3.353
042989 8B 02 00    0859*  	dl 0x00028B ; 000010, 3.576
04298C B3 02 00    0860*  	dl 0x0002B3 ; 000011, 3.799
04298F DC 02 00    0861*  	dl 0x0002DC ; 000012, 4.022
042992 04 03 00    0862*  	dl 0x000304 ; 000013, 4.245
042995 2D 03 00    0863*  	dl 0x00032D ; 000014, 4.467
042998 55 03 00    0864*  	dl 0x000355 ; 000015, 4.690
04299B 7E 03 00    0865*  	dl 0x00037E ; 000016, 4.912
04299E A6 03 00    0866*  	dl 0x0003A6 ; 000017, 5.134
0429A1 CE 03 00    0867*  	dl 0x0003CE ; 000018, 5.356
0429A4 F7 03 00    0868*  	dl 0x0003F7 ; 000019, 5.578
0429A7 1F 04 00    0869*  	dl 0x00041F ; 00001A, 5.799
0429AA 48 04 00    0870*  	dl 0x000448 ; 00001B, 6.021
0429AD 70 04 00    0871*  	dl 0x000470 ; 00001C, 6.242
0429B0 98 04 00    0872*  	dl 0x000498 ; 00001D, 6.463
0429B3 C0 04 00    0873*  	dl 0x0004C0 ; 00001E, 6.684
0429B6 E8 04 00    0874*  	dl 0x0004E8 ; 00001F, 6.905
0429B9 11 05 00    0875*  	dl 0x000511 ; 000020, 7.125
0429BC 39 05 00    0876*  	dl 0x000539 ; 000021, 7.345
0429BF 61 05 00    0877*  	dl 0x000561 ; 000022, 7.565
0429C2 89 05 00    0878*  	dl 0x000589 ; 000023, 7.785
0429C5 B1 05 00    0879*  	dl 0x0005B1 ; 000024, 8.005
0429C8 D9 05 00    0880*  	dl 0x0005D9 ; 000025, 8.224
0429CB 01 06 00    0881*  	dl 0x000601 ; 000026, 8.443
0429CE 28 06 00    0882*  	dl 0x000628 ; 000027, 8.662
0429D1 50 06 00    0883*  	dl 0x000650 ; 000028, 8.881
0429D4 78 06 00    0884*  	dl 0x000678 ; 000029, 9.099
0429D7 A0 06 00    0885*  	dl 0x0006A0 ; 00002A, 9.317
0429DA C7 06 00    0886*  	dl 0x0006C7 ; 00002B, 9.535
0429DD EF 06 00    0887*  	dl 0x0006EF ; 00002C, 9.752
0429E0 16 07 00    0888*  	dl 0x000716 ; 00002D, 9.970
0429E3 3E 07 00    0889*  	dl 0x00073E ; 00002E, 10.187
0429E6 65 07 00    0890*  	dl 0x000765 ; 00002F, 10.403
0429E9 8D 07 00    0891*  	dl 0x00078D ; 000030, 10.620
0429EC B4 07 00    0892*  	dl 0x0007B4 ; 000031, 10.836
0429EF DB 07 00    0893*  	dl 0x0007DB ; 000032, 11.051
0429F2 03 08 00    0894*  	dl 0x000803 ; 000033, 11.267
0429F5 2A 08 00    0895*  	dl 0x00082A ; 000034, 11.482
0429F8 51 08 00    0896*  	dl 0x000851 ; 000035, 11.697
0429FB 78 08 00    0897*  	dl 0x000878 ; 000036, 11.911
0429FE 9F 08 00    0898*  	dl 0x00089F ; 000037, 12.125
042A01 C6 08 00    0899*  	dl 0x0008C6 ; 000038, 12.339
042A04 ED 08 00    0900*  	dl 0x0008ED ; 000039, 12.553
042A07 13 09 00    0901*  	dl 0x000913 ; 00003A, 12.766
042A0A 3A 09 00    0902*  	dl 0x00093A ; 00003B, 12.978
042A0D 61 09 00    0903*  	dl 0x000961 ; 00003C, 13.191
042A10 87 09 00    0904*  	dl 0x000987 ; 00003D, 13.403
042A13 AE 09 00    0905*  	dl 0x0009AE ; 00003E, 13.614
042A16 D4 09 00    0906*  	dl 0x0009D4 ; 00003F, 13.825
042A19 FB 09 00    0907*  	dl 0x0009FB ; 000040, 14.036
042A1C 21 0A 00    0908*  	dl 0x000A21 ; 000041, 14.247
042A1F 47 0A 00    0909*  	dl 0x000A47 ; 000042, 14.457
042A22 6D 0A 00    0910*  	dl 0x000A6D ; 000043, 14.666
042A25 94 0A 00    0911*  	dl 0x000A94 ; 000044, 14.876
042A28 BA 0A 00    0912*  	dl 0x000ABA ; 000045, 15.085
042A2B E0 0A 00    0913*  	dl 0x000AE0 ; 000046, 15.293
042A2E 05 0B 00    0914*  	dl 0x000B05 ; 000047, 15.501
042A31 2B 0B 00    0915*  	dl 0x000B2B ; 000048, 15.709
042A34 51 0B 00    0916*  	dl 0x000B51 ; 000049, 15.916
042A37 77 0B 00    0917*  	dl 0x000B77 ; 00004A, 16.123
042A3A 9C 0B 00    0918*  	dl 0x000B9C ; 00004B, 16.329
042A3D C2 0B 00    0919*  	dl 0x000BC2 ; 00004C, 16.535
042A40 E7 0B 00    0920*  	dl 0x000BE7 ; 00004D, 16.740
042A43 0C 0C 00    0921*  	dl 0x000C0C ; 00004E, 16.945
042A46 32 0C 00    0922*  	dl 0x000C32 ; 00004F, 17.150
042A49 57 0C 00    0923*  	dl 0x000C57 ; 000050, 17.354
042A4C 7C 0C 00    0924*  	dl 0x000C7C ; 000051, 17.558
042A4F A1 0C 00    0925*  	dl 0x000CA1 ; 000052, 17.761
042A52 C6 0C 00    0926*  	dl 0x000CC6 ; 000053, 17.964
042A55 EB 0C 00    0927*  	dl 0x000CEB ; 000054, 18.166
042A58 0F 0D 00    0928*  	dl 0x000D0F ; 000055, 18.368
042A5B 34 0D 00    0929*  	dl 0x000D34 ; 000056, 18.569
042A5E 58 0D 00    0930*  	dl 0x000D58 ; 000057, 18.770
042A61 7D 0D 00    0931*  	dl 0x000D7D ; 000058, 18.970
042A64 A1 0D 00    0932*  	dl 0x000DA1 ; 000059, 19.170
042A67 C6 0D 00    0933*  	dl 0x000DC6 ; 00005A, 19.370
042A6A EA 0D 00    0934*  	dl 0x000DEA ; 00005B, 19.569
042A6D 0E 0E 00    0935*  	dl 0x000E0E ; 00005C, 19.767
042A70 32 0E 00    0936*  	dl 0x000E32 ; 00005D, 19.965
042A73 56 0E 00    0937*  	dl 0x000E56 ; 00005E, 20.163
042A76 7A 0E 00    0938*  	dl 0x000E7A ; 00005F, 20.360
042A79 9E 0E 00    0939*  	dl 0x000E9E ; 000060, 20.556
042A7C C1 0E 00    0940*  	dl 0x000EC1 ; 000061, 20.752
042A7F E5 0E 00    0941*  	dl 0x000EE5 ; 000062, 20.947
042A82 08 0F 00    0942*  	dl 0x000F08 ; 000063, 21.142
042A85 2C 0F 00    0943*  	dl 0x000F2C ; 000064, 21.337
042A88 4F 0F 00    0944*  	dl 0x000F4F ; 000065, 21.531
042A8B 72 0F 00    0945*  	dl 0x000F72 ; 000066, 21.724
042A8E 95 0F 00    0946*  	dl 0x000F95 ; 000067, 21.917
042A91 B8 0F 00    0947*  	dl 0x000FB8 ; 000068, 22.109
042A94 DB 0F 00    0948*  	dl 0x000FDB ; 000069, 22.301
042A97 FE 0F 00    0949*  	dl 0x000FFE ; 00006A, 22.493
042A9A 21 10 00    0950*  	dl 0x001021 ; 00006B, 22.683
042A9D 44 10 00    0951*  	dl 0x001044 ; 00006C, 22.874
042AA0 66 10 00    0952*  	dl 0x001066 ; 00006D, 23.063
042AA3 89 10 00    0953*  	dl 0x001089 ; 00006E, 23.253
042AA6 AB 10 00    0954*  	dl 0x0010AB ; 00006F, 23.441
042AA9 CD 10 00    0955*  	dl 0x0010CD ; 000070, 23.629
042AAC EF 10 00    0956*  	dl 0x0010EF ; 000071, 23.817
042AAF 11 11 00    0957*  	dl 0x001111 ; 000072, 24.004
042AB2 33 11 00    0958*  	dl 0x001133 ; 000073, 24.191
042AB5 55 11 00    0959*  	dl 0x001155 ; 000074, 24.376
042AB8 77 11 00    0960*  	dl 0x001177 ; 000075, 24.562
042ABB 99 11 00    0961*  	dl 0x001199 ; 000076, 24.747
042ABE BA 11 00    0962*  	dl 0x0011BA ; 000077, 24.931
042AC1 DC 11 00    0963*  	dl 0x0011DC ; 000078, 25.115
042AC4 FD 11 00    0964*  	dl 0x0011FD ; 000079, 25.298
042AC7 1E 12 00    0965*  	dl 0x00121E ; 00007A, 25.481
042ACA 3F 12 00    0966*  	dl 0x00123F ; 00007B, 25.663
042ACD 60 12 00    0967*  	dl 0x001260 ; 00007C, 25.844
042AD0 81 12 00    0968*  	dl 0x001281 ; 00007D, 26.025
042AD3 A2 12 00    0969*  	dl 0x0012A2 ; 00007E, 26.206
042AD6 C3 12 00    0970*  	dl 0x0012C3 ; 00007F, 26.386
042AD9 E4 12 00    0971*  	dl 0x0012E4 ; 000080, 26.565
042ADC 04 13 00    0972*  	dl 0x001304 ; 000081, 26.744
042ADF 25 13 00    0973*  	dl 0x001325 ; 000082, 26.922
042AE2 45 13 00    0974*  	dl 0x001345 ; 000083, 27.100
042AE5 65 13 00    0975*  	dl 0x001365 ; 000084, 27.277
042AE8 85 13 00    0976*  	dl 0x001385 ; 000085, 27.453
042AEB A5 13 00    0977*  	dl 0x0013A5 ; 000086, 27.629
042AEE C5 13 00    0978*  	dl 0x0013C5 ; 000087, 27.805
042AF1 E5 13 00    0979*  	dl 0x0013E5 ; 000088, 27.979
042AF4 05 14 00    0980*  	dl 0x001405 ; 000089, 28.154
042AF7 24 14 00    0981*  	dl 0x001424 ; 00008A, 28.327
042AFA 44 14 00    0982*  	dl 0x001444 ; 00008B, 28.501
042AFD 63 14 00    0983*  	dl 0x001463 ; 00008C, 28.673
042B00 83 14 00    0984*  	dl 0x001483 ; 00008D, 28.845
042B03 A2 14 00    0985*  	dl 0x0014A2 ; 00008E, 29.017
042B06 C1 14 00    0986*  	dl 0x0014C1 ; 00008F, 29.187
042B09 E0 14 00    0987*  	dl 0x0014E0 ; 000090, 29.358
042B0C FF 14 00    0988*  	dl 0x0014FF ; 000091, 29.527
042B0F 1E 15 00    0989*  	dl 0x00151E ; 000092, 29.697
042B12 3C 15 00    0990*  	dl 0x00153C ; 000093, 29.865
042B15 5B 15 00    0991*  	dl 0x00155B ; 000094, 30.033
042B18 79 15 00    0992*  	dl 0x001579 ; 000095, 30.201
042B1B 98 15 00    0993*  	dl 0x001598 ; 000096, 30.368
042B1E B6 15 00    0994*  	dl 0x0015B6 ; 000097, 30.534
042B21 D4 15 00    0995*  	dl 0x0015D4 ; 000098, 30.700
042B24 F2 15 00    0996*  	dl 0x0015F2 ; 000099, 30.865
042B27 10 16 00    0997*  	dl 0x001610 ; 00009A, 31.030
042B2A 2E 16 00    0998*  	dl 0x00162E ; 00009B, 31.194
042B2D 4C 16 00    0999*  	dl 0x00164C ; 00009C, 31.357
042B30 6A 16 00    1000*  	dl 0x00166A ; 00009D, 31.520
042B33 87 16 00    1001*  	dl 0x001687 ; 00009E, 31.682
042B36 A5 16 00    1002*  	dl 0x0016A5 ; 00009F, 31.844
042B39 C2 16 00    1003*  	dl 0x0016C2 ; 0000A0, 32.005
042B3C DF 16 00    1004*  	dl 0x0016DF ; 0000A1, 32.166
042B3F FC 16 00    1005*  	dl 0x0016FC ; 0000A2, 32.326
042B42 19 17 00    1006*  	dl 0x001719 ; 0000A3, 32.486
042B45 36 17 00    1007*  	dl 0x001736 ; 0000A4, 32.645
042B48 53 17 00    1008*  	dl 0x001753 ; 0000A5, 32.803
042B4B 70 17 00    1009*  	dl 0x001770 ; 0000A6, 32.961
042B4E 8C 17 00    1010*  	dl 0x00178C ; 0000A7, 33.118
042B51 A9 17 00    1011*  	dl 0x0017A9 ; 0000A8, 33.275
042B54 C5 17 00    1012*  	dl 0x0017C5 ; 0000A9, 33.431
042B57 E2 17 00    1013*  	dl 0x0017E2 ; 0000AA, 33.587
042B5A FE 17 00    1014*  	dl 0x0017FE ; 0000AB, 33.742
042B5D 1A 18 00    1015*  	dl 0x00181A ; 0000AC, 33.896
042B60 36 18 00    1016*  	dl 0x001836 ; 0000AD, 34.050
042B63 52 18 00    1017*  	dl 0x001852 ; 0000AE, 34.203
042B66 6E 18 00    1018*  	dl 0x00186E ; 0000AF, 34.356
042B69 8A 18 00    1019*  	dl 0x00188A ; 0000B0, 34.509
042B6C A5 18 00    1020*  	dl 0x0018A5 ; 0000B1, 34.660
042B6F C1 18 00    1021*  	dl 0x0018C1 ; 0000B2, 34.811
042B72 DC 18 00    1022*  	dl 0x0018DC ; 0000B3, 34.962
042B75 F7 18 00    1023*  	dl 0x0018F7 ; 0000B4, 35.112
042B78 13 19 00    1024*  	dl 0x001913 ; 0000B5, 35.262
042B7B 2E 19 00    1025*  	dl 0x00192E ; 0000B6, 35.410
042B7E 49 19 00    1026*  	dl 0x001949 ; 0000B7, 35.559
042B81 64 19 00    1027*  	dl 0x001964 ; 0000B8, 35.707
042B84 7F 19 00    1028*  	dl 0x00197F ; 0000B9, 35.854
042B87 99 19 00    1029*  	dl 0x001999 ; 0000BA, 36.001
042B8A B4 19 00    1030*  	dl 0x0019B4 ; 0000BB, 36.147
042B8D CE 19 00    1031*  	dl 0x0019CE ; 0000BC, 36.293
042B90 E9 19 00    1032*  	dl 0x0019E9 ; 0000BD, 36.438
042B93 03 1A 00    1033*  	dl 0x001A03 ; 0000BE, 36.582
042B96 1D 1A 00    1034*  	dl 0x001A1D ; 0000BF, 36.726
042B99 37 1A 00    1035*  	dl 0x001A37 ; 0000C0, 36.870
042B9C 51 1A 00    1036*  	dl 0x001A51 ; 0000C1, 37.013
042B9F 6B 1A 00    1037*  	dl 0x001A6B ; 0000C2, 37.155
042BA2 85 1A 00    1038*  	dl 0x001A85 ; 0000C3, 37.297
042BA5 9F 1A 00    1039*  	dl 0x001A9F ; 0000C4, 37.439
042BA8 B9 1A 00    1040*  	dl 0x001AB9 ; 0000C5, 37.579
042BAB D2 1A 00    1041*  	dl 0x001AD2 ; 0000C6, 37.720
042BAE EC 1A 00    1042*  	dl 0x001AEC ; 0000C7, 37.859
042BB1 05 1B 00    1043*  	dl 0x001B05 ; 0000C8, 37.999
042BB4 1E 1B 00    1044*  	dl 0x001B1E ; 0000C9, 38.137
042BB7 37 1B 00    1045*  	dl 0x001B37 ; 0000CA, 38.276
042BBA 50 1B 00    1046*  	dl 0x001B50 ; 0000CB, 38.413
042BBD 69 1B 00    1047*  	dl 0x001B69 ; 0000CC, 38.550
042BC0 82 1B 00    1048*  	dl 0x001B82 ; 0000CD, 38.687
042BC3 9B 1B 00    1049*  	dl 0x001B9B ; 0000CE, 38.823
042BC6 B4 1B 00    1050*  	dl 0x001BB4 ; 0000CF, 38.959
042BC9 CC 1B 00    1051*  	dl 0x001BCC ; 0000D0, 39.094
042BCC E5 1B 00    1052*  	dl 0x001BE5 ; 0000D1, 39.228
042BCF FD 1B 00    1053*  	dl 0x001BFD ; 0000D2, 39.362
042BD2 16 1C 00    1054*  	dl 0x001C16 ; 0000D3, 39.496
042BD5 2E 1C 00    1055*  	dl 0x001C2E ; 0000D4, 39.629
042BD8 46 1C 00    1056*  	dl 0x001C46 ; 0000D5, 39.762
042BDB 5E 1C 00    1057*  	dl 0x001C5E ; 0000D6, 39.894
042BDE 76 1C 00    1058*  	dl 0x001C76 ; 0000D7, 40.025
042BE1 8E 1C 00    1059*  	dl 0x001C8E ; 0000D8, 40.156
042BE4 A5 1C 00    1060*  	dl 0x001CA5 ; 0000D9, 40.286
042BE7 BD 1C 00    1061*  	dl 0x001CBD ; 0000DA, 40.416
042BEA D5 1C 00    1062*  	dl 0x001CD5 ; 0000DB, 40.546
042BED EC 1C 00    1063*  	dl 0x001CEC ; 0000DC, 40.675
042BF0 04 1D 00    1064*  	dl 0x001D04 ; 0000DD, 40.803
042BF3 1B 1D 00    1065*  	dl 0x001D1B ; 0000DE, 40.931
042BF6 32 1D 00    1066*  	dl 0x001D32 ; 0000DF, 41.059
042BF9 49 1D 00    1067*  	dl 0x001D49 ; 0000E0, 41.186
042BFC 60 1D 00    1068*  	dl 0x001D60 ; 0000E1, 41.312
042BFF 77 1D 00    1069*  	dl 0x001D77 ; 0000E2, 41.438
042C02 8E 1D 00    1070*  	dl 0x001D8E ; 0000E3, 41.564
042C05 A5 1D 00    1071*  	dl 0x001DA5 ; 0000E4, 41.689
042C08 BB 1D 00    1072*  	dl 0x001DBB ; 0000E5, 41.814
042C0B D2 1D 00    1073*  	dl 0x001DD2 ; 0000E6, 41.938
042C0E E9 1D 00    1074*  	dl 0x001DE9 ; 0000E7, 42.061
042C11 FF 1D 00    1075*  	dl 0x001DFF ; 0000E8, 42.184
042C14 15 1E 00    1076*  	dl 0x001E15 ; 0000E9, 42.307
042C17 2C 1E 00    1077*  	dl 0x001E2C ; 0000EA, 42.429
042C1A 42 1E 00    1078*  	dl 0x001E42 ; 0000EB, 42.551
042C1D 58 1E 00    1079*  	dl 0x001E58 ; 0000EC, 42.672
042C20 6E 1E 00    1080*  	dl 0x001E6E ; 0000ED, 42.793
042C23 84 1E 00    1081*  	dl 0x001E84 ; 0000EE, 42.913
042C26 99 1E 00    1082*  	dl 0x001E99 ; 0000EF, 43.033
042C29 AF 1E 00    1083*  	dl 0x001EAF ; 0000F0, 43.152
042C2C C5 1E 00    1084*  	dl 0x001EC5 ; 0000F1, 43.271
042C2F DA 1E 00    1085*  	dl 0x001EDA ; 0000F2, 43.390
042C32 F0 1E 00    1086*  	dl 0x001EF0 ; 0000F3, 43.508
042C35 05 1F 00    1087*  	dl 0x001F05 ; 0000F4, 43.625
042C38 1B 1F 00    1088*  	dl 0x001F1B ; 0000F5, 43.742
042C3B 30 1F 00    1089*  	dl 0x001F30 ; 0000F6, 43.859
042C3E 45 1F 00    1090*  	dl 0x001F45 ; 0000F7, 43.975
042C41 5A 1F 00    1091*  	dl 0x001F5A ; 0000F8, 44.091
042C44 6F 1F 00    1092*  	dl 0x001F6F ; 0000F9, 44.206
042C47 84 1F 00    1093*  	dl 0x001F84 ; 0000FA, 44.321
042C4A 99 1F 00    1094*  	dl 0x001F99 ; 0000FB, 44.435
042C4D AD 1F 00    1095*  	dl 0x001FAD ; 0000FC, 44.549
042C50 C2 1F 00    1096*  	dl 0x001FC2 ; 0000FD, 44.662
042C53 D7 1F 00    1097*  	dl 0x001FD7 ; 0000FE, 44.775
042C56 EB 1F 00    1098*  	dl 0x001FEB ; 0000FF, 44.888
042C59 00 20 00    1099*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042C5C             0060   	include "fixed24.inc"
042C5C             0001*  arith24uaf: ds 6
042C62             0002*  arith24uhl: ds 6
042C68             0003*  arith24ubc: ds 6
042C6E             0004*  arith24ude: ds 6
042C74             0005*  arith24uix: ds 6
042C7A             0006*  arith24uiy: ds 6
042C80             0007*  arith24usp: ds 6
042C86             0008*  arith24upc: ds 6
042C8C             0009*  
042C8C             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042C8C             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042C8C             0012*  ; inputs: hlu = 24-bit number to shift
042C8C             0013*  ;         a = signed number of bits to shift
042C8C             0014*  ;         ix = output buffer address
042C8C             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042C8C             0016*  shift_hlu:
042C8C C5          0017*      push bc ; preserve
042C8D 47          0018*      ld b,a            ; store shift value in b for later
042C8E             0019*  
042C8E             0020*  ; Initialize DE to zero and clear output buffer
042C8E 11 00 00 00 0021*      ld de, 0
042C92 DD 1F FD    0022*      ld (ix-3), de
042C95 DD 1F 03    0023*      ld (ix+3), de
042C98             0024*  
042C98             0025*  ; Get absolute value of a and save its original sign
042C98 B7          0026*      or a
042C99 F5          0027*      push af ; save sign flag
042C9A F2 A0 2C 04 0028*      jp p,@F ; If a is positive do nothing
042C9E ED 44       0029*      neg ; If a is negative, negate it
042CA0             0030*  @@:
042CA0             0031*  
042CA0             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042CA0 CD F4 22 04 0033*      call hlu_abs
042CA4 F5          0034*      push af ; save sign of HLU
042CA5 DD 2F 00    0035*      ld (ix), hl
042CA8             0036*  
042CA8             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042CA8 78          0038*      ld a,b            ; Restore original shift value into 'a'
042CA9 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042CAB CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042CAD CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042CAF 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042CB0             0043*  
042CB0             0044*  ; Calculate remainder of a (original shift) mod 8
042CB0 E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042CB2 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042CB3 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042CB7             0048*  
042CB7             0049*  ; Get back the original sign of the byte shift
042CB7 F1          0050*      pop af            ; Restore sign flag
042CB8 F2 C6 2C 04 0051*      jp p,@F           ; If a was positive, we're done
042CBC 79          0052*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042CBD ED 44       0053*      neg               ; Negate the number of whole bytes to shift
042CBF 3D          0054*      dec a             ; Subtract 1 because that's just how this works
042CC0 4F          0055*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042CC1 1B          0056*      dec de            ; DE = -1 to make the signed addition below work
042CC2 3E 08       0057*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042CC4 90          0058*      sub b
042CC5 47          0059*      ld b,a            ; b is the number of bits to shift back up
042CC6             0060*  
042CC6             0061*  @@:
042CC6             0062*  
042CC6             0063*  ; Add the byte offset to the base address of output buffer
042CC6 59          0064*      ld e,c            ; DEU and D were properly signed above
042CC7 DD 19       0065*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042CC9             0066*  
042CC9             0067*  ; Read the byte-aligned result into HL and shift in the required number of bits
042CC9 DD 27 00    0068*      ld hl,(ix)        ; Byte-aligned result
042CCC             0069*  
042CCC             0070*  ; Check whether we're already byte-aligned
042CCC AF          0071*      xor a
042CCD B0          0072*      or b
042CCE 28 08       0073*      jr z,@end         ; If no bits to shift, we're done
042CD0             0074*  
042CD0             0075*  ; Otherwise shiften zee bitzen
042CD0 DD 7E FF    0076*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042CD3             0077*  @loop:
042CD3 07          0078*      rlca              ; One bit to carry
042CD4             0079*  
042CD4 ED 6A       0080*      adc hl,hl         ; Shift the carry into the result
042CD6             0081*  
042CD6 10 FB       0082*      djnz @loop        ; Loop until all bits are shifted up
042CD8             0083*  
042CD8             0084*  @end:
042CD8             0085*  
042CD8             0086*  ; get back HLU's original sign and negate if necessary
042CD8 F1          0087*      pop af
042CD9 F2 E1 2C 04 0088*      jp p,@F
042CDD CD 04 23 04 0089*      call neg_hlu
042CE1             0090*  @@:
042CE1             0091*  ; return the result
042CE1 DD 2F 00    0092*      ld (ix),hl        ; Store the shifted result
042CE4 C1          0093*      pop bc              ; Restore BC
042CE5 C9          0094*      ret
042CE6             0095*  
042CE6             0096*  ; operation: UHL * UDE --> UHL
042CE6             0097*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042CE6             0098*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042CE6             0099*  ; inputs: hl = 24-bit number, de = 24-bit number,
042CE6             0100*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042CE6             0101*  ; outputs: umulfxout = 48-bit intermediate
042CE6             0102*  ; destroys: af, hl, bc, de
042CE6             0103*  umulfx:
042CE6 DD E5       0104*      push ix ; preserve
042CE8 F5          0105*      push af ; need later
042CE9             0106*  
042CE9             0107*  ; do the multiplication
042CE9 CD A0 2D 04 0108*      call umul24x24
042CED             0109*  
042CED             0110*  ; shift the result to the required output precision
042CED 78          0111*      ld a,b
042CEE 81          0112*      add a,c ; a is left shift from the multiplication
042CEF C1          0113*      pop bc ; b is the output precision (was a)
042CF0 90          0114*      sub b ; a is the net shift of the output
042CF1             0115*  
042CF1             0116*  ; Get absolute value of a and save its original sign
042CF1 B7          0117*      or a
042CF2 F5          0118*      push af ; save sign flag
042CF3 F2 F9 2C 04 0119*      jp p,@F ; If a is positive do nothing
042CF7 ED 44       0120*      neg ; If a is negative, negate it
042CF9             0121*  @@:
042CF9             0122*  
042CF9             0123*  ; Divide a by 8 to get the whole byte shift and bit remainder
042CF9 47          0124*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042CFA CB 3F       0125*      srl a             ; a = a / 2 (shift right 1 bit)
042CFC CB 3F       0126*      srl a             ; a = a / 4 (shift right another bit)
042CFE CB 3F       0127*      srl a             ; a = a / 8 (final shift for division by 8)
042D00 4F          0128*      ld c,a            ; c holds the number of whole bytes to shift
042D01             0129*  
042D01             0130*  ; Calculate remainder of a (original shift) mod 8
042D01 78          0131*      ld a,b            ; Restore original shift value into 'a'
042D02 E6 07       0132*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042D04 47          0133*      ld b,a            ; 'b' now holds the number of bits to shift back up
042D05 11 00 00 00 0134*      ld de,0           ; Clear deu for computing the offset address later
042D09             0135*  
042D09             0136*  ; Get back the original sign of the byte shift
042D09 F1          0137*      pop af            ; Restore sign flag
042D0A F2 18 2D 04 0138*      jp p,@F           ; If a was positive, we're done
042D0E 79          0139*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042D0F ED 44       0140*      neg               ; Negate the number of whole bytes to shift
042D11 3D          0141*      dec a             ; Subtract 1 because that's just how this works
042D12 4F          0142*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042D13 1B          0143*      dec de            ; DE = -1 to make the signed addition below work
042D14 3E 08       0144*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042D16 90          0145*      sub b
042D17 47          0146*      ld b,a            ; b is the number of bits to shift back up
042D18             0147*  
042D18             0148*  @@:
042D18             0149*  
042D18             0150*  ; Add the byte offset to the base address of umulfxout
042D18 59          0151*      ld e,c            ; DEU and D were properly signed above
042D19 DD 21 35 2D 0152*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042D1E DD 19       0153*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042D20             0154*  
042D20             0155*  ; Read the byte-aligned result into HL and shift in the required number of bits
042D20 DD 27 00    0156*      ld hl,(ix)        ; Byte-aligned result
042D23 DD 7E FF    0157*      ld a,(ix-1)       ; One byte below
042D26             0158*  
042D26             0159*  ; Check whether we're already byte-aligned
042D26 AF          0160*      xor a
042D27 B0          0161*      or b
042D28 28 05       0162*      jr z,@end         ; If no bits to shift, we're done
042D2A             0163*  
042D2A             0164*  ; Otherwise shiften zee bitzen
042D2A             0165*  @loop:
042D2A             0166*  
042D2A 07          0167*      rlca              ; One bit to carry
042D2B ED 6A       0168*      adc hl,hl         ; Shift the carry into the result
042D2D             0169*  
042D2D 10 FB       0170*      djnz @loop        ; Loop until all bits are shifted up
042D2F             0171*  
042D2F             0172*  @end:
042D2F             0173*  ; return the result
042D2F DD E1       0174*      pop ix ; restore
042D31 C9          0175*      ret
042D32             0176*  
042D32 00 00 00    0177*      dl 0 ; padding
042D35 00 00 00 00 0178*  umulfxout: blkb 6,0
       00 00       
042D3B 00 00 00    0179*      dl 0 ; padding
042D3E             0180*  
042D3E             0181*  ; operation: UHL * UDE --> UHL
042D3E             0182*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042D3E             0183*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042D3E             0184*  ; inputs: hl = 24-bit number, de = 24-bit number,
042D3E             0185*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042D3E             0186*  ; outputs: umulfxout = 48-bit intermediate
042D3E             0187*  ; destroys: af, hl, bc, de
042D3E             0188*  smulfx:
042D3E             0189*  ; make everything positive and store sign flags
042D3E CD F4 22 04 0190*  	call hlu_abs
042D42 F5          0191*  	push af
042D43 EB          0192*  	ex de,hl
042D44 CD F4 22 04 0193*  	call hlu_abs
042D48 EB          0194*  	ex de,hl
042D49 F5          0195*  	push af
042D4A             0196*  ; do the division
042D4A CD E6 2C 04 0197*      call umulfx ; hl = product
042D4E             0198*  ; adjust sign of result
042D4E F1          0199*  	pop af ; sign de
042D4F FA 5A 2D 04 0200*  	jp m,@de_neg
042D53 F1          0201*  	pop af ; sign hl
042D54 F0          0202*  	ret p ; both positive, nothing to do
042D55             0203*  @hl_neg:
042D55 CD 04 23 04 0204*      call neg_hlu ; de pos, hl neg, result is negative
042D59 C9          0205*      ret
042D5A             0206*  @de_neg:
042D5A F1          0207*  	pop af
042D5B F8          0208*  	ret m ; both negative, nothing to do
042D5C CD 04 23 04 0209*  	call neg_hlu ; result is negative
042D60 C9          0210*  	ret
042D61             0211*  
042D61             0212*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042D61             0213*  ; uses EZ80 MLT instruction for speed
042D61             0214*  ; operation: UHL * A --> UHL
042D61             0215*  ; destroys: AF, HL
042D61             0216*  smul24x8:
042D61             0217*  ; make hl positive and store sign flag
042D61 CD F4 22 04 0218*  	call hlu_abs
042D65 F5          0219*  	push af
042D66             0220*  ; do the division
042D66 CD 71 2D 04 0221*      call umul24x8 ; hl = product
042D6A             0222*  ; adjust sign of result
042D6A F1          0223*  	pop af ; sign de
042D6B F0          0224*  	ret p ; hl was positive, nothing to do
042D6C CD 04 23 04 0225*  	call neg_hlu ; result is negative
042D70 C9          0226*  	ret
042D71             0227*  
042D71             0228*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042D71             0229*  ; uses EZ80 MLT instruction for speed
042D71             0230*  ; operation: UHL * A --> AUHL
042D71             0231*  ; destroys: AF, HL
042D71             0232*  umul24x8:
042D71 D5          0233*  	push de ; preserve de
042D72             0234*  ; low byte
042D72 5D          0235*  	ld e,l
042D73 57          0236*  	ld d,a
042D74 ED 5C       0237*  	mlt de
042D76 6B          0238*  	ld l,e ; product low byte
042D77 08          0239*  	ex af,af' ; save multiplier
042D78 7A          0240*  	ld a,d ; carry
042D79 08          0241*  	ex af,af' ; save carry, restore multiplier
042D7A             0242*  ; high byte
042D7A 5C          0243*  	ld e,h
042D7B 57          0244*  	ld d,a
042D7C ED 5C       0245*  	mlt de
042D7E 08          0246*  	ex af,af' ; save multiplier, restore carry
042D7F 83          0247*  	add a,e ; add carry
042D80 67          0248*  	ld h,a ; product middle byte
042D81 7A          0249*  	ld a,d ; carry
042D82 08          0250*  	ex af,af' ; save carry, restore multiplier
042D83             0251*  ; upper byte
042D83 E5          0252*  	push hl
042D84 33          0253*  	inc sp
042D85 D1          0254*  	pop de ; d = hlu
042D86 3B          0255*  	dec sp
042D87 5F          0256*  	ld e,a
042D88 ED 5C       0257*  	mlt de
042D8A 08          0258*  	ex af,af' ; restore carry
042D8B 8B          0259*  	adc a,e ; add carry
042D8C 22 9D 2D 04 0260*      ld (@scratch),hl ; 7 cycles
042D90 32 9F 2D 04 0261*      ld (@scratch+2),a ; 5 cycles
042D94 2A 9D 2D 04 0262*      ld hl,(@scratch) ; 7 cycles
042D98             0263*  ; highest byte
042D98 3E 00       0264*  	ld a,0 ; preserve carry flag
042D9A 8A          0265*  	adc a,d ; product highest byte
042D9B D1          0266*  	pop de ; restore de
042D9C C9          0267*  	ret
042D9D             0268*  @scratch: ds 3
042DA0             0269*  
042DA0             0270*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042DA0             0271*  ; operation: UHL * UDE --> umulfxout
042DA0             0272*  umul24x24:
042DA0 FD 21 35 2D 0273*  	ld iy,umulfxout ; point to output buffer
       04          
042DA5 C5          0274*  	push bc
042DA6 01 00 00 00 0275*  	ld bc,0
042DAA FD 0F 00    0276*  	ld (iy),bc
042DAD FD 0F 03    0277*  	ld (iy+3),bc
042DB0 C1          0278*  	pop bc
042DB1             0279*  
042DB1             0280*  ; STEP 1: UHL * E
042DB1 7B          0281*  	ld a,e
042DB2 E5          0282*  	push hl
042DB3 CD 71 2D 04 0283*  	call umul24x8
042DB7 FD 2F 00    0284*  	ld (iy+0),hl
042DBA FD 77 03    0285*  	ld (iy+3),a
042DBD             0286*  
042DBD             0287*  ; STEP 2: UHL * D
042DBD E1          0288*  	pop hl
042DBE E5          0289*  	push hl
042DBF 7A          0290*  	ld a,d
042DC0 CD 71 2D 04 0291*  	call umul24x8
042DC4 CD D1 2D 04 0292*  	call @accumulate
042DC8             0293*  
042DC8             0294*  ; STEP 3: UHL * DEU
042DC8 E1          0295*  	pop hl
042DC9 D5          0296*  	push de
042DCA 33          0297*  	inc sp
042DCB F1          0298*  	pop af
042DCC 3B          0299*  	dec sp
042DCD CD 71 2D 04 0300*  	call umul24x8
042DD1             0301*  
042DD1             0302*  @accumulate:
042DD1 FD 23       0303*  	inc iy
042DD3             0304*  ; highest byte of product to carry
042DD3 FD 77 03    0305*  	ld (iy+3),a
042DD6             0306*  ; low byte of product
042DD6 7D          0307*  	ld a,l
042DD7 FD 86 00    0308*  	add a,(iy+0)
042DDA FD 77 00    0309*  	ld (iy+0),a
042DDD             0310*  ; high byte of product
042DDD 7C          0311*  	ld a,h
042DDE FD 8E 01    0312*  	adc a,(iy+1)
042DE1 FD 77 01    0313*  	ld (iy+1),a
042DE4             0314*  ; uppper byte of product
042DE4 E5          0315*  	push hl
042DE5 33          0316*  	inc sp
042DE6 E1          0317*  	pop hl
042DE7 3B          0318*  	dec sp
042DE8 7C          0319*  	ld a,h
042DE9 FD 8E 02    0320*  	adc a,(iy+2)
042DEC FD 77 02    0321*  	ld (iy+2),a
042DEF             0322*  ; carry
042DEF 3E 00       0323*  	ld a,0 ; preserve flags
042DF1 FD 8E 03    0324*  	adc a,(iy+3)
042DF4 FD 77 03    0325*  	ld (iy+3),a
042DF7 C9          0326*  	ret
042DF8             0327*  
042DF8             0328*  ; UH.L = UH.L*UD.E (unsigned)
042DF8             0329*  umul168:
042DF8 CD A0 2D 04 0330*  	call umul24x24
042DFC FD 27 FF    0331*  	ld hl,(iy-1)
042DFF C9          0332*  	ret
042E00             0333*  
042E00             0334*  ; UH.L * UD.E --> UH.L (signed)
042E00             0335*  smul168:
042E00             0336*  ; make everything positive and store sign flags
042E00 CD F4 22 04 0337*  	call hlu_abs
042E04 F5          0338*  	push af
042E05 EB          0339*  	ex de,hl
042E06 CD F4 22 04 0340*  	call hlu_abs
042E0A EB          0341*  	ex de,hl
042E0B F5          0342*  	push af
042E0C             0343*  ; do the division
042E0C CD F8 2D 04 0344*      call umul168 ; hl = product
042E10             0345*  ; adjust sign of result
042E10 F1          0346*  	pop af ; sign de
042E11 FA 1C 2E 04 0347*  	jp m,@de_neg
042E15 F1          0348*  	pop af ; sign hl
042E16 F0          0349*  	ret p ; both positive, nothing to do
042E17             0350*  @hl_neg:
042E17 CD 04 23 04 0351*      call neg_hlu ; de pos, hl neg, result is negative
042E1B C9          0352*      ret
042E1C             0353*  @de_neg:
042E1C F1          0354*  	pop af
042E1D F8          0355*  	ret m ; both negative, nothing to do
042E1E CD 04 23 04 0356*  	call neg_hlu ; result is negative
042E22 C9          0357*  	ret
042E23             0358*  
042E23             0359*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
042E23             0360*  ; perform unsigned division of 16.8 fixed place values
042E23             0361*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
042E23             0362*  udiv168:
042E23             0363*  ; back up divisor
042E23 ED 53 5A 2E 0364*  	ld (@ude),de
       04          
042E28             0365*  ; get the 16-bit integer part of the quotient
042E28 CD 8B 2E 04 0366*      call udiv24 ; de = quotient, hl = remainder
042E2C             0367*  ; load quotient to upper three bytes of output
042E2C ED 53 61 2E 0368*      ld (div168_out+1),de
       04          
042E31             0369*  @div256:
042E31             0370*  ; multiply remainder by 256
042E31             0371*  	hlu_mul256
042E31 29          0001*M         add hl,hl ; * 2
042E32 29          0002*M         add hl,hl ; * 4
042E33 29          0003*M         add hl,hl ; * 8
042E34 29          0004*M         add hl,hl ; * 16
042E35 29          0005*M         add hl,hl ; * 32
042E36 29          0006*M         add hl,hl ; * 64
042E37 29          0007*M         add hl,hl ; * 128
042E38 29          0008*M         add hl,hl ; * 256
042E39             0372*  ; skip fractional computation if remainder is zero
042E39             0373*      sign_hlu
042E39 19          0001*M         add hl,de
042E3A B7          0002*M         or a
042E3B ED 52       0003*M         sbc hl,de
042E3D 20 03       0374*      jr nz,@div_frac
042E3F AF          0375*      xor a
042E40 18 0A       0376*      jr @write_frac
042E42             0377*  ; now divide the shifted remainder by the divisor
042E42             0378*  @div_frac:
042E42 ED 5B 5A 2E 0379*  	ld de,(@ude) ; get back divisor
       04          
042E47 CD 8B 2E 04 0380*      call udiv24 ; de = quotient, hl = remainder
042E4B             0381*  ; load low byte of quotient to low byte of output
042E4B 7B          0382*      ld a,e
042E4C             0383*  @write_frac:
042E4C 32 60 2E 04 0384*      ld (div168_out),a
042E50             0385*  ; load de with return value
042E50 ED 5B 60 2E 0386*      ld de,(div168_out)
       04          
042E55             0387*  ; load a with any overflow
042E55 3A 63 2E 04 0388*      ld a,(div168_out+3)
042E59 C9          0389*      ret ; ud.e is the 16.8 result
042E5A             0390*  @ude: ds 6
042E60             0391*  div168_out: ds 4 ; the extra byte is for overflow
042E64             0392*  
042E64             0393*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
042E64             0394*  ; perform signed division of 16.8 fixed place values
042E64             0395*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
042E64             0396*  sdiv168:
042E64             0397*  ; make everything positive and store sign flags
042E64 CD F4 22 04 0398*  	call hlu_abs
042E68 F5          0399*  	push af
042E69 EB          0400*  	ex de,hl
042E6A CD F4 22 04 0401*  	call hlu_abs
042E6E EB          0402*  	ex de,hl
042E6F F5          0403*  	push af
042E70             0404*  ; do the division
042E70 CD 23 2E 04 0405*      call udiv168 ; de = quotient, hl = remainder
042E74             0406*  ; adjust sign of result
042E74 F1          0407*  	pop af ; sign de
042E75 FA 82 2E 04 0408*  	jp m,@de_neg
042E79 F1          0409*  	pop af ; sign hl
042E7A F0          0410*  	ret p ; both positive, nothing to do
042E7B             0411*  @hl_neg:
042E7B EB          0412*      ex de,hl ; hl = quotient, de = remainder
042E7C CD 04 23 04 0413*      call neg_hlu ; de pos, hl neg, result is negative
042E80 EB          0414*      ex de,hl ; de = negated quotient, hl = remainder
042E81 C9          0415*      ret
042E82             0416*  @de_neg:
042E82 F1          0417*  	pop af
042E83 F8          0418*  	ret m ; both negative, nothing to do
042E84 EB          0419*      ex de,hl ; hl = quotient, de = remainder
042E85 CD 04 23 04 0420*  	call neg_hlu ; result is negative
042E89 EB          0421*      ex de,hl ; de = negated quotient, hl = remainder
042E8A C9          0422*  	ret
042E8B             0423*  
042E8B             0424*  ;------------------------------------------------------------------------
042E8B             0425*  ;  arith24.asm
042E8B             0426*  ;  24-bit ez80 arithmetic routines
042E8B             0427*  ;  Copyright (c) Shawn Sijnstra 2024
042E8B             0428*  ;  MIT license
042E8B             0429*  ;
042E8B             0430*  ;  This library was created as a tool to help make ez80
042E8B             0431*  ;  24-bit native assembly routines for simple mathematical problems
042E8B             0432*  ;  more widely available.
042E8B             0433*  ;
042E8B             0434*  ;------------------------------------------------------------------------
042E8B             0435*  ;
042E8B             0436*  ;------------------------------------------------------------------------
042E8B             0437*  ; udiv24
042E8B             0438*  ; Unsigned 24-bit division
042E8B             0439*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
042E8B             0440*  ;
042E8B             0441*  ; Uses AF BC DE HL
042E8B             0442*  ; Uses Restoring Division algorithm
042E8B             0443*  ;------------------------------------------------------------------------
042E8B             0444*  
042E8B             0445*  udiv24:
042E8B E5          0446*  	push	hl
042E8C C1          0447*  	pop		bc	;move dividend to BCU
042E8D 21 00 00 00 0448*  	ld		hl,0	;result
042E91 A7          0449*  	and		a
042E92 ED 52       0450*  	sbc		hl,de	;test for div by 0
042E94 C8          0451*  	ret		z		;it's zero, carry flag is clear
042E95 19          0452*  	add		hl,de	;HL is 0 again
042E96 3E 18       0453*  	ld		a,24	;number of loops through.
042E98             0454*  udiv1:
042E98 C5          0455*  	push	bc	;complicated way of doing this because of lack of access to top bits
042E99 E3          0456*  	ex		(sp),hl
042E9A 37          0457*  	scf
042E9B ED 6A       0458*  	adc	hl,hl
042E9D E3          0459*  	ex	(sp),hl
042E9E C1          0460*  	pop	bc		;we now have bc = (bc * 2) + 1
042E9F             0461*  
042E9F ED 6A       0462*  	adc	hl,hl
042EA1 A7          0463*  	and	a		;is this the bug
042EA2 ED 52       0464*  	sbc	hl,de
042EA4 30 02       0465*  	jr	nc,udiv2
042EA6 19          0466*  	add	hl,de
042EA7             0467*  ;	dec	c
042EA7 0B          0468*  	dec	bc
042EA8             0469*  udiv2:
042EA8 3D          0470*  	dec	a
042EA9 20 ED       0471*  	jr	nz,udiv1
042EAB 37          0472*  	scf		;flag used for div0 error
042EAC C5          0473*  	push	bc
042EAD D1          0474*  	pop		de	;remainder
042EAE C9          0475*  	ret
042EAF             0061   ; App-specific includes
042EAF             0062   	include "player.inc"
042EAF             0001*  ; ######## GAME STATE VARIABLES #######
042EAF             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042EAF 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042EB2             0004*  ; player current shields,binary
042EB2             0005*  ; when < 0 player splodes
042EB2             0006*  ; restores to player_max_shields when new ship spawns
042EB2 10          0007*  player_shields: db 16 ; binary
042EB3             0008*  ; max player shields,binary
042EB3             0009*  ; can increase with power-ups (todo)
042EB3 10          0010*  player_max_shields: db 16 ; binary
042EB4             0011*  ; when reaches zero,game ends
042EB4             0012*  ; can increase based on TODO
042EB4 03          0013*  player_ships: db 0x03 ; binary
042EB5             0014*  
042EB5             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042EB5             0016*  ; uses the same offsets from its table base as the main sprite table:
042EB5             0017*  player_start_variables: ; label marking beginning of table
042EB5 01          0018*  player_id:               db table_max_records
042EB6 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042EB7 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042EBA 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042EBD 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042EBE 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042EBF 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042EC0 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042EC3 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042EC6 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042EC9 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042ECC 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042ECF 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042ED2 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042ED5 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042ED6 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042ED7 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042ED8 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042ED9 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042EDA 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042EDB             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042EDB             0039*  
042EDB             0040*  ; set initial player position
042EDB             0041*  ; inputs: none,everything is hardcoded
042EDB             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042EDB             0043*  ; destroys: a
042EDB             0044*  player_init:
042EDB 3A B5 2E 04 0045*  	ld a,(player_id)
042EDF CD 8C 21 04 0046*  	call vdu_sprite_select
042EE3 CD 9F 21 04 0047*      call vdu_sprite_clear_frames
042EE7 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042EEB CD D9 22 04 0049*      call vdu_sprite_add_buff
042EEF 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042EF3 CD D9 22 04 0051*      call vdu_sprite_add_buff
042EF7 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042EFB CD D9 22 04 0053*      call vdu_sprite_add_buff
042EFF 01 00 00 00 0054*      ld bc,0
042F03 ED 43 C0 2E 0055*      ld (player_x),bc
       04          
042F08 11 00 DF 00 0056*      ld de,0x00DF00
042F0C ED 53 C3 2E 0057*      ld (player_y),de
       04          
042F11 CD 58 22 04 0058*      call vdu_sprite_move_abs168
042F15 CD 02 22 04 0059*      call vdu_sprite_show
042F19 C9          0060*      ret
042F1A             0061*  
042F1A             0062*  ; process player keyboard input, set player bitmap
042F1A             0063*  ; velocities and draw player bitmap at updated coordinates
042F1A             0064*  ; Inputs: player_x/y set at desired position
042F1A             0065*  ; Returns: player bitmap drawn at updated position
042F1A             0066*  ; Destroys: probably everything except maybe iy
042F1A             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042F1A             0068*  ; TODO: requires sprite implementation
042F1A             0069*  player_input:
042F1A             0070*  ; reset player component velocities to zero as the default
042F1A 21 00 00 00 0071*  	ld hl,0
042F1E 22 C6 2E 04 0072*  	ld (player_xvel),hl
042F22 22 C9 2E 04 0073*  	ld (player_yvel),hl
042F26             0074*  ; make ship the active sprite
042F26 3A B5 2E 04 0075*      ld a,(player_id)
042F2A CD 8C 21 04 0076*      call vdu_sprite_select
042F2E             0077*  ; check for keypresses and branch accordingly
042F2E             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042F2E             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042F2E 3E 1E       0001*M 			LD	A, function
042F30 5B CF       0002*M 			RST.LIL	08h
042F32             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042F32             0081*  ; this handles the case where two opposing movement keys
042F32             0082*  ; are down simultaneously (velocities will net to zero)
042F32             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042F32             0084*  ; it also allows movement and action keys to be detected simultaneously
042F32             0085*  ; so we can walk and chew gum at the same time
042F32 3E 01       0086*      ld a,1 ; set ship's default animation to center
042F34             0087*          ; if left and right are both down a will net to
042F34             0088*  
042F34             0089*  @left:
042F34 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042F38 28 0E       0091*      jr z,@right
042F3A 2A C6 2E 04 0092*      ld hl,(player_xvel)
042F3E 01 00 FD FF 0093*      ld bc,-speed_player
042F42 09          0094*      add hl,bc
042F43 22 C6 2E 04 0095*      ld (player_xvel),hl
042F47 3D          0096*      dec a ; set ship's animation to left
042F48             0097*  @right:
042F48 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042F4C 28 0E       0099*  	jr z,@up
042F4E 2A C6 2E 04 0100*      ld hl,(player_xvel)
042F52 01 00 03 00 0101*      ld bc,speed_player
042F56 09          0102*      add hl,bc
042F57 22 C6 2E 04 0103*      ld (player_xvel),hl
042F5B 3C          0104*      inc a ; set ship's animation to right
042F5C             0105*  @up:
042F5C DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042F60 28 0D       0107*  	jr z,@down
042F62 2A C9 2E 04 0108*      ld hl,(player_yvel)
042F66 01 00 FD FF 0109*      ld bc,-speed_player
042F6A 09          0110*      add hl,bc
042F6B 22 C9 2E 04 0111*      ld (player_yvel),hl
042F6F             0112*  @down:
042F6F DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042F73 28 0D       0114*  	jr z,@done_keyboard
042F75 2A C9 2E 04 0115*      ld hl,(player_yvel)
042F79 01 00 03 00 0116*      ld bc,speed_player
042F7D 09          0117*      add hl,bc
042F7E 22 C9 2E 04 0118*      ld (player_yvel),hl
042F82             0119*  @done_keyboard:
042F82             0120*  ; move player sprite according to velocities set by keypresses
042F82 2A C6 2E 04 0121*      ld hl,(player_xvel)
042F86             0122*  ; compute new x position
042F86 ED 5B C0 2E 0123*      ld de,(player_x)
       04          
042F8B 19          0124*      add hl,de ; hl = player_x + player_xvel
042F8C             0125*      ; check for horizontal screen edge collisions
042F8C             0126*      ; and adjust coordinate as necessary
042F8C             0127*  ; TODO: make this work using 24-bit registers
042F8C             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042F8C             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042F8C             0130*      ; ld a,8 ; set x to leftmost allowable position
042F8C             0131*  ; @check_right:
042F8C             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042F8C             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042F8C             0134*  ;     ld a,248 ; set x to rightmost allowable position
042F8C             0135*  @x_ok:
042F8C             0136*  ; save the updated drawing coordinate
042F8C 22 C0 2E 04 0137*      ld (player_x),hl
042F90             0138*  ;compute new y position
042F90 2A C3 2E 04 0139*      ld hl,(player_y)
042F94 ED 5B C9 2E 0140*      ld de,(player_yvel)
       04          
042F99 19          0141*      add hl,de ; hl = player_y + player_yvel
042F9A             0142*  ; TODO: make this work using 24-bit registers
042F9A             0143*  ;     ; check for vertical screen edge collisions
042F9A             0144*  ;     ; and adjust coordinate as necessary
042F9A             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042F9A             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042F9A             0147*  ;     ld a,8 ; set y to topmost allowable position
042F9A             0148*  ; @check_top:
042F9A             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042F9A             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042F9A             0151*  ;     ld a,232 ; set y to bottommost allowable position
042F9A             0152*  @y_ok:
042F9A 22 C3 2E 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042F9E             0154*  ; a should land here loaded with the correct frame
042F9E CD EF 21 04 0155*      call vdu_sprite_select_frame
042FA2             0156*  ; draw player at updated position
042FA2 ED 4B C0 2E 0157*      ld bc,(player_x)
       04          
042FA7 ED 5B C3 2E 0158*  	ld de,(player_y)
       04          
042FAC             0159*  
042FAC             0160*      ; call dumpRegistersHex
042FAC             0161*  
042FAC CD 58 22 04 0162*  	call vdu_sprite_move_abs168
042FB0             0163*  
042FB0             0164*  ; end player_input
042FB0 C9          0165*  	ret
042FB1             0166*  
042FB1             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042FB1             0168*  ; ; INSTEAD OF FRACTIONAL
042FB1             0169*  ; ; ----------------------------------------------------------------
042FB1             0170*  ; ; process player keyboard input, set player bitmap
042FB1             0171*  ; ; velocities and draw player bitmap at updated coordinates
042FB1             0172*  ; ; Inputs: player_x/y set at desired position
042FB1             0173*  ; ; Returns: player bitmap drawn at updated position
042FB1             0174*  ; ; Destroys: probably everything except maybe iy
042FB1             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042FB1             0176*  ; ; TODO: requires sprite implementation
042FB1             0177*  ; player_input:
042FB1             0178*  ; ; reset player component velocities to zero as the default
042FB1             0179*  ; 	ld hl,0
042FB1             0180*  ; 	ld (player_xvel),hl
042FB1             0181*  ; 	ld (player_yvel),hl
042FB1             0182*  ; ; check for keypresses and branch accordingly
042FB1             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042FB1             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042FB1             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042FB1             0186*  ; ; this handles the case where two opposing movement keys
042FB1             0187*  ; ; are down simultaneously (velocities will net to zero)
042FB1             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042FB1             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042FB1             0190*  ; ; so we can walk and chew gum at the same time
042FB1             0191*  ; @left:
042FB1             0192*  ;     bit 1,(ix+3) ; keycode 26
042FB1             0193*  ;     jr z,@right
042FB1             0194*  ;     ld hl,(player_xvel)
042FB1             0195*  ;     ld bc,-3
042FB1             0196*  ;     add hl,bc
042FB1             0197*  ;     ld (player_xvel),hl
042FB1             0198*  ; @right:
042FB1             0199*  ;     bit 1,(ix+15) ; keycode 122
042FB1             0200*  ; 	jr z,@up
042FB1             0201*  ;     ld hl,(player_xvel)
042FB1             0202*  ;     ld bc,3
042FB1             0203*  ;     add hl,bc
042FB1             0204*  ;     ld (player_xvel),hl
042FB1             0205*  ; @up:
042FB1             0206*  ;     bit 1,(ix+7) ; keycode 58
042FB1             0207*  ; 	jr z,@down
042FB1             0208*  ;     ld hl,(player_yvel)
042FB1             0209*  ;     ld bc,-3
042FB1             0210*  ;     add hl,bc
042FB1             0211*  ;     ld (player_yvel),hl
042FB1             0212*  ; @down:
042FB1             0213*  ;     bit 1,(ix+5) ; keycode 42
042FB1             0214*  ; 	jr z,@done_keyboard
042FB1             0215*  ;     ld hl,(player_yvel)
042FB1             0216*  ;     ld bc,3
042FB1             0217*  ;     add hl,bc
042FB1             0218*  ;     ld (player_yvel),hl
042FB1             0219*  ; @done_keyboard:
042FB1             0220*  ; ; move player sprite according to velocities set by keypresses
042FB1             0221*  ;     ld hl,(player_xvel)
042FB1             0222*  ; ; compute new x position
042FB1             0223*  ;     ld de,(player_x)
042FB1             0224*  ;     add hl,de ; hl = player_x + player_xvel
042FB1             0225*  ;     ; check for horizontal screen edge collisions
042FB1             0226*  ;     ; and adjust coordinate as necessary
042FB1             0227*  ; ; TODO: make this work using 24-bit registers
042FB1             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042FB1             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042FB1             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042FB1             0231*  ; ; @check_right:
042FB1             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042FB1             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042FB1             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042FB1             0235*  ; @x_ok:
042FB1             0236*  ;     ; save the updated drawing coordinate
042FB1             0237*  ;     ld (player_x),hl
042FB1             0238*  ; ;compute new y position
042FB1             0239*  ;     ld hl,(player_y)
042FB1             0240*  ;     ld de,(player_yvel)
042FB1             0241*  ;     add hl,de ; hl = player_y + player_yvel
042FB1             0242*  ; ; TODO: make this work using 24-bit registers
042FB1             0243*  ; ;     ; check for vertical screen edge collisions
042FB1             0244*  ; ;     ; and adjust coordinate as necessary
042FB1             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042FB1             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042FB1             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042FB1             0248*  ; ; @check_top:
042FB1             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042FB1             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042FB1             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042FB1             0252*  ; @y_ok:
042FB1             0253*  ;     ld (player_y),hl
042FB1             0254*  ; ; draw player at updated position
042FB1             0255*  ;     ld a,(player_id)
042FB1             0256*  ;     call vdu_sprite_select
042FB1             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042FB1             0258*  ;     call get_sign_hlu ; to set the proper animation
042FB1             0259*  ;     add a,1 ; ...
042FB1             0260*  ;     call vdu_sprite_select_frame
042FB1             0261*  ;     ld bc,(player_x)
042FB1             0262*  ; 	ld de,(player_y)
042FB1             0263*  ; 	call vdu_sprite_move_abs
042FB1             0264*  ; ; end player_input
042FB1             0265*  ; 	ret
042FB1             0266*  
042FB1             0267*  
042FB1             0268*  ; ###################################################################
042FB1             0269*  ; TODO: the below is all stuff from the original code we need to port
042FB1             0270*  ; ###################################################################
042FB1             0271*  
042FB1             0272*  ; kill_player:
042FB1             0273*  ; ; set player status to dead
042FB1             0274*  ;     xor a; sets all player flags to zero
042FB1             0275*  ;     ld (player_collisions),a
042FB1             0276*  ; ; deduct a ship from the inventory
042FB1             0277*  ;     ld a,(player_ships)
042FB1             0278*  ;     dec a
042FB1             0279*  ;     ld (player_ships),a
042FB1             0280*  ; ; are we out of ships?
042FB1             0281*  ;     jp z,game_over
042FB1             0282*  ; ; wait a few ticks
042FB1             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042FB1             0284*  ;     ld (player_move_timer),a
042FB1             0285*  ; kill_player_loop:
042FB1             0286*  ;     call vdu_vblank
042FB1             0287*  ;     ld a,(player_move_timer)
042FB1             0288*  ;     dec a
042FB1             0289*  ;     ld (player_move_timer),a
042FB1             0290*  ;     jr nz,kill_player_loop
042FB1             0291*  ;     call player_init ; player respawn if timer zero
042FB1             0292*  ;     ret ; and out
042FB1             0293*  
042FB1             0294*  
042FB1             0295*  ; player_move:
042FB1             0296*  ; ; begin setting player to active sprite
042FB1             0297*  ;     ld hl,player
042FB1             0298*  ;     ld (sprite_base_bufferId),hl
042FB1             0299*  ;     ld hl,0 ; north
042FB1             0300*  ;     ld (sprite_heading),hl
042FB1             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042FB1             0302*  ;     ld (sprite_animation),a
042FB1             0303*  ;     ; we set position here for the time being as a default
042FB1             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042FB1             0305*  ;     ld hl,(player_x)
042FB1             0306*  ;     ld (sprite_x),hl
042FB1             0307*  ;     ld hl,(player_y)
042FB1             0308*  ;     ld (sprite_y),hl
042FB1             0309*  ; ; did we just die?
042FB1             0310*  ;     ld a,(player_collisions)
042FB1             0311*  ;     and %00000010 ; zero flag will be set if not dead
042FB1             0312*  ;     jr z,player_not_dead
042FB1             0313*  ; ; yes we died
042FB1             0314*  ;     call kill_player
042FB1             0315*  ;     ret ; done
042FB1             0316*  ; ; yay we didn't die
042FB1             0317*  ; player_not_dead:
042FB1             0318*  ; ; set player movements to zero by default
042FB1             0319*  ;     ld hl,0
042FB1             0320*  ;     ld (player_xvel),hl
042FB1             0321*  ;     ld (player_yvel),hl
042FB1             0322*  ; ; do we move it?
042FB1             0323*  ;     in a,(#82) ; keyboard
042FB1             0324*  ;     or a ; if zero,don't move
042FB1             0325*  ;     jr z,player_draw
042FB1             0326*  ; ; move it
042FB1             0327*  ;     call player_move_calc
042FB1             0328*  ; player_draw:
042FB1             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042FB1             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042FB1             0331*  ; player_move_done:
042FB1             0332*  ;     ; write updated x,y coordinates back to player table
042FB1             0333*  ;     ld hl,(sprite_x)
042FB1             0334*  ;     ld (player_x),hl
042FB1             0335*  ;     ld hl,(sprite_y)
042FB1             0336*  ;     ld (player_y),hl
042FB1             0337*  ;     ret
042FB1             0063   	include "tiles.inc"
042FB1             0001*  ; ######### TILES #########
042FB1             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042FB1             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042FB1 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042FB4 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042FB5             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042FB5 00          0007*  cur_level: db 0
042FB6             0008*  num_levels: equ 2 ; number of levels,duh
042FB6             0009*  
042FB6             0010*  ; lookup table for level definitions
042FB6 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042FBC             0012*  
042FBC             0013*  ; tiles_bufferId: dl 0
042FBC 00 00 00    0014*  tiles_x_plot: dl 0
042FBF F1 FF FF    0015*  tiles_y_plot: dl -15
042FC2             0016*  
042FC2             0017*  
042FC2             0018*  tiles_plot:
042FC2             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042FC2             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042FC2             0021*  ; ;       but don't want
042FC2             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042FC2             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042FC2             0024*  ; 	ld bc,0 ; leftmost x-coord
042FC2             0025*  ; 	ld de,0 ; topmost y-coord
042FC2             0026*  ; 	ld ix,255 ; rightmost x-coord
042FC2             0027*  ; 	ld iy,1 ; bottommost y-coord
042FC2             0028*  ; 	call vdu_set_gfx_viewport
042FC2             0029*  
042FC2 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042FC6 22 BC 2F 04 0031*      ld (tiles_x_plot),hl
042FCA 2A B1 2F 04 0032*      ld hl,(tiles_row_defs)
042FCE 06 10       0033*  	ld b,16 ; loop counter
042FD0             0034*  @loop:
042FD0 C5          0035*  	push bc ; save the loop counter
042FD1             0036*  ; read the tile defintion for the current column
042FD1 7E          0037*      ld a,(hl) ; a has tile definition
042FD2 E5          0038*      push hl  ; save pointer to tile definition
042FD3 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042FD7 6F          0040*      ld l,a ; l is tile defintion
042FD8 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042FDA CD 22 1E 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042FDE             0043*  
042FDE             0044*  ; plot the active bitmap
042FDE ED 4B BC 2F 0045*      ld bc,(tiles_x_plot)
       04          
042FE3 ED 5B BF 2F 0046*      ld de,(tiles_y_plot)
       04          
042FE8 CD EB 20 04 0047*      call vdu_plot_bmp
042FEC             0048*  
042FEC             0049*  ; bump x-coords the width of one tile and save it
042FEC 2A BC 2F 04 0050*      ld hl,(tiles_x_plot)
042FF0 01 10 00 00 0051*      ld bc,16
042FF4 09          0052*      add hl,bc
042FF5 22 BC 2F 04 0053*      ld (tiles_x_plot),hl
042FF9             0054*  
042FF9             0055*  ; prepare to loop to next column
042FF9 E1          0056*      pop hl ; get back pointer to tile def
042FFA 23          0057*      inc hl ; bump it to the next column
042FFB C1          0058*  	pop bc ; snag our loop counter
042FFC 10 D2       0059*      djnz @loop
042FFE             0060*  
042FFE             0061*  ; increment tiles plotting y-coordinate
042FFE             0062*  ; when it hits zero, we go to next row of tiles in the map
042FFE             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042FFE DD 21 BF 2F 0064*  	ld ix,tiles_y_plot
       04          
043003 DD 34 00    0065*  	inc (ix)
043006 C0          0066*  	ret nz
043007             0067*  
043007             0068*  ; time to bump tiles_row_defs to next row
043007             0069*  ; (hl was already there at the end of the loop)
043007 22 B1 2F 04 0070*      ld (tiles_row_defs),hl
04300B             0071*  
04300B             0072*  ; reset coords to plot next row of tiles
04300B 21 00 00 00 0073*      ld hl,0
04300F 22 BC 2F 04 0074*      ld (tiles_x_plot),hl
043013 21 F1 FF FF 0075*      ld hl,-15
043017 22 BF 2F 04 0076*      ld (tiles_y_plot),hl
04301B             0077*  
04301B             0078*  ; decrement tiles row counter
04301B 21 B4 2F 04 0079*      ld hl,tiles_row
04301F 35          0080*      dec (hl)
043020 C0          0081*      ret nz
043021             0082*  
043021             0083*  ; queue up next level
043021 3A B5 2F 04 0084*      ld a,(cur_level)
043025 FE 01       0085*      cp num_levels-1
043027 20 02       0086*      jr nz,@inc_level
043029 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
04302B             0088*  
04302B             0089*  @inc_level:
04302B 3C          0090*      inc a
04302C 32 B5 2F 04 0091*      ld (cur_level),a
043030             0092*  
043030             0093*  ; increase the number of enemy sprites
043030 3A 77 30 04 0094*      ld a,(max_enemy_sprites)
043034 3C          0095*      inc a
043035 FE 01       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
043037 28 04       0097*      jr z,init_level
043039 32 77 30 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
04303D             0099*  ; fall through to init_level
04303D             0100*  
04303D             0101*  init_level:
04303D             0102*  ; look up address of level's tile defintion
04303D 21 B6 2F 04 0103*      ld hl,tiles_levels
043041 3A B5 2F 04 0104*      ld a,(cur_level)
043045 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
043049 57          0106*      ld d,a
04304A 1E 03       0107*      ld e,3
04304C ED 5C       0108*      mlt de
04304E 19          0109*      add hl,de
04304F ED 37       0110*      ld ix,(hl)
043051 DD 22 B1 2F 0111*      ld (tiles_row_defs),ix
       04          
043056             0112*  
043056             0113*  ; set tiles_row counter
043056 DD 7E 00    0114*      ld a,(ix)
043059 32 B4 2F 04 0115*      ld (tiles_row),a
04305D DD 23       0116*      inc ix ; now ix points first element of first row tile def
04305F DD 22 B1 2F 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
043064 C9          0118*      ret
043065             0119*  
043065             0120*  
043065             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
043065             0122*  ; dt_is_active:
043065             0123*  ; ; a lands here containing a tile index in the low nibble
043065             0124*  ; ; we test the values for the tiles which are active
043065             0125*  ;     cp #07
043065             0126*  ;     call z,ld_act_landing_pad
043065             0127*  ;     cp #08
043065             0128*  ;     call z,ld_act_laser_turret
043065             0129*  ;     ; fall through
043065             0130*  ;     ret
043065             0131*  
043065             0132*  ; ; some tiles become active sprites,so we load those here
043065             0133*  ; ; sprite_x/y have already been loaded
043065             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
043065             0135*  ; ; we don't want sprite drawn to background like other tiles
043065             0136*  ; ; so this routine only adds them to the sprite table
043065             0137*  ; dt_ld_act:
043065             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
043065             0139*  ;     ld (sprite_y+1),a ; just the integer part
043065             0140*  ;     ld (sprite_base_bufferId),hl
043065             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043065             0142*  ;     call table_add_record
043065             0143*  ;     call sprite_variables_from_stack
043065             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
043065             0145*  ;     ret ; and back
043065             0146*  
043065             0147*  ; ld_act_landing_pad:
043065             0148*  ;     call sprite_variables_to_stack
043065             0149*  
043065             0150*  ;     ld hl,move_landing_pad
043065             0151*  ;     ld (sprite_move_program),hl
043065             0152*  
043065             0153*  ;     xor a
043065             0154*  ;     ld (sprite_animation),a ; animation 0
043065             0155*  
043065             0156*  ;     call rand_8     ; snag a random number
043065             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043065             0158*  ;     add a,64 ; range is now 64-127
043065             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
043065             0160*  
043065             0161*  ;     ld a,%10 ; collides with laser but not player
043065             0162*  ;     ld (iy+sprite_collisions),a
043065             0163*  
043065             0164*  ;     ld a,#05 ; BCD
043065             0165*  ;     ld (sprite_points),a
043065             0166*  ;     ld a,0 ; binary
043065             0167*  ;     ld (sprite_shield_damage),a
043065             0168*  
043065             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
043065             0170*  ;     jr dt_ld_act
043065             0171*  
043065             0172*  ; ld_act_laser_turret:
043065             0173*  ;     call sprite_variables_to_stack
043065             0174*  
043065             0175*  ;     ld hl,move_laser_turret
043065             0176*  ;     ld (sprite_move_program),hl
043065             0177*  
043065             0178*  ;     xor a
043065             0179*  ;     ld (sprite_animation),a
043065             0180*  ;     ld (sprite_move_step),a
043065             0181*  
043065             0182*  ;     call rand_8     ; snag a random number
043065             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043065             0184*  ;     add a,64 ; range is now 64-127
043065             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043065             0186*  
043065             0187*  ;     ld a,%10 ; collides with laser but not player
043065             0188*  ;     ld (iy+sprite_collisions),a
043065             0189*  
043065             0190*  ;     ld a,#10 ; BCD
043065             0191*  ;     ld (sprite_points),a
043065             0192*  ;     ld a,0 ; binary
043065             0193*  ;     ld (sprite_shield_damage),a
043065             0194*  
043065             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
043065             0196*  ;     jp dt_ld_act
043065             0197*  
043065             0198*  
043065             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
043065             0200*  ; deletes sprites from table when they wrap around to top of screen
043065             0201*  move_active_tiles:
043065             0202*  ; get current position
043065 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
043069 3C          0204*      inc a
04306A             0205*  ; are we at the bottom of the screen?
04306A 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
04306C             0207*  ; otherwise kill sprite
04306C 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
04306E FD 77 08    0209*      ld (iy+sprite_collisions),a
043071 C9          0210*      ret ; debug
043072             0211*  move_active_tiles_draw_sprite:
043072 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
043076             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043076             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
043076 C9          0215*      ret ; and done
043077             0064   	include "enemies.inc"
043077 10          0001*  max_enemy_sprites: db 16
043078             0002*  
043078             0003*  ; sprite_type
043078             0004*  enemy_dead: equ 0
043078             0005*  enemy_small: equ 1
043078             0006*  enemy_medium: equ 2
043078             0007*  enemy_large: equ 3
043078             0008*  landing_pad: equ 4
043078             0009*  laser_turret: equ 5
043078             0010*  fireballs: equ 6
043078             0011*  explosion: equ 7
043078             0012*  
043078             0013*  
043078             0014*  respawn_countdown:
043078 2A 99 30 04 0015*      ld hl,(respawn_timer)
04307C 2B          0016*      dec hl
04307D 22 99 30 04 0017*      ld (respawn_timer),hl
043081             0018*  ; check hl for zero
043081 19          0019*      add hl,de
043082 B7          0020*      or a
043083 ED 52       0021*      sbc hl,de
043085 C0          0022*      ret nz
043086 06 01       0023*      ld b,table_max_records
043088             0024*  @respawn_loop:
043088 C5          0025*      push bc
043089 CD 94 31 04 0026*      call enemy_init_from_landing_pad
04308D C1          0027*      pop bc
04308E 10 F8       0028*      djnz @respawn_loop
043090 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
043094 22 99 30 04 0030*      ld (respawn_timer),hl
043098 C9          0031*      ret
043099 3C 00 00    0032*  respawn_timer: dl 1*60
04309C             0033*  
04309C             0034*  move_enemies:
04309C             0035*  ; are there any active enemies or explosions?
04309C 21 00 00 00 0036*      ld hl,0
0430A0 3A 0B 16 04 0037*      ld a,(table_active_sprites)
0430A4 6F          0038*      ld l,a
0430A5             0039*      ; call dumpRegistersHex
0430A5 A7          0040*      and a ; will be zero if no alive enemies or explosions
0430A6             0041*      ; ret z ; so nothing to do but go back
0430A6             0042*      ; ld hl,(respawn_timer)
0430A6             0043*      ; call dumpRegistersHex
0430A6 20 05       0044*      jr nz,move_enemies_do
0430A8 CD 78 30 04 0045*      call respawn_countdown
0430AC C9          0046*      ret
0430AD             0047*  move_enemies_do:
0430AD             0048*  ; initialize pointers and loop counter
0430AD FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
0430B2 06 01       0050*      ld b,table_max_records ; loop counter
0430B4             0051*  move_enemies_loop:
0430B4 FD 22 08 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
0430B9 C5          0053*      push bc ; backup loop counter
0430BA             0054*  ; check sprite_type to see if sprite is active
0430BA FD 7E 01    0055*      ld a,(iy+sprite_type)
0430BD A7          0056*      and a ; if zero, sprite is dead
0430BE 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
0430C0             0058*  ; otherwise we prepare to move the sprite
0430C0 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
0430C3 CD 8C 21 04 0060*      call vdu_sprite_select ; select sprite
0430C7 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0430CA E9          0062*      jp (hl)  ; ... and jump to it
0430CB             0063*  ; we always jp back here from behavior subroutines
0430CB             0064*  move_enemies_loop_return:
0430CB FD 2A 08 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
0430D0             0066*  ; now we check results of all the moves
0430D0 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
0430D3 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
0430D5 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0430D8 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0430DA CD 54 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
0430DE AF          0072*      xor a ; zero a so that we can ...
0430DF FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
0430E2 18 0A       0074*      jr move_enemies_next_record ; and to the next record
0430E4             0075*  move_enemies_draw_sprite:
0430E4             0076*  ; if we got here sprite will have already been activated
0430E4             0077*  ; so all we need to do is set its coordinates and draw it
0430E4 FD 07 0B    0078*      ld bc,(iy+sprite_x)
0430E7 FD 17 0E    0079*      ld de,(iy+sprite_y)
0430EA CD 58 22 04 0080*      call vdu_sprite_move_abs168
0430EE             0081*  ; fall through to next record
0430EE             0082*  move_enemies_next_record:
0430EE 11 26 00 00 0083*      ld de,table_bytes_per_record
0430F2 FD 19       0084*      add iy,de ; point to next record
0430F4 AF          0085*      xor a ; clears carry flag
0430F5 32 0C 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
0430F9 C1          0087*      pop bc ; get back our loop counter
0430FA 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
0430FC C9          0089*      ret ; and we're out
0430FD             0090*  
0430FD             0091*  en_nav_zigzag_start:
0430FD FD 2A 08 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043102 CD A9 23 04 0093*      call rand_8
043106 E6 3F       0094*      and %00111111 ; limit it to 64
043108 CB DF       0095*      set 3,a ; make sure it's at least 8
04310A FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
04310D             0097*      ; fall through to en_nav_zigzag
04310D             0098*  en_nav_zigzag:
04310D FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
043110 3D          0100*      dec a
043111 FD 77 22    0101*      ld (iy+sprite_move_timer),a
043114 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
043116             0103*      ; otherwise flip direction and restart timer
043116 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
043119 EE 01       0105*      xor %1 ; flips bit one
04311B FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
04311E 20 09       0107*      jr nz,en_nav_zigzag_right
043120             0108*  ;otherwise zag left
043120 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
043124 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
043127 18 D4       0111*      jr en_nav_zigzag_start
043129             0112*  en_nav_zigzag_right:
043129 21 00 60 00 0113*      ld hl,0x006000; southeast heading
04312D FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
043130 18 CB       0115*      jr en_nav_zigzag_start
043132             0116*  en_nav_zigzag_no_switch:
043132             0117*      ; ld a,(sprite_orientation)
043132 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
043135 18 13       0119*      jr en_nav_computevelocities
043137             0120*  
043137             0121*  ; contains the logic for how to move the enemy
043137             0122*  ; and then does the moving
043137             0123*  ; inputs: a fully-populated active sprite table
043137             0124*  ;         player position variables
043137             0125*  ; destroys: everything except index registers
043137             0126*  ; outputs: moving enemies
043137             0127*  en_nav:
043137             0128*  ; set velocity and orientation by player's relative location
043137             0129*  ; move enemies y-axis
043137             0130*  ; where is player relative to us?
043137 CD 17 32 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
04313B             0132*  ; is player above or below us?
04313B ED 53 01 1C 0133*      ld (ude),de ; dy
       04          
043140 3A 03 1C 04 0134*      ld a,(ude+2) ; deu
043144 17          0135*      rla ; shift sign bit into carry
043145 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
043147             0137*  ; player is even or above,so home in on current heading
043147 FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
04314A             0139*  
04314A             0140*  ; we land here from zig-zag program so as not to
04314A             0141*  ; redundantly save orientation and heading
04314A             0142*  en_nav_computevelocities:
04314A             0143*  ; set x/y component velocities based on bearing to player
04314A FD 2A 08 16 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04314F E5          0145*      push hl ; we need it back to set rotation frame
043150 FD 17 17    0146*      ld de,(iy+sprite_vel)
043153 CD 02 24 04 0147*      call polar_to_cartesian
043157 FD 2A 08 16 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04315C FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
04315F FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
043162             0151*  ; change the animation frame to match heading
043162             0152*  ; by dividng the heading by 8
043162 E1          0153*      pop hl ; get back Heading
043163 7C          0154*      ld a,h
043164 CB 3F       0155*      srl a
043166 CB 3F       0156*      srl a
043168 CB 3F       0157*      srl a
04316A CD EF 21 04 0158*      call vdu_sprite_select_frame
04316E             0159*  
04316E             0160*  move_enemy_sprite:
04316E FD 2A 08 16 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043173 FD 27 0B    0162*      ld hl,(iy+sprite_x)
043176 FD 17 11    0163*      ld de,(iy+sprite_xvel)
043179 19          0164*      add hl,de
04317A FD 2F 0B    0165*      ld (iy+sprite_x),hl
04317D FD 27 0E    0166*      ld hl,(iy+sprite_y)
043180 FD 17 14    0167*      ld de,(iy+sprite_yvel)
043183 19          0168*      add hl,de
043184 FD 2F 0E    0169*      ld (iy+sprite_y),hl
043187 C9          0170*      ret
043188             0171*  
043188             0172*  ; ; TODO: IMPLEMENT THIS PROPERLY
043188             0173*  ; move_enemy_sprite:
043188             0174*  ; ; x-axis movement first
043188             0175*  ;     ld hl,(iy+sprite_x)
043188             0176*  ;     push hl ; save pre-move position
043188             0177*  ;     pop bc ; to detect screen edge collision
043188             0178*  ;     ld de,(iy+sprite_xvel)
043188             0179*  ;     add hl,de ;compute new x position
043188             0180*  ;     ld (iy+sprite_x),hl ; store it
043188             0181*  ;     and a ; clear the carry flag
043188             0182*  ;     sbc hl,bc ; test which direction was our movement
043188             0183*  ;     jr z,@move_y ; zero flag means no horizontal movement
043188             0184*  ;     jp p,@move_right ; sign positive means moved right
043188             0185*  ; @move_left: ; otherwise we moved left
043188             0186*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
043188             0187*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
043188             0188*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
043188             0189*  ;     ld a,#20 ; west
043188             0190*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043188             0191*  ;     jr @move_y
043188             0192*  ; @move_right:
043188             0193*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
043188             0194*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
043188             0195*  ;     ld l,0x00
043188             0196*  ;     ld a,(iy+sprite_dim_x)
043188             0197*  ;     ld h,a
043188             0198*  ;     ld a,0x00
043188             0199*  ;     sub h
043188             0200*  ;     ld h,a
043188             0201*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
043188             0202*  ;     ld a,0x02 ; east
043188             0203*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043188             0204*  ; @move_y:
043188             0205*  ;     ld hl,(iy+sprite_y)
043188             0206*  ;     ld b,h ; save pre-move position
043188             0207*  ;     ld c,l ; to detect screen edge collision
043188             0208*  ;     ld de,(iy+sprite_yvel)
043188             0209*  ;     add hl,de ;compute new y position
043188             0210*  ;     ld (iy+sprite_y),hl ; store it
043188             0211*  ;     and a ; clear the carry flag
043188             0212*  ;     sbc hl,bc ; test which direction was our movement
043188             0213*  ;     jr z,@move_ret ; zero flag means no vertical movement
043188             0214*  ;     jp p,@move_dn ; sign positive means moved down
043188             0215*  ; @move_up:
043188             0216*  ;     add hl,bc ; get back new y position
043188             0217*  ;     ld de,0x5000 ; top edge of visible screen
043188             0218*  ;     and a ; clear the carry flag
043188             0219*  ;     sbc hl,de
043188             0220*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
043188             0221*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
043188             0222*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
043188             0223*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
043188             0224*  ;     or 0x80 ; north
043188             0225*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043188             0226*  ;     jr @move_ret
043188             0227*  ; @move_dn:
043188             0228*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
043188             0229*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
043188             0230*  ;     ld l,0x00
043188             0231*  ;     ld a,(iy+sprite_dim_y)
043188             0232*  ;     ld h,a
043188             0233*  ;     ld a,0x00
043188             0234*  ;     sub h
043188             0235*  ;     ld h,a
043188             0236*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
043188             0237*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
043188             0238*  ;     or 0x08 ; south
043188             0239*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043188             0240*  ; @move_ret:
043188             0241*  ;     ret
043188             0242*  
043188             0243*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
043188             0244*  ; ; each sprite in the table must have one of these defined
043188             0245*  ; ; but they need not be unique to a particular sprite
043188             0246*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
043188             0247*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
043188             0248*  ; ; but they can call anything they want between those two endpoints
043188             0249*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
043188             0250*  
043188             0251*  ; move_nop: ; does nothing but burn a few cycles changing the PC
043188             0252*  ;     jp move_enemies_loop_return
043188             0253*  
043188             0254*  ; move_explosion:
043188             0255*  ;     call animate_explosion
043188             0256*  ;     jp move_enemies_loop_return
043188             0257*  
043188             0258*  move_enemy_small:
043188 CD 37 31 04 0259*      call en_nav
04318C CD AD 32 04 0260*      call check_collisions
043190 C3 CB 30 04 0261*      jp move_enemies_loop_return
043194             0262*  
043194             0263*  ; move_enemy_medium:
043194             0264*  ;     call en_nav
043194             0265*  ;     call check_collisions
043194             0266*  ;     jp move_enemies_loop_return
043194             0267*  
043194             0268*  ; move_enemy_large:
043194             0269*  ;     call en_nav
043194             0270*  ;     call check_collisions
043194             0271*  ;     jp move_enemies_loop_return
043194             0272*  
043194             0273*  ; move_landing_pad:
043194             0274*  ;     call move_active_tiles
043194             0275*  ;     call check_collisions
043194             0276*  ; ; is it time to launch an enemy?
043194             0277*  ;     ld hl,sprite_move_timer
043194             0278*  ;     dec (hl)
043194             0279*  ;     jp nz,move_enemies_loop_return
043194             0280*  ;     call enemy_init_from_landing_pad
043194             0281*  ;     ; reset move timer so can spawn again if player doesn't take us out
043194             0282*  ;     call rand_8     ; snag a random number
043194             0283*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043194             0284*  ;     add a,64 ; range is now 64-127
043194             0285*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
043194             0286*  ;     jp move_enemies_loop_return
043194             0287*  
043194             0288*  enemy_init_from_landing_pad:
043194             0289*  ; get next available spriteId
043194 CD 2F 16 04 0290*      call table_get_next_id
043198 D0          0291*      ret nc ; no carry means no free sprite slots, so we go home
043199             0292*  ; ix comes back with the pointer to the new sprite variables
043199 DD E5       0293*      push ix ; de picks it up when we're ready for the copy to the table
04319B             0294*  ; a comes back with the spriteId of the new sprite
04319B 32 F1 31 04 0295*      ld (@id),a
04319F             0296*  ; initialize the new sprite
04319F CD 8C 21 04 0297*      call vdu_sprite_select
0431A3 CD 9F 21 04 0298*      call vdu_sprite_clear_frames
0431A7 21 14 01 00 0299*      ld hl,BUF_SEEKER_000
0431AB 06 20       0300*      ld b,32
0431AD             0301*  @load_frames:
0431AD C5          0302*      push bc
0431AE E5          0303*      push hl
0431AF CD D9 22 04 0304*      call vdu_sprite_add_buff
0431B3 E1          0305*      pop hl
0431B4 23          0306*      inc hl
0431B5 C1          0307*      pop bc
0431B6 10 F5       0308*      djnz @load_frames
0431B8             0309*  ; copy coordinates of active sprite to new sprite
0431B8 FD 2A 08 16 0310*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0431BD             0311*      ; ld hl,(iy+sprite_x)
0431BD             0312*  	; ld hl,0x008000 ; debug
0431BD             0313*  
0431BD CD A9 23 04 0314*      call rand_8
0431C1 21 00 00 00 0315*      ld hl,0
0431C5 67          0316*      ld h,a
0431C6             0317*  
0431C6 22 FC 31 04 0318*      ld (@x),hl
0431CA             0319*      ; ld hl,(iy+sprite_y)
0431CA             0320*      ; ld hl,0x002000 ; debug
0431CA             0321*  
0431CA CD A9 23 04 0322*      call rand_8
0431CE 21 00 00 00 0323*      ld hl,0
0431D2 67          0324*      ld h,a
0431D3             0325*  
0431D3 22 FF 31 04 0326*      ld (@y),hl
0431D7 CD A9 23 04 0327*      call rand_8
0431DB E6 01       0328*      and %00000001 ; 50/50 chance of moving left or right on spanw
0431DD 32 14 32 04 0329*      ld (@move_step),a
0431E1             0330*  ; now copy to the table
0431E1 21 F1 31 04 0331*      ld hl,@id ; address to copy from
0431E5 D1          0332*      pop de ; address to copy to (was ix)
0431E6 01 26 00 00 0333*      ld bc,table_bytes_per_record ; number of bytes to copy
0431EA ED B0       0334*      ldir ; copy the records from local scratch to sprite table
0431EC             0335*  ; finally, make the new sprite visible
0431EC CD 02 22 04 0336*      call vdu_sprite_show
0431F0 C9          0337*      ret
0431F1 00          0338*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
0431F2 01          0339*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
0431F3 14 01 00    0340*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0431F6 88 31 04    0341*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0431F9 03          0342*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
0431FA 10          0343*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
0431FB 10          0344*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
0431FC 00 00 00    0345*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0431FF 00 00 00    0346*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043202 00 00 00    0347*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043205 00 00 00    0348*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043208 80 02 00    0349*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
04320B 00 80 00    0350*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
04320E 00 80 00    0351*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
043211 00          0352*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
043212 00          0353*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
043213 01          0354*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
043214 00          0355*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
043215 20          0356*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
043216 02          0357*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
043217             0358*  
043217             0359*  ; move_laser_turret:
043217             0360*  ; ; compute orientation to player
043217             0361*  ;     call orientation_to_player
043217             0362*  ; ; h.l 8.8 fixed angle256 to player
043217             0363*  ; ; bc and de as signed 16-bit integers
043217             0364*  ; ; representing delta-x/y *to* target respectively
043217             0365*  ;     ld (Bearing_t),hl
043217             0366*  ;     ld hl,0x0400
043217             0367*  ;     ld (Vp),hl
043217             0368*  ;     call targeting_computer
043217             0369*  ;     ld (sprite_heading),hl ; store bearing to player
043217             0370*  ; ; is it time to launch a fireball?
043217             0371*  ;     ld hl,sprite_move_timer
043217             0372*  ;     dec (hl)
043217             0373*  ;     jp nz,move_laser_turret_boilerplate
043217             0374*  ;     call fireballs_init
043217             0375*  ;     ; reset move timer so can fire again if player doesn't take us out
043217             0376*  ;     call rand_8     ; snag a random number
043217             0377*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
043217             0378*  ;     add a,64 ; range is now 64-127
043217             0379*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
043217             0380*  ; move_laser_turret_boilerplate:
043217             0381*  ;     call move_active_tiles
043217             0382*  ;     call check_collisions
043217             0383*  ;     jp move_enemies_loop_return
043217             0384*  
043217             0385*  ; fireballs_init:
043217             0386*  ;     call sprite_variables_to_stack
043217             0387*  
043217             0388*  ;     ld hl,fireballs
043217             0389*  ;     ld (sprite_base_bufferId),hl
043217             0390*  
043217             0391*  ;     ld hl,move_fireballs
043217             0392*  ;     ld (sprite_move_program),hl
043217             0393*  
043217             0394*  ;     ld a,%11 ; collides with laser and player
043217             0395*  ;     ; ld a,%10 ; collides with laser DEBUG
043217             0396*  ;     ld (iy+sprite_collisions),a
043217             0397*  
043217             0398*  ;     ld hl,(Vp)
043217             0399*  ;     ld (sprite_vel),hl
043217             0400*  ;     ld hl,(Vp_x)
043217             0401*  ;     ld (sprite_xvel),hl
043217             0402*  ;     ld hl,(Vp_y)
043217             0403*  ;     inc h ; account for ground movement
043217             0404*  ;     ld (sprite_yvel),hl
043217             0405*  
043217             0406*  ;     xor a ; zero a
043217             0407*  ;     ld (sprite_animation),a
043217             0408*  ;     ld (sprite_move_step),a
043217             0409*  ;     ld (sprite_move_timer),a
043217             0410*  
043217             0411*  ;     ld a,6 ; 1/10th of a second timer
043217             0412*  ;     ld (sprite_animation_timer),a
043217             0413*  
043217             0414*  ;     ld a,0x00 ; BCD
043217             0415*  ;     ld (sprite_points),a
043217             0416*  ;     ld a,1 ; binary
043217             0417*  ;     ld (sprite_shield_damage),a
043217             0418*  
043217             0419*  ;     call table_add_record ; plops that on the sprite stack for later
043217             0420*  ;     call sprite_variables_from_stack ; come back to where we started
043217             0421*  ;     ret
043217             0422*  
043217             0423*  ; move_fireballs:
043217             0424*  ;     call move_enemy_sprite ; move sprite
043217             0425*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
043217             0426*  ;     and a ; if zero we're still within screen bounds
043217             0427*  ;     jr z,move_fireballs_alive
043217             0428*  ; ; otherwise kill sprite
043217             0429*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
043217             0430*  ;     ld (iy+sprite_collisions),a
043217             0431*  ;     jp move_enemies_loop_return
043217             0432*  ; move_fireballs_alive:
043217             0433*  ;     ld a,(sprite_animation_timer)
043217             0434*  ;     dec a
043217             0435*  ;     ld (sprite_animation_timer),a
043217             0436*  ;     jr nz,move_fireballs_draw
043217             0437*  ;     ld a,(sprite_animation)
043217             0438*  ;     xor %1
043217             0439*  ;     ld (sprite_animation),a
043217             0440*  ;     ld a,6 ; 1/10th of a second timer
043217             0441*  ;     ld (sprite_animation_timer),a
043217             0442*  ;     ; fall through
043217             0443*  
043217             0444*  ; move_fireballs_draw:
043217             0445*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043217             0446*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043217             0447*  ;     call check_collisions
043217             0448*  ;     jp move_enemies_loop_return
043217             0449*  
043217             0450*  ; compute orientation to player
043217             0451*  ; based on relative positions
043217             0452*  ; returns: h.l 16.8 fixed angle256 to player
043217             0453*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
043217             0454*  ;    representing delta-x/y *to* target respectively
043217             0455*  orientation_to_player:
043217 FD 2A 08 16 0456*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04321C FD E5       0457*      push iy ; so we can send it back intact
04321E FD 07 0B    0458*      ld bc,(iy+sprite_x)
043221 FD 17 0E    0459*      ld de,(iy+sprite_y)
043224 DD 2A C0 2E 0460*      ld ix,(player_x)
       04          
043229 FD 2A C3 2E 0461*      ld iy,(player_y)
       04          
04322E CD 37 24 04 0462*      call dxy168
043232 C5          0463*      push bc
043233 D5          0464*      push de
043234 CD AA 24 04 0465*      call atan2_168fast
043238 D1          0466*      pop de
043239 C1          0467*      pop bc
04323A FD E1       0468*      pop iy ; restore table pointer
04323C C9          0469*      ret
04323D             0470*  
04323D             0471*  
04323D             0472*  ; targeting_computer scratch variables
04323D 00 00       0473*  Bearing_t: dw #0000 ; 8.8 fixed
04323F 00 00       0474*  Heading_t: dw #0000 ; 8.8 fixed
043241 00 00       0475*  Vp: dw #0000 ; 8.8 fixed
043243 00 00       0476*  Vp_x: dw #0000 ; 8.8 fixed
043245 00 00       0477*  Vp_y: dw #0000 ; 8.8 fixed
043247 00 00       0478*  Vt: dw #0000 ; 8.8 fixed
043249 00 00       0479*  Vt_x: dw #0000 ; 8.8 fixed
04324B 00 00       0480*  Vt_y: dw #0000 ; 8.8 fixed
04324D             0481*  
04324D             0482*  
04324D             0483*  ; ; Inputs:   see scratch variables
04324D             0484*  ; ; Note:     a call to orientation_to_player provides these inputs
04324D             0485*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
04324D             0486*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
04324D             0487*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
04324D             0488*  ; targeting_computer:
04324D             0489*  ; ; compute target velocity from x,y component velocities
04324D             0490*  ;     ld bc,(player_xvel)
04324D             0491*  ;     ld de,(player_yvel)
04324D             0492*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
04324D             0493*  
04324D             0494*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
04324D             0495*  ;     ld (Heading_t),bc
04324D             0496*  ;     ld (Vt),de
04324D             0497*  
04324D             0498*  ; ; compute Heading_t-Bearing_t
04324D             0499*  ;     ld h,b
04324D             0500*  ;     ld l,c
04324D             0501*  ;     ld bc,(Bearing_t)
04324D             0502*  ;     and a ; clear carry
04324D             0503*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
04324D             0504*  
04324D             0505*  ; ; compute sin(Heading_t-Bearing_t)
04324D             0506*  ;     ld b,h
04324D             0507*  ;     ld c,l
04324D             0508*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
04324D             0509*  
04324D             0510*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
04324D             0511*  ;     ex de,hl
04324D             0512*  ;     ld bc,(Vt)
04324D             0513*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
04324D             0514*  
04324D             0515*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
04324D             0516*  ;     ld b,h
04324D             0517*  ;     ld c,l
04324D             0518*  ;     ld de,(Vp)
04324D             0519*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
04324D             0520*  ; ; answer is in radians, convert to degrees256
04324D             0521*  ;     ex de,hl
04324D             0522*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
04324D             0523*  ;     call BC_Mul_DE_88
04324D             0524*  
04324D             0525*  ; ; add lead angle to target bearing
04324D             0526*  ;     ld de,(Bearing_t)
04324D             0527*  ;     add hl,de ; h.l=lead angle+target bearing
04324D             0528*  ;     push hl
04324D             0529*  
04324D             0530*  ; ; compute component projectile velocities
04324D             0531*  ;     ld b,h
04324D             0532*  ;     ld c,l
04324D             0533*  ;     ld de,(Vp)
04324D             0534*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
04324D             0535*  
04324D             0536*  ;     ld (Vp_x),bc
04324D             0537*  ;     ld (Vp_y),de
04324D             0538*  ;     pop hl ; h.l=lead angle+target bearing
04324D             0539*  ;     ret
04324D             0540*  
04324D             0541*  ; this routine vanquishes the enemy sprite
04324D             0542*  ; and replaces it with an animated explosion
04324D             0543*  ; we jump here instead of call because
04324D             0544*  ; we want to return to differing locations in the loop
04324D             0545*  ; depending on whether we're still sploding
04324D             0546*  ; destroys: everything except index registers
04324D             0547*  ; returns: an incandescent ball of debris and gas
04324D             0548*  kill_nurple:
04324D             0549*  ; ; tally up points
04324D             0550*  ;     ld bc,0
04324D             0551*  ;     ld a,(sprite_points)
04324D             0552*  ;     ld e,a
04324D             0553*  ;     ld d,0
04324D             0554*  ;     ld hl,add_bcd_arg2
04324D             0555*  ;     call set_bcd
04324D             0556*  ;     ld hl,player_score
04324D             0557*  ;     ld de,add_bcd_arg2
04324D             0558*  ;     ld a,3 ; number of bytes to add
04324D             0559*  ;     call add_bcd
04324D             0560*  ; ; initialize explosion
04324D             0561*  ; init_explosion:
04324D             0562*  ;     ld hl,explosion
04324D             0563*  ;     ld (sprite_base_bufferId),hl
04324D             0564*  ;     ld hl,move_explosion
04324D             0565*  ;     ld (sprite_move_program),hl
04324D             0566*  ;     ld a,%00000000 ; collides with nothing
04324D             0567*  ;     ld (iy+sprite_collisions),a
04324D             0568*  ;     ld hl,0 ; north
04324D             0569*  ;     ld (sprite_heading),hl
04324D             0570*  ;     ld a,0x04 ; will decrement to 03
04324D             0571*  ;     ld (sprite_animation),a
04324D             0572*  ;     ld a,0x07 ; 7/60th of a second timer
04324D             0573*  ;     ld (sprite_animation_timer),a
04324D             0574*  ;     xor a
04324D             0575*  ;     ld (sprite_move_timer),a
04324D             0576*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04324D             0577*  ; ; fall through to next_explosion
04324D             0578*  ; next_explosion:
04324D             0579*  ;     ld a,(sprite_animation)
04324D             0580*  ;     dec a ; if rolled negative from zero,we're done sploding
04324D             0581*  ;     jp m,done_explosion
04324D             0582*  ;     ld (sprite_animation),a
04324D             0583*  ;     ld a,0x7 ; 7/60th of a second timer
04324D             0584*  ;     ld (sprite_animation_timer),a
04324D             0585*  ; ; fall through to animate_explosion
04324D             0586*  ; animate_explosion:
04324D             0587*  ;     ld hl,sprite_y+1
04324D             0588*  ;     inc (hl) ; move explosion down 1 pixel
04324D             0589*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
04324D             0590*  ;     ld hl,sprite_animation_timer
04324D             0591*  ;     dec (hl) ; if timer is zero,we do next animation
04324D             0592*  ;     jr z,next_explosion
04324D             0593*  ;     ;otherwise we fall through to draw the current one
04324D             0594*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04324D             0595*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04324D             0596*  ;     ret ; now we go back to caller
04324D             0597*  ; done_explosion:
04324D 3E 80       0598*      ld a,%10000000 ; high bit set is non-specific kill-me flag
04324F FD 2A 08 16 0599*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
043254 FD 77 08    0600*      ld (iy+sprite_collisions),a
043257 C9          0601*      ret ; now we go back to caller
043258             0602*  
043258             0603*  ; game_over:
043258             0604*  ;     jp new_game
043258             0605*  
043258             0606*  ; it's presumed we've already checked that laser is alive
043258             0607*  collision_enemy_with_laser:
043258 DD 2A E5 32 0608*      ld ix,(laser_x)
       04          
04325D FD 2A E8 32 0609*      ld iy,(laser_y)
       04          
043262 3A E3 32 04 0610*      ld a,(laser_dim_x)
043266 CB 2F       0611*      sra a ; divide by 2
043268 F5          0612*      push af ; we need this later
043269             0613*      ; ld de,0
043269             0614*      ; ld d,a
043269             0615*      ; add ix,de
043269             0616*      ; add iy,de
043269 18 11       0617*      jr collision_enemy
04326B             0618*  
04326B             0619*  ; it's presumed we've already checked that player is alive
04326B             0620*  collision_enemy_with_player:
04326B DD 2A C0 2E 0621*      ld ix,(player_x)
       04          
043270 FD 2A C3 2E 0622*      ld iy,(player_y)
       04          
043275 3A BE 2E 04 0623*      ld a,(player_dim_x)
043279             0624*  
043279             0625*      ; call dumpRegistersHex
043279             0626*  
043279 CB 2F       0627*      sra a ; divide by 2
04327B F5          0628*      push af ; we need this later
04327C             0629*      ; ld de,0
04327C             0630*      ; ld d,a
04327C             0631*      ; add ix,de
04327C             0632*      ; add iy,de
04327C             0633*      ; fall through to collision_enemy
04327C             0634*  
04327C             0635*  ; compute the distance between the two sprites' centers
04327C             0636*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
04327C             0637*  collision_enemy:
04327C             0638*  ; back up iy because we need it as the sprite table pointer
04327C FD E5       0639*      push iy
04327E FD 2A 08 16 0640*      ld iy,(table_pointer)
       04          
043283 FD 27 0B    0641*      ld hl,(iy+sprite_x)
043286 FD 7E 09    0642*      ld a,(iy+sprite_dim_x)
043289 CB 2F       0643*      sra a
04328B F5          0644*      push af ; we need this later
04328C             0645*      ; ld de,0
04328C             0646*      ; ld d,a
04328C             0647*      ; add hl,de
04328C E5          0648*      push hl
04328D C1          0649*      pop bc ; bc = x0
04328E FD 27 0E    0650*      ld hl,(iy+sprite_y)
043291 FD 7E 0A    0651*      ld a,(iy+sprite_dim_y)
043294             0652*      ; sra a
043294             0653*      ; ld de,0
043294             0654*      ; ld d,a
043294             0655*      ; add hl,de
043294 EB          0656*      ex de,hl ; de = y0
043295 F1          0657*      pop af ; TODO: srsly, this is the best way to do this?
043296 FD E1       0658*      pop iy
043298 F5          0659*      push af
043299             0660*  
043299             0661*      ; call dumpRegistersHex
043299             0662*  
043299 CD 5E 24 04 0663*      call distance168
04329D             0664*      ; CALL dumpRegistersHex
04329D             0665*  ; ; subtract sum of radii from distance between centers
04329D             0666*  ;     ld de,0
04329D             0667*  ;     pop af ; radius of enemy sprite
04329D             0668*  ;     ld e,a
04329D             0669*  ;     pop af ; radius of player or laser sprite
04329D             0670*  ;     add a,e
04329D             0671*  ;     ld e,a
04329D             0672*  ;     and a ; clear carry
04329D             0673*  ;     sbc hl,de
04329D             0674*  ;     jr c,collision_enemy_is
04329D             0675*  ;     xor a
04329D             0676*  ;     ret
04329D             0677*  ; temp fix TODO: remove this
04329D F1          0678*      pop af
04329E F1          0679*      pop af
04329F 11 00 10 00 0680*      ld de,16*256
0432A3 A7          0681*      and a
0432A4 ED 52       0682*      sbc hl,de
0432A6 38 02       0683*      jr c,collision_enemy_is
0432A8 AF          0684*      xor a
0432A9             0685*      ; call dumpRegistersHex
0432A9 C9          0686*      ret
0432AA             0687*  collision_enemy_is:
0432AA AF          0688*      xor a
0432AB 3C          0689*      inc a
0432AC             0690*      ; call dumpRegistersHex
0432AC C9          0691*      ret
0432AD             0692*  
0432AD             0693*  ; ; looks up what enemy sprite collides with
0432AD             0694*  ; ; detects collisions
0432AD             0695*  ; ; and sets things to sploding accordingly
0432AD             0696*  ; check_collisions:
0432AD             0697*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
0432AD             0698*  ;     and a ; if this is zero,
0432AD             0699*  ;     ret z ; there's nothing to do
0432AD             0700*  ;     and %01 ; do we collide with player?
0432AD             0701*  ;     jr z,move_enemies_laser ; if not,check laser collision
0432AD             0702*  ;     call collision_enemy_with_player ; otherwise see if we hit player
0432AD             0703*  ;     and a ; was there a collision?
0432AD             0704*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
0432AD             0705*  ; ; yes collision with player
0432AD             0706*  ;     ; deduct shield damage
0432AD             0707*  ;     ld hl,sprite_shield_damage
0432AD             0708*  ;     ld a,(player_shields)
0432AD             0709*  ;     sub (hl)
0432AD             0710*  ;     ld (player_shields),a
0432AD             0711*  ; ; if shields >= 0,player survives
0432AD             0712*  ;     jp p,check_collisions_kill_nurple
0432AD             0713*  ; ; otherwise update player status so it will die
0432AD             0714*  ;     ld a,(player_collisions)
0432AD             0715*  ;     or %10 ; sets bit 1,meaning player just died
0432AD             0716*  ;     ld (player_collisions),a
0432AD             0717*  ;     ; fall through
0432AD             0718*  ; check_collisions_kill_nurple:
0432AD             0719*  ; ; kill enemy and replace with explosion
0432AD             0720*  ;     call kill_nurple
0432AD             0721*  ;     ret ; and out
0432AD             0722*  
0432AD             0723*  check_collisions:
0432AD CD 6B 32 04 0724*      call collision_enemy_with_player ; did we hit the player?
0432B1 A7          0725*      and a ; was there a collision?
0432B2 C8          0726*      ret z ; if not,we're done
0432B3 CD 4D 32 04 0727*      call kill_nurple ; otherwise kill enemy
0432B7 C9          0728*      ret
0432B8             0729*  
0432B8             0730*  ; did we hit the laser?
0432B8             0731*  move_enemies_laser:
0432B8 FD 7E 08    0732*      ld a,(iy+sprite_collisions) ; snag what we collide with again
0432BB E6 02       0733*      and %10 ; do we even collide with laser?
0432BD C8          0734*      ret z ; if not,we're out
0432BE 3A E2 32 04 0735*      ld a,(laser_collisions) ; is laser alive?
0432C2 E6 01       0736*      and %1 ; if bit 0 is not set laser is dead
0432C4 C8          0737*      ret z ; so we're out
0432C5 CD 58 32 04 0738*      call collision_enemy_with_laser ; otherwise check for collision
0432C9 A7          0739*      and a ; was there a collision?
0432CA C8          0740*      ret z ; if not,we're done
0432CB             0741*  ; otherwise we mark laser for termination and kill enemy
0432CB             0742*  ; update laser status so it will die
0432CB 3A E2 32 04 0743*      ld a,(laser_collisions)
0432CF F6 02       0744*      or %10 ; bit 1 set means laser just died
0432D1 32 E2 32 04 0745*      ld (laser_collisions),a
0432D5 CD 4D 32 04 0746*      call kill_nurple ; yes there was a collision,so kill enemy
0432D9 C9          0747*      ret ; we're outta' here
0432DA             0065   	include "laser.inc"
0432DA             0001*  ; ##### LASER SPRITE PARAMETERS #####
0432DA             0002*  ; uses the same offsets from its table base as the main sprite table:
0432DA             0003*  laser_start_variables: ; label marking beginning of table
0432DA 02          0004*  laser_id:               db table_max_records+1
0432DB 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
0432DC 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0432DF 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0432E2 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0432E3 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0432E4 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0432E5 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0432E8 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0432EB 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0432EE 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0432F1 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
0432F4 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0432F7 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
0432FA 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
0432FB 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
0432FC 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
0432FD 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
0432FE 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
0432FF 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
043300             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
043300             0025*  
043300             0026*  ; laser_control:
043300             0027*  ; ; is laser already active?
043300             0028*  ;     ld a,(laser_collisions)
043300             0029*  ;     and %00000001 ; bit zero is lit if laser is active
043300             0030*  ;     jr nz,laser_move ; move laser if not zero
043300             0031*  ; ; otherwise check if laser fired
043300             0032*  ;     in a,(#82) ; keyboard
043300             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
043300             0034*  ;     ret z ; go back if laser not fired
043300             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
043300             0036*  ; ; set laser status to active (set bit 0)
043300             0037*  ;     ld a,%1
043300             0038*  ;     ld (laser_collisions),a
043300             0039*  ; ; initialize laser position
043300             0040*  ;     ld a,(player_x+1) ; we only need the integer part
043300             0041*  ;     ; add a,6 ; horizontal center with player sprite
043300             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
043300             0043*  ;     ld a,(player_y+1) ; we only need the integer part
043300             0044*  ;     add a,-6 ; set laser y a few pixels above player
043300             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
043300             0046*  ;     ; fall through to laser_move
043300             0047*  
043300             0048*  ; laser_move:
043300             0049*  ; ; begin setting laser to active sprite
043300             0050*  ;     ld hl,lasers
043300             0051*  ;     ld (sprite_base_bufferId),hl
043300             0052*  ;     ld hl,0 ; north
043300             0053*  ;     ld (sprite_heading),hl
043300             0054*  ;     xor a ; laser has no animations yet :-(
043300             0055*  ;     ld (sprite_animation),a
043300             0056*  ;     ; we set position here for the time being as a default
043300             0057*  ;     ; in case the laser is flagged for deletion
043300             0058*  ;     ; load sprite_x with laser x position (we do y further down)
043300             0059*  ;     ld hl,(laser_x)
043300             0060*  ;     ld (sprite_x),hl
043300             0061*  ; ; did laser just die?
043300             0062*  ;     ld a,(laser_collisions)
043300             0063*  ;     bit 1,a ; z if laser didn't just die
043300             0064*  ;     jr z,laser_not_dead_yet
043300             0065*  ; ; yes laser died
043300             0066*  ;     call kill_laser
043300             0067*  ;     ret ; done
043300             0068*  ; laser_not_dead_yet:
043300             0069*  ; ; draw it
043300             0070*  ; ; update laser y position
043300             0071*  ;     ld hl,(laser_y) ; grab laser y position
043300             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
043300             0073*  ;     add hl,de ; add y velocity to y pos
043300             0074*  ;     ld (sprite_y),hl ; update laser y position
043300             0075*  ;     ld (laser_y),hl ; update laser y position
043300             0076*  ; ; are we at top of screen?
043300             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
043300             0078*  ;     sub h ; no carry if above threshold
043300             0079*  ;     jr c,finally_draw_the_frikken_laser
043300             0080*  ;     ; if at top of screen,laser dies
043300             0081*  ;     call kill_laser
043300             0082*  ;     ret
043300             0083*  ; ; otherwise,finally draw the frikken laser
043300             0084*  ; finally_draw_the_frikken_laser:
043300             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043300             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043300             0087*  ; ; all done
043300             0088*  ;     ret
043300             0089*  
043300             0090*  ; kill_laser:
043300             0091*  ; ; update status to inactive
043300             0092*  ;     xor a ; zero out a
043300             0093*  ;     ld (laser_collisions),a
043300             0094*  ;     ret
043300             0066   	include "timer.inc"
043300             0001*  ; Table 32. Timer Control Registers
043300             0002*  ; this constant is the base address of the timer control registers
043300             0003*  ; each timer takes three bytes:
043300             0004*  ;   0: control register
043300             0005*  ;   1: low byte of timer reset value
043300             0006*  ;   2: high byte of timer reset value
043300             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043300             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043300             0009*  TMR_CTL:     equ 80h
043300             0010*  
043300             0011*  ; Timer Control Register Bit Definitions
043300             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043300             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043300             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043300             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043300             0016*                              ; the TMRx_CTL register is read.
043300             0017*  
043300             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043300             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043300             0020*  
043300             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043300             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043300             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043300             0024*                              ; written to the counter when the end-of-count value is reached.
043300             0025*  
043300             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043300             0027*  CLK_DIV_256:  equ %00001100 ;
043300             0028*  CLK_DIV_64:   equ %00001000 ;
043300             0029*  CLK_DIV_16:   equ %00000100 ;
043300             0030*  CLK_DIV_4:    equ %00000000 ;
043300             0031*  
043300             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043300             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043300             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043300             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043300             0036*                              ; programmer must ensure that this bit is set to 1 each time
043300             0037*                              ; SINGLE-PASS mode is used.
043300             0038*  
043300             0039*  ; disable/enable the programmable reload timer
043300             0040*  PRT_EN_0:     equ %00000000 ;
043300             0041*  PRT_EN_1:     equ %00000001 ;
043300             0042*  
043300             0043*  ; Table 37. Timer Input Source Select Register
043300             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043300             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043300             0046*  ;   00: System clock / CLK_DIV
043300             0047*  ;   01: RTC / CLK_DIV
043300             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043300             0049*  ;   10: GPIO port B pin 1.
043300             0050*  ;   11: GPIO port B pin 1.
043300             0051*  TMR_ISS:   equ 92h ; register address
043300             0052*  
043300             0053*  ; Table 51. Real-Time Clock Control Register
043300             0054*  RTC_CTRL: equ EDh ; register address
043300             0055*  
043300             0056*  ; alarm interrupt disable/enable
043300             0057*  RTC_ALARM_0:    equ %00000000
043300             0058*  RTC_ALARM_1:    equ %10000000
043300             0059*  
043300             0060*  ; interrupt on alarm disable/enable
043300             0061*  RTC_INT_ENT_0:  equ %00000000
043300             0062*  RTC_INT_ENT_1:  equ %01000000
043300             0063*  
043300             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043300             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043300             0066*  
043300             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043300             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043300             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043300             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043300             0071*  
043300             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043300             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043300             0074*  
043300             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043300             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043300             0077*  
043300             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043300             0079*                                  ; RTC counter is enabled.
043300             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043300             0081*                                  ; RTC counter is disabled.
043300             0082*  
043300             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043300             0084*  
043300             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043300             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043300 00 00 00    0087*  prt_reload: dl 0x000000
043303             0088*  
043303             0089*  ; set PRT timer
043303             0090*  prt_set:
043303 21 00 00 00 0091*      ld hl,0
043307 22 51 33 04 0092*      ld (prt_irq_counter),hl
04330B 2A 00 33 04 0093*      ld hl,(prt_reload)
04330F ED 29 84    0094*      out0 ($84),l
043312 ED 21 85    0095*  	out0 ($85),h
043315             0096*  ; disable timer
043315 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043317 ED 39 83    0098*  	out0 ($83),a
04331A             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04331A 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04331C ED 39 83    0101*  	out0 ($83),a
04331F C9          0102*      ret
043320             0103*  
043320             0104*  ; ===============================================
043320             0105*  ; PRT Timer Interrupt Handling
043320             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
043320             0107*  ; -----------------------------------------------
043320             0108*  prt_irq_init:
043320             0109*      ; set up interrupt vector table 2
043320 21 00 00 00 0110*  	ld hl,0
043324 3A 0C 01 00 0111*  	ld a,($10c)
043328 6F          0112*  	ld l,a
043329 3A 0D 01 00 0113*  	ld a,($10d)
04332D 67          0114*  	ld h,a
04332E             0115*  
04332E             0116*  	; skip over CALL ($c3)
04332E 23          0117*  	inc hl
04332F             0118*  	; load address of jump into vector table 2 (in ram)
04332F ED 27       0119*  	ld hl,(hl)
043331             0120*  
043331             0121*  	; write CALL prt_irq_handler to vector table 2
043331 3E C3       0122*  	ld a,$c3
043333 77          0123*  	ld (hl),a
043334 23          0124*  	inc hl
043335 11 3C 33 04 0125*  	ld de,prt_irq_handler
043339 ED 1F       0126*  	ld (hl),de
04333B             0127*  
04333B C9          0128*      ret
04333C             0129*  
04333C             0130*  prt_irq_handler:
04333C F3          0131*  	di
04333D F5          0132*  	push af
04333E E5          0133*      push hl
04333F ED 38 83    0134*  	in0 a,($83)
043342 2A 51 33 04 0135*  	ld hl,(prt_irq_counter)
043346 23          0136*  	inc hl
043347 22 51 33 04 0137*  	ld (prt_irq_counter),hl
04334B E1          0138*      pop hl
04334C F1          0139*  	pop af
04334D FB          0140*  	ei
04334E 5B ED 4D    0141*  	reti.l
043351             0142*  
043351             0143*  prt_irq_counter:
043351 00 00 00    0144*  	.dl 0
043354             0145*  prt_irq_counter_saved:
043354 00 00 00    0146*      .dl 0
043357             0147*  
043357             0148*  prt_loop_reset:
043357 E5          0149*      push hl
043358 21 00 00 00 0150*  	ld hl,0
04335C 22 51 33 04 0151*  	ld (prt_irq_counter),hl
043360 22 C2 33 04 0152*      ld (prt_loop_counter),hl
043364 22 C5 33 04 0153*      ld (prt_loops),hl
043368 CD 03 33 04 0154*      call prt_set
04336C E1          0155*      pop hl
04336D C9          0156*      ret
04336E             0157*  
04336E             0158*  prt_loop_start:
04336E E5          0159*      push hl
04336F 21 00 00 00 0160*  	ld hl,0
043373 22 51 33 04 0161*  	ld (prt_irq_counter),hl
043377 E1          0162*      pop hl
043378 C9          0163*      ret
043379             0164*  
043379             0165*  prt_loop_stop:
043379 E5          0166*      push hl
04337A D5          0167*      push de
04337B 2A 51 33 04 0168*      ld hl,(prt_irq_counter)
04337F ED 5B C2 33 0169*      ld de,(prt_loop_counter)
       04          
043384 19          0170*      add hl,de
043385 22 C2 33 04 0171*      ld (prt_loop_counter),hl
043389 21 00 00 00 0172*      ld hl,0
04338D 22 51 33 04 0173*      ld (prt_irq_counter),hl
043391 2A C5 33 04 0174*      ld hl,(prt_loops)
043395 23          0175*      inc hl
043396 22 C5 33 04 0176*      ld (prt_loops),hl
04339A D1          0177*      pop de
04339B E1          0178*      pop hl
04339C C9          0179*      ret
04339D             0180*  
04339D             0181*  ; inputs: bc = y,x text coordinates to print
04339D             0182*  prt_loop_print:
04339D F5          0183*      push af
04339E E5          0184*      push hl
04339F C5          0185*      push bc
0433A0 D5          0186*      push de
0433A1 DD E5       0187*      push ix
0433A3 FD E5       0188*      push iy
0433A5 CD 21 1D 04 0189*      call vdu_move_cursor
0433A9             0190*  
0433A9 2A C2 33 04 0191*      ld hl,(prt_loop_counter)
0433AD CD D2 17 04 0192*      call printDec
0433B1             0193*  
0433B1 2A C5 33 04 0194*      ld hl,(prt_loops)
0433B5 CD D2 17 04 0195*      call printDec
0433B9             0196*  
0433B9 FD E1       0197*      pop iy
0433BB DD E1       0198*      pop ix
0433BD D1          0199*      pop de
0433BE C1          0200*      pop bc
0433BF E1          0201*      pop hl
0433C0 F1          0202*      pop af
0433C1 C9          0203*      ret
0433C2             0204*  
0433C2             0205*  prt_loop_counter:
0433C2 00 00 00    0206*      .dl 0
0433C5             0207*  prt_loops:
0433C5 00 00 00    0208*      .dl 0
0433C8             0209*  
0433C8             0210*  ; ===============================================
0433C8             0211*  ; Timer functions
0433C8             0212*  ; -----------------------------------------------
0433C8             0213*  ; set a countdown timer
0433C8             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433C8             0215*  ; returns: hl = current time
0433C8             0216*  tmr_set:
0433C8 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0433CB             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0433CB 3E 08       0001*M 			LD	A, function
0433CD 5B CF       0002*M 			RST.LIL	08h
0433CF DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0433D2 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0433D5 C9          0221*      ret
0433D6             0222*  
0433D6             0223*  ; gets time remaining on a countdown timer
0433D6             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433D6             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0433D6             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0433D6             0227*  tmr_get:
0433D6             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0433D6 3E 08       0001*M 			LD	A, function
0433D8 5B CF       0002*M 			RST.LIL	08h
0433DA DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0433DD FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0433E0 AF          0231*      xor a                   ; clear carry
0433E1 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0433E3 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0433E6 AF          0234*      xor a                   ; clear carry
0433E7 ED 5A       0235*      adc hl,de               ; hl = time remaining
0433E9             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0433E9 C9          0237*      ret
0433EA             0238*  
0433EA             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0433F0             0240*  
0433F0 00 00 00    0241*  timestamp_now: dl 0
0433F3 00 00 00    0242*  timestamp_old: dl 0
0433F6 00 00 00    0243*  timestamp_chg: dl 0
0433F9             0244*  
0433F9             0245*  ; update the global timestamp from the system clock
0433F9             0246*  ; inputs: none
0433F9             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0433F9             0248*  ;          de = current time
0433F9             0249*  ;          ix = pointer to syvars table
0433F9             0250*  ; destroys: af,hl,de,ix
0433F9             0251*  timestamp_tick:
0433F9 ED 5B F0 33 0252*      ld de,(timestamp_now)   ; get previous time
       04          
0433FE ED 53 F3 33 0253*      ld (timestamp_old),de   ; save previous time
       04          
043403             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043403 3E 08       0001*M 			LD	A, function
043405 5B CF       0002*M 			RST.LIL	08h
043407 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
04340A 22 F0 33 04 0256*      ld (timestamp_now),hl   ; save current time
04340E AF          0257*      xor a                   ; clear carry
04340F ED 52       0258*      sbc hl,de               ; hl = time elapsed
043411 22 F6 33 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043415 C9          0260*      ret
043416             0261*  
043416             0262*  ; set a countdown timer
043416             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043416             0264*  ; requires: timestamp_tick to be called at least once before this function
043416             0265*  ; returns: hl = current time
043416             0266*  ; destroys: hl
043416             0267*  timestamp_tmr_set:
043416 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043419 2A F0 33 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
04341D FD 2F 00    0270*      ld (iy+0),hl            ; set start time
043420 C9          0271*      ret
043421             0272*  
043421             0273*  ; gets time remaining on a countdown timer following the global timestamp
043421             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043421             0275*  ; requires: timestamp_tick to be called at least once before this function
043421             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043421             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
043421             0278*  ; destroys: af,hl,de
043421             0279*  timestamp_tmr_get:
043421 ED 5B F0 33 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043426 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043429 AF          0282*      xor a                   ; clear carry
04342A ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04342C FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
04342F AF          0285*      xor a                   ; clear carry
043430 ED 5A       0286*      adc hl,de               ; hl = time remaining
043432             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043432 C9          0288*      ret
043433             0289*  
043433             0290*  ; set a stopwatch
043433             0291*  ; returns: hl = start time
043433             0292*  ; destroys: hl,ix
043433             0293*  stopwatch_set:
043433             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043433 3E 08       0001*M 			LD	A, function
043435 5B CF       0002*M 			RST.LIL	08h
043437 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
04343A 22 4F 34 04 0296*      ld (stopwatch_started),hl            ; set start time
04343E C9          0297*      ret
04343F             0298*  
04343F             0299*  ; gets time elapsed on a stopwatch
04343F             0300*  ; returns: hl = time elapsed in 1/120ths of a second
04343F             0301*  ; destroys: af,hl,de,ix
04343F             0302*  stopwatch_get:
04343F             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
04343F 3E 08       0001*M 			LD	A, function
043441 5B CF       0002*M 			RST.LIL	08h
043443 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043446 ED 5B 4F 34 0305*      ld de,(stopwatch_started)            ; get start time
       04          
04344B AF          0306*      xor a                   ; clear carry
04344C ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04344E C9          0308*      ret
04344F             0309*  
04344F             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043452             0311*  
043452             0312*  ; ------------------
043452             0313*  ; delay routine
043452             0314*  ; Author: Richard Turrnidge
043452             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043452             0316*  ; routine waits a fixed time,then returns
043452             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043452             0318*  ; eg. ld A,00000100b
043452             0319*  
043452             0320*  multiPurposeDelay:
043452 F5          0321*      push af
043453 C5          0322*      push bc
043454 DD E5       0323*      push ix
043456 47          0324*      ld b,a
043457 3E 08       0325*      ld a,$08
043459 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
04345B             0327*  
04345B             0328*  waitLoop:
04345B             0329*  
04345B DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04345E             0331*  
04345E             0332*                                  ;   we check if bit set is same as last time we checked.
04345E             0333*                                  ;   bit 0 - don't use
04345E             0334*                                  ;   bit 1 - changes 64 times per second
04345E             0335*                                  ;   bit 2 - changes 32 times per second
04345E             0336*                                  ;   bit 3 - changes 16 times per second
04345E             0337*  
04345E             0338*                                  ;   bit 4 - changes 8 times per second
04345E             0339*                                  ;   bit 5 - changes 4 times per second
04345E             0340*                                  ;   bit 6 - changes 2 times per second
04345E             0341*                                  ;   bit 7 - changes 1 times per second
04345E A0          0342*      and b
04345F 4F          0343*      ld c,a
043460 3A 71 34 04 0344*      ld a,(oldTimeStamp)
043464 B9          0345*      cp c                        ; is A same as last value?
043465 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043467 79          0347*      ld a,c
043468 32 71 34 04 0348*      ld (oldTimeStamp),a        ; set new value
04346C             0349*  
04346C DD E1       0350*      pop ix
04346E C1          0351*      pop bc
04346F F1          0352*      pop af
043470 C9          0353*      ret
043471             0354*  
043471 00          0355*  oldTimeStamp:   .db 00h
043472             0067   
043472             0068   ; new includes
043472             0069   	include "images.inc"
043472             0001*  image_type: equ 0
043472             0002*  image_width: equ image_type+3
043472             0003*  image_height: equ image_width+3
043472             0004*  image_filesize: equ image_height+3
043472             0005*  image_filename: equ image_filesize+3
043472             0006*  image_bufferId: equ image_filename+3
043472             0007*  image_record_size: equ image_bufferId+3
043472             0008*  
043472 00 00 00    0009*  cur_image_list: dl 0
043475 00 00 00    0010*  cur_file_idx: dl 0
043478 00 00 00    0011*  cur_filename: dl 0
04347B 00 00 00    0012*  cur_buffer_id: dl 0
04347E             0013*  
04347E             0014*  load_ui_images:
04347E             0015*  ; initialize image loading variables
04347E 21 00 00 00 0016*  	ld hl,0
043482 22 75 34 04 0017*  	ld (cur_file_idx),hl
043486 21 38 44 04 0018*  	ld hl,ui_image_list
04348A 22 72 34 04 0019*  	ld (cur_image_list),hl
04348E             0020*  ; load images
04348E 06 02       0021*  	ld b,ui_num_images
043490             0022*  @loop:
043490 C5          0023*  	push bc
043491 CD CB 34 04 0024*  	call load_next_image
043495 C1          0025*  	pop bc
043496 10 F8       0026*  	djnz @loop
043498 C9          0027*  	ret
043499             0028*  
043499             0029*  load_sprite_images:
043499             0030*  ; initialize image loading variables
043499 21 00 00 00 0031*  	ld hl,0
04349D 22 75 34 04 0032*  	ld (cur_file_idx),hl
0434A1 21 5C 35 04 0033*  	ld hl,sprites_image_list
0434A5 22 72 34 04 0034*  	ld (cur_image_list),hl
0434A9 01 59 00 00 0035*  	ld bc,sprites_num_images
0434AD             0036*  ; load images
0434AD CD B2 34 04 0037*  	call img_load_main
0434B1 C9          0038*  	ret
0434B2             0039*  
0434B2             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0434B2             0041*  img_load_main:
0434B2 AF          0042*  	xor a
0434B3 32 75 34 04 0043*      ld (cur_file_idx),a
0434B7             0044*  
0434B7             0045*  img_load_main_loop:
0434B7             0046*  ; back up loop counter
0434B7 C5          0047*      push bc
0434B8             0048*  
0434B8             0049*  ; load the next image
0434B8 CD CB 34 04 0050*      call load_next_image
0434BC             0051*  
0434BC             0052*  ; ; plot the background
0434BC             0053*  ; 	call vdu_cls
0434BC             0054*  ;     ld hl,BUF_SPLASH_BG
0434BC             0055*  ;     call vdu_buff_select
0434BC             0056*  ;     ld bc,0
0434BC             0057*  ;     ld de,0
0434BC             0058*  ;     call vdu_plot_bmp
0434BC             0059*  
0434BC             0060*  ; ; ; draw the most recently loaded image
0434BC             0061*  ; ; 	ld hl,(cur_buffer_id)
0434BC             0062*  ; ; 	call vdu_buff_select
0434BC             0063*  ; ; 	ld bc,0
0434BC             0064*  ; ; 	ld de,0
0434BC             0065*  ; ; 	call vdu_plot_bmp
0434BC             0066*  
0434BC             0067*  ; ; move logo
0434BC             0068*  ; 	call move_logo
0434BC             0069*  
0434BC             0070*  ; ; print current filename
0434BC             0071*  ; 	ld hl,(cur_filename)
0434BC             0072*  ; 	call printString
0434BC             0073*  
0434BC             0074*  ; ; flip the framebuffer
0434BC             0075*  ; 	call vdu_flip
0434BC             0076*  
0434BC             0077*  ; decrement loop counter
0434BC C1          0078*      pop bc
0434BD 0B          0079*  	dec bc
0434BE 79          0080*      ld a,c
0434BF B7          0081*      or a
0434C0 C2 B7 34 04 0082*      jp nz,img_load_main_loop
0434C4 78          0083*      ld a,b
0434C5 B7          0084*      or a
0434C6 C2 B7 34 04 0085*      jp nz,img_load_main_loop
0434CA C9          0086*      ret
0434CB             0087*  
0434CB             0088*  load_next_image:
0434CB 16 12       0089*      ld d,image_record_size
0434CD 3A 75 34 04 0090*  	ld a,(cur_file_idx)
0434D1 5F          0091*  	ld e,a
0434D2 ED 5C       0092*      mlt de
0434D4 FD 2A 72 34 0093*      ld iy,(cur_image_list)
       04          
0434D9 FD 19       0094*      add iy,de
0434DB             0095*  
0434DB FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0434DE FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0434E1 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0434E4 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0434E7 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
0434EA 22 7B 34 04 0101*  	ld (cur_buffer_id),hl
0434EE FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0434F1 FD 22 78 34 0103*  	ld (cur_filename),iy
       04          
0434F6 CD 40 1F 04 0104*      call vdu_load_img
0434FA FD 21 75 34 0105*      ld iy,cur_file_idx
       04          
0434FF FD 34 00    0106*  	inc (iy)
043502 C9          0107*  	ret
043503             0108*  
043503             0109*  img_load_init:
043503             0110*  ; initialize logo's position parameters
043503 21 00 00 00 0111*  	ld hl,0
043507 22 50 35 04 0112*  	ld (logo_xvel),hl
04350B 22 53 35 04 0113*  	ld (logo_xpos),hl
04350F             0114*  ; begin 16.8 maths to determine logo's y position and velocity
04350F 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
043513 22 59 35 04 0116*  	ld (logo_ypos),hl
043517 EB          0117*  	ex de,hl
043518 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
04351C 19          0119*  	add hl,de ; distance for logo to travel
04351D 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
043521 CD 64 2E 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
043525 ED 53 56 35 0122*  	ld (logo_yvel),de
       04          
04352A             0123*  ; all done
04352A C9          0124*      ret
04352B             0125*  
04352B             0126*  move_logo:
04352B             0127*  ; activate logo bitmap
04352B 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
04352F CD 22 1E 04 0129*  	call vdu_buff_select
043533             0130*  ; update position based on velocity parameters
043533 2A 59 35 04 0131*  	ld hl,(logo_ypos)
043537 ED 5B 56 35 0132*  	ld de,(logo_yvel)
       04          
04353C 19          0133*  	add hl,de
04353D 22 59 35 04 0134*  	ld (logo_ypos),hl
043541             0135*  ; draw logo
043541 ED 4B 53 35 0136*  	ld bc,(logo_xpos)
       04          
043546 ED 5B 59 35 0137*  	ld de,(logo_ypos)
       04          
04354B CD 07 21 04 0138*  	call vdu_plot_bmp168
04354F C9          0139*  	ret
043550             0140*  
043550 00 00 00    0141*  logo_xvel: dl 0
043553 00 00 00    0142*  logo_xpos: dl 0
043556             0143*  
043556 00 00 00    0144*  logo_yvel: dl 0
043559 00 00 00    0145*  logo_ypos: dl 0
04355C             0070   	include "images_sprites.inc"
04355C             0001*  ; Generated by make_images.py
04355C             0002*  
04355C             0003*  sprites_num_images: equ 89
04355C             0004*  
04355C             0005*  ; buffer_ids:
04355C             0006*  BUF_0TILE_EMPTY: equ 256
04355C             0007*  BUF_1TILE_CROSS: equ 257
04355C             0008*  BUF_2TILE_HORIZ: equ 258
04355C             0009*  BUF_3TILE_VERT: equ 259
04355C             0010*  BUF_4TILE_SQUARE: equ 260
04355C             0011*  BUF_5TILE_CIRCLE: equ 261
04355C             0012*  BUF_6TILE_PAD: equ 262
04355C             0013*  BUF_7TILE_TURRET: equ 263
04355C             0014*  BUF_CIRCLE: equ 264
04355C             0015*  BUF_CRATER: equ 265
04355C             0016*  BUF_EXPLOSION_A: equ 266
04355C             0017*  BUF_EXPLOSION_B: equ 267
04355C             0018*  BUF_EXPLOSION_C: equ 268
04355C             0019*  BUF_EXPLOSION_D: equ 269
04355C             0020*  BUF_EXPLOSION_E: equ 270
04355C             0021*  BUF_FIREBALL_A: equ 271
04355C             0022*  BUF_FIREBALL_B: equ 272
04355C             0023*  BUF_LASER_A: equ 273
04355C             0024*  BUF_LASER_B: equ 274
04355C             0025*  BUF_PAD: equ 275
04355C             0026*  BUF_SEEKER_000: equ 276
04355C             0027*  BUF_SEEKER_008: equ 277
04355C             0028*  BUF_SEEKER_016: equ 278
04355C             0029*  BUF_SEEKER_024: equ 279
04355C             0030*  BUF_SEEKER_032: equ 280
04355C             0031*  BUF_SEEKER_040: equ 281
04355C             0032*  BUF_SEEKER_048: equ 282
04355C             0033*  BUF_SEEKER_056: equ 283
04355C             0034*  BUF_SEEKER_064: equ 284
04355C             0035*  BUF_SEEKER_072: equ 285
04355C             0036*  BUF_SEEKER_080: equ 286
04355C             0037*  BUF_SEEKER_088: equ 287
04355C             0038*  BUF_SEEKER_096: equ 288
04355C             0039*  BUF_SEEKER_104: equ 289
04355C             0040*  BUF_SEEKER_112: equ 290
04355C             0041*  BUF_SEEKER_120: equ 291
04355C             0042*  BUF_SEEKER_128: equ 292
04355C             0043*  BUF_SEEKER_136: equ 293
04355C             0044*  BUF_SEEKER_144: equ 294
04355C             0045*  BUF_SEEKER_152: equ 295
04355C             0046*  BUF_SEEKER_160: equ 296
04355C             0047*  BUF_SEEKER_168: equ 297
04355C             0048*  BUF_SEEKER_176: equ 298
04355C             0049*  BUF_SEEKER_184: equ 299
04355C             0050*  BUF_SEEKER_192: equ 300
04355C             0051*  BUF_SEEKER_200: equ 301
04355C             0052*  BUF_SEEKER_208: equ 302
04355C             0053*  BUF_SEEKER_216: equ 303
04355C             0054*  BUF_SEEKER_224: equ 304
04355C             0055*  BUF_SEEKER_232: equ 305
04355C             0056*  BUF_SEEKER_240: equ 306
04355C             0057*  BUF_SEEKER_248: equ 307
04355C             0058*  BUF_SHIP_0L: equ 308
04355C             0059*  BUF_SHIP_1C: equ 309
04355C             0060*  BUF_SHIP_2R: equ 310
04355C             0061*  BUF_SHIP_SMALL: equ 311
04355C             0062*  BUF_STAR: equ 312
04355C             0063*  BUF_TURRET_000: equ 313
04355C             0064*  BUF_TURRET_008: equ 314
04355C             0065*  BUF_TURRET_016: equ 315
04355C             0066*  BUF_TURRET_024: equ 316
04355C             0067*  BUF_TURRET_032: equ 317
04355C             0068*  BUF_TURRET_040: equ 318
04355C             0069*  BUF_TURRET_048: equ 319
04355C             0070*  BUF_TURRET_056: equ 320
04355C             0071*  BUF_TURRET_064: equ 321
04355C             0072*  BUF_TURRET_072: equ 322
04355C             0073*  BUF_TURRET_080: equ 323
04355C             0074*  BUF_TURRET_088: equ 324
04355C             0075*  BUF_TURRET_096: equ 325
04355C             0076*  BUF_TURRET_104: equ 326
04355C             0077*  BUF_TURRET_112: equ 327
04355C             0078*  BUF_TURRET_120: equ 328
04355C             0079*  BUF_TURRET_128: equ 329
04355C             0080*  BUF_TURRET_136: equ 330
04355C             0081*  BUF_TURRET_144: equ 331
04355C             0082*  BUF_TURRET_152: equ 332
04355C             0083*  BUF_TURRET_160: equ 333
04355C             0084*  BUF_TURRET_168: equ 334
04355C             0085*  BUF_TURRET_176: equ 335
04355C             0086*  BUF_TURRET_184: equ 336
04355C             0087*  BUF_TURRET_192: equ 337
04355C             0088*  BUF_TURRET_200: equ 338
04355C             0089*  BUF_TURRET_208: equ 339
04355C             0090*  BUF_TURRET_216: equ 340
04355C             0091*  BUF_TURRET_224: equ 341
04355C             0092*  BUF_TURRET_232: equ 342
04355C             0093*  BUF_TURRET_240: equ 343
04355C             0094*  BUF_TURRET_248: equ 344
04355C             0095*  
04355C             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
04355C 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       9E 3B 04 00 
       01 00       
04356E 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       B8 3B 04 01 
       01 00       
043580 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       D2 3B 04 02 
       01 00       
043592 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       EC 3B 04 03 
       01 00       
0435A4 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       05 3C 04 04 
       01 00       
0435B6 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       20 3C 04 05 
       01 00       
0435C8 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       3B 3C 04 06 
       01 00       
0435DA 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       53 3C 04 07 
       01 00       
0435EC 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       6E 3C 04 08 
       01 00       
0435FE 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       83 3C 04 09 
       01 00       
043610 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       98 3C 04 0A 
       01 00       
043622 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       B2 3C 04 0B 
       01 00       
043634 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       CC 3C 04 0C 
       01 00       
043646 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       E6 3C 04 0D 
       01 00       
043658 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       00 3D 04 0E 
       01 00       
04366A 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       1A 3D 04 0F 
       01 00       
04367C 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       33 3D 04 10 
       01 00       
04368E 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       4C 3D 04 11 
       01 00       
0436A0 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       62 3D 04 12 
       01 00       
0436B2 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       78 3D 04 13 
       01 00       
0436C4 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       8A 3D 04 14 
       01 00       
0436D6 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       A3 3D 04 15 
       01 00       
0436E8 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       BC 3D 04 16 
       01 00       
0436FA 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       D5 3D 04 17 
       01 00       
04370C 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       EE 3D 04 18 
       01 00       
04371E 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       07 3E 04 19 
       01 00       
043730 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       20 3E 04 1A 
       01 00       
043742 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       39 3E 04 1B 
       01 00       
043754 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       52 3E 04 1C 
       01 00       
043766 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       6B 3E 04 1D 
       01 00       
043778 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       84 3E 04 1E 
       01 00       
04378A 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       9D 3E 04 1F 
       01 00       
04379C 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       B6 3E 04 20 
       01 00       
0437AE 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       CF 3E 04 21 
       01 00       
0437C0 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       E8 3E 04 22 
       01 00       
0437D2 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       01 3F 04 23 
       01 00       
0437E4 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       1A 3F 04 24 
       01 00       
0437F6 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       33 3F 04 25 
       01 00       
043808 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       4C 3F 04 26 
       01 00       
04381A 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       65 3F 04 27 
       01 00       
04382C 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       7E 3F 04 28 
       01 00       
04383E 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       97 3F 04 29 
       01 00       
043850 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       B0 3F 04 2A 
       01 00       
043862 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       C9 3F 04 2B 
       01 00       
043874 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       E2 3F 04 2C 
       01 00       
043886 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       FB 3F 04 2D 
       01 00       
043898 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       14 40 04 2E 
       01 00       
0438AA 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       2D 40 04 2F 
       01 00       
0438BC 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       46 40 04 30 
       01 00       
0438CE 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       5F 40 04 31 
       01 00       
0438E0 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       78 40 04 32 
       01 00       
0438F2 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       91 40 04 33 
       01 00       
043904 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       AA 40 04 34 
       01 00       
043916 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       C0 40 04 35 
       01 00       
043928 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       D6 40 04 36 
       01 00       
04393A 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       EC 40 04 37 
       01 00       
04394C 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       05 41 04 38 
       01 00       
04395E 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       18 41 04 39 
       01 00       
043970 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       31 41 04 3A 
       01 00       
043982 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       4A 41 04 3B 
       01 00       
043994 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       63 41 04 3C 
       01 00       
0439A6 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       7C 41 04 3D 
       01 00       
0439B8 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       95 41 04 3E 
       01 00       
0439CA 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       AE 41 04 3F 
       01 00       
0439DC 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       C7 41 04 40 
       01 00       
0439EE 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       E0 41 04 41 
       01 00       
043A00 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       F9 41 04 42 
       01 00       
043A12 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       12 42 04 43 
       01 00       
043A24 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       2B 42 04 44 
       01 00       
043A36 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       44 42 04 45 
       01 00       
043A48 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       5D 42 04 46 
       01 00       
043A5A 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       76 42 04 47 
       01 00       
043A6C 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       8F 42 04 48 
       01 00       
043A7E 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       A8 42 04 49 
       01 00       
043A90 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       C1 42 04 4A 
       01 00       
043AA2 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       DA 42 04 4B 
       01 00       
043AB4 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       F3 42 04 4C 
       01 00       
043AC6 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       0C 43 04 4D 
       01 00       
043AD8 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       25 43 04 4E 
       01 00       
043AEA 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       3E 43 04 4F 
       01 00       
043AFC 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       57 43 04 50 
       01 00       
043B0E 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       70 43 04 51 
       01 00       
043B20 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       89 43 04 52 
       01 00       
043B32 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       A2 43 04 53 
       01 00       
043B44 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       BB 43 04 54 
       01 00       
043B56 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       D4 43 04 55 
       01 00       
043B68 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       ED 43 04 56 
       01 00       
043B7A 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       06 44 04 57 
       01 00       
043B8C 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       1F 44 04 58 
       01 00       
043B9E             0186*  
043B9E             0187*  ; files_list: ; filename:
043B9E 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043BB8 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043BD2 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043BEC 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043C05 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043C20 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043C3B 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043C53 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043C6E 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043C83 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043C98 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043CB2 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043CCC 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043CE6 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043D00 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043D1A 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043D33 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043D4C 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043D62 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043D78 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043D8A 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043DA3 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043DBC 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043DD5 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043DEE 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043E07 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043E20 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043E39 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043E52 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043E6B 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043E84 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043E9D 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043EB6 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043ECF 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043EE8 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043F01 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043F1A 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043F33 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043F4C 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043F65 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043F7E 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043F97 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043FB0 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043FC9 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043FE2 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043FFB 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
044014 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04402D 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044046 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04405F 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044078 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
044091 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0440AA 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0440C0 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0440D6 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
0440EC 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
044105 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
044118 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
044131 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
04414A 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
044163 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
04417C 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
044195 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
0441AE 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
0441C7 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
0441E0 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0441F9 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
044212 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
04422B 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
044244 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
04425D 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044276 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
04428F 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
0442A8 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
0442C1 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0442DA 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0442F3 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
04430C 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
044325 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
04433E 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044357 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044370 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
044389 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
0443A2 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
0443BB 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0443D4 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
0443ED 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044406 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04441F 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044438             0071   	include "images_ui.inc"
044438             0001*  ; Generated by make_images.py
044438             0002*  
044438             0003*  ui_num_images: equ 2
044438             0004*  
044438             0005*  ; buffer_ids:
044438             0006*  BUF_SPLASH_BG: equ 0
044438             0007*  BUF_SPLASH_LOGO: equ 1
044438             0008*  
044438             0009*  ui_image_list: ; type; width; height; filename; bufferId:
044438 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       5C 44 04 00 
       00 00       
04444A 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       6F 44 04 01 
       00 00       
04445C             0012*  
04445C             0013*  ; files_list: ; filename:
04445C 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04446F 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
044484             0072   	include "files.inc"
044484             0001*  ; load to onboard 8k sram
044484             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
044484             0073   
044484 57 65 6C 63 0074   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
04449F 4C 6F 61 64 0075   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
0444AA 4C 6F 61 64 0076   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0444B8 50 72 65 73 0077   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0444D3             0078   
0444D3             0079   init:
0444D3             0080   ; clear all buffers
0444D3 CD 14 1F 04 0081       call vdu_clear_all_buffers
0444D7             0082   
0444D7             0083   ; set up the display
0444D7 3E 88       0084       ld a,8+128 ; 136   320   240   64    60hz double-buffered
0444D9 CD FE 1D 04 0085       call vdu_set_screen_mode
0444DD AF          0086       xor a
0444DE CD 0F 1E 04 0087       call vdu_set_scaling
0444E2             0088   
0444E2             0089   ; ; enable additional audio channels
0444E2             0090   ; 	call vdu_enable_channels
0444E2             0091   
0444E2             0092   ; set text background color
0444E2 3E 84       0093   	ld a,4 + 128
0444E4 CD 66 1D 04 0094   	call vdu_colour_text
0444E8             0095   
0444E8             0096   ; set text foreground color
0444E8 3E 2F       0097   	ld a,47 ; aaaaff lavenderish
0444EA CD 66 1D 04 0098   	call vdu_colour_text
0444EE             0099   
0444EE             0100   ; set gfx bg color
0444EE AF          0101   	xor a ; plotting mode 0
0444EF 0E 84       0102   	ld c,4+128 ; dark blue bg
0444F1 CD 77 1D 04 0103   	call vdu_gcol
0444F5 CD 48 1D 04 0104   	call vdu_clg
0444F9             0105   
0444F9             0106   ; set the cursor off
0444F9 CD FD 1C 04 0107   	call vdu_cursor_off
0444FD             0108   
0444FD             0109   ; VDU 28, left, bottom, right, top: Set text viewport **
0444FD             0110   ; MIND THE LITTLE-ENDIANESS
0444FD             0111   ; inputs: c=left,b=bottom,e=right,d=top
0444FD 0E 00       0112   	ld c,0 ; left
0444FF 16 1D       0113   	ld d,29 ; top
044501 1E 27       0114   	ld e,39 ; right
044503 06 1D       0115   	ld b,29; bottom
044505 CD 8E 1D 04 0116   	call vdu_set_txt_viewport
044509             0117   
044509             0118   ; print loading ui message
044509 21 9F 44 04 0119   	ld hl,loading_ui
04450D CD D3 16 04 0120   	call printString
044511 CD 3A 1D 04 0121   	call vdu_flip
044515             0122   
044515             0123   ; load UI images
044515 CD 7E 34 04 0124   	call load_ui_images
044519             0125   
044519             0126   ; ; load fonts ; TODO
044519             0127   ; 	call load_font_rc
044519             0128   
044519             0129   ; load sprites
044519 CD 03 35 04 0130   	call img_load_init ; sets up the animated load screen
04451D CD 99 34 04 0131   	call load_sprite_images
044521             0132   
044521             0133   ; ; load sound effects ; TODO
044521             0134   ; 	ld bc,SFX_num_buffers
044521             0135   ; 	ld hl,SFX_buffer_id_lut
044521             0136   ; 	ld (cur_buffer_id_lut),hl
044521             0137   ; 	ld hl,SFX_load_routines_table
044521             0138   ; 	ld (cur_load_jump_table),hl
044521             0139   ; 	call sfx_load_main
044521             0140   
044521             0141   ; print loading complete message and wait for user keypress
044521 CD 35 1D 04 0142   	call vdu_cls
044525 21 B8 44 04 0143   	ld hl,loading_complete
044529 CD D3 16 04 0144   	call printString
04452D CD 3A 1D 04 0145   	call vdu_flip
044531 CD 71 1C 04 0146   	call waitKeypress
044535             0147   
044535             0148   ; set up display for gameplay
044535             0149       ; ld a,8
044535 3E 14       0150   	ld a,20
044537 CD FE 1D 04 0151       call vdu_set_screen_mode
04453B AF          0152       xor a
04453C CD 0F 1E 04 0153       call vdu_set_scaling
044540 01 20 00 00 0154   	ld bc,32
044544 11 10 00 00 0155   	ld de,16
044548 CD BA 1D 04 0156   	call vdu_set_gfx_origin
04454C CD FD 1C 04 0157   	call vdu_cursor_off
044550             0158   ; set gfx viewport to scrolling window
044550 01 00 00 00 0159   	ld bc,0
044554 11 00 00 00 0160   	ld de,0
044558 DD 21 FF 00 0161   	ld ix,255
       00          
04455D FD 21 DF 00 0162   	ld iy,239-16
       00          
044562 CD D5 1D 04 0163   	call vdu_set_gfx_viewport
044566             0164   
044566 C9          0165   	ret
044567             0166   
044567             0167   new_game:
044567             0168   ; initialize sprites
044567 CD 7B 16 04 0169   	call sprites_init
04456B             0170   
04456B             0171   ; initialize the first level
04456B AF          0172   	xor a
04456C 32 B5 2F 04 0173   	ld (cur_level),a
044570 CD 3D 30 04 0174   	call init_level
044574             0175   
044574             0176   ; initialize player
044574 CD DB 2E 04 0177   	call player_init
044578             0178   
044578             0179   ; spawn an enemy sprite
044578 06 01       0180   	ld b,table_max_records
04457A             0181   @spawn_enemy_loop:
04457A C5          0182   	push bc
04457B CD 94 31 04 0183   	call enemy_init_from_landing_pad
04457F C1          0184   	pop bc
044580 10 F8       0185   	djnz @spawn_enemy_loop
044582             0186   
044582 C9          0187   	ret
044583             0188   
044583             0189   ; ; ###### INITIALIZE GAME #######
044583             0190   ; ; clear the screen
044583             0191   ;     ld a,3
044583             0192   ;     out (81h),a
044583             0193   
044583             0194   ; ; reset the sprite table
044583             0195   ;     xor a
044583             0196   ;     ld (table_active_sprites),a
044583             0197   ;     ld hl,table_limit
044583             0198   ;     ld (table_base),hl
044583             0199   ;     ld (table_pointer),hl
044583             0200   
044583             0201   ; ; draw a starfield over the entire screen
044583             0202   ;     ld b,#50 ; first row of visible screen
044583             0203   ; new_game_draw_stars_loop:
044583             0204   ;     push bc
044583             0205   ;     call draw_stars
044583             0206   ;     pop bc
044583             0207   ;     ld a,#10
044583             0208   ;     add a,b
044583             0209   ;     ld b,a
044583             0210   ;     jr nz,new_game_draw_stars_loop
044583             0211   
044583             0212   ; ; ; print a welcome message
044583             0213   ; ;     ld de,msg_welcome
044583             0214   ; ;     ld hl,#581C
044583             0215   ; ;     ld c,218 ; a bright pastel purple d677e3
044583             0216   ; ;     call print_string
044583             0217   
044583             0218   ; ; push all that to frame buffer
044583             0219   ;     ld a,#01 ; send video to frame buffer
044583             0220   ;     out (81h),a
044583             0221   
044583             0222   ; ; reset score, lives, shields
044583             0223   ;     xor a
044583             0224   ;     ld hl,player_score
044583             0225   ;     ld (hl),a ; player_score 0
044583             0226   ;     inc hl
044583             0227   ;     ld (hl),a ; player_score 1
044583             0228   ;     inc hl
044583             0229   ;     ld (hl),a ; player_score 3
044583             0230   ;     inc hl
044583             0231   ;     ld a,16
044583             0232   ;     ld (hl),a ; player_shields
044583             0233   ;     inc hl
044583             0234   ;     ld (hl),a ; player_max_shields
044583             0235   ;     inc hl
044583             0236   ;     ld a,3
044583             0237   ;     ld (hl),a ; player_ships
044583             0238   ;     inc hl
044583             0239   
044583             0240   ; ; initialize first level
044583             0241   ;     ld a,1 ; levels are zero-based, so this will wrap around
044583             0242   ;     ld (cur_level),a
044583             0243   ;     ld a,3 ; set max enemy sprites to easy street
044583             0244   ;     ld (max_enemy_sprites),a
044583             0245   ;     call dt_next_level
044583             0246   ;     call dt
044583             0247   
044583             0248   ; ; spawn our intrepid hero
044583             0249   ;     call player_init
044583             0250   
044583             0251   ; ; #### BEGIN GAME VARIABLES ####
044583             0252   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
044583             0253   speed_player: equ 0x000300 ; 3 pixels per frame
044583             0254   
044583             0255   main:
044583             0256   ; start a new game
044583 CD 67 45 04 0257   	call new_game
044587             0258   
044587             0259   main_loop:
044587             0260   ; move the background down one pixel
044587 3E 02       0261   	ld a,2 ; current gfx viewport
044589 2E 02       0262   	ld l,2 ; direction=down
04458B 26 01       0263   	ld h,1 ; speed=1 px
04458D CD 4D 1D 04 0264   	call vdu_scroll_down
044591             0265   
044591             0266   ; scroll tiles
044591 CD C2 2F 04 0267   	call tiles_plot
044595             0268   
044595             0269   ; get player input and update sprite position
044595 CD 1A 2F 04 0270   	call player_input
044599             0271   
044599             0272   ; move enemies
044599 CD 9C 30 04 0273   	call move_enemies
04459D             0274   
04459D             0275   ; wait for the next vblank mitigate flicker and for loop timing
04459D CD A9 1D 04 0276   	call vdu_vblank
0445A1             0277   
0445A1             0278   ; poll keyboard
0445A1 3E 08       0279       ld a, $08                           ; code to send to MOS
0445A3 5B CF       0280       rst.lil $08                         ; get IX pointer to System Variables
0445A5             0281   
0445A5 DD 7E 05    0282       ld a, (ix + $05)                    ; get ASCII code of key pressed
0445A8 FE 1B       0283       cp 27                               ; check if 27 (ascii code for ESC)
0445AA CA B2 45 04 0284       jp z, main_end                     ; if pressed, jump to exit
0445AE             0285   
0445AE C3 87 45 04 0286       jp main_loop
0445B2             0287   
0445B2             0288   main_end:
0445B2 CD EF 1C 04 0289       call vdu_cursor_on
0445B6 C9          0290   	ret
0445B7             0291   
0445B7             0292   
0445B7             0293   ; ; #### BEGIN GAME MAIN LOOP ####
0445B7             0294   ; main_loop:
0445B7             0295   ; ; ; debug: start execution counter
0445B7             0296   ; ;     ld a,1
0445B7             0297   ; ;     out (#e0),a ; start counting instructions
0445B7             0298   
0445B7             0299   ; ; refresh background from frame buffer
0445B7             0300   ;     ld a,#02
0445B7             0301   ;     out (81h),a
0445B7             0302   ;     call move_background ; now move it
0445B7             0303   ;     ld a,#01
0445B7             0304   ;     out (81h),a ; save it back to buffer
0445B7             0305   ; ; do all the things
0445B7             0306   ;     call move_enemies
0445B7             0307   ;     call player_move
0445B7             0308   ;     call laser_control
0445B7             0309   ;     call print_score
0445B7             0310   ;     call draw_shields
0445B7             0311   ;     call draw_lives
0445B7             0312   ; ; ; debug: stop execution counter and print results
0445B7             0313   ; ;     ld a,0
0445B7             0314   ; ;     out (#e0),a ; stop counting instructions
0445B7             0315   
0445B7             0316   ; ; ; debug: start execution counter
0445B7             0317   ; ;     ld a,1
0445B7             0318   ; ;     out (#e0),a ; start counting instructions
0445B7             0319   
0445B7             0320   ;     call vdu_vblank
0445B7             0321   ; ; ; debug: stop execution counter and print results
0445B7             0322   ; ;     ld a,0
0445B7             0323   ; ;     out (#e0),a ; stop counting instructions
0445B7             0324   
0445B7             0325   ;     jr main_loop
0445B7             0326   ; #### END GAME MAIN LOOP ####
0445B7             0327   
0445B7             0328   ; draws the player's shields level
0445B7             0329   ; draw_shields:
0445B7             0330   ; TODO: Agonize this routine
0445B7             0331   ; ; prep the loop to draw the bars
0445B7             0332   ;     ld a,(player_shields) ; snag shields
0445B7             0333   ;     and a
0445B7             0334   ;     ret z ; don't draw if zero shields
0445B7             0335   ; ; set loop counter and drawing position
0445B7             0336   ;     ld b,a ; loop counter
0445B7             0337   ;     ld hl,#5300+48+12
0445B7             0338   ; ; set color based on bars remaining
0445B7             0339   ;     ld c,103 ; bright green 28fe0a
0445B7             0340   ;     cp 9
0445B7             0341   ;     jp p,draw_shields_loop
0445B7             0342   ;     ld c,74 ; bright yellow eafe5b
0445B7             0343   ;     cp 3
0445B7             0344   ;     jp p,draw_shields_loop
0445B7             0345   ;     ld c,28 ; bright red fe0a0a
0445B7             0346   ; draw_shields_loop:
0445B7             0347   ;     push bc ; yup,outta
0445B7             0348   ;     push hl ; registers again
0445B7             0349   ;     ; ld a,#A8 ; ▀,168
0445B7             0350   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
0445B7             0351   ;     ; call draw_char
0445B7             0352   ;     call draw_num ; we nuked draw_char for the time being
0445B7             0353   ;     pop hl
0445B7             0354   ;     ld a,8
0445B7             0355   ;     add a,l
0445B7             0356   ;     ld l,a
0445B7             0357   ;     pop bc
0445B7             0358   ;     djnz draw_shields_loop
0445B7             0359       ; ret
0445B7             0360   
0445B7             0361   ; prints the player's score
0445B7             0362   ; print_score:
0445B7             0363   ; TODO: Agonize this
0445B7             0364   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0445B7             0365   ;     ld c,42 ; dark orange b74400
0445B7             0366   ;     ld hl,#5200+1+8+6*6
0445B7             0367   ;     ld a,3 ; print 6 bdc digits
0445B7             0368   ;     ld de,player_score
0445B7             0369   ;     call print_num
0445B7             0370   
0445B7             0371   ;     ld c,58 ; golden yellow fec10a
0445B7             0372   ;     ld hl,#5100+8+6*6
0445B7             0373   ;     ld a,3 ; print 6 bdc digits
0445B7             0374   ;     ld de,player_score
0445B7             0375   ;     call print_num
0445B7             0376       ; ret
0445B7             0377   
0445B7             0378   ; draw_lives:
0445B7             0379   ;     ld hl,player_small ; make small yellow ship the active sprite
0445B7             0380   ;     ld (sprite_base_bufferId),hl
0445B7             0381   ;     ; ld a,#80 ; northern orientation
0445B7             0382   ;     ; ld (sprite_orientation),a
0445B7             0383   ;     ld hl,0 ; north
0445B7             0384   ;     ld (sprite_heading),hl
0445B7             0385   ;     xor a
0445B7             0386   ;     ld (sprite_animation),a
0445B7             0387   ;     ld a,#56 ; top of visible screen
0445B7             0388   ;     ld (sprite_y+1),a
0445B7             0389   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0445B7             0390   ;     ld a,(player_ships)
0445B7             0391   ;     dec a ; we draw one fewer ships than lives
0445B7             0392   ;     ret z ; nothing to draw here, move along
0445B7             0393   ;     ld b,a ; loop counter
0445B7             0394   ;     ld a,256-16 ; initial x position
0445B7             0395   ; draw_lives_loop:
0445B7             0396   ;     ld (sprite_x+1),a
0445B7             0397   ;     push af
0445B7             0398   ;     push bc
0445B7             0399   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0445B7             0400   ;     pop bc
0445B7             0401   ;     pop af
0445B7             0402   ;     sub 10
0445B7             0403   ;     djnz draw_lives_loop
0445B7             0404   ;     ret
