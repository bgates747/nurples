PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 39 42 04 0030   	call	init			; Initialization code
040050 CD E9 42 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04167A             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
04167A             0033*  
04167A             0034*  ; pointer to top address of current record, initialized to table_base
04167A E2 15 04    0035*  table_pointer: dl table_base
04167D             0036*  ; how many active sprites
04167D 00          0037*  table_active_sprites: db 0x00
04167E             0038*  ; flag indicating collision with screen edge
04167E             0039*  ; uses orientation codes to specify which edge(s)
04167E 00          0040*  sprite_screen_edge: db #00
04167F             0041*  ; next sprite id to use
04167F 00          0042*  sprite_next_id: db 0
041680             0043*  
041680             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041680             0045*  ; integer coordinates are all that are needed for collision calculations
041680 00          0046*  collision_x: db 0x00
041681 00          0047*  collision_y: db 0x00
041682 00          0048*  collision_dim_x: db 0x00
041683 00          0049*  collision_dim_y: db 0x00
041684             0050*  
041684             0051*  ; scratch variables
041684 00          0052*  x: db 0x00 ; 8-bit signed integer
041685 00          0053*  y: db 0x00 ; 8-bit signed integer
041686 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041689 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04168C 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04168F 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041692 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041695 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041698             0060*  
041698             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041698 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04169B 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04169E 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
0416A1             0065*  
0416A1             0066*  ; gets the next available sprite id
0416A1             0067*  ; inputs; none
0416A1             0068*  ; returns: if new sprite available, a = sprite id,
0416A1             0069*  ;           ix pointing to new sprite vars, carry set
0416A1             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
0416A1             0071*  ; destroys: a,b,hl,ix
0416A1             0072*  ; affects: bumps table_active_sprites by one
0416A1             0073*  table_get_next_id:
0416A1 DD 21 E2 15 0074*      ld ix,table_base
       04          
0416A6 11 26 00 00 0075*      ld de,table_bytes_per_record
0416AA 06 04       0076*      ld b,table_max_records
0416AC             0077*  @loop:
0416AC DD 7E 01    0078*      ld a,(ix+sprite_type)
0416AF A7          0079*      and a
0416B0 28 06       0080*      jr z,@found
0416B2 DD 19       0081*      add ix,de
0416B4 10 F6       0082*      djnz @loop
0416B6             0083*  @notfound:
0416B6 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
0416B7 C9          0085*      ret
0416B8             0086*  @found:
0416B8             0087*  ; bump number of active sprites
0416B8 21 7D 16 04 0088*      ld hl,table_active_sprites
0416BC 34          0089*      inc (hl)
0416BD             0090*  ; return sprite id
0416BD 3E 04       0091*      ld a,table_max_records
0416BF 90          0092*      sub b
0416C0 32 7F 16 04 0093*      ld (sprite_next_id),a
0416C4 37          0094*      scf ; sets carry flag indicating we found a free sprite
0416C5 C9          0095*      ret ; done
0416C6             0096*  
0416C6             0097*  ; deactivate the sprite with the given id
0416C6             0098*  ; inputs: a = sprite id
0416C6             0099*  ; outputs: nothing
0416C6             0100*  ; destroys: a,ix,de
0416C6             0101*  ; affects: decrements table_active_sprites by one
0416C6             0102*  table_deactivate_sprite:
0416C6 F5          0103*      push af ; save sprite id bc we need it later
0416C7 CD C9 1F 04 0104*      call vdu_sprite_select
0416CB CD 4D 20 04 0105*      call vdu_sprite_hide
0416CF F1          0106*      pop af ; restore sprite id
0416D0 11 00 00 00 0107*      ld de,0 ; clear deu
0416D4 57          0108*      ld d,a
0416D5 1E 26       0109*      ld e,table_bytes_per_record
0416D7 ED 5C       0110*      mlt de
0416D9 DD 21 E2 15 0111*      ld ix,table_base
       04          
0416DE DD 19       0112*      add ix,de
0416E0 AF          0113*      xor a
0416E1 DD 77 01    0114*      ld (ix+sprite_type),a
0416E4 DD 21 7D 16 0115*      ld ix,table_active_sprites
       04          
0416E9 DD 35 00    0116*      dec (ix)
0416EC C9          0117*      ret
0416ED             0118*  
0416ED             0119*  sprites_init:
0416ED             0120*  ; initialize sprites
0416ED CD F5 20 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0416F1 AF          0122*  	xor a
0416F2             0123*  @sprite_loop:
0416F2 F5          0124*  	push af
0416F3 CD C9 1F 04 0125*  	call vdu_sprite_select
0416F7 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0416FB CD 16 21 04 0127*  	call vdu_sprite_add_buff
0416FF F1          0128*  	pop af
041700 3C          0129*  	inc a
041701 FE 05       0130*  	cp table_max_records+1 ; tack on sprites for player and laser
041703 20 ED       0131*  	jr nz,@sprite_loop
041705 3C          0132*  	inc a
041706 CD FD 1F 04 0133*  	call vdu_sprite_activate
04170A             0134*  
04170A             0135*  ; define player sprite
04170A 3A F7 2B 04 0136*  	ld a,(player_id)
04170E CD C9 1F 04 0137*  	call vdu_sprite_select
041712 CD DC 1F 04 0138*  	call vdu_sprite_clear_frames
041716 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
04171A 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
04171E             0141*  @sprite_player_loop:
04171E C5          0142*  	push bc
04171F E5          0143*  	push hl
041720 CD 16 21 04 0144*  	call vdu_sprite_add_buff
041724 E1          0145*  	pop hl
041725 23          0146*  	inc hl
041726 C1          0147*  	pop bc
041727 10 F5       0148*  	djnz @sprite_player_loop
041729 CD 3F 20 04 0149*  	call vdu_sprite_show
04172D             0150*  
04172D             0151*  ; all done
04172D C9          0152*      ret
04172E             0050   ; API includes
04172E             0051       include "mos_api.inc"
04172E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04172E             0002*  ; Title:	AGON MOS - API for user projects
04172E             0003*  ; Author:	Dean Belfield
04172E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04172E             0005*  ;			Added MOS error codes for return in HL
04172E             0006*  ; Created:	03/08/2022
04172E             0007*  ; Last Updated:	10/08/2023
04172E             0008*  ;
04172E             0009*  ; Modinfo:
04172E             0010*  ; 05/08/2022:	Added mos_feof
04172E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04172E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04172E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04172E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04172E             0015*  ; 13/10/2022:	Added mos_oscli
04172E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04172E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04172E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04172E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04172E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04172E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04172E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04172E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04172E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04172E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04172E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04172E             0027*  ; 03/08/2023:	Added mos_setkbvector
04172E             0028*  ; 10/08/2023:	Added mos_getkbmap
04172E             0029*  
04172E             0030*  ; VDP control (VDU 23, 0, n)
04172E             0031*  ;
04172E             0032*  vdp_gp:				EQU 80h
04172E             0033*  vdp_keycode:		EQU 81h
04172E             0034*  vdp_cursor:			EQU	82h
04172E             0035*  vdp_scrchar:		EQU	83h
04172E             0036*  vdp_scrpixel:		EQU	84h
04172E             0037*  vdp_audio:			EQU	85h
04172E             0038*  vdp_mode:			EQU	86h
04172E             0039*  vdp_rtc:			EQU	87h
04172E             0040*  vdp_keystate:		EQU	88h
04172E             0041*  vdp_logicalcoords:	EQU	C0h
04172E             0042*  vdp_terminalmode:	EQU	FFh
04172E             0043*  
04172E             0044*  ; MOS high level functions
04172E             0045*  ;
04172E             0046*  mos_getkey:			EQU	00h
04172E             0047*  mos_load:			EQU	01h
04172E             0048*  mos_save:			EQU	02h
04172E             0049*  mos_cd:				EQU	03h
04172E             0050*  mos_dir:			EQU	04h
04172E             0051*  mos_del:			EQU	05h
04172E             0052*  mos_ren:			EQU	06h
04172E             0053*  mos_mkdir:			EQU	07h
04172E             0054*  mos_sysvars:		EQU	08h
04172E             0055*  mos_editline:		EQU	09h
04172E             0056*  mos_fopen:			EQU	0Ah
04172E             0057*  mos_fclose:			EQU	0Bh
04172E             0058*  mos_fgetc:			EQU	0Ch
04172E             0059*  mos_fputc:			EQU	0Dh
04172E             0060*  mos_feof:			EQU	0Eh
04172E             0061*  mos_getError:		EQU	0Fh
04172E             0062*  mos_oscli:			EQU	10h
04172E             0063*  mos_copy:			EQU	11h
04172E             0064*  mos_getrtc:			EQU	12h
04172E             0065*  mos_setrtc:			EQU	13h
04172E             0066*  mos_setintvector:	EQU	14h
04172E             0067*  mos_uopen:			EQU	15h
04172E             0068*  mos_uclose:			EQU	16h
04172E             0069*  mos_ugetc:			EQU	17h
04172E             0070*  mos_uputc:			EQU	18h
04172E             0071*  mos_getfil:			EQU	19h
04172E             0072*  mos_fread:			EQU	1Ah
04172E             0073*  mos_fwrite:			EQU	1Bh
04172E             0074*  mos_flseek:			EQU	1Ch
04172E             0075*  mos_setkbvector:	EQU	1Dh
04172E             0076*  mos_getkbmap:		EQU	1Eh
04172E             0077*  
04172E             0078*  ; MOS program exit codes
04172E             0079*  ;
04172E             0080*  EXIT_OK:				EQU  0;	"OK",
04172E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04172E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04172E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04172E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04172E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04172E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04172E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04172E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04172E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04172E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04172E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04172E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04172E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04172E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04172E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04172E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04172E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04172E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04172E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04172E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04172E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04172E             0102*  ; FatFS file access functions
04172E             0103*  ;
04172E             0104*  ffs_fopen:			EQU	80h
04172E             0105*  ffs_fclose:			EQU	81h
04172E             0106*  ffs_fread:			EQU	82h
04172E             0107*  ffs_fwrite:			EQU	83h
04172E             0108*  ffs_flseek:			EQU	84h
04172E             0109*  ffs_ftruncate:		EQU	85h
04172E             0110*  ffs_fsync:			EQU	86h
04172E             0111*  ffs_fforward:		EQU	87h
04172E             0112*  ffs_fexpand:		EQU	88h
04172E             0113*  ffs_fgets:			EQU	89h
04172E             0114*  ffs_fputc:			EQU	8Ah
04172E             0115*  ffs_fputs:			EQU	8Bh
04172E             0116*  ffs_fprintf:		EQU	8Ch
04172E             0117*  ffs_ftell:			EQU	8Dh
04172E             0118*  ffs_feof:			EQU	8Eh
04172E             0119*  ffs_fsize:			EQU	8Fh
04172E             0120*  ffs_ferror:			EQU	90h
04172E             0121*  
04172E             0122*  ; FatFS directory access functions
04172E             0123*  ;
04172E             0124*  ffs_dopen:			EQU	91h
04172E             0125*  ffs_dclose:			EQU	92h
04172E             0126*  ffs_dread:			EQU	93h
04172E             0127*  ffs_dfindfirst:		EQU	94h
04172E             0128*  ffs_dfindnext:		EQU	95h
04172E             0129*  
04172E             0130*  ; FatFS file and directory management functions
04172E             0131*  ;
04172E             0132*  ffs_stat:			EQU	96h
04172E             0133*  ffs_unlink:			EQU	97h
04172E             0134*  ffs_rename:			EQU	98h
04172E             0135*  ffs_chmod:			EQU	99h
04172E             0136*  ffs_utime:			EQU	9Ah
04172E             0137*  ffs_mkdir:			EQU	9Bh
04172E             0138*  ffs_chdir:			EQU	9Ch
04172E             0139*  ffs_chdrive:		EQU	9Dh
04172E             0140*  ffs_getcwd:			EQU	9Eh
04172E             0141*  
04172E             0142*  ; FatFS volume management and system configuration functions
04172E             0143*  ;
04172E             0144*  ffs_mount:			EQU	9Fh
04172E             0145*  ffs_mkfs:			EQU	A0h
04172E             0146*  ffs_fdisk:			EQU	A1h
04172E             0147*  ffs_getfree:		EQU	A2h
04172E             0148*  ffs_getlabel:		EQU	A3h
04172E             0149*  ffs_setlabel:		EQU	A4h
04172E             0150*  ffs_setcp:			EQU	A5h
04172E             0151*  
04172E             0152*  ; File access modes
04172E             0153*  ;
04172E             0154*  fa_read:			EQU	01h
04172E             0155*  fa_write:			EQU	02h
04172E             0156*  fa_open_existing:	EQU	00h
04172E             0157*  fa_create_new:		EQU	04h
04172E             0158*  fa_create_always:	EQU	08h
04172E             0159*  fa_open_always:		EQU	10h
04172E             0160*  fa_open_append:		EQU	30h
04172E             0161*  
04172E             0162*  ; System variable indexes for api_sysvars
04172E             0163*  ; Index into _sysvars in globals.inc
04172E             0164*  ;
04172E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04172E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04172E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04172E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04172E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04172E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04172E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04172E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04172E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04172E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04172E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04172E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04172E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04172E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04172E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04172E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04172E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04172E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04172E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04172E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04172E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04172E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04172E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04172E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04172E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04172E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04172E             0191*  
04172E             0192*  ; Flags for the VPD protocol
04172E             0193*  ;
04172E             0194*  vdp_pflag_cursor:		EQU	00000001b
04172E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04172E             0196*  vdp_pflag_point:		EQU	00000100b
04172E             0197*  vdp_pflag_audio:		EQU	00001000b
04172E             0198*  vdp_pflag_mode:			EQU	00010000b
04172E             0199*  vdp_pflag_rtc:			EQU	00100000b
04172E             0200*  
04172E             0201*  ;
04172E             0202*  ; FatFS structures
04172E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04172E             0204*  ;
04172E             0205*  ; Object ID and allocation information (FFOBJID)
04172E             0206*  ;
04172E             0207*  ; Indexes into FFOBJID structure
04172E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04172E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04172E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04172E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04172E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04172E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04172E             0214*  ;
04172E             0215*  ; File object structure (FIL)
04172E             0216*  ;
04172E             0217*  ; Indexes into FIL structure
04172E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04172E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04172E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04172E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04172E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04172E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04172E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04172E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04172E             0226*  ;
04172E             0227*  ; Directory object structure (DIR)
04172E             0228*  ; Indexes into DIR structure
04172E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04172E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04172E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04172E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04172E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04172E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04172E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04172E             0236*  ;
04172E             0237*  ; File information structure (FILINFO)
04172E             0238*  ;
04172E             0239*  ; Indexes into FILINFO structure
04172E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04172E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04172E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04172E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04172E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04172E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04172E             0246*  ;
04172E             0247*  ; Macro for calling the API
04172E             0248*  ; Parameters:
04172E             0249*  ; - function: One of the function numbers listed above
04172E             0250*  ;
04172E             0251*  	MACRO	MOSCALL	function
04172E             0252*  			LD	A, function
04172E             0253*  			RST.LIL	08h
04172E             0254*  	ENDMACRO
04172E             0052       include "functions.inc"
04172E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04172E             0002*  ; Print a zero-terminated string
04172E             0003*  ; HL: Pointer to string
04172E             0004*  printString:
04172E C5          0005*  	PUSH	BC
04172F 01 00 00 00 0006*  	LD		BC,0
041733 3E 00       0007*  	LD 	 	A,0
041735 5B DF       0008*  	RST.LIL 18h
041737 C1          0009*  	POP		BC
041738 C9          0010*  	RET
041739             0011*  ; print a VDU sequence
041739             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
041739             0013*  sendVDUsequence:
041739 C5          0014*  	PUSH	BC
04173A 01 00 00 00 0015*  	LD		BC, 0
04173E 4E          0016*  	LD		C, (HL)
04173F 5B DF       0017*  	RST.LIL	18h
041741 C1          0018*  	POP		BC
041742 C9          0019*  	RET
041743             0020*  ; Print Newline sequence to VDP
041743             0021*  printNewLine:
041743 3E 0D       0022*  	LD	A, '\r'
041745 5B D7       0023*  	RST.LIL 10h
041747 3E 0A       0024*  	LD	A, '\n'
041749 5B D7       0025*  	RST.LIL 10h
04174B C9          0026*  	RET
04174C             0027*  ; Print a 24-bit HEX number
04174C             0028*  ; HLU: Number to print
04174C             0029*  printHex24:
04174C E5          0030*  	PUSH	HL
04174D 21 02 00 00 0031*  	LD		HL, 2
041751 39          0032*  	ADD		HL, SP
041752 7E          0033*  	LD		A, (HL)
041753 E1          0034*  	POP		HL
041754 CD 5E 17 04 0035*  	CALL	printHex8
041758             0036*  ; Print a 16-bit HEX number
041758             0037*  ; HL: Number to print
041758             0038*  printHex16:
041758 7C          0039*  	LD		A,H
041759 CD 5E 17 04 0040*  	CALL	printHex8
04175D 7D          0041*  	LD		A,L
04175E             0042*  ; Print an 8-bit HEX number
04175E             0043*  ; A: Number to print
04175E             0044*  printHex8:
04175E 4F          0045*  	LD		C,A
04175F 1F          0046*  	RRA
041760 1F          0047*  	RRA
041761 1F          0048*  	RRA
041762 1F          0049*  	RRA
041763 CD 68 17 04 0050*  	CALL	@F
041767 79          0051*  	LD		A,C
041768             0052*  @@:
041768 E6 0F       0053*  	AND		0Fh
04176A C6 90       0054*  	ADD		A,90h
04176C 27          0055*  	DAA
04176D CE 40       0056*  	ADC		A,40h
04176F 27          0057*  	DAA
041770 5B D7       0058*  	RST.LIL	10h
041772 C9          0059*  	RET
041773             0060*  
041773             0061*  ; Print a 0x HEX prefix
041773             0062*  DisplayHexPrefix:
041773 3E 30       0063*  	LD	A, '0'
041775 5B D7       0064*  	RST.LIL 10h
041777 3E 78       0065*  	LD	A, 'x'
041779 5B D7       0066*  	RST.LIL 10h
04177B C9          0067*  	RET
04177C             0068*  
04177C             0069*  
04177C             0070*  ; Prints the right justified decimal value in HL without leading zeroes
04177C             0071*  ; HL : Value to print
04177C             0072*  printDec:
04177C 11 A0 17 04 0073*  	LD	 DE, _printDecBuffer
041780 CD A9 17 04 0074*  	CALL Num2String
041784             0075*  ; BEGIN MY CODE
041784             0076*  ; replace leading zeroes with spaces
041784 21 A0 17 04 0077*      LD	 HL, _printDecBuffer
041788 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
04178A             0079*  @loop:
04178A 7E          0080*      LD	 A, (HL)
04178B FE 30       0081*      CP	 '0'
04178D C2 9B 17 04 0082*      JP	 NZ, @done
041791 3E 20       0083*      LD   A, ' '
041793 77          0084*      LD	 (HL), A
041794 23          0085*      INC	 HL
041795 CD 59 1B 04 0086*      CALL vdu_cursor_forward
041799 10 EF       0087*      DJNZ @loop
04179B             0088*  @done:
04179B             0089*  ; END MY CODE
04179B             0090*  	; LD	 HL, _printDecBuffer
04179B CD 2E 17 04 0091*  	CALL printString
04179F C9          0092*  	RET
0417A0 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0417A9             0094*  
0417A9             0095*  ; This routine converts the value from HL into it's ASCII representation,
0417A9             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0417A9             0097*  ; so it will allways be 8 characters length
0417A9             0098*  ; HL : Value to convert to string
0417A9             0099*  ; DE : pointer to buffer, at least 8 byte + 0
0417A9             0100*  Num2String:
0417A9 01 80 69 67 0101*  	LD	 BC,-10000000
0417AD CD E0 17 04 0102*  	CALL OneDigit
0417B1 01 C0 BD F0 0103*  	LD	 BC,-1000000
0417B5 CD E0 17 04 0104*  	CALL OneDigit
0417B9 01 60 79 FE 0105*  	LD	 BC,-100000
0417BD CD E0 17 04 0106*  	CALL OneDigit
0417C1 01 F0 D8 FF 0107*  	LD   BC,-10000
0417C5 CD E0 17 04 0108*  	CALL OneDigit
0417C9 01 18 FC FF 0109*  	LD   BC,-1000
0417CD CD E0 17 04 0110*  	CALL OneDigit
0417D1 01 9C FF FF 0111*  	LD   BC,-100
0417D5 CD E0 17 04 0112*  	CALL OneDigit
0417D9 0E F6       0113*  	LD   C,-10
0417DB CD E0 17 04 0114*  	CALL OneDigit
0417DF 48          0115*  	LD   C,B
0417E0             0116*  OneDigit:
0417E0 3E 2F       0117*  	LD   A,'0'-1
0417E2             0118*  DivideMe:
0417E2 3C          0119*  	INC  A
0417E3 09          0120*  	ADD  HL,BC
0417E4 38 FC       0121*  	JR   C,DivideMe
0417E6 ED 42       0122*  	SBC  HL,BC
0417E8 12          0123*  	LD   (DE),A
0417E9 13          0124*  	INC  DE
0417EA C9          0125*  	RET
0417EB             0126*  
0417EB             0127*  
0417EB             0128*  ; #### new functions added by Brandon R. Gates ####
0417EB             0129*  
0417EB             0130*  ; print the binary representation of the 8-bit value in a
0417EB             0131*  ; destroys a, hl, bc
0417EB             0132*  printBin8:
0417EB 06 08       0133*      ld b,8      ; loop counter for 8 bits
0417ED 21 08 18 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
0417F1             0135*                  ; (which will be the high bit of the value in a)
0417F1             0136*  @loop:
0417F1 07          0137*      rlca ; put the next highest bit into carry
0417F2 38 04       0138*      jr c,@one
0417F4 36 30       0139*      ld (hl),'0'
0417F6 18 02       0140*      jr @next_bit
0417F8             0141*  @one:
0417F8 36 31       0142*      ld (hl),'1'
0417FA             0143*  @next_bit:
0417FA 23          0144*      inc hl
0417FB 10 F4       0145*      djnz @loop
0417FD             0146*  ; print it
0417FD 21 08 18 04 0147*  	ld hl,@cmd
041801 01 08 00 00 0148*  	ld bc,@end-@cmd
041805 5B DF       0149*  	rst.lil $18
041807 C9          0150*  	ret
041808             0151*  @cmd: ds 8 ; eight bytes for eight bits
041810             0152*  @end:
041810             0153*  
041810             0154*  ; print the binary representation of the 8-bit value in a
041810             0155*  ; in reverse order (lsb first)
041810             0156*  ; destroys a, hl, bc
041810             0157*  printBin8Rev:
041810 06 08       0158*      ld b,8      ; loop counter for 8 bits
041812 21 2D 18 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
041816             0160*                  ; (which will be the high bit of the value in a)
041816             0161*  @loop:
041816 0F          0162*      rrca ; put the next lowest bit into carry
041817 38 04       0163*      jr c,@one
041819 36 30       0164*      ld (hl),'0'
04181B 18 02       0165*      jr @next_bit
04181D             0166*  @one:
04181D 36 31       0167*      ld (hl),'1'
04181F             0168*  @next_bit:
04181F 23          0169*      inc hl
041820 10 F4       0170*      djnz @loop
041822             0171*  ; print it
041822 21 2D 18 04 0172*  	ld hl,@cmd
041826 01 08 00 00 0173*  	ld bc,@end-@cmd
04182A 5B DF       0174*  	rst.lil $18
04182C C9          0175*  	ret
04182D             0176*  @cmd: ds 8 ; eight bytes for eight bits
041835             0177*  @end:
041835             0178*  
041835             0179*  ; print registers to screen in hexidecimal format
041835             0180*  ; inputs: none
041835             0181*  ; outputs: values of every register printed to screen
041835             0182*  ;    values of each register in global scratch memory
041835             0183*  ; destroys: nothing
041835             0184*  stepRegistersHex:
041835             0185*  ; store everything in scratch
041835 22 34 1A 04 0186*      ld (uhl),hl
041839 ED 43 37 1A 0187*      ld (ubc),bc
       04          
04183E ED 53 3A 1A 0188*      ld (ude),de
       04          
041843 DD 22 3D 1A 0189*      ld (uix),ix
       04          
041848 FD 22 40 1A 0190*      ld (uiy),iy
       04          
04184D F5          0191*      push af ; fml
04184E E1          0192*      pop hl  ; thanks, zilog
04184F 22 31 1A 04 0193*      ld (uaf),hl
041853 F5          0194*      push af ; dammit
041854             0195*  
041854             0196*  ; home the cursor
041854 CD 27 1B 04 0197*      call vdu_home_cursor
041858             0198*  
041858             0199*  ; print each register
041858 21 BD 19 04 0200*      ld hl,str_afu
04185C CD 2E 17 04 0201*      call printString
041860 2A 31 1A 04 0202*      ld hl,(uaf)
041864 CD 4C 17 04 0203*      call printHex24
041868 CD 43 17 04 0204*      call printNewLine
04186C             0205*  
04186C 21 C1 19 04 0206*      ld hl,str_hlu
041870 CD 2E 17 04 0207*      call printString
041874 2A 34 1A 04 0208*      ld hl,(uhl)
041878 CD 4C 17 04 0209*      call printHex24
04187C CD 43 17 04 0210*      call printNewLine
041880             0211*  
041880 21 C5 19 04 0212*      ld hl,str_bcu
041884 CD 2E 17 04 0213*      call printString
041888 2A 37 1A 04 0214*      ld hl,(ubc)
04188C CD 4C 17 04 0215*      call printHex24
041890 CD 43 17 04 0216*      call printNewLine
041894             0217*  
041894 21 C9 19 04 0218*      ld hl,str_deu
041898 CD 2E 17 04 0219*      call printString
04189C 2A 3A 1A 04 0220*      ld hl,(ude)
0418A0 CD 4C 17 04 0221*      call printHex24
0418A4 CD 43 17 04 0222*      call printNewLine
0418A8             0223*  
0418A8 21 CD 19 04 0224*      ld hl,str_ixu
0418AC CD 2E 17 04 0225*      call printString
0418B0 2A 3D 1A 04 0226*      ld hl,(uix)
0418B4 CD 4C 17 04 0227*      call printHex24
0418B8 CD 43 17 04 0228*      call printNewLine
0418BC             0229*  
0418BC 21 D1 19 04 0230*      ld hl,str_iyu
0418C0 CD 2E 17 04 0231*      call printString
0418C4 2A 40 1A 04 0232*      ld hl,(uiy)
0418C8 CD 4C 17 04 0233*      call printHex24
0418CC CD 43 17 04 0234*      call printNewLine
0418D0             0235*  
0418D0             0236*      ; call vdu_vblank
0418D0             0237*  
0418D0 CD 43 17 04 0238*      call printNewLine
0418D4             0239*  
0418D4             0240*  ; check for right shift key and quit if pressed
0418D4             0241*  	MOSCALL mos_getkbmap
0418D4 3E 1E       0001*M 			LD	A, function
0418D6 5B CF       0002*M 			RST.LIL	08h
0418D8             0242*  @stayhere:
0418D8             0243*  ; 7 RightShift
0418D8 DD CB 00 76 0244*      bit 6,(ix+0)
0418DC 20 02       0245*      jr nz,@RightShift
0418DE 18 F8       0246*      jr @stayhere
0418E0             0247*  @RightShift:
0418E0 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
0418E4 3E 80       0249*      ld a,%10000000
0418E6 CD 90 31 04 0250*      call multiPurposeDelay
0418EA             0251*  
0418EA             0252*  ; restore everything
0418EA 2A 34 1A 04 0253*      ld hl, (uhl)
0418EE ED 4B 37 1A 0254*      ld bc, (ubc)
       04          
0418F3 ED 5B 3A 1A 0255*      ld de, (ude)
       04          
0418F8 DD 2A 3D 1A 0256*      ld ix, (uix)
       04          
0418FD FD 2A 40 1A 0257*      ld iy, (uiy)
       04          
041902 F1          0258*      pop af
041903             0259*  ; all done
041903 C9          0260*      ret
041904             0261*  
041904             0262*  ; print registers to screen in hexidecimal format
041904             0263*  ; inputs: none
041904             0264*  ; outputs: values of every register printed to screen
041904             0265*  ;    values of each register in global scratch memory
041904             0266*  ; destroys: nothing
041904             0267*  dumpRegistersHex:
041904             0268*  ; store everything in scratch
041904 22 34 1A 04 0269*      ld (uhl),hl
041908 ED 43 37 1A 0270*      ld (ubc),bc
       04          
04190D ED 53 3A 1A 0271*      ld (ude),de
       04          
041912 DD 22 3D 1A 0272*      ld (uix),ix
       04          
041917 FD 22 40 1A 0273*      ld (uiy),iy
       04          
04191C F5          0274*      push af ; fml
04191D E1          0275*      pop hl  ; thanks, zilog
04191E 22 31 1A 04 0276*      ld (uaf),hl
041922 F5          0277*      push af ; dammit
041923             0278*  
041923             0279*  ; home the cursor
041923 CD 27 1B 04 0280*      call vdu_home_cursor
041927             0281*  
041927             0282*  ; print each register
041927 21 BD 19 04 0283*      ld hl,str_afu
04192B CD 2E 17 04 0284*      call printString
04192F 2A 31 1A 04 0285*      ld hl,(uaf)
041933 CD 4C 17 04 0286*      call printHex24
041937 CD 43 17 04 0287*      call printNewLine
04193B             0288*  
04193B 21 C1 19 04 0289*      ld hl,str_hlu
04193F CD 2E 17 04 0290*      call printString
041943 2A 34 1A 04 0291*      ld hl,(uhl)
041947 CD 4C 17 04 0292*      call printHex24
04194B CD 43 17 04 0293*      call printNewLine
04194F             0294*  
04194F 21 C5 19 04 0295*      ld hl,str_bcu
041953 CD 2E 17 04 0296*      call printString
041957 2A 37 1A 04 0297*      ld hl,(ubc)
04195B CD 4C 17 04 0298*      call printHex24
04195F CD 43 17 04 0299*      call printNewLine
041963             0300*  
041963 21 C9 19 04 0301*      ld hl,str_deu
041967 CD 2E 17 04 0302*      call printString
04196B 2A 3A 1A 04 0303*      ld hl,(ude)
04196F CD 4C 17 04 0304*      call printHex24
041973 CD 43 17 04 0305*      call printNewLine
041977             0306*  
041977 21 CD 19 04 0307*      ld hl,str_ixu
04197B CD 2E 17 04 0308*      call printString
04197F 2A 3D 1A 04 0309*      ld hl,(uix)
041983 CD 4C 17 04 0310*      call printHex24
041987 CD 43 17 04 0311*      call printNewLine
04198B             0312*  
04198B 21 D1 19 04 0313*      ld hl,str_iyu
04198F CD 2E 17 04 0314*      call printString
041993 2A 40 1A 04 0315*      ld hl,(uiy)
041997 CD 4C 17 04 0316*      call printHex24
04199B CD 43 17 04 0317*      call printNewLine
04199F             0318*  
04199F             0319*      ; call vdu_vblank
04199F             0320*  
04199F CD 43 17 04 0321*      call printNewLine
0419A3             0322*  ; restore everything
0419A3 2A 34 1A 04 0323*      ld hl, (uhl)
0419A7 ED 4B 37 1A 0324*      ld bc, (ubc)
       04          
0419AC ED 5B 3A 1A 0325*      ld de, (ude)
       04          
0419B1 DD 2A 3D 1A 0326*      ld ix, (uix)
       04          
0419B6 FD 2A 40 1A 0327*      ld iy, (uiy)
       04          
0419BB F1          0328*      pop af
0419BC             0329*  ; all done
0419BC C9          0330*      ret
0419BD             0331*  
0419BD 61 66 3D 00 0332*  str_afu: db "af=",0
0419C1 68 6C 3D 00 0333*  str_hlu: db "hl=",0
0419C5 62 63 3D 00 0334*  str_bcu: db "bc=",0
0419C9 64 65 3D 00 0335*  str_deu: db "de=",0
0419CD 69 78 3D 00 0336*  str_ixu: db "ix=",0
0419D1 69 79 3D 00 0337*  str_iyu: db "iy=",0
0419D5             0338*  
0419D5             0339*  ; print udeuhl to screen in hexidecimal format
0419D5             0340*  ; inputs: none
0419D5             0341*  ; outputs: concatenated hexidecimal udeuhl
0419D5             0342*  ; destroys: nothing
0419D5             0343*  dumpUDEUHLHex:
0419D5             0344*  ; store everything in scratch
0419D5 22 34 1A 04 0345*      ld (uhl),hl
0419D9 ED 43 37 1A 0346*      ld (ubc),bc
       04          
0419DE ED 53 3A 1A 0347*      ld (ude),de
       04          
0419E3 DD 22 3D 1A 0348*      ld (uix),ix
       04          
0419E8 FD 22 40 1A 0349*      ld (uiy),iy
       04          
0419ED F5          0350*      push af
0419EE             0351*  
0419EE             0352*  ; print each register
0419EE             0353*  
0419EE 21 28 1A 04 0354*      ld hl,str_udeuhl
0419F2 CD 2E 17 04 0355*      call printString
0419F6 2A 3A 1A 04 0356*      ld hl,(ude)
0419FA CD 4C 17 04 0357*      call printHex24
0419FE 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
041A00 5B D7       0359*  	rst.lil 10h
041A02 2A 34 1A 04 0360*      ld hl,(uhl)
041A06 CD 4C 17 04 0361*      call printHex24
041A0A CD 43 17 04 0362*      call printNewLine
041A0E             0363*  
041A0E             0364*  ; restore everything
041A0E 2A 34 1A 04 0365*      ld hl, (uhl)
041A12 ED 4B 37 1A 0366*      ld bc, (ubc)
       04          
041A17 ED 5B 3A 1A 0367*      ld de, (ude)
       04          
041A1C DD 2A 3D 1A 0368*      ld ix, (uix)
       04          
041A21 FD 2A 40 1A 0369*      ld iy, (uiy)
       04          
041A26 F1          0370*      pop af
041A27             0371*  ; all done
041A27 C9          0372*      ret
041A28             0373*  
041A28 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041A31             0375*  
041A31             0376*  ; global scratch memory for registers
041A31 00 00 00    0377*  uaf: dl 0
041A34 00 00 00    0378*  uhl: dl 0
041A37 00 00 00    0379*  ubc: dl 0
041A3A 00 00 00    0380*  ude: dl 0
041A3D 00 00 00    0381*  uix: dl 0
041A40 00 00 00    0382*  uiy: dl 0
041A43 00 00 00    0383*  usp: dl 0
041A46 00 00 00    0384*  upc: dl 0
041A49             0385*  
041A49             0386*  ; inputs: whatever is in the flags register
041A49             0387*  ; outputs: binary representation of flags
041A49             0388*  ;          with a header so we know which is what
041A49             0389*  ; destroys: nothing
041A49             0390*  ; preserves: everything
041A49             0391*  dumpFlags:
041A49             0392*  ; first we curse zilog for not giving direct access to flags
041A49 F5          0393*      push af ; this is so we can send it back unharmed
041A4A F5          0394*      push af ; this is so we can pop it to hl
041A4B             0395*  ; store everything in scratch
041A4B 22 34 1A 04 0396*      ld (uhl),hl
041A4F ED 43 37 1A 0397*      ld (ubc),bc
       04          
041A54 ED 53 3A 1A 0398*      ld (ude),de
       04          
041A59 DD 22 3D 1A 0399*      ld (uix),ix
       04          
041A5E FD 22 40 1A 0400*      ld (uiy),iy
       04          
041A63             0401*  ; next we print the header
041A63 21 8F 1A 04 0402*      ld hl,@header
041A67 CD 2E 17 04 0403*      call printString
041A6B E1          0404*      pop hl ; flags are now in l
041A6C 7D          0405*      ld a,l ; flags are now in a
041A6D CD EB 17 04 0406*      call printBin8
041A71 CD 43 17 04 0407*  	call printNewLine
041A75             0408*  ; restore everything
041A75 2A 34 1A 04 0409*      ld hl, (uhl)
041A79 ED 4B 37 1A 0410*      ld bc, (ubc)
       04          
041A7E ED 5B 3A 1A 0411*      ld de, (ude)
       04          
041A83 DD 2A 3D 1A 0412*      ld ix, (uix)
       04          
041A88 FD 2A 40 1A 0413*      ld iy, (uiy)
       04          
041A8D F1          0414*      pop af ; send her home the way she came
041A8E C9          0415*      ret
041A8F             0416*  ; Bit 7 (S): Sign flag
041A8F             0417*  ; Bit 6 (Z): Zero flag
041A8F             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041A8F             0419*  ; Bit 4 (H): Half Carry flag
041A8F             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041A8F             0421*  ; Bit 2 (PV): Parity/Overflow flag
041A8F             0422*  ; Bit 1 (N): Subtract flag
041A8F             0423*  ; Bit 0 (C): Carry flag
041A8F 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041A9A             0425*  
041A9A             0426*  ; set all the bits in the flag register
041A9A             0427*  ; more of an academic exercise than anything useful
041A9A             0428*  ; inputs; none
041A9A             0429*  ; outputs; a=0,f=255
041A9A             0430*  ; destroys: flags, hl
041A9A             0431*  ; preserves: a, because why not
041A9A             0432*  setAllFlags:
041A9A 21 FF 00 00 0433*      ld hl,255
041A9E 67          0434*      ld h,a ; four cycles to preserve a is cheap
041A9F E5          0435*      push hl
041AA0 F1          0436*      pop af
041AA1 C9          0437*      ret
041AA2             0438*  
041AA2             0439*  ; reset all the bits in the flag register
041AA2             0440*  ; unlike its inverse counterpart, this may actually be useful
041AA2             0441*  ; inputs; none
041AA2             0442*  ; outputs; a=0,f=0
041AA2             0443*  ; destroys: flags, hl
041AA2             0444*  ; preserves: a, because why not
041AA2             0445*  resetAllFlags:
041AA2 21 00 00 00 0446*      ld hl,0
041AA6 67          0447*      ld h,a ; four cycles to preserve a is cheap
041AA7 E5          0448*      push hl
041AA8 F1          0449*      pop af
041AA9 C9          0450*      ret
041AAA             0451*  
041AAA             0452*  ; wait until user presses a key
041AAA             0453*  ; inputs: none
041AAA             0454*  ; outputs: none
041AAA             0455*  ; destroys: af,ix
041AAA             0456*  waitKeypress:
041AAA             0457*      MOSCALL mos_sysvars
041AAA 3E 08       0001*M 			LD	A, function
041AAC 5B CF       0002*M 			RST.LIL	08h
041AAE AF          0458*      xor a ; zero out any prior keypresses
041AAF DD 77 05    0459*      ld (ix+sysvar_keyascii),a
041AB2             0460*  @loop:
041AB2 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
041AB5 A7          0462*      and a
041AB6 C0          0463*      ret nz
041AB7 18 F9       0464*      jr @loop
041AB9             0465*  
041AB9             0466*  
041AB9             0467*  ; print bytes from an address to the screen in hexidecimal format
041AB9             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041AB9             0469*  ; outputs: values of each byte printed to screen separated by spaces
041AB9             0470*  ; destroys: nothing
041AB9             0471*  dumpMemoryHex:
041AB9             0472*  ; save all registers to the stack
041AB9 F5          0473*      push af
041ABA C5          0474*      push bc
041ABB D5          0475*      push de
041ABC E5          0476*      push hl
041ABD DD E5       0477*      push ix
041ABF FD E5       0478*      push iy
041AC1             0479*  
041AC1             0480*  ; set b to be our loop counter
041AC1 47          0481*      ld b,a
041AC2             0482*  @loop:
041AC2             0483*  ; print the byte
041AC2 7E          0484*      ld a,(hl)
041AC3 CD 5E 17 04 0485*      call printHex8
041AC7             0486*  ; print a space
041AC7 3E 20       0487*      ld a,' '
041AC9 5B D7       0488*      rst.lil 10h
041ACB 23          0489*      inc hl
041ACC 10 F4       0490*      djnz @loop
041ACE CD 43 17 04 0491*      call printNewLine
041AD2             0492*  
041AD2             0493*  ; restore everything
041AD2 FD E1       0494*      pop iy
041AD4 DD E1       0495*      pop ix
041AD6 E1          0496*      pop hl
041AD7 D1          0497*      pop de
041AD8 C1          0498*      pop bc
041AD9 F1          0499*      pop af
041ADA             0500*  ; all done
041ADA C9          0501*      ret
041ADB             0502*  
041ADB             0503*  
041ADB             0504*  ; print bytes from an address to the screen in binary format
041ADB             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041ADB             0506*  ; outputs: values of each byte printed to screen separated by spaces
041ADB             0507*  ; destroys: nothing
041ADB             0508*  dumpMemoryBin:
041ADB             0509*  ; save all registers to the stack
041ADB F5          0510*      push af
041ADC C5          0511*      push bc
041ADD D5          0512*      push de
041ADE E5          0513*      push hl
041ADF DD E5       0514*      push ix
041AE1 FD E5       0515*      push iy
041AE3             0516*  
041AE3             0517*  ; set b to be our loop counter
041AE3 47          0518*      ld b,a
041AE4             0519*  @loop:
041AE4             0520*  ; print the byte
041AE4 7E          0521*      ld a,(hl)
041AE5 E5          0522*      push hl
041AE6 C5          0523*      push bc
041AE7 CD EB 17 04 0524*      call printBin8
041AEB C1          0525*      pop bc
041AEC             0526*  ; print a space
041AEC 3E 20       0527*      ld a,' '
041AEE 5B D7       0528*      rst.lil 10h
041AF0 E1          0529*      pop hl
041AF1 23          0530*      inc hl
041AF2 10 F0       0531*      djnz @loop
041AF4 CD 43 17 04 0532*      call printNewLine
041AF8             0533*  
041AF8             0534*  ; restore everything
041AF8 FD E1       0535*      pop iy
041AFA DD E1       0536*      pop ix
041AFC E1          0537*      pop hl
041AFD D1          0538*      pop de
041AFE C1          0539*      pop bc
041AFF F1          0540*      pop af
041B00             0541*  ; all done
041B00 C9          0542*      ret
041B01             0543*  
041B01             0544*  ; print bytes from an address to the screen in binary format
041B01             0545*  ; with the bits of each byte in reverse order (lsb first)
041B01             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041B01             0547*  ; outputs: values of each byte printed to screen separated by spaces
041B01             0548*  ; destroys: nothing
041B01             0549*  dumpMemoryBinRev:
041B01             0550*  ; save all registers to the stack
041B01 F5          0551*      push af
041B02 C5          0552*      push bc
041B03 D5          0553*      push de
041B04 E5          0554*      push hl
041B05 DD E5       0555*      push ix
041B07 FD E5       0556*      push iy
041B09             0557*  
041B09             0558*  ; set b to be our loop counter
041B09 47          0559*      ld b,a
041B0A             0560*  @loop:
041B0A             0561*  ; print the byte
041B0A 7E          0562*      ld a,(hl)
041B0B E5          0563*      push hl
041B0C C5          0564*      push bc
041B0D CD 10 18 04 0565*      call printBin8Rev
041B11 C1          0566*      pop bc
041B12             0567*  ; print a space
041B12 3E 20       0568*      ld a,' '
041B14 5B D7       0569*      rst.lil 10h
041B16 E1          0570*      pop hl
041B17 23          0571*      inc hl
041B18 10 F0       0572*      djnz @loop
041B1A CD 43 17 04 0573*      call printNewLine
041B1E             0574*  
041B1E             0575*  ; restore everything
041B1E FD E1       0576*      pop iy
041B20 DD E1       0577*      pop ix
041B22 E1          0578*      pop hl
041B23 D1          0579*      pop de
041B24 C1          0580*      pop bc
041B25 F1          0581*      pop af
041B26             0582*  ; all done
041B26 C9          0583*      ret
041B27             0053       include "vdu.inc"
041B27             0001*  
041B27             0002*  ; VDU 30: Home cursor
041B27             0003*  vdu_home_cursor:
041B27 3E 1E       0004*      ld a,30
041B29 5B D7       0005*  	rst.lil $10
041B2B C9          0006*  	ret
041B2C             0007*  
041B2C             0008*  vdu_cursor_on:
041B2C 21 37 1B 04 0009*  	ld hl,@cmd
041B30 01 03 00 00 0010*  	ld bc,@end-@cmd
041B34 5B DF       0011*  	rst.lil $18
041B36 C9          0012*  	ret
041B37             0013*  @cmd:
041B37 17 01 01    0014*  	db 23,1,1
041B3A             0015*  @end:
041B3A             0016*  
041B3A             0017*  vdu_cursor_off:
041B3A 21 45 1B 04 0018*  	ld hl,@cmd
041B3E 01 03 00 00 0019*  	ld bc,@end-@cmd
041B42 5B DF       0020*  	rst.lil $18
041B44 C9          0021*  	ret
041B45             0022*  @cmd:
041B45 17 01 00    0023*  	db 23,1,0
041B48             0024*  @end:
041B48             0025*  
041B48             0026*  ; VDU 5: Write text at graphics cursor
041B48             0027*  ; inputs: a is the character to write to the screen
041B48             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041B48             0029*  ; outputs: see the name of the function
041B48             0030*  ; destroys: a, hl, bc
041B48             0031*  vdu_char_to_gfx_cursor:
041B48 32 58 1B 04 0032*  	ld (@arg),a
041B4C 21 57 1B 04 0033*  	ld hl,@cmd
041B50 01 02 00 00 0034*  	ld bc,@end-@cmd
041B54 5B DF       0035*  	rst.lil $18
041B56 C9          0036*  	ret
041B57 05          0037*  @cmd: db 5
041B58 00          0038*  @arg: db 0
041B59             0039*  @end:
041B59             0040*  ; VDU 9: Move cursor forward one character
041B59             0041*  vdu_cursor_forward:
041B59 3E 09       0042*      ld a,9
041B5B 5B D7       0043*  	rst.lil $10
041B5D C9          0044*  	ret
041B5E             0045*  
041B5E             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041B5E             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041B5E             0048*  vdu_move_cursor:
041B5E ED 43 6F 1B 0049*      ld (@x0),bc
       04          
041B63 21 6E 1B 04 0050*  	ld hl,@cmd
041B67 01 03 00 00 0051*  	ld bc,@end-@cmd
041B6B 5B DF       0052*  	rst.lil $18
041B6D C9          0053*  	ret
041B6E 1F          0054*  @cmd: 	db 31
041B6F 00          0055*  @x0:	db 0
041B70 00          0056*  @y0: 	db 0
041B71 00          0057*  @end: 	db 0 ; padding
041B72             0058*  
041B72             0059*  ; VDU 12: Clear text area (CLS)
041B72             0060*  vdu_cls:
041B72 3E 0C       0061*      ld a,12
041B74 5B D7       0062*  	rst.lil $10
041B76 C9          0063*  	ret
041B77             0064*  
041B77             0065*  vdu_flip:
041B77 21 82 1B 04 0066*  	ld hl,@cmd
041B7B 01 03 00 00 0067*  	ld bc,@end-@cmd
041B7F 5B DF       0068*  	rst.lil $18
041B81 C9          0069*  	ret
041B82 17 00 C3    0070*  @cmd: db 23,0,0xC3
041B85             0071*  @end:
041B85             0072*  
041B85             0073*  ; VDU 16: Clear graphics area (CLG)
041B85             0074*  vdu_clg:
041B85 3E 10       0075*      ld a,16
041B87 5B D7       0076*  	rst.lil $10
041B89 C9          0077*  	ret
041B8A             0078*  
041B8A             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041B8A             0080*  ; VDU 23, 7: Scrolling
041B8A             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041B8A             0082*  ; inputs: a, extent; l, direction; h; speed
041B8A             0083*  vdu_scroll_down:
041B8A 32 9F 1B 04 0084*  	ld (@extent),a
041B8E 22 A0 1B 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041B92 21 9D 1B 04 0086*  	ld hl,@cmd
041B96 01 05 00 00 0087*  	ld bc,@end-@cmd
041B9A 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041B9C C9          0089*  	ret
041B9D 17 07       0090*  @cmd:       db 23,7
041B9F 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041BA0 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041BA1 00          0093*  @speed:     db 0x00 ; pixels
041BA2 00          0094*  @end:		db 0x00 ; padding
041BA3             0095*  
041BA3             0096*  ; COLOUR MODES
041BA3             0097*  ; Mode	Effect
041BA3             0098*  ; 0	Set on-screen pixel to target colour value
041BA3             0099*  ; 1	OR value with the on-screen pixel
041BA3             0100*  ; 2	AND value with the on-screen pixel
041BA3             0101*  ; 3	XOR value with the on-screen pixel
041BA3             0102*  ; 4	Invert the on-screen pixel
041BA3             0103*  ; 5	No operation
041BA3             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041BA3             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041BA3             0106*  
041BA3             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041BA3             0108*  vdu_colour_text:
041BA3 32 B3 1B 04 0109*  	ld (@arg),a
041BA7 21 B2 1B 04 0110*  	ld hl,@cmd
041BAB 01 02 00 00 0111*  	ld bc,@end-@cmd
041BAF 5B DF       0112*  	rst.lil $18
041BB1 C9          0113*  	ret
041BB2 11          0114*  @cmd: db 17
041BB3 00          0115*  @arg: db 0
041BB4             0116*  @end:
041BB4             0117*  
041BB4             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041BB4             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041BB4             0120*  vdu_gcol:
041BB4 32 C9 1B 04 0121*  	ld (@mode),a
041BB8 79          0122*      ld a,c
041BB9 32 CA 1B 04 0123*      ld (@col),a
041BBD 21 C8 1B 04 0124*  	ld hl,@cmd
041BC1 01 03 00 00 0125*  	ld bc,@end-@cmd
041BC5 5B DF       0126*  	rst.lil $18
041BC7 C9          0127*  	ret
041BC8 12          0128*  @cmd:  db 18
041BC9 00          0129*  @mode: db 0
041BCA 00          0130*  @col:  db 0
041BCB             0131*  @end:
041BCB             0132*  
041BCB             0133*  
041BCB             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041BCB             0135*  ; MIND THE LITTLE-ENDIANESS
041BCB             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041BCB             0137*  ; outputs; nothing
041BCB             0138*  ; destroys: a might make it out alive
041BCB             0139*  vdu_set_txt_viewport:
041BCB ED 43 E1 1B 0140*      ld (@lb),bc
       04          
041BD0 ED 53 E3 1B 0141*  	ld (@rt),de
       04          
041BD5 21 E0 1B 04 0142*  	ld hl,@cmd
041BD9 01 05 00 00 0143*  	ld bc,@end-@cmd
041BDD 5B DF       0144*  	rst.lil $18
041BDF C9          0145*  	ret
041BE0 1C          0146*  @cmd:   db 28 ; set text viewport command
041BE1 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041BE3 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041BE5 00          0149*  @end:   db 0x00	  ; padding
041BE6             0150*  
041BE6             0151*  ; Wait for VBLANK interrupt
041BE6             0152*  vdu_vblank:
041BE6 DD E5       0153*      PUSH 	IX
041BE8             0154*  	MOSCALL	mos_sysvars
041BE8 3E 08       0001*M 			LD	A, function
041BEA 5B CF       0002*M 			RST.LIL	08h
041BEC DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041BEF             0156*  @wait:
041BEF DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041BF2 28 FB       0158*      JR	Z, @wait
041BF4 DD E1       0159*      POP	IX
041BF6 C9          0160*      RET
041BF7             0161*  
041BF7             0162*  ; VDU 29, x; y;: Set graphics origin
041BF7             0163*  ; This command sets the graphics origin.
041BF7             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041BF7             0165*  ; inputs: bc=x0,de=y0
041BF7             0166*  ; outputs; nothing
041BF7             0167*  ; destroys: a might make it out alive
041BF7             0168*  vdu_set_gfx_origin:
041BF7 ED 43 0D 1C 0169*      ld (@x0),bc
       04          
041BFC ED 53 0F 1C 0170*      ld (@y0),de
       04          
041C01 21 0C 1C 04 0171*      ld hl,@cmd
041C05 01 05 00 00 0172*      ld bc,@end-@cmd
041C09 5B DF       0173*      rst.lil $18
041C0B C9          0174*      ret
041C0C 1D          0175*  @cmd:   db 29 ; set graphics origin command
041C0D 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041C0F 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041C11 00          0178*  @end:   db 0x00	  ; padding
041C12             0179*  
041C12             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041C12             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041C12             0182*  ; 	because we have turned off logical screen scaling
041C12             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041C12             0184*  ; outputs; nothing
041C12             0185*  ; destroys: a might make it out alive
041C12             0186*  vdu_set_gfx_viewport:
041C12 ED 43 32 1C 0187*      ld (@x0),bc
       04          
041C17 FD 22 34 1C 0188*      ld (@y1),iy
       04          
041C1C DD 22 36 1C 0189*  	ld (@x1),ix
       04          
041C21 ED 53 38 1C 0190*  	ld (@y0),de
       04          
041C26 21 31 1C 04 0191*  	ld hl,@cmd
041C2A 01 09 00 00 0192*  	ld bc,@end-@cmd
041C2E 5B DF       0193*  	rst.lil $18
041C30 C9          0194*  	ret
041C31 18          0195*  @cmd:   db 24 ; set graphics viewport command
041C32 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041C34 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041C36 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041C38 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041C3A 00          0200*  @end:   db 0x00	  ; padding
041C3B             0201*  
041C3B             0202*  ; SCREEN MODES
041C3B             0203*  ; ===============================
041C3B             0204*  ; Mode  Horz  Vert  Cols  Refresh
041C3B             0205*  ; ---   ----  ----  ----  -------
041C3B             0206*  ; 11    320   240   2     60hz
041C3B             0207*  ; 139   320   240   2     60hz
041C3B             0208*  ; 23    512   384   2     60hz
041C3B             0209*  ; 151   512   384   2     60hz
041C3B             0210*  ; 6     640   240   2     60hz
041C3B             0211*  ; 134   640   240   2     60hz
041C3B             0212*  ; 2     640   480   2     60hz
041C3B             0213*  ; 130   640   480   2     60hz
041C3B             0214*  ; 17    800   600   2     60hz
041C3B             0215*  ; 145   800   600   2     60hz
041C3B             0216*  ; 18    1024  768   2     60hz
041C3B             0217*  ; 146   1024  768   2     60hz
041C3B             0218*  ; ---   ----  ----  ----  -------
041C3B             0219*  ; 10    320   240   4     60hz
041C3B             0220*  ; 138   320   240   4     60hz
041C3B             0221*  ; 22    512   384   4     60hz
041C3B             0222*  ; 150   512   384   4     60hz
041C3B             0223*  ; 5     640   240   4     60hz
041C3B             0224*  ; 133   640   240   4     60hz
041C3B             0225*  ; 1     640   480   4     60hz
041C3B             0226*  ; 129   640   480   4     60hz
041C3B             0227*  ; 16    800   600   4     60hz
041C3B             0228*  ; 19    1024  768   4     60hz
041C3B             0229*  ; ---   ----  ----  ----  -------
041C3B             0230*  ; 9     320   240   16    60hz
041C3B             0231*  ; 137   320   240   16    60hz
041C3B             0232*  ; 21    512   384   16    60hz
041C3B             0233*  ; 149   512   384   16    60hz
041C3B             0234*  ; 4     640   240   16    60hz
041C3B             0235*  ; 132   640   240   16    60hz
041C3B             0236*  ; 0     640   480   16    60hz
041C3B             0237*  ; 7     n/a   n/a   16    60hz
041C3B             0238*  ; ---   ----  ----  ----  -------
041C3B             0239*  ; 8     320   240   64    60hz
041C3B             0240*  ; 136   320   240   64    60hz
041C3B             0241*  ; 20    512   384   64    60hz
041C3B             0242*  ; 3     640   240   64    60hz
041C3B             0243*  ; ---   ----  ----  ----  -------
041C3B             0244*  vdu_set_screen_mode:
041C3B 32 4B 1C 04 0245*  	ld (@arg),a
041C3F 21 4A 1C 04 0246*  	ld hl,@cmd
041C43 01 02 00 00 0247*  	ld bc,@end-@cmd
041C47 5B DF       0248*  	rst.lil $18
041C49 C9          0249*  	ret
041C4A 16          0250*  @cmd: db 22 ; set screen mode
041C4B 00          0251*  @arg: db 0  ; screen mode parameter
041C4C             0252*  @end:
041C4C             0253*  
041C4C             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041C4C             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041C4C             0256*  ; note: default setting on boot is scaling ON
041C4C             0257*  vdu_set_scaling:
041C4C 32 5E 1C 04 0258*  	ld (@arg),a
041C50 21 5B 1C 04 0259*  	ld hl,@cmd
041C54 01 04 00 00 0260*  	ld bc,@end-@cmd
041C58 5B DF       0261*  	rst.lil $18
041C5A C9          0262*  	ret
041C5B 17 00 C0    0263*  @cmd: db 23,0,0xC0
041C5E 00          0264*  @arg: db 0  ; scaling on/off
041C5F             0265*  @end:
041C5F             0266*  
041C5F             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041C5F             0268*  ; inputs: hl=bufferId
041C5F             0269*  vdu_buff_select:
041C5F 22 71 1C 04 0270*  	ld (@bufferId),hl
041C63 21 6E 1C 04 0271*  	ld hl,@cmd
041C67 01 05 00 00 0272*  	ld bc,@end-@cmd
041C6B 5B DF       0273*  	rst.lil $18
041C6D C9          0274*  	ret
041C6E 17 1B 20    0275*  @cmd: db 23,27,0x20
041C71 00 00       0276*  @bufferId: dw 0x0000
041C73 00          0277*  @end: db 0x00 ; padding
041C74             0278*  
041C74             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041C74             0280*  ; inputs: a=format; bc=width; de=height
041C74             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041C74             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041C74             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041C74             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041C74             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041C74             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041C74             0287*  vdu_bmp_create:
041C74 ED 43 90 1C 0288*      ld (@width),bc
       04          
041C79 ED 53 92 1C 0289*      ld (@height),de
       04          
041C7E 32 94 1C 04 0290*      ld (@fmt),a
041C82 21 8D 1C 04 0291*  	ld hl,@cmd
041C86 01 08 00 00 0292*  	ld bc,@end-@cmd
041C8A 5B DF       0293*  	rst.lil $18
041C8C C9          0294*  	ret
041C8D 17 1B 21    0295*  @cmd:       db 23,27,0x21
041C90 00 00       0296*  @width:     dw 0x0000
041C92 00 00       0297*  @height:    dw 0x0000
041C94 00          0298*  @fmt:       db 0x00
041C95             0299*  @end:
041C95             0300*  
041C95             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041C95             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041C95             0303*  vdu_load_img_rgba2_to_8:
041C95             0304*  ; backup the target buffer id and image dimensions
041C95 E5          0305*      push hl
041C96 D5          0306*      push de
041C97 C5          0307*      push bc
041C98             0308*  ; load the rgba2 image to working buffer 65534
041C98 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041C9C CD 9F 1D 04 0310*  	call vdu_load_buffer_from_file
041CA0             0311*  ; restore the image dimensions and target buffer id
041CA0 C1          0312*      pop bc
041CA1 D1          0313*      pop de
041CA2 E1          0314*      pop hl
041CA3             0315*  ; fall through to vdu_rgba2_to_8
041CA3             0316*  
041CA3             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041CA3             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041CA3             0319*  ; the "expand bitmap" command is:
041CA3             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CA3             0321*  ; and then to reverse the byte order to fix endian-ness:
041CA3             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CA3             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CA3             0324*  ; VDU 23,27,&20,targetBufferID%;
041CA3             0325*  ; VDU 23,27,&21,width%;height%;0
041CA3             0326*  ; -------------------------------------------------------------------
041CA3             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041CA3             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041CA3             0329*  vdu_rgba2_to_8:
041CA3             0330*  ; load the image dimensions and buffer id parameters
041CA3 ED 43 FF 1C 0331*      ld (@width),bc
       04          
041CA8 ED 53 01 1D 0332*      ld (@height),de
       04          
041CAD 22 E4 1C 04 0333*      ld (@bufferId0),hl
041CB1 22 F1 1C 04 0334*      ld (@bufferId2),hl
041CB5 22 FA 1C 04 0335*      ld (@bufferId1),hl
041CB9             0336*  ; clean up bytes that got stomped on by the ID loads
041CB9 3E 48       0337*      ld a,0x48
041CBB 32 E6 1C 04 0338*      ld (@bufferId0+2),a
041CBF 3E 17       0339*      ld a,23
041CC1 32 FC 1C 04 0340*      ld (@bufferId1+2),a
041CC5 3E 18       0341*      ld a,24
041CC7 32 F3 1C 04 0342*      ld (@bufferId2+2),a
041CCB AF          0343*      xor a
041CCC 32 03 1D 04 0344*      ld (@height+2),a
041CD0             0345*  ; send the vdu command strings
041CD0 21 DB 1C 04 0346*      ld hl,@beg
041CD4 01 29 00 00 0347*      ld bc,@end-@beg
041CD8 5B DF       0348*      rst.lil $18
041CDA C9          0349*      ret
041CDB             0350*  @beg:
041CDB             0351*  ; Command 14: Consolidate blocks in a buffer
041CDB             0352*  ; VDU 23, 0, &A0, bufferId; 14
041CDB 17 00 A0    0353*      db 23,0,0xA0
041CDE FE FF       0354*      dw 65534 ; workingBufferId
041CE0 0E          0355*      db 14 ; consolidate blocks
041CE1             0356*  ; the "expand bitmap" command is:
041CE1             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CE1 17 00 A0    0358*      db 23,0,0xA0
041CE4 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041CE6 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041CE7 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041CE8 FE FF       0362*      dw 65534 ; sourceBufferId
041CEA 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041CEE             0364*  ; reverse the byte order to fix endian-ness:
041CEE             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041CEE             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041CEE             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CEE 17 00 A0    0368*      db 23,0,0xA0
041CF1 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041CF3 18          0370*      db 24 ; reverse byte order
041CF4 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041CF5 04 00       0372*      dw 4 ; size (4 bytes)
041CF7             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CF7             0374*  ; VDU 23,27,&20,targetBufferID%;
041CF7 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041CFA 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041CFC             0377*  ; VDU 23,27,&21,width%;height%;0
041CFC 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041CFF 00 00       0379*  @width: dw 0x0000
041D01 00 00       0380*  @height: dw 0x0000
041D03 00          0381*      db 0x00 ; rgba8888 format
041D04             0382*  @end:
041D04             0383*  
041D04             0384*  ; scratch variables
041D04 00 00 00    0385*  bufferId0: dl 0x000000
041D07 00 00 00    0386*  bufferId1: dl 0x000000
041D0A             0387*  
041D0A             0388*  ; load a vdu buffer from local memory
041D0A             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041D0A             0390*  vdu_load_buffer:
041D0A ED 43 33 1D 0391*      ld (@length),bc
       04          
041D0F D5          0392*      push de ; save data pointer
041D10             0393*  ; send the vdu command string
041D10 7D          0394*      ld a,l
041D11 32 30 1D 04 0395*      ld (@bufferId),a
041D15 7C          0396*      ld a,h
041D16 32 31 1D 04 0397*      ld (@bufferId+1),a
041D1A 21 2D 1D 04 0398*      ld hl,@cmd
041D1E 01 08 00 00 0399*      ld bc,@end-@cmd
041D22 5B DF       0400*      rst.lil $18
041D24             0401*  ; send the buffer data
041D24 E1          0402*      pop hl ; pointer to data
041D25 ED 4B 33 1D 0403*      ld bc,(@length)
       04          
041D2A 5B DF       0404*      rst.lil $18 ; send it
041D2C C9          0405*      ret
041D2D             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D2D 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041D30 00 00       0408*  @bufferId:	dw 0x0000
041D32 00          0409*  		    db 0 ; load buffer
041D33 00 00       0410*  @length:	dw 0x0000
041D35 00          0411*  @end: db 0 ; padding
041D36             0412*  
041D36             0413*  ; clear a buffer
041D36             0414*  ; inputs: hl = bufferId
041D36             0415*  vdu_clear_buffer:
041D36 7D          0416*      ld a,l
041D37 32 4E 1D 04 0417*      ld (@bufferId),a
041D3B 7C          0418*      ld a,h
041D3C 32 4F 1D 04 0419*      ld (@bufferId+1),a
041D40 21 4B 1D 04 0420*      ld hl,@cmd
041D44 01 06 00 00 0421*      ld bc,@end-@cmd
041D48 5B DF       0422*      rst.lil $18
041D4A C9          0423*      ret
041D4B 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041D4E 00 00       0425*  @bufferId:	dw 0x0000
041D50 02          0426*  		    db 2 ; clear buffer
041D51             0427*  @end:
041D51             0428*  
041D51             0429*  vdu_clear_all_buffers:
041D51             0430*  ; clear all buffers
041D51 21 5C 1D 04 0431*      ld hl,@beg
041D55 01 06 00 00 0432*      ld bc,@end-@beg
041D59 5B DF       0433*      rst.lil $18
041D5B C9          0434*      ret
041D5C 17 00 A0    0435*  @beg: db 23,0,$A0
041D5F FF FF       0436*        dw -1 ; clear all buffers
041D61 02          0437*        db 2  ; command 2: clear a buffer
041D62             0438*  @end:
041D62             0439*  
041D62             0440*  ; Command 14: Consolidate blocks in a buffer
041D62             0441*  vdu_consolidate_buffer:
041D62             0442*  ; set parameters for vdu call
041D62 7D          0443*      ld a,l
041D63 32 7A 1D 04 0444*      ld (@bufferId),a
041D67 7C          0445*      ld a,h
041D68 32 7B 1D 04 0446*      ld (@bufferId+1),a
041D6C 21 77 1D 04 0447*      ld hl,@beg
041D70 01 06 00 00 0448*      ld bc,@end-@beg
041D74 5B DF       0449*      rst.lil $18
041D76 C9          0450*      ret
041D77             0451*  ; VDU 23, 0, &A0, bufferId; 14
041D77 17 00 A0    0452*  @beg: db 23,0,0xA0
041D7A 00 00       0453*  @bufferId: dw 0x0000
041D7C 0E          0454*             db 14
041D7D             0455*  @end:
041D7D             0456*  
041D7D             0457*  ; load an image file to a buffer and make it a bitmap
041D7D             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041D7D             0459*  vdu_load_img:
041D7D             0460*  ; back up image type and dimension parameters
041D7D 22 04 1D 04 0461*      ld (bufferId0),hl
041D81 F5          0462*      push af
041D82 C5          0463*  	push bc
041D83 D5          0464*  	push de
041D84             0465*  ; load the image
041D84 CD 9F 1D 04 0466*  	call vdu_load_buffer_from_file
041D88             0467*  ; now make it a bitmap
041D88 2A 04 1D 04 0468*      ld hl,(bufferId0)
041D8C CD 62 1D 04 0469*      call vdu_consolidate_buffer
041D90 2A 04 1D 04 0470*      ld hl,(bufferId0)
041D94 CD 5F 1C 04 0471*      call vdu_buff_select
041D98 D1          0472*  	pop de ; image height
041D99 C1          0473*  	pop bc ; image width
041D9A F1          0474*  	pop af ; image type
041D9B C3 74 1C 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041D9F             0476*  
041D9F             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041D9F             0478*  vdu_load_buffer_from_file:
041D9F 22 04 1D 04 0479*      ld (bufferId0),hl
041DA3             0480*  
041DA3             0481*  ; clear target buffer
041DA3 CD 36 1D 04 0482*      call vdu_clear_buffer
041DA7             0483*  
041DA7             0484*  ; open the file in read mode
041DA7             0485*  ; Open a file
041DA7             0486*  ; HLU: Filename
041DA7             0487*  ;   C: Mode
041DA7             0488*  ; Returns:
041DA7             0489*  ;   A: Filehandle, or 0 if couldn't open
041DA7 FD E5       0490*  	push iy ; pointer to filename
041DA9 E1          0491*  	pop hl
041DAA 0E 01       0492*  	ld c,fa_read
041DAC             0493*      MOSCALL mos_fopen
041DAC 3E 0A       0001*M 			LD	A, function
041DAE 5B CF       0002*M 			RST.LIL	08h
041DB0 32 EB 1D 04 0494*      ld (@filehandle),a
041DB4             0495*  
041DB4             0496*  @read_file:
041DB4             0497*  ; Read a block of data from a file
041DB4             0498*  ;   C: Filehandle
041DB4             0499*  ; HLU: Pointer to where to write the data to
041DB4             0500*  ; DEU: Number of bytes to read
041DB4             0501*  ; Returns:
041DB4             0502*  ; DEU: Number of bytes read
041DB4 3A EB 1D 04 0503*      ld a,(@filehandle)
041DB8 4F          0504*      ld c,a
041DB9 21 00 E0 B7 0505*      ld hl,filedata
041DBD 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041DC1             0507*      MOSCALL mos_fread
041DC1 3E 1A       0001*M 			LD	A, function
041DC3 5B CF       0002*M 			RST.LIL	08h
041DC5             0508*  
041DC5             0509*  ; ; DEBUG: print chunk size
041DC5             0510*  ;     push de
041DC5             0511*  ;     pop hl
041DC5             0512*  ;     call printDec
041DC5             0513*  ;     call printNewLine
041DC5             0514*  
041DC5             0515*  ; test de for zero bytes read
041DC5 21 00 00 00 0516*      ld hl,0
041DC9 AF          0517*      xor a ; clear carry
041DCA ED 52       0518*      sbc hl,de
041DCC CA E2 1D 04 0519*      jp z,@close_file
041DD0             0520*  
041DD0             0521*  ; load a vdu buffer from local memory
041DD0             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041DD0 2A 04 1D 04 0523*      ld hl,(bufferId0)
041DD4 D5          0524*      push de ; chunksize
041DD5 C1          0525*      pop bc
041DD6 11 00 E0 B7 0526*      ld de,filedata
041DDA CD 0A 1D 04 0527*      call vdu_load_buffer
041DDE             0528*  
041DDE             0529*  ; ; print progress breadcrumbs
041DDE             0530*  ;     ld a,'.'
041DDE             0531*  ;     rst.lil 10h
041DDE             0532*  
041DDE             0533*  ; read the next block
041DDE C3 B4 1D 04 0534*      jp @read_file
041DE2             0535*  
041DE2             0536*  ; close the file
041DE2             0537*  @close_file:
041DE2 3A EB 1D 04 0538*      ld a,(@filehandle)
041DE6             0539*      MOSCALL mos_fclose
041DE6 3E 0B       0001*M 			LD	A, function
041DE8 5B CF       0002*M 			RST.LIL	08h
041DEA C9          0540*      ret ; vdu_load_buffer_from_file
041DEB             0541*  
041DEB 00          0542*  @filehandle: db 0 ; file handle
041DEC 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
041DEF             0544*  
041DEF 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
041DF2             0546*  
041DF2             0547*  ; File information structure (FILINFO)
041DF2             0548*  @filinfo:
041DF2 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041DF6 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041DF8 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041DFA 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041DFB 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041E08 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041F08             0054       include "vdu_buff.inc"
041F08             0001*  ; VDP Buffered Commands API
041F08             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
041F08             0003*  
041F08             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F08             0005*  ; This command is used to store a data block (a sequence of bytes)
041F08             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
041F08             0007*  ; It could be a sequence of VDU commands which can be executed
041F08             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
041F08             0009*  ; When used for a sequence of VDU commands, this effectively
041F08             0010*  ; allows for functions or stored procedures to be created.
041F08             0011*  
041F08             0012*  ; This is the most common command to use to send data to the VDP.
041F08             0013*  ; Typically you will call command 2 first to ensure that the
041F08             0014*  ; buffer is empty, and then make a series of calls to this command
041F08             0015*  ; to send data to the buffer.
041F08             0016*  
041F08             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
041F08             0018*  ; write to. Writing to the same buffer ID multiple times will add
041F08             0019*  ; new blocks to that buffer. This allows a buffer to be built up
041F08             0020*  ; over time, essentially allowing for a command to be sent across
041F08             0021*  ; to the VDP in multiple separate packets.
041F08             0022*  
041F08             0023*  ; Whilst the length of an individual block added using this command
041F08             0024*  ; is restricted to 65535 bytes (as the largest value that can be
041F08             0025*  ; sent in a 16-bit number) the total size of a buffer is not
041F08             0026*  ; restricted to this size, as multiple blocks can be added to a
041F08             0027*  ; buffer. Given how long it takes to send data to the VDP it is
041F08             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
041F08             0029*  ; data or less at a time.
041F08             0030*  
041F08             0031*  ; As writing to a single buffer ID is cumulative with this command,
041F08             0032*  ; care should be taken to ensure that the buffer is cleared out
041F08             0033*  ; before writing to it.
041F08             0034*  
041F08             0035*  ; When building up a complex sequence of commands it is often
041F08             0036*  ; advisable to use multiple blocks within a buffer. Typically
041F08             0037*  ; this is easier to code, as otherwise working out exactly how
041F08             0038*  ; many bytes long a command sequence is can be can be onerously
041F08             0039*  ; difficult. It is also easier to modify a command sequences that
041F08             0040*  ; are broken up into multiple blocks.
041F08             0041*  
041F08             0042*  ; As mentioned above it is advisable to send large pieces of data,
041F08             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
041F08             0044*  ; each packet of data sent to a buffer, the user can then perform
041F08             0045*  ; other operations, such as updating the screen to indicate
041F08             0046*  ; progress. This allows for long-running operations to be performed
041F08             0047*  ; without blocking the screen, and larger amounts of data to be
041F08             0048*  ; transferred over to the VDP than may otherwise be practical given
041F08             0049*  ; the limitations of the eZ80.
041F08             0050*  
041F08             0051*  ; If a buffer ID of 65535 is used then this command will be
041F08             0052*  ; ignored, and the data discarded. This is because this buffer ID
041F08             0053*  ; is reserved for special functions.
041F08             0054*  
041F08             0055*  ; Using buffers for bitmaps
041F08             0056*  
041F08             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
041F08             0058*  ; they cannot be used if they are spread over multiple blocks.
041F08             0059*  ; To use a bitmap its data must be in a single contiguous block,
041F08             0060*  ; and this is achieved by using the “consolidate” command &0E.
041F08             0061*  
041F08             0062*  ; Once you have a block that is ready to be used for a bitmap,
041F08             0063*  ; the buffer must be selected, and then a bitmap created for that
041F08             0064*  ; buffer using the bitmap and sprites API. This is done with the
041F08             0065*  ; following commands:
041F08             0066*  
041F08             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
041F08             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
041F08             0069*  
041F08             0070*  ; Until the “create bitmap” call has been made the buffer cannot
041F08             0071*  ; be used as a bitmap. That is because the system needs to
041F08             0072*  ; understand the dimensions of the bitmap, as well as the format
041F08             0073*  ; of the data. Usually this only needs to be done once. The format
041F08             0074*  ; is given as an 8-bit value, with the following values supported:
041F08             0075*  ; Value 	Type 	Description
041F08             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
041F08             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
041F08             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
041F08             0079*  
041F08             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
041F08             0081*  ; and these are automatically stored in buffers numbered 64000-64255
041F08             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
041F08             0083*  ; simply a matter of adding 64000. All bitmaps created with that
041F08             0084*  ; API will be RGBA8888 format.
041F08             0085*  
041F08             0086*  ; There is one other additional call added to the bitmap and
041F08             0087*  ; sprites API, which allows for bitmaps referenced with a
041F08             0088*  ; buffer ID to be added to sprites. This is done with the
041F08             0089*  ; following command:
041F08             0090*  
041F08             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
041F08             0092*  
041F08             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
041F08             0094*  
041F08             0095*  ; It should be noted that it is possible to modify the buffer
041F08             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
041F08             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
041F08             0098*  ; can allow you to do things such as changing colours in a bitmap,
041F08             0099*  ; or flipping an image horizontally or vertically. This will even
041F08             0100*  ; work on bitmaps that are being used inside sprites.
041F08             0101*  
041F08             0102*  ; Using commands targetting a buffer that create new blocks,
041F08             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
041F08             0104*  ; and remove it from use.
041F08             0105*  
041F08             0106*  ; Using buffers for sound samples
041F08             0107*  
041F08             0108*  ; Much like with bitmaps, it is advisable to send samples over
041F08             0109*  ; to the VDP in multiple blocks for the same reasons.
041F08             0110*  
041F08             0111*  ; In contrast to bitmaps, the sound system can play back samples
041F08             0112*  ; that are spread over multiple blocks, so there is no need to
041F08             0113*  ; consolidate buffers. As a result of this, the sample playback
041F08             0114*  ; system is also more tolerant of modifications being made to
041F08             0115*  ; the buffer after a sample has been created from it, even if
041F08             0116*  ; the sample is currently playing. It should be noted that
041F08             0117*  ; splitting a buffer may result in unexpected behaviour if
041F08             0118*  ; the sample is currently playing, such as skipping to other
041F08             0119*  ; parts of the sample.
041F08             0120*  
041F08             0121*  ; Once you have a buffer that contains block(s) that are ready
041F08             0122*  ; to be used for a sound sample, the following command must be
041F08             0123*  ; used to indicate that a sample should be created from that buffer:
041F08             0124*  
041F08             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
041F08             0126*  
041F08             0127*  ; The format parameter is an 8-bit value that indicates the
041F08             0128*  ; format of the sample data. The following values are supported:
041F08             0129*  ; Value 	Description
041F08             0130*  ; 0 	8-bit signed, 16KHz
041F08             0131*  ; 1 	8-bit unsigned, 16KHz
041F08             0132*  
041F08             0133*  ; Once a sample has been created in this way, the sample can
041F08             0134*  ; be selected for use on a channel using the following command:
041F08             0135*  
041F08             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
041F08             0137*  
041F08             0138*  ; Samples uploaded using the existing “load sample” command
041F08             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
041F08             0140*  ; are also stored in buffers automatically. A sample number using this system is in
041F08             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
041F08             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
041F08             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
041F08             0144*  ; buffer 64257, and so on.
041F08             0145*  ; Command 1: Call a buffer
041F08             0146*  
041F08             0147*  ; VDU 23, 0 &A0, bufferId; 1
041F08             0148*  
041F08             0149*  ; This command will attempt to execute all of the commands
041F08             0150*  ; stored in the buffer with the given ID. If the buffer does
041F08             0151*  ; not exist, or is empty, then this command will do nothing.
041F08             0152*  
041F08             0153*  ; Essentially, this command passes the contents of the buffer
041F08             0154*  ; to the VDP’s VDU command processor system, and executes them
041F08             0155*  ; as if they were sent directly to the VDP.
041F08             0156*  
041F08             0157*  ; As noted against command 0, it is possible to build up a
041F08             0158*  ; buffer over time by sending across multiple commands to write
041F08             0159*  ; to the same buffer ID. When calling a buffer with multiple
041F08             0160*  ; blocks, the blocks are executed in order.
041F08             0161*  
041F08             0162*  ; Care should be taken when using this command within a buffer,
041F08             0163*  ; as it is possible to create an infinite loop. For instance,
041F08             0164*  ; if a buffer contains a command to call itself, then this will
041F08             0165*  ; result in an infinite loop. This will cause the VDP to hang,
041F08             0166*  ; and the only way to recover from this is to reset the VDP.
041F08             0167*  
041F08             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
041F08             0169*  ; to be executed. This can be useful for creating loops within
041F08             0170*  ; a buffer. It will be ignored if used outside of a buffered
041F08             0171*  ; command sequence.
041F08             0172*  
041F08             0173*  ; Command 2: Clear a buffer
041F08             0174*  ; VDU 23, 0 &A0, bufferId; 2
041F08             0175*  
041F08             0176*  ; This command will clear the buffer with the given ID. If
041F08             0177*  ; the buffer does not exist then this command will do nothing.
041F08             0178*  
041F08             0179*  ; Please note that this clears out all of the blocks sent to
041F08             0180*  ; a buffer via command 0, not just the last one. i.e. if you
041F08             0181*  ; have built up a buffer over time by sending multiple commands
041F08             0182*  ; to write to the same buffer ID, this command will clear out
041F08             0183*  ; all of those commands.
041F08             0184*  
041F08             0185*  ; Calling this command with a bufferId value of -1 (65535) will
041F08             0186*  ; clear out all buffers.
041F08             0187*  
041F08             0188*  ; Command 3: Create a writeable buffer
041F08             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
041F08             0190*  ; This command will create a new writeable buffer with the given
041F08             0191*  ; ID. If a buffer with the given ID already exists then this
041F08             0192*  ; command will do nothing. This command is primarily intended
041F08             0193*  ; for use to create a buffer that can be used to capture output
041F08             0194*  ; using the “set output stream” command (see below), or to store
041F08             0195*  ; data that can be used for other commands.
041F08             0196*  
041F08             0197*  ; It is generally quite rare that you will want to use this
041F08             0198*  ; command. Typically you will instead want to use command 0
041F08             0199*  ; to write data to a buffer. It is not necessary to use this
041F08             0200*  ; command before using command 0, and indeed doing so will
041F08             0201*  ; lead to errors as you will end up with two blocks in the
041F08             0202*  ; buffer, the first of which will be empty. If you do wish
041F08             0203*  ; to use this command to create a buffer for data and then
041F08             0204*  ; write to it, you would need to use operation 2 of command 5,
041F08             0205*  ; the “set” operation in the “buffer adjust” command, to set a
041F08             0206*  ; sequence of bytes in the buffer to the data you want to write.
041F08             0207*  ; This is not recommended, as it is much easier to just use
041F08             0208*  ; command 0 to write a data block to a buffer.
041F08             0209*  
041F08             0210*  ; This new buffer will be a single empty single block upon
041F08             0211*  ; creation, containing zeros.
041F08             0212*  
041F08             0213*  ; The length parameter is a 16-bit integer that specifies
041F08             0214*  ; the maximum size of the buffer. This is the maximum number
041F08             0215*  ; of bytes that can be stored in the buffer. If the buffer
041F08             0216*  ; is full then no more data can be written to it, and subsequent
041F08             0217*  ; writes will be ignored.
041F08             0218*  
041F08             0219*  ; After creating a buffer with this command it is possible to
041F08             0220*  ; use command 0 to write further blocks to the buffer, however
041F08             0221*  ; this is probably not advisable.
041F08             0222*  
041F08             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
041F08             0224*  ; values have special meanings for writable buffers. See command 4.
041F08             0225*  
041F08             0226*  ; Command 4: Set output stream to a buffer
041F08             0227*  ; VDU 23, 0 &A0, bufferId; 4
041F08             0228*  
041F08             0229*  ; Sets then current output stream to the buffer with the given ID.
041F08             0230*  ; With two exceptions, noted below, this needs to be a writable
041F08             0231*  ; buffer created with command 3. If the buffer does not exist,
041F08             0232*  ; or the first block within the buffer is not writable, then
041F08             0233*  ; this command will do nothing.
041F08             0234*  
041F08             0235*  ; Following this command, any subsequent VDU commands that send
041F08             0236*  ; response packets will have those packets written to the specified
041F08             0237*  ; output buffer. This allows the user to capture the response
041F08             0238*  ; packets from a command sent to the VDP.
041F08             0239*  
041F08             0240*  ; By default, the output stream (for the main VDU command processor)
041F08             0241*  ; is the communications channel from the VDP to MOS running on the
041F08             0242*  ; eZ80.
041F08             0243*  
041F08             0244*  ; Passing a buffer ID of -1 (65535) to this command will
041F08             0245*  ; remove/detach the output buffer. From that point onwards,
041F08             0246*  ; any subsequent VDU commands that send response packets will
041F08             0247*  ; have those responses discarded/ignored.
041F08             0248*  
041F08             0249*  ; Passing a buffer ID of 0 to this command will set the output
041F08             0250*  ; buffer back to its original value for the current command stream.
041F08             0251*  ; Typically that will be the communications channel from the VDP to
041F08             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
041F08             0253*  ; call has been made.
041F08             0254*  
041F08             0255*  ; When used inside a buffered command sequence, this command will
041F08             0256*  ; only affect the output stream for that sequence of commands, and
041F08             0257*  ; any other buffered command sequences that are called from within
041F08             0258*  ; that sequence. Once the buffered command sequence has completed,
041F08             0259*  ; the output stream will effectively be reset to its original value.
041F08             0260*  
041F08             0261*  ; It is strongly recommended to only use this command from within a
041F08             0262*  ; buffered command sequence. Whilst it is possible to use this
041F08             0263*  ; command from within a normal VDU command sequence, it is not
041F08             0264*  ; recommended as it may cause unexpected behaviour. If you do use
041F08             0265*  ; it in that context, it is very important to remember to restore
041F08             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
041F08             0267*  ; future, this command may be disabled from being used outside of
041F08             0268*  ; a buffered command sequence.)
041F08             0269*  
041F08             0270*  ; At present, writable buffers can only be written to until the end
041F08             0271*  ; of the buffer has been reached; once that happens no more data
041F08             0272*  ; will be written to the buffer. It is not currently possible to
041F08             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
041F08             0274*  ; that the buffer is large enough to capture all of the data that
041F08             0275*  ; is expected to be written to it. The only current way to “rewind”
041F08             0276*  ; an output stream would be to clear the buffer and create a new
041F08             0277*  ; one, and then call set output stream again with the newly created
041F08             0278*  ; buffer.
041F08             0279*  
041F08             0280*  ; Command 5: Adjust buffer contents
041F08             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041F08             0282*  
041F08             0283*  ; This command will adjust the contents of a buffer, at a given
041F08             0284*  ; offset. The exact nature of the adjustment will depend on the
041F08             0285*  ; operation used.
041F08             0286*  
041F08             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
041F08             0288*  ; the contents of the current buffer. This will only work if this
041F08             0289*  ; command is used within a buffered command sequence, otherwise the
041F08             0290*  ; command will not do anything.
041F08             0291*  
041F08             0292*  ; The basic set of adjustment operations are as follows:
041F08             0293*  ; Operation 	Description
041F08             0294*  ; 0 	NOT
041F08             0295*  ; 1 	Negate
041F08             0296*  ; 2 	Set value
041F08             0297*  ; 3 	Add
041F08             0298*  ; 4 	Add with carry
041F08             0299*  ; 5 	AND
041F08             0300*  ; 6 	OR
041F08             0301*  ; 7 	XOR
041F08             0302*  
041F08             0303*  ; All of these operations will modify a byte found at the given
041F08             0304*  ; offset in the buffer. The only exception to that is the “Add with
041F08             0305*  ; carry” operation, which will also store the “carry” value in the
041F08             0306*  ; byte at the next offset. With the exception of NOT and Negate,
041F08             0307*  ; each command requires an operand value to be specified.
041F08             0308*  
041F08             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
041F08             0310*  ; need to use the NOT operation, and so the following command would
041F08             0311*  ; be used:
041F08             0312*  
041F08             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
041F08             0314*  
041F08             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
041F08             0316*  ; to use the Add operation, and so the following command would be
041F08             0317*  ; used:
041F08             0318*  
041F08             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
041F08             0320*  
041F08             0321*  ; When using add with carry, the carry value is stored in the byte
041F08             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
041F08             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
041F08             0324*  ; you would need to use the Add with carry operation, and so the
041F08             0325*  ; following command would be used:
041F08             0326*  
041F08             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
041F08             0328*  
041F08             0329*  ; Advanced operations
041F08             0330*  
041F08             0331*  ; Whilst these operations are useful, they are not particularly
041F08             0332*  ; powerful as they only operate one one byte at a time, with a
041F08             0333*  ; fixed operand value, and potentially cannot reach all bytes in
041F08             0334*  ; a buffer. To address this, the API supports a number of advanced
041F08             0335*  ; operations.
041F08             0336*  
041F08             0337*  ; The operation value used is an 8-bit value that can have bits
041F08             0338*  ; set to modify the behaviour of the operation. The following bits
041F08             0339*  ; are defined:
041F08             0340*  ; Bit 	Description
041F08             0341*  ; &10 	Use “advanced” offsets
041F08             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041F08             0343*  ; &40 	Multiple target values should be adjusted
041F08             0344*  ; &80 	Multiple operand values should be used
041F08             0345*  
041F08             0346*  ; These bits can be combined together to modify the behaviour of
041F08             0347*  ; the operation.
041F08             0348*  
041F08             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
041F08             0350*  ; offset one byte at a time. When either of the “multiple” variants
041F08             0351*  ; are used, a 16-bit count must be provided to indicate how many
041F08             0352*  ; bytes should be altered.
041F08             0353*  
041F08             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
041F08             0355*  ; order, which can allow for buffers that are larger than 64kb
041F08             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
041F08             0357*  ; the 16-bit value immediately following the offset is used as a
041F08             0358*  ; block index number, and the remaining 23-bits of the offset value
041F08             0359*  ; are used as an offset within that block. When the “advanced”
041F08             0360*  ; offset mode bit has been set then all offsets associated with
041F08             0361*  ; this command must be sent as advanced offsets.
041F08             0362*  
041F08             0363*  ; The “buffer-fetched value” mode allows for the operand value to
041F08             0364*  ; be fetched from a buffer. The operand sent as part of the
041F08             0365*  ; command in this case is a pair of 16-bit values giving the
041F08             0366*  ; buffer ID and offset to indicate where the actual operand value
041F08             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
041F08             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
041F08             0369*  ; used inside a buffered command sequence. If the advanced offset
041F08             0370*  ; mode is used, then the operand value is an advanced offset value.
041F08             0371*  
041F08             0372*  ; The “multiple target values” mode allows for multiple bytes to
041F08             0373*  ; be adjusted at once. When this mode is used, the count value
041F08             0374*  ; must be provided to indicate how many bytes should be adjusted.
041F08             0375*  ; Unless the “multiple operand values” mode is also used, the
041F08             0376*  ; operand value is used for all bytes adjusted.
041F08             0377*  
041F08             0378*  ; The “multiple operand values” mode allows for multiple operand
041F08             0379*  ; values to be used. When this mode is used, the count value must
041F08             0380*  ; be provided to indicate how many operand values should be used.
041F08             0381*  ; This can allow, for instance, to add together several bytes in a
041F08             0382*  ; buffer. When this mode is used in conjunction with the “multiple
041F08             0383*  ; target values” mode, the number of operand values must match the
041F08             0384*  ; number of target values, and the operation happens one byte at a
041F08             0385*  ; time.
041F08             0386*  
041F08             0387*  ; Some examples of advanced operations are as follows:
041F08             0388*  
041F08             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
041F08             0390*  
041F08             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
041F08             0392*  
041F08             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
041F08             0394*  ; modifier (&40).
041F08             0395*  
041F08             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
041F08             0397*  
041F08             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
041F08             0399*  
041F08             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
041F08             0401*  
041F08             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
041F08             0403*  
041F08             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
041F08             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
041F08             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
041F08             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
041F08             0408*  ; in little-endian order. As the top bit of the offset is set, this
041F08             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
041F08             0410*  ; Finally the value to write is sent, 42.
041F08             0411*  
041F08             0412*  ; An operation like this could be used to set the position as part
041F08             0413*  ; of a draw command.
041F08             0414*  
041F08             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
041F08             0416*  ; values 1, 2, 3, 4, 5:
041F08             0417*  
041F08             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
041F08             0419*  ; offset 12 (set it to 0)
041F08             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
041F08             0421*  
041F08             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
041F08             0423*  ; 7 bytes in buffer 4 starting at offset 42:
041F08             0424*  
041F08             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
041F08             0426*  
041F08             0427*  ; As we are working on a little-endian system, integers longer
041F08             0428*  ; than one byte are sent with their least significant byte first.
041F08             0429*  ; This means that the add with carry operation can be used to add
041F08             0430*  ; together integers of any size, so long as they are the same size.
041F08             0431*  ; To do this, both the “multiple target values” and “multiple
041F08             0432*  ; operand values” modes must be used.
041F08             0433*  
041F08             0434*  ; The following commands will add together a 16-bit, 24-bit,
041F08             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
041F08             0436*  ; in buffer 3 starting at offset 12, and all using the operand
041F08             0437*  ; value of 42:
041F08             0438*  
041F08             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
041F08             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
041F08             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
041F08             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
041F08             0443*  
041F08             0444*  ; Take note of how the operand value is padded out with zeros
041F08             0445*  ; to match the size of the target value. 42; is used as a base
041F08             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
041F08             0447*  ; 16-bits to pad it out to the required size. The “carry” value
041F08             0448*  ; will be stored at the next offset in the target buffer after
041F08             0449*  ; the complete target value. So for a 16-bit value, the carry
041F08             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
041F08             0451*  ; at offset 15, and so on.
041F08             0452*  
041F08             0453*  ; Command 6: Conditionally call a buffer
041F08             0454*  
041F08             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041F08             0456*  
041F08             0457*  ; This command will conditionally call a buffer if the condition
041F08             0458*  ; operation passes. This command works in a similar manner to the
041F08             0459*  ; “Adjust buffer contents” command.
041F08             0460*  
041F08             0461*  ; With this command a buffer ID of 65535 (-1) is always
041F08             0462*  ; interpretted as “current buffer”, and so can only be used
041F08             0463*  ; within a buffered command sequence. If used outside of a
041F08             0464*  ; buffered command sequence then this command will do nothing.
041F08             0465*  
041F08             0466*  ; The basic set of condition operations are as follows:
041F08             0467*  ; Operation 	Description
041F08             0468*  ; 0 	Exists (value is non-zero)
041F08             0469*  ; 1 	Not exists (value is zero)
041F08             0470*  ; 2 	Equal
041F08             0471*  ; 3 	Not equal
041F08             0472*  ; 4 	Less than
041F08             0473*  ; 5 	Greater than
041F08             0474*  ; 6 	Less than or equal
041F08             0475*  ; 7 	Greater than or equal
041F08             0476*  ; 8 	AND
041F08             0477*  ; 9 	OR
041F08             0478*  
041F08             0479*  ; The value that is being checked is fetched from the specified
041F08             0480*  ; check buffer ID and offset. With the exception of “Exists” and
041F08             0481*  ; “Not exists”, each command requires an operand value to be
041F08             0482*  ; specified to check against.
041F08             0483*  
041F08             0484*  ; The operation value used is an 8-bit value that can have bits
041F08             0485*  ; set to modify the behaviour of the operation. The following bits
041F08             0486*  ; are defined:
041F08             0487*  ; Bit value 	Description
041F08             0488*  ; &10 	Use advanced offsets
041F08             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041F08             0490*  
041F08             0491*  ; These modifiers can be combined together to modify the behaviour
041F08             0492*  ; of the operation.
041F08             0493*  
041F08             0494*  ; At this time, unlike with the “adjust” command, multiple target
041F08             0495*  ; values and multiple operand values are not supported. All
041F08             0496*  ; comparisons are therefore only conducted on single 8-bit values.
041F08             0497*  ; (If comparisons of 16-bit values are required, multiple calls
041F08             0498*  ; can be combined.) Support for them may be added in the future.
041F08             0499*  
041F08             0500*  ; The AND and OR operations are logical operations, and so the
041F08             0501*  ; operand value is used as a boolean value. Any non-zero value is
041F08             0502*  ; considered to be true, and zero is considered to be false. These
041F08             0503*  ; operations therefore are most useful when used with buffer-fetched
041F08             0504*  ; operand values (operations &28, &29, &38 and &39).
041F08             0505*  
041F08             0506*  ; Some examples of condition operations are as follows:
041F08             0507*  
041F08             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
041F08             0509*  ; (is non-zero):
041F08             0510*  
041F08             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041F08             0512*  
041F08             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
041F08             0514*  ; exist (is zero):
041F08             0515*  
041F08             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041F08             0517*  
041F08             0518*  ; Combining the above two examples is effectively equivalent to
041F08             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
041F08             0520*  
041F08             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041F08             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041F08             0523*  
041F08             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
041F08             0525*  
041F08             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
041F08             0527*  
041F08             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
041F08             0529*  ; the value in buffer 2 at offset 8:
041F08             0530*  
041F08             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
041F08             0532*  
041F08             0533*  ; Command 7: Jump to a buffer
041F08             0534*  
041F08             0535*  ; VDU 23, 0, &A0, bufferId; 7
041F08             0536*  
041F08             0537*  ; This command will jump to the buffer with the given ID. If
041F08             0538*  ; the buffer does not exist, or is empty, then this command will
041F08             0539*  ; do nothing.
041F08             0540*  
041F08             0541*  ; This essentially works the same as the call command (command 1),
041F08             0542*  ;  except that it does not return to the caller. This command is
041F08             0543*  ;  therefore useful for creating loops.
041F08             0544*  
041F08             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
041F08             0546*  ; treated as a “jump to end of current buffer”. This will return
041F08             0547*  ; execution to the caller, and can be useful for exiting a loop.
041F08             0548*  
041F08             0549*  ; ## Command 8: Conditional Jump to a buffer
041F08             0550*  
041F08             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041F08             0552*  
041F08             0553*  ; This command operates in a similar manner to the “Conditionally
041F08             0554*  ; call a buffer” command (command 6), except that it will jump to
041F08             0555*  ; the buffer if the condition operation passes.
041F08             0556*  
041F08             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
041F08             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
041F08             0559*  ; Command 9: Jump to an offset in a buffer
041F08             0560*  
041F08             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041F08             0562*  
041F08             0563*  ; This command will jump to the given offset in the buffer with the
041F08             0564*  ; given ID. If the buffer does not exist, or is empty, then this
041F08             0565*  ; command will do nothing.
041F08             0566*  
041F08             0567*  ; The offset in this command is always an “advanced” offset, given
041F08             0568*  ; as a 24-bit value in little-endian order. As with other uses of
041F08             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
041F08             0570*  ; offset value, a block number must also be provided.
041F08             0571*  
041F08             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
041F08             0573*  ; meaning “jump within current buffer”. This can be useful for
041F08             0574*  ; creating loops within a buffer, or when building up command
041F08             0575*  ; sequences that may be copied across multiple buffers.
041F08             0576*  
041F08             0577*  ; Jumping to an offset that is beyond the end of the buffer is
041F08             0578*  ; equivalent to jumping to the end of the buffer.
041F08             0579*  ; Command 10: Conditional jump to an offset in a buffer
041F08             0580*  
041F08             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041F08             0582*  
041F08             0583*  ; A conditional jump with an offset works in a similar manner to
041F08             0584*  ; the “Conditional call a buffer” command (command 6), except that
041F08             0585*  ; it will jump to the given offset in the buffer if the condition
041F08             0586*  ; operation passes.
041F08             0587*  
041F08             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
041F08             0589*  ; the offset in this command is always an “advanced” offset, given
041F08             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
041F08             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
041F08             0592*  ; treated as meaning “jump within current buffer”.
041F08             0593*  ; Command 11: Call buffer with an offset
041F08             0594*  
041F08             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041F08             0596*  
041F08             0597*  ; Works just like “Call a buffer” (command 1), except that it also
041F08             0598*  ; accepts an advanced offset.
041F08             0599*  
041F08             0600*  ; Command 12: Conditional call buffer with an offset
041F08             0601*  
041F08             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
041F08             0603*  
041F08             0604*  ; Works just like the “Conditional call a buffer” command
041F08             0605*  ; (command 6), except that it also accepts an advanced offset.
041F08             0606*  
041F08             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
041F08             0608*  
041F08             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
041F08             0610*  
041F08             0611*  ; This command will copy the contents of multiple buffers into a
041F08             0612*  ; single buffer. The buffers to copy from are specified as a list
041F08             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
041F08             0614*  ; buffers are copied in the order they are specified.
041F08             0615*  
041F08             0616*  ; This is a block-wise copy, so the blocks from the source buffers
041F08             0617*  ; are copied into the target buffer. The blocks are copied in the
041F08             0618*  ; order they are found in the source buffers.
041F08             0619*  
041F08             0620*  ; The target buffer will be overwritten with the contents of the
041F08             0621*  ; source buffers. This will not be done however until after all the
041F08             0622*  ; data has been gathered and copied. The target buffer can therefore
041F08             0623*  ; included in the list of the source buffers.
041F08             0624*  
041F08             0625*  ; If a source buffer that does not exist is specified, or a source
041F08             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
041F08             0627*  
041F08             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
041F08             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
041F08             0630*  ; copied multiple times into the target buffer.
041F08             0631*  
041F08             0632*  ; If there is insufficient memory available on the VDP to complete
041F08             0633*  ; this command then it will fail, and the target buffer will be
041F08             0634*  ; left unchanged.
041F08             0635*  
041F08             0636*  
041F08             0637*  ; Command 14: Consolidate blocks in a buffer
041F08             0638*  
041F08             0639*  ; VDU 23, 0, &A0, bufferId; 14
041F08             0640*  
041F08             0641*  ; Takes all the blocks in a buffer and consolidates them into a
041F08             0642*  ; single block. This is useful for bitmaps, as it allows for a
041F08             0643*  ; bitmap to be built up over time in multiple blocks, and then
041F08             0644*  ; consolidated into a single block for use as a bitmap.
041F08             0645*  
041F08             0646*  ; If there is insufficient memory available on the VDP to complete
041F08             0647*  ; this command then it will fail, and the buffer will be left
041F08             0648*  ; unchanged.
041F08             0649*  
041F08             0650*  ; Command 15: Split a buffer into multiple blocks
041F08             0651*  
041F08             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
041F08             0653*  
041F08             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
041F08             0655*  ; is a 16-bit integer that specifies the target size of each block.
041F08             0656*  ; If the source data is not a multiple of the block size then the
041F08             0657*  ; last block will be smaller than the specified block size.
041F08             0658*  
041F08             0659*  ; If this command is used on a buffer that is already split into
041F08             0660*  ; multiple blocks, then the blocks will be consolidated first,
041F08             0661*  ; and then re-split into the new block size.
041F08             0662*  
041F08             0663*  ; If there is insufficient memory available on the VDP to complete
041F08             0664*  ; this command then it will fail, and the buffer will be left
041F08             0665*  ; unchanged.
041F08             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
041F08             0667*  ; multiple buffers
041F08             0668*  
041F08             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0670*  
041F08             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
041F08             0672*  ; then spreads the resultant blocks across the target buffers.
041F08             0673*  ; The target buffers are specified as a list of buffer IDs,
041F08             0674*  ; terminated by a buffer ID of -1 (65535).
041F08             0675*  
041F08             0676*  ; The blocks are spread across the target buffers in the order
041F08             0677*  ; they are specified, and the spread will loop around the buffers
041F08             0678*  ; until all the blocks have been distributed. The target buffers
041F08             0679*  ; will be cleared out before the blocks are spread across them.
041F08             0680*  
041F08             0681*  ; What this means is that if the source buffer is, let’s say,
041F08             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
041F08             0683*  ; then we will end up with 10 blocks. If we then spread those
041F08             0684*  ; blocks across 3 target buffers, then the first buffer will
041F08             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
041F08             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
041F08             0687*  ; blocks 3, 6 and 9.
041F08             0688*  
041F08             0689*  ; This command attempts to ensure that, in the event of
041F08             0690*  ; insufficient memory being available on the VDP to complete
041F08             0691*  ; the command, it will leave the targets as they were before
041F08             0692*  ; the command was executed. However this may not always be
041F08             0693*  ; possible. The first step of this command is to consolidate
041F08             0694*  ; the source buffer into a single block, and this may fail from
041F08             0695*  ; insufficient memory. If that happens then all the buffers will
041F08             0696*  ; be left as they were. After this however the target buffers
041F08             0697*  ; will be cleared. If there is insufficient memory to successfully
041F08             0698*  ; split the buffer into multiple blocks then the call will exit,
041F08             0699*  ; and the target buffers will be left empty.
041F08             0700*  ; Command 17: Split a buffer and spread across blocks, starting
041F08             0701*  ; at target buffer ID
041F08             0702*  
041F08             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
041F08             0704*  
041F08             0705*  ; As per the above two commands, this will split a buffer into
041F08             0706*  ; multiple blocks. It will then spread the blocks across buffers
041F08             0707*  ; starting at the target buffer ID, incrementing the target buffer
041F08             0708*  ; ID until all the blocks have been distributed.
041F08             0709*  
041F08             0710*  ; Target blocks will be cleared before a block is stored in them.
041F08             0711*  ; Each target will contain a single block. The exception to this
041F08             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
041F08             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
041F08             0714*  ; will be placed into buffer 65534.
041F08             0715*  
041F08             0716*  ; With this command if there is insufficient memory available on
041F08             0717*  ; the VDP to complete the command then it will fail, and the target
041F08             0718*  ; buffers will be left unchanged.
041F08             0719*  
041F08             0720*  ; Command 18: Split a buffer into blocks by width
041F08             0721*  
041F08             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
041F08             0723*  
041F08             0724*  ; This command splits a buffer into a given number of blocks by
041F08             0725*  ; first of all splitting the buffer into blocks of a given width
041F08             0726*  ; (number of bytes), and then consolidating those blocks into the
041F08             0727*  ; given number of blocks.
041F08             0728*  
041F08             0729*  ; This is useful for splitting a bitmap into a number of separate
041F08             0730*  ; columns, which can then be manipulated individually. This can be
041F08             0731*  ; useful for dealing with sprite sheets.
041F08             0732*  ; Command 19: Split by width into blocks and spread across target
041F08             0733*  ; buffers
041F08             0734*  
041F08             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0736*  
041F08             0737*  ; This command essentially operates the same as command 18, but the
041F08             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
041F08             0739*  
041F08             0740*  ; Command 20: Split by width into blocks and spread across blocks
041F08             0741*  ; starting at target buffer ID
041F08             0742*  
041F08             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
041F08             0744*  
041F08             0745*  ; This command essentially operates the same as command 18, but
041F08             0746*  ; the generated blocks are spread across blocks starting at the
041F08             0747*  ; target buffer ID, as per command 17.
041F08             0748*  
041F08             0749*  ; Command 21: Spread blocks from a buffer across multiple target
041F08             0750*  ; buffers
041F08             0751*  
041F08             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
041F08             0753*  
041F08             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
041F08             0755*  ; The target buffers are specified as a list of buffer IDs,
041F08             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
041F08             0757*  ; across the target buffers in the order they are specified, and
041F08             0758*  ; the spread will loop around the buffers until all the blocks have
041F08             0759*  ; been distributed.
041F08             0760*  
041F08             0761*  ; It should be noted that this command does not copy the blocks,
041F08             0762*  ; and nor does it move them. Unless the source buffer has been
041F08             0763*  ; included in the list of targets, it will remain completely
041F08             0764*  ; intact. The blocks distributed across the target buffers will
041F08             0765*  ; point to the same memory as the blocks in the source buffer.
041F08             0766*  ; Operations to modify data in the source buffer will also modify
041F08             0767*  ; the data in the target buffers. Clearing the source buffer
041F08             0768*  ; however will not clear the target buffers.
041F08             0769*  
041F08             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
041F08             0771*  ; at target buffer ID
041F08             0772*  
041F08             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
041F08             0774*  
041F08             0775*  ; Spreads the blocks from a buffer across blocks starting at
041F08             0776*  ; the target buffer ID.
041F08             0777*  
041F08             0778*  ; This essentially works the same as command 21, and the same
041F08             0779*  ; notes about copying and moving blocks apply. Blocks are spread
041F08             0780*  ; in the same manner as commands 17 and 20.
041F08             0781*  
041F08             0782*  ; Command 23: Reverse the order of blocks in a buffer
041F08             0783*  
041F08             0784*  ; VDU 23, 0, &A0, bufferId; 23
041F08             0785*  
041F08             0786*  ; Reverses the order of the blocks in a buffer.
041F08             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
041F08             0788*  
041F08             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041F08             0790*  
041F08             0791*  ; Reverses the order of the data within the blocks of a buffer.
041F08             0792*  ; The options parameter is an 8-bit value that can have bits set
041F08             0793*  ; to modify the behaviour of the operation. The following bits
041F08             0794*  ; are defined:
041F08             0795*  ; Bit value 	Description
041F08             0796*  ; 1 	Values are 16-bits in size
041F08             0797*  ; 2 	Values are 32-bits in size
041F08             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
041F08             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
041F08             0800*  ; 8 	Reverse blocks
041F08             0801*  
041F08             0802*  ; These modifiers can be combined together to modify the behaviour
041F08             0803*  ; of the operation.
041F08             0804*  
041F08             0805*  ; If no value size is set in the options (i.e. the value of the
041F08             0806*  ; bottom two bits of the options is zero) then the value size is
041F08             0807*  ; assumed to be 8-bits.
041F08             0808*  
041F08             0809*  ; It is probably easiest to understand what this operation is
041F08             0810*  ; capable of by going through some examples of how it can be used
041F08             0811*  ; to manipulate bitmaps. The VDP supports two different formats
041F08             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
041F08             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
041F08             0814*  ; pixel.
041F08             0815*  
041F08             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
041F08             0817*  ; degrees, which can be done by just reversing the order of
041F08             0818*  ; bytes in the buffer:
041F08             0819*  
041F08             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
041F08             0821*  
041F08             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
041F08             0823*  ; little more complex, as each pixel is made up of 4 bytes.
041F08             0824*  ; However with this command it is still a simple operation, as
041F08             0825*  ; we can just reverse the order of the 32-bit values that make
041F08             0826*  ; up the bitmap by using an options value of 2:
041F08             0827*  
041F08             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
041F08             0829*  
041F08             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
041F08             0831*  ; the order of rows of pixels. To do this we can set a custom
041F08             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
041F08             0833*  ; bitmap we can just set a custom value size to our bitmap width:
041F08             0834*  
041F08             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
041F08             0836*  
041F08             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
041F08             0838*  ; our width by 4:
041F08             0839*  
041F08             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
041F08             0841*  
041F08             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
041F08             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
041F08             0844*  ; just set a custom chunk size to our bitmap width:
041F08             0845*  
041F08             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
041F08             0847*  
041F08             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
041F08             0849*  ; 32-bit values as well as a custom chunk size:
041F08             0850*  
041F08             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
041F08             0852*  
041F08             0853*  ; Command 25: Copy blocks from multiple buffers by reference
041F08             0854*  
041F08             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
041F08             0856*  
041F08             0857*  ; This command is essentially a version of command 13 that copies
041F08             0858*  ; blocks by reference rather than by value. The parameters for
041F08             0859*  ; this command are the same as for command 13, and the same rules
041F08             0860*  ; apply.
041F08             0861*  
041F08             0862*  ; If the target buffer is included in the list of source buffers
041F08             0863*  ; then it will be skipped to prevent a reference loop.
041F08             0864*  
041F08             0865*  ; Copying by reference means that the blocks in the target buffer
041F08             0866*  ; will point to the same memory as the blocks in the source
041F08             0867*  ; buffers. Operations to modify data blocks in the source buffers
041F08             0868*  ; will therefore also modify those blocks in the target buffer.
041F08             0869*  ; Clearing the source buffers will not clear the target buffer -
041F08             0870*  ; it will still point to the original data blocks. Data blocks
041F08             0871*  ; are only freed from memory when no buffers are left with any
041F08             0872*  ; references to them.
041F08             0873*  
041F08             0874*  ; Buffers that get consolidated become new blocks, so will lose
041F08             0875*  ; their links to the original blocks, thus after a “consolidate”
041F08             0876*  ; operation modifications to the original blocks will no longer be
041F08             0877*  ; reflected in the consolidated buffer.
041F08             0878*  
041F08             0879*  ; This command is useful to construct a single buffer from multiple
041F08             0880*  ; sources without the copy overhead, which can be costly. For
041F08             0881*  ; example, this can be useful for constructing a bitmap from
041F08             0882*  ; multiple constituent parts before consolidating it into a
041F08             0883*  ; single block. In such an example, using command 13 instead
041F08             0884*  ; would first make a copy of the contents of the source buffers,
041F08             0885*  ; and then consolidate them into a single block. Using this
041F08             0886*  ; command does not make that first copy, and so would be faster.
041F08             0887*  
041F08             0888*  ; This command is also useful for creating multiple buffers that
041F08             0889*  ; all point to the same data.
041F08             0890*  
041F08             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
041F08             0892*  
041F08             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
041F08             0055       include "vdu_plot.inc"
041F08             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F08             0002*  ; PLOT code 	(Decimal) 	Effect
041F08             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
041F08             0004*  plot_sl_both: equ 0x00
041F08             0005*  
041F08             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
041F08             0007*  plot_sl_first: equ 0x08
041F08             0008*  
041F08             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041F08             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041F08             0011*  
041F08             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
041F08             0013*  plot_sl_last: equ 0x20
041F08             0014*  
041F08             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
041F08             0016*  plot_sl_none: equ 0x28
041F08             0017*  
041F08             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041F08             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041F08             0020*  
041F08             0021*  ; &40-&47 	64-71 	Point plot
041F08             0022*  plot_pt: equ 0x40
041F08             0023*  
041F08             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041F08             0025*  plot_lf_lr_non_bg: equ 0x48
041F08             0026*  
041F08             0027*  ; &50-&57 	80-87 	Triangle fill
041F08             0028*  plot_tf: equ 0x50
041F08             0029*  
041F08             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
041F08             0031*  plot_lf_r_bg: equ 0x58
041F08             0032*  
041F08             0033*  ; &60-&67 	96-103 	Rectangle fill
041F08             0034*  plot_rf: equ 0x60
041F08             0035*  
041F08             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041F08             0037*  plot_lf_lr_fg: equ 0x60
041F08             0038*  
041F08             0039*  ; &70-&77 	112-119 	Parallelogram fill
041F08             0040*  plot_pf: equ 0x70
041F08             0041*  
041F08             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041F08             0043*  plot_lf_r_non_fg: equ 0x78
041F08             0044*  
041F08             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
041F08             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041F08             0047*  
041F08             0048*  ; &90-&97 	144-151 	Circle outline
041F08             0049*  plot_co: equ 0x90
041F08             0050*  
041F08             0051*  ; &98-&9F 	152-159 	Circle fill
041F08             0052*  plot_cf: equ 0x98
041F08             0053*  
041F08             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
041F08             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
041F08             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
041F08             0057*  
041F08             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
041F08             0059*  plot_rcm: equ 0xB8
041F08             0060*  
041F08             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041F08             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041F08             0063*  ; &D0-&D7 	208-215 	Not defined
041F08             0064*  ; &D8-&DF 	216-223 	Not defined
041F08             0065*  ; &E0-&E7 	224-231 	Not defined
041F08             0066*  
041F08             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
041F08             0068*  plot_bmp: equ 0xE8
041F08             0069*  
041F08             0070*  ; &F0-&F7 	240-247 	Not defined
041F08             0071*  ; &F8-&FF 	248-255 	Not defined
041F08             0072*  
041F08             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041F08             0074*  ; Agon Console8 VDP 2.2.0
041F08             0075*  
041F08             0076*  ; Within each group of eight plot codes, the effects are as follows:
041F08             0077*  ; Plot code 	Effect
041F08             0078*  ; 0 	Move relative
041F08             0079*  mv_rel: equ 0
041F08             0080*  
041F08             0081*  ; 1 	Plot relative in current foreground colour
041F08             0082*  dr_rel_fg: equ 1
041F08             0083*  
041F08             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
041F08             0085*  ; 3 	Plot relative in current background colour
041F08             0086*  dr_rel_bg: equ 3
041F08             0087*  
041F08             0088*  ; 4 	Move absolute
041F08             0089*  mv_abs: equ 4
041F08             0090*  
041F08             0091*  ; 5 	Plot absolute in current foreground colour
041F08             0092*  dr_abs_fg: equ 5
041F08             0093*  
041F08             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
041F08             0095*  ; 7 	Plot absolute in current background colour
041F08             0096*  dr_abs_bg: equ 7
041F08             0097*  
041F08             0098*  ; Codes 0-3 use the position data provided as part of the command
041F08             0099*  ; as a relative position, adding the position given to the current
041F08             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
041F08             0101*  ; as part of the command as an absolute position, setting the current
041F08             0102*  ; graphical cursor position to the position given.
041F08             0103*  
041F08             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041F08             0105*  ; current pixel colour. These operations cannot currently be supported
041F08             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
041F08             0107*  ; supported. Support for these codes may be added in a future version
041F08             0108*  ; of the VDP firmware.
041F08             0109*  
041F08             0110*  ; 16 colour palette constants
041F08             0111*  c_black: equ 0
041F08             0112*  c_red_dk: equ 1
041F08             0113*  c_green_dk: equ 2
041F08             0114*  c_yellow_dk: equ 3
041F08             0115*  c_blue_dk: equ 4
041F08             0116*  c_magenta_dk: equ 5
041F08             0117*  c_cyan_dk: equ 6
041F08             0118*  c_grey: equ 7
041F08             0119*  c_grey_dk: equ 8
041F08             0120*  c_red: equ 9
041F08             0121*  c_green: equ 10
041F08             0122*  c_yellow: equ 11
041F08             0123*  c_blue: equ 12
041F08             0124*  c_magenta: equ 13
041F08             0125*  c_cyan: equ 14
041F08             0126*  c_white: equ 15
041F08             0127*  
041F08             0128*  ; VDU 25, mode, x; y;: PLOT command
041F08             0129*  ; inputs: a=mode, bc=x0, de=y0
041F08             0130*  vdu_plot:
041F08 32 22 1F 04 0131*      ld (@mode),a
041F0C ED 43 23 1F 0132*      ld (@x0),bc
       04          
041F11 ED 53 25 1F 0133*      ld (@y0),de
       04          
041F16 21 21 1F 04 0134*  	ld hl,@cmd
041F1A 01 06 00 00 0135*  	ld bc,@end-@cmd
041F1E 5B DF       0136*  	rst.lil $18
041F20 C9          0137*  	ret
041F21 19          0138*  @cmd:   db 25
041F22 00          0139*  @mode:  db 0
041F23 00 00       0140*  @x0: 	dw 0
041F25 00 00       0141*  @y0: 	dw 0
041F27 00          0142*  @end:   db 0 ; extra byte to soak up deu
041F28             0143*  
041F28             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F28             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
041F28             0146*  ; VDU 25, mode, x; y;: PLOT command
041F28             0147*  ; inputs: bc=x0, de=y0
041F28             0148*  ; prerequisites: vdu_buff_select
041F28             0149*  vdu_plot_bmp:
041F28 ED 43 3F 1F 0150*      ld (@x0),bc
       04          
041F2D ED 53 41 1F 0151*      ld (@y0),de
       04          
041F32 21 3D 1F 04 0152*  	ld hl,@cmd
041F36 01 06 00 00 0153*  	ld bc,@end-@cmd
041F3A 5B DF       0154*  	rst.lil $18
041F3C C9          0155*  	ret
041F3D 19          0156*  @cmd:   db 25
041F3E ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041F3F 00 00       0158*  @x0: 	dw 0x0000
041F41 00 00       0159*  @y0: 	dw 0x0000
041F43 00          0160*  @end:   db 0x00 ; padding
041F44             0161*  
041F44             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F44             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
041F44             0164*  ; VDU 25, mode, x; y;: PLOT command
041F44             0165*  ; inputs: bc=x0, de=y0
041F44             0166*  ; USING 16.8 FIXED POINT COORDINATES
041F44             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041F44             0168*  ;   the fractional portiion of the inputs are truncated
041F44             0169*  ;   leaving only the 16-bit integer portion
041F44             0170*  ; prerequisites: vdu_buff_select
041F44             0171*  vdu_plot_bmp168:
041F44             0172*  ; populate in the reverse of normal to keep the
041F44             0173*  ; inputs from stomping on each other
041F44 ED 53 62 1F 0174*      ld (@y0-1),de
       04          
041F49 ED 43 60 1F 0175*      ld (@x0-1),bc
       04          
041F4E 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041F50 32 60 1F 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041F54 21 5F 1F 04 0178*  	ld hl,@cmd
041F58 01 06 00 00 0179*  	ld bc,@end-@cmd
041F5C 5B DF       0180*  	rst.lil $18
041F5E C9          0181*  	ret
041F5F 19          0182*  @cmd:   db 25
041F60 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041F61 00 00       0184*  @x0: 	dw 0x0000
041F63 00 00       0185*  @y0: 	dw 0x0000
041F65             0186*  @end:  ; no padding required b/c we shifted de right
041F65             0187*  
041F65             0188*  ; draw a filled rectangle
041F65             0189*  vdu_plot_rf:
041F65 ED 43 8C 1F 0190*      ld (@x0),bc
       04          
041F6A ED 53 8E 1F 0191*      ld (@y0),de
       04          
041F6F DD 22 92 1F 0192*      ld (@x1),ix
       04          
041F74 FD 22 94 1F 0193*      ld (@y1),iy
       04          
041F79 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041F7B 32 90 1F 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F7F 21 8A 1F 04 0196*  	ld hl,@cmd0
041F83 01 0C 00 00 0197*  	ld bc,@end-@cmd0
041F87 5B DF       0198*  	rst.lil $18
041F89 C9          0199*      ret
041F8A 19          0200*  @cmd0:  db 25 ; plot
041F8B 04          0201*  @arg0:  db plot_sl_both+mv_abs
041F8C 00 00       0202*  @x0:    dw 0x0000
041F8E 00 00       0203*  @y0:    dw 0x0000
041F90 19          0204*  @cmd1:  db 25 ; plot
041F91 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041F92 00 00       0206*  @x1:    dw 0x0000
041F94 00 00       0207*  @y1:    dw 0x0000
041F96 00          0208*  @end:   db 0x00 ; padding
041F97             0209*  
041F97             0210*  ; draw a filled circle
041F97             0211*  vdu_plot_cf:
041F97 ED 43 BE 1F 0212*      ld (@x0),bc
       04          
041F9C ED 53 C0 1F 0213*      ld (@y0),de
       04          
041FA1 DD 22 C4 1F 0214*      ld (@x1),ix
       04          
041FA6 FD 22 C6 1F 0215*      ld (@y1),iy
       04          
041FAB 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041FAD 32 C2 1F 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041FB1 21 BC 1F 04 0218*  	ld hl,@cmd0
041FB5 01 0C 00 00 0219*  	ld bc,@end-@cmd0
041FB9 5B DF       0220*  	rst.lil $18
041FBB C9          0221*      ret
041FBC 19          0222*  @cmd0:  db 25 ; plot
041FBD 04          0223*  @arg0:  db plot_sl_both+mv_abs
041FBE 00 00       0224*  @x0:    dw 0x0000
041FC0 00 00       0225*  @y0:    dw 0x0000
041FC2 19          0226*  @cmd1:  db 25 ; plot
041FC3 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
041FC4 00 00       0228*  @x1:    dw 0x0000
041FC6 00 00       0229*  @y1:    dw 0x0000
041FC8 00          0230*  @end:   db 0x00 ; padding
041FC9             0056   	include "vdu_sprites.inc"
041FC9             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041FC9             0002*  ; the VDP can support up to 256 sprites. They must be defined
041FC9             0003*  ; contiguously, and so the first sprite is sprite 0.
041FC9             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041FC9             0005*  ; Once a selection of sprites have been defined, you can activate
041FC9             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
041FC9             0007*  ; of sprites to activate. This will activate the first n sprites,
041FC9             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041FC9             0009*  
041FC9             0010*  ; A single sprite can have multiple "frames", referring to
041FC9             0011*  ; different bitmaps.
041FC9             0012*  ; (These bitmaps do not need to be the same size.)
041FC9             0013*  ; This allows a sprite to include an animation sequence,
041FC9             0014*  ; which can be stepped through one frame at a time, or picked
041FC9             0015*  ; in any order.
041FC9             0016*  
041FC9             0017*  ; Any format of bitmap can be used as a sprite frame. It should
041FC9             0018*  ; be noted however that "native" format bitmaps are not
041FC9             0019*  ; recommended for use as sprite frames, as they cannot get
041FC9             0020*  ; erased from the screen. (As noted above, the "native" bitmap
041FC9             0021*  ; format is not really intended for general use.) This is part
041FC9             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041FC9             0023*  ; screen are now stored in RGBA2222 format.
041FC9             0024*  
041FC9             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
041FC9             0026*  ; and then later shown again.
041FC9             0027*  
041FC9             0028*  ; Moving sprites around the screen is done by changing the
041FC9             0029*  ; position of the sprite. This can be done either by setting
041FC9             0030*  ; the absolute position of the sprite, or by moving the sprite
041FC9             0031*  ; by a given number of pixels. (Sprites are positioned using
041FC9             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
041FC9             0033*  ; In the current sprite system, sprites will not update their
041FC9             0034*  ; position on-screen until either another drawing operation is
041FC9             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
041FC9             0036*  
041FC9             0037*  ; VDU 23, 27, 4, n: Select sprite n
041FC9             0038*  ; inputs: a is the 8-bit sprite id
041FC9             0039*  vdu_sprite_select:
041FC9 32 DB 1F 04 0040*      ld (@sprite),a
041FCD 21 D8 1F 04 0041*      ld hl,@cmd
041FD1 01 04 00 00 0042*      ld bc,@end-@cmd
041FD5 5B DF       0043*      rst.lil $18
041FD7 C9          0044*      ret
041FD8 17 1B 04    0045*  @cmd:    db 23,27,4
041FDB 00          0046*  @sprite: db 0x00
041FDC             0047*  @end:
041FDC             0048*  
041FDC             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
041FDC             0050*  ; inputs: none
041FDC             0051*  ; prerequisites: vdu_sprite_select
041FDC             0052*  vdu_sprite_clear_frames:
041FDC 21 E7 1F 04 0053*      ld hl,@cmd
041FE0 01 03 00 00 0054*      ld bc,@end-@cmd
041FE4 5B DF       0055*      rst.lil $18
041FE6 C9          0056*      ret
041FE7 17 1B 05    0057*  @cmd: db 23,27,5
041FEA             0058*  @end:
041FEA             0059*  
041FEA             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
041FEA             0061*  ; inputs: a is the 8-bit bitmap number
041FEA             0062*  ; prerequisites: vdu_sprite_select
041FEA             0063*  vdu_sprite_add_bmp:
041FEA 32 FC 1F 04 0064*      ld (@bmp),a
041FEE 21 F9 1F 04 0065*      ld hl,@cmd
041FF2 01 04 00 00 0066*      ld bc,@end-@cmd
041FF6 5B DF       0067*      rst.lil $18
041FF8 C9          0068*      ret
041FF9 17 1B 06    0069*  @cmd: db 23,27,6
041FFC 00          0070*  @bmp: db 0x00
041FFD             0071*  @end:
041FFD             0072*  
041FFD             0073*  ; VDU 23, 27, 7, n: Activate n sprites
041FFD             0074*  ; inputs: a is the number of sprites to activate
041FFD             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
041FFD             0076*  vdu_sprite_activate:
041FFD 32 0F 20 04 0077*      ld (@num),a
042001 21 0C 20 04 0078*      ld hl,@cmd
042005 01 04 00 00 0079*      ld bc,@end-@cmd
042009 5B DF       0080*      rst.lil $18
04200B C9          0081*      ret
04200C 17 1B 07    0082*  @cmd: db 23,27,7
04200F 00          0083*  @num: db 0x00
042010             0084*  @end:
042010             0085*  
042010             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
042010             0087*  ; inputs: none
042010             0088*  ; prerequisites: vdu_sprite_select
042010             0089*  vdu_sprite_next_frame:
042010 21 1B 20 04 0090*      ld hl,@cmd
042014 01 03 00 00 0091*      ld bc,@end-@cmd
042018 5B DF       0092*      rst.lil $18
04201A C9          0093*      ret
04201B 17 1B 08    0094*  @cmd: db 23,27,8
04201E             0095*  @end:
04201E             0096*  
04201E             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04201E             0098*  ; inputs: none
04201E             0099*  ; prerequisites: vdu_sprite_select
04201E             0100*  vdu_sprite_prev_frame:
04201E 21 29 20 04 0101*      ld hl,@cmd
042022 01 03 00 00 0102*      ld bc,@end-@cmd
042026 5B DF       0103*      rst.lil $18
042028 C9          0104*      ret
042029 17 1B 09    0105*  @cmd: db 23,27,9
04202C             0106*  @end:
04202C             0107*  
04202C             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
04202C             0109*  ; inputs: a is frame number to select
04202C             0110*  ; prerequisites: vdu_sprite_select
04202C             0111*  vdu_sprite_select_frame:
04202C 32 3E 20 04 0112*      ld (@frame),a
042030 21 3B 20 04 0113*      ld hl,@cmd
042034 01 04 00 00 0114*      ld bc,@end-@cmd
042038 5B DF       0115*      rst.lil $18
04203A C9          0116*      ret
04203B 17 1B 0A    0117*  @cmd:    db 23,27,10
04203E 00          0118*  @frame:  db 0x00
04203F             0119*  @end:
04203F             0120*  
04203F             0121*  ; VDU 23, 27, 11: Show current sprite
04203F             0122*  ; inputs: none
04203F             0123*  ; prerequisites: vdu_sprite_select
04203F             0124*  vdu_sprite_show:
04203F 21 4A 20 04 0125*      ld hl,@cmd
042043 01 03 00 00 0126*      ld bc,@end-@cmd
042047 5B DF       0127*      rst.lil $18
042049 C9          0128*      ret
04204A 17 1B 0B    0129*  @cmd: db 23,27,11
04204D             0130*  @end:
04204D             0131*  
04204D             0132*  ; VDU 23, 27, 12: Hide current sprite
04204D             0133*  ; inputs: none
04204D             0134*  ; prerequisites: vdu_sprite_select
04204D             0135*  vdu_sprite_hide:
04204D 21 58 20 04 0136*      ld hl,@cmd
042051 01 03 00 00 0137*      ld bc,@end-@cmd
042055 5B DF       0138*      rst.lil $18
042057 C9          0139*      ret
042058 17 1B 0C    0140*  @cmd: db 23,27,12
04205B             0141*  @end:
04205B             0142*  
04205B             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04205B             0144*  ; inputs: bc is x coordinate, de is y coordinate
04205B             0145*  ; prerequisites: vdu_sprite_select
04205B             0146*  vdu_sprite_move_abs:
04205B ED 43 73 20 0147*      ld (@xpos),bc
       04          
042060 ED 53 75 20 0148*      ld (@ypos),de
       04          
042065 21 70 20 04 0149*      ld hl,@cmd
042069 01 07 00 00 0150*      ld bc,@end-@cmd
04206D 5B DF       0151*      rst.lil $18
04206F C9          0152*      ret
042070 17 1B 0D    0153*  @cmd:  db 23,27,13
042073 00 00       0154*  @xpos: dw 0x0000
042075 00 00       0155*  @ypos: dw 0x0000
042077 00          0156*  @end:  db 0x00 ; padding
042078             0157*  
042078             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042078             0159*  ; inputs: bc is x coordinate, de is y coordinate
042078             0160*  ; prerequisites: vdu_sprite_select
042078             0161*  vdu_sprite_move_rel:
042078 ED 43 90 20 0162*      ld (@dx),bc
       04          
04207D ED 53 92 20 0163*      ld (@dy),de
       04          
042082 21 8D 20 04 0164*      ld hl,@cmd
042086 01 07 00 00 0165*      ld bc,@end-@cmd
04208A 5B DF       0166*      rst.lil $18
04208C C9          0167*      ret
04208D 17 1B 0E    0168*  @cmd: db 23,27,14
042090 00 00       0169*  @dx:  dw 0x0000
042092 00 00       0170*  @dy:  dw 0x0000
042094 00          0171*  @end: db 0x00 ; padding
042095             0172*  
042095             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042095             0174*  ; USING 16.8 FIXED POINT COORDINATES
042095             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042095             0176*  ;   the fractional portiion of the inputs are truncated
042095             0177*  ;   leaving only the 16-bit integer portion
042095             0178*  ; prerequisites: vdu_sprite_select
042095             0179*  vdu_sprite_move_abs168:
042095             0180*  ; populate in the reverse of normal to keep the
042095             0181*  ; inputs from stomping on each other
042095 ED 53 B4 20 0182*      ld (@ypos-1),de
       04          
04209A ED 43 B2 20 0183*      ld (@xpos-1),bc
       04          
04209F 3E 0D       0184*      ld a,13       ; restore the final byte of the command
0420A1 32 B2 20 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
0420A5 21 B0 20 04 0186*      ld hl,@cmd
0420A9 01 07 00 00 0187*      ld bc,@end-@cmd
0420AD 5B DF       0188*      rst.lil $18
0420AF C9          0189*      ret
0420B0 17 1B 0D    0190*  @cmd:  db 23,27,13
0420B3 00 00       0191*  @xpos: dw 0x0000
0420B5 00 00       0192*  @ypos: dw 0x0000
0420B7             0193*  @end:  ; no padding required b/c we shifted de right
0420B7             0194*  
0420B7             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0420B7             0196*  ; USING 16.8 FIXED POINT COORDINATES
0420B7             0197*  ; inputs: ub.c is dx, ud.e is dy
0420B7             0198*  ;   the fractional portiion of the inputs are truncated
0420B7             0199*  ;   leaving only the 16-bit integer portion
0420B7             0200*  ; prerequisites: vdu_sprite_select
0420B7             0201*  vdu_sprite_move_rel168:
0420B7             0202*  ; populate in the reverse of normal to keep the
0420B7             0203*  ; inputs from stomping on each other
0420B7 ED 53 D6 20 0204*      ld (@dy-1),de
       04          
0420BC ED 43 D4 20 0205*      ld (@dx-1),bc
       04          
0420C1 3E 0E       0206*      ld a,14       ; restore the final byte of the command
0420C3 32 D4 20 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
0420C7 21 D2 20 04 0208*      ld hl,@cmd
0420CB 01 07 00 00 0209*      ld bc,@end-@cmd
0420CF 5B DF       0210*      rst.lil $18
0420D1 C9          0211*      ret
0420D2 17 1B 0E    0212*  @cmd:  db 23,27,14
0420D5 00 00       0213*  @dx: dw 0x0000
0420D7 00 00       0214*  @dy: dw 0x0000
0420D9             0215*  @end:  ; no padding required b/c we shifted de right
0420D9             0216*  
0420D9             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
0420D9             0218*  ; inputs: none
0420D9             0219*  vdu_sprite_update:
0420D9 21 E4 20 04 0220*      ld hl,@cmd
0420DD 01 03 00 00 0221*      ld bc,@end-@cmd
0420E1 5B DF       0222*      rst.lil $18
0420E3 C9          0223*      ret
0420E4 17 1B 0F    0224*  @cmd: db 23,27,15
0420E7             0225*  @end:
0420E7             0226*  
0420E7             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0420E7             0228*  ; inputs: none
0420E7             0229*  vdu_sprite_bmp_reset:
0420E7 21 F2 20 04 0230*      ld hl,@cmd
0420EB 01 03 00 00 0231*      ld bc,@end-@cmd
0420EF 5B DF       0232*      rst.lil $18
0420F1 C9          0233*      ret
0420F2 17 1B 10    0234*  @cmd: db 23,27,16
0420F5             0235*  @end:
0420F5             0236*  
0420F5             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0420F5             0238*  ; inputs: none
0420F5             0239*  vdu_sprite_reset:
0420F5 21 00 21 04 0240*      ld hl,@cmd
0420F9 01 03 00 00 0241*      ld bc,@end-@cmd
0420FD 5B DF       0242*      rst.lil $18
0420FF C9          0243*      ret
042100 17 1B 11    0244*  @cmd: db 23,27,17
042103             0245*  @end:
042103             0246*  
042103             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042103             0248*  ; inputs: a is the GCOL paint mode
042103             0249*  ; prerequisites: vdu_sprite_select
042103             0250*  vdu_sprite_set_gcol:
042103 32 15 21 04 0251*      ld (@mode),a
042107 21 12 21 04 0252*      ld hl,@cmd
04210B 01 04 00 00 0253*      ld bc,@end-@cmd
04210F 5B DF       0254*      rst.lil $18
042111 C9          0255*      ret
042112 17 1B 12    0256*  @cmd:  db 23,27,18
042115 00          0257*  @mode: db 0x00
042116             0258*  @end:
042116             0259*  
042116             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
042116             0261*  ; inputs: hl=bufferId
042116             0262*  ; prerequisites: vdu_sprite_select
042116             0263*  vdu_sprite_add_buff:
042116 22 28 21 04 0264*      ld (@bufferId),hl
04211A 21 25 21 04 0265*      ld hl,@cmd
04211E 01 05 00 00 0266*      ld bc,@end-@cmd
042122 5B DF       0267*      rst.lil $18
042124 C9          0268*      ret
042125 17 1B 26    0269*  @cmd:      db 23,27,0x26
042128 00 00       0270*  @bufferId: dw 0x0000
04212A 00          0271*  @end:      db 0x00 ; padding
04212B             0057   	include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
04212B             0001*  ; 24-bit integer and 16.8 fixed point division routines
04212B             0002*  ; by Brandon R. Gates (BeeGee747)
04212B             0003*  ; have undergone cursory testing and seem to be generating
04212B             0004*  ; correct results (assuming no overflows) but seem very inefficient,
04212B             0005*  ; so they have been published for review and improvement
04212B             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
04212B             0007*  ;
04212B             0008*  ; ---------------------------------------------------------
04212B             0009*  ; BEGIN DIVISION ROUTINES
04212B             0010*  ; ---------------------------------------------------------
04212B             0011*  ;
04212B             0012*  ; perform signed division of 16.8 fixed place values
04212B             0013*  ; with an signed 16.8 fixed place result
04212B             0014*  ; inputs: ub.c is dividend,ud.e is divisor
04212B             0015*  ; outputs: uh.l is quotient
04212B             0016*  ; destroys: a,bc
04212B             0017*  ; note: uses carry flag to test for sign of operands and result
04212B             0018*  ;       which can be confusing and should perhaps be changed
04212B             0019*  ; note2: helper functions abs_hlu and neg_hlu have been modified
04212B             0020*  ;       to return accurate flags according to the origional signs
04212B             0021*  ;       (or zero) of this function's inputs
04212B             0022*  sdiv168:
04212B             0023*  ; make everything positive and save signs
04212B C5          0024*      push bc         ; get bc to hl
04212C E1          0025*      pop hl          ; for the next call
04212D CD D2 21 04 0026*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
042131 CA 64 21 04 0027*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
042135 F5          0028*      push af         ; save sign of bc
042136 E5          0029*      push hl         ; now put abs(hl)
042137 C1          0030*      pop bc          ; back into bc = abs(bc)
042138 EB          0031*      ex de,hl        ; now we do de same way
042139 CD D2 21 04 0032*      call abs_hlu
04213D CA 66 21 04 0033*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
042141 EB          0034*      ex de,hl        ; hl back to de = abs(de)
042142             0035*  ; determine sign of result
042142 F2 4D 21 04 0036*      jp p,@de_pos    ; sign positive,de is positive
042146 F1          0037*      pop af          ; get back sign of bc
042147 FA 56 21 04 0038*      jp m,@result_pos  ; bc and de negative, result is positive
04214B 18 05       0039*      jr @result_neg
04214D             0040*  @de_pos:
04214D F1          0041*      pop af          ; get back sign of bc
04214E F2 56 21 04 0042*      jp p,@result_pos   ; bc and de are both positive so result is positive
042152             0043*                      ; fall through to result_neg
042152             0044*  @result_neg:
042152 AF          0045*      xor a           ; zero a and clear carry
042153 3D          0046*      dec a           ; set sign flag to negative
042154 18 02       0047*      jr @do_div
042156             0048*  @result_pos:
042156 AF          0049*      xor a           ; zero a and clear carry
042157 3C          0050*      inc a           ; set sign flag to negative
042158             0051*                      ; fall through to do_div
042158             0052*  @do_div:
042158 F5          0053*      push af         ; save sign of result
042159 CD 69 21 04 0054*      call udiv168
04215D F1          0055*      pop af          ; get back sign of result
04215E F0          0056*      ret p           ; result is positive so nothing to do
04215F CD E2 21 04 0057*      call neg_hlu    ; result is negative so negate it
042163 C9          0058*      ret
042164             0059*  @is_zero:           ; result is zero
042164 AF          0060*      xor a           ; sets zero flag, which we want,
042165             0061*                      ; sets pv flag which we might not (zero is parity even)
042165             0062*                      ; resets all others which is okay
042165 C9          0063*      ret
042166             0064*  @div_by_zero:       ; result is undefined, which isn't defined in binary
042166             0065*                      ; so we'll just return zero until i can think of something better
042166 F1          0066*      pop af          ; dummy pop
042167 AF          0067*      xor a           ; sets zero flag, which is ok,
042168             0068*                      ; sets pv flag which could be interpreted as overflow, which is good
042168             0069*                      ; resets all others which is okay
042168 C9          0070*      ret
042169             0071*  
042169             0072*  ; ; perform unsigned division of 16.8 fixed place values
042169             0073*  ; ; with an unsigned 16.8 fixed place result
042169             0074*  ; ; inputs: ub.c is dividend,ud.e is divisor
042169             0075*  ; ; outputs: uh.l is quotient
042169             0076*  ; ; destroys: a,bc
042169             0077*  ; udiv168:
042169             0078*  ; ; get the 16-bit integer part of the quotient
042169             0079*  ;     ; call div_24
042169             0080*  ;     call udiv24
042169             0081*  ;     ; call dumpRegistersHex
042169             0082*  ; ; load quotient to upper three bytes of output
042169             0083*  ;     ld (div168_out+1),bc
042169             0084*  ; ; TODO: THIS MAY BE BUGGED
042169             0085*  ; ; check remainder for zero, and if it is
042169             0086*  ; ; we can skip calculating the fractional part
042169             0087*  ;     add hl,de
042169             0088*  ;     or a
042169             0089*  ;     sbc hl,de
042169             0090*  ;     jr nz,@div256
042169             0091*  ;     xor a
042169             0092*  ;     jr @write_frac
042169             0093*  ; ; END TODO
042169             0094*  ; @div256:
042169             0095*  ; ; divide divisor by 256
042169             0096*  ;     push hl ; save remainder
042169             0097*  ; ; TODO: it feels like this could be more efficient
042169             0098*  ;     ld (ude),de
042169             0099*  ;     ld a,d
042169             0100*  ;     ld (ude),a
042169             0101*  ;     ld a,(ude+2)
042169             0102*  ;     ld (ude+1),a
042169             0103*  ;     xor a
042169             0104*  ;     ld (ude+2),a
042169             0105*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
042169             0106*  ; ; TODO: THIS MAY BE BUGGED
042169             0107*  ; ; now we check the shifted divisor for zero, and if it is
042169             0108*  ; ; we again set the fractional part to zero
042169             0109*  ;     add hl,de
042169             0110*  ;     or a
042169             0111*  ;     sbc hl,de
042169             0112*  ;     ex de,hl ; now de is where it's supposed to be
042169             0113*  ;     pop hl ; get remainder back
042169             0114*  ; ; TODO: THIS MAY BE BUGGED
042169             0115*  ;     jr nz,@div_frac
042169             0116*  ;     xor a
042169             0117*  ;     jr @write_frac
042169             0118*  ; ; END TODO
042169             0119*  ; ; now divide the remainder by the shifted divisor
042169             0120*  ; @div_frac:
042169             0121*  ;     push hl ; my kingdom for ld bc,hl
042169             0122*  ;     pop bc  ; or even ex bc,hl
042169             0123*  ;     ; call div_24
042169             0124*  ;     call udiv24
042169             0125*  ; ; load low byte of quotient to low byte of output
042169             0126*  ;     ld a,c
042169             0127*  ; @write_frac:
042169             0128*  ;     ld (div168_out),a
042169             0129*  ; ; load hl with return value
042169             0130*  ;     ld hl,(div168_out)
042169             0131*  ; ; load a with any overflow
042169             0132*  ;     ld a,(div168_out+3)
042169             0133*  ;     ret ; uh.l is the 16.8 result
042169             0134*  ; div168_out: ds 4 ; the extra byte is for overflow
042169             0135*  
042169             0136*  ; perform unsigned division of fixed place values
042169             0137*  ; with an unsigned 16.8 fixed place result
042169             0138*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
042169             0139*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
042169             0140*  ; destroys: a,bc
042169             0141*  udiv168:
042169             0142*  ; shift dividend left 8 bits
042169 ED 43 38 1A 0143*      ld (ubc+1),bc
       04          
04216E AF          0144*      xor a
04216F 32 37 1A 04 0145*      ld (ubc),a
042173 ED 4B 37 1A 0146*      ld bc,(ubc)
       04          
042178 CD FF 21 04 0147*      call udiv24
04217C             0148*  ; flip-flop outptuts to satisfy downstream consumers
04217C             0149*  ; TODO: this is a hack and should be fixed
04217C             0150*  ; (so says copilot ... but it's not wrong)
04217C E5          0151*      push hl
04217D C5          0152*      push bc
04217E E1          0153*      pop hl
04217F C1          0154*      pop bc
042180 C9          0155*      ret
042181             0156*  
042181             0157*  ; this is an adaptation of Div16 extended to 24 bits
042181             0158*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
042181             0159*  ; it works by shifting each byte of the dividend left into carry 8 times
042181             0160*  ; and adding the dividend into hl if the carry is set
042181             0161*  ; thus hl accumulates a remainder depending on the result of each iteration
042181             0162*  ; ---------------------------------------------------------
042181             0163*  ; Divide 24-bit unsigned values
042181             0164*  ;   with 24-bit unsigned result
042181             0165*  ;   and 24-bit remainder
042181             0166*  ; In: Divide ubc by ude
042181             0167*  ; Out: ubc = result, uhl = remainder
042181             0168*  ; Destroys: a,hl,bc
042181             0169*  div_24:
042181 21 00 00 00 0170*      ld hl,0     ; Clear accumulator for remainder
042185             0171*  ; put dividend in scratch so we can get at all its bytes
042185 ED 43 37 1A 0172*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
04218A 3A 39 1A 04 0173*      ld a,(ubc+2); grab the upper byte of the dividend
04218E 06 08       0174*      ld b,8      ; loop counter for 8 bits in a byte
042190             0175*  @loop0:
042190 17          0176*      rla         ; shift the next bit of dividend into the carry flag
042191 ED 6A       0177*      adc hl,hl   ; shift the remainder left one bit and add carry if any
042193 ED 52       0178*      sbc hl,de   ; subtract divisor from remainder
042195 30 01       0179*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
042197             0180*                  ; meaning remainder is divisible by divisor
042197 19          0181*      add hl,de   ; otherwise add divisor back to remainder
042198             0182*                  ; reversing the previous subtraction
042198             0183*  @noadd0:
042198 10 F6       0184*      djnz @loop0 ; repeat for all 8 bits
04219A 17          0185*      rla         ; now we shift a left one more time
04219B 2F          0186*      cpl         ; then flip its bits for some reason
04219C 32 39 1A 04 0187*      ld (ubc+2),a; magically this is the upper byte of the quotient
0421A0 3A 38 1A 04 0188*      ld a,(ubc+1); now we pick up the middle byte of the dividend
0421A4 06 08       0189*      ld b,8      ; set up the next loop and do it all again ...
0421A6             0190*  @loop1:
0421A6 17          0191*      rla
0421A7 ED 6A       0192*      adc hl,hl
0421A9 ED 52       0193*      sbc hl,de
0421AB 30 01       0194*      jr nc,@noadd1
0421AD 19          0195*      add hl,de
0421AE             0196*  @noadd1:
0421AE 10 F6       0197*      djnz @loop1
0421B0 17          0198*      rla
0421B1 2F          0199*      cpl
0421B2 32 38 1A 04 0200*      ld (ubc+1),a ; writing the middle byte of quotient
0421B6 3A 37 1A 04 0201*      ld a,(ubc)
0421BA 06 08       0202*      ld b,8
0421BC             0203*  @loop2:          ; compute low byte of quotient
0421BC 17          0204*      rla
0421BD ED 6A       0205*      adc hl,hl
0421BF ED 52       0206*      sbc hl,de
0421C1 30 01       0207*      jr nc,@noadd2
0421C3 19          0208*      add hl,de
0421C4             0209*  @noadd2:
0421C4 10 F6       0210*      djnz @loop2
0421C6 17          0211*      rla
0421C7 2F          0212*      cpl
0421C8 32 37 1A 04 0213*      ld (ubc),a  ; ... write low byte of quotient
0421CC ED 4B 37 1A 0214*      ld bc,(ubc) ; load quotient into bc for return
       04          
0421D1 C9          0215*      ret         ; hl already contains remainder so we're done
0421D2             0216*  
0421D2             0217*  ; ---------------------------------------------------------
0421D2             0218*  ; BEGIN HELPER ROUTINES
0421D2             0219*  ; ---------------------------------------------------------
0421D2             0220*  ;
0421D2             0221*  ; absolute value of hlu
0421D2             0222*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0421D2             0223*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0421D2             0224*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0421D2             0225*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0421D2             0226*  ; destroys: a
0421D2             0227*  abs_hlu:
0421D2 19          0228*      add hl,de
0421D3 B7          0229*      or a
0421D4 ED 52       0230*      sbc hl,de
0421D6 FA DB 21 04 0231*      jp m,@is_neg
0421DA C9          0232*      ret         ; hlu is positive or zero so we're done
0421DB             0233*  @is_neg:
0421DB F5          0234*      push af     ; otherwise, save current flags for return
0421DC CD E2 21 04 0235*      call neg_hlu ; negate hlu
0421E0 F1          0236*      pop af      ; get back flags
0421E1 C9          0237*      ret
0421E2             0238*  
0421E2             0239*  ; flip the sign of hlu
0421E2             0240*  ; inputs: hlu
0421E2             0241*  ; returns: 0-hlu, flags set appropriately for the result:
0421E2             0242*  ;         s1,z0,pv0,n1,c1 if result is negative
0421E2             0243*  ;         s0,z1,pv0,n1,c0 if result is zero
0421E2             0244*  ;         s0,z0,pv0,n1,c1 if result is positive
0421E2             0245*  ; destroys a
0421E2             0246*  neg_hlu:
0421E2 D5          0247*      push de     ; save de
0421E3 EB          0248*      ex de,hl    ; put hl into de
0421E4 21 00 00 00 0249*      ld hl,0     ; clear hl
0421E8 AF          0250*      xor a       ; clear carry
0421E9 ED 52       0251*      sbc hl,de   ; 0-hlu = -hlu
0421EB D1          0252*      pop de      ; get de back
0421EC C9          0253*      ret         ; easy peasy
0421ED             0254*  
0421ED             0255*  ; -----------------------------------------------------------------------
0421ED             0256*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
0421ED             0257*  ;------------------------------------------------------------------------
0421ED             0258*  ;  arith24.asm
0421ED             0259*  ;  24-bit ez80 arithmetic routines
0421ED             0260*  ;  Copyright (c) Shawn Sijnstra 2024
0421ED             0261*  ;  MIT license
0421ED             0262*  ;
0421ED             0263*  ;  This library was created as a tool to help make ez80
0421ED             0264*  ;  24-bit native assembly routines for simple mathematical problems
0421ED             0265*  ;  more widely available.
0421ED             0266*  ;
0421ED             0267*  ;------------------------------------------------------------------------
0421ED             0268*  
0421ED             0269*  ;------------------------------------------------------------------------
0421ED             0270*  ; umul24:	HLU = BCU*DEU (unsigned)
0421ED             0271*  ; Preserves AF, BCU, DEU
0421ED             0272*  ; Uses a fast multiply routine.
0421ED             0273*  ;------------------------------------------------------------------------
0421ED             0274*  ; modified to take BCU as multiplier instead of HLU
0421ED             0275*  umul24:
0421ED             0276*  	; push	DE
0421ED             0277*  	; push	BC
0421ED             0278*  	; push	AF
0421ED             0279*  	; push	HL
0421ED             0280*  	; pop		BC
0421ED 3E 18       0281*      ld	 	a,24 ; No. of bits to process
0421EF 21 00 00 00 0282*      ld	 	hl,0 ; Result
0421F3             0283*  umul24_lp:
0421F3 29          0284*  	add	hl,hl
0421F4 EB          0285*  	ex	de,hl
0421F5 29          0286*  	add	hl,hl
0421F6 EB          0287*  	ex	de,hl
0421F7 30 01       0288*  	jr	nc,umul24_nc
0421F9 09          0289*  	add	hl,bc
0421FA             0290*  umul24_nc:
0421FA 3D          0291*  	dec	a
0421FB 20 F6       0292*  	jr	nz,umul24_lp
0421FD 0B          0293*      dec bc ; debug
0421FE             0294*  	; pop	af
0421FE             0295*  	; pop	bc
0421FE             0296*  	; pop	de
0421FE C9          0297*  	ret
0421FF             0298*  
0421FF             0299*  
0421FF             0300*  ;------------------------------------------------------------------------
0421FF             0301*  ; udiv24
0421FF             0302*  ; Unsigned 24-bit division
0421FF             0303*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
0421FF             0304*  ;
0421FF             0305*  ; Uses AF BC DE HL
0421FF             0306*  ; Uses Restoring Division algorithm
0421FF             0307*  ;------------------------------------------------------------------------
0421FF             0308*  ; modified to take BCU as dividend instead of HLU
0421FF             0309*  ; and give BCU as quotient instead of DEU
0421FF             0310*  ; -----------------------------------------------------------------------
0421FF             0311*  udiv24:
0421FF             0312*  	; push	hl
0421FF             0313*  	; pop		bc	;move dividend to BCU
0421FF 21 00 00 00 0314*  	ld		hl,0	;result
042203 A7          0315*  	and		a
042204 ED 52       0316*  	sbc		hl,de	;test for div by 0
042206 C8          0317*  	ret		z		;it's zero, carry flag is clear
042207 19          0318*  	add		hl,de	;HL is 0 again
042208 3E 18       0319*  	ld		a,24	;number of loops through.
04220A             0320*  udiv1:
04220A C5          0321*  	push	bc	;complicated way of doing this because of lack of access to top bits
04220B E3          0322*  	ex		(sp),hl
04220C 37          0323*  	scf
04220D ED 6A       0324*  	adc	hl,hl
04220F E3          0325*  	ex	(sp),hl
042210 C1          0326*  	pop	bc		;we now have bc = (bc * 2) + 1
042211             0327*  
042211 ED 6A       0328*  	adc	hl,hl
042213 A7          0329*  	and	a		;is this the bug
042214 ED 52       0330*  	sbc	hl,de
042216 30 02       0331*  	jr	nc,udiv2
042218 19          0332*  	add	hl,de
042219             0333*  ;	dec	c
042219 0B          0334*  	dec	bc
04221A             0335*  udiv2:
04221A 3D          0336*  	dec	a
04221B 20 ED       0337*  	jr	nz,udiv1
04221D 37          0338*  	scf		;flag used for div0 error
04221E             0339*  	; push	bc
04221E             0340*  	; pop		de	;remainder
04221E C9          0341*  	ret
04221F             0342*  
04221F             0343*  
04221F             0344*  
04221F             0345*  ;------------------------------------------------------------------------
04221F             0346*  ; neg24
04221F             0347*  ; Returns: HLU = 0-HLU
04221F             0348*  ; preserves all other registers
04221F             0349*  ;------------------------------------------------------------------------
04221F             0350*  neg24:
04221F D5          0351*  	push	de
042220 EB          0352*  	ex		de,hl
042221 21 00 00 00 0353*  	ld		hl,0
042225 B7          0354*  	or		a
042226 ED 52       0355*  	sbc		hl,de
042228 D1          0356*  	pop		de
042229 C9          0357*  	ret
04222A             0358*  
04222A             0359*  ;------------------------------------------------------------------------
04222A             0360*  ; or_hlu_deu: 24 bit bitwise OR
04222A             0361*  ; Returns: hlu = hlu OR deu
04222A             0362*  ; preserves all other registers
04222A             0363*  ;------------------------------------------------------------------------
04222A             0364*  or_hlu_deu:
04222A 22 E6 22 04 0365*  	ld	(bitbuf1),hl
04222E ED 53 E9 22 0366*  	ld	(bitbuf2),de
       04          
042233 D5          0367*  	push	de	;preserve DEU
042234 C5          0368*  	push	bc	;preserve BCU
042235 06 03       0369*  	ld		b,3
042237 21 E6 22 04 0370*  	ld	hl,bitbuf1
04223B 11 E6 22 04 0371*  	ld	de,bitbuf1
04223F             0372*  orloop_24:
04223F 1A          0373*  	ld	a,(de)
042240 B6          0374*  	or	(hl)
042241 12          0375*  	ld	(de),a
042242 13          0376*  	inc	de
042243 23          0377*  	inc	hl
042244 10 F9       0378*  	djnz	orloop_24
042246 2A E9 22 04 0379*  	ld	hl,(bitbuf2)
04224A C1          0380*  	pop		bc	;restore BC
04224B D1          0381*  	pop		de	;restore DE
04224C             0382*  
04224C             0383*  ;------------------------------------------------------------------------
04224C             0384*  ; and_hlu_deu: 24 bit bitwise AND
04224C             0385*  ; Returns: hlu = hlu AND deu
04224C             0386*  ; preserves all other registers
04224C             0387*  ;------------------------------------------------------------------------
04224C             0388*  and_hlu_deu:
04224C 22 E6 22 04 0389*  	ld	(bitbuf1),hl
042250 ED 53 E9 22 0390*  	ld	(bitbuf2),de
       04          
042255 D5          0391*  	push	de	;preserve DEU
042256 C5          0392*  	push	bc	;preserve BCU
042257 06 03       0393*  	ld		b,3
042259 21 E6 22 04 0394*  	ld	hl,bitbuf1
04225D 11 E6 22 04 0395*  	ld	de,bitbuf1
042261             0396*  andloop_24:
042261 1A          0397*  	ld	a,(de)
042262 A6          0398*  	and	(hl)
042263 12          0399*  	ld	(de),a
042264 13          0400*  	inc	de
042265 23          0401*  	inc	hl
042266 10 F9       0402*  	djnz	andloop_24
042268 2A E9 22 04 0403*  	ld	hl,(bitbuf2)
04226C C1          0404*  	pop		bc	;restore BC
04226D D1          0405*  	pop		de	;restore DE
04226E             0406*  
04226E             0407*  ;------------------------------------------------------------------------
04226E             0408*  ; xor_hlu_deu: 24 bit bitwise XOR
04226E             0409*  ; Returns: hlu = hlu XOR deu
04226E             0410*  ; preserves all other registers
04226E             0411*  ;------------------------------------------------------------------------
04226E             0412*  xor_hlu_deu:
04226E 22 E6 22 04 0413*  	ld	(bitbuf1),hl
042272 ED 53 E9 22 0414*  	ld	(bitbuf2),de
       04          
042277 D5          0415*  	push	de	;preserve DEU
042278 C5          0416*  	push	bc	;preserve BCU
042279 06 03       0417*  	ld		b,3
04227B 21 E6 22 04 0418*  	ld	hl,bitbuf1
04227F 11 E6 22 04 0419*  	ld	de,bitbuf1
042283             0420*  xorloop_24:
042283 1A          0421*  	ld	a,(de)
042284 AE          0422*  	xor	(hl)
042285 12          0423*  	ld	(de),a
042286 13          0424*  	inc	de
042287 23          0425*  	inc	hl
042288 10 F9       0426*  	djnz	xorloop_24
04228A 2A E9 22 04 0427*  	ld	hl,(bitbuf2)
04228E C1          0428*  	pop		bc	;restore BC
04228F D1          0429*  	pop		de	;restore DE
042290             0430*  
042290             0431*  ;------------------------------------------------------------------------
042290             0432*  ; shl_hlu: 24 bit shift left hlu by deu positions
042290             0433*  ; Returns: hlu = hlu << deu
042290             0434*  ;		   de = 0
042290             0435*  ; NOTE: only considers deu up to 16 bits.
042290             0436*  ; preserves all other registers
042290             0437*  ;------------------------------------------------------------------------
042290             0438*  shl_hlu:
042290 7A          0439*  	ld		a,d		;up to 16 bit.
042291 B3          0440*  	or		e
042292 C8          0441*  	ret		z		;we're done
042293 29          0442*  	add		hl,hl	;shift HLU left
042294 1B          0443*  	dec		de
042295 18 F9       0444*  	jr		shl_hlu
042297             0445*  
042297             0446*  ;------------------------------------------------------------------------
042297             0447*  ; shr_hlu: 24 bit shift right hlu by deu positions
042297             0448*  ; Returns: hlu = hlu >> deu
042297             0449*  ;		   de = 0
042297             0450*  ; NOTE: only considers deu up to 16 bits.
042297             0451*  ; preserves all other registers
042297             0452*  ;------------------------------------------------------------------------
042297             0453*  shr_hlu:
042297 22 E6 22 04 0454*  	ld		(bitbuf1),hl
04229B 21 E8 22 04 0455*  	ld		hl,bitbuf1+2
04229F             0456*  shr_loop:
04229F 7A          0457*  	ld		a,d		;up to 16 bit.
0422A0 B3          0458*  	or		e
0422A1 28 0D       0459*  	jr		z,shr_done		;we're done
0422A3             0460*  ;carry is clear from or instruction
0422A3 CB 1E       0461*  	rr		(hl)
0422A5 2B          0462*  	dec		hl
0422A6 CB 1E       0463*  	rr		(hl)
0422A8 2B          0464*  	dec		hl
0422A9 CB 1E       0465*  	rr		(hl)
0422AB 23          0466*  	inc		hl
0422AC 23          0467*  	inc		hl
0422AD 1B          0468*  	dec		de
0422AE 18 EF       0469*  	jr		shr_loop
0422B0             0470*  shr_done:
0422B0 2A E6 22 04 0471*  	ld		hl,(bitbuf1)	;collect result
0422B4 C9          0472*  	ret
0422B5             0473*  
0422B5             0474*  ;------------------------------------------------------------------------
0422B5             0475*  ; divide hlu by 2, inspired by above
0422B5             0476*  ;------------------------------------------------------------------------
0422B5             0477*  hlu_div2:
0422B5 22 E6 22 04 0478*  	ld		(bitbuf1),hl
0422B9 21 E8 22 04 0479*  	ld		hl,bitbuf1+2
0422BD CB 1E       0480*  	rr		(hl)
0422BF 2B          0481*  	dec		hl
0422C0 CB 1E       0482*  	rr		(hl)
0422C2 2B          0483*  	dec		hl
0422C3 CB 1E       0484*  	rr		(hl)
0422C5 23          0485*  	inc		hl
0422C6 23          0486*  	inc		hl
0422C7 2A E6 22 04 0487*      ld hl,(bitbuf1)
0422CB C9          0488*      ret
0422CC             0489*  
0422CC             0490*  ; this is my little hack to divide by 16
0422CC             0491*  hlu_div16:
0422CC AF          0492*      xor a
0422CD 29          0493*      add hl,hl
0422CE 17          0494*      rla
0422CF 29          0495*      add hl,hl
0422D0 17          0496*      rla
0422D1 29          0497*      add hl,hl
0422D2 17          0498*      rla
0422D3 29          0499*      add hl,hl
0422D4 17          0500*      rla
0422D5 22 E2 22 04 0501*      ld (@scratch),hl
0422D9 32 E5 22 04 0502*      ld (@scratch+3),a
0422DD 2A E3 22 04 0503*      ld hl,(@scratch+1)
0422E1 C9          0504*      ret
0422E2             0505*  @scratch: ds 4
0422E6             0506*  
0422E6             0507*  ;------------------------------------------------------------------------
0422E6             0508*  ; Scratch area for calculations
0422E6             0509*  ;------------------------------------------------------------------------
0422E6 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0422E9 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0422EC             0512*  
0422EC             0513*  
0422EC             0514*  ; -----------------------------------------------------------------------
0422EC             0515*  ; EEMES TUTORIALS
0422EC             0516*  ; -----------------------------------------------------------------------
0422EC             0517*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
0422EC             0518*  ; DEHL=BC*DE
0422EC             0519*  Mul16:
0422EC 21 00 00 00 0520*      ld hl,0
0422F0 3E 10       0521*      ld a,16
0422F2             0522*  Mul16Loop:
0422F2 29          0523*      add hl,hl
0422F3 CB 13       0524*      rl e
0422F5 CB 12       0525*      rl d
0422F7 D2 01 23 04 0526*      jp nc,NoMul16
0422FB 09          0527*      add hl,bc
0422FC D2 01 23 04 0528*      jp nc,NoMul16
042300 13          0529*      inc de
042301             0530*  NoMul16:
042301 3D          0531*      dec a
042302 C2 F2 22 04 0532*      jp nz,Mul16Loop
042306 C9          0533*      ret
042307             0534*  
042307             0535*  ; DEUHLU=BCU*DEU
042307             0536*  umul2448:
042307 21 00 00 00 0537*      ld hl,0
04230B 3E 18       0538*      ld a,24
04230D             0539*  umul2448Loop:
04230D 29          0540*      add hl,hl
04230E EB          0541*      ex de,hl
04230F ED 6A       0542*      adc hl,hl
042311 EB          0543*      ex de,hl
042312 D2 1C 23 04 0544*      jp nc,Noumul2448
042316 09          0545*      add hl,bc
042317 D2 1C 23 04 0546*      jp nc,Noumul2448
04231B 13          0547*      inc de
04231C             0548*  Noumul2448:
04231C 3D          0549*      dec a
04231D C2 0D 23 04 0550*      jp nz,umul2448Loop
042321 C9          0551*      ret
042322             0552*  
042322             0553*  umul168:
042322 CD 07 23 04 0554*      call umul2448
042326             0555*  
042326             0556*      ; call dumpUDEUHLHex
042326             0557*  
042326             0558*  ; UDEU.HL is the 32.16 fixed result
042326             0559*  ; we want UH.L to be the 16.8 fixed result
042326             0560*  ; so we divide by 256 by shiftng down a byte
042326             0561*  ; easiest way is to write deu and hlu to scratch
042326 ED 53 3B 23 0562*      ld (umul168out+3),de
       04          
04232B 22 38 23 04 0563*      ld (umul168out),hl
04232F             0564*  ; then load hlu from scratch shfited forward a byte
04232F 2A 39 23 04 0565*      ld hl,(umul168out+1)
042333 3A 3D 23 04 0566*      ld a,(umul168out+5) ; send a back with any overflow
042337 C9          0567*      ret
042338             0568*  umul168out: ds 6
04233E             0569*  
04233E             0570*  ; perform signed multiplication of 16.8 fixed place values
04233E             0571*  ; with an signed 16.8 fixed place result
04233E             0572*  ; inputs: ub.c and ud.e are the operands
04233E             0573*  ; outputs: uh.l is the product
04233E             0574*  ; destroys: a,bc
04233E             0575*  ; TODO: make flags appropriate to the sign of the result
04233E             0576*  smul168:
04233E             0577*  ; make everything positive and save signs
04233E C5          0578*      push bc         ; get bc to hl
04233F E1          0579*      pop hl          ; for the next call
042340 CD D2 21 04 0580*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
042344             0581*  
042344             0582*      ; call dumpFlags ; passes
042344             0583*  
042344 CA 77 23 04 0584*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
042348 F5          0585*      push af         ; save sign of bc
042349 E5          0586*      push hl         ; now put abs(hl)
04234A C1          0587*      pop bc          ; back into bc = abs(bc)
04234B EB          0588*      ex de,hl        ; now we do de same way
04234C CD D2 21 04 0589*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
042350             0590*  
042350             0591*      ; call dumpFlags ; passes
042350             0592*  
042350 CA 77 23 04 0593*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
042354 EB          0594*      ex de,hl        ; hl back to de = abs(de)
042355             0595*  ; determine sign of result
042355 F2 60 23 04 0596*      jp p,@de_pos    ; sign positive,de is positive
042359             0597*  
042359             0598*      ; call dumpFlags ; correctly doesnt make it here
042359             0599*  
042359 F1          0600*      pop af          ; get back sign of bc
04235A             0601*  
04235A             0602*      ; call dumpFlags ; correctly doesn't make it here
04235A             0603*  
04235A FA 69 23 04 0604*      jp m,@result_pos  ; bc and de negative, result is positive
04235E             0605*  
04235E             0606*      ; call dumpFlags  ; corectly doesn't make it here
04235E             0607*  
04235E 18 05       0608*      jr @result_neg
042360             0609*  @de_pos:
042360 F1          0610*      pop af          ; get back sign of bc
042361             0611*  
042361             0612*      ; call dumpFlags  ; passes
042361             0613*  
042361 F2 69 23 04 0614*      jp p,@result_pos   ; bc and de are both positive so result is positive
042365             0615*  
042365             0616*      ; call dumpFlags ; correctly makes it here
042365             0617*  
042365             0618*                      ; fall through to result_neg
042365             0619*  @result_neg:
042365 AF          0620*      xor a           ; zero a and clear carry
042366 3D          0621*      dec a           ; set sign flag to negative
042367             0622*  
042367             0623*      ; call dumpFlags ; passes
042367             0624*  
042367 18 02       0625*      jr @do_mul
042369             0626*  @result_pos:
042369 AF          0627*      xor a           ; zero a and clear carry
04236A 3C          0628*      inc a           ; set sign flag to positive
04236B             0629*                      ; fall through to do_mul
04236B             0630*  
04236B             0631*      ; call dumpFlags ; correctly doesn't make it here
04236B             0632*  
04236B             0633*  @do_mul:
04236B F5          0634*      push af         ; save sign of result
04236C CD 22 23 04 0635*      call umul168
042370 F1          0636*      pop af          ; get back sign of result
042371             0637*  
042371             0638*      ; call dumpFlags ; passes
042371             0639*  
042371 F0          0640*      ret p           ; result is positive so nothing to do
042372             0641*  
042372             0642*      ; call dumpRegistersHex ; passes
042372             0643*  
042372 CD E2 21 04 0644*      call neg_hlu    ; result is negative so negate it
042376             0645*  
042376             0646*      ; call dumpRegistersHex ; passes
042376 C9          0647*      ret
042377             0648*  @is_zero:           ; result is zero
042377 AF          0649*      xor a           ; sets zero flag, which we want,
042378             0650*                      ; sets pv flag which we might not (zero is parity even)
042378             0651*                      ; resets all others which is okay
042378 C9          0652*      ret
042379             0058   	include "maths24.inc"
042379             0001*  ; http://www.z80.info/pseudo-random.txt
042379             0002*  rand_8:
042379 C5          0003*      push bc
04237A 3A 8D 23 04 0004*      ld a,(r_seed)
04237E 4F          0005*      ld c,a
04237F             0006*  
04237F 0F          0007*      rrca ; multiply by 32
042380 0F          0008*      rrca
042381 0F          0009*      rrca
042382 EE 1F       0010*      xor 0x1f
042384             0011*  
042384 81          0012*      add a,c
042385 DE FF       0013*      sbc a,255 ; carry
042387             0014*  
042387 32 8D 23 04 0015*      ld (r_seed),a
04238B C1          0016*      pop bc
04238C C9          0017*      ret
04238D 50          0018*  r_seed: defb $50
04238E             0019*  
04238E             0020*  ; tests the sign of 24-bit register hlu
04238E             0021*  ; returns: a in [-1,0,1]
04238E             0022*  ;   sign and zero flags as expected
04238E             0023*  ;   hl is untouched
04238E             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
04238E             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
04238E             0026*  get_sign_hlu:
04238E             0027*      ; Load the upper byte of HLU into A
04238E E5          0028*      push hl
04238F DD 21 00 00 0029*      ld ix,0
       00          
042394 DD 39       0030*      add ix,sp
042396 DD 7E 02    0031*      ld a,(ix+2)
042399 E1          0032*      pop hl
04239A             0033*  
04239A B5          0034*      or l                ; OR with the low byte to check if HL is zero
04239B C8          0035*      ret z               ; Return if HL is zero
04239C             0036*  
04239C 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
04239E CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0423A0 C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
0423A1             0040*  
0423A1 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
0423A3 A7          0042*      and a               ; Reset the zero flag
0423A4 C9          0043*      ret                 ; Return with A set to 1
0423A5             0044*  
0423A5             0045*  ; 16.8 fixed inputs / outputs
0423A5             0046*  ; takes: uh.l as angle in degrees 256
0423A5             0047*  ;        ud.e as radius
0423A5             0048*  ; returns ub.c as dx, ud.e as dy
0423A5             0049*  ;        displacements from origin (0,0)
0423A5             0050*  ; destroys: everything except indexes
0423A5             0051*  polar_to_cartesian:
0423A5             0052*  ; back up input parameters
0423A5 22 34 1A 04 0053*      ld (uhl),hl
0423A9 ED 53 3A 1A 0054*      ld (ude),de
       04          
0423AE             0055*  ; compute dx = sin(uh.l) * ud.e
0423AE CD DD 23 04 0056*      call sin168
0423B2 E5          0057*      push hl
0423B3 C1          0058*      pop bc ; ub.c = sin(uh.l)
0423B4 ED 5B 3A 1A 0059*  	ld de,(ude) ; get radius back
       04          
0423B9 CD 3E 23 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
0423BD E5          0061*      push hl ; store dx for output
0423BE             0062*  ; compute dy = -cos(uh.l) * ud.e
0423BE 2A 34 1A 04 0063*      ld hl,(uhl)
0423C2 CD D8 23 04 0064*      call cos168
0423C6 CD E2 21 04 0065*  	call neg_hlu ; invert dy for screen coords convention
0423CA E5          0066*      push hl
0423CB C1          0067*      pop bc ; ub.c = -cos(uh.l)
0423CC ED 5B 3A 1A 0068*      ld de,(ude) ; get radius back
       04          
0423D1 CD 3E 23 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
0423D5 EB          0070*      ex de,hl    ; de = dy for output
0423D6 C1          0071*      pop bc      ; bc = dx for output
0423D7             0072*  ; and out
0423D7 C9          0073*      ret
0423D8             0074*  
0423D8             0075*  ; fixed 16.8 routine
0423D8             0076*  ; cos(uh.l) --> uh.l
0423D8             0077*  ; destroys: de
0423D8             0078*  cos168:
0423D8             0079*  ; for cos we simply increment the angle by 90 degrees
0423D8             0080*  ; or 0x004000 in 16.8 degrees256
0423D8             0081*  ; which makes it a sin problem
0423D8 11 00 40 00 0082*      ld de,0x004000
0423DC 19          0083*      add hl,de ; modulo 256 happens below
0423DD             0084*  ; fall through to sin168
0423DD             0085*  ; ---------------------
0423DD             0086*  ; fixed 16.8 routine
0423DD             0087*  ; sin(uh.l) --> uh.l
0423DD             0088*  ; destroys: de
0423DD             0089*  sin168:
0423DD             0090*  ; h contains the integer portion of our angle
0423DD             0091*  ; we multiply it by three to get our lookup table index
0423DD 2E 03       0092*      ld l,3
0423DF ED 6C       0093*      mlt hl ; gosh that is handy
0423E1 11 00 00 00 0094*      ld de,0 ; clear deu
0423E5 54          0095*      ld d,h ; copy hl to de
0423E6 5D          0096*      ld e,l ; de contains our index
0423E7 21 EE 25 04 0097*      ld hl,sin_lut_168 ; grab the lut address
0423EB 19          0098*      add hl,de ; bump hl by the index
0423EC ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
0423EE C9          0100*      ret ; and out
0423EF             0101*  
0423EF             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0423EF             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0423EF             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0423EF             0105*  ;         also populates scratch locations dx168 and dy168
0423EF             0106*  ; destroys: a,hl,bc,de
0423EF             0107*  dxy168:
0423EF             0108*  ; compute dx = x1-x0
0423EF AF          0109*      xor a ; clear carry
0423F0 DD E5       0110*      push ix ; move ix to hl via the stack
0423F2 E1          0111*      pop hl ; hl = x1
0423F3 ED 42       0112*      sbc hl,bc ; hl = dx
0423F5 22 4A 24 04 0113*      ld (dx168),hl ; dx to scratch
0423F9             0114*  ; compute dy = y1-y0
0423F9 AF          0115*      xor a ; clear carry
0423FA FD E5       0116*      push iy ; move iy to hl via the stack
0423FC E1          0117*      pop hl ; hl = y1
0423FD ED 52       0118*      sbc hl,de ; hl = dy
0423FF 22 50 24 04 0119*      ld (dy168),hl ; dy to scratch
042403             0120*  ; populate output registers and return
042403 EB          0121*      ex de,hl        ; ud.e = dy
042404 ED 4B 4A 24 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
042409 C9          0123*      ret
04240A             0124*  
04240A             0125*  ; compute the euclidian distance between two cartesian coordinates
04240A             0126*  ; using the formula d = sqrt(dx^2+dy^2
04240A             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04240A             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04240A             0129*  ; output; uh.l is the 16.8 fixed format distance
04240A             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
04240A             0131*  ; destroys: a,hl,bc,de
04240A             0132*  distance168:
04240A             0133*  ; compute dx = x1-x0
04240A AF          0134*      xor a ; clear carry
04240B DD E5       0135*      push ix ; move ix to hl via the stack
04240D E1          0136*      pop hl ; hl = x1
04240E ED 42       0137*      sbc hl,bc ; hl = dx
042410 22 4A 24 04 0138*      ld (dx168),hl ; dx to scratch
042414             0139*  ; ; test dx for overflow
042414             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
042414             0141*  ; 	ex de,hl
042414             0142*  ; 	sbc hl,de ; test for overflow
042414             0143*  ; 	push af ; carry indicates overflow
042414             0144*  ; compute dy = y1-y0
042414 AF          0145*      xor a ; clear carry
042415 FD E5       0146*      push iy ; move iy to hl via the stack
042417 E1          0147*      pop hl ; hl = y1
042418 ED 52       0148*      sbc hl,de ; hl = dy
04241A 22 50 24 04 0149*      ld (dy168),hl ; dy to scratch
04241E             0150*  ; ; test dy for overflow
04241E             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
04241E             0152*  ; 	ex de,hl
04241E             0153*  ; 	sbc hl,de ; test for overflow
04241E             0154*  ; 	push af ; carry indicates overflow
04241E             0155*  ; compute dy^2
04241E 2A 50 24 04 0156*  	ld hl,(dy168)
042422 CD D2 21 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
042426             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
042426 E5          0159*      push hl ; load hl/2 to bc via the stack
042427 C1          0160*      pop bc ; bc = dy/2
042428 EB          0161*      ex de,hl ; de = dy/2
042429 CD 22 23 04 0162*      call umul168 ; uh.l = dy^2/2
04242D E5          0163*      push hl ; dy^2/2 to the stack
04242E             0164*  ; compute dx^2
04242E 2A 4A 24 04 0165*      ld hl,(dx168) ; get back dx
042432 CD D2 21 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
042436             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
042436 E5          0168*      push hl ; load hl/2 to bc via the stack
042437 C1          0169*      pop bc ; bc = dx/2
042438 EB          0170*      ex de,hl ; de = dx/2
042439 CD 22 23 04 0171*      call umul168 ; uh.l = dx^2/2
04243D             0172*  ; commpute dy^2+dx^2
04243D D1          0173*      pop de ; get back dx^2/2
04243E 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
04243F             0175*  ; compute sqrt(dx^2/2+dy^2/2)
04243F CD 03 25 04 0176*      call sqrt168 ; uh.l = distance/2
042443             0177*      ; add hl,hl ; hl = distance
042443             0178*  ; ; check for overflow
042443             0179*  ; 	pop af ; get back the overflow flags
042443             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042443             0181*  ; 	ld b,a ; save the overflow flag
042443             0182*  ; 	pop af ; get back the overflow flags
042443             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042443             0184*  ; 	add a,b ; if a != 0 then we had overflow
042443             0185*  ;     ret z ; no overflow we're done
042443             0186*  ; @overflow:
042443             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
042443 C9          0188*  	ret
042444             0189*  @scratch: ds 6
04244A             0190*  dx168: ds 6
042450             0191*  dy168: ds 6
042456             0192*  
042456             0193*  ; atan2(ub.c,ud.e) --> uh.l
042456             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042456             0195*  ;   whether inputs are integers or fractional doesn't matter
042456             0196*  ;   so long as the sign bit of the upper byte is correct
042456             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
042456             0198*  ; angles are COMPASS HEADINGS based on
042456             0199*  ; screen coordinate conventions,where the y axis is flipped
042456             0200*  ; #E0 315      0       45 #20
042456             0201*  ;        -x,-y | +x,-y
042456             0202*  ; #C0 270------+------ 90 #40
042456             0203*  ;        -x,+y | +x,+y
042456             0204*  ; #A0 225   180 #80   135 #60
042456             0205*  atan2_168game:
042456             0206*  ; get signs and make everything positive
042456             0207*  ; get abs(x) and store its original sign
042456 C5          0208*      push bc
042457 E1          0209*      pop hl
042458 CD D2 21 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
04245C E5          0211*      push hl ; store abs(x)
04245D C1          0212*      pop bc ; bc = abs(x)
04245E F5          0213*      push af ; store sign of x
04245F             0214*  ; get abs(y) and store its original sign
04245F EB          0215*      ex de,hl ; hl = y
042460 CD D2 21 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
042464 EB          0217*      ex de,hl ; de = abs(y)
042465 F5          0218*      push af ; store sign of y
042466             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
042466             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
042466 AF          0221*      xor a ; clear the carry flag
042467 D5          0222*      push de
042468 E1          0223*      pop hl
042469 ED 42       0224*      sbc hl,bc
04246B F5          0225*      push af ; save sign of de - bc
04246C F2 75 24 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
042470             0227*  ; otherwise we swap bc and de
042470 C5          0228*      push bc
042471 E1          0229*      pop hl
042472 EB          0230*      ex de,hl
042473 E5          0231*      push hl
042474 C1          0232*      pop bc
042475             0233*  @1:
042475             0234*  ; now we're ready to snag our preliminary result
042475 CD E3 24 04 0235*      call atan_168game ; uh.l comes back with prelim result
042479             0236*  ; now we adjust uh.l based on sign of de - bc
042479 F1          0237*      pop af
04247A F2 86 24 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
04247E EB          0239*      ex de,hl
04247F 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
042483 AF          0241*      xor a ; clear the carry flag
042484 ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
042486             0243*      ; ld de,0 ; prep to clear hlu
042486             0244*      ; ld d,h
042486             0245*      ; ld e,l
042486             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
042486             0247*      ; fall through
042486             0248*  @2:
042486             0249*  ; now the fun part of adjusting the result
042486             0250*  ; based on which quadrant (x,y) is in
042486             0251*  ; #E0 315      0       45 #20
042486             0252*  ;        -x,-y | +x,-y
042486             0253*  ; #C0 270------+------ 90 #40
042486             0254*  ;        -x,+y | +x,+y
042486             0255*  ; #A0 225   180 #80   135 #60
042486 F1          0256*      pop af ; sign of y
042487 CA C4 24 04 0257*      jp z,@y_zero
04248B F2 A4 24 04 0258*      jp p,@y_pos
04248F             0259*  ; y neg,check x
04248F F1          0260*      pop af ; sign of x
042490 CA 9E 24 04 0261*      jp z,@y_neg_x_zero
042494 F2 A3 24 04 0262*      jp p,@y_neg_x_pos
042498             0263*  ; y neg,x neg
042498             0264*  ; angle is 270-360
042498             0265*  ; negating the intermediate does the trick
042498 CD E2 21 04 0266*      call neg_hlu
04249C 18 31       0267*      jr @zero_hlu
04249E             0268*  
04249E             0269*  @y_neg_x_zero:
04249E             0270*  ; y neg,x zero
04249E             0271*  ; angle is 0
04249E 21 00 00 00 0272*      ld hl,0
0424A2 C9          0273*      ret
0424A3             0274*  @y_neg_x_pos:
0424A3             0275*  ; y neg,x pos
0424A3             0276*  ; angle is 0 to 90
0424A3             0277*  ; so we're good
0424A3 C9          0278*      ret
0424A4             0279*  
0424A4             0280*  @y_pos:
0424A4 F1          0281*      pop af ; sign of x
0424A5 CA B4 24 04 0282*      jp z,@y_pos_x_zero
0424A9 F2 B9 24 04 0283*      jp p,@y_pos_x_pos
0424AD             0284*  ; y pos,x neg
0424AD             0285*  ; angle is 180-270
0424AD             0286*  ; so we add 180 to intermediate
0424AD 11 00 80 00 0287*      ld de,0x008000
0424B1 19          0288*      add hl,de
0424B2 18 1B       0289*      jr @zero_hlu
0424B4             0290*  @y_pos_x_zero:
0424B4             0291*  ; y pos,x zero
0424B4             0292*  ; angle is 180
0424B4 21 00 80 00 0293*      ld hl,0x008000
0424B8 C9          0294*      ret
0424B9             0295*  @y_pos_x_pos:
0424B9             0296*  ; y pos,x pos
0424B9             0297*  ; angle is 90-180
0424B9             0298*  ; neg the intermediate and add 180 degrees
0424B9 CD E2 21 04 0299*      call neg_hlu
0424BD 11 00 80 00 0300*      ld de,0x008000
0424C1 19          0301*      add hl,de
0424C2 18 0B       0302*      jr @zero_hlu
0424C4             0303*  
0424C4             0304*  @y_zero:
0424C4 F1          0305*      pop af ; sign of x
0424C5 FA CA 24 04 0306*      jp m,@y_zero_x_neg
0424C9             0307*  ; y zero,x pos
0424C9             0308*  ; angle is 90,nothing to do
0424C9 C9          0309*      ret
0424CA             0310*  @y_zero_x_neg:
0424CA             0311*  ; y zero ,x neg
0424CA             0312*  ; angle is 270
0424CA 21 00 C0 00 0313*      ld hl,0x00C000
0424CE C9          0314*      ret
0424CF             0315*  @zero_hlu:
0424CF AF          0316*      xor a
0424D0 22 DD 24 04 0317*      ld (@scratch),hl
0424D4 32 DF 24 04 0318*      ld (@scratch+2),a
0424D8 2A DD 24 04 0319*      ld hl,(@scratch)
0424DC C9          0320*      ret
0424DD             0321*  @scratch: ds 6
0424E3             0322*  
0424E3             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0424E3             0324*  ; output: uh.l is the 16.8 fixed format angle
0424E3             0325*  ; destroys: a,hl,bc,de
0424E3             0326*  ; the following note was written by github copilot:
0424E3             0327*  ; note: this routine is a bit of a hack
0424E3             0328*  ;      but it works
0424E3             0329*  ;      and it's fast
0424E3             0330*  ;      and it's small
0424E3             0331*  ;      and it's accurate
0424E3             0332*  ;      and it's easy to understand
0424E3             0333*  ;      and it's easy to modify
0424E3             0334*  ;      and it's easy to use
0424E3             0335*  ;      and it's easy to remember
0424E3             0336*  ;      and it's easy to love
0424E3             0337*  ;      and it's easy to hate
0424E3             0338*  ;      and it's easy to ignore
0424E3             0339*  ;      and it's easy to forget
0424E3             0340*  ;      and it's easy to remember
0424E3             0341*  ;      and it's easy to forget
0424E3             0342*  ;      and it's easy to remember
0424E3             0343*  ;      (ok the bot is stuck in a loop)
0424E3             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0424E3             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0424E3             0346*  atan_168game:
0424E3             0347*  ; because we use compass headings instead of geometric angles
0424E3             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0424E3             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
0424E3 CD 69 21 04 0350*  	call udiv168 ; uh.l = dx/dy
0424E7             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0424E7             0352*  ; ; test uh.l for 0
0424E7             0353*  ;     add hl,de
0424E7             0354*  ;     or a
0424E7             0355*  ;     sbc hl,de
0424E7             0356*  ;     jr z,@is_zero
0424E7             0357*  ; ; test uh.l for 1
0424E7             0358*  ;     xor a ; clear carry
0424E7             0359*  ;     ex de,hl
0424E7             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0424E7             0361*  ;     sbc hl,de
0424E7             0362*  ;     jr z,@is_45
0424E7             0363*  ; ; END TODO
0424E7             0364*  
0424E7             0365*  ; no special cases so we move on
0424E7             0366*  ; l contains the fractional portion of tan(uh.l)
0424E7             0367*  ; we multiply it by three to get our lookup table index
0424E7 26 03       0368*      ld h,3
0424E9 ED 6C       0369*      mlt hl ; gosh that is handy
0424EB 11 00 00 00 0370*      ld de,0 ; clear deu
0424EF 54          0371*      ld d,h ; copy hl to de
0424F0 5D          0372*      ld e,l ; de contains our index
0424F1 21 EE 28 04 0373*      ld hl,atan_lut_168 ; grab the lut address
0424F5 19          0374*      add hl,de ; bump hl by the index
0424F6 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
0424F8 C9          0376*      ret ; and out
0424F9             0377*  @is_45:
0424F9 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
0424FD C9          0379*      ret
0424FE             0380*  ; for the case tan(0)
0424FE             0381*  @is_zero:
0424FE 21 00 00 00 0382*      ld hl,0x000000
042502 C9          0383*      ret
042503             0384*  
042503             0385*  ; Expects  ADL mode
042503             0386*  ; Inputs:  UH.L
042503             0387*  ; Outputs: UH.L is the 16.8 square root
042503             0388*  ;          UD.E is the difference inputHL-DE^2
042503             0389*  ;          c flag reset
042503             0390*  sqrt168:
042503 CD 0D 25 04 0391*      call sqrt24
042507 EB          0392*      ex de,hl
042508 29          0393*      add hl,hl
042509 29          0394*      add hl,hl
04250A 29          0395*      add hl,hl
04250B 29          0396*      add hl,hl
04250C C9          0397*      ret
04250D             0398*  
04250D             0399*  ; Expects  ADL mode
04250D             0400*  ; Inputs:  HL
04250D             0401*  ; Outputs: DE is the integer square root
04250D             0402*  ;          HL is the difference inputHL-DE^2
04250D             0403*  ;          c flag reset
04250D             0404*  sqrt24:
04250D AF          0405*      xor a
04250E 45          0406*      ld b,l
04250F C5          0407*      push bc
042510 47          0408*      ld b,a
042511 57          0409*      ld d,a
042512 4F          0410*      ld c,a
042513 6F          0411*      ld l,a
042514 5F          0412*      ld e,a
042515             0413*  
042515             0414*      ;Iteration 1
042515 29          0415*      add hl,hl
042516 CB 11       0416*      rl c
042518 29          0417*      add hl,hl
042519 CB 11       0418*      rl c
04251B 91          0419*      sub c
04251C 30 04       0420*      jr nc,$+6
04251E 1C          0421*      inc e
04251F 1C          0422*      inc e
042520 2F          0423*      cpl
042521 4F          0424*      ld c,a
042522             0425*  
042522             0426*      ;Iteration 2
042522 29          0427*      add hl,hl
042523 CB 11       0428*      rl c
042525 29          0429*      add hl,hl
042526 CB 11       0430*      rl c
042528 CB 13       0431*      rl e
04252A 7B          0432*      ld a,e
04252B 91          0433*      sub c
04252C 30 04       0434*      jr nc,$+6
04252E 1C          0435*      inc e
04252F 1C          0436*      inc e
042530 2F          0437*      cpl
042531 4F          0438*      ld c,a
042532             0439*  
042532             0440*      ;Iteration 3
042532 29          0441*      add hl,hl
042533 CB 11       0442*      rl c
042535 29          0443*      add hl,hl
042536 CB 11       0444*      rl c
042538 CB 13       0445*      rl e
04253A 7B          0446*      ld a,e
04253B 91          0447*      sub c
04253C 30 04       0448*      jr nc,$+6
04253E 1C          0449*      inc e
04253F 1C          0450*      inc e
042540 2F          0451*      cpl
042541 4F          0452*      ld c,a
042542             0453*  
042542             0454*      ;Iteration 4
042542 29          0455*      add hl,hl
042543 CB 11       0456*      rl c
042545 29          0457*      add hl,hl
042546 CB 11       0458*      rl c
042548 CB 13       0459*      rl e
04254A 7B          0460*      ld a,e
04254B 91          0461*      sub c
04254C 30 04       0462*      jr nc,$+6
04254E 1C          0463*      inc e
04254F 1C          0464*      inc e
042550 2F          0465*      cpl
042551 4F          0466*      ld c,a
042552             0467*  
042552             0468*      ;Iteration 5
042552 29          0469*      add hl,hl
042553 CB 11       0470*      rl c
042555 29          0471*      add hl,hl
042556 CB 11       0472*      rl c
042558 CB 13       0473*      rl e
04255A 7B          0474*      ld a,e
04255B 91          0475*      sub c
04255C 30 04       0476*      jr nc,$+6
04255E 1C          0477*      inc e
04255F 1C          0478*      inc e
042560 2F          0479*      cpl
042561 4F          0480*      ld c,a
042562             0481*  
042562             0482*      ;Iteration 6
042562 29          0483*      add hl,hl
042563 CB 11       0484*      rl c
042565 29          0485*      add hl,hl
042566 CB 11       0486*      rl c
042568 CB 13       0487*      rl e
04256A 7B          0488*      ld a,e
04256B 91          0489*      sub c
04256C 30 04       0490*      jr nc,$+6
04256E 1C          0491*      inc e
04256F 1C          0492*      inc e
042570 2F          0493*      cpl
042571 4F          0494*      ld c,a
042572             0495*  
042572             0496*      ;Iteration 7
042572 29          0497*      add hl,hl
042573 CB 11       0498*      rl c
042575 29          0499*      add hl,hl
042576 CB 11       0500*      rl c
042578 CB 10       0501*      rl b
04257A EB          0502*      ex de,hl
04257B 29          0503*      add hl,hl
04257C E5          0504*      push hl
04257D ED 42       0505*      sbc hl,bc
04257F 30 06       0506*      jr nc,$+8
042581 7C          0507*      ld a,h
042582 2F          0508*      cpl
042583 47          0509*      ld b,a
042584 7D          0510*      ld a,l
042585 2F          0511*      cpl
042586 4F          0512*      ld c,a
042587 E1          0513*      pop hl
042588 30 02       0514*      jr nc,$+4
04258A 23          0515*      inc hl
04258B 23          0516*      inc hl
04258C EB          0517*      ex de,hl
04258D             0518*  
04258D             0519*      ;Iteration 8
04258D 29          0520*      add hl,hl
04258E 69          0521*      ld l,c
04258F 60          0522*      ld h,b
042590 ED 6A       0523*      adc hl,hl
042592 ED 6A       0524*      adc hl,hl
042594 EB          0525*      ex de,hl
042595 29          0526*      add hl,hl
042596 ED 52       0527*      sbc hl,de
042598 19          0528*      add hl,de
042599 EB          0529*      ex de,hl
04259A 30 04       0530*      jr nc,$+6
04259C ED 52       0531*      sbc hl,de
04259E 13          0532*      inc de
04259F 13          0533*      inc de
0425A0             0534*  
0425A0             0535*      ;Iteration 9
0425A0 F1          0536*      pop af
0425A1 17          0537*      rla
0425A2 ED 6A       0538*      adc hl,hl
0425A4 17          0539*      rla
0425A5 ED 6A       0540*      adc hl,hl
0425A7 EB          0541*      ex de,hl
0425A8 29          0542*      add hl,hl
0425A9 ED 52       0543*      sbc hl,de
0425AB 19          0544*      add hl,de
0425AC EB          0545*      ex de,hl
0425AD 30 04       0546*      jr nc,$+6
0425AF ED 52       0547*      sbc hl,de
0425B1 13          0548*      inc de
0425B2 13          0549*      inc de
0425B3             0550*  
0425B3             0551*      ;Iteration 10
0425B3 17          0552*      rla
0425B4 ED 6A       0553*      adc hl,hl
0425B6 17          0554*      rla
0425B7 ED 6A       0555*      adc hl,hl
0425B9 EB          0556*      ex de,hl
0425BA 29          0557*      add hl,hl
0425BB ED 52       0558*      sbc hl,de
0425BD 19          0559*      add hl,de
0425BE EB          0560*      ex de,hl
0425BF 30 04       0561*      jr nc,$+6
0425C1 ED 52       0562*      sbc hl,de
0425C3 13          0563*      inc de
0425C4 13          0564*      inc de
0425C5             0565*  
0425C5             0566*      ;Iteration 11
0425C5 17          0567*      rla
0425C6 ED 6A       0568*      adc hl,hl
0425C8 17          0569*      rla
0425C9 ED 6A       0570*      adc hl,hl
0425CB EB          0571*      ex de,hl
0425CC 29          0572*      add hl,hl
0425CD ED 52       0573*      sbc hl,de
0425CF 19          0574*      add hl,de
0425D0 EB          0575*      ex de,hl
0425D1 30 04       0576*      jr nc,$+6
0425D3 ED 52       0577*      sbc hl,de
0425D5 13          0578*      inc de
0425D6 13          0579*      inc de
0425D7             0580*  
0425D7             0581*      ;Iteration 11
0425D7 17          0582*      rla
0425D8 ED 6A       0583*      adc hl,hl
0425DA 17          0584*      rla
0425DB ED 6A       0585*      adc hl,hl
0425DD EB          0586*      ex de,hl
0425DE 29          0587*      add hl,hl
0425DF ED 52       0588*      sbc hl,de
0425E1 19          0589*      add hl,de
0425E2 EB          0590*      ex de,hl
0425E3 30 04       0591*      jr nc,$+6
0425E5 ED 52       0592*      sbc hl,de
0425E7 13          0593*      inc de
0425E8 13          0594*      inc de
0425E9             0595*  
0425E9 CB 1A       0596*      rr d
0425EB CB 1B       0597*      rr e
0425ED C9          0598*      ret
0425EE             0599*  
0425EE             0600*  sin_lut_168:
0425EE 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
0425F1 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
0425F4 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
0425F7 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
0425FA 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
0425FD 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
042600 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
042603 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
042606 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
042609 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
04260C 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
04260F 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
042612 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
042615 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
042618 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
04261B 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
04261E 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
042621 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
042624 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
042627 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
04262A 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
04262D 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
042630 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
042633 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
042636 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
042639 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
04263C 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
04263F 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
042642 A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
042645 A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
042648 AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
04264B B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
04264E B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
042651 B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
042654 BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
042657 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
04265A C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
04265D C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
042660 CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
042663 D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
042666 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
042669 D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
04266C DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
04266F DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
042672 E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
042675 E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
042678 E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
04267B EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
04267E EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
042681 EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
042684 F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
042687 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
04268A F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
04268D F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
042690 F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
042693 F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
042696 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
042699 FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
04269C FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
04269F FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
0426A2 FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
0426A5 FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
0426A8 FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
0426AB FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
0426AE 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
0426B1 FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
0426B4 FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
0426B7 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
0426BA FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
0426BD FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
0426C0 FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
0426C3 FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
0426C6 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
0426C9 F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
0426CC F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
0426CF F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
0426D2 F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
0426D5 F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
0426D8 F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
0426DB EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
0426DE EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
0426E1 EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
0426E4 E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
0426E7 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
0426EA E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
0426ED DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
0426F0 DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
0426F3 D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
0426F6 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
0426F9 D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
0426FC CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
0426FF C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
042702 C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
042705 C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
042708 BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
04270B B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
04270E B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
042711 B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
042714 AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
042717 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
04271A A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
04271D 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
042720 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
042723 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
042726 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
042729 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
04272C 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
04272F 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
042732 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
042735 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
042738 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
04273B 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
04273E 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
042741 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
042744 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
042747 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
04274A 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
04274D 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
042750 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
042753 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
042756 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
042759 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
04275C 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
04275F 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
042762 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
042765 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
042768 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
04276B 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
04276E 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
042771 FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
042774 F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
042777 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
04277A E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
04277D E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
042780 DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
042783 D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
042786 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
042789 C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
04278C C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
04278F BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
042792 B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
042795 B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042798 AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04279B A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
04279E 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
0427A1 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
0427A4 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
0427A7 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
0427AA 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
0427AD 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
0427B0 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
0427B3 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
0427B6 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
0427B9 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
0427BC 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0427BF 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0427C2 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0427C5 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0427C8 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0427CB 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0427CE 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0427D1 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0427D4 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0427D7 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0427DA 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0427DD 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0427E0 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0427E3 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0427E6 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0427E9 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0427EC 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0427EF 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0427F2 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0427F5 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0427F8 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0427FB 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0427FE 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042801 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
042804 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
042807 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04280A 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
04280D 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042810 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042813 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
042816 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042819 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
04281C 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
04281F 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042822 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
042825 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042828 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04282B 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
04282E 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042831 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
042834 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
042837 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04283A 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04283D 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042840 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042843 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042846 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042849 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04284C 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
04284F 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042852 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042855 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042858 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04285B 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
04285E 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042861 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
042864 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
042867 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04286A 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
04286D 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
042870 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
042873 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
042876 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042879 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
04287C 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
04287F 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042882 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
042885 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
042888 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04288B 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
04288E 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
042891 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
042894 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
042897 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04289A 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
04289D 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0428A0 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0428A3 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0428A6 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0428A9 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0428AC 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0428AF 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0428B2 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0428B5 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0428B8 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0428BB 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0428BE 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0428C1 A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0428C4 AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0428C7 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0428CA B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0428CD BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0428D0 C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0428D3 C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0428D6 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0428D9 D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0428DC DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0428DF E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0428E2 E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0428E5 EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0428E8 F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0428EB FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0428EE             0857*  
0428EE             0858*  atan_lut_168:
0428EE 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
0428F1 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
0428F4 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
0428F7 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
0428FA A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
0428FD CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
042900 F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
042903 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
042906 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
042909 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
04290C 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
04290F BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
042912 E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
042915 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
042918 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
04291B 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
04291E 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
042921 B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
042924 DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
042927 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
04292A 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
04292D 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
042930 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
042933 A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
042936 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
042939 F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
04293C 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
04293F 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
042942 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
042945 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
042948 C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
04294B E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
04294E 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
042951 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
042954 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
042957 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
04295A B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
04295D D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
042960 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
042963 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
042966 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
042969 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
04296C A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
04296F C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
042972 EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
042975 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
042978 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
04297B 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
04297E 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
042981 B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
042984 DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
042987 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
04298A 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
04298D 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
042990 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
042993 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
042996 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
042999 ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
04299C 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
04299F 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
0429A2 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
0429A5 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
0429A8 AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
0429AB D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
0429AE FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
0429B1 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
0429B4 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
0429B7 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
0429BA 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
0429BD BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
0429C0 E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
0429C3 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
0429C6 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
0429C9 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
0429CC 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
0429CF 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
0429D2 C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
0429D5 E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
0429D8 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
0429DB 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
0429DE 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
0429E1 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
0429E4 A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
0429E7 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
0429EA EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
0429ED 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
0429F0 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
0429F3 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
0429F6 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
0429F9 A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
0429FC C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
0429FF EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
042A02 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
042A05 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
042A08 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
042A0B 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
042A0E 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
042A11 C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
042A14 E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
042A17 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
042A1A 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
042A1D 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
042A20 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
042A23 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
042A26 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
042A29 DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
042A2C FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
042A2F 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
042A32 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
042A35 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
042A38 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
042A3B AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
042A3E CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
042A41 EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
042A44 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
042A47 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
042A4A 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
042A4D 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
042A50 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
042A53 BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
042A56 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
042A59 FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
042A5C 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
042A5F 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
042A62 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
042A65 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
042A68 A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
042A6B C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
042A6E E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
042A71 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
042A74 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
042A77 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
042A7A 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
042A7D 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
042A80 A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
042A83 C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
042A86 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
042A89 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
042A8C 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
042A8F 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
042A92 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
042A95 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
042A98 A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
042A9B C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
042A9E E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
042AA1 FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
042AA4 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
042AA7 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
042AAA 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
042AAD 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
042AB0 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
042AB3 B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
042AB6 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
042AB9 F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
042ABC 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
042ABF 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
042AC2 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
042AC5 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
042AC8 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
042ACB A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
042ACE C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
042AD1 DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
042AD4 FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
042AD7 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
042ADA 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
042ADD 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
042AE0 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
042AE3 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
042AE6 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
042AE9 C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
042AEC E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
042AEF FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
042AF2 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
042AF5 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
042AF8 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
042AFB 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
042AFE 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
042B01 A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
042B04 C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
042B07 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
042B0A F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
042B0D 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
042B10 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
042B13 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
042B16 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
042B19 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
042B1C 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
042B1F B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
042B22 CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
042B25 E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
042B28 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
042B2B 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
042B2E 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
042B31 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
042B34 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
042B37 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
042B3A 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
042B3D B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
042B40 D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
042B43 EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
042B46 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
042B49 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
042B4C 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
042B4F 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
042B52 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
042B55 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
042B58 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
042B5B B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
042B5E CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
042B61 E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
042B64 FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
042B67 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
042B6A 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
042B6D 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
042B70 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
042B73 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
042B76 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
042B79 A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
042B7C BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
042B7F D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
042B82 EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
042B85 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
042B88 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
042B8B 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
042B8E 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
042B91 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
042B94 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
042B97 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
042B9A A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
042B9D BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
042BA0 D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
042BA3 E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
042BA6 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
042BA9 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
042BAC 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
042BAF 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
042BB2 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
042BB5 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
042BB8 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
042BBB 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
042BBE AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
042BC1 C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
042BC4 DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
042BC7 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
042BCA 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
042BCD 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
042BD0 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
042BD3 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
042BD6 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
042BD9 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
042BDC 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
042BDF 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
042BE2 AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
042BE5 C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
042BE8 D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
042BEB EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
042BEE 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042BF1             0059   ; App-specific includes
042BF1             0060   	include "player.inc"
042BF1             0001*  ; ######## GAME STATE VARIABLES #######
042BF1             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042BF1 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042BF4             0004*  ; player current shields,binary
042BF4             0005*  ; when < 0 player splodes
042BF4             0006*  ; restores to player_max_shields when new ship spawns
042BF4 10          0007*  player_shields: db 16 ; binary
042BF5             0008*  ; max player shields,binary
042BF5             0009*  ; can increase with power-ups (todo)
042BF5 10          0010*  player_max_shields: db 16 ; binary
042BF6             0011*  ; when reaches zero,game ends
042BF6             0012*  ; can increase based on TODO
042BF6 03          0013*  player_ships: db 0x03 ; binary
042BF7             0014*  
042BF7             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042BF7             0016*  ; uses the same offsets from its table base as the main sprite table:
042BF7             0017*  player_start_variables: ; label marking beginning of table
042BF7 04          0018*  player_id:               db table_max_records
042BF8 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042BF9 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042BFC 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042BFF 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042C00 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042C01 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042C02 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042C05 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042C08 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042C0B 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042C0E 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042C11 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042C14 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042C17 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042C18 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042C19 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042C1A 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042C1B 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042C1C 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042C1D             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042C1D             0039*  
042C1D             0040*  ; set initial player position
042C1D             0041*  ; inputs: none,everything is hardcoded
042C1D             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042C1D             0043*  ; destroys: a
042C1D             0044*  player_init:
042C1D 3A F7 2B 04 0045*  	ld a,(player_id)
042C21 CD C9 1F 04 0046*  	call vdu_sprite_select
042C25 CD DC 1F 04 0047*      call vdu_sprite_clear_frames
042C29 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042C2D CD 16 21 04 0049*      call vdu_sprite_add_buff
042C31 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042C35 CD 16 21 04 0051*      call vdu_sprite_add_buff
042C39 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042C3D CD 16 21 04 0053*      call vdu_sprite_add_buff
042C41 01 00 00 00 0054*      ld bc,0
042C45 ED 43 02 2C 0055*      ld (player_x),bc
       04          
042C4A 11 00 DF 00 0056*      ld de,0x00DF00
042C4E ED 53 05 2C 0057*      ld (player_y),de
       04          
042C53 CD 95 20 04 0058*      call vdu_sprite_move_abs168
042C57 CD 3F 20 04 0059*      call vdu_sprite_show
042C5B C9          0060*      ret
042C5C             0061*  
042C5C             0062*  ; process player keyboard input, set player bitmap
042C5C             0063*  ; velocities and draw player bitmap at updated coordinates
042C5C             0064*  ; Inputs: player_x/y set at desired position
042C5C             0065*  ; Returns: player bitmap drawn at updated position
042C5C             0066*  ; Destroys: probably everything except maybe iy
042C5C             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042C5C             0068*  ; TODO: requires sprite implementation
042C5C             0069*  player_input:
042C5C             0070*  ; reset player component velocities to zero as the default
042C5C 21 00 00 00 0071*  	ld hl,0
042C60 22 08 2C 04 0072*  	ld (player_xvel),hl
042C64 22 0B 2C 04 0073*  	ld (player_yvel),hl
042C68             0074*  ; make ship the active sprite
042C68 3A F7 2B 04 0075*      ld a,(player_id)
042C6C CD C9 1F 04 0076*      call vdu_sprite_select
042C70             0077*  ; check for keypresses and branch accordingly
042C70             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042C70             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042C70 3E 1E       0001*M 			LD	A, function
042C72 5B CF       0002*M 			RST.LIL	08h
042C74             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042C74             0081*  ; this handles the case where two opposing movement keys
042C74             0082*  ; are down simultaneously (velocities will net to zero)
042C74             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042C74             0084*  ; it also allows movement and action keys to be detected simultaneously
042C74             0085*  ; so we can walk and chew gum at the same time
042C74 3E 01       0086*      ld a,1 ; set ship's default animation to center
042C76             0087*          ; if left and right are both down a will net to
042C76             0088*  
042C76             0089*  @left:
042C76 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042C7A 28 0E       0091*      jr z,@right
042C7C 2A 08 2C 04 0092*      ld hl,(player_xvel)
042C80 01 00 FD FF 0093*      ld bc,-speed_player
042C84 09          0094*      add hl,bc
042C85 22 08 2C 04 0095*      ld (player_xvel),hl
042C89 3D          0096*      dec a ; set ship's animation to left
042C8A             0097*  @right:
042C8A DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042C8E 28 0E       0099*  	jr z,@up
042C90 2A 08 2C 04 0100*      ld hl,(player_xvel)
042C94 01 00 03 00 0101*      ld bc,speed_player
042C98 09          0102*      add hl,bc
042C99 22 08 2C 04 0103*      ld (player_xvel),hl
042C9D 3C          0104*      inc a ; set ship's animation to right
042C9E             0105*  @up:
042C9E DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042CA2 28 0D       0107*  	jr z,@down
042CA4 2A 0B 2C 04 0108*      ld hl,(player_yvel)
042CA8 01 00 FD FF 0109*      ld bc,-speed_player
042CAC 09          0110*      add hl,bc
042CAD 22 0B 2C 04 0111*      ld (player_yvel),hl
042CB1             0112*  @down:
042CB1 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042CB5 28 0D       0114*  	jr z,@done_keyboard
042CB7 2A 0B 2C 04 0115*      ld hl,(player_yvel)
042CBB 01 00 03 00 0116*      ld bc,speed_player
042CBF 09          0117*      add hl,bc
042CC0 22 0B 2C 04 0118*      ld (player_yvel),hl
042CC4             0119*  @done_keyboard:
042CC4             0120*  ; move player sprite according to velocities set by keypresses
042CC4 2A 08 2C 04 0121*      ld hl,(player_xvel)
042CC8             0122*  ; compute new x position
042CC8 ED 5B 02 2C 0123*      ld de,(player_x)
       04          
042CCD 19          0124*      add hl,de ; hl = player_x + player_xvel
042CCE             0125*      ; check for horizontal screen edge collisions
042CCE             0126*      ; and adjust coordinate as necessary
042CCE             0127*  ; TODO: make this work using 24-bit registers
042CCE             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042CCE             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042CCE             0130*      ; ld a,8 ; set x to leftmost allowable position
042CCE             0131*  ; @check_right:
042CCE             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042CCE             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042CCE             0134*  ;     ld a,248 ; set x to rightmost allowable position
042CCE             0135*  @x_ok:
042CCE             0136*  ; save the updated drawing coordinate
042CCE 22 02 2C 04 0137*      ld (player_x),hl
042CD2             0138*  ;compute new y position
042CD2 2A 05 2C 04 0139*      ld hl,(player_y)
042CD6 ED 5B 0B 2C 0140*      ld de,(player_yvel)
       04          
042CDB 19          0141*      add hl,de ; hl = player_y + player_yvel
042CDC             0142*  ; TODO: make this work using 24-bit registers
042CDC             0143*  ;     ; check for vertical screen edge collisions
042CDC             0144*  ;     ; and adjust coordinate as necessary
042CDC             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042CDC             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042CDC             0147*  ;     ld a,8 ; set y to topmost allowable position
042CDC             0148*  ; @check_top:
042CDC             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042CDC             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042CDC             0151*  ;     ld a,232 ; set y to bottommost allowable position
042CDC             0152*  @y_ok:
042CDC 22 05 2C 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042CE0             0154*  ; a should land here loaded with the correct frame
042CE0 CD 2C 20 04 0155*      call vdu_sprite_select_frame
042CE4             0156*  ; draw player at updated position
042CE4 ED 4B 02 2C 0157*      ld bc,(player_x)
       04          
042CE9 ED 5B 05 2C 0158*  	ld de,(player_y)
       04          
042CEE             0159*  
042CEE             0160*      ; call dumpRegistersHex
042CEE             0161*  
042CEE CD 95 20 04 0162*  	call vdu_sprite_move_abs168
042CF2             0163*  
042CF2             0164*  ; end player_input
042CF2 C9          0165*  	ret
042CF3             0166*  
042CF3             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042CF3             0168*  ; ; INSTEAD OF FRACTIONAL
042CF3             0169*  ; ; ----------------------------------------------------------------
042CF3             0170*  ; ; process player keyboard input, set player bitmap
042CF3             0171*  ; ; velocities and draw player bitmap at updated coordinates
042CF3             0172*  ; ; Inputs: player_x/y set at desired position
042CF3             0173*  ; ; Returns: player bitmap drawn at updated position
042CF3             0174*  ; ; Destroys: probably everything except maybe iy
042CF3             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042CF3             0176*  ; ; TODO: requires sprite implementation
042CF3             0177*  ; player_input:
042CF3             0178*  ; ; reset player component velocities to zero as the default
042CF3             0179*  ; 	ld hl,0
042CF3             0180*  ; 	ld (player_xvel),hl
042CF3             0181*  ; 	ld (player_yvel),hl
042CF3             0182*  ; ; check for keypresses and branch accordingly
042CF3             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042CF3             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042CF3             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042CF3             0186*  ; ; this handles the case where two opposing movement keys
042CF3             0187*  ; ; are down simultaneously (velocities will net to zero)
042CF3             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042CF3             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042CF3             0190*  ; ; so we can walk and chew gum at the same time
042CF3             0191*  ; @left:
042CF3             0192*  ;     bit 1,(ix+3) ; keycode 26
042CF3             0193*  ;     jr z,@right
042CF3             0194*  ;     ld hl,(player_xvel)
042CF3             0195*  ;     ld bc,-3
042CF3             0196*  ;     add hl,bc
042CF3             0197*  ;     ld (player_xvel),hl
042CF3             0198*  ; @right:
042CF3             0199*  ;     bit 1,(ix+15) ; keycode 122
042CF3             0200*  ; 	jr z,@up
042CF3             0201*  ;     ld hl,(player_xvel)
042CF3             0202*  ;     ld bc,3
042CF3             0203*  ;     add hl,bc
042CF3             0204*  ;     ld (player_xvel),hl
042CF3             0205*  ; @up:
042CF3             0206*  ;     bit 1,(ix+7) ; keycode 58
042CF3             0207*  ; 	jr z,@down
042CF3             0208*  ;     ld hl,(player_yvel)
042CF3             0209*  ;     ld bc,-3
042CF3             0210*  ;     add hl,bc
042CF3             0211*  ;     ld (player_yvel),hl
042CF3             0212*  ; @down:
042CF3             0213*  ;     bit 1,(ix+5) ; keycode 42
042CF3             0214*  ; 	jr z,@done_keyboard
042CF3             0215*  ;     ld hl,(player_yvel)
042CF3             0216*  ;     ld bc,3
042CF3             0217*  ;     add hl,bc
042CF3             0218*  ;     ld (player_yvel),hl
042CF3             0219*  ; @done_keyboard:
042CF3             0220*  ; ; move player sprite according to velocities set by keypresses
042CF3             0221*  ;     ld hl,(player_xvel)
042CF3             0222*  ; ; compute new x position
042CF3             0223*  ;     ld de,(player_x)
042CF3             0224*  ;     add hl,de ; hl = player_x + player_xvel
042CF3             0225*  ;     ; check for horizontal screen edge collisions
042CF3             0226*  ;     ; and adjust coordinate as necessary
042CF3             0227*  ; ; TODO: make this work using 24-bit registers
042CF3             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042CF3             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042CF3             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042CF3             0231*  ; ; @check_right:
042CF3             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042CF3             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042CF3             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042CF3             0235*  ; @x_ok:
042CF3             0236*  ;     ; save the updated drawing coordinate
042CF3             0237*  ;     ld (player_x),hl
042CF3             0238*  ; ;compute new y position
042CF3             0239*  ;     ld hl,(player_y)
042CF3             0240*  ;     ld de,(player_yvel)
042CF3             0241*  ;     add hl,de ; hl = player_y + player_yvel
042CF3             0242*  ; ; TODO: make this work using 24-bit registers
042CF3             0243*  ; ;     ; check for vertical screen edge collisions
042CF3             0244*  ; ;     ; and adjust coordinate as necessary
042CF3             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042CF3             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042CF3             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042CF3             0248*  ; ; @check_top:
042CF3             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042CF3             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042CF3             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042CF3             0252*  ; @y_ok:
042CF3             0253*  ;     ld (player_y),hl
042CF3             0254*  ; ; draw player at updated position
042CF3             0255*  ;     ld a,(player_id)
042CF3             0256*  ;     call vdu_sprite_select
042CF3             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042CF3             0258*  ;     call get_sign_hlu ; to set the proper animation
042CF3             0259*  ;     add a,1 ; ...
042CF3             0260*  ;     call vdu_sprite_select_frame
042CF3             0261*  ;     ld bc,(player_x)
042CF3             0262*  ; 	ld de,(player_y)
042CF3             0263*  ; 	call vdu_sprite_move_abs
042CF3             0264*  ; ; end player_input
042CF3             0265*  ; 	ret
042CF3             0266*  
042CF3             0267*  
042CF3             0268*  ; ###################################################################
042CF3             0269*  ; TODO: the below is all stuff from the original code we need to port
042CF3             0270*  ; ###################################################################
042CF3             0271*  
042CF3             0272*  ; kill_player:
042CF3             0273*  ; ; set player status to dead
042CF3             0274*  ;     xor a; sets all player flags to zero
042CF3             0275*  ;     ld (player_collisions),a
042CF3             0276*  ; ; deduct a ship from the inventory
042CF3             0277*  ;     ld a,(player_ships)
042CF3             0278*  ;     dec a
042CF3             0279*  ;     ld (player_ships),a
042CF3             0280*  ; ; are we out of ships?
042CF3             0281*  ;     jp z,game_over
042CF3             0282*  ; ; wait a few ticks
042CF3             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042CF3             0284*  ;     ld (player_move_timer),a
042CF3             0285*  ; kill_player_loop:
042CF3             0286*  ;     call vdu_vblank
042CF3             0287*  ;     ld a,(player_move_timer)
042CF3             0288*  ;     dec a
042CF3             0289*  ;     ld (player_move_timer),a
042CF3             0290*  ;     jr nz,kill_player_loop
042CF3             0291*  ;     call player_init ; player respawn if timer zero
042CF3             0292*  ;     ret ; and out
042CF3             0293*  
042CF3             0294*  
042CF3             0295*  ; player_move:
042CF3             0296*  ; ; begin setting player to active sprite
042CF3             0297*  ;     ld hl,player
042CF3             0298*  ;     ld (sprite_base_bufferId),hl
042CF3             0299*  ;     ld hl,0 ; north
042CF3             0300*  ;     ld (sprite_heading),hl
042CF3             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042CF3             0302*  ;     ld (sprite_animation),a
042CF3             0303*  ;     ; we set position here for the time being as a default
042CF3             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042CF3             0305*  ;     ld hl,(player_x)
042CF3             0306*  ;     ld (sprite_x),hl
042CF3             0307*  ;     ld hl,(player_y)
042CF3             0308*  ;     ld (sprite_y),hl
042CF3             0309*  ; ; did we just die?
042CF3             0310*  ;     ld a,(player_collisions)
042CF3             0311*  ;     and %00000010 ; zero flag will be set if not dead
042CF3             0312*  ;     jr z,player_not_dead
042CF3             0313*  ; ; yes we died
042CF3             0314*  ;     call kill_player
042CF3             0315*  ;     ret ; done
042CF3             0316*  ; ; yay we didn't die
042CF3             0317*  ; player_not_dead:
042CF3             0318*  ; ; set player movements to zero by default
042CF3             0319*  ;     ld hl,0
042CF3             0320*  ;     ld (player_xvel),hl
042CF3             0321*  ;     ld (player_yvel),hl
042CF3             0322*  ; ; do we move it?
042CF3             0323*  ;     in a,(#82) ; keyboard
042CF3             0324*  ;     or a ; if zero,don't move
042CF3             0325*  ;     jr z,player_draw
042CF3             0326*  ; ; move it
042CF3             0327*  ;     call player_move_calc
042CF3             0328*  ; player_draw:
042CF3             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042CF3             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042CF3             0331*  ; player_move_done:
042CF3             0332*  ;     ; write updated x,y coordinates back to player table
042CF3             0333*  ;     ld hl,(sprite_x)
042CF3             0334*  ;     ld (player_x),hl
042CF3             0335*  ;     ld hl,(sprite_y)
042CF3             0336*  ;     ld (player_y),hl
042CF3             0337*  ;     ret
042CF3             0061   	include "tiles.inc"
042CF3             0001*  ; ######### TILES #########
042CF3             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042CF3             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042CF3 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042CF6 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042CF7             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042CF7 00          0007*  cur_level: db 0
042CF8             0008*  num_levels: equ 2 ; number of levels,duh
042CF8             0009*  
042CF8             0010*  ; lookup table for level definitions
042CF8 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042CFE             0012*  
042CFE             0013*  ; tiles_bufferId: dl 0
042CFE 00 00 00    0014*  tiles_x_plot: dl 0
042D01 F1 FF FF    0015*  tiles_y_plot: dl -15
042D04             0016*  
042D04             0017*  
042D04             0018*  tiles_plot:
042D04             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042D04             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042D04             0021*  ; ;       but don't want
042D04             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042D04             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042D04             0024*  ; 	ld bc,0 ; leftmost x-coord
042D04             0025*  ; 	ld de,0 ; topmost y-coord
042D04             0026*  ; 	ld ix,255 ; rightmost x-coord
042D04             0027*  ; 	ld iy,1 ; bottommost y-coord
042D04             0028*  ; 	call vdu_set_gfx_viewport
042D04             0029*  
042D04 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042D08 22 FE 2C 04 0031*      ld (tiles_x_plot),hl
042D0C 2A F3 2C 04 0032*      ld hl,(tiles_row_defs)
042D10 06 10       0033*  	ld b,16 ; loop counter
042D12             0034*  @loop:
042D12 C5          0035*  	push bc ; save the loop counter
042D13             0036*  ; read the tile defintion for the current column
042D13 7E          0037*      ld a,(hl) ; a has tile definition
042D14 E5          0038*      push hl  ; save pointer to tile definition
042D15 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042D19 6F          0040*      ld l,a ; l is tile defintion
042D1A 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042D1C CD 5F 1C 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042D20             0043*  
042D20             0044*  ; plot the active bitmap
042D20 ED 4B FE 2C 0045*      ld bc,(tiles_x_plot)
       04          
042D25 ED 5B 01 2D 0046*      ld de,(tiles_y_plot)
       04          
042D2A CD 28 1F 04 0047*      call vdu_plot_bmp
042D2E             0048*  
042D2E             0049*  ; bump x-coords the width of one tile and save it
042D2E 2A FE 2C 04 0050*      ld hl,(tiles_x_plot)
042D32 01 10 00 00 0051*      ld bc,16
042D36 09          0052*      add hl,bc
042D37 22 FE 2C 04 0053*      ld (tiles_x_plot),hl
042D3B             0054*  
042D3B             0055*  ; prepare to loop to next column
042D3B E1          0056*      pop hl ; get back pointer to tile def
042D3C 23          0057*      inc hl ; bump it to the next column
042D3D C1          0058*  	pop bc ; snag our loop counter
042D3E 10 D2       0059*      djnz @loop
042D40             0060*  
042D40             0061*  ; increment tiles plotting y-coordinate
042D40             0062*  ; when it hits zero, we go to next row of tiles in the map
042D40             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042D40 DD 21 01 2D 0064*  	ld ix,tiles_y_plot
       04          
042D45 DD 34 00    0065*  	inc (ix)
042D48 C0          0066*  	ret nz
042D49             0067*  
042D49             0068*  ; time to bump tiles_row_defs to next row
042D49             0069*  ; (hl was already there at the end of the loop)
042D49 22 F3 2C 04 0070*      ld (tiles_row_defs),hl
042D4D             0071*  
042D4D             0072*  ; reset coords to plot next row of tiles
042D4D 21 00 00 00 0073*      ld hl,0
042D51 22 FE 2C 04 0074*      ld (tiles_x_plot),hl
042D55 21 F1 FF FF 0075*      ld hl,-15
042D59 22 01 2D 04 0076*      ld (tiles_y_plot),hl
042D5D             0077*  
042D5D             0078*  ; decrement tiles row counter
042D5D 21 F6 2C 04 0079*      ld hl,tiles_row
042D61 35          0080*      dec (hl)
042D62 C0          0081*      ret nz
042D63             0082*  
042D63             0083*  ; queue up next level
042D63 3A F7 2C 04 0084*      ld a,(cur_level)
042D67 FE 01       0085*      cp num_levels-1
042D69 20 02       0086*      jr nz,@inc_level
042D6B 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
042D6D             0088*  
042D6D             0089*  @inc_level:
042D6D 3C          0090*      inc a
042D6E 32 F7 2C 04 0091*      ld (cur_level),a
042D72             0092*  
042D72             0093*  ; increase the number of enemy sprites
042D72 3A B9 2D 04 0094*      ld a,(max_enemy_sprites)
042D76 3C          0095*      inc a
042D77 FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
042D79 28 04       0097*      jr z,init_level
042D7B 32 B9 2D 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
042D7F             0099*  ; fall through to init_level
042D7F             0100*  
042D7F             0101*  init_level:
042D7F             0102*  ; look up address of level's tile defintion
042D7F 21 F8 2C 04 0103*      ld hl,tiles_levels
042D83 3A F7 2C 04 0104*      ld a,(cur_level)
042D87 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
042D8B 57          0106*      ld d,a
042D8C 1E 03       0107*      ld e,3
042D8E ED 5C       0108*      mlt de
042D90 19          0109*      add hl,de
042D91 ED 37       0110*      ld ix,(hl)
042D93 DD 22 F3 2C 0111*      ld (tiles_row_defs),ix
       04          
042D98             0112*  
042D98             0113*  ; set tiles_row counter
042D98 DD 7E 00    0114*      ld a,(ix)
042D9B 32 F6 2C 04 0115*      ld (tiles_row),a
042D9F DD 23       0116*      inc ix ; now ix points first element of first row tile def
042DA1 DD 22 F3 2C 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
042DA6 C9          0118*      ret
042DA7             0119*  
042DA7             0120*  
042DA7             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
042DA7             0122*  ; dt_is_active:
042DA7             0123*  ; ; a lands here containing a tile index in the low nibble
042DA7             0124*  ; ; we test the values for the tiles which are active
042DA7             0125*  ;     cp #07
042DA7             0126*  ;     call z,ld_act_landing_pad
042DA7             0127*  ;     cp #08
042DA7             0128*  ;     call z,ld_act_laser_turret
042DA7             0129*  ;     ; fall through
042DA7             0130*  ;     ret
042DA7             0131*  
042DA7             0132*  ; ; some tiles become active sprites,so we load those here
042DA7             0133*  ; ; sprite_x/y have already been loaded
042DA7             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
042DA7             0135*  ; ; we don't want sprite drawn to background like other tiles
042DA7             0136*  ; ; so this routine only adds them to the sprite table
042DA7             0137*  ; dt_ld_act:
042DA7             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
042DA7             0139*  ;     ld (sprite_y+1),a ; just the integer part
042DA7             0140*  ;     ld (sprite_base_bufferId),hl
042DA7             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042DA7             0142*  ;     call table_add_record
042DA7             0143*  ;     call sprite_variables_from_stack
042DA7             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
042DA7             0145*  ;     ret ; and back
042DA7             0146*  
042DA7             0147*  ; ld_act_landing_pad:
042DA7             0148*  ;     call sprite_variables_to_stack
042DA7             0149*  
042DA7             0150*  ;     ld hl,move_landing_pad
042DA7             0151*  ;     ld (sprite_move_program),hl
042DA7             0152*  
042DA7             0153*  ;     xor a
042DA7             0154*  ;     ld (sprite_animation),a ; animation 0
042DA7             0155*  
042DA7             0156*  ;     call rand_8     ; snag a random number
042DA7             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042DA7             0158*  ;     add a,64 ; range is now 64-127
042DA7             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042DA7             0160*  
042DA7             0161*  ;     ld a,%10 ; collides with laser but not player
042DA7             0162*  ;     ld (iy+sprite_collisions),a
042DA7             0163*  
042DA7             0164*  ;     ld a,#05 ; BCD
042DA7             0165*  ;     ld (sprite_points),a
042DA7             0166*  ;     ld a,0 ; binary
042DA7             0167*  ;     ld (sprite_shield_damage),a
042DA7             0168*  
042DA7             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
042DA7             0170*  ;     jr dt_ld_act
042DA7             0171*  
042DA7             0172*  ; ld_act_laser_turret:
042DA7             0173*  ;     call sprite_variables_to_stack
042DA7             0174*  
042DA7             0175*  ;     ld hl,move_laser_turret
042DA7             0176*  ;     ld (sprite_move_program),hl
042DA7             0177*  
042DA7             0178*  ;     xor a
042DA7             0179*  ;     ld (sprite_animation),a
042DA7             0180*  ;     ld (sprite_move_step),a
042DA7             0181*  
042DA7             0182*  ;     call rand_8     ; snag a random number
042DA7             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042DA7             0184*  ;     add a,64 ; range is now 64-127
042DA7             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042DA7             0186*  
042DA7             0187*  ;     ld a,%10 ; collides with laser but not player
042DA7             0188*  ;     ld (iy+sprite_collisions),a
042DA7             0189*  
042DA7             0190*  ;     ld a,#10 ; BCD
042DA7             0191*  ;     ld (sprite_points),a
042DA7             0192*  ;     ld a,0 ; binary
042DA7             0193*  ;     ld (sprite_shield_damage),a
042DA7             0194*  
042DA7             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
042DA7             0196*  ;     jp dt_ld_act
042DA7             0197*  
042DA7             0198*  
042DA7             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
042DA7             0200*  ; deletes sprites from table when they wrap around to top of screen
042DA7             0201*  move_active_tiles:
042DA7             0202*  ; get current position
042DA7 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
042DAB 3C          0204*      inc a
042DAC             0205*  ; are we at the bottom of the screen?
042DAC 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
042DAE             0207*  ; otherwise kill sprite
042DAE 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
042DB0 FD 77 08    0209*      ld (iy+sprite_collisions),a
042DB3 C9          0210*      ret ; debug
042DB4             0211*  move_active_tiles_draw_sprite:
042DB4 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
042DB8             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042DB8             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
042DB8 C9          0215*      ret ; and done
042DB9             0062   	include "enemies.inc"
042DB9 10          0001*  max_enemy_sprites: db 16
042DBA             0002*  
042DBA             0003*  ; sprite_type
042DBA             0004*  enemy_dead: equ 0
042DBA             0005*  enemy_small: equ 1
042DBA             0006*  enemy_medium: equ 2
042DBA             0007*  enemy_large: equ 3
042DBA             0008*  landing_pad: equ 4
042DBA             0009*  laser_turret: equ 5
042DBA             0010*  fireballs: equ 6
042DBA             0011*  explosion: equ 7
042DBA             0012*  
042DBA             0013*  
042DBA             0014*  respawn_countdown:
042DBA 2A DB 2D 04 0015*      ld hl,(respawn_timer)
042DBE 2B          0016*      dec hl
042DBF 22 DB 2D 04 0017*      ld (respawn_timer),hl
042DC3             0018*  ; check hl for zero
042DC3 19          0019*      add hl,de
042DC4 B7          0020*      or a
042DC5 ED 52       0021*      sbc hl,de
042DC7 C0          0022*      ret nz
042DC8 06 04       0023*      ld b,table_max_records
042DCA             0024*  @respawn_loop:
042DCA C5          0025*      push bc
042DCB CD CC 2E 04 0026*      call enemy_init_from_landing_pad
042DCF C1          0027*      pop bc
042DD0 10 F8       0028*      djnz @respawn_loop
042DD2 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
042DD6 22 DB 2D 04 0030*      ld (respawn_timer),hl
042DDA C9          0031*      ret
042DDB 3C 00 00    0032*  respawn_timer: dl 1*60
042DDE             0033*  
042DDE             0034*  move_enemies:
042DDE             0035*  ; are there any active enemies or explosions?
042DDE 21 00 00 00 0036*      ld hl,0
042DE2 3A 7D 16 04 0037*      ld a,(table_active_sprites)
042DE6 6F          0038*      ld l,a
042DE7             0039*      ; call dumpRegistersHex
042DE7 A7          0040*      and a ; will be zero if no alive enemies or explosions
042DE8             0041*      ; ret z ; so nothing to do but go back
042DE8             0042*      ; ld hl,(respawn_timer)
042DE8             0043*      ; call dumpRegistersHex
042DE8 20 05       0044*      jr nz,move_enemies_do
042DEA CD BA 2D 04 0045*      call respawn_countdown
042DEE C9          0046*      ret
042DEF             0047*  move_enemies_do:
042DEF             0048*  ; initialize pointers and loop counter
042DEF FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
042DF4 06 04       0050*      ld b,table_max_records ; loop counter
042DF6             0051*  move_enemies_loop:
042DF6 FD 22 7A 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
042DFB C5          0053*      push bc ; backup loop counter
042DFC             0054*  ; check sprite_type to see if sprite is active
042DFC FD 7E 01    0055*      ld a,(iy+sprite_type)
042DFF A7          0056*      and a ; if zero, sprite is dead
042E00 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
042E02             0058*  ; otherwise we prepare to move the sprite
042E02 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
042E05 CD C9 1F 04 0060*      call vdu_sprite_select ; select sprite
042E09 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
042E0C E9          0062*      jp (hl)  ; ... and jump to it
042E0D             0063*  ; we always jp back here from behavior subroutines
042E0D             0064*  move_enemies_loop_return:
042E0D FD 2A 7A 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
042E12             0066*  ; now we check results of all the moves
042E12 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
042E15 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
042E17 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
042E1A 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
042E1C CD C6 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
042E20 AF          0072*      xor a ; zero a so that we can ...
042E21 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
042E24 18 0A       0074*      jr move_enemies_next_record ; and to the next record
042E26             0075*  move_enemies_draw_sprite:
042E26             0076*  ; if we got here sprite will have already been activated
042E26             0077*  ; so all we need to do is set its coordinates and draw it
042E26 FD 07 0B    0078*      ld bc,(iy+sprite_x)
042E29 FD 17 0E    0079*      ld de,(iy+sprite_y)
042E2C CD 95 20 04 0080*      call vdu_sprite_move_abs168
042E30             0081*  ; fall through to next record
042E30             0082*  move_enemies_next_record:
042E30 11 26 00 00 0083*      ld de,table_bytes_per_record
042E34 FD 19       0084*      add iy,de ; point to next record
042E36 AF          0085*      xor a ; clears carry flag
042E37 32 7E 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
042E3B C1          0087*      pop bc ; get back our loop counter
042E3C 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
042E3E C9          0089*      ret ; and we're out
042E3F             0090*  
042E3F             0091*  en_nav_zigzag_start:
042E3F FD 2A 7A 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042E44 CD 79 23 04 0093*      call rand_8
042E48 E6 3F       0094*      and %00111111 ; limit it to 64
042E4A CB DF       0095*      set 3,a ; make sure it's at least 8
042E4C FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
042E4F             0097*      ; fall through to en_nav_zigzag
042E4F             0098*  en_nav_zigzag:
042E4F FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
042E52 3D          0100*      dec a
042E53 FD 77 22    0101*      ld (iy+sprite_move_timer),a
042E56 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
042E58             0103*      ; otherwise flip direction and restart timer
042E58 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
042E5B EE 01       0105*      xor %1 ; flips bit one
042E5D FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
042E60 20 09       0107*      jr nz,en_nav_zigzag_right
042E62             0108*  ;otherwise zag left
042E62 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
042E66 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
042E69 18 D4       0111*      jr en_nav_zigzag_start
042E6B             0112*  en_nav_zigzag_right:
042E6B 21 00 60 00 0113*      ld hl,0x006000; southeast heading
042E6F FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
042E72 18 CB       0115*      jr en_nav_zigzag_start
042E74             0116*  en_nav_zigzag_no_switch:
042E74             0117*      ; ld a,(sprite_orientation)
042E74 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
042E77 18 13       0119*      jr en_nav_computevelocities
042E79             0120*  
042E79             0121*  ; contains the logic for how to move the enemy
042E79             0122*  ; and then does the moving
042E79             0123*  ; inputs: a fully-populated active sprite table
042E79             0124*  ;         player position variables
042E79             0125*  ; destroys: everything except index registers
042E79             0126*  ; outputs: moving enemies
042E79             0127*  en_nav:
042E79             0128*  ; set velocity and orientation by player's relative location
042E79             0129*  ; move enemies y-axis
042E79             0130*  ; where is player relative to us?
042E79 CD 4F 2F 04 0131*      call orientation_to_player
042E7D             0132*  ;    h.l 16.8 fixed angle256 to player
042E7D             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042E7D             0134*  ; is player above or below us?
042E7D ED 53 3A 1A 0135*      ld (ude),de ; dy
       04          
042E82 3A 3C 1A 04 0136*      ld a,(ude+2) ; deu
042E86 17          0137*      rla ; shift sign bit into carry
042E87 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
042E89             0139*  ; player is even or above,so home in on current heading
042E89 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
042E8C             0141*  
042E8C             0142*  ; we land here from zig-zag program so as not to
042E8C             0143*  ; redundantly save orientation and heading
042E8C             0144*  en_nav_computevelocities:
042E8C             0145*  ; set x/y component velocities based on bearing to player
042E8C FD 2A 7A 16 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042E91 E5          0147*      push hl ; we need it back to set rotation frame
042E92 FD 17 17    0148*      ld de,(iy+sprite_vel)
042E95 CD A5 23 04 0149*      call polar_to_cartesian
042E99 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
042E9C FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
042E9F             0152*  ; change the animation frame to match heading
042E9F             0153*  ; by dividng the heading by 8
042E9F E1          0154*      pop hl ; get back Heading
042EA0 7C          0155*      ld a,h
042EA1 CB 3F       0156*      srl a
042EA3 CB 3F       0157*      srl a
042EA5 CB 3F       0158*      srl a
042EA7 CD 2C 20 04 0159*      call vdu_sprite_select_frame
042EAB             0160*  ; update sprite position
042EAB             0161*  move_enemy_sprite:
042EAB FD 27 0B    0162*      ld hl,(iy+sprite_x)
042EAE FD 17 11    0163*      ld de,(iy+sprite_xvel)
042EB1 19          0164*      add hl,de
042EB2 FD 2F 0B    0165*      ld (iy+sprite_x),hl
042EB5             0166*  
042EB5 FD 27 0E    0167*      ld hl,(iy+sprite_y)
042EB8 FD 17 14    0168*      ld de,(iy+sprite_yvel)
042EBB 19          0169*      add hl,de
042EBC FD 2F 0E    0170*      ld (iy+sprite_y),hl
042EBF C9          0171*      ret
042EC0             0172*  
042EC0             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
042EC0             0174*  ; move_enemy_sprite:
042EC0             0175*  ; ; x-axis movement first
042EC0             0176*  ;     ld hl,(iy+sprite_x)
042EC0             0177*  ;     push hl ; save pre-move position
042EC0             0178*  ;     pop bc ; to detect screen edge collision
042EC0             0179*  ;     ld de,(iy+sprite_xvel)
042EC0             0180*  ;     add hl,de ;compute new x position
042EC0             0181*  ;     ld (iy+sprite_x),hl ; store it
042EC0             0182*  ;     and a ; clear the carry flag
042EC0             0183*  ;     sbc hl,bc ; test which direction was our movement
042EC0             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
042EC0             0185*  ;     jp p,@move_right ; sign positive means moved right
042EC0             0186*  ; @move_left: ; otherwise we moved left
042EC0             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
042EC0             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
042EC0             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
042EC0             0190*  ;     ld a,#20 ; west
042EC0             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042EC0             0192*  ;     jr @move_y
042EC0             0193*  ; @move_right:
042EC0             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
042EC0             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042EC0             0196*  ;     ld l,0x00
042EC0             0197*  ;     ld a,(iy+sprite_dim_x)
042EC0             0198*  ;     ld h,a
042EC0             0199*  ;     ld a,0x00
042EC0             0200*  ;     sub h
042EC0             0201*  ;     ld h,a
042EC0             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
042EC0             0203*  ;     ld a,0x02 ; east
042EC0             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042EC0             0205*  ; @move_y:
042EC0             0206*  ;     ld hl,(iy+sprite_y)
042EC0             0207*  ;     ld b,h ; save pre-move position
042EC0             0208*  ;     ld c,l ; to detect screen edge collision
042EC0             0209*  ;     ld de,(iy+sprite_yvel)
042EC0             0210*  ;     add hl,de ;compute new y position
042EC0             0211*  ;     ld (iy+sprite_y),hl ; store it
042EC0             0212*  ;     and a ; clear the carry flag
042EC0             0213*  ;     sbc hl,bc ; test which direction was our movement
042EC0             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
042EC0             0215*  ;     jp p,@move_dn ; sign positive means moved down
042EC0             0216*  ; @move_up:
042EC0             0217*  ;     add hl,bc ; get back new y position
042EC0             0218*  ;     ld de,0x5000 ; top edge of visible screen
042EC0             0219*  ;     and a ; clear the carry flag
042EC0             0220*  ;     sbc hl,de
042EC0             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
042EC0             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
042EC0             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
042EC0             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042EC0             0225*  ;     or 0x80 ; north
042EC0             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042EC0             0227*  ;     jr @move_ret
042EC0             0228*  ; @move_dn:
042EC0             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
042EC0             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042EC0             0231*  ;     ld l,0x00
042EC0             0232*  ;     ld a,(iy+sprite_dim_y)
042EC0             0233*  ;     ld h,a
042EC0             0234*  ;     ld a,0x00
042EC0             0235*  ;     sub h
042EC0             0236*  ;     ld h,a
042EC0             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
042EC0             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042EC0             0239*  ;     or 0x08 ; south
042EC0             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042EC0             0241*  ; @move_ret:
042EC0             0242*  ;     ret
042EC0             0243*  
042EC0             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
042EC0             0245*  ; ; each sprite in the table must have one of these defined
042EC0             0246*  ; ; but they need not be unique to a particular sprite
042EC0             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
042EC0             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
042EC0             0249*  ; ; but they can call anything they want between those two endpoints
042EC0             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
042EC0             0251*  
042EC0             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
042EC0             0253*  ;     jp move_enemies_loop_return
042EC0             0254*  
042EC0             0255*  ; move_explosion:
042EC0             0256*  ;     call animate_explosion
042EC0             0257*  ;     jp move_enemies_loop_return
042EC0             0258*  
042EC0             0259*  move_enemy_small:
042EC0 CD 79 2E 04 0260*      call en_nav
042EC4 CD EB 2F 04 0261*      call check_collisions
042EC8 C3 0D 2E 04 0262*      jp move_enemies_loop_return
042ECC             0263*  
042ECC             0264*  ; move_enemy_medium:
042ECC             0265*  ;     call en_nav
042ECC             0266*  ;     call check_collisions
042ECC             0267*  ;     jp move_enemies_loop_return
042ECC             0268*  
042ECC             0269*  ; move_enemy_large:
042ECC             0270*  ;     call en_nav
042ECC             0271*  ;     call check_collisions
042ECC             0272*  ;     jp move_enemies_loop_return
042ECC             0273*  
042ECC             0274*  ; move_landing_pad:
042ECC             0275*  ;     call move_active_tiles
042ECC             0276*  ;     call check_collisions
042ECC             0277*  ; ; is it time to launch an enemy?
042ECC             0278*  ;     ld hl,sprite_move_timer
042ECC             0279*  ;     dec (hl)
042ECC             0280*  ;     jp nz,move_enemies_loop_return
042ECC             0281*  ;     call enemy_init_from_landing_pad
042ECC             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
042ECC             0283*  ;     call rand_8     ; snag a random number
042ECC             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042ECC             0285*  ;     add a,64 ; range is now 64-127
042ECC             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042ECC             0287*  ;     jp move_enemies_loop_return
042ECC             0288*  
042ECC             0289*  enemy_init_from_landing_pad:
042ECC             0290*  ; get next available spriteId
042ECC CD A1 16 04 0291*      call table_get_next_id
042ED0 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
042ED1             0293*  ; ix comes back with the pointer to the new sprite variables
042ED1 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
042ED3             0295*  ; a comes back with the spriteId of the new sprite
042ED3 32 29 2F 04 0296*      ld (@id),a
042ED7             0297*  ; initialize the new sprite
042ED7 CD C9 1F 04 0298*      call vdu_sprite_select
042EDB CD DC 1F 04 0299*      call vdu_sprite_clear_frames
042EDF 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
042EE3 06 20       0301*      ld b,32
042EE5             0302*  @load_frames:
042EE5 C5          0303*      push bc
042EE6 E5          0304*      push hl
042EE7 CD 16 21 04 0305*      call vdu_sprite_add_buff
042EEB E1          0306*      pop hl
042EEC 23          0307*      inc hl
042EED C1          0308*      pop bc
042EEE 10 F5       0309*      djnz @load_frames
042EF0             0310*  ; copy coordinates of active sprite to new sprite
042EF0 FD 2A 7A 16 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042EF5             0312*      ; ld hl,(iy+sprite_x)
042EF5             0313*  	; ld hl,0x008000 ; debug
042EF5             0314*  
042EF5 CD 79 23 04 0315*      call rand_8
042EF9 21 00 00 00 0316*      ld hl,0
042EFD 67          0317*      ld h,a
042EFE             0318*  
042EFE 22 34 2F 04 0319*      ld (@x),hl
042F02             0320*      ; ld hl,(iy+sprite_y)
042F02             0321*      ; ld hl,0x002000 ; debug
042F02             0322*  
042F02 CD 79 23 04 0323*      call rand_8
042F06 21 00 00 00 0324*      ld hl,0
042F0A 67          0325*      ld h,a
042F0B             0326*  
042F0B 22 37 2F 04 0327*      ld (@y),hl
042F0F CD 79 23 04 0328*      call rand_8
042F13 E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
042F15 32 4C 2F 04 0330*      ld (@move_step),a
042F19             0331*  ; now copy to the table
042F19 21 29 2F 04 0332*      ld hl,@id ; address to copy from
042F1D D1          0333*      pop de ; address to copy to (was ix)
042F1E 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
042F22 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
042F24             0336*  ; finally, make the new sprite visible
042F24 CD 3F 20 04 0337*      call vdu_sprite_show
042F28 C9          0338*      ret
042F29 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
042F2A 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
042F2B 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
042F2E C0 2E 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
042F31 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
042F32 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
042F33 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
042F34 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
042F37 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042F3A 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042F3D 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042F40 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
042F43 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042F46 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
042F49 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
042F4A 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
042F4B 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
042F4C 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
042F4D 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
042F4E 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
042F4F             0359*  
042F4F             0360*  ; move_laser_turret:
042F4F             0361*  ; ; compute orientation to player
042F4F             0362*  ;     call orientation_to_player
042F4F             0363*  ; ; h.l 8.8 fixed angle256 to player
042F4F             0364*  ; ; bc and de as signed 16-bit integers
042F4F             0365*  ; ; representing delta-x/y *to* target respectively
042F4F             0366*  ;     ld (Bearing_t),hl
042F4F             0367*  ;     ld hl,0x0400
042F4F             0368*  ;     ld (Vp),hl
042F4F             0369*  ;     call targeting_computer
042F4F             0370*  ;     ld (sprite_heading),hl ; store bearing to player
042F4F             0371*  ; ; is it time to launch a fireball?
042F4F             0372*  ;     ld hl,sprite_move_timer
042F4F             0373*  ;     dec (hl)
042F4F             0374*  ;     jp nz,move_laser_turret_boilerplate
042F4F             0375*  ;     call fireballs_init
042F4F             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
042F4F             0377*  ;     call rand_8     ; snag a random number
042F4F             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042F4F             0379*  ;     add a,64 ; range is now 64-127
042F4F             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042F4F             0381*  ; move_laser_turret_boilerplate:
042F4F             0382*  ;     call move_active_tiles
042F4F             0383*  ;     call check_collisions
042F4F             0384*  ;     jp move_enemies_loop_return
042F4F             0385*  
042F4F             0386*  ; fireballs_init:
042F4F             0387*  ;     call sprite_variables_to_stack
042F4F             0388*  
042F4F             0389*  ;     ld hl,fireballs
042F4F             0390*  ;     ld (sprite_base_bufferId),hl
042F4F             0391*  
042F4F             0392*  ;     ld hl,move_fireballs
042F4F             0393*  ;     ld (sprite_move_program),hl
042F4F             0394*  
042F4F             0395*  ;     ld a,%11 ; collides with laser and player
042F4F             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
042F4F             0397*  ;     ld (iy+sprite_collisions),a
042F4F             0398*  
042F4F             0399*  ;     ld hl,(Vp)
042F4F             0400*  ;     ld (sprite_vel),hl
042F4F             0401*  ;     ld hl,(Vp_x)
042F4F             0402*  ;     ld (sprite_xvel),hl
042F4F             0403*  ;     ld hl,(Vp_y)
042F4F             0404*  ;     inc h ; account for ground movement
042F4F             0405*  ;     ld (sprite_yvel),hl
042F4F             0406*  
042F4F             0407*  ;     xor a ; zero a
042F4F             0408*  ;     ld (sprite_animation),a
042F4F             0409*  ;     ld (sprite_move_step),a
042F4F             0410*  ;     ld (sprite_move_timer),a
042F4F             0411*  
042F4F             0412*  ;     ld a,6 ; 1/10th of a second timer
042F4F             0413*  ;     ld (sprite_animation_timer),a
042F4F             0414*  
042F4F             0415*  ;     ld a,0x00 ; BCD
042F4F             0416*  ;     ld (sprite_points),a
042F4F             0417*  ;     ld a,1 ; binary
042F4F             0418*  ;     ld (sprite_shield_damage),a
042F4F             0419*  
042F4F             0420*  ;     call table_add_record ; plops that on the sprite stack for later
042F4F             0421*  ;     call sprite_variables_from_stack ; come back to where we started
042F4F             0422*  ;     ret
042F4F             0423*  
042F4F             0424*  ; move_fireballs:
042F4F             0425*  ;     call move_enemy_sprite ; move sprite
042F4F             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
042F4F             0427*  ;     and a ; if zero we're still within screen bounds
042F4F             0428*  ;     jr z,move_fireballs_alive
042F4F             0429*  ; ; otherwise kill sprite
042F4F             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
042F4F             0431*  ;     ld (iy+sprite_collisions),a
042F4F             0432*  ;     jp move_enemies_loop_return
042F4F             0433*  ; move_fireballs_alive:
042F4F             0434*  ;     ld a,(sprite_animation_timer)
042F4F             0435*  ;     dec a
042F4F             0436*  ;     ld (sprite_animation_timer),a
042F4F             0437*  ;     jr nz,move_fireballs_draw
042F4F             0438*  ;     ld a,(sprite_animation)
042F4F             0439*  ;     xor %1
042F4F             0440*  ;     ld (sprite_animation),a
042F4F             0441*  ;     ld a,6 ; 1/10th of a second timer
042F4F             0442*  ;     ld (sprite_animation_timer),a
042F4F             0443*  ;     ; fall through
042F4F             0444*  
042F4F             0445*  ; move_fireballs_draw:
042F4F             0446*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F4F             0447*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042F4F             0448*  ;     call check_collisions
042F4F             0449*  ;     jp move_enemies_loop_return
042F4F             0450*  
042F4F             0451*  ; compute orientation to player
042F4F             0452*  ; based on relative positions
042F4F             0453*  ; returns: h.l 16.8 fixed angle256 to player
042F4F             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042F4F             0455*  ;    representing delta-x/y *to* target respectively
042F4F             0456*  orientation_to_player:
042F4F FD 2A 7A 16 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F54 FD E5       0458*      push iy ; so we can send it back intact
042F56 FD 07 0B    0459*      ld bc,(iy+sprite_x)
042F59 FD 17 0E    0460*      ld de,(iy+sprite_y)
042F5C DD 2A 02 2C 0461*      ld ix,(player_x)
       04          
042F61 FD 2A 05 2C 0462*      ld iy,(player_y)
       04          
042F66 CD EF 23 04 0463*      call dxy168
042F6A CD 56 24 04 0464*      call atan2_168game
042F6E ED 4B 4A 24 0465*      ld bc,(dx168)
       04          
042F73 ED 5B 50 24 0466*      ld de,(dy168)
       04          
042F78 FD E1       0467*      pop iy ; restore table pointer
042F7A C9          0468*      ret
042F7B             0469*  
042F7B             0470*  
042F7B             0471*  ; targeting_computer scratch variables
042F7B 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
042F7D 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
042F7F 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
042F81 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
042F83 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
042F85 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
042F87 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
042F89 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
042F8B             0480*  
042F8B             0481*  
042F8B             0482*  ; ; Inputs:   see scratch variables
042F8B             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
042F8B             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
042F8B             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
042F8B             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
042F8B             0487*  ; targeting_computer:
042F8B             0488*  ; ; compute target velocity from x,y component velocities
042F8B             0489*  ;     ld bc,(player_xvel)
042F8B             0490*  ;     ld de,(player_yvel)
042F8B             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
042F8B             0492*  
042F8B             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
042F8B             0494*  ;     ld (Heading_t),bc
042F8B             0495*  ;     ld (Vt),de
042F8B             0496*  
042F8B             0497*  ; ; compute Heading_t-Bearing_t
042F8B             0498*  ;     ld h,b
042F8B             0499*  ;     ld l,c
042F8B             0500*  ;     ld bc,(Bearing_t)
042F8B             0501*  ;     and a ; clear carry
042F8B             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
042F8B             0503*  
042F8B             0504*  ; ; compute sin(Heading_t-Bearing_t)
042F8B             0505*  ;     ld b,h
042F8B             0506*  ;     ld c,l
042F8B             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
042F8B             0508*  
042F8B             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
042F8B             0510*  ;     ex de,hl
042F8B             0511*  ;     ld bc,(Vt)
042F8B             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
042F8B             0513*  
042F8B             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
042F8B             0515*  ;     ld b,h
042F8B             0516*  ;     ld c,l
042F8B             0517*  ;     ld de,(Vp)
042F8B             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
042F8B             0519*  ; ; answer is in radians, convert to degrees256
042F8B             0520*  ;     ex de,hl
042F8B             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
042F8B             0522*  ;     call BC_Mul_DE_88
042F8B             0523*  
042F8B             0524*  ; ; add lead angle to target bearing
042F8B             0525*  ;     ld de,(Bearing_t)
042F8B             0526*  ;     add hl,de ; h.l=lead angle+target bearing
042F8B             0527*  ;     push hl
042F8B             0528*  
042F8B             0529*  ; ; compute component projectile velocities
042F8B             0530*  ;     ld b,h
042F8B             0531*  ;     ld c,l
042F8B             0532*  ;     ld de,(Vp)
042F8B             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
042F8B             0534*  
042F8B             0535*  ;     ld (Vp_x),bc
042F8B             0536*  ;     ld (Vp_y),de
042F8B             0537*  ;     pop hl ; h.l=lead angle+target bearing
042F8B             0538*  ;     ret
042F8B             0539*  
042F8B             0540*  ; this routine vanquishes the enemy sprite
042F8B             0541*  ; and replaces it with an animated explosion
042F8B             0542*  ; we jump here instead of call because
042F8B             0543*  ; we want to return to differing locations in the loop
042F8B             0544*  ; depending on whether we're still sploding
042F8B             0545*  ; destroys: everything except index registers
042F8B             0546*  ; returns: an incandescent ball of debris and gas
042F8B             0547*  kill_nurple:
042F8B             0548*  ; ; tally up points
042F8B             0549*  ;     ld bc,0
042F8B             0550*  ;     ld a,(sprite_points)
042F8B             0551*  ;     ld e,a
042F8B             0552*  ;     ld d,0
042F8B             0553*  ;     ld hl,add_bcd_arg2
042F8B             0554*  ;     call set_bcd
042F8B             0555*  ;     ld hl,player_score
042F8B             0556*  ;     ld de,add_bcd_arg2
042F8B             0557*  ;     ld a,3 ; number of bytes to add
042F8B             0558*  ;     call add_bcd
042F8B             0559*  ; ; initialize explosion
042F8B             0560*  ; init_explosion:
042F8B             0561*  ;     ld hl,explosion
042F8B             0562*  ;     ld (sprite_base_bufferId),hl
042F8B             0563*  ;     ld hl,move_explosion
042F8B             0564*  ;     ld (sprite_move_program),hl
042F8B             0565*  ;     ld a,%00000000 ; collides with nothing
042F8B             0566*  ;     ld (iy+sprite_collisions),a
042F8B             0567*  ;     ld hl,0 ; north
042F8B             0568*  ;     ld (sprite_heading),hl
042F8B             0569*  ;     ld a,0x04 ; will decrement to 03
042F8B             0570*  ;     ld (sprite_animation),a
042F8B             0571*  ;     ld a,0x07 ; 7/60th of a second timer
042F8B             0572*  ;     ld (sprite_animation_timer),a
042F8B             0573*  ;     xor a
042F8B             0574*  ;     ld (sprite_move_timer),a
042F8B             0575*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F8B             0576*  ; ; fall through to next_explosion
042F8B             0577*  ; next_explosion:
042F8B             0578*  ;     ld a,(sprite_animation)
042F8B             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
042F8B             0580*  ;     jp m,done_explosion
042F8B             0581*  ;     ld (sprite_animation),a
042F8B             0582*  ;     ld a,0x7 ; 7/60th of a second timer
042F8B             0583*  ;     ld (sprite_animation_timer),a
042F8B             0584*  ; ; fall through to animate_explosion
042F8B             0585*  ; animate_explosion:
042F8B             0586*  ;     ld hl,sprite_y+1
042F8B             0587*  ;     inc (hl) ; move explosion down 1 pixel
042F8B             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
042F8B             0589*  ;     ld hl,sprite_animation_timer
042F8B             0590*  ;     dec (hl) ; if timer is zero,we do next animation
042F8B             0591*  ;     jr z,next_explosion
042F8B             0592*  ;     ;otherwise we fall through to draw the current one
042F8B             0593*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F8B             0594*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042F8B             0595*  ;     ret ; now we go back to caller
042F8B             0596*  ; done_explosion:
042F8B 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
042F8D FD 2A 7A 16 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
042F92 FD 77 08    0599*      ld (iy+sprite_collisions),a
042F95 C9          0600*      ret ; now we go back to caller
042F96             0601*  
042F96             0602*  ; game_over:
042F96             0603*  ;     jp new_game
042F96             0604*  
042F96             0605*  ; it's presumed we've already checked that laser is alive
042F96             0606*  collision_enemy_with_laser:
042F96 DD 2A 23 30 0607*      ld ix,(laser_x)
       04          
042F9B FD 2A 26 30 0608*      ld iy,(laser_y)
       04          
042FA0 3A 21 30 04 0609*      ld a,(laser_dim_x)
042FA4 CB 2F       0610*      sra a ; divide by 2
042FA6 F5          0611*      push af ; we need this later
042FA7             0612*      ; ld de,0
042FA7             0613*      ; ld d,a
042FA7             0614*      ; add ix,de
042FA7             0615*      ; add iy,de
042FA7 18 11       0616*      jr collision_enemy
042FA9             0617*  
042FA9             0618*  ; it's presumed we've already checked that player is alive
042FA9             0619*  collision_enemy_with_player:
042FA9 DD 2A 02 2C 0620*      ld ix,(player_x)
       04          
042FAE FD 2A 05 2C 0621*      ld iy,(player_y)
       04          
042FB3 3A 00 2C 04 0622*      ld a,(player_dim_x)
042FB7             0623*  
042FB7             0624*      ; call dumpRegistersHex
042FB7             0625*  
042FB7 CB 2F       0626*      sra a ; divide by 2
042FB9 F5          0627*      push af ; we need this later
042FBA             0628*      ; ld de,0
042FBA             0629*      ; ld d,a
042FBA             0630*      ; add ix,de
042FBA             0631*      ; add iy,de
042FBA             0632*      ; fall through to collision_enemy
042FBA             0633*  
042FBA             0634*  ; compute the distance between the two sprites' centers
042FBA             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
042FBA             0636*  collision_enemy:
042FBA             0637*  ; back up iy because we need it as the sprite table pointer
042FBA FD E5       0638*      push iy
042FBC FD 2A 7A 16 0639*      ld iy,(table_pointer)
       04          
042FC1 FD 27 0B    0640*      ld hl,(iy+sprite_x)
042FC4 FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
042FC7 CB 2F       0642*      sra a
042FC9 F5          0643*      push af ; we need this later
042FCA             0644*      ; ld de,0
042FCA             0645*      ; ld d,a
042FCA             0646*      ; add hl,de
042FCA E5          0647*      push hl
042FCB C1          0648*      pop bc ; bc = x0
042FCC FD 27 0E    0649*      ld hl,(iy+sprite_y)
042FCF FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
042FD2             0651*      ; sra a
042FD2             0652*      ; ld de,0
042FD2             0653*      ; ld d,a
042FD2             0654*      ; add hl,de
042FD2 EB          0655*      ex de,hl ; de = y0
042FD3 F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
042FD4 FD E1       0657*      pop iy
042FD6 F5          0658*      push af
042FD7             0659*  
042FD7             0660*      ; call dumpRegistersHex
042FD7             0661*  
042FD7 CD 0A 24 04 0662*      call distance168
042FDB             0663*      ; CALL dumpRegistersHex
042FDB             0664*  ; ; subtract sum of radii from distance between centers
042FDB             0665*  ;     ld de,0
042FDB             0666*  ;     pop af ; radius of enemy sprite
042FDB             0667*  ;     ld e,a
042FDB             0668*  ;     pop af ; radius of player or laser sprite
042FDB             0669*  ;     add a,e
042FDB             0670*  ;     ld e,a
042FDB             0671*  ;     and a ; clear carry
042FDB             0672*  ;     sbc hl,de
042FDB             0673*  ;     jr c,collision_enemy_is
042FDB             0674*  ;     xor a
042FDB             0675*  ;     ret
042FDB             0676*  ; temp fix TODO: remove this
042FDB F1          0677*      pop af
042FDC F1          0678*      pop af
042FDD 11 00 10 00 0679*      ld de,16*256
042FE1 A7          0680*      and a
042FE2 ED 52       0681*      sbc hl,de
042FE4 38 02       0682*      jr c,collision_enemy_is
042FE6 AF          0683*      xor a
042FE7             0684*      ; call dumpRegistersHex
042FE7 C9          0685*      ret
042FE8             0686*  collision_enemy_is:
042FE8 AF          0687*      xor a
042FE9 3C          0688*      inc a
042FEA             0689*      ; call dumpRegistersHex
042FEA C9          0690*      ret
042FEB             0691*  
042FEB             0692*  ; ; looks up what enemy sprite collides with
042FEB             0693*  ; ; detects collisions
042FEB             0694*  ; ; and sets things to sploding accordingly
042FEB             0695*  ; check_collisions:
042FEB             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
042FEB             0697*  ;     and a ; if this is zero,
042FEB             0698*  ;     ret z ; there's nothing to do
042FEB             0699*  ;     and %01 ; do we collide with player?
042FEB             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
042FEB             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
042FEB             0702*  ;     and a ; was there a collision?
042FEB             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
042FEB             0704*  ; ; yes collision with player
042FEB             0705*  ;     ; deduct shield damage
042FEB             0706*  ;     ld hl,sprite_shield_damage
042FEB             0707*  ;     ld a,(player_shields)
042FEB             0708*  ;     sub (hl)
042FEB             0709*  ;     ld (player_shields),a
042FEB             0710*  ; ; if shields >= 0,player survives
042FEB             0711*  ;     jp p,check_collisions_kill_nurple
042FEB             0712*  ; ; otherwise update player status so it will die
042FEB             0713*  ;     ld a,(player_collisions)
042FEB             0714*  ;     or %10 ; sets bit 1,meaning player just died
042FEB             0715*  ;     ld (player_collisions),a
042FEB             0716*  ;     ; fall through
042FEB             0717*  ; check_collisions_kill_nurple:
042FEB             0718*  ; ; kill enemy and replace with explosion
042FEB             0719*  ;     call kill_nurple
042FEB             0720*  ;     ret ; and out
042FEB             0721*  
042FEB             0722*  check_collisions:
042FEB CD A9 2F 04 0723*      call collision_enemy_with_player ; did we hit the player?
042FEF A7          0724*      and a ; was there a collision?
042FF0 C8          0725*      ret z ; if not,we're done
042FF1 CD 8B 2F 04 0726*      call kill_nurple ; otherwise kill enemy
042FF5 C9          0727*      ret
042FF6             0728*  
042FF6             0729*  ; did we hit the laser?
042FF6             0730*  move_enemies_laser:
042FF6 FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
042FF9 E6 02       0732*      and %10 ; do we even collide with laser?
042FFB C8          0733*      ret z ; if not,we're out
042FFC 3A 20 30 04 0734*      ld a,(laser_collisions) ; is laser alive?
043000 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
043002 C8          0736*      ret z ; so we're out
043003 CD 96 2F 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
043007 A7          0738*      and a ; was there a collision?
043008 C8          0739*      ret z ; if not,we're done
043009             0740*  ; otherwise we mark laser for termination and kill enemy
043009             0741*  ; update laser status so it will die
043009 3A 20 30 04 0742*      ld a,(laser_collisions)
04300D F6 02       0743*      or %10 ; bit 1 set means laser just died
04300F 32 20 30 04 0744*      ld (laser_collisions),a
043013 CD 8B 2F 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
043017 C9          0746*      ret ; we're outta' here
043018             0063   	include "laser.inc"
043018             0001*  ; ##### LASER SPRITE PARAMETERS #####
043018             0002*  ; uses the same offsets from its table base as the main sprite table:
043018             0003*  laser_start_variables: ; label marking beginning of table
043018 05          0004*  laser_id:               db table_max_records+1
043019 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
04301A 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
04301D 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
043020 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
043021 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043022 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043023 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
043026 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043029 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04302C 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04302F 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
043032 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043035 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
043038 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
043039 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
04303A 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
04303B 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
04303C 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
04303D 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
04303E             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
04303E             0025*  
04303E             0026*  ; laser_control:
04303E             0027*  ; ; is laser already active?
04303E             0028*  ;     ld a,(laser_collisions)
04303E             0029*  ;     and %00000001 ; bit zero is lit if laser is active
04303E             0030*  ;     jr nz,laser_move ; move laser if not zero
04303E             0031*  ; ; otherwise check if laser fired
04303E             0032*  ;     in a,(#82) ; keyboard
04303E             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
04303E             0034*  ;     ret z ; go back if laser not fired
04303E             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
04303E             0036*  ; ; set laser status to active (set bit 0)
04303E             0037*  ;     ld a,%1
04303E             0038*  ;     ld (laser_collisions),a
04303E             0039*  ; ; initialize laser position
04303E             0040*  ;     ld a,(player_x+1) ; we only need the integer part
04303E             0041*  ;     ; add a,6 ; horizontal center with player sprite
04303E             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
04303E             0043*  ;     ld a,(player_y+1) ; we only need the integer part
04303E             0044*  ;     add a,-6 ; set laser y a few pixels above player
04303E             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
04303E             0046*  ;     ; fall through to laser_move
04303E             0047*  
04303E             0048*  ; laser_move:
04303E             0049*  ; ; begin setting laser to active sprite
04303E             0050*  ;     ld hl,lasers
04303E             0051*  ;     ld (sprite_base_bufferId),hl
04303E             0052*  ;     ld hl,0 ; north
04303E             0053*  ;     ld (sprite_heading),hl
04303E             0054*  ;     xor a ; laser has no animations yet :-(
04303E             0055*  ;     ld (sprite_animation),a
04303E             0056*  ;     ; we set position here for the time being as a default
04303E             0057*  ;     ; in case the laser is flagged for deletion
04303E             0058*  ;     ; load sprite_x with laser x position (we do y further down)
04303E             0059*  ;     ld hl,(laser_x)
04303E             0060*  ;     ld (sprite_x),hl
04303E             0061*  ; ; did laser just die?
04303E             0062*  ;     ld a,(laser_collisions)
04303E             0063*  ;     bit 1,a ; z if laser didn't just die
04303E             0064*  ;     jr z,laser_not_dead_yet
04303E             0065*  ; ; yes laser died
04303E             0066*  ;     call kill_laser
04303E             0067*  ;     ret ; done
04303E             0068*  ; laser_not_dead_yet:
04303E             0069*  ; ; draw it
04303E             0070*  ; ; update laser y position
04303E             0071*  ;     ld hl,(laser_y) ; grab laser y position
04303E             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
04303E             0073*  ;     add hl,de ; add y velocity to y pos
04303E             0074*  ;     ld (sprite_y),hl ; update laser y position
04303E             0075*  ;     ld (laser_y),hl ; update laser y position
04303E             0076*  ; ; are we at top of screen?
04303E             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
04303E             0078*  ;     sub h ; no carry if above threshold
04303E             0079*  ;     jr c,finally_draw_the_frikken_laser
04303E             0080*  ;     ; if at top of screen,laser dies
04303E             0081*  ;     call kill_laser
04303E             0082*  ;     ret
04303E             0083*  ; ; otherwise,finally draw the frikken laser
04303E             0084*  ; finally_draw_the_frikken_laser:
04303E             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04303E             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04303E             0087*  ; ; all done
04303E             0088*  ;     ret
04303E             0089*  
04303E             0090*  ; kill_laser:
04303E             0091*  ; ; update status to inactive
04303E             0092*  ;     xor a ; zero out a
04303E             0093*  ;     ld (laser_collisions),a
04303E             0094*  ;     ret
04303E             0064   	include "timer.inc"
04303E             0001*  ; Table 32. Timer Control Registers
04303E             0002*  ; this constant is the base address of the timer control registers
04303E             0003*  ; each timer takes three bytes:
04303E             0004*  ;   0: control register
04303E             0005*  ;   1: low byte of timer reset value
04303E             0006*  ;   2: high byte of timer reset value
04303E             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
04303E             0008*  ; which correctly force the high and upper bytes of the address bus to zero
04303E             0009*  TMR_CTL:     equ 80h
04303E             0010*  
04303E             0011*  ; Timer Control Register Bit Definitions
04303E             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
04303E             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
04303E             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
04303E             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
04303E             0016*                              ; the TMRx_CTL register is read.
04303E             0017*  
04303E             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
04303E             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
04303E             0020*  
04303E             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
04303E             0022*                              ;  0,and counting stops when the end-of-count value is reached.
04303E             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
04303E             0024*                              ; written to the counter when the end-of-count value is reached.
04303E             0025*  
04303E             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
04303E             0027*  CLK_DIV_256:  equ %00001100 ;
04303E             0028*  CLK_DIV_64:   equ %00001000 ;
04303E             0029*  CLK_DIV_16:   equ %00000100 ;
04303E             0030*  CLK_DIV_4:    equ %00000000 ;
04303E             0031*  
04303E             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
04303E             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
04303E             0034*                              ; When a 1 is written to this bit,the values in the reload registers
04303E             0035*                              ;  are loaded into the downcounter when the timer restarts. The
04303E             0036*                              ; programmer must ensure that this bit is set to 1 each time
04303E             0037*                              ; SINGLE-PASS mode is used.
04303E             0038*  
04303E             0039*  ; disable/enable the programmable reload timer
04303E             0040*  PRT_EN_0:     equ %00000000 ;
04303E             0041*  PRT_EN_1:     equ %00000001 ;
04303E             0042*  
04303E             0043*  ; Table 37. Timer Input Source Select Register
04303E             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
04303E             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
04303E             0046*  ;   00: System clock / CLK_DIV
04303E             0047*  ;   01: RTC / CLK_DIV
04303E             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
04303E             0049*  ;   10: GPIO port B pin 1.
04303E             0050*  ;   11: GPIO port B pin 1.
04303E             0051*  TMR_ISS:   equ 92h ; register address
04303E             0052*  
04303E             0053*  ; Table 51. Real-Time Clock Control Register
04303E             0054*  RTC_CTRL: equ EDh ; register address
04303E             0055*  
04303E             0056*  ; alarm interrupt disable/enable
04303E             0057*  RTC_ALARM_0:    equ %00000000
04303E             0058*  RTC_ALARM_1:    equ %10000000
04303E             0059*  
04303E             0060*  ; interrupt on alarm disable/enable
04303E             0061*  RTC_INT_ENT_0:  equ %00000000
04303E             0062*  RTC_INT_ENT_1:  equ %01000000
04303E             0063*  
04303E             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
04303E             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
04303E             0066*  
04303E             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
04303E             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
04303E             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
04303E             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
04303E             0071*  
04303E             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
04303E             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
04303E             0074*  
04303E             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
04303E             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
04303E             0077*  
04303E             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
04303E             0079*                                  ; RTC counter is enabled.
04303E             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
04303E             0081*                                  ; RTC counter is disabled.
04303E             0082*  
04303E             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
04303E             0084*  
04303E             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
04303E             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
04303E 00 00 00    0087*  prt_reload: dl 0x000000
043041             0088*  
043041             0089*  ; set PRT timer
043041             0090*  prt_set:
043041 21 00 00 00 0091*      ld hl,0
043045 22 8F 30 04 0092*      ld (prt_irq_counter),hl
043049 2A 3E 30 04 0093*      ld hl,(prt_reload)
04304D ED 29 84    0094*      out0 ($84),l
043050 ED 21 85    0095*  	out0 ($85),h
043053             0096*  ; disable timer
043053 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043055 ED 39 83    0098*  	out0 ($83),a
043058             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043058 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04305A ED 39 83    0101*  	out0 ($83),a
04305D C9          0102*      ret
04305E             0103*  
04305E             0104*  ; ===============================================
04305E             0105*  ; PRT Timer Interrupt Handling
04305E             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
04305E             0107*  ; -----------------------------------------------
04305E             0108*  prt_irq_init:
04305E             0109*      ; set up interrupt vector table 2
04305E 21 00 00 00 0110*  	ld hl,0
043062 3A 0C 01 00 0111*  	ld a,($10c)
043066 6F          0112*  	ld l,a
043067 3A 0D 01 00 0113*  	ld a,($10d)
04306B 67          0114*  	ld h,a
04306C             0115*  
04306C             0116*  	; skip over CALL ($c3)
04306C 23          0117*  	inc hl
04306D             0118*  	; load address of jump into vector table 2 (in ram)
04306D ED 27       0119*  	ld hl,(hl)
04306F             0120*  
04306F             0121*  	; write CALL prt_irq_handler to vector table 2
04306F 3E C3       0122*  	ld a,$c3
043071 77          0123*  	ld (hl),a
043072 23          0124*  	inc hl
043073 11 7A 30 04 0125*  	ld de,prt_irq_handler
043077 ED 1F       0126*  	ld (hl),de
043079             0127*  
043079 C9          0128*      ret
04307A             0129*  
04307A             0130*  prt_irq_handler:
04307A F3          0131*  	di
04307B F5          0132*  	push af
04307C E5          0133*      push hl
04307D ED 38 83    0134*  	in0 a,($83)
043080 2A 8F 30 04 0135*  	ld hl,(prt_irq_counter)
043084 23          0136*  	inc hl
043085 22 8F 30 04 0137*  	ld (prt_irq_counter),hl
043089 E1          0138*      pop hl
04308A F1          0139*  	pop af
04308B FB          0140*  	ei
04308C 5B ED 4D    0141*  	reti.l
04308F             0142*  
04308F             0143*  prt_irq_counter:
04308F 00 00 00    0144*  	.dl 0
043092             0145*  prt_irq_counter_saved:
043092 00 00 00    0146*      .dl 0
043095             0147*  
043095             0148*  prt_loop_reset:
043095 E5          0149*      push hl
043096 21 00 00 00 0150*  	ld hl,0
04309A 22 8F 30 04 0151*  	ld (prt_irq_counter),hl
04309E 22 00 31 04 0152*      ld (prt_loop_counter),hl
0430A2 22 03 31 04 0153*      ld (prt_loops),hl
0430A6 CD 41 30 04 0154*      call prt_set
0430AA E1          0155*      pop hl
0430AB C9          0156*      ret
0430AC             0157*  
0430AC             0158*  prt_loop_start:
0430AC E5          0159*      push hl
0430AD 21 00 00 00 0160*  	ld hl,0
0430B1 22 8F 30 04 0161*  	ld (prt_irq_counter),hl
0430B5 E1          0162*      pop hl
0430B6 C9          0163*      ret
0430B7             0164*  
0430B7             0165*  prt_loop_stop:
0430B7 E5          0166*      push hl
0430B8 D5          0167*      push de
0430B9 2A 8F 30 04 0168*      ld hl,(prt_irq_counter)
0430BD ED 5B 00 31 0169*      ld de,(prt_loop_counter)
       04          
0430C2 19          0170*      add hl,de
0430C3 22 00 31 04 0171*      ld (prt_loop_counter),hl
0430C7 21 00 00 00 0172*      ld hl,0
0430CB 22 8F 30 04 0173*      ld (prt_irq_counter),hl
0430CF 2A 03 31 04 0174*      ld hl,(prt_loops)
0430D3 23          0175*      inc hl
0430D4 22 03 31 04 0176*      ld (prt_loops),hl
0430D8 D1          0177*      pop de
0430D9 E1          0178*      pop hl
0430DA C9          0179*      ret
0430DB             0180*  
0430DB             0181*  ; inputs: bc = y,x text coordinates to print
0430DB             0182*  prt_loop_print:
0430DB F5          0183*      push af
0430DC E5          0184*      push hl
0430DD C5          0185*      push bc
0430DE D5          0186*      push de
0430DF DD E5       0187*      push ix
0430E1 FD E5       0188*      push iy
0430E3 CD 5E 1B 04 0189*      call vdu_move_cursor
0430E7             0190*  
0430E7 2A 00 31 04 0191*      ld hl,(prt_loop_counter)
0430EB CD 7C 17 04 0192*      call printDec
0430EF             0193*  
0430EF 2A 03 31 04 0194*      ld hl,(prt_loops)
0430F3 CD 7C 17 04 0195*      call printDec
0430F7             0196*  
0430F7 FD E1       0197*      pop iy
0430F9 DD E1       0198*      pop ix
0430FB D1          0199*      pop de
0430FC C1          0200*      pop bc
0430FD E1          0201*      pop hl
0430FE F1          0202*      pop af
0430FF C9          0203*      ret
043100             0204*  
043100             0205*  prt_loop_counter:
043100 00 00 00    0206*      .dl 0
043103             0207*  prt_loops:
043103 00 00 00    0208*      .dl 0
043106             0209*  
043106             0210*  ; ===============================================
043106             0211*  ; Timer functions
043106             0212*  ; -----------------------------------------------
043106             0213*  ; set a countdown timer
043106             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043106             0215*  ; returns: hl = current time
043106             0216*  tmr_set:
043106 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
043109             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
043109 3E 08       0001*M 			LD	A, function
04310B 5B CF       0002*M 			RST.LIL	08h
04310D DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043110 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
043113 C9          0221*      ret
043114             0222*  
043114             0223*  ; gets time remaining on a countdown timer
043114             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043114             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043114             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
043114             0227*  tmr_get:
043114             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
043114 3E 08       0001*M 			LD	A, function
043116 5B CF       0002*M 			RST.LIL	08h
043118 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
04311B FD 27 00    0230*      ld hl,(iy+0)            ; get start time
04311E AF          0231*      xor a                   ; clear carry
04311F ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043121 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
043124 AF          0234*      xor a                   ; clear carry
043125 ED 5A       0235*      adc hl,de               ; hl = time remaining
043127             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043127 C9          0237*      ret
043128             0238*  
043128             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
04312E             0240*  
04312E 00 00 00    0241*  timestamp_now: dl 0
043131 00 00 00    0242*  timestamp_old: dl 0
043134 00 00 00    0243*  timestamp_chg: dl 0
043137             0244*  
043137             0245*  ; update the global timestamp from the system clock
043137             0246*  ; inputs: none
043137             0247*  ; returns: hl = time elapsed in 1/120ths of a second
043137             0248*  ;          de = current time
043137             0249*  ;          ix = pointer to syvars table
043137             0250*  ; destroys: af,hl,de,ix
043137             0251*  timestamp_tick:
043137 ED 5B 2E 31 0252*      ld de,(timestamp_now)   ; get previous time
       04          
04313C ED 53 31 31 0253*      ld (timestamp_old),de   ; save previous time
       04          
043141             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
043141 3E 08       0001*M 			LD	A, function
043143 5B CF       0002*M 			RST.LIL	08h
043145 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
043148 22 2E 31 04 0256*      ld (timestamp_now),hl   ; save current time
04314C AF          0257*      xor a                   ; clear carry
04314D ED 52       0258*      sbc hl,de               ; hl = time elapsed
04314F 22 34 31 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
043153 C9          0260*      ret
043154             0261*  
043154             0262*  ; set a countdown timer
043154             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043154             0264*  ; requires: timestamp_tick to be called at least once before this function
043154             0265*  ; returns: hl = current time
043154             0266*  ; destroys: hl
043154             0267*  timestamp_tmr_set:
043154 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043157 2A 2E 31 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
04315B FD 2F 00    0270*      ld (iy+0),hl            ; set start time
04315E C9          0271*      ret
04315F             0272*  
04315F             0273*  ; gets time remaining on a countdown timer following the global timestamp
04315F             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04315F             0275*  ; requires: timestamp_tick to be called at least once before this function
04315F             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04315F             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
04315F             0278*  ; destroys: af,hl,de
04315F             0279*  timestamp_tmr_get:
04315F ED 5B 2E 31 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043164 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043167 AF          0282*      xor a                   ; clear carry
043168 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04316A FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
04316D AF          0285*      xor a                   ; clear carry
04316E ED 5A       0286*      adc hl,de               ; hl = time remaining
043170             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043170 C9          0288*      ret
043171             0289*  
043171             0290*  ; set a stopwatch
043171             0291*  ; returns: hl = start time
043171             0292*  ; destroys: hl,ix
043171             0293*  stopwatch_set:
043171             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043171 3E 08       0001*M 			LD	A, function
043173 5B CF       0002*M 			RST.LIL	08h
043175 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043178 22 8D 31 04 0296*      ld (stopwatch_started),hl            ; set start time
04317C C9          0297*      ret
04317D             0298*  
04317D             0299*  ; gets time elapsed on a stopwatch
04317D             0300*  ; returns: hl = time elapsed in 1/120ths of a second
04317D             0301*  ; destroys: af,hl,de,ix
04317D             0302*  stopwatch_get:
04317D             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
04317D 3E 08       0001*M 			LD	A, function
04317F 5B CF       0002*M 			RST.LIL	08h
043181 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043184 ED 5B 8D 31 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043189 AF          0306*      xor a                   ; clear carry
04318A ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04318C C9          0308*      ret
04318D             0309*  
04318D             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043190             0311*  
043190             0312*  ; ------------------
043190             0313*  ; delay routine
043190             0314*  ; Author: Richard Turrnidge
043190             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043190             0316*  ; routine waits a fixed time,then returns
043190             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043190             0318*  ; eg. ld A,00000100b
043190             0319*  
043190             0320*  multiPurposeDelay:
043190 F5          0321*      push af
043191 C5          0322*      push bc
043192 DD E5       0323*      push ix
043194 47          0324*      ld b,a
043195 3E 08       0325*      ld a,$08
043197 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043199             0327*  
043199             0328*  waitLoop:
043199             0329*  
043199 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04319C             0331*  
04319C             0332*                                  ;   we check if bit set is same as last time we checked.
04319C             0333*                                  ;   bit 0 - don't use
04319C             0334*                                  ;   bit 1 - changes 64 times per second
04319C             0335*                                  ;   bit 2 - changes 32 times per second
04319C             0336*                                  ;   bit 3 - changes 16 times per second
04319C             0337*  
04319C             0338*                                  ;   bit 4 - changes 8 times per second
04319C             0339*                                  ;   bit 5 - changes 4 times per second
04319C             0340*                                  ;   bit 6 - changes 2 times per second
04319C             0341*                                  ;   bit 7 - changes 1 times per second
04319C A0          0342*      and b
04319D 4F          0343*      ld c,a
04319E 3A AF 31 04 0344*      ld a,(oldTimeStamp)
0431A2 B9          0345*      cp c                        ; is A same as last value?
0431A3 28 F4       0346*      jr z,waitLoop              ; loop here if it is
0431A5 79          0347*      ld a,c
0431A6 32 AF 31 04 0348*      ld (oldTimeStamp),a        ; set new value
0431AA             0349*  
0431AA DD E1       0350*      pop ix
0431AC C1          0351*      pop bc
0431AD F1          0352*      pop af
0431AE C9          0353*      ret
0431AF             0354*  
0431AF 00          0355*  oldTimeStamp:   .db 00h
0431B0             0065   
0431B0             0066   ; new includes
0431B0             0067   	include "images.inc"
0431B0             0001*  image_type: equ 0
0431B0             0002*  image_width: equ image_type+3
0431B0             0003*  image_height: equ image_width+3
0431B0             0004*  image_filesize: equ image_height+3
0431B0             0005*  image_filename: equ image_filesize+3
0431B0             0006*  image_bufferId: equ image_filename+3
0431B0             0007*  image_record_size: equ image_bufferId+3
0431B0             0008*  
0431B0 00 00 00    0009*  cur_image_list: dl 0
0431B3 00 00 00    0010*  cur_file_idx: dl 0
0431B6 00 00 00    0011*  cur_filename: dl 0
0431B9 00 00 00    0012*  cur_buffer_id: dl 0
0431BC             0013*  
0431BC             0014*  load_ui_images:
0431BC             0015*  ; initialize image loading variables
0431BC 21 00 00 00 0016*  	ld hl,0
0431C0 22 B3 31 04 0017*  	ld (cur_file_idx),hl
0431C4 21 9E 41 04 0018*  	ld hl,ui_image_list
0431C8 22 B0 31 04 0019*  	ld (cur_image_list),hl
0431CC             0020*  ; load images
0431CC 06 02       0021*  	ld b,ui_num_images
0431CE             0022*  @loop:
0431CE C5          0023*  	push bc
0431CF CD 31 32 04 0024*  	call load_next_image
0431D3 C1          0025*  	pop bc
0431D4 10 F8       0026*  	djnz @loop
0431D6 C9          0027*  	ret
0431D7             0028*  
0431D7             0029*  load_sprite_images:
0431D7             0030*  ; initialize image loading variables
0431D7 21 00 00 00 0031*  	ld hl,0
0431DB 22 B3 31 04 0032*  	ld (cur_file_idx),hl
0431DF 21 C2 32 04 0033*  	ld hl,sprites_image_list
0431E3 22 B0 31 04 0034*  	ld (cur_image_list),hl
0431E7 01 59 00 00 0035*  	ld bc,sprites_num_images
0431EB             0036*  ; load images
0431EB CD F0 31 04 0037*  	call img_load_main
0431EF C9          0038*  	ret
0431F0             0039*  
0431F0             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0431F0             0041*  img_load_main:
0431F0 AF          0042*  	xor a
0431F1 32 B3 31 04 0043*      ld (cur_file_idx),a
0431F5             0044*  
0431F5             0045*  img_load_main_loop:
0431F5             0046*  ; back up loop counter
0431F5 C5          0047*      push bc
0431F6             0048*  
0431F6             0049*  ; load the next image
0431F6 CD 31 32 04 0050*      call load_next_image
0431FA             0051*  
0431FA             0052*  ; plot the background
0431FA CD 72 1B 04 0053*  	call vdu_cls
0431FE 21 00 00 00 0054*      ld hl,BUF_SPLASH_BG
043202 CD 5F 1C 04 0055*      call vdu_buff_select
043206 01 00 00 00 0056*      ld bc,0
04320A 11 00 00 00 0057*      ld de,0
04320E CD 28 1F 04 0058*      call vdu_plot_bmp
043212             0059*  
043212             0060*  ; ; draw the most recently loaded image
043212             0061*  ; 	ld hl,(cur_buffer_id)
043212             0062*  ; 	call vdu_buff_select
043212             0063*  ; 	ld bc,0
043212             0064*  ; 	ld de,0
043212             0065*  ; 	call vdu_plot_bmp
043212             0066*  
043212             0067*  ; move logo
043212 CD 91 32 04 0068*  	call move_logo
043216             0069*  
043216             0070*  ; print current filename
043216 2A B6 31 04 0071*  	ld hl,(cur_filename)
04321A CD 2E 17 04 0072*  	call printString
04321E             0073*  
04321E             0074*  ; flip the framebuffer
04321E CD 77 1B 04 0075*  	call vdu_flip
043222             0076*  
043222             0077*  ; decrement loop counter
043222 C1          0078*      pop bc
043223 0B          0079*  	dec bc
043224 79          0080*      ld a,c
043225 B7          0081*      or a
043226 C2 F5 31 04 0082*      jp nz,img_load_main_loop
04322A 78          0083*      ld a,b
04322B B7          0084*      or a
04322C C2 F5 31 04 0085*      jp nz,img_load_main_loop
043230 C9          0086*      ret
043231             0087*  
043231             0088*  load_next_image:
043231 16 12       0089*      ld d,image_record_size
043233 3A B3 31 04 0090*  	ld a,(cur_file_idx)
043237 5F          0091*  	ld e,a
043238 ED 5C       0092*      mlt de
04323A FD 2A B0 31 0093*      ld iy,(cur_image_list)
       04          
04323F FD 19       0094*      add iy,de
043241             0095*  
043241 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
043244 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
043247 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
04324A FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
04324D FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
043250 22 B9 31 04 0101*  	ld (cur_buffer_id),hl
043254 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
043257 FD 22 B6 31 0103*  	ld (cur_filename),iy
       04          
04325C CD 7D 1D 04 0104*      call vdu_load_img
043260 FD 21 B3 31 0105*      ld iy,cur_file_idx
       04          
043265 FD 34 00    0106*  	inc (iy)
043268 C9          0107*  	ret
043269             0108*  
043269             0109*  img_load_init:
043269             0110*  ; initialize logo's position parameters
043269 21 00 00 00 0111*  	ld hl,0
04326D 22 B6 32 04 0112*  	ld (logo_xvel),hl
043271 22 B9 32 04 0113*  	ld (logo_xpos),hl
043275             0114*  ; begin 16.8 maths to determine logo's y position and velocity
043275 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
043279 22 BF 32 04 0116*  	ld (logo_ypos),hl
04327D EB          0117*  	ex de,hl
04327E 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
043282 19          0119*  	add hl,de ; distance for logo to travel
043283 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
043287 CD 2B 21 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
04328B ED 53 BC 32 0122*  	ld (logo_yvel),de
       04          
043290             0123*  ; all done
043290 C9          0124*      ret
043291             0125*  
043291             0126*  move_logo:
043291             0127*  ; activate logo bitmap
043291 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
043295 CD 5F 1C 04 0129*  	call vdu_buff_select
043299             0130*  ; update position based on velocity parameters
043299 2A BF 32 04 0131*  	ld hl,(logo_ypos)
04329D ED 5B BC 32 0132*  	ld de,(logo_yvel)
       04          
0432A2 19          0133*  	add hl,de
0432A3 22 BF 32 04 0134*  	ld (logo_ypos),hl
0432A7             0135*  ; draw logo
0432A7 ED 4B B9 32 0136*  	ld bc,(logo_xpos)
       04          
0432AC ED 5B BF 32 0137*  	ld de,(logo_ypos)
       04          
0432B1 CD 44 1F 04 0138*  	call vdu_plot_bmp168
0432B5 C9          0139*  	ret
0432B6             0140*  
0432B6 00 00 00    0141*  logo_xvel: dl 0
0432B9 00 00 00    0142*  logo_xpos: dl 0
0432BC             0143*  
0432BC 00 00 00    0144*  logo_yvel: dl 0
0432BF 00 00 00    0145*  logo_ypos: dl 0
0432C2             0068   	include "images_sprites.inc"
0432C2             0001*  ; Generated by make_images.py
0432C2             0002*  
0432C2             0003*  sprites_num_images: equ 89
0432C2             0004*  
0432C2             0005*  ; buffer_ids:
0432C2             0006*  BUF_0TILE_EMPTY: equ 256
0432C2             0007*  BUF_1TILE_CROSS: equ 257
0432C2             0008*  BUF_2TILE_HORIZ: equ 258
0432C2             0009*  BUF_3TILE_VERT: equ 259
0432C2             0010*  BUF_4TILE_SQUARE: equ 260
0432C2             0011*  BUF_5TILE_CIRCLE: equ 261
0432C2             0012*  BUF_6TILE_PAD: equ 262
0432C2             0013*  BUF_7TILE_TURRET: equ 263
0432C2             0014*  BUF_CIRCLE: equ 264
0432C2             0015*  BUF_CRATER: equ 265
0432C2             0016*  BUF_EXPLOSION_A: equ 266
0432C2             0017*  BUF_EXPLOSION_B: equ 267
0432C2             0018*  BUF_EXPLOSION_C: equ 268
0432C2             0019*  BUF_EXPLOSION_D: equ 269
0432C2             0020*  BUF_EXPLOSION_E: equ 270
0432C2             0021*  BUF_FIREBALL_A: equ 271
0432C2             0022*  BUF_FIREBALL_B: equ 272
0432C2             0023*  BUF_LASER_A: equ 273
0432C2             0024*  BUF_LASER_B: equ 274
0432C2             0025*  BUF_PAD: equ 275
0432C2             0026*  BUF_SEEKER_000: equ 276
0432C2             0027*  BUF_SEEKER_008: equ 277
0432C2             0028*  BUF_SEEKER_016: equ 278
0432C2             0029*  BUF_SEEKER_024: equ 279
0432C2             0030*  BUF_SEEKER_032: equ 280
0432C2             0031*  BUF_SEEKER_040: equ 281
0432C2             0032*  BUF_SEEKER_048: equ 282
0432C2             0033*  BUF_SEEKER_056: equ 283
0432C2             0034*  BUF_SEEKER_064: equ 284
0432C2             0035*  BUF_SEEKER_072: equ 285
0432C2             0036*  BUF_SEEKER_080: equ 286
0432C2             0037*  BUF_SEEKER_088: equ 287
0432C2             0038*  BUF_SEEKER_096: equ 288
0432C2             0039*  BUF_SEEKER_104: equ 289
0432C2             0040*  BUF_SEEKER_112: equ 290
0432C2             0041*  BUF_SEEKER_120: equ 291
0432C2             0042*  BUF_SEEKER_128: equ 292
0432C2             0043*  BUF_SEEKER_136: equ 293
0432C2             0044*  BUF_SEEKER_144: equ 294
0432C2             0045*  BUF_SEEKER_152: equ 295
0432C2             0046*  BUF_SEEKER_160: equ 296
0432C2             0047*  BUF_SEEKER_168: equ 297
0432C2             0048*  BUF_SEEKER_176: equ 298
0432C2             0049*  BUF_SEEKER_184: equ 299
0432C2             0050*  BUF_SEEKER_192: equ 300
0432C2             0051*  BUF_SEEKER_200: equ 301
0432C2             0052*  BUF_SEEKER_208: equ 302
0432C2             0053*  BUF_SEEKER_216: equ 303
0432C2             0054*  BUF_SEEKER_224: equ 304
0432C2             0055*  BUF_SEEKER_232: equ 305
0432C2             0056*  BUF_SEEKER_240: equ 306
0432C2             0057*  BUF_SEEKER_248: equ 307
0432C2             0058*  BUF_SHIP_0L: equ 308
0432C2             0059*  BUF_SHIP_1C: equ 309
0432C2             0060*  BUF_SHIP_2R: equ 310
0432C2             0061*  BUF_SHIP_SMALL: equ 311
0432C2             0062*  BUF_STAR: equ 312
0432C2             0063*  BUF_TURRET_000: equ 313
0432C2             0064*  BUF_TURRET_008: equ 314
0432C2             0065*  BUF_TURRET_016: equ 315
0432C2             0066*  BUF_TURRET_024: equ 316
0432C2             0067*  BUF_TURRET_032: equ 317
0432C2             0068*  BUF_TURRET_040: equ 318
0432C2             0069*  BUF_TURRET_048: equ 319
0432C2             0070*  BUF_TURRET_056: equ 320
0432C2             0071*  BUF_TURRET_064: equ 321
0432C2             0072*  BUF_TURRET_072: equ 322
0432C2             0073*  BUF_TURRET_080: equ 323
0432C2             0074*  BUF_TURRET_088: equ 324
0432C2             0075*  BUF_TURRET_096: equ 325
0432C2             0076*  BUF_TURRET_104: equ 326
0432C2             0077*  BUF_TURRET_112: equ 327
0432C2             0078*  BUF_TURRET_120: equ 328
0432C2             0079*  BUF_TURRET_128: equ 329
0432C2             0080*  BUF_TURRET_136: equ 330
0432C2             0081*  BUF_TURRET_144: equ 331
0432C2             0082*  BUF_TURRET_152: equ 332
0432C2             0083*  BUF_TURRET_160: equ 333
0432C2             0084*  BUF_TURRET_168: equ 334
0432C2             0085*  BUF_TURRET_176: equ 335
0432C2             0086*  BUF_TURRET_184: equ 336
0432C2             0087*  BUF_TURRET_192: equ 337
0432C2             0088*  BUF_TURRET_200: equ 338
0432C2             0089*  BUF_TURRET_208: equ 339
0432C2             0090*  BUF_TURRET_216: equ 340
0432C2             0091*  BUF_TURRET_224: equ 341
0432C2             0092*  BUF_TURRET_232: equ 342
0432C2             0093*  BUF_TURRET_240: equ 343
0432C2             0094*  BUF_TURRET_248: equ 344
0432C2             0095*  
0432C2             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
0432C2 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       04 39 04 00 
       01 00       
0432D4 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       1E 39 04 01 
       01 00       
0432E6 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       38 39 04 02 
       01 00       
0432F8 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       52 39 04 03 
       01 00       
04330A 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       6B 39 04 04 
       01 00       
04331C 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       86 39 04 05 
       01 00       
04332E 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       A1 39 04 06 
       01 00       
043340 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       B9 39 04 07 
       01 00       
043352 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       D4 39 04 08 
       01 00       
043364 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       E9 39 04 09 
       01 00       
043376 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       FE 39 04 0A 
       01 00       
043388 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       18 3A 04 0B 
       01 00       
04339A 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       32 3A 04 0C 
       01 00       
0433AC 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       4C 3A 04 0D 
       01 00       
0433BE 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       66 3A 04 0E 
       01 00       
0433D0 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       80 3A 04 0F 
       01 00       
0433E2 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       99 3A 04 10 
       01 00       
0433F4 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       B2 3A 04 11 
       01 00       
043406 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       C8 3A 04 12 
       01 00       
043418 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       DE 3A 04 13 
       01 00       
04342A 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       F0 3A 04 14 
       01 00       
04343C 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       09 3B 04 15 
       01 00       
04344E 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       22 3B 04 16 
       01 00       
043460 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       3B 3B 04 17 
       01 00       
043472 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       54 3B 04 18 
       01 00       
043484 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       6D 3B 04 19 
       01 00       
043496 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       86 3B 04 1A 
       01 00       
0434A8 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       9F 3B 04 1B 
       01 00       
0434BA 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       B8 3B 04 1C 
       01 00       
0434CC 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       D1 3B 04 1D 
       01 00       
0434DE 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       EA 3B 04 1E 
       01 00       
0434F0 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       03 3C 04 1F 
       01 00       
043502 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       1C 3C 04 20 
       01 00       
043514 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       35 3C 04 21 
       01 00       
043526 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       4E 3C 04 22 
       01 00       
043538 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       67 3C 04 23 
       01 00       
04354A 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       80 3C 04 24 
       01 00       
04355C 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       99 3C 04 25 
       01 00       
04356E 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       B2 3C 04 26 
       01 00       
043580 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       CB 3C 04 27 
       01 00       
043592 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       E4 3C 04 28 
       01 00       
0435A4 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       FD 3C 04 29 
       01 00       
0435B6 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       16 3D 04 2A 
       01 00       
0435C8 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       2F 3D 04 2B 
       01 00       
0435DA 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       48 3D 04 2C 
       01 00       
0435EC 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       61 3D 04 2D 
       01 00       
0435FE 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       7A 3D 04 2E 
       01 00       
043610 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       93 3D 04 2F 
       01 00       
043622 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       AC 3D 04 30 
       01 00       
043634 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       C5 3D 04 31 
       01 00       
043646 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       DE 3D 04 32 
       01 00       
043658 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       F7 3D 04 33 
       01 00       
04366A 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       10 3E 04 34 
       01 00       
04367C 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       26 3E 04 35 
       01 00       
04368E 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       3C 3E 04 36 
       01 00       
0436A0 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       52 3E 04 37 
       01 00       
0436B2 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       6B 3E 04 38 
       01 00       
0436C4 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       7E 3E 04 39 
       01 00       
0436D6 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       97 3E 04 3A 
       01 00       
0436E8 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       B0 3E 04 3B 
       01 00       
0436FA 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       C9 3E 04 3C 
       01 00       
04370C 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       E2 3E 04 3D 
       01 00       
04371E 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       FB 3E 04 3E 
       01 00       
043730 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       14 3F 04 3F 
       01 00       
043742 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       2D 3F 04 40 
       01 00       
043754 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       46 3F 04 41 
       01 00       
043766 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       5F 3F 04 42 
       01 00       
043778 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       78 3F 04 43 
       01 00       
04378A 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       91 3F 04 44 
       01 00       
04379C 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       AA 3F 04 45 
       01 00       
0437AE 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       C3 3F 04 46 
       01 00       
0437C0 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       DC 3F 04 47 
       01 00       
0437D2 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       F5 3F 04 48 
       01 00       
0437E4 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       0E 40 04 49 
       01 00       
0437F6 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       27 40 04 4A 
       01 00       
043808 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       40 40 04 4B 
       01 00       
04381A 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       59 40 04 4C 
       01 00       
04382C 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       72 40 04 4D 
       01 00       
04383E 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       8B 40 04 4E 
       01 00       
043850 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       A4 40 04 4F 
       01 00       
043862 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       BD 40 04 50 
       01 00       
043874 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       D6 40 04 51 
       01 00       
043886 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       EF 40 04 52 
       01 00       
043898 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       08 41 04 53 
       01 00       
0438AA 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       21 41 04 54 
       01 00       
0438BC 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       3A 41 04 55 
       01 00       
0438CE 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       53 41 04 56 
       01 00       
0438E0 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       6C 41 04 57 
       01 00       
0438F2 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       85 41 04 58 
       01 00       
043904             0186*  
043904             0187*  ; files_list: ; filename:
043904 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
04391E 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043938 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043952 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
04396B 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043986 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
0439A1 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
0439B9 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
0439D4 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
0439E9 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
0439FE 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043A18 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043A32 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043A4C 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043A66 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043A80 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043A99 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043AB2 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043AC8 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043ADE 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043AF0 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043B09 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043B22 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043B3B 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043B54 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043B6D 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043B86 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043B9F 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043BB8 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043BD1 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043BEA 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043C03 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043C1C 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043C35 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043C4E 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043C67 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043C80 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043C99 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043CB2 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043CCB 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043CE4 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043CFD 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043D16 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043D2F 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043D48 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043D61 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
043D7A 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
043D93 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
043DAC 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
043DC5 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
043DDE 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
043DF7 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
043E10 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
043E26 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
043E3C 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
043E52 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
043E6B 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
043E7E 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043E97 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043EB0 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043EC9 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043EE2 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043EFB 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043F14 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043F2D 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043F46 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043F5F 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043F78 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043F91 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043FAA 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043FC3 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043FDC 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043FF5 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
04400E 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
044027 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
044040 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044059 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
044072 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
04408B 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0440A4 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0440BD 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
0440D6 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0440EF 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
044108 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044121 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
04413A 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
044153 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
04416C 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
044185 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
04419E             0069   	include "images_ui.inc"
04419E             0001*  ; Generated by make_images.py
04419E             0002*  
04419E             0003*  ui_num_images: equ 2
04419E             0004*  
04419E             0005*  ; buffer_ids:
04419E             0006*  BUF_SPLASH_BG: equ 0
04419E             0007*  BUF_SPLASH_LOGO: equ 1
04419E             0008*  
04419E             0009*  ui_image_list: ; type; width; height; filename; bufferId:
04419E 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       C2 41 04 00 
       00 00       
0441B0 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       D5 41 04 01 
       00 00       
0441C2             0012*  
0441C2             0013*  ; files_list: ; filename:
0441C2 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
0441D5 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
0441EA             0070   	include "files.inc"
0441EA             0001*  ; load to onboard 8k sram
0441EA             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0441EA             0071   	; include "fixed24.inc"
0441EA             0072   
0441EA 57 65 6C 63 0073   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
044205 4C 6F 61 64 0074   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044210 4C 6F 61 64 0075   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
04421E 50 72 65 73 0076   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
044239             0077   
044239             0078   init:
044239             0079   ; clear all buffers
044239 CD 51 1D 04 0080       call vdu_clear_all_buffers
04423D             0081   
04423D             0082   ; set up the display
04423D 3E 88       0083       ld a,8+128 ; 136   320   240   64    60hz double-buffered
04423F CD 3B 1C 04 0084       call vdu_set_screen_mode
044243 AF          0085       xor a
044244 CD 4C 1C 04 0086       call vdu_set_scaling
044248             0087   
044248             0088   ; ; enable additional audio channels
044248             0089   ; 	call vdu_enable_channels
044248             0090   
044248             0091   ; set text background color
044248 3E 84       0092   	ld a,4 + 128
04424A CD A3 1B 04 0093   	call vdu_colour_text
04424E             0094   
04424E             0095   ; set text foreground color
04424E 3E 2F       0096   	ld a,47 ; aaaaff lavenderish
044250 CD A3 1B 04 0097   	call vdu_colour_text
044254             0098   
044254             0099   ; set gfx bg color
044254 AF          0100   	xor a ; plotting mode 0
044255 0E 84       0101   	ld c,4+128 ; dark blue bg
044257 CD B4 1B 04 0102   	call vdu_gcol
04425B CD 85 1B 04 0103   	call vdu_clg
04425F             0104   
04425F             0105   ; set the cursor off
04425F CD 3A 1B 04 0106   	call vdu_cursor_off
044263             0107   
044263             0108   ; VDU 28, left, bottom, right, top: Set text viewport **
044263             0109   ; MIND THE LITTLE-ENDIANESS
044263             0110   ; inputs: c=left,b=bottom,e=right,d=top
044263 0E 00       0111   	ld c,0 ; left
044265 16 1D       0112   	ld d,29 ; top
044267 1E 27       0113   	ld e,39 ; right
044269 06 1D       0114   	ld b,29; bottom
04426B CD CB 1B 04 0115   	call vdu_set_txt_viewport
04426F             0116   
04426F             0117   ; print loading ui message
04426F 21 05 42 04 0118   	ld hl,loading_ui
044273 CD 2E 17 04 0119   	call printString
044277 CD 77 1B 04 0120   	call vdu_flip
04427B             0121   
04427B             0122   ; load UI images
04427B CD BC 31 04 0123   	call load_ui_images
04427F             0124   
04427F             0125   ; ; load fonts ; TODO
04427F             0126   ; 	call load_font_rc
04427F             0127   
04427F             0128   ; load sprites
04427F CD 69 32 04 0129   	call img_load_init ; sets up the animated load screen
044283 CD D7 31 04 0130   	call load_sprite_images
044287             0131   
044287             0132   ; ; load sound effects ; TODO
044287             0133   ; 	ld bc,SFX_num_buffers
044287             0134   ; 	ld hl,SFX_buffer_id_lut
044287             0135   ; 	ld (cur_buffer_id_lut),hl
044287             0136   ; 	ld hl,SFX_load_routines_table
044287             0137   ; 	ld (cur_load_jump_table),hl
044287             0138   ; 	call sfx_load_main
044287             0139   
044287             0140   ; print loading complete message and wait for user keypress
044287 CD 72 1B 04 0141   	call vdu_cls
04428B 21 1E 42 04 0142   	ld hl,loading_complete
04428F CD 2E 17 04 0143   	call printString
044293 CD 77 1B 04 0144   	call vdu_flip
044297 CD AA 1A 04 0145   	call waitKeypress
04429B             0146   
04429B             0147   ; set up display for gameplay
04429B 3E 08       0148       ld a,8
04429D CD 3B 1C 04 0149       call vdu_set_screen_mode
0442A1 AF          0150       xor a
0442A2 CD 4C 1C 04 0151       call vdu_set_scaling
0442A6 01 20 00 00 0152   	ld bc,32
0442AA 11 10 00 00 0153   	ld de,16
0442AE CD F7 1B 04 0154   	call vdu_set_gfx_origin
0442B2 CD 3A 1B 04 0155   	call vdu_cursor_off
0442B6             0156   ; set gfx viewport to scrolling window
0442B6 01 00 00 00 0157   	ld bc,0
0442BA 11 00 00 00 0158   	ld de,0
0442BE DD 21 FF 00 0159   	ld ix,255
       00          
0442C3 FD 21 DF 00 0160   	ld iy,239-16
       00          
0442C8 CD 12 1C 04 0161   	call vdu_set_gfx_viewport
0442CC             0162   
0442CC C9          0163   	ret
0442CD             0164   
0442CD             0165   new_game:
0442CD             0166   ; initialize sprites
0442CD CD ED 16 04 0167   	call sprites_init
0442D1             0168   
0442D1             0169   ; initialize the first level
0442D1 AF          0170   	xor a
0442D2 32 F7 2C 04 0171   	ld (cur_level),a
0442D6 CD 7F 2D 04 0172   	call init_level
0442DA             0173   
0442DA             0174   ; initialize player
0442DA CD 1D 2C 04 0175   	call player_init
0442DE             0176   
0442DE             0177   ; spawn an enemy sprite
0442DE 06 04       0178   	ld b,table_max_records
0442E0             0179   @spawn_enemy_loop:
0442E0 C5          0180   	push bc
0442E1 CD CC 2E 04 0181   	call enemy_init_from_landing_pad
0442E5 C1          0182   	pop bc
0442E6 10 F8       0183   	djnz @spawn_enemy_loop
0442E8             0184   
0442E8 C9          0185   	ret
0442E9             0186   
0442E9             0187   ; ; ###### INITIALIZE GAME #######
0442E9             0188   ; ; clear the screen
0442E9             0189   ;     ld a,3
0442E9             0190   ;     out (81h),a
0442E9             0191   
0442E9             0192   ; ; reset the sprite table
0442E9             0193   ;     xor a
0442E9             0194   ;     ld (table_active_sprites),a
0442E9             0195   ;     ld hl,table_limit
0442E9             0196   ;     ld (table_base),hl
0442E9             0197   ;     ld (table_pointer),hl
0442E9             0198   
0442E9             0199   ; ; draw a starfield over the entire screen
0442E9             0200   ;     ld b,#50 ; first row of visible screen
0442E9             0201   ; new_game_draw_stars_loop:
0442E9             0202   ;     push bc
0442E9             0203   ;     call draw_stars
0442E9             0204   ;     pop bc
0442E9             0205   ;     ld a,#10
0442E9             0206   ;     add a,b
0442E9             0207   ;     ld b,a
0442E9             0208   ;     jr nz,new_game_draw_stars_loop
0442E9             0209   
0442E9             0210   ; ; ; print a welcome message
0442E9             0211   ; ;     ld de,msg_welcome
0442E9             0212   ; ;     ld hl,#581C
0442E9             0213   ; ;     ld c,218 ; a bright pastel purple d677e3
0442E9             0214   ; ;     call print_string
0442E9             0215   
0442E9             0216   ; ; push all that to frame buffer
0442E9             0217   ;     ld a,#01 ; send video to frame buffer
0442E9             0218   ;     out (81h),a
0442E9             0219   
0442E9             0220   ; ; reset score, lives, shields
0442E9             0221   ;     xor a
0442E9             0222   ;     ld hl,player_score
0442E9             0223   ;     ld (hl),a ; player_score 0
0442E9             0224   ;     inc hl
0442E9             0225   ;     ld (hl),a ; player_score 1
0442E9             0226   ;     inc hl
0442E9             0227   ;     ld (hl),a ; player_score 3
0442E9             0228   ;     inc hl
0442E9             0229   ;     ld a,16
0442E9             0230   ;     ld (hl),a ; player_shields
0442E9             0231   ;     inc hl
0442E9             0232   ;     ld (hl),a ; player_max_shields
0442E9             0233   ;     inc hl
0442E9             0234   ;     ld a,3
0442E9             0235   ;     ld (hl),a ; player_ships
0442E9             0236   ;     inc hl
0442E9             0237   
0442E9             0238   ; ; initialize first level
0442E9             0239   ;     ld a,1 ; levels are zero-based, so this will wrap around
0442E9             0240   ;     ld (cur_level),a
0442E9             0241   ;     ld a,3 ; set max enemy sprites to easy street
0442E9             0242   ;     ; ld a,64 ; DEBUG: BRING IT
0442E9             0243   ;     ld (max_enemy_sprites),a
0442E9             0244   ;     call dt_next_level
0442E9             0245   ;     call dt
0442E9             0246   
0442E9             0247   ; ; spawn our intrepid hero
0442E9             0248   ;     call player_init
0442E9             0249   
0442E9             0250   ; ; #### BEGIN GAME VARIABLES ####
0442E9             0251   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
0442E9             0252   speed_player: equ 0x000300 ; 3 pixels per frame
0442E9             0253   
0442E9             0254   main:
0442E9             0255   ; start a new game
0442E9 CD CD 42 04 0256   	call new_game
0442ED             0257   
0442ED             0258   main_loop:
0442ED             0259   ; move the background down one pixel
0442ED 3E 02       0260   	ld a,2 ; current gfx viewport
0442EF 2E 02       0261   	ld l,2 ; direction=down
0442F1 26 01       0262   	ld h,1 ; speed=1 px
0442F3 CD 8A 1B 04 0263   	call vdu_scroll_down
0442F7             0264   
0442F7             0265   ; scroll tiles
0442F7 CD 04 2D 04 0266   	call tiles_plot
0442FB             0267   
0442FB             0268   ; get player input and update sprite position
0442FB CD 5C 2C 04 0269   	call player_input
0442FF             0270   
0442FF             0271   ; move enemies
0442FF CD DE 2D 04 0272   	call move_enemies
044303             0273   
044303             0274   ; wait for the next vblank mitigate flicker and for loop timing
044303 CD E6 1B 04 0275   	call vdu_vblank
044307             0276   
044307             0277   ; poll keyboard
044307 3E 08       0278       ld a, $08                           ; code to send to MOS
044309 5B CF       0279       rst.lil $08                         ; get IX pointer to System Variables
04430B             0280   
04430B DD 7E 05    0281       ld a, (ix + $05)                    ; get ASCII code of key pressed
04430E FE 1B       0282       cp 27                               ; check if 27 (ascii code for ESC)
044310 CA 18 43 04 0283       jp z, main_end                     ; if pressed, jump to exit
044314             0284   
044314 C3 ED 42 04 0285       jp main_loop
044318             0286   
044318             0287   main_end:
044318 CD 2C 1B 04 0288       call vdu_cursor_on
04431C C9          0289   	ret
04431D             0290   
04431D             0291   
04431D             0292   ; ; #### BEGIN GAME MAIN LOOP ####
04431D             0293   ; main_loop:
04431D             0294   ; ; ; debug: start execution counter
04431D             0295   ; ;     ld a,1
04431D             0296   ; ;     out (#e0),a ; start counting instructions
04431D             0297   
04431D             0298   ; ; refresh background from frame buffer
04431D             0299   ;     ld a,#02
04431D             0300   ;     out (81h),a
04431D             0301   ;     call move_background ; now move it
04431D             0302   ;     ld a,#01
04431D             0303   ;     out (81h),a ; save it back to buffer
04431D             0304   ; ; do all the things
04431D             0305   ;     call move_enemies
04431D             0306   ;     call player_move
04431D             0307   ;     call laser_control
04431D             0308   ;     call print_score
04431D             0309   ;     call draw_shields
04431D             0310   ;     call draw_lives
04431D             0311   ; ; ; debug: stop execution counter and print results
04431D             0312   ; ;     ld a,0
04431D             0313   ; ;     out (#e0),a ; stop counting instructions
04431D             0314   
04431D             0315   ; ; ; debug: start execution counter
04431D             0316   ; ;     ld a,1
04431D             0317   ; ;     out (#e0),a ; start counting instructions
04431D             0318   
04431D             0319   ;     call vdu_vblank
04431D             0320   ; ; ; debug: stop execution counter and print results
04431D             0321   ; ;     ld a,0
04431D             0322   ; ;     out (#e0),a ; stop counting instructions
04431D             0323   
04431D             0324   ;     jr main_loop
04431D             0325   ; #### END GAME MAIN LOOP ####
04431D             0326   
04431D             0327   ; draws the player's shields level
04431D             0328   ; draw_shields:
04431D             0329   ; TODO: Agonize this routine
04431D             0330   ; ; prep the loop to draw the bars
04431D             0331   ;     ld a,(player_shields) ; snag shields
04431D             0332   ;     and a
04431D             0333   ;     ret z ; don't draw if zero shields
04431D             0334   ; ; set loop counter and drawing position
04431D             0335   ;     ld b,a ; loop counter
04431D             0336   ;     ld hl,#5300+48+12
04431D             0337   ; ; set color based on bars remaining
04431D             0338   ;     ld c,103 ; bright green 28fe0a
04431D             0339   ;     cp 9
04431D             0340   ;     jp p,draw_shields_loop
04431D             0341   ;     ld c,74 ; bright yellow eafe5b
04431D             0342   ;     cp 3
04431D             0343   ;     jp p,draw_shields_loop
04431D             0344   ;     ld c,28 ; bright red fe0a0a
04431D             0345   ; draw_shields_loop:
04431D             0346   ;     push bc ; yup,outta
04431D             0347   ;     push hl ; registers again
04431D             0348   ;     ; ld a,#A8 ; ▀,168
04431D             0349   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
04431D             0350   ;     ; call draw_char
04431D             0351   ;     call draw_num ; we nuked draw_char for the time being
04431D             0352   ;     pop hl
04431D             0353   ;     ld a,8
04431D             0354   ;     add a,l
04431D             0355   ;     ld l,a
04431D             0356   ;     pop bc
04431D             0357   ;     djnz draw_shields_loop
04431D             0358       ; ret
04431D             0359   
04431D             0360   ; prints the player's score
04431D             0361   ; print_score:
04431D             0362   ; TODO: Agonize this
04431D             0363   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
04431D             0364   ;     ld c,42 ; dark orange b74400
04431D             0365   ;     ld hl,#5200+1+8+6*6
04431D             0366   ;     ld a,3 ; print 6 bdc digits
04431D             0367   ;     ld de,player_score
04431D             0368   ;     call print_num
04431D             0369   
04431D             0370   ;     ld c,58 ; golden yellow fec10a
04431D             0371   ;     ld hl,#5100+8+6*6
04431D             0372   ;     ld a,3 ; print 6 bdc digits
04431D             0373   ;     ld de,player_score
04431D             0374   ;     call print_num
04431D             0375       ; ret
04431D             0376   
04431D             0377   ; draw_lives:
04431D             0378   ;     ld hl,player_small ; make small yellow ship the active sprite
04431D             0379   ;     ld (sprite_base_bufferId),hl
04431D             0380   ;     ; ld a,#80 ; northern orientation
04431D             0381   ;     ; ld (sprite_orientation),a
04431D             0382   ;     ld hl,0 ; north
04431D             0383   ;     ld (sprite_heading),hl
04431D             0384   ;     xor a
04431D             0385   ;     ld (sprite_animation),a
04431D             0386   ;     ld a,#56 ; top of visible screen
04431D             0387   ;     ld (sprite_y+1),a
04431D             0388   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04431D             0389   ;     ld a,(player_ships)
04431D             0390   ;     dec a ; we draw one fewer ships than lives
04431D             0391   ;     ret z ; nothing to draw here, move along
04431D             0392   ;     ld b,a ; loop counter
04431D             0393   ;     ld a,256-16 ; initial x position
04431D             0394   ; draw_lives_loop:
04431D             0395   ;     ld (sprite_x+1),a
04431D             0396   ;     push af
04431D             0397   ;     push bc
04431D             0398   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04431D             0399   ;     pop bc
04431D             0400   ;     pop af
04431D             0401   ;     sub 10
04431D             0402   ;     djnz draw_lives_loop
04431D             0403   ;     ret
