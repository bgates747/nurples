PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 54 42 04 0030   	call	init			; Initialization code
040050 CD E7 42 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	; include "images2.inc" ; deprecated in favor of images.inc, images_sprites.inc, images_ui.inc
040060             0048   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0049   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0050   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04167A             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
04167A             0033*  
04167A             0034*  ; pointer to top address of current record, initialized to table_base
04167A E2 15 04    0035*  table_pointer: dl table_base
04167D             0036*  ; how many active sprites
04167D 00          0037*  table_active_sprites: db 0x00
04167E             0038*  ; flag indicating collision with screen edge
04167E             0039*  ; uses orientation codes to specify which edge(s)
04167E 00          0040*  sprite_screen_edge: db #00
04167F             0041*  ; next sprite id to use
04167F 00          0042*  sprite_next_id: db 0
041680             0043*  
041680             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041680             0045*  ; integer coordinates are all that are needed for collision calculations
041680 00          0046*  collision_x: db 0x00
041681 00          0047*  collision_y: db 0x00
041682 00          0048*  collision_dim_x: db 0x00
041683 00          0049*  collision_dim_y: db 0x00
041684             0050*  
041684             0051*  ; scratch variables
041684 00          0052*  x: db 0x00 ; 8-bit signed integer
041685 00          0053*  y: db 0x00 ; 8-bit signed integer
041686 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041689 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04168C 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04168F 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041692 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041695 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041698             0060*  
041698             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041698 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04169B 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04169E 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
0416A1             0065*  
0416A1             0066*  ; gets the next available sprite id
0416A1             0067*  ; inputs; none
0416A1             0068*  ; returns: if new sprite available, a = sprite id,
0416A1             0069*  ;           ix pointing to new sprite vars, carry set
0416A1             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
0416A1             0071*  ; destroys: a,b,hl,ix
0416A1             0072*  ; affects: bumps table_active_sprites by one
0416A1             0073*  table_get_next_id:
0416A1 DD 21 E2 15 0074*      ld ix,table_base
       04          
0416A6 11 26 00 00 0075*      ld de,table_bytes_per_record
0416AA 06 04       0076*      ld b,table_max_records
0416AC             0077*  @loop:
0416AC DD 7E 01    0078*      ld a,(ix+sprite_type)
0416AF A7          0079*      and a
0416B0 28 06       0080*      jr z,@found
0416B2 DD 19       0081*      add ix,de
0416B4 10 F6       0082*      djnz @loop
0416B6             0083*  @notfound:
0416B6 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
0416B7 C9          0085*      ret
0416B8             0086*  @found:
0416B8             0087*  ; bump number of active sprites
0416B8 21 7D 16 04 0088*      ld hl,table_active_sprites
0416BC 34          0089*      inc (hl)
0416BD             0090*  ; return sprite id
0416BD 3E 04       0091*      ld a,table_max_records
0416BF 90          0092*      sub b
0416C0 32 7F 16 04 0093*      ld (sprite_next_id),a
0416C4 37          0094*      scf ; sets carry flag indicating we found a free sprite
0416C5 C9          0095*      ret ; done
0416C6             0096*  
0416C6             0097*  ; deactivate the sprite with the given id
0416C6             0098*  ; inputs: a = sprite id
0416C6             0099*  ; outputs: nothing
0416C6             0100*  ; destroys: a,ix,de
0416C6             0101*  ; affects: decrements table_active_sprites by one
0416C6             0102*  table_deactivate_sprite:
0416C6 F5          0103*      push af ; save sprite id bc we need it later
0416C7 CD 88 1F 04 0104*      call vdu_sprite_select
0416CB CD 0C 20 04 0105*      call vdu_sprite_hide
0416CF F1          0106*      pop af ; restore sprite id
0416D0 11 00 00 00 0107*      ld de,0 ; clear deu
0416D4 57          0108*      ld d,a
0416D5 1E 26       0109*      ld e,table_bytes_per_record
0416D7 ED 5C       0110*      mlt de
0416D9 DD 21 E2 15 0111*      ld ix,table_base
       04          
0416DE DD 19       0112*      add ix,de
0416E0 AF          0113*      xor a
0416E1 DD 77 01    0114*      ld (ix+sprite_type),a
0416E4 DD 21 7D 16 0115*      ld ix,table_active_sprites
       04          
0416E9 DD 35 00    0116*      dec (ix)
0416EC C9          0117*      ret
0416ED             0051   ; API includes
0416ED             0052       include "mos_api.inc"
0416ED             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0416ED             0002*  ; Title:	AGON MOS - API for user projects
0416ED             0003*  ; Author:	Dean Belfield
0416ED             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0416ED             0005*  ;			Added MOS error codes for return in HL
0416ED             0006*  ; Created:	03/08/2022
0416ED             0007*  ; Last Updated:	10/08/2023
0416ED             0008*  ;
0416ED             0009*  ; Modinfo:
0416ED             0010*  ; 05/08/2022:	Added mos_feof
0416ED             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0416ED             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0416ED             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0416ED             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0416ED             0015*  ; 13/10/2022:	Added mos_oscli
0416ED             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0416ED             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0416ED             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0416ED             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0416ED             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0416ED             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0416ED             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0416ED             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0416ED             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0416ED             0025*  ; 19/05/2023:	Added sysvar_scrMode
0416ED             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0416ED             0027*  ; 03/08/2023:	Added mos_setkbvector
0416ED             0028*  ; 10/08/2023:	Added mos_getkbmap
0416ED             0029*  
0416ED             0030*  ; VDP control (VDU 23, 0, n)
0416ED             0031*  ;
0416ED             0032*  vdp_gp:				EQU 80h
0416ED             0033*  vdp_keycode:		EQU 81h
0416ED             0034*  vdp_cursor:			EQU	82h
0416ED             0035*  vdp_scrchar:		EQU	83h
0416ED             0036*  vdp_scrpixel:		EQU	84h
0416ED             0037*  vdp_audio:			EQU	85h
0416ED             0038*  vdp_mode:			EQU	86h
0416ED             0039*  vdp_rtc:			EQU	87h
0416ED             0040*  vdp_keystate:		EQU	88h
0416ED             0041*  vdp_logicalcoords:	EQU	C0h
0416ED             0042*  vdp_terminalmode:	EQU	FFh
0416ED             0043*  
0416ED             0044*  ; MOS high level functions
0416ED             0045*  ;
0416ED             0046*  mos_getkey:			EQU	00h
0416ED             0047*  mos_load:			EQU	01h
0416ED             0048*  mos_save:			EQU	02h
0416ED             0049*  mos_cd:				EQU	03h
0416ED             0050*  mos_dir:			EQU	04h
0416ED             0051*  mos_del:			EQU	05h
0416ED             0052*  mos_ren:			EQU	06h
0416ED             0053*  mos_mkdir:			EQU	07h
0416ED             0054*  mos_sysvars:		EQU	08h
0416ED             0055*  mos_editline:		EQU	09h
0416ED             0056*  mos_fopen:			EQU	0Ah
0416ED             0057*  mos_fclose:			EQU	0Bh
0416ED             0058*  mos_fgetc:			EQU	0Ch
0416ED             0059*  mos_fputc:			EQU	0Dh
0416ED             0060*  mos_feof:			EQU	0Eh
0416ED             0061*  mos_getError:		EQU	0Fh
0416ED             0062*  mos_oscli:			EQU	10h
0416ED             0063*  mos_copy:			EQU	11h
0416ED             0064*  mos_getrtc:			EQU	12h
0416ED             0065*  mos_setrtc:			EQU	13h
0416ED             0066*  mos_setintvector:	EQU	14h
0416ED             0067*  mos_uopen:			EQU	15h
0416ED             0068*  mos_uclose:			EQU	16h
0416ED             0069*  mos_ugetc:			EQU	17h
0416ED             0070*  mos_uputc:			EQU	18h
0416ED             0071*  mos_getfil:			EQU	19h
0416ED             0072*  mos_fread:			EQU	1Ah
0416ED             0073*  mos_fwrite:			EQU	1Bh
0416ED             0074*  mos_flseek:			EQU	1Ch
0416ED             0075*  mos_setkbvector:	EQU	1Dh
0416ED             0076*  mos_getkbmap:		EQU	1Eh
0416ED             0077*  
0416ED             0078*  ; MOS program exit codes
0416ED             0079*  ;
0416ED             0080*  EXIT_OK:				EQU  0;	"OK",
0416ED             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0416ED             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0416ED             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0416ED             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0416ED             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0416ED             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0416ED             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0416ED             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0416ED             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0416ED             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0416ED             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0416ED             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0416ED             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0416ED             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0416ED             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0416ED             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0416ED             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0416ED             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0416ED             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0416ED             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0416ED             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0416ED             0102*  ; FatFS file access functions
0416ED             0103*  ;
0416ED             0104*  ffs_fopen:			EQU	80h
0416ED             0105*  ffs_fclose:			EQU	81h
0416ED             0106*  ffs_fread:			EQU	82h
0416ED             0107*  ffs_fwrite:			EQU	83h
0416ED             0108*  ffs_flseek:			EQU	84h
0416ED             0109*  ffs_ftruncate:		EQU	85h
0416ED             0110*  ffs_fsync:			EQU	86h
0416ED             0111*  ffs_fforward:		EQU	87h
0416ED             0112*  ffs_fexpand:		EQU	88h
0416ED             0113*  ffs_fgets:			EQU	89h
0416ED             0114*  ffs_fputc:			EQU	8Ah
0416ED             0115*  ffs_fputs:			EQU	8Bh
0416ED             0116*  ffs_fprintf:		EQU	8Ch
0416ED             0117*  ffs_ftell:			EQU	8Dh
0416ED             0118*  ffs_feof:			EQU	8Eh
0416ED             0119*  ffs_fsize:			EQU	8Fh
0416ED             0120*  ffs_ferror:			EQU	90h
0416ED             0121*  
0416ED             0122*  ; FatFS directory access functions
0416ED             0123*  ;
0416ED             0124*  ffs_dopen:			EQU	91h
0416ED             0125*  ffs_dclose:			EQU	92h
0416ED             0126*  ffs_dread:			EQU	93h
0416ED             0127*  ffs_dfindfirst:		EQU	94h
0416ED             0128*  ffs_dfindnext:		EQU	95h
0416ED             0129*  
0416ED             0130*  ; FatFS file and directory management functions
0416ED             0131*  ;
0416ED             0132*  ffs_stat:			EQU	96h
0416ED             0133*  ffs_unlink:			EQU	97h
0416ED             0134*  ffs_rename:			EQU	98h
0416ED             0135*  ffs_chmod:			EQU	99h
0416ED             0136*  ffs_utime:			EQU	9Ah
0416ED             0137*  ffs_mkdir:			EQU	9Bh
0416ED             0138*  ffs_chdir:			EQU	9Ch
0416ED             0139*  ffs_chdrive:		EQU	9Dh
0416ED             0140*  ffs_getcwd:			EQU	9Eh
0416ED             0141*  
0416ED             0142*  ; FatFS volume management and system configuration functions
0416ED             0143*  ;
0416ED             0144*  ffs_mount:			EQU	9Fh
0416ED             0145*  ffs_mkfs:			EQU	A0h
0416ED             0146*  ffs_fdisk:			EQU	A1h
0416ED             0147*  ffs_getfree:		EQU	A2h
0416ED             0148*  ffs_getlabel:		EQU	A3h
0416ED             0149*  ffs_setlabel:		EQU	A4h
0416ED             0150*  ffs_setcp:			EQU	A5h
0416ED             0151*  
0416ED             0152*  ; File access modes
0416ED             0153*  ;
0416ED             0154*  fa_read:			EQU	01h
0416ED             0155*  fa_write:			EQU	02h
0416ED             0156*  fa_open_existing:	EQU	00h
0416ED             0157*  fa_create_new:		EQU	04h
0416ED             0158*  fa_create_always:	EQU	08h
0416ED             0159*  fa_open_always:		EQU	10h
0416ED             0160*  fa_open_append:		EQU	30h
0416ED             0161*  
0416ED             0162*  ; System variable indexes for api_sysvars
0416ED             0163*  ; Index into _sysvars in globals.inc
0416ED             0164*  ;
0416ED             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0416ED             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0416ED             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0416ED             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0416ED             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0416ED             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0416ED             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0416ED             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0416ED             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0416ED             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0416ED             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0416ED             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0416ED             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0416ED             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0416ED             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0416ED             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0416ED             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0416ED             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0416ED             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0416ED             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0416ED             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0416ED             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0416ED             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0416ED             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0416ED             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0416ED             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0416ED             0191*  
0416ED             0192*  ; Flags for the VPD protocol
0416ED             0193*  ;
0416ED             0194*  vdp_pflag_cursor:		EQU	00000001b
0416ED             0195*  vdp_pflag_scrchar:		EQU	00000010b
0416ED             0196*  vdp_pflag_point:		EQU	00000100b
0416ED             0197*  vdp_pflag_audio:		EQU	00001000b
0416ED             0198*  vdp_pflag_mode:			EQU	00010000b
0416ED             0199*  vdp_pflag_rtc:			EQU	00100000b
0416ED             0200*  
0416ED             0201*  ;
0416ED             0202*  ; FatFS structures
0416ED             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0416ED             0204*  ;
0416ED             0205*  ; Object ID and allocation information (FFOBJID)
0416ED             0206*  ;
0416ED             0207*  ; Indexes into FFOBJID structure
0416ED             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0416ED             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0416ED             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0416ED             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0416ED             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0416ED             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0416ED             0214*  ;
0416ED             0215*  ; File object structure (FIL)
0416ED             0216*  ;
0416ED             0217*  ; Indexes into FIL structure
0416ED             0218*  fil_obj:		EQU 0	; 15: Object identifier
0416ED             0219*  fil_flag:		EQU	15 	;  1: File status flags
0416ED             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0416ED             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0416ED             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0416ED             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0416ED             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0416ED             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0416ED             0226*  ;
0416ED             0227*  ; Directory object structure (DIR)
0416ED             0228*  ; Indexes into DIR structure
0416ED             0229*  dir_obj:		EQU  0	; 15: Object identifier
0416ED             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0416ED             0231*  dir_clust:		EQU	19	;  4: Current cluster
0416ED             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0416ED             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0416ED             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0416ED             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0416ED             0236*  ;
0416ED             0237*  ; File information structure (FILINFO)
0416ED             0238*  ;
0416ED             0239*  ; Indexes into FILINFO structure
0416ED             0240*  filinfo_fsize:		EQU 0	;   4: File size
0416ED             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0416ED             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0416ED             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0416ED             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0416ED             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0416ED             0246*  ;
0416ED             0247*  ; Macro for calling the API
0416ED             0248*  ; Parameters:
0416ED             0249*  ; - function: One of the function numbers listed above
0416ED             0250*  ;
0416ED             0251*  	MACRO	MOSCALL	function
0416ED             0252*  			LD	A, function
0416ED             0253*  			RST.LIL	08h
0416ED             0254*  	ENDMACRO
0416ED             0053       include "functions.inc"
0416ED             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0416ED             0002*  ; Print a zero-terminated string
0416ED             0003*  ; HL: Pointer to string
0416ED             0004*  printString:
0416ED C5          0005*  	PUSH	BC
0416EE 01 00 00 00 0006*  	LD		BC,0
0416F2 3E 00       0007*  	LD 	 	A,0
0416F4 5B DF       0008*  	RST.LIL 18h
0416F6 C1          0009*  	POP		BC
0416F7 C9          0010*  	RET
0416F8             0011*  ; print a VDU sequence
0416F8             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0416F8             0013*  sendVDUsequence:
0416F8 C5          0014*  	PUSH	BC
0416F9 01 00 00 00 0015*  	LD		BC, 0
0416FD 4E          0016*  	LD		C, (HL)
0416FE 5B DF       0017*  	RST.LIL	18h
041700 C1          0018*  	POP		BC
041701 C9          0019*  	RET
041702             0020*  ; Print Newline sequence to VDP
041702             0021*  printNewLine:
041702 3E 0D       0022*  	LD	A, '\r'
041704 5B D7       0023*  	RST.LIL 10h
041706 3E 0A       0024*  	LD	A, '\n'
041708 5B D7       0025*  	RST.LIL 10h
04170A C9          0026*  	RET
04170B             0027*  ; Print a 24-bit HEX number
04170B             0028*  ; HLU: Number to print
04170B             0029*  printHex24:
04170B E5          0030*  	PUSH	HL
04170C 21 02 00 00 0031*  	LD		HL, 2
041710 39          0032*  	ADD		HL, SP
041711 7E          0033*  	LD		A, (HL)
041712 E1          0034*  	POP		HL
041713 CD 1D 17 04 0035*  	CALL	printHex8
041717             0036*  ; Print a 16-bit HEX number
041717             0037*  ; HL: Number to print
041717             0038*  printHex16:
041717 7C          0039*  	LD		A,H
041718 CD 1D 17 04 0040*  	CALL	printHex8
04171C 7D          0041*  	LD		A,L
04171D             0042*  ; Print an 8-bit HEX number
04171D             0043*  ; A: Number to print
04171D             0044*  printHex8:
04171D 4F          0045*  	LD		C,A
04171E 1F          0046*  	RRA
04171F 1F          0047*  	RRA
041720 1F          0048*  	RRA
041721 1F          0049*  	RRA
041722 CD 27 17 04 0050*  	CALL	@F
041726 79          0051*  	LD		A,C
041727             0052*  @@:
041727 E6 0F       0053*  	AND		0Fh
041729 C6 90       0054*  	ADD		A,90h
04172B 27          0055*  	DAA
04172C CE 40       0056*  	ADC		A,40h
04172E 27          0057*  	DAA
04172F 5B D7       0058*  	RST.LIL	10h
041731 C9          0059*  	RET
041732             0060*  
041732             0061*  ; Print a 0x HEX prefix
041732             0062*  DisplayHexPrefix:
041732 3E 30       0063*  	LD	A, '0'
041734 5B D7       0064*  	RST.LIL 10h
041736 3E 78       0065*  	LD	A, 'x'
041738 5B D7       0066*  	RST.LIL 10h
04173A C9          0067*  	RET
04173B             0068*  
04173B             0069*  
04173B             0070*  ; Prints the right justified decimal value in HL without leading zeroes
04173B             0071*  ; HL : Value to print
04173B             0072*  printDec:
04173B 11 5F 17 04 0073*  	LD	 DE, _printDecBuffer
04173F CD 68 17 04 0074*  	CALL Num2String
041743             0075*  ; BEGIN MY CODE
041743             0076*  ; replace leading zeroes with spaces
041743 21 5F 17 04 0077*      LD	 HL, _printDecBuffer
041747 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
041749             0079*  @loop:
041749 7E          0080*      LD	 A, (HL)
04174A FE 30       0081*      CP	 '0'
04174C C2 5A 17 04 0082*      JP	 NZ, @done
041750 3E 20       0083*      LD   A, ' '
041752 77          0084*      LD	 (HL), A
041753 23          0085*      INC	 HL
041754 CD 18 1B 04 0086*      CALL vdu_cursor_forward
041758 10 EF       0087*      DJNZ @loop
04175A             0088*  @done:
04175A             0089*  ; END MY CODE
04175A             0090*  	; LD	 HL, _printDecBuffer
04175A CD ED 16 04 0091*  	CALL printString
04175E C9          0092*  	RET
04175F 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
041768             0094*  
041768             0095*  ; This routine converts the value from HL into it's ASCII representation,
041768             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041768             0097*  ; so it will allways be 8 characters length
041768             0098*  ; HL : Value to convert to string
041768             0099*  ; DE : pointer to buffer, at least 8 byte + 0
041768             0100*  Num2String:
041768 01 80 69 67 0101*  	LD	 BC,-10000000
04176C CD 9F 17 04 0102*  	CALL OneDigit
041770 01 C0 BD F0 0103*  	LD	 BC,-1000000
041774 CD 9F 17 04 0104*  	CALL OneDigit
041778 01 60 79 FE 0105*  	LD	 BC,-100000
04177C CD 9F 17 04 0106*  	CALL OneDigit
041780 01 F0 D8 FF 0107*  	LD   BC,-10000
041784 CD 9F 17 04 0108*  	CALL OneDigit
041788 01 18 FC FF 0109*  	LD   BC,-1000
04178C CD 9F 17 04 0110*  	CALL OneDigit
041790 01 9C FF FF 0111*  	LD   BC,-100
041794 CD 9F 17 04 0112*  	CALL OneDigit
041798 0E F6       0113*  	LD   C,-10
04179A CD 9F 17 04 0114*  	CALL OneDigit
04179E 48          0115*  	LD   C,B
04179F             0116*  OneDigit:
04179F 3E 2F       0117*  	LD   A,'0'-1
0417A1             0118*  DivideMe:
0417A1 3C          0119*  	INC  A
0417A2 09          0120*  	ADD  HL,BC
0417A3 38 FC       0121*  	JR   C,DivideMe
0417A5 ED 42       0122*  	SBC  HL,BC
0417A7 12          0123*  	LD   (DE),A
0417A8 13          0124*  	INC  DE
0417A9 C9          0125*  	RET
0417AA             0126*  
0417AA             0127*  
0417AA             0128*  ; #### new functions added by Brandon R. Gates ####
0417AA             0129*  
0417AA             0130*  ; print the binary representation of the 8-bit value in a
0417AA             0131*  ; destroys a, hl, bc
0417AA             0132*  printBin8:
0417AA 06 08       0133*      ld b,8      ; loop counter for 8 bits
0417AC 21 C7 17 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
0417B0             0135*                  ; (which will be the high bit of the value in a)
0417B0             0136*  @loop:
0417B0 07          0137*      rlca ; put the next highest bit into carry
0417B1 38 04       0138*      jr c,@one
0417B3 36 30       0139*      ld (hl),'0'
0417B5 18 02       0140*      jr @next_bit
0417B7             0141*  @one:
0417B7 36 31       0142*      ld (hl),'1'
0417B9             0143*  @next_bit:
0417B9 23          0144*      inc hl
0417BA 10 F4       0145*      djnz @loop
0417BC             0146*  ; print it
0417BC 21 C7 17 04 0147*  	ld hl,@cmd
0417C0 01 08 00 00 0148*  	ld bc,@end-@cmd
0417C4 5B DF       0149*  	rst.lil $18
0417C6 C9          0150*  	ret
0417C7             0151*  @cmd: ds 8 ; eight bytes for eight bits
0417CF             0152*  @end:
0417CF             0153*  
0417CF             0154*  ; print the binary representation of the 8-bit value in a
0417CF             0155*  ; in reverse order (lsb first)
0417CF             0156*  ; destroys a, hl, bc
0417CF             0157*  printBin8Rev:
0417CF 06 08       0158*      ld b,8      ; loop counter for 8 bits
0417D1 21 EC 17 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
0417D5             0160*                  ; (which will be the high bit of the value in a)
0417D5             0161*  @loop:
0417D5 0F          0162*      rrca ; put the next lowest bit into carry
0417D6 38 04       0163*      jr c,@one
0417D8 36 30       0164*      ld (hl),'0'
0417DA 18 02       0165*      jr @next_bit
0417DC             0166*  @one:
0417DC 36 31       0167*      ld (hl),'1'
0417DE             0168*  @next_bit:
0417DE 23          0169*      inc hl
0417DF 10 F4       0170*      djnz @loop
0417E1             0171*  ; print it
0417E1 21 EC 17 04 0172*  	ld hl,@cmd
0417E5 01 08 00 00 0173*  	ld bc,@end-@cmd
0417E9 5B DF       0174*  	rst.lil $18
0417EB C9          0175*  	ret
0417EC             0176*  @cmd: ds 8 ; eight bytes for eight bits
0417F4             0177*  @end:
0417F4             0178*  
0417F4             0179*  ; print registers to screen in hexidecimal format
0417F4             0180*  ; inputs: none
0417F4             0181*  ; outputs: values of every register printed to screen
0417F4             0182*  ;    values of each register in global scratch memory
0417F4             0183*  ; destroys: nothing
0417F4             0184*  stepRegistersHex:
0417F4             0185*  ; store everything in scratch
0417F4 22 F3 19 04 0186*      ld (uhl),hl
0417F8 ED 43 F6 19 0187*      ld (ubc),bc
       04          
0417FD ED 53 F9 19 0188*      ld (ude),de
       04          
041802 DD 22 FC 19 0189*      ld (uix),ix
       04          
041807 FD 22 FF 19 0190*      ld (uiy),iy
       04          
04180C F5          0191*      push af ; fml
04180D E1          0192*      pop hl  ; thanks, zilog
04180E 22 F0 19 04 0193*      ld (uaf),hl
041812 F5          0194*      push af ; dammit
041813             0195*  
041813             0196*  ; home the cursor
041813 CD E6 1A 04 0197*      call vdu_home_cursor
041817             0198*  
041817             0199*  ; print each register
041817 21 7C 19 04 0200*      ld hl,str_afu
04181B CD ED 16 04 0201*      call printString
04181F 2A F0 19 04 0202*      ld hl,(uaf)
041823 CD 0B 17 04 0203*      call printHex24
041827 CD 02 17 04 0204*      call printNewLine
04182B             0205*  
04182B 21 80 19 04 0206*      ld hl,str_hlu
04182F CD ED 16 04 0207*      call printString
041833 2A F3 19 04 0208*      ld hl,(uhl)
041837 CD 0B 17 04 0209*      call printHex24
04183B CD 02 17 04 0210*      call printNewLine
04183F             0211*  
04183F 21 84 19 04 0212*      ld hl,str_bcu
041843 CD ED 16 04 0213*      call printString
041847 2A F6 19 04 0214*      ld hl,(ubc)
04184B CD 0B 17 04 0215*      call printHex24
04184F CD 02 17 04 0216*      call printNewLine
041853             0217*  
041853 21 88 19 04 0218*      ld hl,str_deu
041857 CD ED 16 04 0219*      call printString
04185B 2A F9 19 04 0220*      ld hl,(ude)
04185F CD 0B 17 04 0221*      call printHex24
041863 CD 02 17 04 0222*      call printNewLine
041867             0223*  
041867 21 8C 19 04 0224*      ld hl,str_ixu
04186B CD ED 16 04 0225*      call printString
04186F 2A FC 19 04 0226*      ld hl,(uix)
041873 CD 0B 17 04 0227*      call printHex24
041877 CD 02 17 04 0228*      call printNewLine
04187B             0229*  
04187B 21 90 19 04 0230*      ld hl,str_iyu
04187F CD ED 16 04 0231*      call printString
041883 2A FF 19 04 0232*      ld hl,(uiy)
041887 CD 0B 17 04 0233*      call printHex24
04188B CD 02 17 04 0234*      call printNewLine
04188F             0235*  
04188F             0236*      ; call vdu_vblank
04188F             0237*  
04188F CD 02 17 04 0238*      call printNewLine
041893             0239*  
041893             0240*  ; check for right shift key and quit if pressed
041893             0241*  	MOSCALL mos_getkbmap
041893 3E 1E       0001*M 			LD	A, function
041895 5B CF       0002*M 			RST.LIL	08h
041897             0242*  @stayhere:
041897             0243*  ; 7 RightShift
041897 DD CB 00 76 0244*      bit 6,(ix+0)
04189B 20 02       0245*      jr nz,@RightShift
04189D 18 F8       0246*      jr @stayhere
04189F             0247*  @RightShift:
04189F DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
0418A3 3E 80       0249*      ld a,%10000000
0418A5 CD BF 31 04 0250*      call multiPurposeDelay
0418A9             0251*  
0418A9             0252*  ; restore everything
0418A9 2A F3 19 04 0253*      ld hl, (uhl)
0418AD ED 4B F6 19 0254*      ld bc, (ubc)
       04          
0418B2 ED 5B F9 19 0255*      ld de, (ude)
       04          
0418B7 DD 2A FC 19 0256*      ld ix, (uix)
       04          
0418BC FD 2A FF 19 0257*      ld iy, (uiy)
       04          
0418C1 F1          0258*      pop af
0418C2             0259*  ; all done
0418C2 C9          0260*      ret
0418C3             0261*  
0418C3             0262*  ; print registers to screen in hexidecimal format
0418C3             0263*  ; inputs: none
0418C3             0264*  ; outputs: values of every register printed to screen
0418C3             0265*  ;    values of each register in global scratch memory
0418C3             0266*  ; destroys: nothing
0418C3             0267*  dumpRegistersHex:
0418C3             0268*  ; store everything in scratch
0418C3 22 F3 19 04 0269*      ld (uhl),hl
0418C7 ED 43 F6 19 0270*      ld (ubc),bc
       04          
0418CC ED 53 F9 19 0271*      ld (ude),de
       04          
0418D1 DD 22 FC 19 0272*      ld (uix),ix
       04          
0418D6 FD 22 FF 19 0273*      ld (uiy),iy
       04          
0418DB F5          0274*      push af ; fml
0418DC E1          0275*      pop hl  ; thanks, zilog
0418DD 22 F0 19 04 0276*      ld (uaf),hl
0418E1 F5          0277*      push af ; dammit
0418E2             0278*  
0418E2             0279*  ; home the cursor
0418E2 CD E6 1A 04 0280*      call vdu_home_cursor
0418E6             0281*  
0418E6             0282*  ; print each register
0418E6 21 7C 19 04 0283*      ld hl,str_afu
0418EA CD ED 16 04 0284*      call printString
0418EE 2A F0 19 04 0285*      ld hl,(uaf)
0418F2 CD 0B 17 04 0286*      call printHex24
0418F6 CD 02 17 04 0287*      call printNewLine
0418FA             0288*  
0418FA 21 80 19 04 0289*      ld hl,str_hlu
0418FE CD ED 16 04 0290*      call printString
041902 2A F3 19 04 0291*      ld hl,(uhl)
041906 CD 0B 17 04 0292*      call printHex24
04190A CD 02 17 04 0293*      call printNewLine
04190E             0294*  
04190E 21 84 19 04 0295*      ld hl,str_bcu
041912 CD ED 16 04 0296*      call printString
041916 2A F6 19 04 0297*      ld hl,(ubc)
04191A CD 0B 17 04 0298*      call printHex24
04191E CD 02 17 04 0299*      call printNewLine
041922             0300*  
041922 21 88 19 04 0301*      ld hl,str_deu
041926 CD ED 16 04 0302*      call printString
04192A 2A F9 19 04 0303*      ld hl,(ude)
04192E CD 0B 17 04 0304*      call printHex24
041932 CD 02 17 04 0305*      call printNewLine
041936             0306*  
041936 21 8C 19 04 0307*      ld hl,str_ixu
04193A CD ED 16 04 0308*      call printString
04193E 2A FC 19 04 0309*      ld hl,(uix)
041942 CD 0B 17 04 0310*      call printHex24
041946 CD 02 17 04 0311*      call printNewLine
04194A             0312*  
04194A 21 90 19 04 0313*      ld hl,str_iyu
04194E CD ED 16 04 0314*      call printString
041952 2A FF 19 04 0315*      ld hl,(uiy)
041956 CD 0B 17 04 0316*      call printHex24
04195A CD 02 17 04 0317*      call printNewLine
04195E             0318*  
04195E             0319*      ; call vdu_vblank
04195E             0320*  
04195E CD 02 17 04 0321*      call printNewLine
041962             0322*  ; restore everything
041962 2A F3 19 04 0323*      ld hl, (uhl)
041966 ED 4B F6 19 0324*      ld bc, (ubc)
       04          
04196B ED 5B F9 19 0325*      ld de, (ude)
       04          
041970 DD 2A FC 19 0326*      ld ix, (uix)
       04          
041975 FD 2A FF 19 0327*      ld iy, (uiy)
       04          
04197A F1          0328*      pop af
04197B             0329*  ; all done
04197B C9          0330*      ret
04197C             0331*  
04197C 61 66 3D 00 0332*  str_afu: db "af=",0
041980 68 6C 3D 00 0333*  str_hlu: db "hl=",0
041984 62 63 3D 00 0334*  str_bcu: db "bc=",0
041988 64 65 3D 00 0335*  str_deu: db "de=",0
04198C 69 78 3D 00 0336*  str_ixu: db "ix=",0
041990 69 79 3D 00 0337*  str_iyu: db "iy=",0
041994             0338*  
041994             0339*  ; print udeuhl to screen in hexidecimal format
041994             0340*  ; inputs: none
041994             0341*  ; outputs: concatenated hexidecimal udeuhl
041994             0342*  ; destroys: nothing
041994             0343*  dumpUDEUHLHex:
041994             0344*  ; store everything in scratch
041994 22 F3 19 04 0345*      ld (uhl),hl
041998 ED 43 F6 19 0346*      ld (ubc),bc
       04          
04199D ED 53 F9 19 0347*      ld (ude),de
       04          
0419A2 DD 22 FC 19 0348*      ld (uix),ix
       04          
0419A7 FD 22 FF 19 0349*      ld (uiy),iy
       04          
0419AC F5          0350*      push af
0419AD             0351*  
0419AD             0352*  ; print each register
0419AD             0353*  
0419AD 21 E7 19 04 0354*      ld hl,str_udeuhl
0419B1 CD ED 16 04 0355*      call printString
0419B5 2A F9 19 04 0356*      ld hl,(ude)
0419B9 CD 0B 17 04 0357*      call printHex24
0419BD 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
0419BF 5B D7       0359*  	rst.lil 10h
0419C1 2A F3 19 04 0360*      ld hl,(uhl)
0419C5 CD 0B 17 04 0361*      call printHex24
0419C9 CD 02 17 04 0362*      call printNewLine
0419CD             0363*  
0419CD             0364*  ; restore everything
0419CD 2A F3 19 04 0365*      ld hl, (uhl)
0419D1 ED 4B F6 19 0366*      ld bc, (ubc)
       04          
0419D6 ED 5B F9 19 0367*      ld de, (ude)
       04          
0419DB DD 2A FC 19 0368*      ld ix, (uix)
       04          
0419E0 FD 2A FF 19 0369*      ld iy, (uiy)
       04          
0419E5 F1          0370*      pop af
0419E6             0371*  ; all done
0419E6 C9          0372*      ret
0419E7             0373*  
0419E7 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0419F0             0375*  
0419F0             0376*  ; global scratch memory for registers
0419F0 00 00 00    0377*  uaf: dl 0
0419F3 00 00 00    0378*  uhl: dl 0
0419F6 00 00 00    0379*  ubc: dl 0
0419F9 00 00 00    0380*  ude: dl 0
0419FC 00 00 00    0381*  uix: dl 0
0419FF 00 00 00    0382*  uiy: dl 0
041A02 00 00 00    0383*  usp: dl 0
041A05 00 00 00    0384*  upc: dl 0
041A08             0385*  
041A08             0386*  ; inputs: whatever is in the flags register
041A08             0387*  ; outputs: binary representation of flags
041A08             0388*  ;          with a header so we know which is what
041A08             0389*  ; destroys: nothing
041A08             0390*  ; preserves: everything
041A08             0391*  dumpFlags:
041A08             0392*  ; first we curse zilog for not giving direct access to flags
041A08 F5          0393*      push af ; this is so we can send it back unharmed
041A09 F5          0394*      push af ; this is so we can pop it to hl
041A0A             0395*  ; store everything in scratch
041A0A 22 F3 19 04 0396*      ld (uhl),hl
041A0E ED 43 F6 19 0397*      ld (ubc),bc
       04          
041A13 ED 53 F9 19 0398*      ld (ude),de
       04          
041A18 DD 22 FC 19 0399*      ld (uix),ix
       04          
041A1D FD 22 FF 19 0400*      ld (uiy),iy
       04          
041A22             0401*  ; next we print the header
041A22 21 4E 1A 04 0402*      ld hl,@header
041A26 CD ED 16 04 0403*      call printString
041A2A E1          0404*      pop hl ; flags are now in l
041A2B 7D          0405*      ld a,l ; flags are now in a
041A2C CD AA 17 04 0406*      call printBin8
041A30 CD 02 17 04 0407*  	call printNewLine
041A34             0408*  ; restore everything
041A34 2A F3 19 04 0409*      ld hl, (uhl)
041A38 ED 4B F6 19 0410*      ld bc, (ubc)
       04          
041A3D ED 5B F9 19 0411*      ld de, (ude)
       04          
041A42 DD 2A FC 19 0412*      ld ix, (uix)
       04          
041A47 FD 2A FF 19 0413*      ld iy, (uiy)
       04          
041A4C F1          0414*      pop af ; send her home the way she came
041A4D C9          0415*      ret
041A4E             0416*  ; Bit 7 (S): Sign flag
041A4E             0417*  ; Bit 6 (Z): Zero flag
041A4E             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041A4E             0419*  ; Bit 4 (H): Half Carry flag
041A4E             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041A4E             0421*  ; Bit 2 (PV): Parity/Overflow flag
041A4E             0422*  ; Bit 1 (N): Subtract flag
041A4E             0423*  ; Bit 0 (C): Carry flag
041A4E 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041A59             0425*  
041A59             0426*  ; set all the bits in the flag register
041A59             0427*  ; more of an academic exercise than anything useful
041A59             0428*  ; inputs; none
041A59             0429*  ; outputs; a=0,f=255
041A59             0430*  ; destroys: flags, hl
041A59             0431*  ; preserves: a, because why not
041A59             0432*  setAllFlags:
041A59 21 FF 00 00 0433*      ld hl,255
041A5D 67          0434*      ld h,a ; four cycles to preserve a is cheap
041A5E E5          0435*      push hl
041A5F F1          0436*      pop af
041A60 C9          0437*      ret
041A61             0438*  
041A61             0439*  ; reset all the bits in the flag register
041A61             0440*  ; unlike its inverse counterpart, this may actually be useful
041A61             0441*  ; inputs; none
041A61             0442*  ; outputs; a=0,f=0
041A61             0443*  ; destroys: flags, hl
041A61             0444*  ; preserves: a, because why not
041A61             0445*  resetAllFlags:
041A61 21 00 00 00 0446*      ld hl,0
041A65 67          0447*      ld h,a ; four cycles to preserve a is cheap
041A66 E5          0448*      push hl
041A67 F1          0449*      pop af
041A68 C9          0450*      ret
041A69             0451*  
041A69             0452*  ; wait until user presses a key
041A69             0453*  ; inputs: none
041A69             0454*  ; outputs: none
041A69             0455*  ; destroys: af,ix
041A69             0456*  waitKeypress:
041A69             0457*      MOSCALL mos_sysvars
041A69 3E 08       0001*M 			LD	A, function
041A6B 5B CF       0002*M 			RST.LIL	08h
041A6D AF          0458*      xor a ; zero out any prior keypresses
041A6E DD 77 05    0459*      ld (ix+sysvar_keyascii),a
041A71             0460*  @loop:
041A71 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
041A74 A7          0462*      and a
041A75 C0          0463*      ret nz
041A76 18 F9       0464*      jr @loop
041A78             0465*  
041A78             0466*  
041A78             0467*  ; print bytes from an address to the screen in hexidecimal format
041A78             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041A78             0469*  ; outputs: values of each byte printed to screen separated by spaces
041A78             0470*  ; destroys: nothing
041A78             0471*  dumpMemoryHex:
041A78             0472*  ; save all registers to the stack
041A78 F5          0473*      push af
041A79 C5          0474*      push bc
041A7A D5          0475*      push de
041A7B E5          0476*      push hl
041A7C DD E5       0477*      push ix
041A7E FD E5       0478*      push iy
041A80             0479*  
041A80             0480*  ; set b to be our loop counter
041A80 47          0481*      ld b,a
041A81             0482*  @loop:
041A81             0483*  ; print the byte
041A81 7E          0484*      ld a,(hl)
041A82 CD 1D 17 04 0485*      call printHex8
041A86             0486*  ; print a space
041A86 3E 20       0487*      ld a,' '
041A88 5B D7       0488*      rst.lil 10h
041A8A 23          0489*      inc hl
041A8B 10 F4       0490*      djnz @loop
041A8D CD 02 17 04 0491*      call printNewLine
041A91             0492*  
041A91             0493*  ; restore everything
041A91 FD E1       0494*      pop iy
041A93 DD E1       0495*      pop ix
041A95 E1          0496*      pop hl
041A96 D1          0497*      pop de
041A97 C1          0498*      pop bc
041A98 F1          0499*      pop af
041A99             0500*  ; all done
041A99 C9          0501*      ret
041A9A             0502*  
041A9A             0503*  
041A9A             0504*  ; print bytes from an address to the screen in binary format
041A9A             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041A9A             0506*  ; outputs: values of each byte printed to screen separated by spaces
041A9A             0507*  ; destroys: nothing
041A9A             0508*  dumpMemoryBin:
041A9A             0509*  ; save all registers to the stack
041A9A F5          0510*      push af
041A9B C5          0511*      push bc
041A9C D5          0512*      push de
041A9D E5          0513*      push hl
041A9E DD E5       0514*      push ix
041AA0 FD E5       0515*      push iy
041AA2             0516*  
041AA2             0517*  ; set b to be our loop counter
041AA2 47          0518*      ld b,a
041AA3             0519*  @loop:
041AA3             0520*  ; print the byte
041AA3 7E          0521*      ld a,(hl)
041AA4 E5          0522*      push hl
041AA5 C5          0523*      push bc
041AA6 CD AA 17 04 0524*      call printBin8
041AAA C1          0525*      pop bc
041AAB             0526*  ; print a space
041AAB 3E 20       0527*      ld a,' '
041AAD 5B D7       0528*      rst.lil 10h
041AAF E1          0529*      pop hl
041AB0 23          0530*      inc hl
041AB1 10 F0       0531*      djnz @loop
041AB3 CD 02 17 04 0532*      call printNewLine
041AB7             0533*  
041AB7             0534*  ; restore everything
041AB7 FD E1       0535*      pop iy
041AB9 DD E1       0536*      pop ix
041ABB E1          0537*      pop hl
041ABC D1          0538*      pop de
041ABD C1          0539*      pop bc
041ABE F1          0540*      pop af
041ABF             0541*  ; all done
041ABF C9          0542*      ret
041AC0             0543*  
041AC0             0544*  ; print bytes from an address to the screen in binary format
041AC0             0545*  ; with the bits of each byte in reverse order (lsb first)
041AC0             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041AC0             0547*  ; outputs: values of each byte printed to screen separated by spaces
041AC0             0548*  ; destroys: nothing
041AC0             0549*  dumpMemoryBinRev:
041AC0             0550*  ; save all registers to the stack
041AC0 F5          0551*      push af
041AC1 C5          0552*      push bc
041AC2 D5          0553*      push de
041AC3 E5          0554*      push hl
041AC4 DD E5       0555*      push ix
041AC6 FD E5       0556*      push iy
041AC8             0557*  
041AC8             0558*  ; set b to be our loop counter
041AC8 47          0559*      ld b,a
041AC9             0560*  @loop:
041AC9             0561*  ; print the byte
041AC9 7E          0562*      ld a,(hl)
041ACA E5          0563*      push hl
041ACB C5          0564*      push bc
041ACC CD CF 17 04 0565*      call printBin8Rev
041AD0 C1          0566*      pop bc
041AD1             0567*  ; print a space
041AD1 3E 20       0568*      ld a,' '
041AD3 5B D7       0569*      rst.lil 10h
041AD5 E1          0570*      pop hl
041AD6 23          0571*      inc hl
041AD7 10 F0       0572*      djnz @loop
041AD9 CD 02 17 04 0573*      call printNewLine
041ADD             0574*  
041ADD             0575*  ; restore everything
041ADD FD E1       0576*      pop iy
041ADF DD E1       0577*      pop ix
041AE1 E1          0578*      pop hl
041AE2 D1          0579*      pop de
041AE3 C1          0580*      pop bc
041AE4 F1          0581*      pop af
041AE5             0582*  ; all done
041AE5 C9          0583*      ret
041AE6             0054       include "vdu.inc"
041AE6             0001*  
041AE6             0002*  ; VDU 30: Home cursor
041AE6             0003*  vdu_home_cursor:
041AE6 3E 1E       0004*      ld a,30
041AE8 5B D7       0005*  	rst.lil $10
041AEA C9          0006*  	ret
041AEB             0007*  
041AEB             0008*  vdu_cursor_on:
041AEB 21 F6 1A 04 0009*  	ld hl,@cmd
041AEF 01 03 00 00 0010*  	ld bc,@end-@cmd
041AF3 5B DF       0011*  	rst.lil $18
041AF5 C9          0012*  	ret
041AF6             0013*  @cmd:
041AF6 17 01 01    0014*  	db 23,1,1
041AF9             0015*  @end:
041AF9             0016*  
041AF9             0017*  vdu_cursor_off:
041AF9 21 04 1B 04 0018*  	ld hl,@cmd
041AFD 01 03 00 00 0019*  	ld bc,@end-@cmd
041B01 5B DF       0020*  	rst.lil $18
041B03 C9          0021*  	ret
041B04             0022*  @cmd:
041B04 17 01 00    0023*  	db 23,1,0
041B07             0024*  @end:
041B07             0025*  
041B07             0026*  ; VDU 5: Write text at graphics cursor
041B07             0027*  ; inputs: a is the character to write to the screen
041B07             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041B07             0029*  ; outputs: see the name of the function
041B07             0030*  ; destroys: a, hl, bc
041B07             0031*  vdu_char_to_gfx_cursor:
041B07 32 17 1B 04 0032*  	ld (@arg),a
041B0B 21 16 1B 04 0033*  	ld hl,@cmd
041B0F 01 02 00 00 0034*  	ld bc,@end-@cmd
041B13 5B DF       0035*  	rst.lil $18
041B15 C9          0036*  	ret
041B16 05          0037*  @cmd: db 5
041B17 00          0038*  @arg: db 0
041B18             0039*  @end:
041B18             0040*  ; VDU 9: Move cursor forward one character
041B18             0041*  vdu_cursor_forward:
041B18 3E 09       0042*      ld a,9
041B1A 5B D7       0043*  	rst.lil $10
041B1C C9          0044*  	ret
041B1D             0045*  
041B1D             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041B1D             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041B1D             0048*  vdu_move_cursor:
041B1D ED 43 2E 1B 0049*      ld (@x0),bc
       04          
041B22 21 2D 1B 04 0050*  	ld hl,@cmd
041B26 01 03 00 00 0051*  	ld bc,@end-@cmd
041B2A 5B DF       0052*  	rst.lil $18
041B2C C9          0053*  	ret
041B2D 1F          0054*  @cmd: 	db 31
041B2E 00          0055*  @x0:	db 0
041B2F 00          0056*  @y0: 	db 0
041B30 00          0057*  @end: 	db 0 ; padding
041B31             0058*  
041B31             0059*  ; VDU 12: Clear text area (CLS)
041B31             0060*  vdu_cls:
041B31 3E 0C       0061*      ld a,12
041B33 5B D7       0062*  	rst.lil $10
041B35 C9          0063*  	ret
041B36             0064*  
041B36             0065*  vdu_flip:
041B36 21 41 1B 04 0066*  	ld hl,@cmd
041B3A 01 03 00 00 0067*  	ld bc,@end-@cmd
041B3E 5B DF       0068*  	rst.lil $18
041B40 C9          0069*  	ret
041B41 17 00 C3    0070*  @cmd: db 23,0,0xC3
041B44             0071*  @end:
041B44             0072*  
041B44             0073*  ; VDU 16: Clear graphics area (CLG)
041B44             0074*  vdu_clg:
041B44 3E 10       0075*      ld a,16
041B46 5B D7       0076*  	rst.lil $10
041B48 C9          0077*  	ret
041B49             0078*  
041B49             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041B49             0080*  ; VDU 23, 7: Scrolling
041B49             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041B49             0082*  ; inputs: a, extent; l, direction; h; speed
041B49             0083*  vdu_scroll_down:
041B49 32 5E 1B 04 0084*  	ld (@extent),a
041B4D 22 5F 1B 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041B51 21 5C 1B 04 0086*  	ld hl,@cmd
041B55 01 05 00 00 0087*  	ld bc,@end-@cmd
041B59 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041B5B C9          0089*  	ret
041B5C 17 07       0090*  @cmd:       db 23,7
041B5E 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041B5F 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041B60 00          0093*  @speed:     db 0x00 ; pixels
041B61 00          0094*  @end:		db 0x00 ; padding
041B62             0095*  
041B62             0096*  ; COLOUR MODES
041B62             0097*  ; Mode	Effect
041B62             0098*  ; 0	Set on-screen pixel to target colour value
041B62             0099*  ; 1	OR value with the on-screen pixel
041B62             0100*  ; 2	AND value with the on-screen pixel
041B62             0101*  ; 3	XOR value with the on-screen pixel
041B62             0102*  ; 4	Invert the on-screen pixel
041B62             0103*  ; 5	No operation
041B62             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041B62             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041B62             0106*  
041B62             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041B62             0108*  vdu_colour_text:
041B62 32 72 1B 04 0109*  	ld (@arg),a
041B66 21 71 1B 04 0110*  	ld hl,@cmd
041B6A 01 02 00 00 0111*  	ld bc,@end-@cmd
041B6E 5B DF       0112*  	rst.lil $18
041B70 C9          0113*  	ret
041B71 11          0114*  @cmd: db 17
041B72 00          0115*  @arg: db 0
041B73             0116*  @end:
041B73             0117*  
041B73             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041B73             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041B73             0120*  vdu_gcol:
041B73 32 88 1B 04 0121*  	ld (@mode),a
041B77 79          0122*      ld a,c
041B78 32 89 1B 04 0123*      ld (@col),a
041B7C 21 87 1B 04 0124*  	ld hl,@cmd
041B80 01 03 00 00 0125*  	ld bc,@end-@cmd
041B84 5B DF       0126*  	rst.lil $18
041B86 C9          0127*  	ret
041B87 12          0128*  @cmd:  db 18
041B88 00          0129*  @mode: db 0
041B89 00          0130*  @col:  db 0
041B8A             0131*  @end:
041B8A             0132*  
041B8A             0133*  
041B8A             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041B8A             0135*  ; MIND THE LITTLE-ENDIANESS
041B8A             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041B8A             0137*  ; outputs; nothing
041B8A             0138*  ; destroys: a might make it out alive
041B8A             0139*  vdu_set_txt_viewport:
041B8A ED 43 A0 1B 0140*      ld (@lb),bc
       04          
041B8F ED 53 A2 1B 0141*  	ld (@rt),de
       04          
041B94 21 9F 1B 04 0142*  	ld hl,@cmd
041B98 01 05 00 00 0143*  	ld bc,@end-@cmd
041B9C 5B DF       0144*  	rst.lil $18
041B9E C9          0145*  	ret
041B9F 1C          0146*  @cmd:   db 28 ; set text viewport command
041BA0 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041BA2 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041BA4 00          0149*  @end:   db 0x00	  ; padding
041BA5             0150*  
041BA5             0151*  ; Wait for VBLANK interrupt
041BA5             0152*  vdu_vblank:
041BA5 DD E5       0153*      PUSH 	IX
041BA7             0154*  	MOSCALL	mos_sysvars
041BA7 3E 08       0001*M 			LD	A, function
041BA9 5B CF       0002*M 			RST.LIL	08h
041BAB DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041BAE             0156*  @wait:
041BAE DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041BB1 28 FB       0158*      JR	Z, @wait
041BB3 DD E1       0159*      POP	IX
041BB5 C9          0160*      RET
041BB6             0161*  
041BB6             0162*  ; VDU 29, x; y;: Set graphics origin
041BB6             0163*  ; This command sets the graphics origin.
041BB6             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041BB6             0165*  ; inputs: bc=x0,de=y0
041BB6             0166*  ; outputs; nothing
041BB6             0167*  ; destroys: a might make it out alive
041BB6             0168*  vdu_set_gfx_origin:
041BB6 ED 43 CC 1B 0169*      ld (@x0),bc
       04          
041BBB ED 53 CE 1B 0170*      ld (@y0),de
       04          
041BC0 21 CB 1B 04 0171*      ld hl,@cmd
041BC4 01 05 00 00 0172*      ld bc,@end-@cmd
041BC8 5B DF       0173*      rst.lil $18
041BCA C9          0174*      ret
041BCB 1D          0175*  @cmd:   db 29 ; set graphics origin command
041BCC 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041BCE 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041BD0 00          0178*  @end:   db 0x00	  ; padding
041BD1             0179*  
041BD1             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041BD1             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041BD1             0182*  ; 	because we have turned off logical screen scaling
041BD1             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041BD1             0184*  ; outputs; nothing
041BD1             0185*  ; destroys: a might make it out alive
041BD1             0186*  vdu_set_gfx_viewport:
041BD1 ED 43 F1 1B 0187*      ld (@x0),bc
       04          
041BD6 FD 22 F3 1B 0188*      ld (@y1),iy
       04          
041BDB DD 22 F5 1B 0189*  	ld (@x1),ix
       04          
041BE0 ED 53 F7 1B 0190*  	ld (@y0),de
       04          
041BE5 21 F0 1B 04 0191*  	ld hl,@cmd
041BE9 01 09 00 00 0192*  	ld bc,@end-@cmd
041BED 5B DF       0193*  	rst.lil $18
041BEF C9          0194*  	ret
041BF0 18          0195*  @cmd:   db 24 ; set graphics viewport command
041BF1 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041BF3 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041BF5 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041BF7 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041BF9 00          0200*  @end:   db 0x00	  ; padding
041BFA             0201*  
041BFA             0202*  ; SCREEN MODES
041BFA             0203*  ; ===============================
041BFA             0204*  ; Mode  Horz  Vert  Cols  Refresh
041BFA             0205*  ; ---   ----  ----  ----  -------
041BFA             0206*  ; 11    320   240   2     60hz
041BFA             0207*  ; 139   320   240   2     60hz
041BFA             0208*  ; 23    512   384   2     60hz
041BFA             0209*  ; 151   512   384   2     60hz
041BFA             0210*  ; 6     640   240   2     60hz
041BFA             0211*  ; 134   640   240   2     60hz
041BFA             0212*  ; 2     640   480   2     60hz
041BFA             0213*  ; 130   640   480   2     60hz
041BFA             0214*  ; 17    800   600   2     60hz
041BFA             0215*  ; 145   800   600   2     60hz
041BFA             0216*  ; 18    1024  768   2     60hz
041BFA             0217*  ; 146   1024  768   2     60hz
041BFA             0218*  ; ---   ----  ----  ----  -------
041BFA             0219*  ; 10    320   240   4     60hz
041BFA             0220*  ; 138   320   240   4     60hz
041BFA             0221*  ; 22    512   384   4     60hz
041BFA             0222*  ; 150   512   384   4     60hz
041BFA             0223*  ; 5     640   240   4     60hz
041BFA             0224*  ; 133   640   240   4     60hz
041BFA             0225*  ; 1     640   480   4     60hz
041BFA             0226*  ; 129   640   480   4     60hz
041BFA             0227*  ; 16    800   600   4     60hz
041BFA             0228*  ; 19    1024  768   4     60hz
041BFA             0229*  ; ---   ----  ----  ----  -------
041BFA             0230*  ; 9     320   240   16    60hz
041BFA             0231*  ; 137   320   240   16    60hz
041BFA             0232*  ; 21    512   384   16    60hz
041BFA             0233*  ; 149   512   384   16    60hz
041BFA             0234*  ; 4     640   240   16    60hz
041BFA             0235*  ; 132   640   240   16    60hz
041BFA             0236*  ; 0     640   480   16    60hz
041BFA             0237*  ; 7     n/a   n/a   16    60hz
041BFA             0238*  ; ---   ----  ----  ----  -------
041BFA             0239*  ; 8     320   240   64    60hz
041BFA             0240*  ; 136   320   240   64    60hz
041BFA             0241*  ; 20    512   384   64    60hz
041BFA             0242*  ; 3     640   240   64    60hz
041BFA             0243*  ; ---   ----  ----  ----  -------
041BFA             0244*  vdu_set_screen_mode:
041BFA 32 0A 1C 04 0245*  	ld (@arg),a
041BFE 21 09 1C 04 0246*  	ld hl,@cmd
041C02 01 02 00 00 0247*  	ld bc,@end-@cmd
041C06 5B DF       0248*  	rst.lil $18
041C08 C9          0249*  	ret
041C09 16          0250*  @cmd: db 22 ; set screen mode
041C0A 00          0251*  @arg: db 0  ; screen mode parameter
041C0B             0252*  @end:
041C0B             0253*  
041C0B             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041C0B             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041C0B             0256*  ; note: default setting on boot is scaling ON
041C0B             0257*  vdu_set_scaling:
041C0B 32 1D 1C 04 0258*  	ld (@arg),a
041C0F 21 1A 1C 04 0259*  	ld hl,@cmd
041C13 01 04 00 00 0260*  	ld bc,@end-@cmd
041C17 5B DF       0261*  	rst.lil $18
041C19 C9          0262*  	ret
041C1A 17 00 C0    0263*  @cmd: db 23,0,0xC0
041C1D 00          0264*  @arg: db 0  ; scaling on/off
041C1E             0265*  @end:
041C1E             0266*  
041C1E             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041C1E             0268*  ; inputs: hl=bufferId
041C1E             0269*  vdu_buff_select:
041C1E 22 30 1C 04 0270*  	ld (@bufferId),hl
041C22 21 2D 1C 04 0271*  	ld hl,@cmd
041C26 01 05 00 00 0272*  	ld bc,@end-@cmd
041C2A 5B DF       0273*  	rst.lil $18
041C2C C9          0274*  	ret
041C2D 17 1B 20    0275*  @cmd: db 23,27,0x20
041C30 00 00       0276*  @bufferId: dw 0x0000
041C32 00          0277*  @end: db 0x00 ; padding
041C33             0278*  
041C33             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041C33             0280*  ; inputs: a=format; bc=width; de=height
041C33             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041C33             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041C33             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041C33             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041C33             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041C33             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041C33             0287*  vdu_bmp_create:
041C33 ED 43 4F 1C 0288*      ld (@width),bc
       04          
041C38 ED 53 51 1C 0289*      ld (@height),de
       04          
041C3D 32 53 1C 04 0290*      ld (@fmt),a
041C41 21 4C 1C 04 0291*  	ld hl,@cmd
041C45 01 08 00 00 0292*  	ld bc,@end-@cmd
041C49 5B DF       0293*  	rst.lil $18
041C4B C9          0294*  	ret
041C4C 17 1B 21    0295*  @cmd:       db 23,27,0x21
041C4F 00 00       0296*  @width:     dw 0x0000
041C51 00 00       0297*  @height:    dw 0x0000
041C53 00          0298*  @fmt:       db 0x00
041C54             0299*  @end:
041C54             0300*  
041C54             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041C54             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041C54             0303*  vdu_load_img_rgba2_to_8:
041C54             0304*  ; backup the target buffer id and image dimensions
041C54 E5          0305*      push hl
041C55 D5          0306*      push de
041C56 C5          0307*      push bc
041C57             0308*  ; load the rgba2 image to working buffer 65534
041C57 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041C5B CD 5E 1D 04 0310*  	call vdu_load_buffer_from_file
041C5F             0311*  ; restore the image dimensions and target buffer id
041C5F C1          0312*      pop bc
041C60 D1          0313*      pop de
041C61 E1          0314*      pop hl
041C62             0315*  ; fall through to vdu_rgba2_to_8
041C62             0316*  
041C62             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041C62             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041C62             0319*  ; the "expand bitmap" command is:
041C62             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041C62             0321*  ; and then to reverse the byte order to fix endian-ness:
041C62             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041C62             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041C62             0324*  ; VDU 23,27,&20,targetBufferID%;
041C62             0325*  ; VDU 23,27,&21,width%;height%;0
041C62             0326*  ; -------------------------------------------------------------------
041C62             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041C62             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041C62             0329*  vdu_rgba2_to_8:
041C62             0330*  ; load the image dimensions and buffer id parameters
041C62 ED 43 BE 1C 0331*      ld (@width),bc
       04          
041C67 ED 53 C0 1C 0332*      ld (@height),de
       04          
041C6C 22 A3 1C 04 0333*      ld (@bufferId0),hl
041C70 22 B0 1C 04 0334*      ld (@bufferId2),hl
041C74 22 B9 1C 04 0335*      ld (@bufferId1),hl
041C78             0336*  ; clean up bytes that got stomped on by the ID loads
041C78 3E 48       0337*      ld a,0x48
041C7A 32 A5 1C 04 0338*      ld (@bufferId0+2),a
041C7E 3E 17       0339*      ld a,23
041C80 32 BB 1C 04 0340*      ld (@bufferId1+2),a
041C84 3E 18       0341*      ld a,24
041C86 32 B2 1C 04 0342*      ld (@bufferId2+2),a
041C8A AF          0343*      xor a
041C8B 32 C2 1C 04 0344*      ld (@height+2),a
041C8F             0345*  ; send the vdu command strings
041C8F 21 9A 1C 04 0346*      ld hl,@beg
041C93 01 29 00 00 0347*      ld bc,@end-@beg
041C97 5B DF       0348*      rst.lil $18
041C99 C9          0349*      ret
041C9A             0350*  @beg:
041C9A             0351*  ; Command 14: Consolidate blocks in a buffer
041C9A             0352*  ; VDU 23, 0, &A0, bufferId; 14
041C9A 17 00 A0    0353*      db 23,0,0xA0
041C9D FE FF       0354*      dw 65534 ; workingBufferId
041C9F 0E          0355*      db 14 ; consolidate blocks
041CA0             0356*  ; the "expand bitmap" command is:
041CA0             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041CA0 17 00 A0    0358*      db 23,0,0xA0
041CA3 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041CA5 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041CA6 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041CA7 FE FF       0362*      dw 65534 ; sourceBufferId
041CA9 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041CAD             0364*  ; reverse the byte order to fix endian-ness:
041CAD             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041CAD             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041CAD             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041CAD 17 00 A0    0368*      db 23,0,0xA0
041CB0 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041CB2 18          0370*      db 24 ; reverse byte order
041CB3 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041CB4 04 00       0372*      dw 4 ; size (4 bytes)
041CB6             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041CB6             0374*  ; VDU 23,27,&20,targetBufferID%;
041CB6 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041CB9 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041CBB             0377*  ; VDU 23,27,&21,width%;height%;0
041CBB 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041CBE 00 00       0379*  @width: dw 0x0000
041CC0 00 00       0380*  @height: dw 0x0000
041CC2 00          0381*      db 0x00 ; rgba8888 format
041CC3             0382*  @end:
041CC3             0383*  
041CC3             0384*  ; scratch variables
041CC3 00 00 00    0385*  bufferId0: dl 0x000000
041CC6 00 00 00    0386*  bufferId1: dl 0x000000
041CC9             0387*  
041CC9             0388*  ; load a vdu buffer from local memory
041CC9             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041CC9             0390*  vdu_load_buffer:
041CC9 ED 43 F2 1C 0391*      ld (@length),bc
       04          
041CCE D5          0392*      push de ; save data pointer
041CCF             0393*  ; send the vdu command string
041CCF 7D          0394*      ld a,l
041CD0 32 EF 1C 04 0395*      ld (@bufferId),a
041CD4 7C          0396*      ld a,h
041CD5 32 F0 1C 04 0397*      ld (@bufferId+1),a
041CD9 21 EC 1C 04 0398*      ld hl,@cmd
041CDD 01 08 00 00 0399*      ld bc,@end-@cmd
041CE1 5B DF       0400*      rst.lil $18
041CE3             0401*  ; send the buffer data
041CE3 E1          0402*      pop hl ; pointer to data
041CE4 ED 4B F2 1C 0403*      ld bc,(@length)
       04          
041CE9 5B DF       0404*      rst.lil $18 ; send it
041CEB C9          0405*      ret
041CEC             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041CEC 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041CEF 00 00       0408*  @bufferId:	dw 0x0000
041CF1 00          0409*  		    db 0 ; load buffer
041CF2 00 00       0410*  @length:	dw 0x0000
041CF4 00          0411*  @end: db 0 ; padding
041CF5             0412*  
041CF5             0413*  ; clear a buffer
041CF5             0414*  ; inputs: hl = bufferId
041CF5             0415*  vdu_clear_buffer:
041CF5 7D          0416*      ld a,l
041CF6 32 0D 1D 04 0417*      ld (@bufferId),a
041CFA 7C          0418*      ld a,h
041CFB 32 0E 1D 04 0419*      ld (@bufferId+1),a
041CFF 21 0A 1D 04 0420*      ld hl,@cmd
041D03 01 06 00 00 0421*      ld bc,@end-@cmd
041D07 5B DF       0422*      rst.lil $18
041D09 C9          0423*      ret
041D0A 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041D0D 00 00       0425*  @bufferId:	dw 0x0000
041D0F 02          0426*  		    db 2 ; clear buffer
041D10             0427*  @end:
041D10             0428*  
041D10             0429*  vdu_clear_all_buffers:
041D10             0430*  ; clear all buffers
041D10 21 1B 1D 04 0431*      ld hl,@beg
041D14 01 06 00 00 0432*      ld bc,@end-@beg
041D18 5B DF       0433*      rst.lil $18
041D1A C9          0434*      ret
041D1B 17 00 A0    0435*  @beg: db 23,0,$A0
041D1E FF FF       0436*        dw -1 ; clear all buffers
041D20 02          0437*        db 2  ; command 2: clear a buffer
041D21             0438*  @end:
041D21             0439*  
041D21             0440*  ; Command 14: Consolidate blocks in a buffer
041D21             0441*  vdu_consolidate_buffer:
041D21             0442*  ; set parameters for vdu call
041D21 7D          0443*      ld a,l
041D22 32 39 1D 04 0444*      ld (@bufferId),a
041D26 7C          0445*      ld a,h
041D27 32 3A 1D 04 0446*      ld (@bufferId+1),a
041D2B 21 36 1D 04 0447*      ld hl,@beg
041D2F 01 06 00 00 0448*      ld bc,@end-@beg
041D33 5B DF       0449*      rst.lil $18
041D35 C9          0450*      ret
041D36             0451*  ; VDU 23, 0, &A0, bufferId; 14
041D36 17 00 A0    0452*  @beg: db 23,0,0xA0
041D39 00 00       0453*  @bufferId: dw 0x0000
041D3B 0E          0454*             db 14
041D3C             0455*  @end:
041D3C             0456*  
041D3C             0457*  ; load an image file to a buffer and make it a bitmap
041D3C             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041D3C             0459*  vdu_load_img:
041D3C             0460*  ; back up image type and dimension parameters
041D3C 22 C3 1C 04 0461*      ld (bufferId0),hl
041D40 F5          0462*      push af
041D41 C5          0463*  	push bc
041D42 D5          0464*  	push de
041D43             0465*  ; load the image
041D43 CD 5E 1D 04 0466*  	call vdu_load_buffer_from_file
041D47             0467*  ; now make it a bitmap
041D47 2A C3 1C 04 0468*      ld hl,(bufferId0)
041D4B CD 21 1D 04 0469*      call vdu_consolidate_buffer
041D4F 2A C3 1C 04 0470*      ld hl,(bufferId0)
041D53 CD 1E 1C 04 0471*      call vdu_buff_select
041D57 D1          0472*  	pop de ; image height
041D58 C1          0473*  	pop bc ; image width
041D59 F1          0474*  	pop af ; image type
041D5A C3 33 1C 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041D5E             0476*  
041D5E             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041D5E             0478*  vdu_load_buffer_from_file:
041D5E 22 C3 1C 04 0479*      ld (bufferId0),hl
041D62             0480*  
041D62             0481*  ; clear target buffer
041D62 CD F5 1C 04 0482*      call vdu_clear_buffer
041D66             0483*  
041D66             0484*  ; open the file in read mode
041D66             0485*  ; Open a file
041D66             0486*  ; HLU: Filename
041D66             0487*  ;   C: Mode
041D66             0488*  ; Returns:
041D66             0489*  ;   A: Filehandle, or 0 if couldn't open
041D66 FD E5       0490*  	push iy ; pointer to filename
041D68 E1          0491*  	pop hl
041D69 0E 01       0492*  	ld c,fa_read
041D6B             0493*      MOSCALL mos_fopen
041D6B 3E 0A       0001*M 			LD	A, function
041D6D 5B CF       0002*M 			RST.LIL	08h
041D6F 32 AA 1D 04 0494*      ld (@filehandle),a
041D73             0495*  
041D73             0496*  @read_file:
041D73             0497*  ; Read a block of data from a file
041D73             0498*  ;   C: Filehandle
041D73             0499*  ; HLU: Pointer to where to write the data to
041D73             0500*  ; DEU: Number of bytes to read
041D73             0501*  ; Returns:
041D73             0502*  ; DEU: Number of bytes read
041D73 3A AA 1D 04 0503*      ld a,(@filehandle)
041D77 4F          0504*      ld c,a
041D78 21 00 E0 B7 0505*      ld hl,filedata
041D7C 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041D80             0507*      MOSCALL mos_fread
041D80 3E 1A       0001*M 			LD	A, function
041D82 5B CF       0002*M 			RST.LIL	08h
041D84             0508*  
041D84             0509*  ; ; DEBUG: print chunk size
041D84             0510*  ;     push de
041D84             0511*  ;     pop hl
041D84             0512*  ;     call printDec
041D84             0513*  ;     call printNewLine
041D84             0514*  
041D84             0515*  ; test de for zero bytes read
041D84 21 00 00 00 0516*      ld hl,0
041D88 AF          0517*      xor a ; clear carry
041D89 ED 52       0518*      sbc hl,de
041D8B CA A1 1D 04 0519*      jp z,@close_file
041D8F             0520*  
041D8F             0521*  ; load a vdu buffer from local memory
041D8F             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041D8F 2A C3 1C 04 0523*      ld hl,(bufferId0)
041D93 D5          0524*      push de ; chunksize
041D94 C1          0525*      pop bc
041D95 11 00 E0 B7 0526*      ld de,filedata
041D99 CD C9 1C 04 0527*      call vdu_load_buffer
041D9D             0528*  
041D9D             0529*  ; ; print progress breadcrumbs
041D9D             0530*  ;     ld a,'.'
041D9D             0531*  ;     rst.lil 10h
041D9D             0532*  
041D9D             0533*  ; read the next block
041D9D C3 73 1D 04 0534*      jp @read_file
041DA1             0535*  
041DA1             0536*  ; close the file
041DA1             0537*  @close_file:
041DA1 3A AA 1D 04 0538*      ld a,(@filehandle)
041DA5             0539*      MOSCALL mos_fclose
041DA5 3E 0B       0001*M 			LD	A, function
041DA7 5B CF       0002*M 			RST.LIL	08h
041DA9 C9          0540*      ret ; vdu_load_buffer_from_file
041DAA             0541*  
041DAA 00          0542*  @filehandle: db 0 ; file handle
041DAB 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
041DAE             0544*  
041DAE 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
041DB1             0546*  
041DB1             0547*  ; File information structure (FILINFO)
041DB1             0548*  @filinfo:
041DB1 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041DB5 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041DB7 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041DB9 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041DBA 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041DC7 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041EC7             0055       include "vdu_buff.inc"
041EC7             0001*  ; VDP Buffered Commands API
041EC7             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
041EC7             0003*  
041EC7             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041EC7             0005*  ; This command is used to store a data block (a sequence of bytes)
041EC7             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
041EC7             0007*  ; It could be a sequence of VDU commands which can be executed
041EC7             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
041EC7             0009*  ; When used for a sequence of VDU commands, this effectively
041EC7             0010*  ; allows for functions or stored procedures to be created.
041EC7             0011*  
041EC7             0012*  ; This is the most common command to use to send data to the VDP.
041EC7             0013*  ; Typically you will call command 2 first to ensure that the
041EC7             0014*  ; buffer is empty, and then make a series of calls to this command
041EC7             0015*  ; to send data to the buffer.
041EC7             0016*  
041EC7             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
041EC7             0018*  ; write to. Writing to the same buffer ID multiple times will add
041EC7             0019*  ; new blocks to that buffer. This allows a buffer to be built up
041EC7             0020*  ; over time, essentially allowing for a command to be sent across
041EC7             0021*  ; to the VDP in multiple separate packets.
041EC7             0022*  
041EC7             0023*  ; Whilst the length of an individual block added using this command
041EC7             0024*  ; is restricted to 65535 bytes (as the largest value that can be
041EC7             0025*  ; sent in a 16-bit number) the total size of a buffer is not
041EC7             0026*  ; restricted to this size, as multiple blocks can be added to a
041EC7             0027*  ; buffer. Given how long it takes to send data to the VDP it is
041EC7             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
041EC7             0029*  ; data or less at a time.
041EC7             0030*  
041EC7             0031*  ; As writing to a single buffer ID is cumulative with this command,
041EC7             0032*  ; care should be taken to ensure that the buffer is cleared out
041EC7             0033*  ; before writing to it.
041EC7             0034*  
041EC7             0035*  ; When building up a complex sequence of commands it is often
041EC7             0036*  ; advisable to use multiple blocks within a buffer. Typically
041EC7             0037*  ; this is easier to code, as otherwise working out exactly how
041EC7             0038*  ; many bytes long a command sequence is can be can be onerously
041EC7             0039*  ; difficult. It is also easier to modify a command sequences that
041EC7             0040*  ; are broken up into multiple blocks.
041EC7             0041*  
041EC7             0042*  ; As mentioned above it is advisable to send large pieces of data,
041EC7             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
041EC7             0044*  ; each packet of data sent to a buffer, the user can then perform
041EC7             0045*  ; other operations, such as updating the screen to indicate
041EC7             0046*  ; progress. This allows for long-running operations to be performed
041EC7             0047*  ; without blocking the screen, and larger amounts of data to be
041EC7             0048*  ; transferred over to the VDP than may otherwise be practical given
041EC7             0049*  ; the limitations of the eZ80.
041EC7             0050*  
041EC7             0051*  ; If a buffer ID of 65535 is used then this command will be
041EC7             0052*  ; ignored, and the data discarded. This is because this buffer ID
041EC7             0053*  ; is reserved for special functions.
041EC7             0054*  
041EC7             0055*  ; Using buffers for bitmaps
041EC7             0056*  
041EC7             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
041EC7             0058*  ; they cannot be used if they are spread over multiple blocks.
041EC7             0059*  ; To use a bitmap its data must be in a single contiguous block,
041EC7             0060*  ; and this is achieved by using the “consolidate” command &0E.
041EC7             0061*  
041EC7             0062*  ; Once you have a block that is ready to be used for a bitmap,
041EC7             0063*  ; the buffer must be selected, and then a bitmap created for that
041EC7             0064*  ; buffer using the bitmap and sprites API. This is done with the
041EC7             0065*  ; following commands:
041EC7             0066*  
041EC7             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
041EC7             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
041EC7             0069*  
041EC7             0070*  ; Until the “create bitmap” call has been made the buffer cannot
041EC7             0071*  ; be used as a bitmap. That is because the system needs to
041EC7             0072*  ; understand the dimensions of the bitmap, as well as the format
041EC7             0073*  ; of the data. Usually this only needs to be done once. The format
041EC7             0074*  ; is given as an 8-bit value, with the following values supported:
041EC7             0075*  ; Value 	Type 	Description
041EC7             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
041EC7             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
041EC7             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
041EC7             0079*  
041EC7             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
041EC7             0081*  ; and these are automatically stored in buffers numbered 64000-64255
041EC7             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
041EC7             0083*  ; simply a matter of adding 64000. All bitmaps created with that
041EC7             0084*  ; API will be RGBA8888 format.
041EC7             0085*  
041EC7             0086*  ; There is one other additional call added to the bitmap and
041EC7             0087*  ; sprites API, which allows for bitmaps referenced with a
041EC7             0088*  ; buffer ID to be added to sprites. This is done with the
041EC7             0089*  ; following command:
041EC7             0090*  
041EC7             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
041EC7             0092*  
041EC7             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
041EC7             0094*  
041EC7             0095*  ; It should be noted that it is possible to modify the buffer
041EC7             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
041EC7             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
041EC7             0098*  ; can allow you to do things such as changing colours in a bitmap,
041EC7             0099*  ; or flipping an image horizontally or vertically. This will even
041EC7             0100*  ; work on bitmaps that are being used inside sprites.
041EC7             0101*  
041EC7             0102*  ; Using commands targetting a buffer that create new blocks,
041EC7             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
041EC7             0104*  ; and remove it from use.
041EC7             0105*  
041EC7             0106*  ; Using buffers for sound samples
041EC7             0107*  
041EC7             0108*  ; Much like with bitmaps, it is advisable to send samples over
041EC7             0109*  ; to the VDP in multiple blocks for the same reasons.
041EC7             0110*  
041EC7             0111*  ; In contrast to bitmaps, the sound system can play back samples
041EC7             0112*  ; that are spread over multiple blocks, so there is no need to
041EC7             0113*  ; consolidate buffers. As a result of this, the sample playback
041EC7             0114*  ; system is also more tolerant of modifications being made to
041EC7             0115*  ; the buffer after a sample has been created from it, even if
041EC7             0116*  ; the sample is currently playing. It should be noted that
041EC7             0117*  ; splitting a buffer may result in unexpected behaviour if
041EC7             0118*  ; the sample is currently playing, such as skipping to other
041EC7             0119*  ; parts of the sample.
041EC7             0120*  
041EC7             0121*  ; Once you have a buffer that contains block(s) that are ready
041EC7             0122*  ; to be used for a sound sample, the following command must be
041EC7             0123*  ; used to indicate that a sample should be created from that buffer:
041EC7             0124*  
041EC7             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
041EC7             0126*  
041EC7             0127*  ; The format parameter is an 8-bit value that indicates the
041EC7             0128*  ; format of the sample data. The following values are supported:
041EC7             0129*  ; Value 	Description
041EC7             0130*  ; 0 	8-bit signed, 16KHz
041EC7             0131*  ; 1 	8-bit unsigned, 16KHz
041EC7             0132*  
041EC7             0133*  ; Once a sample has been created in this way, the sample can
041EC7             0134*  ; be selected for use on a channel using the following command:
041EC7             0135*  
041EC7             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
041EC7             0137*  
041EC7             0138*  ; Samples uploaded using the existing “load sample” command
041EC7             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
041EC7             0140*  ; are also stored in buffers automatically. A sample number using this system is in
041EC7             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
041EC7             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
041EC7             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
041EC7             0144*  ; buffer 64257, and so on.
041EC7             0145*  ; Command 1: Call a buffer
041EC7             0146*  
041EC7             0147*  ; VDU 23, 0 &A0, bufferId; 1
041EC7             0148*  
041EC7             0149*  ; This command will attempt to execute all of the commands
041EC7             0150*  ; stored in the buffer with the given ID. If the buffer does
041EC7             0151*  ; not exist, or is empty, then this command will do nothing.
041EC7             0152*  
041EC7             0153*  ; Essentially, this command passes the contents of the buffer
041EC7             0154*  ; to the VDP’s VDU command processor system, and executes them
041EC7             0155*  ; as if they were sent directly to the VDP.
041EC7             0156*  
041EC7             0157*  ; As noted against command 0, it is possible to build up a
041EC7             0158*  ; buffer over time by sending across multiple commands to write
041EC7             0159*  ; to the same buffer ID. When calling a buffer with multiple
041EC7             0160*  ; blocks, the blocks are executed in order.
041EC7             0161*  
041EC7             0162*  ; Care should be taken when using this command within a buffer,
041EC7             0163*  ; as it is possible to create an infinite loop. For instance,
041EC7             0164*  ; if a buffer contains a command to call itself, then this will
041EC7             0165*  ; result in an infinite loop. This will cause the VDP to hang,
041EC7             0166*  ; and the only way to recover from this is to reset the VDP.
041EC7             0167*  
041EC7             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
041EC7             0169*  ; to be executed. This can be useful for creating loops within
041EC7             0170*  ; a buffer. It will be ignored if used outside of a buffered
041EC7             0171*  ; command sequence.
041EC7             0172*  
041EC7             0173*  ; Command 2: Clear a buffer
041EC7             0174*  ; VDU 23, 0 &A0, bufferId; 2
041EC7             0175*  
041EC7             0176*  ; This command will clear the buffer with the given ID. If
041EC7             0177*  ; the buffer does not exist then this command will do nothing.
041EC7             0178*  
041EC7             0179*  ; Please note that this clears out all of the blocks sent to
041EC7             0180*  ; a buffer via command 0, not just the last one. i.e. if you
041EC7             0181*  ; have built up a buffer over time by sending multiple commands
041EC7             0182*  ; to write to the same buffer ID, this command will clear out
041EC7             0183*  ; all of those commands.
041EC7             0184*  
041EC7             0185*  ; Calling this command with a bufferId value of -1 (65535) will
041EC7             0186*  ; clear out all buffers.
041EC7             0187*  
041EC7             0188*  ; Command 3: Create a writeable buffer
041EC7             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
041EC7             0190*  ; This command will create a new writeable buffer with the given
041EC7             0191*  ; ID. If a buffer with the given ID already exists then this
041EC7             0192*  ; command will do nothing. This command is primarily intended
041EC7             0193*  ; for use to create a buffer that can be used to capture output
041EC7             0194*  ; using the “set output stream” command (see below), or to store
041EC7             0195*  ; data that can be used for other commands.
041EC7             0196*  
041EC7             0197*  ; It is generally quite rare that you will want to use this
041EC7             0198*  ; command. Typically you will instead want to use command 0
041EC7             0199*  ; to write data to a buffer. It is not necessary to use this
041EC7             0200*  ; command before using command 0, and indeed doing so will
041EC7             0201*  ; lead to errors as you will end up with two blocks in the
041EC7             0202*  ; buffer, the first of which will be empty. If you do wish
041EC7             0203*  ; to use this command to create a buffer for data and then
041EC7             0204*  ; write to it, you would need to use operation 2 of command 5,
041EC7             0205*  ; the “set” operation in the “buffer adjust” command, to set a
041EC7             0206*  ; sequence of bytes in the buffer to the data you want to write.
041EC7             0207*  ; This is not recommended, as it is much easier to just use
041EC7             0208*  ; command 0 to write a data block to a buffer.
041EC7             0209*  
041EC7             0210*  ; This new buffer will be a single empty single block upon
041EC7             0211*  ; creation, containing zeros.
041EC7             0212*  
041EC7             0213*  ; The length parameter is a 16-bit integer that specifies
041EC7             0214*  ; the maximum size of the buffer. This is the maximum number
041EC7             0215*  ; of bytes that can be stored in the buffer. If the buffer
041EC7             0216*  ; is full then no more data can be written to it, and subsequent
041EC7             0217*  ; writes will be ignored.
041EC7             0218*  
041EC7             0219*  ; After creating a buffer with this command it is possible to
041EC7             0220*  ; use command 0 to write further blocks to the buffer, however
041EC7             0221*  ; this is probably not advisable.
041EC7             0222*  
041EC7             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
041EC7             0224*  ; values have special meanings for writable buffers. See command 4.
041EC7             0225*  
041EC7             0226*  ; Command 4: Set output stream to a buffer
041EC7             0227*  ; VDU 23, 0 &A0, bufferId; 4
041EC7             0228*  
041EC7             0229*  ; Sets then current output stream to the buffer with the given ID.
041EC7             0230*  ; With two exceptions, noted below, this needs to be a writable
041EC7             0231*  ; buffer created with command 3. If the buffer does not exist,
041EC7             0232*  ; or the first block within the buffer is not writable, then
041EC7             0233*  ; this command will do nothing.
041EC7             0234*  
041EC7             0235*  ; Following this command, any subsequent VDU commands that send
041EC7             0236*  ; response packets will have those packets written to the specified
041EC7             0237*  ; output buffer. This allows the user to capture the response
041EC7             0238*  ; packets from a command sent to the VDP.
041EC7             0239*  
041EC7             0240*  ; By default, the output stream (for the main VDU command processor)
041EC7             0241*  ; is the communications channel from the VDP to MOS running on the
041EC7             0242*  ; eZ80.
041EC7             0243*  
041EC7             0244*  ; Passing a buffer ID of -1 (65535) to this command will
041EC7             0245*  ; remove/detach the output buffer. From that point onwards,
041EC7             0246*  ; any subsequent VDU commands that send response packets will
041EC7             0247*  ; have those responses discarded/ignored.
041EC7             0248*  
041EC7             0249*  ; Passing a buffer ID of 0 to this command will set the output
041EC7             0250*  ; buffer back to its original value for the current command stream.
041EC7             0251*  ; Typically that will be the communications channel from the VDP to
041EC7             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
041EC7             0253*  ; call has been made.
041EC7             0254*  
041EC7             0255*  ; When used inside a buffered command sequence, this command will
041EC7             0256*  ; only affect the output stream for that sequence of commands, and
041EC7             0257*  ; any other buffered command sequences that are called from within
041EC7             0258*  ; that sequence. Once the buffered command sequence has completed,
041EC7             0259*  ; the output stream will effectively be reset to its original value.
041EC7             0260*  
041EC7             0261*  ; It is strongly recommended to only use this command from within a
041EC7             0262*  ; buffered command sequence. Whilst it is possible to use this
041EC7             0263*  ; command from within a normal VDU command sequence, it is not
041EC7             0264*  ; recommended as it may cause unexpected behaviour. If you do use
041EC7             0265*  ; it in that context, it is very important to remember to restore
041EC7             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
041EC7             0267*  ; future, this command may be disabled from being used outside of
041EC7             0268*  ; a buffered command sequence.)
041EC7             0269*  
041EC7             0270*  ; At present, writable buffers can only be written to until the end
041EC7             0271*  ; of the buffer has been reached; once that happens no more data
041EC7             0272*  ; will be written to the buffer. It is not currently possible to
041EC7             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
041EC7             0274*  ; that the buffer is large enough to capture all of the data that
041EC7             0275*  ; is expected to be written to it. The only current way to “rewind”
041EC7             0276*  ; an output stream would be to clear the buffer and create a new
041EC7             0277*  ; one, and then call set output stream again with the newly created
041EC7             0278*  ; buffer.
041EC7             0279*  
041EC7             0280*  ; Command 5: Adjust buffer contents
041EC7             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041EC7             0282*  
041EC7             0283*  ; This command will adjust the contents of a buffer, at a given
041EC7             0284*  ; offset. The exact nature of the adjustment will depend on the
041EC7             0285*  ; operation used.
041EC7             0286*  
041EC7             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
041EC7             0288*  ; the contents of the current buffer. This will only work if this
041EC7             0289*  ; command is used within a buffered command sequence, otherwise the
041EC7             0290*  ; command will not do anything.
041EC7             0291*  
041EC7             0292*  ; The basic set of adjustment operations are as follows:
041EC7             0293*  ; Operation 	Description
041EC7             0294*  ; 0 	NOT
041EC7             0295*  ; 1 	Negate
041EC7             0296*  ; 2 	Set value
041EC7             0297*  ; 3 	Add
041EC7             0298*  ; 4 	Add with carry
041EC7             0299*  ; 5 	AND
041EC7             0300*  ; 6 	OR
041EC7             0301*  ; 7 	XOR
041EC7             0302*  
041EC7             0303*  ; All of these operations will modify a byte found at the given
041EC7             0304*  ; offset in the buffer. The only exception to that is the “Add with
041EC7             0305*  ; carry” operation, which will also store the “carry” value in the
041EC7             0306*  ; byte at the next offset. With the exception of NOT and Negate,
041EC7             0307*  ; each command requires an operand value to be specified.
041EC7             0308*  
041EC7             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
041EC7             0310*  ; need to use the NOT operation, and so the following command would
041EC7             0311*  ; be used:
041EC7             0312*  
041EC7             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
041EC7             0314*  
041EC7             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
041EC7             0316*  ; to use the Add operation, and so the following command would be
041EC7             0317*  ; used:
041EC7             0318*  
041EC7             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
041EC7             0320*  
041EC7             0321*  ; When using add with carry, the carry value is stored in the byte
041EC7             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
041EC7             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
041EC7             0324*  ; you would need to use the Add with carry operation, and so the
041EC7             0325*  ; following command would be used:
041EC7             0326*  
041EC7             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
041EC7             0328*  
041EC7             0329*  ; Advanced operations
041EC7             0330*  
041EC7             0331*  ; Whilst these operations are useful, they are not particularly
041EC7             0332*  ; powerful as they only operate one one byte at a time, with a
041EC7             0333*  ; fixed operand value, and potentially cannot reach all bytes in
041EC7             0334*  ; a buffer. To address this, the API supports a number of advanced
041EC7             0335*  ; operations.
041EC7             0336*  
041EC7             0337*  ; The operation value used is an 8-bit value that can have bits
041EC7             0338*  ; set to modify the behaviour of the operation. The following bits
041EC7             0339*  ; are defined:
041EC7             0340*  ; Bit 	Description
041EC7             0341*  ; &10 	Use “advanced” offsets
041EC7             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041EC7             0343*  ; &40 	Multiple target values should be adjusted
041EC7             0344*  ; &80 	Multiple operand values should be used
041EC7             0345*  
041EC7             0346*  ; These bits can be combined together to modify the behaviour of
041EC7             0347*  ; the operation.
041EC7             0348*  
041EC7             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
041EC7             0350*  ; offset one byte at a time. When either of the “multiple” variants
041EC7             0351*  ; are used, a 16-bit count must be provided to indicate how many
041EC7             0352*  ; bytes should be altered.
041EC7             0353*  
041EC7             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
041EC7             0355*  ; order, which can allow for buffers that are larger than 64kb
041EC7             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
041EC7             0357*  ; the 16-bit value immediately following the offset is used as a
041EC7             0358*  ; block index number, and the remaining 23-bits of the offset value
041EC7             0359*  ; are used as an offset within that block. When the “advanced”
041EC7             0360*  ; offset mode bit has been set then all offsets associated with
041EC7             0361*  ; this command must be sent as advanced offsets.
041EC7             0362*  
041EC7             0363*  ; The “buffer-fetched value” mode allows for the operand value to
041EC7             0364*  ; be fetched from a buffer. The operand sent as part of the
041EC7             0365*  ; command in this case is a pair of 16-bit values giving the
041EC7             0366*  ; buffer ID and offset to indicate where the actual operand value
041EC7             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
041EC7             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
041EC7             0369*  ; used inside a buffered command sequence. If the advanced offset
041EC7             0370*  ; mode is used, then the operand value is an advanced offset value.
041EC7             0371*  
041EC7             0372*  ; The “multiple target values” mode allows for multiple bytes to
041EC7             0373*  ; be adjusted at once. When this mode is used, the count value
041EC7             0374*  ; must be provided to indicate how many bytes should be adjusted.
041EC7             0375*  ; Unless the “multiple operand values” mode is also used, the
041EC7             0376*  ; operand value is used for all bytes adjusted.
041EC7             0377*  
041EC7             0378*  ; The “multiple operand values” mode allows for multiple operand
041EC7             0379*  ; values to be used. When this mode is used, the count value must
041EC7             0380*  ; be provided to indicate how many operand values should be used.
041EC7             0381*  ; This can allow, for instance, to add together several bytes in a
041EC7             0382*  ; buffer. When this mode is used in conjunction with the “multiple
041EC7             0383*  ; target values” mode, the number of operand values must match the
041EC7             0384*  ; number of target values, and the operation happens one byte at a
041EC7             0385*  ; time.
041EC7             0386*  
041EC7             0387*  ; Some examples of advanced operations are as follows:
041EC7             0388*  
041EC7             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
041EC7             0390*  
041EC7             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
041EC7             0392*  
041EC7             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
041EC7             0394*  ; modifier (&40).
041EC7             0395*  
041EC7             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
041EC7             0397*  
041EC7             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
041EC7             0399*  
041EC7             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
041EC7             0401*  
041EC7             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
041EC7             0403*  
041EC7             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
041EC7             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
041EC7             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
041EC7             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
041EC7             0408*  ; in little-endian order. As the top bit of the offset is set, this
041EC7             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
041EC7             0410*  ; Finally the value to write is sent, 42.
041EC7             0411*  
041EC7             0412*  ; An operation like this could be used to set the position as part
041EC7             0413*  ; of a draw command.
041EC7             0414*  
041EC7             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
041EC7             0416*  ; values 1, 2, 3, 4, 5:
041EC7             0417*  
041EC7             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
041EC7             0419*  ; offset 12 (set it to 0)
041EC7             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
041EC7             0421*  
041EC7             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
041EC7             0423*  ; 7 bytes in buffer 4 starting at offset 42:
041EC7             0424*  
041EC7             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
041EC7             0426*  
041EC7             0427*  ; As we are working on a little-endian system, integers longer
041EC7             0428*  ; than one byte are sent with their least significant byte first.
041EC7             0429*  ; This means that the add with carry operation can be used to add
041EC7             0430*  ; together integers of any size, so long as they are the same size.
041EC7             0431*  ; To do this, both the “multiple target values” and “multiple
041EC7             0432*  ; operand values” modes must be used.
041EC7             0433*  
041EC7             0434*  ; The following commands will add together a 16-bit, 24-bit,
041EC7             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
041EC7             0436*  ; in buffer 3 starting at offset 12, and all using the operand
041EC7             0437*  ; value of 42:
041EC7             0438*  
041EC7             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
041EC7             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
041EC7             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
041EC7             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
041EC7             0443*  
041EC7             0444*  ; Take note of how the operand value is padded out with zeros
041EC7             0445*  ; to match the size of the target value. 42; is used as a base
041EC7             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
041EC7             0447*  ; 16-bits to pad it out to the required size. The “carry” value
041EC7             0448*  ; will be stored at the next offset in the target buffer after
041EC7             0449*  ; the complete target value. So for a 16-bit value, the carry
041EC7             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
041EC7             0451*  ; at offset 15, and so on.
041EC7             0452*  
041EC7             0453*  ; Command 6: Conditionally call a buffer
041EC7             0454*  
041EC7             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041EC7             0456*  
041EC7             0457*  ; This command will conditionally call a buffer if the condition
041EC7             0458*  ; operation passes. This command works in a similar manner to the
041EC7             0459*  ; “Adjust buffer contents” command.
041EC7             0460*  
041EC7             0461*  ; With this command a buffer ID of 65535 (-1) is always
041EC7             0462*  ; interpretted as “current buffer”, and so can only be used
041EC7             0463*  ; within a buffered command sequence. If used outside of a
041EC7             0464*  ; buffered command sequence then this command will do nothing.
041EC7             0465*  
041EC7             0466*  ; The basic set of condition operations are as follows:
041EC7             0467*  ; Operation 	Description
041EC7             0468*  ; 0 	Exists (value is non-zero)
041EC7             0469*  ; 1 	Not exists (value is zero)
041EC7             0470*  ; 2 	Equal
041EC7             0471*  ; 3 	Not equal
041EC7             0472*  ; 4 	Less than
041EC7             0473*  ; 5 	Greater than
041EC7             0474*  ; 6 	Less than or equal
041EC7             0475*  ; 7 	Greater than or equal
041EC7             0476*  ; 8 	AND
041EC7             0477*  ; 9 	OR
041EC7             0478*  
041EC7             0479*  ; The value that is being checked is fetched from the specified
041EC7             0480*  ; check buffer ID and offset. With the exception of “Exists” and
041EC7             0481*  ; “Not exists”, each command requires an operand value to be
041EC7             0482*  ; specified to check against.
041EC7             0483*  
041EC7             0484*  ; The operation value used is an 8-bit value that can have bits
041EC7             0485*  ; set to modify the behaviour of the operation. The following bits
041EC7             0486*  ; are defined:
041EC7             0487*  ; Bit value 	Description
041EC7             0488*  ; &10 	Use advanced offsets
041EC7             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041EC7             0490*  
041EC7             0491*  ; These modifiers can be combined together to modify the behaviour
041EC7             0492*  ; of the operation.
041EC7             0493*  
041EC7             0494*  ; At this time, unlike with the “adjust” command, multiple target
041EC7             0495*  ; values and multiple operand values are not supported. All
041EC7             0496*  ; comparisons are therefore only conducted on single 8-bit values.
041EC7             0497*  ; (If comparisons of 16-bit values are required, multiple calls
041EC7             0498*  ; can be combined.) Support for them may be added in the future.
041EC7             0499*  
041EC7             0500*  ; The AND and OR operations are logical operations, and so the
041EC7             0501*  ; operand value is used as a boolean value. Any non-zero value is
041EC7             0502*  ; considered to be true, and zero is considered to be false. These
041EC7             0503*  ; operations therefore are most useful when used with buffer-fetched
041EC7             0504*  ; operand values (operations &28, &29, &38 and &39).
041EC7             0505*  
041EC7             0506*  ; Some examples of condition operations are as follows:
041EC7             0507*  
041EC7             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
041EC7             0509*  ; (is non-zero):
041EC7             0510*  
041EC7             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041EC7             0512*  
041EC7             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
041EC7             0514*  ; exist (is zero):
041EC7             0515*  
041EC7             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041EC7             0517*  
041EC7             0518*  ; Combining the above two examples is effectively equivalent to
041EC7             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
041EC7             0520*  
041EC7             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041EC7             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041EC7             0523*  
041EC7             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
041EC7             0525*  
041EC7             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
041EC7             0527*  
041EC7             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
041EC7             0529*  ; the value in buffer 2 at offset 8:
041EC7             0530*  
041EC7             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
041EC7             0532*  
041EC7             0533*  ; Command 7: Jump to a buffer
041EC7             0534*  
041EC7             0535*  ; VDU 23, 0, &A0, bufferId; 7
041EC7             0536*  
041EC7             0537*  ; This command will jump to the buffer with the given ID. If
041EC7             0538*  ; the buffer does not exist, or is empty, then this command will
041EC7             0539*  ; do nothing.
041EC7             0540*  
041EC7             0541*  ; This essentially works the same as the call command (command 1),
041EC7             0542*  ;  except that it does not return to the caller. This command is
041EC7             0543*  ;  therefore useful for creating loops.
041EC7             0544*  
041EC7             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
041EC7             0546*  ; treated as a “jump to end of current buffer”. This will return
041EC7             0547*  ; execution to the caller, and can be useful for exiting a loop.
041EC7             0548*  
041EC7             0549*  ; ## Command 8: Conditional Jump to a buffer
041EC7             0550*  
041EC7             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041EC7             0552*  
041EC7             0553*  ; This command operates in a similar manner to the “Conditionally
041EC7             0554*  ; call a buffer” command (command 6), except that it will jump to
041EC7             0555*  ; the buffer if the condition operation passes.
041EC7             0556*  
041EC7             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
041EC7             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
041EC7             0559*  ; Command 9: Jump to an offset in a buffer
041EC7             0560*  
041EC7             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041EC7             0562*  
041EC7             0563*  ; This command will jump to the given offset in the buffer with the
041EC7             0564*  ; given ID. If the buffer does not exist, or is empty, then this
041EC7             0565*  ; command will do nothing.
041EC7             0566*  
041EC7             0567*  ; The offset in this command is always an “advanced” offset, given
041EC7             0568*  ; as a 24-bit value in little-endian order. As with other uses of
041EC7             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
041EC7             0570*  ; offset value, a block number must also be provided.
041EC7             0571*  
041EC7             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
041EC7             0573*  ; meaning “jump within current buffer”. This can be useful for
041EC7             0574*  ; creating loops within a buffer, or when building up command
041EC7             0575*  ; sequences that may be copied across multiple buffers.
041EC7             0576*  
041EC7             0577*  ; Jumping to an offset that is beyond the end of the buffer is
041EC7             0578*  ; equivalent to jumping to the end of the buffer.
041EC7             0579*  ; Command 10: Conditional jump to an offset in a buffer
041EC7             0580*  
041EC7             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041EC7             0582*  
041EC7             0583*  ; A conditional jump with an offset works in a similar manner to
041EC7             0584*  ; the “Conditional call a buffer” command (command 6), except that
041EC7             0585*  ; it will jump to the given offset in the buffer if the condition
041EC7             0586*  ; operation passes.
041EC7             0587*  
041EC7             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
041EC7             0589*  ; the offset in this command is always an “advanced” offset, given
041EC7             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
041EC7             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
041EC7             0592*  ; treated as meaning “jump within current buffer”.
041EC7             0593*  ; Command 11: Call buffer with an offset
041EC7             0594*  
041EC7             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041EC7             0596*  
041EC7             0597*  ; Works just like “Call a buffer” (command 1), except that it also
041EC7             0598*  ; accepts an advanced offset.
041EC7             0599*  
041EC7             0600*  ; Command 12: Conditional call buffer with an offset
041EC7             0601*  
041EC7             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
041EC7             0603*  
041EC7             0604*  ; Works just like the “Conditional call a buffer” command
041EC7             0605*  ; (command 6), except that it also accepts an advanced offset.
041EC7             0606*  
041EC7             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
041EC7             0608*  
041EC7             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
041EC7             0610*  
041EC7             0611*  ; This command will copy the contents of multiple buffers into a
041EC7             0612*  ; single buffer. The buffers to copy from are specified as a list
041EC7             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
041EC7             0614*  ; buffers are copied in the order they are specified.
041EC7             0615*  
041EC7             0616*  ; This is a block-wise copy, so the blocks from the source buffers
041EC7             0617*  ; are copied into the target buffer. The blocks are copied in the
041EC7             0618*  ; order they are found in the source buffers.
041EC7             0619*  
041EC7             0620*  ; The target buffer will be overwritten with the contents of the
041EC7             0621*  ; source buffers. This will not be done however until after all the
041EC7             0622*  ; data has been gathered and copied. The target buffer can therefore
041EC7             0623*  ; included in the list of the source buffers.
041EC7             0624*  
041EC7             0625*  ; If a source buffer that does not exist is specified, or a source
041EC7             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
041EC7             0627*  
041EC7             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
041EC7             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
041EC7             0630*  ; copied multiple times into the target buffer.
041EC7             0631*  
041EC7             0632*  ; If there is insufficient memory available on the VDP to complete
041EC7             0633*  ; this command then it will fail, and the target buffer will be
041EC7             0634*  ; left unchanged.
041EC7             0635*  
041EC7             0636*  
041EC7             0637*  ; Command 14: Consolidate blocks in a buffer
041EC7             0638*  
041EC7             0639*  ; VDU 23, 0, &A0, bufferId; 14
041EC7             0640*  
041EC7             0641*  ; Takes all the blocks in a buffer and consolidates them into a
041EC7             0642*  ; single block. This is useful for bitmaps, as it allows for a
041EC7             0643*  ; bitmap to be built up over time in multiple blocks, and then
041EC7             0644*  ; consolidated into a single block for use as a bitmap.
041EC7             0645*  
041EC7             0646*  ; If there is insufficient memory available on the VDP to complete
041EC7             0647*  ; this command then it will fail, and the buffer will be left
041EC7             0648*  ; unchanged.
041EC7             0649*  
041EC7             0650*  ; Command 15: Split a buffer into multiple blocks
041EC7             0651*  
041EC7             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
041EC7             0653*  
041EC7             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
041EC7             0655*  ; is a 16-bit integer that specifies the target size of each block.
041EC7             0656*  ; If the source data is not a multiple of the block size then the
041EC7             0657*  ; last block will be smaller than the specified block size.
041EC7             0658*  
041EC7             0659*  ; If this command is used on a buffer that is already split into
041EC7             0660*  ; multiple blocks, then the blocks will be consolidated first,
041EC7             0661*  ; and then re-split into the new block size.
041EC7             0662*  
041EC7             0663*  ; If there is insufficient memory available on the VDP to complete
041EC7             0664*  ; this command then it will fail, and the buffer will be left
041EC7             0665*  ; unchanged.
041EC7             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
041EC7             0667*  ; multiple buffers
041EC7             0668*  
041EC7             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
041EC7             0670*  
041EC7             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
041EC7             0672*  ; then spreads the resultant blocks across the target buffers.
041EC7             0673*  ; The target buffers are specified as a list of buffer IDs,
041EC7             0674*  ; terminated by a buffer ID of -1 (65535).
041EC7             0675*  
041EC7             0676*  ; The blocks are spread across the target buffers in the order
041EC7             0677*  ; they are specified, and the spread will loop around the buffers
041EC7             0678*  ; until all the blocks have been distributed. The target buffers
041EC7             0679*  ; will be cleared out before the blocks are spread across them.
041EC7             0680*  
041EC7             0681*  ; What this means is that if the source buffer is, let’s say,
041EC7             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
041EC7             0683*  ; then we will end up with 10 blocks. If we then spread those
041EC7             0684*  ; blocks across 3 target buffers, then the first buffer will
041EC7             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
041EC7             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
041EC7             0687*  ; blocks 3, 6 and 9.
041EC7             0688*  
041EC7             0689*  ; This command attempts to ensure that, in the event of
041EC7             0690*  ; insufficient memory being available on the VDP to complete
041EC7             0691*  ; the command, it will leave the targets as they were before
041EC7             0692*  ; the command was executed. However this may not always be
041EC7             0693*  ; possible. The first step of this command is to consolidate
041EC7             0694*  ; the source buffer into a single block, and this may fail from
041EC7             0695*  ; insufficient memory. If that happens then all the buffers will
041EC7             0696*  ; be left as they were. After this however the target buffers
041EC7             0697*  ; will be cleared. If there is insufficient memory to successfully
041EC7             0698*  ; split the buffer into multiple blocks then the call will exit,
041EC7             0699*  ; and the target buffers will be left empty.
041EC7             0700*  ; Command 17: Split a buffer and spread across blocks, starting
041EC7             0701*  ; at target buffer ID
041EC7             0702*  
041EC7             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
041EC7             0704*  
041EC7             0705*  ; As per the above two commands, this will split a buffer into
041EC7             0706*  ; multiple blocks. It will then spread the blocks across buffers
041EC7             0707*  ; starting at the target buffer ID, incrementing the target buffer
041EC7             0708*  ; ID until all the blocks have been distributed.
041EC7             0709*  
041EC7             0710*  ; Target blocks will be cleared before a block is stored in them.
041EC7             0711*  ; Each target will contain a single block. The exception to this
041EC7             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
041EC7             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
041EC7             0714*  ; will be placed into buffer 65534.
041EC7             0715*  
041EC7             0716*  ; With this command if there is insufficient memory available on
041EC7             0717*  ; the VDP to complete the command then it will fail, and the target
041EC7             0718*  ; buffers will be left unchanged.
041EC7             0719*  
041EC7             0720*  ; Command 18: Split a buffer into blocks by width
041EC7             0721*  
041EC7             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
041EC7             0723*  
041EC7             0724*  ; This command splits a buffer into a given number of blocks by
041EC7             0725*  ; first of all splitting the buffer into blocks of a given width
041EC7             0726*  ; (number of bytes), and then consolidating those blocks into the
041EC7             0727*  ; given number of blocks.
041EC7             0728*  
041EC7             0729*  ; This is useful for splitting a bitmap into a number of separate
041EC7             0730*  ; columns, which can then be manipulated individually. This can be
041EC7             0731*  ; useful for dealing with sprite sheets.
041EC7             0732*  ; Command 19: Split by width into blocks and spread across target
041EC7             0733*  ; buffers
041EC7             0734*  
041EC7             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
041EC7             0736*  
041EC7             0737*  ; This command essentially operates the same as command 18, but the
041EC7             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
041EC7             0739*  
041EC7             0740*  ; Command 20: Split by width into blocks and spread across blocks
041EC7             0741*  ; starting at target buffer ID
041EC7             0742*  
041EC7             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
041EC7             0744*  
041EC7             0745*  ; This command essentially operates the same as command 18, but
041EC7             0746*  ; the generated blocks are spread across blocks starting at the
041EC7             0747*  ; target buffer ID, as per command 17.
041EC7             0748*  
041EC7             0749*  ; Command 21: Spread blocks from a buffer across multiple target
041EC7             0750*  ; buffers
041EC7             0751*  
041EC7             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
041EC7             0753*  
041EC7             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
041EC7             0755*  ; The target buffers are specified as a list of buffer IDs,
041EC7             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
041EC7             0757*  ; across the target buffers in the order they are specified, and
041EC7             0758*  ; the spread will loop around the buffers until all the blocks have
041EC7             0759*  ; been distributed.
041EC7             0760*  
041EC7             0761*  ; It should be noted that this command does not copy the blocks,
041EC7             0762*  ; and nor does it move them. Unless the source buffer has been
041EC7             0763*  ; included in the list of targets, it will remain completely
041EC7             0764*  ; intact. The blocks distributed across the target buffers will
041EC7             0765*  ; point to the same memory as the blocks in the source buffer.
041EC7             0766*  ; Operations to modify data in the source buffer will also modify
041EC7             0767*  ; the data in the target buffers. Clearing the source buffer
041EC7             0768*  ; however will not clear the target buffers.
041EC7             0769*  
041EC7             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
041EC7             0771*  ; at target buffer ID
041EC7             0772*  
041EC7             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
041EC7             0774*  
041EC7             0775*  ; Spreads the blocks from a buffer across blocks starting at
041EC7             0776*  ; the target buffer ID.
041EC7             0777*  
041EC7             0778*  ; This essentially works the same as command 21, and the same
041EC7             0779*  ; notes about copying and moving blocks apply. Blocks are spread
041EC7             0780*  ; in the same manner as commands 17 and 20.
041EC7             0781*  
041EC7             0782*  ; Command 23: Reverse the order of blocks in a buffer
041EC7             0783*  
041EC7             0784*  ; VDU 23, 0, &A0, bufferId; 23
041EC7             0785*  
041EC7             0786*  ; Reverses the order of the blocks in a buffer.
041EC7             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
041EC7             0788*  
041EC7             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041EC7             0790*  
041EC7             0791*  ; Reverses the order of the data within the blocks of a buffer.
041EC7             0792*  ; The options parameter is an 8-bit value that can have bits set
041EC7             0793*  ; to modify the behaviour of the operation. The following bits
041EC7             0794*  ; are defined:
041EC7             0795*  ; Bit value 	Description
041EC7             0796*  ; 1 	Values are 16-bits in size
041EC7             0797*  ; 2 	Values are 32-bits in size
041EC7             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
041EC7             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
041EC7             0800*  ; 8 	Reverse blocks
041EC7             0801*  
041EC7             0802*  ; These modifiers can be combined together to modify the behaviour
041EC7             0803*  ; of the operation.
041EC7             0804*  
041EC7             0805*  ; If no value size is set in the options (i.e. the value of the
041EC7             0806*  ; bottom two bits of the options is zero) then the value size is
041EC7             0807*  ; assumed to be 8-bits.
041EC7             0808*  
041EC7             0809*  ; It is probably easiest to understand what this operation is
041EC7             0810*  ; capable of by going through some examples of how it can be used
041EC7             0811*  ; to manipulate bitmaps. The VDP supports two different formats
041EC7             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
041EC7             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
041EC7             0814*  ; pixel.
041EC7             0815*  
041EC7             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
041EC7             0817*  ; degrees, which can be done by just reversing the order of
041EC7             0818*  ; bytes in the buffer:
041EC7             0819*  
041EC7             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
041EC7             0821*  
041EC7             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
041EC7             0823*  ; little more complex, as each pixel is made up of 4 bytes.
041EC7             0824*  ; However with this command it is still a simple operation, as
041EC7             0825*  ; we can just reverse the order of the 32-bit values that make
041EC7             0826*  ; up the bitmap by using an options value of 2:
041EC7             0827*  
041EC7             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
041EC7             0829*  
041EC7             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
041EC7             0831*  ; the order of rows of pixels. To do this we can set a custom
041EC7             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
041EC7             0833*  ; bitmap we can just set a custom value size to our bitmap width:
041EC7             0834*  
041EC7             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
041EC7             0836*  
041EC7             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
041EC7             0838*  ; our width by 4:
041EC7             0839*  
041EC7             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
041EC7             0841*  
041EC7             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
041EC7             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
041EC7             0844*  ; just set a custom chunk size to our bitmap width:
041EC7             0845*  
041EC7             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
041EC7             0847*  
041EC7             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
041EC7             0849*  ; 32-bit values as well as a custom chunk size:
041EC7             0850*  
041EC7             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
041EC7             0852*  
041EC7             0853*  ; Command 25: Copy blocks from multiple buffers by reference
041EC7             0854*  
041EC7             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
041EC7             0856*  
041EC7             0857*  ; This command is essentially a version of command 13 that copies
041EC7             0858*  ; blocks by reference rather than by value. The parameters for
041EC7             0859*  ; this command are the same as for command 13, and the same rules
041EC7             0860*  ; apply.
041EC7             0861*  
041EC7             0862*  ; If the target buffer is included in the list of source buffers
041EC7             0863*  ; then it will be skipped to prevent a reference loop.
041EC7             0864*  
041EC7             0865*  ; Copying by reference means that the blocks in the target buffer
041EC7             0866*  ; will point to the same memory as the blocks in the source
041EC7             0867*  ; buffers. Operations to modify data blocks in the source buffers
041EC7             0868*  ; will therefore also modify those blocks in the target buffer.
041EC7             0869*  ; Clearing the source buffers will not clear the target buffer -
041EC7             0870*  ; it will still point to the original data blocks. Data blocks
041EC7             0871*  ; are only freed from memory when no buffers are left with any
041EC7             0872*  ; references to them.
041EC7             0873*  
041EC7             0874*  ; Buffers that get consolidated become new blocks, so will lose
041EC7             0875*  ; their links to the original blocks, thus after a “consolidate”
041EC7             0876*  ; operation modifications to the original blocks will no longer be
041EC7             0877*  ; reflected in the consolidated buffer.
041EC7             0878*  
041EC7             0879*  ; This command is useful to construct a single buffer from multiple
041EC7             0880*  ; sources without the copy overhead, which can be costly. For
041EC7             0881*  ; example, this can be useful for constructing a bitmap from
041EC7             0882*  ; multiple constituent parts before consolidating it into a
041EC7             0883*  ; single block. In such an example, using command 13 instead
041EC7             0884*  ; would first make a copy of the contents of the source buffers,
041EC7             0885*  ; and then consolidate them into a single block. Using this
041EC7             0886*  ; command does not make that first copy, and so would be faster.
041EC7             0887*  
041EC7             0888*  ; This command is also useful for creating multiple buffers that
041EC7             0889*  ; all point to the same data.
041EC7             0890*  
041EC7             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
041EC7             0892*  
041EC7             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
041EC7             0056       include "vdu_plot.inc"
041EC7             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041EC7             0002*  ; PLOT code 	(Decimal) 	Effect
041EC7             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
041EC7             0004*  plot_sl_both: equ 0x00
041EC7             0005*  
041EC7             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
041EC7             0007*  plot_sl_first: equ 0x08
041EC7             0008*  
041EC7             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041EC7             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041EC7             0011*  
041EC7             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
041EC7             0013*  plot_sl_last: equ 0x20
041EC7             0014*  
041EC7             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
041EC7             0016*  plot_sl_none: equ 0x28
041EC7             0017*  
041EC7             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041EC7             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041EC7             0020*  
041EC7             0021*  ; &40-&47 	64-71 	Point plot
041EC7             0022*  plot_pt: equ 0x40
041EC7             0023*  
041EC7             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041EC7             0025*  plot_lf_lr_non_bg: equ 0x48
041EC7             0026*  
041EC7             0027*  ; &50-&57 	80-87 	Triangle fill
041EC7             0028*  plot_tf: equ 0x50
041EC7             0029*  
041EC7             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
041EC7             0031*  plot_lf_r_bg: equ 0x58
041EC7             0032*  
041EC7             0033*  ; &60-&67 	96-103 	Rectangle fill
041EC7             0034*  plot_rf: equ 0x60
041EC7             0035*  
041EC7             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041EC7             0037*  plot_lf_lr_fg: equ 0x60
041EC7             0038*  
041EC7             0039*  ; &70-&77 	112-119 	Parallelogram fill
041EC7             0040*  plot_pf: equ 0x70
041EC7             0041*  
041EC7             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041EC7             0043*  plot_lf_r_non_fg: equ 0x78
041EC7             0044*  
041EC7             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
041EC7             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041EC7             0047*  
041EC7             0048*  ; &90-&97 	144-151 	Circle outline
041EC7             0049*  plot_co: equ 0x90
041EC7             0050*  
041EC7             0051*  ; &98-&9F 	152-159 	Circle fill
041EC7             0052*  plot_cf: equ 0x98
041EC7             0053*  
041EC7             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
041EC7             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
041EC7             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
041EC7             0057*  
041EC7             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
041EC7             0059*  plot_rcm: equ 0xB8
041EC7             0060*  
041EC7             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041EC7             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041EC7             0063*  ; &D0-&D7 	208-215 	Not defined
041EC7             0064*  ; &D8-&DF 	216-223 	Not defined
041EC7             0065*  ; &E0-&E7 	224-231 	Not defined
041EC7             0066*  
041EC7             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
041EC7             0068*  plot_bmp: equ 0xE8
041EC7             0069*  
041EC7             0070*  ; &F0-&F7 	240-247 	Not defined
041EC7             0071*  ; &F8-&FF 	248-255 	Not defined
041EC7             0072*  
041EC7             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041EC7             0074*  ; Agon Console8 VDP 2.2.0
041EC7             0075*  
041EC7             0076*  ; Within each group of eight plot codes, the effects are as follows:
041EC7             0077*  ; Plot code 	Effect
041EC7             0078*  ; 0 	Move relative
041EC7             0079*  mv_rel: equ 0
041EC7             0080*  
041EC7             0081*  ; 1 	Plot relative in current foreground colour
041EC7             0082*  dr_rel_fg: equ 1
041EC7             0083*  
041EC7             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
041EC7             0085*  ; 3 	Plot relative in current background colour
041EC7             0086*  dr_rel_bg: equ 3
041EC7             0087*  
041EC7             0088*  ; 4 	Move absolute
041EC7             0089*  mv_abs: equ 4
041EC7             0090*  
041EC7             0091*  ; 5 	Plot absolute in current foreground colour
041EC7             0092*  dr_abs_fg: equ 5
041EC7             0093*  
041EC7             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
041EC7             0095*  ; 7 	Plot absolute in current background colour
041EC7             0096*  dr_abs_bg: equ 7
041EC7             0097*  
041EC7             0098*  ; Codes 0-3 use the position data provided as part of the command
041EC7             0099*  ; as a relative position, adding the position given to the current
041EC7             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
041EC7             0101*  ; as part of the command as an absolute position, setting the current
041EC7             0102*  ; graphical cursor position to the position given.
041EC7             0103*  
041EC7             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041EC7             0105*  ; current pixel colour. These operations cannot currently be supported
041EC7             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
041EC7             0107*  ; supported. Support for these codes may be added in a future version
041EC7             0108*  ; of the VDP firmware.
041EC7             0109*  
041EC7             0110*  ; 16 colour palette constants
041EC7             0111*  c_black: equ 0
041EC7             0112*  c_red_dk: equ 1
041EC7             0113*  c_green_dk: equ 2
041EC7             0114*  c_yellow_dk: equ 3
041EC7             0115*  c_blue_dk: equ 4
041EC7             0116*  c_magenta_dk: equ 5
041EC7             0117*  c_cyan_dk: equ 6
041EC7             0118*  c_grey: equ 7
041EC7             0119*  c_grey_dk: equ 8
041EC7             0120*  c_red: equ 9
041EC7             0121*  c_green: equ 10
041EC7             0122*  c_yellow: equ 11
041EC7             0123*  c_blue: equ 12
041EC7             0124*  c_magenta: equ 13
041EC7             0125*  c_cyan: equ 14
041EC7             0126*  c_white: equ 15
041EC7             0127*  
041EC7             0128*  ; VDU 25, mode, x; y;: PLOT command
041EC7             0129*  ; inputs: a=mode, bc=x0, de=y0
041EC7             0130*  vdu_plot:
041EC7 32 E1 1E 04 0131*      ld (@mode),a
041ECB ED 43 E2 1E 0132*      ld (@x0),bc
       04          
041ED0 ED 53 E4 1E 0133*      ld (@y0),de
       04          
041ED5 21 E0 1E 04 0134*  	ld hl,@cmd
041ED9 01 06 00 00 0135*  	ld bc,@end-@cmd
041EDD 5B DF       0136*  	rst.lil $18
041EDF C9          0137*  	ret
041EE0 19          0138*  @cmd:   db 25
041EE1 00          0139*  @mode:  db 0
041EE2 00 00       0140*  @x0: 	dw 0
041EE4 00 00       0141*  @y0: 	dw 0
041EE6 00          0142*  @end:   db 0 ; extra byte to soak up deu
041EE7             0143*  
041EE7             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041EE7             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
041EE7             0146*  ; VDU 25, mode, x; y;: PLOT command
041EE7             0147*  ; inputs: bc=x0, de=y0
041EE7             0148*  ; prerequisites: vdu_buff_select
041EE7             0149*  vdu_plot_bmp:
041EE7 ED 43 FE 1E 0150*      ld (@x0),bc
       04          
041EEC ED 53 00 1F 0151*      ld (@y0),de
       04          
041EF1 21 FC 1E 04 0152*  	ld hl,@cmd
041EF5 01 06 00 00 0153*  	ld bc,@end-@cmd
041EF9 5B DF       0154*  	rst.lil $18
041EFB C9          0155*  	ret
041EFC 19          0156*  @cmd:   db 25
041EFD ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041EFE 00 00       0158*  @x0: 	dw 0x0000
041F00 00 00       0159*  @y0: 	dw 0x0000
041F02 00          0160*  @end:   db 0x00 ; padding
041F03             0161*  
041F03             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041F03             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
041F03             0164*  ; VDU 25, mode, x; y;: PLOT command
041F03             0165*  ; inputs: bc=x0, de=y0
041F03             0166*  ; USING 16.8 FIXED POINT COORDINATES
041F03             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041F03             0168*  ;   the fractional portiion of the inputs are truncated
041F03             0169*  ;   leaving only the 16-bit integer portion
041F03             0170*  ; prerequisites: vdu_buff_select
041F03             0171*  vdu_plot_bmp168:
041F03             0172*  ; populate in the reverse of normal to keep the
041F03             0173*  ; inputs from stomping on each other
041F03 ED 53 21 1F 0174*      ld (@y0-1),de
       04          
041F08 ED 43 1F 1F 0175*      ld (@x0-1),bc
       04          
041F0D 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041F0F 32 1F 1F 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041F13 21 1E 1F 04 0178*  	ld hl,@cmd
041F17 01 06 00 00 0179*  	ld bc,@end-@cmd
041F1B 5B DF       0180*  	rst.lil $18
041F1D C9          0181*  	ret
041F1E 19          0182*  @cmd:   db 25
041F1F ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041F20 00 00       0184*  @x0: 	dw 0x0000
041F22 00 00       0185*  @y0: 	dw 0x0000
041F24             0186*  @end:  ; no padding required b/c we shifted de right
041F24             0187*  
041F24             0188*  ; draw a filled rectangle
041F24             0189*  vdu_plot_rf:
041F24 ED 43 4B 1F 0190*      ld (@x0),bc
       04          
041F29 ED 53 4D 1F 0191*      ld (@y0),de
       04          
041F2E DD 22 51 1F 0192*      ld (@x1),ix
       04          
041F33 FD 22 53 1F 0193*      ld (@y1),iy
       04          
041F38 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041F3A 32 4F 1F 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F3E 21 49 1F 04 0196*  	ld hl,@cmd0
041F42 01 0C 00 00 0197*  	ld bc,@end-@cmd0
041F46 5B DF       0198*  	rst.lil $18
041F48 C9          0199*      ret
041F49 19          0200*  @cmd0:  db 25 ; plot
041F4A 04          0201*  @arg0:  db plot_sl_both+mv_abs
041F4B 00 00       0202*  @x0:    dw 0x0000
041F4D 00 00       0203*  @y0:    dw 0x0000
041F4F 19          0204*  @cmd1:  db 25 ; plot
041F50 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041F51 00 00       0206*  @x1:    dw 0x0000
041F53 00 00       0207*  @y1:    dw 0x0000
041F55 00          0208*  @end:   db 0x00 ; padding
041F56             0209*  
041F56             0210*  ; draw a filled circle
041F56             0211*  vdu_plot_cf:
041F56 ED 43 7D 1F 0212*      ld (@x0),bc
       04          
041F5B ED 53 7F 1F 0213*      ld (@y0),de
       04          
041F60 DD 22 83 1F 0214*      ld (@x1),ix
       04          
041F65 FD 22 85 1F 0215*      ld (@y1),iy
       04          
041F6A 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041F6C 32 81 1F 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F70 21 7B 1F 04 0218*  	ld hl,@cmd0
041F74 01 0C 00 00 0219*  	ld bc,@end-@cmd0
041F78 5B DF       0220*  	rst.lil $18
041F7A C9          0221*      ret
041F7B 19          0222*  @cmd0:  db 25 ; plot
041F7C 04          0223*  @arg0:  db plot_sl_both+mv_abs
041F7D 00 00       0224*  @x0:    dw 0x0000
041F7F 00 00       0225*  @y0:    dw 0x0000
041F81 19          0226*  @cmd1:  db 25 ; plot
041F82 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
041F83 00 00       0228*  @x1:    dw 0x0000
041F85 00 00       0229*  @y1:    dw 0x0000
041F87 00          0230*  @end:   db 0x00 ; padding
041F88             0057   	include "vdu_sprites.inc"
041F88             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041F88             0002*  ; the VDP can support up to 256 sprites. They must be defined
041F88             0003*  ; contiguously, and so the first sprite is sprite 0.
041F88             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041F88             0005*  ; Once a selection of sprites have been defined, you can activate
041F88             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
041F88             0007*  ; of sprites to activate. This will activate the first n sprites,
041F88             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041F88             0009*  
041F88             0010*  ; A single sprite can have multiple "frames", referring to
041F88             0011*  ; different bitmaps.
041F88             0012*  ; (These bitmaps do not need to be the same size.)
041F88             0013*  ; This allows a sprite to include an animation sequence,
041F88             0014*  ; which can be stepped through one frame at a time, or picked
041F88             0015*  ; in any order.
041F88             0016*  
041F88             0017*  ; Any format of bitmap can be used as a sprite frame. It should
041F88             0018*  ; be noted however that "native" format bitmaps are not
041F88             0019*  ; recommended for use as sprite frames, as they cannot get
041F88             0020*  ; erased from the screen. (As noted above, the "native" bitmap
041F88             0021*  ; format is not really intended for general use.) This is part
041F88             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041F88             0023*  ; screen are now stored in RGBA2222 format.
041F88             0024*  
041F88             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
041F88             0026*  ; and then later shown again.
041F88             0027*  
041F88             0028*  ; Moving sprites around the screen is done by changing the
041F88             0029*  ; position of the sprite. This can be done either by setting
041F88             0030*  ; the absolute position of the sprite, or by moving the sprite
041F88             0031*  ; by a given number of pixels. (Sprites are positioned using
041F88             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
041F88             0033*  ; In the current sprite system, sprites will not update their
041F88             0034*  ; position on-screen until either another drawing operation is
041F88             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
041F88             0036*  
041F88             0037*  ; VDU 23, 27, 4, n: Select sprite n
041F88             0038*  ; inputs: a is the 8-bit sprite id
041F88             0039*  vdu_sprite_select:
041F88 32 9A 1F 04 0040*      ld (@sprite),a
041F8C 21 97 1F 04 0041*      ld hl,@cmd
041F90 01 04 00 00 0042*      ld bc,@end-@cmd
041F94 5B DF       0043*      rst.lil $18
041F96 C9          0044*      ret
041F97 17 1B 04    0045*  @cmd:    db 23,27,4
041F9A 00          0046*  @sprite: db 0x00
041F9B             0047*  @end:
041F9B             0048*  
041F9B             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
041F9B             0050*  ; inputs: none
041F9B             0051*  ; prerequisites: vdu_sprite_select
041F9B             0052*  vdu_sprite_clear_frames:
041F9B 21 A6 1F 04 0053*      ld hl,@cmd
041F9F 01 03 00 00 0054*      ld bc,@end-@cmd
041FA3 5B DF       0055*      rst.lil $18
041FA5 C9          0056*      ret
041FA6 17 1B 05    0057*  @cmd: db 23,27,5
041FA9             0058*  @end:
041FA9             0059*  
041FA9             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
041FA9             0061*  ; inputs: a is the 8-bit bitmap number
041FA9             0062*  ; prerequisites: vdu_sprite_select
041FA9             0063*  vdu_sprite_add_bmp:
041FA9 32 BB 1F 04 0064*      ld (@bmp),a
041FAD 21 B8 1F 04 0065*      ld hl,@cmd
041FB1 01 04 00 00 0066*      ld bc,@end-@cmd
041FB5 5B DF       0067*      rst.lil $18
041FB7 C9          0068*      ret
041FB8 17 1B 06    0069*  @cmd: db 23,27,6
041FBB 00          0070*  @bmp: db 0x00
041FBC             0071*  @end:
041FBC             0072*  
041FBC             0073*  ; VDU 23, 27, 7, n: Activate n sprites
041FBC             0074*  ; inputs: a is the number of sprites to activate
041FBC             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
041FBC             0076*  vdu_sprite_activate:
041FBC 32 CE 1F 04 0077*      ld (@num),a
041FC0 21 CB 1F 04 0078*      ld hl,@cmd
041FC4 01 04 00 00 0079*      ld bc,@end-@cmd
041FC8 5B DF       0080*      rst.lil $18
041FCA C9          0081*      ret
041FCB 17 1B 07    0082*  @cmd: db 23,27,7
041FCE 00          0083*  @num: db 0x00
041FCF             0084*  @end:
041FCF             0085*  
041FCF             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
041FCF             0087*  ; inputs: none
041FCF             0088*  ; prerequisites: vdu_sprite_select
041FCF             0089*  vdu_sprite_next_frame:
041FCF 21 DA 1F 04 0090*      ld hl,@cmd
041FD3 01 03 00 00 0091*      ld bc,@end-@cmd
041FD7 5B DF       0092*      rst.lil $18
041FD9 C9          0093*      ret
041FDA 17 1B 08    0094*  @cmd: db 23,27,8
041FDD             0095*  @end:
041FDD             0096*  
041FDD             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
041FDD             0098*  ; inputs: none
041FDD             0099*  ; prerequisites: vdu_sprite_select
041FDD             0100*  vdu_sprite_prev_frame:
041FDD 21 E8 1F 04 0101*      ld hl,@cmd
041FE1 01 03 00 00 0102*      ld bc,@end-@cmd
041FE5 5B DF       0103*      rst.lil $18
041FE7 C9          0104*      ret
041FE8 17 1B 09    0105*  @cmd: db 23,27,9
041FEB             0106*  @end:
041FEB             0107*  
041FEB             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
041FEB             0109*  ; inputs: a is frame number to select
041FEB             0110*  ; prerequisites: vdu_sprite_select
041FEB             0111*  vdu_sprite_select_frame:
041FEB 32 FD 1F 04 0112*      ld (@frame),a
041FEF 21 FA 1F 04 0113*      ld hl,@cmd
041FF3 01 04 00 00 0114*      ld bc,@end-@cmd
041FF7 5B DF       0115*      rst.lil $18
041FF9 C9          0116*      ret
041FFA 17 1B 0A    0117*  @cmd:    db 23,27,10
041FFD 00          0118*  @frame:  db 0x00
041FFE             0119*  @end:
041FFE             0120*  
041FFE             0121*  ; VDU 23, 27, 11: Show current sprite
041FFE             0122*  ; inputs: none
041FFE             0123*  ; prerequisites: vdu_sprite_select
041FFE             0124*  vdu_sprite_show:
041FFE 21 09 20 04 0125*      ld hl,@cmd
042002 01 03 00 00 0126*      ld bc,@end-@cmd
042006 5B DF       0127*      rst.lil $18
042008 C9          0128*      ret
042009 17 1B 0B    0129*  @cmd: db 23,27,11
04200C             0130*  @end:
04200C             0131*  
04200C             0132*  ; VDU 23, 27, 12: Hide current sprite
04200C             0133*  ; inputs: none
04200C             0134*  ; prerequisites: vdu_sprite_select
04200C             0135*  vdu_sprite_hide:
04200C 21 17 20 04 0136*      ld hl,@cmd
042010 01 03 00 00 0137*      ld bc,@end-@cmd
042014 5B DF       0138*      rst.lil $18
042016 C9          0139*      ret
042017 17 1B 0C    0140*  @cmd: db 23,27,12
04201A             0141*  @end:
04201A             0142*  
04201A             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04201A             0144*  ; inputs: bc is x coordinate, de is y coordinate
04201A             0145*  ; prerequisites: vdu_sprite_select
04201A             0146*  vdu_sprite_move_abs:
04201A ED 43 32 20 0147*      ld (@xpos),bc
       04          
04201F ED 53 34 20 0148*      ld (@ypos),de
       04          
042024 21 2F 20 04 0149*      ld hl,@cmd
042028 01 07 00 00 0150*      ld bc,@end-@cmd
04202C 5B DF       0151*      rst.lil $18
04202E C9          0152*      ret
04202F 17 1B 0D    0153*  @cmd:  db 23,27,13
042032 00 00       0154*  @xpos: dw 0x0000
042034 00 00       0155*  @ypos: dw 0x0000
042036 00          0156*  @end:  db 0x00 ; padding
042037             0157*  
042037             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042037             0159*  ; inputs: bc is x coordinate, de is y coordinate
042037             0160*  ; prerequisites: vdu_sprite_select
042037             0161*  vdu_sprite_move_rel:
042037 ED 43 4F 20 0162*      ld (@dx),bc
       04          
04203C ED 53 51 20 0163*      ld (@dy),de
       04          
042041 21 4C 20 04 0164*      ld hl,@cmd
042045 01 07 00 00 0165*      ld bc,@end-@cmd
042049 5B DF       0166*      rst.lil $18
04204B C9          0167*      ret
04204C 17 1B 0E    0168*  @cmd: db 23,27,14
04204F 00 00       0169*  @dx:  dw 0x0000
042051 00 00       0170*  @dy:  dw 0x0000
042053 00          0171*  @end: db 0x00 ; padding
042054             0172*  
042054             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042054             0174*  ; USING 16.8 FIXED POINT COORDINATES
042054             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042054             0176*  ;   the fractional portiion of the inputs are truncated
042054             0177*  ;   leaving only the 16-bit integer portion
042054             0178*  ; prerequisites: vdu_sprite_select
042054             0179*  vdu_sprite_move_abs168:
042054             0180*  ; populate in the reverse of normal to keep the
042054             0181*  ; inputs from stomping on each other
042054 ED 53 73 20 0182*      ld (@ypos-1),de
       04          
042059 ED 43 71 20 0183*      ld (@xpos-1),bc
       04          
04205E 3E 0D       0184*      ld a,13       ; restore the final byte of the command
042060 32 71 20 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
042064 21 6F 20 04 0186*      ld hl,@cmd
042068 01 07 00 00 0187*      ld bc,@end-@cmd
04206C 5B DF       0188*      rst.lil $18
04206E C9          0189*      ret
04206F 17 1B 0D    0190*  @cmd:  db 23,27,13
042072 00 00       0191*  @xpos: dw 0x0000
042074 00 00       0192*  @ypos: dw 0x0000
042076             0193*  @end:  ; no padding required b/c we shifted de right
042076             0194*  
042076             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042076             0196*  ; USING 16.8 FIXED POINT COORDINATES
042076             0197*  ; inputs: ub.c is dx, ud.e is dy
042076             0198*  ;   the fractional portiion of the inputs are truncated
042076             0199*  ;   leaving only the 16-bit integer portion
042076             0200*  ; prerequisites: vdu_sprite_select
042076             0201*  vdu_sprite_move_rel168:
042076             0202*  ; populate in the reverse of normal to keep the
042076             0203*  ; inputs from stomping on each other
042076 ED 53 95 20 0204*      ld (@dy-1),de
       04          
04207B ED 43 93 20 0205*      ld (@dx-1),bc
       04          
042080 3E 0E       0206*      ld a,14       ; restore the final byte of the command
042082 32 93 20 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
042086 21 91 20 04 0208*      ld hl,@cmd
04208A 01 07 00 00 0209*      ld bc,@end-@cmd
04208E 5B DF       0210*      rst.lil $18
042090 C9          0211*      ret
042091 17 1B 0E    0212*  @cmd:  db 23,27,14
042094 00 00       0213*  @dx: dw 0x0000
042096 00 00       0214*  @dy: dw 0x0000
042098             0215*  @end:  ; no padding required b/c we shifted de right
042098             0216*  
042098             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
042098             0218*  ; inputs: none
042098             0219*  vdu_sprite_update:
042098 21 A3 20 04 0220*      ld hl,@cmd
04209C 01 03 00 00 0221*      ld bc,@end-@cmd
0420A0 5B DF       0222*      rst.lil $18
0420A2 C9          0223*      ret
0420A3 17 1B 0F    0224*  @cmd: db 23,27,15
0420A6             0225*  @end:
0420A6             0226*  
0420A6             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0420A6             0228*  ; inputs: none
0420A6             0229*  vdu_sprite_bmp_reset:
0420A6 21 B1 20 04 0230*      ld hl,@cmd
0420AA 01 03 00 00 0231*      ld bc,@end-@cmd
0420AE 5B DF       0232*      rst.lil $18
0420B0 C9          0233*      ret
0420B1 17 1B 10    0234*  @cmd: db 23,27,16
0420B4             0235*  @end:
0420B4             0236*  
0420B4             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0420B4             0238*  ; inputs: none
0420B4             0239*  vdu_sprite_reset:
0420B4 21 BF 20 04 0240*      ld hl,@cmd
0420B8 01 03 00 00 0241*      ld bc,@end-@cmd
0420BC 5B DF       0242*      rst.lil $18
0420BE C9          0243*      ret
0420BF 17 1B 11    0244*  @cmd: db 23,27,17
0420C2             0245*  @end:
0420C2             0246*  
0420C2             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0420C2             0248*  ; inputs: a is the GCOL paint mode
0420C2             0249*  ; prerequisites: vdu_sprite_select
0420C2             0250*  vdu_sprite_set_gcol:
0420C2 32 D4 20 04 0251*      ld (@mode),a
0420C6 21 D1 20 04 0252*      ld hl,@cmd
0420CA 01 04 00 00 0253*      ld bc,@end-@cmd
0420CE 5B DF       0254*      rst.lil $18
0420D0 C9          0255*      ret
0420D1 17 1B 12    0256*  @cmd:  db 23,27,18
0420D4 00          0257*  @mode: db 0x00
0420D5             0258*  @end:
0420D5             0259*  
0420D5             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0420D5             0261*  ; inputs: hl=bufferId
0420D5             0262*  ; prerequisites: vdu_sprite_select
0420D5             0263*  vdu_sprite_add_buff:
0420D5 22 E7 20 04 0264*      ld (@bufferId),hl
0420D9 21 E4 20 04 0265*      ld hl,@cmd
0420DD 01 05 00 00 0266*      ld bc,@end-@cmd
0420E1 5B DF       0267*      rst.lil $18
0420E3 C9          0268*      ret
0420E4 17 1B 26    0269*  @cmd:      db 23,27,0x26
0420E7 00 00       0270*  @bufferId: dw 0x0000
0420E9 00          0271*  @end:      db 0x00 ; padding
0420EA             0058   	include "div_168_signed.inc"
0420EA             0001*  ; 24-bit integer and 16.8 fixed point division routines
0420EA             0002*  ; by Brandon R. Gates (BeeGee747)
0420EA             0003*  ; have undergone cursory testing and seem to be generating
0420EA             0004*  ; correct results (assuming no overflows) but seem very inefficient,
0420EA             0005*  ; so they have been published for review and improvement
0420EA             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
0420EA             0007*  ;
0420EA             0008*  ; ---------------------------------------------------------
0420EA             0009*  ; BEGIN DIVISION ROUTINES
0420EA             0010*  ; ---------------------------------------------------------
0420EA             0011*  ;
0420EA             0012*  ; perform signed division of 16.8 fixed place values
0420EA             0013*  ; with an signed 16.8 fixed place result
0420EA             0014*  ; inputs: ub.c is dividend,ud.e is divisor
0420EA             0015*  ; outputs: uh.l is quotient
0420EA             0016*  ; destroys: a,bc
0420EA             0017*  ; note: uses carry flag to test for sign of operands and result
0420EA             0018*  ;       which can be confusing and should perhaps be changed
0420EA             0019*  ; note2: helper functions abs_hlu and neg_hlu have been modified
0420EA             0020*  ;       to return accurate flags according to the origional signs
0420EA             0021*  ;       (or zero) of this function's inputs
0420EA             0022*  sdiv168:
0420EA             0023*  ; make everything positive and save signs
0420EA C5          0024*      push bc         ; get bc to hl
0420EB E1          0025*      pop hl          ; for the next call
0420EC CD 91 21 04 0026*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
0420F0 CA 23 21 04 0027*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0420F4 F5          0028*      push af         ; save sign of bc
0420F5 E5          0029*      push hl         ; now put abs(hl)
0420F6 C1          0030*      pop bc          ; back into bc = abs(bc)
0420F7 EB          0031*      ex de,hl        ; now we do de same way
0420F8 CD 91 21 04 0032*      call abs_hlu
0420FC CA 25 21 04 0033*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
042100 EB          0034*      ex de,hl        ; hl back to de = abs(de)
042101             0035*  ; determine sign of result
042101 F2 0C 21 04 0036*      jp p,@de_pos    ; sign positive,de is positive
042105 F1          0037*      pop af          ; get back sign of bc
042106 FA 15 21 04 0038*      jp m,@result_pos  ; bc and de negative, result is positive
04210A 18 05       0039*      jr @result_neg
04210C             0040*  @de_pos:
04210C F1          0041*      pop af          ; get back sign of bc
04210D F2 15 21 04 0042*      jp p,@result_pos   ; bc and de are both positive so result is positive
042111             0043*                      ; fall through to result_neg
042111             0044*  @result_neg:
042111 AF          0045*      xor a           ; zero a and clear carry
042112 3D          0046*      dec a           ; set sign flag to negative
042113 18 02       0047*      jr @do_div
042115             0048*  @result_pos:
042115 AF          0049*      xor a           ; zero a and clear carry
042116 3C          0050*      inc a           ; set sign flag to negative
042117             0051*                      ; fall through to do_div
042117             0052*  @do_div:
042117 F5          0053*      push af         ; save sign of result
042118 CD 28 21 04 0054*      call udiv168
04211C F1          0055*      pop af          ; get back sign of result
04211D F0          0056*      ret p           ; result is positive so nothing to do
04211E CD A1 21 04 0057*      call neg_hlu    ; result is negative so negate it
042122 C9          0058*      ret
042123             0059*  @is_zero:           ; result is zero
042123 AF          0060*      xor a           ; sets zero flag, which we want,
042124             0061*                      ; sets pv flag which we might not (zero is parity even)
042124             0062*                      ; resets all others which is okay
042124 C9          0063*      ret
042125             0064*  @div_by_zero:       ; result is undefined, which isn't defined in binary
042125             0065*                      ; so we'll just return zero until i can think of something better
042125 F1          0066*      pop af          ; dummy pop
042126 AF          0067*      xor a           ; sets zero flag, which is ok,
042127             0068*                      ; sets pv flag which could be interpreted as overflow, which is good
042127             0069*                      ; resets all others which is okay
042127 C9          0070*      ret
042128             0071*  
042128             0072*  ; ; perform unsigned division of 16.8 fixed place values
042128             0073*  ; ; with an unsigned 16.8 fixed place result
042128             0074*  ; ; inputs: ub.c is dividend,ud.e is divisor
042128             0075*  ; ; outputs: uh.l is quotient
042128             0076*  ; ; destroys: a,bc
042128             0077*  ; udiv168:
042128             0078*  ; ; get the 16-bit integer part of the quotient
042128             0079*  ;     ; call div_24
042128             0080*  ;     call udiv24
042128             0081*  ;     ; call dumpRegistersHex
042128             0082*  ; ; load quotient to upper three bytes of output
042128             0083*  ;     ld (div168_out+1),bc
042128             0084*  ; ; TODO: THIS MAY BE BUGGED
042128             0085*  ; ; check remainder for zero, and if it is
042128             0086*  ; ; we can skip calculating the fractional part
042128             0087*  ;     add hl,de
042128             0088*  ;     or a
042128             0089*  ;     sbc hl,de
042128             0090*  ;     jr nz,@div256
042128             0091*  ;     xor a
042128             0092*  ;     jr @write_frac
042128             0093*  ; ; END TODO
042128             0094*  ; @div256:
042128             0095*  ; ; divide divisor by 256
042128             0096*  ;     push hl ; save remainder
042128             0097*  ; ; TODO: it feels like this could be more efficient
042128             0098*  ;     ld (ude),de
042128             0099*  ;     ld a,d
042128             0100*  ;     ld (ude),a
042128             0101*  ;     ld a,(ude+2)
042128             0102*  ;     ld (ude+1),a
042128             0103*  ;     xor a
042128             0104*  ;     ld (ude+2),a
042128             0105*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
042128             0106*  ; ; TODO: THIS MAY BE BUGGED
042128             0107*  ; ; now we check the shifted divisor for zero, and if it is
042128             0108*  ; ; we again set the fractional part to zero
042128             0109*  ;     add hl,de
042128             0110*  ;     or a
042128             0111*  ;     sbc hl,de
042128             0112*  ;     ex de,hl ; now de is where it's supposed to be
042128             0113*  ;     pop hl ; get remainder back
042128             0114*  ; ; TODO: THIS MAY BE BUGGED
042128             0115*  ;     jr nz,@div_frac
042128             0116*  ;     xor a
042128             0117*  ;     jr @write_frac
042128             0118*  ; ; END TODO
042128             0119*  ; ; now divide the remainder by the shifted divisor
042128             0120*  ; @div_frac:
042128             0121*  ;     push hl ; my kingdom for ld bc,hl
042128             0122*  ;     pop bc  ; or even ex bc,hl
042128             0123*  ;     ; call div_24
042128             0124*  ;     call udiv24
042128             0125*  ; ; load low byte of quotient to low byte of output
042128             0126*  ;     ld a,c
042128             0127*  ; @write_frac:
042128             0128*  ;     ld (div168_out),a
042128             0129*  ; ; load hl with return value
042128             0130*  ;     ld hl,(div168_out)
042128             0131*  ; ; load a with any overflow
042128             0132*  ;     ld a,(div168_out+3)
042128             0133*  ;     ret ; uh.l is the 16.8 result
042128             0134*  ; div168_out: ds 4 ; the extra byte is for overflow
042128             0135*  
042128             0136*  ; perform unsigned division of fixed place values
042128             0137*  ; with an unsigned 16.8 fixed place result
042128             0138*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
042128             0139*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
042128             0140*  ; destroys: a,bc
042128             0141*  udiv168:
042128             0142*  ; shift dividend left 8 bits
042128 ED 43 F7 19 0143*      ld (ubc+1),bc
       04          
04212D AF          0144*      xor a
04212E 32 F6 19 04 0145*      ld (ubc),a
042132 ED 4B F6 19 0146*      ld bc,(ubc)
       04          
042137 CD BE 21 04 0147*      call udiv24
04213B             0148*  ; flip-flop outptuts to satisfy downstream consumers
04213B             0149*  ; TODO: this is a hack and should be fixed
04213B             0150*  ; (so says copilot ... but it's not wrong)
04213B E5          0151*      push hl
04213C C5          0152*      push bc
04213D E1          0153*      pop hl
04213E C1          0154*      pop bc
04213F C9          0155*      ret
042140             0156*  
042140             0157*  ; this is an adaptation of Div16 extended to 24 bits
042140             0158*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
042140             0159*  ; it works by shifting each byte of the dividend left into carry 8 times
042140             0160*  ; and adding the dividend into hl if the carry is set
042140             0161*  ; thus hl accumulates a remainder depending on the result of each iteration
042140             0162*  ; ---------------------------------------------------------
042140             0163*  ; Divide 24-bit unsigned values
042140             0164*  ;   with 24-bit unsigned result
042140             0165*  ;   and 24-bit remainder
042140             0166*  ; In: Divide ubc by ude
042140             0167*  ; Out: ubc = result, uhl = remainder
042140             0168*  ; Destroys: a,hl,bc
042140             0169*  div_24:
042140 21 00 00 00 0170*      ld hl,0     ; Clear accumulator for remainder
042144             0171*  ; put dividend in scratch so we can get at all its bytes
042144 ED 43 F6 19 0172*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
042149 3A F8 19 04 0173*      ld a,(ubc+2); grab the upper byte of the dividend
04214D 06 08       0174*      ld b,8      ; loop counter for 8 bits in a byte
04214F             0175*  @loop0:
04214F 17          0176*      rla         ; shift the next bit of dividend into the carry flag
042150 ED 6A       0177*      adc hl,hl   ; shift the remainder left one bit and add carry if any
042152 ED 52       0178*      sbc hl,de   ; subtract divisor from remainder
042154 30 01       0179*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
042156             0180*                  ; meaning remainder is divisible by divisor
042156 19          0181*      add hl,de   ; otherwise add divisor back to remainder
042157             0182*                  ; reversing the previous subtraction
042157             0183*  @noadd0:
042157 10 F6       0184*      djnz @loop0 ; repeat for all 8 bits
042159 17          0185*      rla         ; now we shift a left one more time
04215A 2F          0186*      cpl         ; then flip its bits for some reason
04215B 32 F8 19 04 0187*      ld (ubc+2),a; magically this is the upper byte of the quotient
04215F 3A F7 19 04 0188*      ld a,(ubc+1); now we pick up the middle byte of the dividend
042163 06 08       0189*      ld b,8      ; set up the next loop and do it all again ...
042165             0190*  @loop1:
042165 17          0191*      rla
042166 ED 6A       0192*      adc hl,hl
042168 ED 52       0193*      sbc hl,de
04216A 30 01       0194*      jr nc,@noadd1
04216C 19          0195*      add hl,de
04216D             0196*  @noadd1:
04216D 10 F6       0197*      djnz @loop1
04216F 17          0198*      rla
042170 2F          0199*      cpl
042171 32 F7 19 04 0200*      ld (ubc+1),a ; writing the middle byte of quotient
042175 3A F6 19 04 0201*      ld a,(ubc)
042179 06 08       0202*      ld b,8
04217B             0203*  @loop2:          ; compute low byte of quotient
04217B 17          0204*      rla
04217C ED 6A       0205*      adc hl,hl
04217E ED 52       0206*      sbc hl,de
042180 30 01       0207*      jr nc,@noadd2
042182 19          0208*      add hl,de
042183             0209*  @noadd2:
042183 10 F6       0210*      djnz @loop2
042185 17          0211*      rla
042186 2F          0212*      cpl
042187 32 F6 19 04 0213*      ld (ubc),a  ; ... write low byte of quotient
04218B ED 4B F6 19 0214*      ld bc,(ubc) ; load quotient into bc for return
       04          
042190 C9          0215*      ret         ; hl already contains remainder so we're done
042191             0216*  
042191             0217*  ; ---------------------------------------------------------
042191             0218*  ; BEGIN HELPER ROUTINES
042191             0219*  ; ---------------------------------------------------------
042191             0220*  ;
042191             0221*  ; absolute value of hlu
042191             0222*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
042191             0223*  ;         s1,z0,pv0,n1,c0 if hlu was negative
042191             0224*  ;         s0,z1,pv0,n1,c0 if hlu was zero
042191             0225*  ;         s0,z0,pv0,n1,c0 if hlu was positive
042191             0226*  ; destroys: a
042191             0227*  abs_hlu:
042191 19          0228*      add hl,de
042192 B7          0229*      or a
042193 ED 52       0230*      sbc hl,de
042195 FA 9A 21 04 0231*      jp m,@is_neg
042199 C9          0232*      ret         ; hlu is positive or zero so we're done
04219A             0233*  @is_neg:
04219A F5          0234*      push af     ; otherwise, save current flags for return
04219B CD A1 21 04 0235*      call neg_hlu ; negate hlu
04219F F1          0236*      pop af      ; get back flags
0421A0 C9          0237*      ret
0421A1             0238*  
0421A1             0239*  ; flip the sign of hlu
0421A1             0240*  ; inputs: hlu
0421A1             0241*  ; returns: 0-hlu, flags set appropriately for the result:
0421A1             0242*  ;         s1,z0,pv0,n1,c1 if result is negative
0421A1             0243*  ;         s0,z1,pv0,n1,c0 if result is zero
0421A1             0244*  ;         s0,z0,pv0,n1,c1 if result is positive
0421A1             0245*  ; destroys a
0421A1             0246*  neg_hlu:
0421A1 D5          0247*      push de     ; save de
0421A2 EB          0248*      ex de,hl    ; put hl into de
0421A3 21 00 00 00 0249*      ld hl,0     ; clear hl
0421A7 AF          0250*      xor a       ; clear carry
0421A8 ED 52       0251*      sbc hl,de   ; 0-hlu = -hlu
0421AA D1          0252*      pop de      ; get de back
0421AB C9          0253*      ret         ; easy peasy
0421AC             0254*  
0421AC             0255*  ; -----------------------------------------------------------------------
0421AC             0256*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
0421AC             0257*  ;------------------------------------------------------------------------
0421AC             0258*  ;  arith24.asm
0421AC             0259*  ;  24-bit ez80 arithmetic routines
0421AC             0260*  ;  Copyright (c) Shawn Sijnstra 2024
0421AC             0261*  ;  MIT license
0421AC             0262*  ;
0421AC             0263*  ;  This library was created as a tool to help make ez80
0421AC             0264*  ;  24-bit native assembly routines for simple mathematical problems
0421AC             0265*  ;  more widely available.
0421AC             0266*  ;
0421AC             0267*  ;------------------------------------------------------------------------
0421AC             0268*  
0421AC             0269*  ;------------------------------------------------------------------------
0421AC             0270*  ; umul24:	HLU = BCU*DEU (unsigned)
0421AC             0271*  ; Preserves AF, BCU, DEU
0421AC             0272*  ; Uses a fast multiply routine.
0421AC             0273*  ;------------------------------------------------------------------------
0421AC             0274*  ; modified to take BCU as multiplier instead of HLU
0421AC             0275*  umul24:
0421AC             0276*  	; push	DE
0421AC             0277*  	; push	BC
0421AC             0278*  	; push	AF
0421AC             0279*  	; push	HL
0421AC             0280*  	; pop		BC
0421AC 3E 18       0281*      ld	 	a,24 ; No. of bits to process
0421AE 21 00 00 00 0282*      ld	 	hl,0 ; Result
0421B2             0283*  umul24_lp:
0421B2 29          0284*  	add	hl,hl
0421B3 EB          0285*  	ex	de,hl
0421B4 29          0286*  	add	hl,hl
0421B5 EB          0287*  	ex	de,hl
0421B6 30 01       0288*  	jr	nc,umul24_nc
0421B8 09          0289*  	add	hl,bc
0421B9             0290*  umul24_nc:
0421B9 3D          0291*  	dec	a
0421BA 20 F6       0292*  	jr	nz,umul24_lp
0421BC 0B          0293*      dec bc ; debug
0421BD             0294*  	; pop	af
0421BD             0295*  	; pop	bc
0421BD             0296*  	; pop	de
0421BD C9          0297*  	ret
0421BE             0298*  
0421BE             0299*  
0421BE             0300*  ;------------------------------------------------------------------------
0421BE             0301*  ; udiv24
0421BE             0302*  ; Unsigned 24-bit division
0421BE             0303*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
0421BE             0304*  ;
0421BE             0305*  ; Uses AF BC DE HL
0421BE             0306*  ; Uses Restoring Division algorithm
0421BE             0307*  ;------------------------------------------------------------------------
0421BE             0308*  ; modified to take BCU as dividend instead of HLU
0421BE             0309*  ; and give BCU as quotient instead of DEU
0421BE             0310*  ; -----------------------------------------------------------------------
0421BE             0311*  udiv24:
0421BE             0312*  	; push	hl
0421BE             0313*  	; pop		bc	;move dividend to BCU
0421BE 21 00 00 00 0314*  	ld		hl,0	;result
0421C2 A7          0315*  	and		a
0421C3 ED 52       0316*  	sbc		hl,de	;test for div by 0
0421C5 C8          0317*  	ret		z		;it's zero, carry flag is clear
0421C6 19          0318*  	add		hl,de	;HL is 0 again
0421C7 3E 18       0319*  	ld		a,24	;number of loops through.
0421C9             0320*  udiv1:
0421C9 C5          0321*  	push	bc	;complicated way of doing this because of lack of access to top bits
0421CA E3          0322*  	ex		(sp),hl
0421CB 37          0323*  	scf
0421CC ED 6A       0324*  	adc	hl,hl
0421CE E3          0325*  	ex	(sp),hl
0421CF C1          0326*  	pop	bc		;we now have bc = (bc * 2) + 1
0421D0             0327*  
0421D0 ED 6A       0328*  	adc	hl,hl
0421D2 A7          0329*  	and	a		;is this the bug
0421D3 ED 52       0330*  	sbc	hl,de
0421D5 30 02       0331*  	jr	nc,udiv2
0421D7 19          0332*  	add	hl,de
0421D8             0333*  ;	dec	c
0421D8 0B          0334*  	dec	bc
0421D9             0335*  udiv2:
0421D9 3D          0336*  	dec	a
0421DA 20 ED       0337*  	jr	nz,udiv1
0421DC 37          0338*  	scf		;flag used for div0 error
0421DD             0339*  	; push	bc
0421DD             0340*  	; pop		de	;remainder
0421DD C9          0341*  	ret
0421DE             0342*  
0421DE             0343*  
0421DE             0344*  
0421DE             0345*  ;------------------------------------------------------------------------
0421DE             0346*  ; neg24
0421DE             0347*  ; Returns: HLU = 0-HLU
0421DE             0348*  ; preserves all other registers
0421DE             0349*  ;------------------------------------------------------------------------
0421DE             0350*  neg24:
0421DE D5          0351*  	push	de
0421DF EB          0352*  	ex		de,hl
0421E0 21 00 00 00 0353*  	ld		hl,0
0421E4 B7          0354*  	or		a
0421E5 ED 52       0355*  	sbc		hl,de
0421E7 D1          0356*  	pop		de
0421E8 C9          0357*  	ret
0421E9             0358*  
0421E9             0359*  ;------------------------------------------------------------------------
0421E9             0360*  ; or_hlu_deu: 24 bit bitwise OR
0421E9             0361*  ; Returns: hlu = hlu OR deu
0421E9             0362*  ; preserves all other registers
0421E9             0363*  ;------------------------------------------------------------------------
0421E9             0364*  or_hlu_deu:
0421E9 22 A5 22 04 0365*  	ld	(bitbuf1),hl
0421ED ED 53 A8 22 0366*  	ld	(bitbuf2),de
       04          
0421F2 D5          0367*  	push	de	;preserve DEU
0421F3 C5          0368*  	push	bc	;preserve BCU
0421F4 06 03       0369*  	ld		b,3
0421F6 21 A5 22 04 0370*  	ld	hl,bitbuf1
0421FA 11 A5 22 04 0371*  	ld	de,bitbuf1
0421FE             0372*  orloop_24:
0421FE 1A          0373*  	ld	a,(de)
0421FF B6          0374*  	or	(hl)
042200 12          0375*  	ld	(de),a
042201 13          0376*  	inc	de
042202 23          0377*  	inc	hl
042203 10 F9       0378*  	djnz	orloop_24
042205 2A A8 22 04 0379*  	ld	hl,(bitbuf2)
042209 C1          0380*  	pop		bc	;restore BC
04220A D1          0381*  	pop		de	;restore DE
04220B             0382*  
04220B             0383*  ;------------------------------------------------------------------------
04220B             0384*  ; and_hlu_deu: 24 bit bitwise AND
04220B             0385*  ; Returns: hlu = hlu AND deu
04220B             0386*  ; preserves all other registers
04220B             0387*  ;------------------------------------------------------------------------
04220B             0388*  and_hlu_deu:
04220B 22 A5 22 04 0389*  	ld	(bitbuf1),hl
04220F ED 53 A8 22 0390*  	ld	(bitbuf2),de
       04          
042214 D5          0391*  	push	de	;preserve DEU
042215 C5          0392*  	push	bc	;preserve BCU
042216 06 03       0393*  	ld		b,3
042218 21 A5 22 04 0394*  	ld	hl,bitbuf1
04221C 11 A5 22 04 0395*  	ld	de,bitbuf1
042220             0396*  andloop_24:
042220 1A          0397*  	ld	a,(de)
042221 A6          0398*  	and	(hl)
042222 12          0399*  	ld	(de),a
042223 13          0400*  	inc	de
042224 23          0401*  	inc	hl
042225 10 F9       0402*  	djnz	andloop_24
042227 2A A8 22 04 0403*  	ld	hl,(bitbuf2)
04222B C1          0404*  	pop		bc	;restore BC
04222C D1          0405*  	pop		de	;restore DE
04222D             0406*  
04222D             0407*  ;------------------------------------------------------------------------
04222D             0408*  ; xor_hlu_deu: 24 bit bitwise XOR
04222D             0409*  ; Returns: hlu = hlu XOR deu
04222D             0410*  ; preserves all other registers
04222D             0411*  ;------------------------------------------------------------------------
04222D             0412*  xor_hlu_deu:
04222D 22 A5 22 04 0413*  	ld	(bitbuf1),hl
042231 ED 53 A8 22 0414*  	ld	(bitbuf2),de
       04          
042236 D5          0415*  	push	de	;preserve DEU
042237 C5          0416*  	push	bc	;preserve BCU
042238 06 03       0417*  	ld		b,3
04223A 21 A5 22 04 0418*  	ld	hl,bitbuf1
04223E 11 A5 22 04 0419*  	ld	de,bitbuf1
042242             0420*  xorloop_24:
042242 1A          0421*  	ld	a,(de)
042243 AE          0422*  	xor	(hl)
042244 12          0423*  	ld	(de),a
042245 13          0424*  	inc	de
042246 23          0425*  	inc	hl
042247 10 F9       0426*  	djnz	xorloop_24
042249 2A A8 22 04 0427*  	ld	hl,(bitbuf2)
04224D C1          0428*  	pop		bc	;restore BC
04224E D1          0429*  	pop		de	;restore DE
04224F             0430*  
04224F             0431*  ;------------------------------------------------------------------------
04224F             0432*  ; shl_hlu: 24 bit shift left hlu by deu positions
04224F             0433*  ; Returns: hlu = hlu << deu
04224F             0434*  ;		   de = 0
04224F             0435*  ; NOTE: only considers deu up to 16 bits.
04224F             0436*  ; preserves all other registers
04224F             0437*  ;------------------------------------------------------------------------
04224F             0438*  shl_hlu:
04224F 7A          0439*  	ld		a,d		;up to 16 bit.
042250 B3          0440*  	or		e
042251 C8          0441*  	ret		z		;we're done
042252 29          0442*  	add		hl,hl	;shift HLU left
042253 1B          0443*  	dec		de
042254 18 F9       0444*  	jr		shl_hlu
042256             0445*  
042256             0446*  ;------------------------------------------------------------------------
042256             0447*  ; shr_hlu: 24 bit shift right hlu by deu positions
042256             0448*  ; Returns: hlu = hlu >> deu
042256             0449*  ;		   de = 0
042256             0450*  ; NOTE: only considers deu up to 16 bits.
042256             0451*  ; preserves all other registers
042256             0452*  ;------------------------------------------------------------------------
042256             0453*  shr_hlu:
042256 22 A5 22 04 0454*  	ld		(bitbuf1),hl
04225A 21 A7 22 04 0455*  	ld		hl,bitbuf1+2
04225E             0456*  shr_loop:
04225E 7A          0457*  	ld		a,d		;up to 16 bit.
04225F B3          0458*  	or		e
042260 28 0D       0459*  	jr		z,shr_done		;we're done
042262             0460*  ;carry is clear from or instruction
042262 CB 1E       0461*  	rr		(hl)
042264 2B          0462*  	dec		hl
042265 CB 1E       0463*  	rr		(hl)
042267 2B          0464*  	dec		hl
042268 CB 1E       0465*  	rr		(hl)
04226A 23          0466*  	inc		hl
04226B 23          0467*  	inc		hl
04226C 1B          0468*  	dec		de
04226D 18 EF       0469*  	jr		shr_loop
04226F             0470*  shr_done:
04226F 2A A5 22 04 0471*  	ld		hl,(bitbuf1)	;collect result
042273 C9          0472*  	ret
042274             0473*  
042274             0474*  ;------------------------------------------------------------------------
042274             0475*  ; divide hlu by 2, inspired by above
042274             0476*  ;------------------------------------------------------------------------
042274             0477*  hlu_div2:
042274 22 A5 22 04 0478*  	ld		(bitbuf1),hl
042278 21 A7 22 04 0479*  	ld		hl,bitbuf1+2
04227C CB 1E       0480*  	rr		(hl)
04227E 2B          0481*  	dec		hl
04227F CB 1E       0482*  	rr		(hl)
042281 2B          0483*  	dec		hl
042282 CB 1E       0484*  	rr		(hl)
042284 23          0485*  	inc		hl
042285 23          0486*  	inc		hl
042286 2A A5 22 04 0487*      ld hl,(bitbuf1)
04228A C9          0488*      ret
04228B             0489*  
04228B             0490*  ; this is my little hack to divide by 16
04228B             0491*  hlu_div16:
04228B AF          0492*      xor a
04228C 29          0493*      add hl,hl
04228D 17          0494*      rla
04228E 29          0495*      add hl,hl
04228F 17          0496*      rla
042290 29          0497*      add hl,hl
042291 17          0498*      rla
042292 29          0499*      add hl,hl
042293 17          0500*      rla
042294 22 A1 22 04 0501*      ld (@scratch),hl
042298 32 A4 22 04 0502*      ld (@scratch+3),a
04229C 2A A2 22 04 0503*      ld hl,(@scratch+1)
0422A0 C9          0504*      ret
0422A1             0505*  @scratch: ds 4
0422A5             0506*  
0422A5             0507*  ;------------------------------------------------------------------------
0422A5             0508*  ; Scratch area for calculations
0422A5             0509*  ;------------------------------------------------------------------------
0422A5 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0422A8 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0422AB             0512*  
0422AB             0513*  
0422AB             0514*  ; -----------------------------------------------------------------------
0422AB             0515*  ; EEMES TUTORIALS
0422AB             0516*  ; -----------------------------------------------------------------------
0422AB             0517*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
0422AB             0518*  ; DEHL=BC*DE
0422AB             0519*  Mul16:
0422AB 21 00 00 00 0520*      ld hl,0
0422AF 3E 10       0521*      ld a,16
0422B1             0522*  Mul16Loop:
0422B1 29          0523*      add hl,hl
0422B2 CB 13       0524*      rl e
0422B4 CB 12       0525*      rl d
0422B6 D2 C0 22 04 0526*      jp nc,NoMul16
0422BA 09          0527*      add hl,bc
0422BB D2 C0 22 04 0528*      jp nc,NoMul16
0422BF 13          0529*      inc de
0422C0             0530*  NoMul16:
0422C0 3D          0531*      dec a
0422C1 C2 B1 22 04 0532*      jp nz,Mul16Loop
0422C5 C9          0533*      ret
0422C6             0534*  
0422C6             0535*  ; DEUHLU=BCU*DEU
0422C6             0536*  umul2448:
0422C6 21 00 00 00 0537*      ld hl,0
0422CA 3E 18       0538*      ld a,24
0422CC             0539*  umul2448Loop:
0422CC 29          0540*      add hl,hl
0422CD EB          0541*      ex de,hl
0422CE ED 6A       0542*      adc hl,hl
0422D0 EB          0543*      ex de,hl
0422D1 D2 DB 22 04 0544*      jp nc,Noumul2448
0422D5 09          0545*      add hl,bc
0422D6 D2 DB 22 04 0546*      jp nc,Noumul2448
0422DA 13          0547*      inc de
0422DB             0548*  Noumul2448:
0422DB 3D          0549*      dec a
0422DC C2 CC 22 04 0550*      jp nz,umul2448Loop
0422E0 C9          0551*      ret
0422E1             0552*  
0422E1             0553*  umul168:
0422E1 CD C6 22 04 0554*      call umul2448
0422E5             0555*  
0422E5             0556*      ; call dumpUDEUHLHex
0422E5             0557*  
0422E5             0558*  ; UDEU.HL is the 32.16 fixed result
0422E5             0559*  ; we want UH.L to be the 16.8 fixed result
0422E5             0560*  ; so we divide by 256 by shiftng down a byte
0422E5             0561*  ; easiest way is to write deu and hlu to scratch
0422E5 ED 53 FA 22 0562*      ld (umul168out+3),de
       04          
0422EA 22 F7 22 04 0563*      ld (umul168out),hl
0422EE             0564*  ; then load hlu from scratch shfited forward a byte
0422EE 2A F8 22 04 0565*      ld hl,(umul168out+1)
0422F2 3A FC 22 04 0566*      ld a,(umul168out+5) ; send a back with any overflow
0422F6 C9          0567*      ret
0422F7             0568*  umul168out: ds 6
0422FD             0569*  
0422FD             0570*  ; perform signed multiplication of 16.8 fixed place values
0422FD             0571*  ; with an signed 16.8 fixed place result
0422FD             0572*  ; inputs: ub.c and ud.e are the operands
0422FD             0573*  ; outputs: uh.l is the product
0422FD             0574*  ; destroys: a,bc
0422FD             0575*  ; TODO: make flags appropriate to the sign of the result
0422FD             0576*  smul168:
0422FD             0577*  ; make everything positive and save signs
0422FD C5          0578*      push bc         ; get bc to hl
0422FE E1          0579*      pop hl          ; for the next call
0422FF CD 91 21 04 0580*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
042303             0581*  
042303             0582*      ; call dumpFlags ; passes
042303             0583*  
042303 CA 36 23 04 0584*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
042307 F5          0585*      push af         ; save sign of bc
042308 E5          0586*      push hl         ; now put abs(hl)
042309 C1          0587*      pop bc          ; back into bc = abs(bc)
04230A EB          0588*      ex de,hl        ; now we do de same way
04230B CD 91 21 04 0589*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
04230F             0590*  
04230F             0591*      ; call dumpFlags ; passes
04230F             0592*  
04230F CA 36 23 04 0593*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
042313 EB          0594*      ex de,hl        ; hl back to de = abs(de)
042314             0595*  ; determine sign of result
042314 F2 1F 23 04 0596*      jp p,@de_pos    ; sign positive,de is positive
042318             0597*  
042318             0598*      ; call dumpFlags ; correctly doesnt make it here
042318             0599*  
042318 F1          0600*      pop af          ; get back sign of bc
042319             0601*  
042319             0602*      ; call dumpFlags ; correctly doesn't make it here
042319             0603*  
042319 FA 28 23 04 0604*      jp m,@result_pos  ; bc and de negative, result is positive
04231D             0605*  
04231D             0606*      ; call dumpFlags  ; corectly doesn't make it here
04231D             0607*  
04231D 18 05       0608*      jr @result_neg
04231F             0609*  @de_pos:
04231F F1          0610*      pop af          ; get back sign of bc
042320             0611*  
042320             0612*      ; call dumpFlags  ; passes
042320             0613*  
042320 F2 28 23 04 0614*      jp p,@result_pos   ; bc and de are both positive so result is positive
042324             0615*  
042324             0616*      ; call dumpFlags ; correctly makes it here
042324             0617*  
042324             0618*                      ; fall through to result_neg
042324             0619*  @result_neg:
042324 AF          0620*      xor a           ; zero a and clear carry
042325 3D          0621*      dec a           ; set sign flag to negative
042326             0622*  
042326             0623*      ; call dumpFlags ; passes
042326             0624*  
042326 18 02       0625*      jr @do_mul
042328             0626*  @result_pos:
042328 AF          0627*      xor a           ; zero a and clear carry
042329 3C          0628*      inc a           ; set sign flag to positive
04232A             0629*                      ; fall through to do_mul
04232A             0630*  
04232A             0631*      ; call dumpFlags ; correctly doesn't make it here
04232A             0632*  
04232A             0633*  @do_mul:
04232A F5          0634*      push af         ; save sign of result
04232B CD E1 22 04 0635*      call umul168
04232F F1          0636*      pop af          ; get back sign of result
042330             0637*  
042330             0638*      ; call dumpFlags ; passes
042330             0639*  
042330 F0          0640*      ret p           ; result is positive so nothing to do
042331             0641*  
042331             0642*      ; call dumpRegistersHex ; passes
042331             0643*  
042331 CD A1 21 04 0644*      call neg_hlu    ; result is negative so negate it
042335             0645*  
042335             0646*      ; call dumpRegistersHex ; passes
042335 C9          0647*      ret
042336             0648*  @is_zero:           ; result is zero
042336 AF          0649*      xor a           ; sets zero flag, which we want,
042337             0650*                      ; sets pv flag which we might not (zero is parity even)
042337             0651*                      ; resets all others which is okay
042337 C9          0652*      ret
042338             0059   	include "maths24.inc"
042338             0001*  ; http://www.z80.info/pseudo-random.txt
042338             0002*  rand_8:
042338 C5          0003*      push bc
042339 3A 4C 23 04 0004*      ld a,(r_seed)
04233D 4F          0005*      ld c,a
04233E             0006*  
04233E 0F          0007*      rrca ; multiply by 32
04233F 0F          0008*      rrca
042340 0F          0009*      rrca
042341 EE 1F       0010*      xor 0x1f
042343             0011*  
042343 81          0012*      add a,c
042344 DE FF       0013*      sbc a,255 ; carry
042346             0014*  
042346 32 4C 23 04 0015*      ld (r_seed),a
04234A C1          0016*      pop bc
04234B C9          0017*      ret
04234C 50          0018*  r_seed: defb $50
04234D             0019*  
04234D             0020*  ; tests the sign of 24-bit register hlu
04234D             0021*  ; returns: a in [-1,0,1]
04234D             0022*  ;   sign and zero flags as expected
04234D             0023*  ;   hl is untouched
04234D             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
04234D             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
04234D             0026*  get_sign_hlu:
04234D             0027*      ; Load the upper byte of HLU into A
04234D E5          0028*      push hl
04234E DD 21 00 00 0029*      ld ix,0
       00          
042353 DD 39       0030*      add ix,sp
042355 DD 7E 02    0031*      ld a,(ix+2)
042358 E1          0032*      pop hl
042359             0033*  
042359 B5          0034*      or l                ; OR with the low byte to check if HL is zero
04235A C8          0035*      ret z               ; Return if HL is zero
04235B             0036*  
04235B 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
04235D CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
04235F C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
042360             0040*  
042360 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
042362 A7          0042*      and a               ; Reset the zero flag
042363 C9          0043*      ret                 ; Return with A set to 1
042364             0044*  
042364             0045*  ; 16.8 fixed inputs / outputs
042364             0046*  ; takes: uh.l as angle in degrees 256
042364             0047*  ;        ud.e as radius
042364             0048*  ; returns ub.c as dx, ud.e as dy
042364             0049*  ;        displacements from origin (0,0)
042364             0050*  ; destroys: everything except indexes
042364             0051*  polar_to_cartesian:
042364             0052*  ; back up input parameters
042364 22 F3 19 04 0053*      ld (uhl),hl
042368 ED 53 F9 19 0054*      ld (ude),de
       04          
04236D             0055*  ; compute dx = sin(uh.l) * ud.e
04236D CD 9C 23 04 0056*      call sin168
042371 E5          0057*      push hl
042372 C1          0058*      pop bc ; ub.c = sin(uh.l)
042373 ED 5B F9 19 0059*  	ld de,(ude) ; get radius back
       04          
042378 CD FD 22 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
04237C E5          0061*      push hl ; store dx for output
04237D             0062*  ; compute dy = -cos(uh.l) * ud.e
04237D 2A F3 19 04 0063*      ld hl,(uhl)
042381 CD 97 23 04 0064*      call cos168
042385 CD A1 21 04 0065*  	call neg_hlu ; invert dy for screen coords convention
042389 E5          0066*      push hl
04238A C1          0067*      pop bc ; ub.c = -cos(uh.l)
04238B ED 5B F9 19 0068*      ld de,(ude) ; get radius back
       04          
042390 CD FD 22 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
042394 EB          0070*      ex de,hl    ; de = dy for output
042395 C1          0071*      pop bc      ; bc = dx for output
042396             0072*  ; and out
042396 C9          0073*      ret
042397             0074*  
042397             0075*  ; fixed 16.8 routine
042397             0076*  ; cos(uh.l) --> uh.l
042397             0077*  ; destroys: de
042397             0078*  cos168:
042397             0079*  ; for cos we simply increment the angle by 90 degrees
042397             0080*  ; or 0x004000 in 16.8 degrees256
042397             0081*  ; which makes it a sin problem
042397 11 00 40 00 0082*      ld de,0x004000
04239B 19          0083*      add hl,de ; modulo 256 happens below
04239C             0084*  ; fall through to sin168
04239C             0085*  ; ---------------------
04239C             0086*  ; fixed 16.8 routine
04239C             0087*  ; sin(uh.l) --> uh.l
04239C             0088*  ; destroys: de
04239C             0089*  sin168:
04239C             0090*  ; h contains the integer portion of our angle
04239C             0091*  ; we multiply it by three to get our lookup table index
04239C 2E 03       0092*      ld l,3
04239E ED 6C       0093*      mlt hl ; gosh that is handy
0423A0 11 00 00 00 0094*      ld de,0 ; clear deu
0423A4 54          0095*      ld d,h ; copy hl to de
0423A5 5D          0096*      ld e,l ; de contains our index
0423A6 21 AD 25 04 0097*      ld hl,sin_lut_168 ; grab the lut address
0423AA 19          0098*      add hl,de ; bump hl by the index
0423AB ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
0423AD C9          0100*      ret ; and out
0423AE             0101*  
0423AE             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0423AE             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0423AE             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0423AE             0105*  ;         also populates scratch locations dx168 and dy168
0423AE             0106*  ; destroys: a,hl,bc,de
0423AE             0107*  dxy168:
0423AE             0108*  ; compute dx = x1-x0
0423AE AF          0109*      xor a ; clear carry
0423AF DD E5       0110*      push ix ; move ix to hl via the stack
0423B1 E1          0111*      pop hl ; hl = x1
0423B2 ED 42       0112*      sbc hl,bc ; hl = dx
0423B4 22 09 24 04 0113*      ld (dx168),hl ; dx to scratch
0423B8             0114*  ; compute dy = y1-y0
0423B8 AF          0115*      xor a ; clear carry
0423B9 FD E5       0116*      push iy ; move iy to hl via the stack
0423BB E1          0117*      pop hl ; hl = y1
0423BC ED 52       0118*      sbc hl,de ; hl = dy
0423BE 22 0F 24 04 0119*      ld (dy168),hl ; dy to scratch
0423C2             0120*  ; populate output registers and return
0423C2 EB          0121*      ex de,hl        ; ud.e = dy
0423C3 ED 4B 09 24 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
0423C8 C9          0123*      ret
0423C9             0124*  
0423C9             0125*  ; compute the euclidian distance between two cartesian coordinates
0423C9             0126*  ; using the formula d = sqrt(dx^2+dy^2
0423C9             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0423C9             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0423C9             0129*  ; output; uh.l is the 16.8 fixed format distance
0423C9             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
0423C9             0131*  ; destroys: a,hl,bc,de
0423C9             0132*  distance168:
0423C9             0133*  ; compute dx = x1-x0
0423C9 AF          0134*      xor a ; clear carry
0423CA DD E5       0135*      push ix ; move ix to hl via the stack
0423CC E1          0136*      pop hl ; hl = x1
0423CD ED 42       0137*      sbc hl,bc ; hl = dx
0423CF 22 09 24 04 0138*      ld (dx168),hl ; dx to scratch
0423D3             0139*  ; ; test dx for overflow
0423D3             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0423D3             0141*  ; 	ex de,hl
0423D3             0142*  ; 	sbc hl,de ; test for overflow
0423D3             0143*  ; 	push af ; carry indicates overflow
0423D3             0144*  ; compute dy = y1-y0
0423D3 AF          0145*      xor a ; clear carry
0423D4 FD E5       0146*      push iy ; move iy to hl via the stack
0423D6 E1          0147*      pop hl ; hl = y1
0423D7 ED 52       0148*      sbc hl,de ; hl = dy
0423D9 22 0F 24 04 0149*      ld (dy168),hl ; dy to scratch
0423DD             0150*  ; ; test dy for overflow
0423DD             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0423DD             0152*  ; 	ex de,hl
0423DD             0153*  ; 	sbc hl,de ; test for overflow
0423DD             0154*  ; 	push af ; carry indicates overflow
0423DD             0155*  ; compute dy^2
0423DD 2A 0F 24 04 0156*  	ld hl,(dy168)
0423E1 CD 91 21 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0423E5             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0423E5 E5          0159*      push hl ; load hl/2 to bc via the stack
0423E6 C1          0160*      pop bc ; bc = dy/2
0423E7 EB          0161*      ex de,hl ; de = dy/2
0423E8 CD E1 22 04 0162*      call umul168 ; uh.l = dy^2/2
0423EC E5          0163*      push hl ; dy^2/2 to the stack
0423ED             0164*  ; compute dx^2
0423ED 2A 09 24 04 0165*      ld hl,(dx168) ; get back dx
0423F1 CD 91 21 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0423F5             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0423F5 E5          0168*      push hl ; load hl/2 to bc via the stack
0423F6 C1          0169*      pop bc ; bc = dx/2
0423F7 EB          0170*      ex de,hl ; de = dx/2
0423F8 CD E1 22 04 0171*      call umul168 ; uh.l = dx^2/2
0423FC             0172*  ; commpute dy^2+dx^2
0423FC D1          0173*      pop de ; get back dx^2/2
0423FD 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
0423FE             0175*  ; compute sqrt(dx^2/2+dy^2/2)
0423FE CD C2 24 04 0176*      call sqrt168 ; uh.l = distance/2
042402             0177*      ; add hl,hl ; hl = distance
042402             0178*  ; ; check for overflow
042402             0179*  ; 	pop af ; get back the overflow flags
042402             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042402             0181*  ; 	ld b,a ; save the overflow flag
042402             0182*  ; 	pop af ; get back the overflow flags
042402             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
042402             0184*  ; 	add a,b ; if a != 0 then we had overflow
042402             0185*  ;     ret z ; no overflow we're done
042402             0186*  ; @overflow:
042402             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
042402 C9          0188*  	ret
042403             0189*  @scratch: ds 6
042409             0190*  dx168: ds 6
04240F             0191*  dy168: ds 6
042415             0192*  
042415             0193*  ; atan2(ub.c,ud.e) --> uh.l
042415             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042415             0195*  ;   whether inputs are integers or fractional doesn't matter
042415             0196*  ;   so long as the sign bit of the upper byte is correct
042415             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
042415             0198*  ; angles are COMPASS HEADINGS based on
042415             0199*  ; screen coordinate conventions,where the y axis is flipped
042415             0200*  ; #E0 315      0       45 #20
042415             0201*  ;        -x,-y | +x,-y
042415             0202*  ; #C0 270------+------ 90 #40
042415             0203*  ;        -x,+y | +x,+y
042415             0204*  ; #A0 225   180 #80   135 #60
042415             0205*  atan2_168game:
042415             0206*  ; get signs and make everything positive
042415             0207*  ; get abs(x) and store its original sign
042415 C5          0208*      push bc
042416 E1          0209*      pop hl
042417 CD 91 21 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
04241B E5          0211*      push hl ; store abs(x)
04241C C1          0212*      pop bc ; bc = abs(x)
04241D F5          0213*      push af ; store sign of x
04241E             0214*  ; get abs(y) and store its original sign
04241E EB          0215*      ex de,hl ; hl = y
04241F CD 91 21 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
042423 EB          0217*      ex de,hl ; de = abs(y)
042424 F5          0218*      push af ; store sign of y
042425             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
042425             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
042425 AF          0221*      xor a ; clear the carry flag
042426 D5          0222*      push de
042427 E1          0223*      pop hl
042428 ED 42       0224*      sbc hl,bc
04242A F5          0225*      push af ; save sign of de - bc
04242B F2 34 24 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
04242F             0227*  ; otherwise we swap bc and de
04242F C5          0228*      push bc
042430 E1          0229*      pop hl
042431 EB          0230*      ex de,hl
042432 E5          0231*      push hl
042433 C1          0232*      pop bc
042434             0233*  @1:
042434             0234*  ; now we're ready to snag our preliminary result
042434 CD A2 24 04 0235*      call atan_168game ; uh.l comes back with prelim result
042438             0236*  ; now we adjust uh.l based on sign of de - bc
042438 F1          0237*      pop af
042439 F2 45 24 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
04243D EB          0239*      ex de,hl
04243E 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
042442 AF          0241*      xor a ; clear the carry flag
042443 ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
042445             0243*      ; ld de,0 ; prep to clear hlu
042445             0244*      ; ld d,h
042445             0245*      ; ld e,l
042445             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
042445             0247*      ; fall through
042445             0248*  @2:
042445             0249*  ; now the fun part of adjusting the result
042445             0250*  ; based on which quadrant (x,y) is in
042445             0251*  ; #E0 315      0       45 #20
042445             0252*  ;        -x,-y | +x,-y
042445             0253*  ; #C0 270------+------ 90 #40
042445             0254*  ;        -x,+y | +x,+y
042445             0255*  ; #A0 225   180 #80   135 #60
042445 F1          0256*      pop af ; sign of y
042446 CA 83 24 04 0257*      jp z,@y_zero
04244A F2 63 24 04 0258*      jp p,@y_pos
04244E             0259*  ; y neg,check x
04244E F1          0260*      pop af ; sign of x
04244F CA 5D 24 04 0261*      jp z,@y_neg_x_zero
042453 F2 62 24 04 0262*      jp p,@y_neg_x_pos
042457             0263*  ; y neg,x neg
042457             0264*  ; angle is 270-360
042457             0265*  ; negating the intermediate does the trick
042457 CD A1 21 04 0266*      call neg_hlu
04245B 18 31       0267*      jr @zero_hlu
04245D             0268*  
04245D             0269*  @y_neg_x_zero:
04245D             0270*  ; y neg,x zero
04245D             0271*  ; angle is 0
04245D 21 00 00 00 0272*      ld hl,0
042461 C9          0273*      ret
042462             0274*  @y_neg_x_pos:
042462             0275*  ; y neg,x pos
042462             0276*  ; angle is 0 to 90
042462             0277*  ; so we're good
042462 C9          0278*      ret
042463             0279*  
042463             0280*  @y_pos:
042463 F1          0281*      pop af ; sign of x
042464 CA 73 24 04 0282*      jp z,@y_pos_x_zero
042468 F2 78 24 04 0283*      jp p,@y_pos_x_pos
04246C             0284*  ; y pos,x neg
04246C             0285*  ; angle is 180-270
04246C             0286*  ; so we add 180 to intermediate
04246C 11 00 80 00 0287*      ld de,0x008000
042470 19          0288*      add hl,de
042471 18 1B       0289*      jr @zero_hlu
042473             0290*  @y_pos_x_zero:
042473             0291*  ; y pos,x zero
042473             0292*  ; angle is 180
042473 21 00 80 00 0293*      ld hl,0x008000
042477 C9          0294*      ret
042478             0295*  @y_pos_x_pos:
042478             0296*  ; y pos,x pos
042478             0297*  ; angle is 90-180
042478             0298*  ; neg the intermediate and add 180 degrees
042478 CD A1 21 04 0299*      call neg_hlu
04247C 11 00 80 00 0300*      ld de,0x008000
042480 19          0301*      add hl,de
042481 18 0B       0302*      jr @zero_hlu
042483             0303*  
042483             0304*  @y_zero:
042483 F1          0305*      pop af ; sign of x
042484 FA 89 24 04 0306*      jp m,@y_zero_x_neg
042488             0307*  ; y zero,x pos
042488             0308*  ; angle is 90,nothing to do
042488 C9          0309*      ret
042489             0310*  @y_zero_x_neg:
042489             0311*  ; y zero ,x neg
042489             0312*  ; angle is 270
042489 21 00 C0 00 0313*      ld hl,0x00C000
04248D C9          0314*      ret
04248E             0315*  @zero_hlu:
04248E AF          0316*      xor a
04248F 22 9C 24 04 0317*      ld (@scratch),hl
042493 32 9E 24 04 0318*      ld (@scratch+2),a
042497 2A 9C 24 04 0319*      ld hl,(@scratch)
04249B C9          0320*      ret
04249C             0321*  @scratch: ds 6
0424A2             0322*  
0424A2             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0424A2             0324*  ; output: uh.l is the 16.8 fixed format angle
0424A2             0325*  ; destroys: a,hl,bc,de
0424A2             0326*  ; the following note was written by github copilot:
0424A2             0327*  ; note: this routine is a bit of a hack
0424A2             0328*  ;      but it works
0424A2             0329*  ;      and it's fast
0424A2             0330*  ;      and it's small
0424A2             0331*  ;      and it's accurate
0424A2             0332*  ;      and it's easy to understand
0424A2             0333*  ;      and it's easy to modify
0424A2             0334*  ;      and it's easy to use
0424A2             0335*  ;      and it's easy to remember
0424A2             0336*  ;      and it's easy to love
0424A2             0337*  ;      and it's easy to hate
0424A2             0338*  ;      and it's easy to ignore
0424A2             0339*  ;      and it's easy to forget
0424A2             0340*  ;      and it's easy to remember
0424A2             0341*  ;      and it's easy to forget
0424A2             0342*  ;      and it's easy to remember
0424A2             0343*  ;      (ok the bot is stuck in a loop)
0424A2             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0424A2             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0424A2             0346*  atan_168game:
0424A2             0347*  ; because we use compass headings instead of geometric angles
0424A2             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0424A2             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
0424A2 CD 28 21 04 0350*  	call udiv168 ; uh.l = dx/dy
0424A6             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0424A6             0352*  ; ; test uh.l for 0
0424A6             0353*  ;     add hl,de
0424A6             0354*  ;     or a
0424A6             0355*  ;     sbc hl,de
0424A6             0356*  ;     jr z,@is_zero
0424A6             0357*  ; ; test uh.l for 1
0424A6             0358*  ;     xor a ; clear carry
0424A6             0359*  ;     ex de,hl
0424A6             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0424A6             0361*  ;     sbc hl,de
0424A6             0362*  ;     jr z,@is_45
0424A6             0363*  ; ; END TODO
0424A6             0364*  
0424A6             0365*  ; no special cases so we move on
0424A6             0366*  ; l contains the fractional portion of tan(uh.l)
0424A6             0367*  ; we multiply it by three to get our lookup table index
0424A6 26 03       0368*      ld h,3
0424A8 ED 6C       0369*      mlt hl ; gosh that is handy
0424AA 11 00 00 00 0370*      ld de,0 ; clear deu
0424AE 54          0371*      ld d,h ; copy hl to de
0424AF 5D          0372*      ld e,l ; de contains our index
0424B0 21 AD 28 04 0373*      ld hl,atan_lut_168 ; grab the lut address
0424B4 19          0374*      add hl,de ; bump hl by the index
0424B5 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
0424B7 C9          0376*      ret ; and out
0424B8             0377*  @is_45:
0424B8 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
0424BC C9          0379*      ret
0424BD             0380*  ; for the case tan(0)
0424BD             0381*  @is_zero:
0424BD 21 00 00 00 0382*      ld hl,0x000000
0424C1 C9          0383*      ret
0424C2             0384*  
0424C2             0385*  ; Expects  ADL mode
0424C2             0386*  ; Inputs:  UH.L
0424C2             0387*  ; Outputs: UH.L is the 16.8 square root
0424C2             0388*  ;          UD.E is the difference inputHL-DE^2
0424C2             0389*  ;          c flag reset
0424C2             0390*  sqrt168:
0424C2 CD CC 24 04 0391*      call sqrt24
0424C6 EB          0392*      ex de,hl
0424C7 29          0393*      add hl,hl
0424C8 29          0394*      add hl,hl
0424C9 29          0395*      add hl,hl
0424CA 29          0396*      add hl,hl
0424CB C9          0397*      ret
0424CC             0398*  
0424CC             0399*  ; Expects  ADL mode
0424CC             0400*  ; Inputs:  HL
0424CC             0401*  ; Outputs: DE is the integer square root
0424CC             0402*  ;          HL is the difference inputHL-DE^2
0424CC             0403*  ;          c flag reset
0424CC             0404*  sqrt24:
0424CC AF          0405*      xor a
0424CD 45          0406*      ld b,l
0424CE C5          0407*      push bc
0424CF 47          0408*      ld b,a
0424D0 57          0409*      ld d,a
0424D1 4F          0410*      ld c,a
0424D2 6F          0411*      ld l,a
0424D3 5F          0412*      ld e,a
0424D4             0413*  
0424D4             0414*      ;Iteration 1
0424D4 29          0415*      add hl,hl
0424D5 CB 11       0416*      rl c
0424D7 29          0417*      add hl,hl
0424D8 CB 11       0418*      rl c
0424DA 91          0419*      sub c
0424DB 30 04       0420*      jr nc,$+6
0424DD 1C          0421*      inc e
0424DE 1C          0422*      inc e
0424DF 2F          0423*      cpl
0424E0 4F          0424*      ld c,a
0424E1             0425*  
0424E1             0426*      ;Iteration 2
0424E1 29          0427*      add hl,hl
0424E2 CB 11       0428*      rl c
0424E4 29          0429*      add hl,hl
0424E5 CB 11       0430*      rl c
0424E7 CB 13       0431*      rl e
0424E9 7B          0432*      ld a,e
0424EA 91          0433*      sub c
0424EB 30 04       0434*      jr nc,$+6
0424ED 1C          0435*      inc e
0424EE 1C          0436*      inc e
0424EF 2F          0437*      cpl
0424F0 4F          0438*      ld c,a
0424F1             0439*  
0424F1             0440*      ;Iteration 3
0424F1 29          0441*      add hl,hl
0424F2 CB 11       0442*      rl c
0424F4 29          0443*      add hl,hl
0424F5 CB 11       0444*      rl c
0424F7 CB 13       0445*      rl e
0424F9 7B          0446*      ld a,e
0424FA 91          0447*      sub c
0424FB 30 04       0448*      jr nc,$+6
0424FD 1C          0449*      inc e
0424FE 1C          0450*      inc e
0424FF 2F          0451*      cpl
042500 4F          0452*      ld c,a
042501             0453*  
042501             0454*      ;Iteration 4
042501 29          0455*      add hl,hl
042502 CB 11       0456*      rl c
042504 29          0457*      add hl,hl
042505 CB 11       0458*      rl c
042507 CB 13       0459*      rl e
042509 7B          0460*      ld a,e
04250A 91          0461*      sub c
04250B 30 04       0462*      jr nc,$+6
04250D 1C          0463*      inc e
04250E 1C          0464*      inc e
04250F 2F          0465*      cpl
042510 4F          0466*      ld c,a
042511             0467*  
042511             0468*      ;Iteration 5
042511 29          0469*      add hl,hl
042512 CB 11       0470*      rl c
042514 29          0471*      add hl,hl
042515 CB 11       0472*      rl c
042517 CB 13       0473*      rl e
042519 7B          0474*      ld a,e
04251A 91          0475*      sub c
04251B 30 04       0476*      jr nc,$+6
04251D 1C          0477*      inc e
04251E 1C          0478*      inc e
04251F 2F          0479*      cpl
042520 4F          0480*      ld c,a
042521             0481*  
042521             0482*      ;Iteration 6
042521 29          0483*      add hl,hl
042522 CB 11       0484*      rl c
042524 29          0485*      add hl,hl
042525 CB 11       0486*      rl c
042527 CB 13       0487*      rl e
042529 7B          0488*      ld a,e
04252A 91          0489*      sub c
04252B 30 04       0490*      jr nc,$+6
04252D 1C          0491*      inc e
04252E 1C          0492*      inc e
04252F 2F          0493*      cpl
042530 4F          0494*      ld c,a
042531             0495*  
042531             0496*      ;Iteration 7
042531 29          0497*      add hl,hl
042532 CB 11       0498*      rl c
042534 29          0499*      add hl,hl
042535 CB 11       0500*      rl c
042537 CB 10       0501*      rl b
042539 EB          0502*      ex de,hl
04253A 29          0503*      add hl,hl
04253B E5          0504*      push hl
04253C ED 42       0505*      sbc hl,bc
04253E 30 06       0506*      jr nc,$+8
042540 7C          0507*      ld a,h
042541 2F          0508*      cpl
042542 47          0509*      ld b,a
042543 7D          0510*      ld a,l
042544 2F          0511*      cpl
042545 4F          0512*      ld c,a
042546 E1          0513*      pop hl
042547 30 02       0514*      jr nc,$+4
042549 23          0515*      inc hl
04254A 23          0516*      inc hl
04254B EB          0517*      ex de,hl
04254C             0518*  
04254C             0519*      ;Iteration 8
04254C 29          0520*      add hl,hl
04254D 69          0521*      ld l,c
04254E 60          0522*      ld h,b
04254F ED 6A       0523*      adc hl,hl
042551 ED 6A       0524*      adc hl,hl
042553 EB          0525*      ex de,hl
042554 29          0526*      add hl,hl
042555 ED 52       0527*      sbc hl,de
042557 19          0528*      add hl,de
042558 EB          0529*      ex de,hl
042559 30 04       0530*      jr nc,$+6
04255B ED 52       0531*      sbc hl,de
04255D 13          0532*      inc de
04255E 13          0533*      inc de
04255F             0534*  
04255F             0535*      ;Iteration 9
04255F F1          0536*      pop af
042560 17          0537*      rla
042561 ED 6A       0538*      adc hl,hl
042563 17          0539*      rla
042564 ED 6A       0540*      adc hl,hl
042566 EB          0541*      ex de,hl
042567 29          0542*      add hl,hl
042568 ED 52       0543*      sbc hl,de
04256A 19          0544*      add hl,de
04256B EB          0545*      ex de,hl
04256C 30 04       0546*      jr nc,$+6
04256E ED 52       0547*      sbc hl,de
042570 13          0548*      inc de
042571 13          0549*      inc de
042572             0550*  
042572             0551*      ;Iteration 10
042572 17          0552*      rla
042573 ED 6A       0553*      adc hl,hl
042575 17          0554*      rla
042576 ED 6A       0555*      adc hl,hl
042578 EB          0556*      ex de,hl
042579 29          0557*      add hl,hl
04257A ED 52       0558*      sbc hl,de
04257C 19          0559*      add hl,de
04257D EB          0560*      ex de,hl
04257E 30 04       0561*      jr nc,$+6
042580 ED 52       0562*      sbc hl,de
042582 13          0563*      inc de
042583 13          0564*      inc de
042584             0565*  
042584             0566*      ;Iteration 11
042584 17          0567*      rla
042585 ED 6A       0568*      adc hl,hl
042587 17          0569*      rla
042588 ED 6A       0570*      adc hl,hl
04258A EB          0571*      ex de,hl
04258B 29          0572*      add hl,hl
04258C ED 52       0573*      sbc hl,de
04258E 19          0574*      add hl,de
04258F EB          0575*      ex de,hl
042590 30 04       0576*      jr nc,$+6
042592 ED 52       0577*      sbc hl,de
042594 13          0578*      inc de
042595 13          0579*      inc de
042596             0580*  
042596             0581*      ;Iteration 11
042596 17          0582*      rla
042597 ED 6A       0583*      adc hl,hl
042599 17          0584*      rla
04259A ED 6A       0585*      adc hl,hl
04259C EB          0586*      ex de,hl
04259D 29          0587*      add hl,hl
04259E ED 52       0588*      sbc hl,de
0425A0 19          0589*      add hl,de
0425A1 EB          0590*      ex de,hl
0425A2 30 04       0591*      jr nc,$+6
0425A4 ED 52       0592*      sbc hl,de
0425A6 13          0593*      inc de
0425A7 13          0594*      inc de
0425A8             0595*  
0425A8 CB 1A       0596*      rr d
0425AA CB 1B       0597*      rr e
0425AC C9          0598*      ret
0425AD             0599*  
0425AD             0600*  sin_lut_168:
0425AD 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
0425B0 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
0425B3 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
0425B6 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
0425B9 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
0425BC 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
0425BF 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
0425C2 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
0425C5 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
0425C8 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
0425CB 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
0425CE 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
0425D1 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
0425D4 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
0425D7 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
0425DA 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
0425DD 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
0425E0 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
0425E3 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
0425E6 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
0425E9 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
0425EC 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
0425EF 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
0425F2 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
0425F5 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
0425F8 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
0425FB 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
0425FE 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
042601 A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
042604 A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
042607 AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
04260A B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
04260D B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
042610 B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
042613 BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
042616 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
042619 C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
04261C C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
04261F CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
042622 D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
042625 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
042628 D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
04262B DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
04262E DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
042631 E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
042634 E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
042637 E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
04263A EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
04263D EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
042640 EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
042643 F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
042646 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
042649 F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
04264C F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
04264F F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
042652 F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
042655 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
042658 FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
04265B FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
04265E FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
042661 FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
042664 FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
042667 FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
04266A FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
04266D 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
042670 FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
042673 FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
042676 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
042679 FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
04267C FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
04267F FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
042682 FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
042685 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
042688 F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
04268B F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
04268E F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
042691 F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
042694 F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
042697 F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
04269A EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
04269D EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
0426A0 EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
0426A3 E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
0426A6 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
0426A9 E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
0426AC DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
0426AF DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
0426B2 D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
0426B5 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
0426B8 D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
0426BB CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
0426BE C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
0426C1 C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
0426C4 C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
0426C7 BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
0426CA B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
0426CD B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
0426D0 B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
0426D3 AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
0426D6 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
0426D9 A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
0426DC 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
0426DF 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
0426E2 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
0426E5 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
0426E8 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
0426EB 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
0426EE 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
0426F1 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
0426F4 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
0426F7 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
0426FA 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
0426FD 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
042700 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
042703 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
042706 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
042709 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
04270C 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
04270F 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
042712 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
042715 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
042718 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
04271B 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
04271E 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
042721 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
042724 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
042727 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
04272A 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
04272D 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
042730 FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
042733 F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
042736 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
042739 E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
04273C E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
04273F DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
042742 D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
042745 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
042748 C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
04274B C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
04274E BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
042751 B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
042754 B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042757 AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04275A A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
04275D 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
042760 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
042763 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
042766 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
042769 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
04276C 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
04276F 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
042772 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
042775 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
042778 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
04277B 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
04277E 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042781 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
042784 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042787 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04278A 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
04278D 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042790 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
042793 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
042796 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042799 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
04279C 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
04279F 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0427A2 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0427A5 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0427A8 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0427AB 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0427AE 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0427B1 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0427B4 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0427B7 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0427BA 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0427BD 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0427C0 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0427C3 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0427C6 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0427C9 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0427CC 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0427CF 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0427D2 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0427D5 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0427D8 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0427DB 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0427DE 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0427E1 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0427E4 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0427E7 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0427EA 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0427ED 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0427F0 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0427F3 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0427F6 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0427F9 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0427FC 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0427FF 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042802 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042805 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042808 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04280B 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
04280E 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042811 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042814 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042817 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04281A 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
04281D 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042820 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
042823 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
042826 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
042829 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
04282C 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
04282F 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
042832 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
042835 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042838 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
04283B 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
04283E 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042841 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
042844 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
042847 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04284A 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
04284D 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
042850 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
042853 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
042856 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
042859 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
04285C 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
04285F 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
042862 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
042865 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
042868 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
04286B 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
04286E 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
042871 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
042874 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
042877 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04287A 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
04287D 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042880 A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
042883 AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
042886 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042889 B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
04288C BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
04288F C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042892 C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
042895 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
042898 D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04289B DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
04289E E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0428A1 E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0428A4 EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0428A7 F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0428AA FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0428AD             0857*  
0428AD             0858*  atan_lut_168:
0428AD 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
0428B0 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
0428B3 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
0428B6 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
0428B9 A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
0428BC CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
0428BF F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
0428C2 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
0428C5 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
0428C8 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
0428CB 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
0428CE BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
0428D1 E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
0428D4 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
0428D7 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
0428DA 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
0428DD 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
0428E0 B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
0428E3 DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
0428E6 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
0428E9 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
0428EC 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
0428EF 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
0428F2 A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
0428F5 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
0428F8 F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
0428FB 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
0428FE 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
042901 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
042904 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
042907 C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
04290A E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
04290D 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
042910 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
042913 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
042916 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
042919 B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
04291C D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
04291F 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
042922 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
042925 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
042928 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
04292B A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
04292E C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
042931 EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
042934 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
042937 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
04293A 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
04293D 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
042940 B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
042943 DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
042946 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
042949 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
04294C 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
04294F 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
042952 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
042955 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
042958 ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
04295B 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
04295E 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
042961 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
042964 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
042967 AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
04296A D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
04296D FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
042970 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
042973 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
042976 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
042979 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
04297C BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
04297F E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
042982 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
042985 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
042988 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
04298B 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
04298E 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
042991 C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
042994 E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
042997 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
04299A 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
04299D 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
0429A0 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
0429A3 A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
0429A6 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
0429A9 EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
0429AC 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
0429AF 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
0429B2 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
0429B5 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
0429B8 A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
0429BB C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
0429BE EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
0429C1 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
0429C4 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
0429C7 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
0429CA 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
0429CD 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
0429D0 C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
0429D3 E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
0429D6 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
0429D9 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
0429DC 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
0429DF 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
0429E2 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
0429E5 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
0429E8 DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
0429EB FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
0429EE 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
0429F1 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
0429F4 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
0429F7 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
0429FA AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
0429FD CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
042A00 EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
042A03 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
042A06 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
042A09 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
042A0C 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
042A0F 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
042A12 BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
042A15 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
042A18 FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
042A1B 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
042A1E 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
042A21 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
042A24 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
042A27 A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
042A2A C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
042A2D E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
042A30 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
042A33 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
042A36 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
042A39 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
042A3C 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
042A3F A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
042A42 C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
042A45 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
042A48 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
042A4B 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
042A4E 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
042A51 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
042A54 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
042A57 A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
042A5A C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
042A5D E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
042A60 FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
042A63 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
042A66 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
042A69 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
042A6C 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
042A6F 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
042A72 B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
042A75 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
042A78 F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
042A7B 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
042A7E 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
042A81 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
042A84 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
042A87 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
042A8A A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
042A8D C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
042A90 DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
042A93 FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
042A96 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
042A99 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
042A9C 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
042A9F 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
042AA2 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
042AA5 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
042AA8 C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
042AAB E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
042AAE FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
042AB1 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
042AB4 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
042AB7 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
042ABA 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
042ABD 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
042AC0 A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
042AC3 C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
042AC6 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
042AC9 F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
042ACC 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
042ACF 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
042AD2 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
042AD5 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
042AD8 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
042ADB 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
042ADE B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
042AE1 CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
042AE4 E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
042AE7 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
042AEA 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
042AED 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
042AF0 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
042AF3 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
042AF6 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
042AF9 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
042AFC B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
042AFF D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
042B02 EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
042B05 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
042B08 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
042B0B 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
042B0E 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
042B11 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
042B14 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
042B17 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
042B1A B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
042B1D CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
042B20 E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
042B23 FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
042B26 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
042B29 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
042B2C 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
042B2F 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
042B32 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
042B35 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
042B38 A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
042B3B BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
042B3E D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
042B41 EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
042B44 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
042B47 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
042B4A 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
042B4D 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
042B50 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
042B53 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
042B56 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
042B59 A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
042B5C BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
042B5F D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
042B62 E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
042B65 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
042B68 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
042B6B 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
042B6E 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
042B71 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
042B74 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
042B77 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
042B7A 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
042B7D AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
042B80 C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
042B83 DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
042B86 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
042B89 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
042B8C 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
042B8F 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
042B92 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
042B95 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
042B98 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
042B9B 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
042B9E 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
042BA1 AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
042BA4 C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
042BA7 D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
042BAA EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
042BAD 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042BB0             0060   ; App-specific includes
042BB0             0061   	include "player.inc"
042BB0             0001*  ; ######## GAME STATE VARIABLES #######
042BB0             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042BB0 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042BB3             0004*  ; player current shields,binary
042BB3             0005*  ; when < 0 player splodes
042BB3             0006*  ; restores to player_max_shields when new ship spawns
042BB3 10          0007*  player_shields: db 16 ; binary
042BB4             0008*  ; max player shields,binary
042BB4             0009*  ; can increase with power-ups (todo)
042BB4 10          0010*  player_max_shields: db 16 ; binary
042BB5             0011*  ; when reaches zero,game ends
042BB5             0012*  ; can increase based on TODO
042BB5 03          0013*  player_ships: db 0x03 ; binary
042BB6             0014*  
042BB6             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042BB6             0016*  ; uses the same offsets from its table base as the main sprite table:
042BB6             0017*  player_start_variables: ; label marking beginning of table
042BB6 04          0018*  player_id:               db table_max_records
042BB7 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042BB8 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042BBB 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042BBE 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042BBF 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042BC0 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042BC1 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042BC4 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042BC7 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042BCA 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042BCD 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042BD0 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042BD3 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042BD6 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042BD7 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042BD8 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042BD9 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042BDA 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042BDB 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042BDC             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042BDC             0039*  
042BDC             0040*  ; set initial player position
042BDC             0041*  ; inputs: none,everything is hardcoded
042BDC             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042BDC             0043*  ; destroys: a
042BDC             0044*  player_init:
042BDC 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
042BDE CD 88 1F 04 0046*  	call vdu_sprite_select
042BE2 CD 9B 1F 04 0047*      call vdu_sprite_clear_frames
042BE6 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042BEA CD D5 20 04 0049*      call vdu_sprite_add_buff
042BEE 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042BF2 CD D5 20 04 0051*      call vdu_sprite_add_buff
042BF6 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042BFA CD D5 20 04 0053*      call vdu_sprite_add_buff
042BFE 01 00 00 00 0054*      ld bc,0
042C02 ED 43 C1 2B 0055*      ld (player_x),bc
       04          
042C07 11 00 DF 00 0056*      ld de,0x00DF00
042C0B ED 53 C4 2B 0057*      ld (player_y),de
       04          
042C10 CD 54 20 04 0058*      call vdu_sprite_move_abs168
042C14 CD FE 1F 04 0059*      call vdu_sprite_show
042C18 C9          0060*      ret
042C19             0061*  
042C19             0062*  ; process player keyboard input, set player bitmap
042C19             0063*  ; velocities and draw player bitmap at updated coordinates
042C19             0064*  ; Inputs: player_x/y set at desired position
042C19             0065*  ; Returns: player bitmap drawn at updated position
042C19             0066*  ; Destroys: probably everything except maybe iy
042C19             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042C19             0068*  ; TODO: requires sprite implementation
042C19             0069*  player_input:
042C19             0070*  ; reset player component velocities to zero as the default
042C19 21 00 00 00 0071*  	ld hl,0
042C1D 22 C7 2B 04 0072*  	ld (player_xvel),hl
042C21 22 CA 2B 04 0073*  	ld (player_yvel),hl
042C25             0074*  ; make ship the active sprite
042C25 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
042C27 CD 88 1F 04 0076*      call vdu_sprite_select
042C2B             0077*  ; check for keypresses and branch accordingly
042C2B             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042C2B             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042C2B 3E 1E       0001*M 			LD	A, function
042C2D 5B CF       0002*M 			RST.LIL	08h
042C2F             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042C2F             0081*  ; this handles the case where two opposing movement keys
042C2F             0082*  ; are down simultaneously (velocities will net to zero)
042C2F             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042C2F             0084*  ; it also allows movement and action keys to be detected simultaneously
042C2F             0085*  ; so we can walk and chew gum at the same time
042C2F 3E 01       0086*      ld a,1 ; set ship's default animation to center
042C31             0087*          ; if left and right are both down a will net to
042C31             0088*  
042C31             0089*  @left:
042C31 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042C35 28 0E       0091*      jr z,@right
042C37 2A C7 2B 04 0092*      ld hl,(player_xvel)
042C3B 01 00 FD FF 0093*      ld bc,-speed_player
042C3F 09          0094*      add hl,bc
042C40 22 C7 2B 04 0095*      ld (player_xvel),hl
042C44 3D          0096*      dec a ; set ship's animation to left
042C45             0097*  @right:
042C45 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042C49 28 0E       0099*  	jr z,@up
042C4B 2A C7 2B 04 0100*      ld hl,(player_xvel)
042C4F 01 00 03 00 0101*      ld bc,speed_player
042C53 09          0102*      add hl,bc
042C54 22 C7 2B 04 0103*      ld (player_xvel),hl
042C58 3C          0104*      inc a ; set ship's animation to right
042C59             0105*  @up:
042C59 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042C5D 28 0D       0107*  	jr z,@down
042C5F 2A CA 2B 04 0108*      ld hl,(player_yvel)
042C63 01 00 FD FF 0109*      ld bc,-speed_player
042C67 09          0110*      add hl,bc
042C68 22 CA 2B 04 0111*      ld (player_yvel),hl
042C6C             0112*  @down:
042C6C DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042C70 28 0D       0114*  	jr z,@done_keyboard
042C72 2A CA 2B 04 0115*      ld hl,(player_yvel)
042C76 01 00 03 00 0116*      ld bc,speed_player
042C7A 09          0117*      add hl,bc
042C7B 22 CA 2B 04 0118*      ld (player_yvel),hl
042C7F             0119*  @done_keyboard:
042C7F             0120*  ; move player sprite according to velocities set by keypresses
042C7F 2A C7 2B 04 0121*      ld hl,(player_xvel)
042C83             0122*  ; compute new x position
042C83 ED 5B C1 2B 0123*      ld de,(player_x)
       04          
042C88 19          0124*      add hl,de ; hl = player_x + player_xvel
042C89             0125*      ; check for horizontal screen edge collisions
042C89             0126*      ; and adjust coordinate as necessary
042C89             0127*  ; TODO: make this work using 24-bit registers
042C89             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042C89             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042C89             0130*      ; ld a,8 ; set x to leftmost allowable position
042C89             0131*  ; @check_right:
042C89             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042C89             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042C89             0134*  ;     ld a,248 ; set x to rightmost allowable position
042C89             0135*  @x_ok:
042C89             0136*  ; save the updated drawing coordinate
042C89 22 C1 2B 04 0137*      ld (player_x),hl
042C8D             0138*  ;compute new y position
042C8D 2A C4 2B 04 0139*      ld hl,(player_y)
042C91 ED 5B CA 2B 0140*      ld de,(player_yvel)
       04          
042C96 19          0141*      add hl,de ; hl = player_y + player_yvel
042C97             0142*  ; TODO: make this work using 24-bit registers
042C97             0143*  ;     ; check for vertical screen edge collisions
042C97             0144*  ;     ; and adjust coordinate as necessary
042C97             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042C97             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042C97             0147*  ;     ld a,8 ; set y to topmost allowable position
042C97             0148*  ; @check_top:
042C97             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042C97             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042C97             0151*  ;     ld a,232 ; set y to bottommost allowable position
042C97             0152*  @y_ok:
042C97 22 C4 2B 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042C9B             0154*  ; a should land here loaded with the correct frame
042C9B CD EB 1F 04 0155*      call vdu_sprite_select_frame
042C9F             0156*  ; draw player at updated position
042C9F ED 4B C1 2B 0157*      ld bc,(player_x)
       04          
042CA4 ED 5B C4 2B 0158*  	ld de,(player_y)
       04          
042CA9             0159*  
042CA9             0160*      ; call dumpRegistersHex
042CA9             0161*  
042CA9 CD 54 20 04 0162*  	call vdu_sprite_move_abs168
042CAD             0163*  
042CAD             0164*  ; end player_input
042CAD C9          0165*  	ret
042CAE             0166*  
042CAE             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042CAE             0168*  ; ; INSTEAD OF FRACTIONAL
042CAE             0169*  ; ; ----------------------------------------------------------------
042CAE             0170*  ; ; process player keyboard input, set player bitmap
042CAE             0171*  ; ; velocities and draw player bitmap at updated coordinates
042CAE             0172*  ; ; Inputs: player_x/y set at desired position
042CAE             0173*  ; ; Returns: player bitmap drawn at updated position
042CAE             0174*  ; ; Destroys: probably everything except maybe iy
042CAE             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042CAE             0176*  ; ; TODO: requires sprite implementation
042CAE             0177*  ; player_input:
042CAE             0178*  ; ; reset player component velocities to zero as the default
042CAE             0179*  ; 	ld hl,0
042CAE             0180*  ; 	ld (player_xvel),hl
042CAE             0181*  ; 	ld (player_yvel),hl
042CAE             0182*  ; ; check for keypresses and branch accordingly
042CAE             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042CAE             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042CAE             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042CAE             0186*  ; ; this handles the case where two opposing movement keys
042CAE             0187*  ; ; are down simultaneously (velocities will net to zero)
042CAE             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042CAE             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042CAE             0190*  ; ; so we can walk and chew gum at the same time
042CAE             0191*  ; @left:
042CAE             0192*  ;     bit 1,(ix+3) ; keycode 26
042CAE             0193*  ;     jr z,@right
042CAE             0194*  ;     ld hl,(player_xvel)
042CAE             0195*  ;     ld bc,-3
042CAE             0196*  ;     add hl,bc
042CAE             0197*  ;     ld (player_xvel),hl
042CAE             0198*  ; @right:
042CAE             0199*  ;     bit 1,(ix+15) ; keycode 122
042CAE             0200*  ; 	jr z,@up
042CAE             0201*  ;     ld hl,(player_xvel)
042CAE             0202*  ;     ld bc,3
042CAE             0203*  ;     add hl,bc
042CAE             0204*  ;     ld (player_xvel),hl
042CAE             0205*  ; @up:
042CAE             0206*  ;     bit 1,(ix+7) ; keycode 58
042CAE             0207*  ; 	jr z,@down
042CAE             0208*  ;     ld hl,(player_yvel)
042CAE             0209*  ;     ld bc,-3
042CAE             0210*  ;     add hl,bc
042CAE             0211*  ;     ld (player_yvel),hl
042CAE             0212*  ; @down:
042CAE             0213*  ;     bit 1,(ix+5) ; keycode 42
042CAE             0214*  ; 	jr z,@done_keyboard
042CAE             0215*  ;     ld hl,(player_yvel)
042CAE             0216*  ;     ld bc,3
042CAE             0217*  ;     add hl,bc
042CAE             0218*  ;     ld (player_yvel),hl
042CAE             0219*  ; @done_keyboard:
042CAE             0220*  ; ; move player sprite according to velocities set by keypresses
042CAE             0221*  ;     ld hl,(player_xvel)
042CAE             0222*  ; ; compute new x position
042CAE             0223*  ;     ld de,(player_x)
042CAE             0224*  ;     add hl,de ; hl = player_x + player_xvel
042CAE             0225*  ;     ; check for horizontal screen edge collisions
042CAE             0226*  ;     ; and adjust coordinate as necessary
042CAE             0227*  ; ; TODO: make this work using 24-bit registers
042CAE             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042CAE             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042CAE             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042CAE             0231*  ; ; @check_right:
042CAE             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042CAE             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042CAE             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042CAE             0235*  ; @x_ok:
042CAE             0236*  ;     ; save the updated drawing coordinate
042CAE             0237*  ;     ld (player_x),hl
042CAE             0238*  ; ;compute new y position
042CAE             0239*  ;     ld hl,(player_y)
042CAE             0240*  ;     ld de,(player_yvel)
042CAE             0241*  ;     add hl,de ; hl = player_y + player_yvel
042CAE             0242*  ; ; TODO: make this work using 24-bit registers
042CAE             0243*  ; ;     ; check for vertical screen edge collisions
042CAE             0244*  ; ;     ; and adjust coordinate as necessary
042CAE             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042CAE             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042CAE             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042CAE             0248*  ; ; @check_top:
042CAE             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042CAE             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042CAE             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042CAE             0252*  ; @y_ok:
042CAE             0253*  ;     ld (player_y),hl
042CAE             0254*  ; ; draw player at updated position
042CAE             0255*  ;     ld a,table_max_records ; this is always player spriteId
042CAE             0256*  ;     call vdu_sprite_select
042CAE             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042CAE             0258*  ;     call get_sign_hlu ; to set the proper animation
042CAE             0259*  ;     add a,1 ; ...
042CAE             0260*  ;     call vdu_sprite_select_frame
042CAE             0261*  ;     ld bc,(player_x)
042CAE             0262*  ; 	ld de,(player_y)
042CAE             0263*  ; 	call vdu_sprite_move_abs
042CAE             0264*  ; ; end player_input
042CAE             0265*  ; 	ret
042CAE             0266*  
042CAE             0267*  
042CAE             0268*  ; ###################################################################
042CAE             0269*  ; TODO: the below is all stuff from the original code we need to port
042CAE             0270*  ; ###################################################################
042CAE             0271*  
042CAE             0272*  ; kill_player:
042CAE             0273*  ; ; set player status to dead
042CAE             0274*  ;     xor a; sets all player flags to zero
042CAE             0275*  ;     ld (player_collisions),a
042CAE             0276*  ; ; deduct a ship from the inventory
042CAE             0277*  ;     ld a,(player_ships)
042CAE             0278*  ;     dec a
042CAE             0279*  ;     ld (player_ships),a
042CAE             0280*  ; ; are we out of ships?
042CAE             0281*  ;     jp z,game_over
042CAE             0282*  ; ; wait a few ticks
042CAE             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042CAE             0284*  ;     ld (player_move_timer),a
042CAE             0285*  ; kill_player_loop:
042CAE             0286*  ;     call vdu_vblank
042CAE             0287*  ;     ld a,(player_move_timer)
042CAE             0288*  ;     dec a
042CAE             0289*  ;     ld (player_move_timer),a
042CAE             0290*  ;     jr nz,kill_player_loop
042CAE             0291*  ;     call player_init ; player respawn if timer zero
042CAE             0292*  ;     ret ; and out
042CAE             0293*  
042CAE             0294*  
042CAE             0295*  ; player_move:
042CAE             0296*  ; ; begin setting player to active sprite
042CAE             0297*  ;     ld hl,player
042CAE             0298*  ;     ld (sprite_base_bufferId),hl
042CAE             0299*  ;     ld hl,0 ; north
042CAE             0300*  ;     ld (sprite_heading),hl
042CAE             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042CAE             0302*  ;     ld (sprite_animation),a
042CAE             0303*  ;     ; we set position here for the time being as a default
042CAE             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042CAE             0305*  ;     ld hl,(player_x)
042CAE             0306*  ;     ld (sprite_x),hl
042CAE             0307*  ;     ld hl,(player_y)
042CAE             0308*  ;     ld (sprite_y),hl
042CAE             0309*  ; ; did we just die?
042CAE             0310*  ;     ld a,(player_collisions)
042CAE             0311*  ;     and %00000010 ; zero flag will be set if not dead
042CAE             0312*  ;     jr z,player_not_dead
042CAE             0313*  ; ; yes we died
042CAE             0314*  ;     call kill_player
042CAE             0315*  ;     ret ; done
042CAE             0316*  ; ; yay we didn't die
042CAE             0317*  ; player_not_dead:
042CAE             0318*  ; ; set player movements to zero by default
042CAE             0319*  ;     ld hl,0
042CAE             0320*  ;     ld (player_xvel),hl
042CAE             0321*  ;     ld (player_yvel),hl
042CAE             0322*  ; ; do we move it?
042CAE             0323*  ;     in a,(#82) ; keyboard
042CAE             0324*  ;     or a ; if zero,don't move
042CAE             0325*  ;     jr z,player_draw
042CAE             0326*  ; ; move it
042CAE             0327*  ;     call player_move_calc
042CAE             0328*  ; player_draw:
042CAE             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042CAE             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042CAE             0331*  ; player_move_done:
042CAE             0332*  ;     ; write updated x,y coordinates back to player table
042CAE             0333*  ;     ld hl,(sprite_x)
042CAE             0334*  ;     ld (player_x),hl
042CAE             0335*  ;     ld hl,(sprite_y)
042CAE             0336*  ;     ld (player_y),hl
042CAE             0337*  ;     ret
042CAE             0062   	include "tiles.inc"
042CAE             0001*  ; ######### TILES #########
042CAE             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042CAE             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042CAE 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042CB1 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042CB2             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042CB2 00          0007*  cur_level: db 0
042CB3             0008*  num_levels: equ 2 ; number of levels,duh
042CB3             0009*  
042CB3             0010*  ; lookup table for level definitions
042CB3 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042CB9             0012*  
042CB9             0013*  ; tiles_bufferId: dl 0
042CB9 00 00 00    0014*  tiles_x_plot: dl 0
042CBC F1 FF FF    0015*  tiles_y_plot: dl -15
042CBF             0016*  
042CBF             0017*  
042CBF             0018*  tiles_plot:
042CBF             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042CBF             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042CBF             0021*  ; ;       but don't want
042CBF             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042CBF             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042CBF             0024*  ; 	ld bc,0 ; leftmost x-coord
042CBF             0025*  ; 	ld de,0 ; topmost y-coord
042CBF             0026*  ; 	ld ix,255 ; rightmost x-coord
042CBF             0027*  ; 	ld iy,1 ; bottommost y-coord
042CBF             0028*  ; 	call vdu_set_gfx_viewport
042CBF             0029*  
042CBF 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042CC3 22 B9 2C 04 0031*      ld (tiles_x_plot),hl
042CC7 2A AE 2C 04 0032*      ld hl,(tiles_row_defs)
042CCB 06 10       0033*  	ld b,16 ; loop counter
042CCD             0034*  @loop:
042CCD C5          0035*  	push bc ; save the loop counter
042CCE             0036*  ; read the tile defintion for the current column
042CCE 7E          0037*      ld a,(hl) ; a has tile definition
042CCF E5          0038*      push hl  ; save pointer to tile definition
042CD0 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042CD4 6F          0040*      ld l,a ; l is tile defintion
042CD5 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042CD7 CD 1E 1C 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042CDB             0043*  
042CDB             0044*  ; plot the active bitmap
042CDB ED 4B B9 2C 0045*      ld bc,(tiles_x_plot)
       04          
042CE0 ED 5B BC 2C 0046*      ld de,(tiles_y_plot)
       04          
042CE5 CD E7 1E 04 0047*      call vdu_plot_bmp
042CE9             0048*  
042CE9             0049*  ; bump x-coords the width of one tile and save it
042CE9 2A B9 2C 04 0050*      ld hl,(tiles_x_plot)
042CED 01 10 00 00 0051*      ld bc,16
042CF1 09          0052*      add hl,bc
042CF2 22 B9 2C 04 0053*      ld (tiles_x_plot),hl
042CF6             0054*  
042CF6             0055*  ; prepare to loop to next column
042CF6 E1          0056*      pop hl ; get back pointer to tile def
042CF7 23          0057*      inc hl ; bump it to the next column
042CF8 C1          0058*  	pop bc ; snag our loop counter
042CF9 10 D2       0059*      djnz @loop
042CFB             0060*  
042CFB             0061*  ; increment tiles plotting y-coordinate
042CFB             0062*  ; when it hits zero, we go to next row of tiles in the map
042CFB             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042CFB DD 21 BC 2C 0064*  	ld ix,tiles_y_plot
       04          
042D00 DD 34 00    0065*  	inc (ix)
042D03 C0          0066*  	ret nz
042D04             0067*  
042D04             0068*  ; time to bump tiles_row_defs to next row
042D04             0069*  ; (hl was already there at the end of the loop)
042D04 22 AE 2C 04 0070*      ld (tiles_row_defs),hl
042D08             0071*  
042D08             0072*  ; reset coords to plot next row of tiles
042D08 21 00 00 00 0073*      ld hl,0
042D0C 22 B9 2C 04 0074*      ld (tiles_x_plot),hl
042D10 21 F1 FF FF 0075*      ld hl,-15
042D14 22 BC 2C 04 0076*      ld (tiles_y_plot),hl
042D18             0077*  
042D18             0078*  ; decrement tiles row counter
042D18 21 B1 2C 04 0079*      ld hl,tiles_row
042D1C 35          0080*      dec (hl)
042D1D C0          0081*      ret nz
042D1E             0082*  
042D1E             0083*  ; queue up next level
042D1E 3A B2 2C 04 0084*      ld a,(cur_level)
042D22 FE 01       0085*      cp num_levels-1
042D24 20 02       0086*      jr nz,@inc_level
042D26 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
042D28             0088*  
042D28             0089*  @inc_level:
042D28 3C          0090*      inc a
042D29 32 B2 2C 04 0091*      ld (cur_level),a
042D2D             0092*  
042D2D             0093*  ; increase the number of enemy sprites
042D2D 3A 74 2D 04 0094*      ld a,(max_enemy_sprites)
042D31 3C          0095*      inc a
042D32 FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
042D34 28 04       0097*      jr z,init_level
042D36 32 74 2D 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
042D3A             0099*  ; fall through to init_level
042D3A             0100*  
042D3A             0101*  init_level:
042D3A             0102*  ; look up address of level's tile defintion
042D3A 21 B3 2C 04 0103*      ld hl,tiles_levels
042D3E 3A B2 2C 04 0104*      ld a,(cur_level)
042D42 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
042D46 57          0106*      ld d,a
042D47 1E 03       0107*      ld e,3
042D49 ED 5C       0108*      mlt de
042D4B 19          0109*      add hl,de
042D4C ED 37       0110*      ld ix,(hl)
042D4E DD 22 AE 2C 0111*      ld (tiles_row_defs),ix
       04          
042D53             0112*  
042D53             0113*  ; set tiles_row counter
042D53 DD 7E 00    0114*      ld a,(ix)
042D56 32 B1 2C 04 0115*      ld (tiles_row),a
042D5A DD 23       0116*      inc ix ; now ix points first element of first row tile def
042D5C DD 22 AE 2C 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
042D61 C9          0118*      ret
042D62             0119*  
042D62             0120*  
042D62             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
042D62             0122*  ; dt_is_active:
042D62             0123*  ; ; a lands here containing a tile index in the low nibble
042D62             0124*  ; ; we test the values for the tiles which are active
042D62             0125*  ;     cp #07
042D62             0126*  ;     call z,ld_act_landing_pad
042D62             0127*  ;     cp #08
042D62             0128*  ;     call z,ld_act_laser_turret
042D62             0129*  ;     ; fall through
042D62             0130*  ;     ret
042D62             0131*  
042D62             0132*  ; ; some tiles become active sprites,so we load those here
042D62             0133*  ; ; sprite_x/y have already been loaded
042D62             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
042D62             0135*  ; ; we don't want sprite drawn to background like other tiles
042D62             0136*  ; ; so this routine only adds them to the sprite table
042D62             0137*  ; dt_ld_act:
042D62             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
042D62             0139*  ;     ld (sprite_y+1),a ; just the integer part
042D62             0140*  ;     ld (sprite_base_bufferId),hl
042D62             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042D62             0142*  ;     call table_add_record
042D62             0143*  ;     call sprite_variables_from_stack
042D62             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
042D62             0145*  ;     ret ; and back
042D62             0146*  
042D62             0147*  ; ld_act_landing_pad:
042D62             0148*  ;     call sprite_variables_to_stack
042D62             0149*  
042D62             0150*  ;     ld hl,move_landing_pad
042D62             0151*  ;     ld (sprite_move_program),hl
042D62             0152*  
042D62             0153*  ;     xor a
042D62             0154*  ;     ld (sprite_animation),a ; animation 0
042D62             0155*  
042D62             0156*  ;     call rand_8     ; snag a random number
042D62             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042D62             0158*  ;     add a,64 ; range is now 64-127
042D62             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042D62             0160*  
042D62             0161*  ;     ld a,%10 ; collides with laser but not player
042D62             0162*  ;     ld (iy+sprite_collisions),a
042D62             0163*  
042D62             0164*  ;     ld a,#05 ; BCD
042D62             0165*  ;     ld (sprite_points),a
042D62             0166*  ;     ld a,0 ; binary
042D62             0167*  ;     ld (sprite_shield_damage),a
042D62             0168*  
042D62             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
042D62             0170*  ;     jr dt_ld_act
042D62             0171*  
042D62             0172*  ; ld_act_laser_turret:
042D62             0173*  ;     call sprite_variables_to_stack
042D62             0174*  
042D62             0175*  ;     ld hl,move_laser_turret
042D62             0176*  ;     ld (sprite_move_program),hl
042D62             0177*  
042D62             0178*  ;     xor a
042D62             0179*  ;     ld (sprite_animation),a
042D62             0180*  ;     ld (sprite_move_step),a
042D62             0181*  
042D62             0182*  ;     call rand_8     ; snag a random number
042D62             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042D62             0184*  ;     add a,64 ; range is now 64-127
042D62             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042D62             0186*  
042D62             0187*  ;     ld a,%10 ; collides with laser but not player
042D62             0188*  ;     ld (iy+sprite_collisions),a
042D62             0189*  
042D62             0190*  ;     ld a,#10 ; BCD
042D62             0191*  ;     ld (sprite_points),a
042D62             0192*  ;     ld a,0 ; binary
042D62             0193*  ;     ld (sprite_shield_damage),a
042D62             0194*  
042D62             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
042D62             0196*  ;     jp dt_ld_act
042D62             0197*  
042D62             0198*  
042D62             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
042D62             0200*  ; deletes sprites from table when they wrap around to top of screen
042D62             0201*  move_active_tiles:
042D62             0202*  ; get current position
042D62 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
042D66 3C          0204*      inc a
042D67             0205*  ; are we at the bottom of the screen?
042D67 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
042D69             0207*  ; otherwise kill sprite
042D69 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
042D6B FD 77 08    0209*      ld (iy+sprite_collisions),a
042D6E C9          0210*      ret ; debug
042D6F             0211*  move_active_tiles_draw_sprite:
042D6F 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
042D73             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042D73             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
042D73 C9          0215*      ret ; and done
042D74             0063   	include "enemies.inc"
042D74 10          0001*  max_enemy_sprites: db 16
042D75             0002*  
042D75             0003*  ; sprite_type
042D75             0004*  enemy_dead: equ 0
042D75             0005*  enemy_small: equ 1
042D75             0006*  enemy_medium: equ 2
042D75             0007*  enemy_large: equ 3
042D75             0008*  landing_pad: equ 4
042D75             0009*  laser_turret: equ 5
042D75             0010*  fireballs: equ 6
042D75             0011*  explosion: equ 7
042D75             0012*  
042D75             0013*  
042D75             0014*  respawn_countdown:
042D75 2A 96 2D 04 0015*      ld hl,(respawn_timer)
042D79 2B          0016*      dec hl
042D7A 22 96 2D 04 0017*      ld (respawn_timer),hl
042D7E             0018*  ; check hl for zero
042D7E 19          0019*      add hl,de
042D7F B7          0020*      or a
042D80 ED 52       0021*      sbc hl,de
042D82 C0          0022*      ret nz
042D83 06 04       0023*      ld b,table_max_records
042D85             0024*  @respawn_loop:
042D85 C5          0025*      push bc
042D86 CD 87 2E 04 0026*      call enemy_init_from_landing_pad
042D8A C1          0027*      pop bc
042D8B 10 F8       0028*      djnz @respawn_loop
042D8D 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
042D91 22 96 2D 04 0030*      ld (respawn_timer),hl
042D95 C9          0031*      ret
042D96 3C 00 00    0032*  respawn_timer: dl 1*60
042D99             0033*  
042D99             0034*  move_enemies:
042D99             0035*  ; are there any active enemies or explosions?
042D99 21 00 00 00 0036*      ld hl,0
042D9D 3A 7D 16 04 0037*      ld a,(table_active_sprites)
042DA1 6F          0038*      ld l,a
042DA2             0039*      ; call dumpRegistersHex
042DA2 A7          0040*      and a ; will be zero if no alive enemies or explosions
042DA3             0041*      ; ret z ; so nothing to do but go back
042DA3             0042*      ; ld hl,(respawn_timer)
042DA3             0043*      ; call dumpRegistersHex
042DA3 20 05       0044*      jr nz,move_enemies_do
042DA5 CD 75 2D 04 0045*      call respawn_countdown
042DA9 C9          0046*      ret
042DAA             0047*  move_enemies_do:
042DAA             0048*  ; initialize pointers and loop counter
042DAA FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
042DAF 06 04       0050*      ld b,table_max_records ; loop counter
042DB1             0051*  move_enemies_loop:
042DB1 FD 22 7A 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
042DB6 C5          0053*      push bc ; backup loop counter
042DB7             0054*  ; check sprite_type to see if sprite is active
042DB7 FD 7E 01    0055*      ld a,(iy+sprite_type)
042DBA A7          0056*      and a ; if zero, sprite is dead
042DBB 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
042DBD             0058*  ; otherwise we prepare to move the sprite
042DBD FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
042DC0 CD 88 1F 04 0060*      call vdu_sprite_select ; select sprite
042DC4 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
042DC7 E9          0062*      jp (hl)  ; ... and jump to it
042DC8             0063*  ; we always jp back here from behavior subroutines
042DC8             0064*  move_enemies_loop_return:
042DC8 FD 2A 7A 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
042DCD             0066*  ; now we check results of all the moves
042DCD FD 7E 08    0067*      ld a,(iy+sprite_collisions)
042DD0 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
042DD2 FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
042DD5 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
042DD7 CD C6 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
042DDB AF          0072*      xor a ; zero a so that we can ...
042DDC FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
042DDF 18 0A       0074*      jr move_enemies_next_record ; and to the next record
042DE1             0075*  move_enemies_draw_sprite:
042DE1             0076*  ; if we got here sprite will have already been activated
042DE1             0077*  ; so all we need to do is set its coordinates and draw it
042DE1 FD 07 0B    0078*      ld bc,(iy+sprite_x)
042DE4 FD 17 0E    0079*      ld de,(iy+sprite_y)
042DE7 CD 54 20 04 0080*      call vdu_sprite_move_abs168
042DEB             0081*  ; fall through to next record
042DEB             0082*  move_enemies_next_record:
042DEB 11 26 00 00 0083*      ld de,table_bytes_per_record
042DEF FD 19       0084*      add iy,de ; point to next record
042DF1 AF          0085*      xor a ; clears carry flag
042DF2 32 7E 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
042DF6 C1          0087*      pop bc ; get back our loop counter
042DF7 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
042DF9 C9          0089*      ret ; and we're out
042DFA             0090*  
042DFA             0091*  en_nav_zigzag_start:
042DFA FD 2A 7A 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042DFF CD 38 23 04 0093*      call rand_8
042E03 E6 3F       0094*      and %00111111 ; limit it to 64
042E05 CB DF       0095*      set 3,a ; make sure it's at least 8
042E07 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
042E0A             0097*      ; fall through to en_nav_zigzag
042E0A             0098*  en_nav_zigzag:
042E0A FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
042E0D 3D          0100*      dec a
042E0E FD 77 22    0101*      ld (iy+sprite_move_timer),a
042E11 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
042E13             0103*      ; otherwise flip direction and restart timer
042E13 FD 7E 23    0104*      ld a,(iy+sprite_move_step)
042E16 EE 01       0105*      xor %1 ; flips bit one
042E18 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
042E1B 20 09       0107*      jr nz,en_nav_zigzag_right
042E1D             0108*  ;otherwise zag left
042E1D 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
042E21 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
042E24 18 D4       0111*      jr en_nav_zigzag_start
042E26             0112*  en_nav_zigzag_right:
042E26 21 00 60 00 0113*      ld hl,0x006000; southeast heading
042E2A FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
042E2D 18 CB       0115*      jr en_nav_zigzag_start
042E2F             0116*  en_nav_zigzag_no_switch:
042E2F             0117*      ; ld a,(sprite_orientation)
042E2F FD 27 1A    0118*      ld hl,(iy+sprite_heading)
042E32 18 13       0119*      jr en_nav_computevelocities
042E34             0120*  
042E34             0121*  ; contains the logic for how to move the enemy
042E34             0122*  ; and then does the moving
042E34             0123*  ; inputs: a fully-populated active sprite table
042E34             0124*  ;         player position variables
042E34             0125*  ; destroys: everything except index registers
042E34             0126*  ; outputs: moving enemies
042E34             0127*  en_nav:
042E34             0128*  ; set velocity and orientation by player's relative location
042E34             0129*  ; move enemies y-axis
042E34             0130*  ; where is player relative to us?
042E34 CD 0A 2F 04 0131*      call orientation_to_player
042E38             0132*  ;    h.l 16.8 fixed angle256 to player
042E38             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042E38             0134*  ; is player above or below us?
042E38 ED 53 F9 19 0135*      ld (ude),de ; dy
       04          
042E3D 3A FB 19 04 0136*      ld a,(ude+2) ; deu
042E41 17          0137*      rla ; shift sign bit into carry
042E42 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
042E44             0139*  ; player is even or above,so home in on current heading
042E44 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
042E47             0141*  
042E47             0142*  ; we land here from zig-zag program so as not to
042E47             0143*  ; redundantly save orientation and heading
042E47             0144*  en_nav_computevelocities:
042E47             0145*  ; set x/y component velocities based on bearing to player
042E47 FD 2A 7A 16 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042E4C E5          0147*      push hl ; we need it back to set rotation frame
042E4D FD 17 17    0148*      ld de,(iy+sprite_vel)
042E50 CD 64 23 04 0149*      call polar_to_cartesian
042E54 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
042E57 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
042E5A             0152*  ; change the animation frame to match heading
042E5A             0153*  ; by dividng the heading by 8
042E5A E1          0154*      pop hl ; get back Heading
042E5B 7C          0155*      ld a,h
042E5C CB 3F       0156*      srl a
042E5E CB 3F       0157*      srl a
042E60 CB 3F       0158*      srl a
042E62 CD EB 1F 04 0159*      call vdu_sprite_select_frame
042E66             0160*  ; update sprite position
042E66             0161*  move_enemy_sprite:
042E66 FD 27 0B    0162*      ld hl,(iy+sprite_x)
042E69 FD 17 11    0163*      ld de,(iy+sprite_xvel)
042E6C 19          0164*      add hl,de
042E6D FD 2F 0B    0165*      ld (iy+sprite_x),hl
042E70             0166*  
042E70 FD 27 0E    0167*      ld hl,(iy+sprite_y)
042E73 FD 17 14    0168*      ld de,(iy+sprite_yvel)
042E76 19          0169*      add hl,de
042E77 FD 2F 0E    0170*      ld (iy+sprite_y),hl
042E7A C9          0171*      ret
042E7B             0172*  
042E7B             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
042E7B             0174*  ; move_enemy_sprite:
042E7B             0175*  ; ; x-axis movement first
042E7B             0176*  ;     ld hl,(iy+sprite_x)
042E7B             0177*  ;     push hl ; save pre-move position
042E7B             0178*  ;     pop bc ; to detect screen edge collision
042E7B             0179*  ;     ld de,(iy+sprite_xvel)
042E7B             0180*  ;     add hl,de ;compute new x position
042E7B             0181*  ;     ld (iy+sprite_x),hl ; store it
042E7B             0182*  ;     and a ; clear the carry flag
042E7B             0183*  ;     sbc hl,bc ; test which direction was our movement
042E7B             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
042E7B             0185*  ;     jp p,@move_right ; sign positive means moved right
042E7B             0186*  ; @move_left: ; otherwise we moved left
042E7B             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
042E7B             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
042E7B             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
042E7B             0190*  ;     ld a,#20 ; west
042E7B             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042E7B             0192*  ;     jr @move_y
042E7B             0193*  ; @move_right:
042E7B             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
042E7B             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042E7B             0196*  ;     ld l,0x00
042E7B             0197*  ;     ld a,(iy+sprite_dim_x)
042E7B             0198*  ;     ld h,a
042E7B             0199*  ;     ld a,0x00
042E7B             0200*  ;     sub h
042E7B             0201*  ;     ld h,a
042E7B             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
042E7B             0203*  ;     ld a,0x02 ; east
042E7B             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042E7B             0205*  ; @move_y:
042E7B             0206*  ;     ld hl,(iy+sprite_y)
042E7B             0207*  ;     ld b,h ; save pre-move position
042E7B             0208*  ;     ld c,l ; to detect screen edge collision
042E7B             0209*  ;     ld de,(iy+sprite_yvel)
042E7B             0210*  ;     add hl,de ;compute new y position
042E7B             0211*  ;     ld (iy+sprite_y),hl ; store it
042E7B             0212*  ;     and a ; clear the carry flag
042E7B             0213*  ;     sbc hl,bc ; test which direction was our movement
042E7B             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
042E7B             0215*  ;     jp p,@move_dn ; sign positive means moved down
042E7B             0216*  ; @move_up:
042E7B             0217*  ;     add hl,bc ; get back new y position
042E7B             0218*  ;     ld de,0x5000 ; top edge of visible screen
042E7B             0219*  ;     and a ; clear the carry flag
042E7B             0220*  ;     sbc hl,de
042E7B             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
042E7B             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
042E7B             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
042E7B             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042E7B             0225*  ;     or 0x80 ; north
042E7B             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042E7B             0227*  ;     jr @move_ret
042E7B             0228*  ; @move_dn:
042E7B             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
042E7B             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042E7B             0231*  ;     ld l,0x00
042E7B             0232*  ;     ld a,(iy+sprite_dim_y)
042E7B             0233*  ;     ld h,a
042E7B             0234*  ;     ld a,0x00
042E7B             0235*  ;     sub h
042E7B             0236*  ;     ld h,a
042E7B             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
042E7B             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042E7B             0239*  ;     or 0x08 ; south
042E7B             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042E7B             0241*  ; @move_ret:
042E7B             0242*  ;     ret
042E7B             0243*  
042E7B             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
042E7B             0245*  ; ; each sprite in the table must have one of these defined
042E7B             0246*  ; ; but they need not be unique to a particular sprite
042E7B             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
042E7B             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
042E7B             0249*  ; ; but they can call anything they want between those two endpoints
042E7B             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
042E7B             0251*  
042E7B             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
042E7B             0253*  ;     jp move_enemies_loop_return
042E7B             0254*  
042E7B             0255*  ; move_explosion:
042E7B             0256*  ;     call animate_explosion
042E7B             0257*  ;     jp move_enemies_loop_return
042E7B             0258*  
042E7B             0259*  move_enemy_small:
042E7B CD 34 2E 04 0260*      call en_nav
042E7F CD A6 2F 04 0261*      call check_collisions
042E83 C3 C8 2D 04 0262*      jp move_enemies_loop_return
042E87             0263*  
042E87             0264*  ; move_enemy_medium:
042E87             0265*  ;     call en_nav
042E87             0266*  ;     call check_collisions
042E87             0267*  ;     jp move_enemies_loop_return
042E87             0268*  
042E87             0269*  ; move_enemy_large:
042E87             0270*  ;     call en_nav
042E87             0271*  ;     call check_collisions
042E87             0272*  ;     jp move_enemies_loop_return
042E87             0273*  
042E87             0274*  ; move_landing_pad:
042E87             0275*  ;     call move_active_tiles
042E87             0276*  ;     call check_collisions
042E87             0277*  ; ; is it time to launch an enemy?
042E87             0278*  ;     ld hl,sprite_move_timer
042E87             0279*  ;     dec (hl)
042E87             0280*  ;     jp nz,move_enemies_loop_return
042E87             0281*  ;     call enemy_init_from_landing_pad
042E87             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
042E87             0283*  ;     call rand_8     ; snag a random number
042E87             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042E87             0285*  ;     add a,64 ; range is now 64-127
042E87             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042E87             0287*  ;     jp move_enemies_loop_return
042E87             0288*  
042E87             0289*  enemy_init_from_landing_pad:
042E87             0290*  ; get next available spriteId
042E87 CD A1 16 04 0291*      call table_get_next_id
042E8B D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
042E8C             0293*  ; ix comes back with the pointer to the new sprite variables
042E8C DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
042E8E             0295*  ; a comes back with the spriteId of the new sprite
042E8E 32 E4 2E 04 0296*      ld (@id),a
042E92             0297*  ; initialize the new sprite
042E92 CD 88 1F 04 0298*      call vdu_sprite_select
042E96 CD 9B 1F 04 0299*      call vdu_sprite_clear_frames
042E9A 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
042E9E 06 20       0301*      ld b,32
042EA0             0302*  @load_frames:
042EA0 C5          0303*      push bc
042EA1 E5          0304*      push hl
042EA2 CD D5 20 04 0305*      call vdu_sprite_add_buff
042EA6 E1          0306*      pop hl
042EA7 23          0307*      inc hl
042EA8 C1          0308*      pop bc
042EA9 10 F5       0309*      djnz @load_frames
042EAB             0310*  ; copy coordinates of active sprite to new sprite
042EAB FD 2A 7A 16 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042EB0             0312*      ; ld hl,(iy+sprite_x)
042EB0             0313*  	; ld hl,0x008000 ; debug
042EB0             0314*  
042EB0 CD 38 23 04 0315*      call rand_8
042EB4 21 00 00 00 0316*      ld hl,0
042EB8 67          0317*      ld h,a
042EB9             0318*  
042EB9 22 EF 2E 04 0319*      ld (@x),hl
042EBD             0320*      ; ld hl,(iy+sprite_y)
042EBD             0321*      ; ld hl,0x002000 ; debug
042EBD             0322*  
042EBD CD 38 23 04 0323*      call rand_8
042EC1 21 00 00 00 0324*      ld hl,0
042EC5 67          0325*      ld h,a
042EC6             0326*  
042EC6 22 F2 2E 04 0327*      ld (@y),hl
042ECA CD 38 23 04 0328*      call rand_8
042ECE E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
042ED0 32 07 2F 04 0330*      ld (@move_step),a
042ED4             0331*  ; now copy to the table
042ED4 21 E4 2E 04 0332*      ld hl,@id ; address to copy from
042ED8 D1          0333*      pop de ; address to copy to (was ix)
042ED9 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
042EDD ED B0       0335*      ldir ; copy the records from local scratch to sprite table
042EDF             0336*  ; finally, make the new sprite visible
042EDF CD FE 1F 04 0337*      call vdu_sprite_show
042EE3 C9          0338*      ret
042EE4 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
042EE5 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
042EE6 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
042EE9 7B 2E 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
042EEC 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
042EED 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
042EEE 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
042EEF 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
042EF2 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042EF5 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042EF8 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042EFB 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
042EFE 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042F01 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
042F04 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
042F05 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
042F06 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
042F07 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
042F08 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
042F09 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
042F0A             0359*  
042F0A             0360*  ; move_laser_turret:
042F0A             0361*  ; ; compute orientation to player
042F0A             0362*  ;     call orientation_to_player
042F0A             0363*  ; ; h.l 8.8 fixed angle256 to player
042F0A             0364*  ; ; bc and de as signed 16-bit integers
042F0A             0365*  ; ; representing delta-x/y *to* target respectively
042F0A             0366*  ;     ld (Bearing_t),hl
042F0A             0367*  ;     ld hl,0x0400
042F0A             0368*  ;     ld (Vp),hl
042F0A             0369*  ;     call targeting_computer
042F0A             0370*  ;     ld (sprite_heading),hl ; store bearing to player
042F0A             0371*  ; ; is it time to launch a fireball?
042F0A             0372*  ;     ld hl,sprite_move_timer
042F0A             0373*  ;     dec (hl)
042F0A             0374*  ;     jp nz,move_laser_turret_boilerplate
042F0A             0375*  ;     call fireballs_init
042F0A             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
042F0A             0377*  ;     call rand_8     ; snag a random number
042F0A             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042F0A             0379*  ;     add a,64 ; range is now 64-127
042F0A             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042F0A             0381*  ; move_laser_turret_boilerplate:
042F0A             0382*  ;     call move_active_tiles
042F0A             0383*  ;     call check_collisions
042F0A             0384*  ;     jp move_enemies_loop_return
042F0A             0385*  
042F0A             0386*  ; fireballs_init:
042F0A             0387*  ;     call sprite_variables_to_stack
042F0A             0388*  
042F0A             0389*  ;     ld hl,fireballs
042F0A             0390*  ;     ld (sprite_base_bufferId),hl
042F0A             0391*  
042F0A             0392*  ;     ld hl,move_fireballs
042F0A             0393*  ;     ld (sprite_move_program),hl
042F0A             0394*  
042F0A             0395*  ;     ld a,%11 ; collides with laser and player
042F0A             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
042F0A             0397*  ;     ld (iy+sprite_collisions),a
042F0A             0398*  
042F0A             0399*  ;     ld hl,(Vp)
042F0A             0400*  ;     ld (sprite_vel),hl
042F0A             0401*  ;     ld hl,(Vp_x)
042F0A             0402*  ;     ld (sprite_xvel),hl
042F0A             0403*  ;     ld hl,(Vp_y)
042F0A             0404*  ;     inc h ; account for ground movement
042F0A             0405*  ;     ld (sprite_yvel),hl
042F0A             0406*  
042F0A             0407*  ;     xor a ; zero a
042F0A             0408*  ;     ld (sprite_animation),a
042F0A             0409*  ;     ld (sprite_move_step),a
042F0A             0410*  ;     ld (sprite_move_timer),a
042F0A             0411*  
042F0A             0412*  ;     ld a,6 ; 1/10th of a second timer
042F0A             0413*  ;     ld (sprite_animation_timer),a
042F0A             0414*  
042F0A             0415*  ;     ld a,0x00 ; BCD
042F0A             0416*  ;     ld (sprite_points),a
042F0A             0417*  ;     ld a,1 ; binary
042F0A             0418*  ;     ld (sprite_shield_damage),a
042F0A             0419*  
042F0A             0420*  ;     call table_add_record ; plops that on the sprite stack for later
042F0A             0421*  ;     call sprite_variables_from_stack ; come back to where we started
042F0A             0422*  ;     ret
042F0A             0423*  
042F0A             0424*  ; move_fireballs:
042F0A             0425*  ;     call move_enemy_sprite ; move sprite
042F0A             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
042F0A             0427*  ;     and a ; if zero we're still within screen bounds
042F0A             0428*  ;     jr z,move_fireballs_alive
042F0A             0429*  ; ; otherwise kill sprite
042F0A             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
042F0A             0431*  ;     ld (iy+sprite_collisions),a
042F0A             0432*  ;     jp move_enemies_loop_return
042F0A             0433*  ; move_fireballs_alive:
042F0A             0434*  ;     ld a,(sprite_animation_timer)
042F0A             0435*  ;     dec a
042F0A             0436*  ;     ld (sprite_animation_timer),a
042F0A             0437*  ;     jr nz,move_fireballs_draw
042F0A             0438*  ;     ld a,(sprite_animation)
042F0A             0439*  ;     xor %1
042F0A             0440*  ;     ld (sprite_animation),a
042F0A             0441*  ;     ld a,6 ; 1/10th of a second timer
042F0A             0442*  ;     ld (sprite_animation_timer),a
042F0A             0443*  ;     ; fall through
042F0A             0444*  
042F0A             0445*  ; move_fireballs_draw:
042F0A             0446*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F0A             0447*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042F0A             0448*  ;     call check_collisions
042F0A             0449*  ;     jp move_enemies_loop_return
042F0A             0450*  
042F0A             0451*  ; compute orientation to player
042F0A             0452*  ; based on relative positions
042F0A             0453*  ; returns: h.l 16.8 fixed angle256 to player
042F0A             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042F0A             0455*  ;    representing delta-x/y *to* target respectively
042F0A             0456*  orientation_to_player:
042F0A FD 2A 7A 16 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F0F FD E5       0458*      push iy ; so we can send it back intact
042F11 FD 07 0B    0459*      ld bc,(iy+sprite_x)
042F14 FD 17 0E    0460*      ld de,(iy+sprite_y)
042F17 DD 2A C1 2B 0461*      ld ix,(player_x)
       04          
042F1C FD 2A C4 2B 0462*      ld iy,(player_y)
       04          
042F21 CD AE 23 04 0463*      call dxy168
042F25 CD 15 24 04 0464*      call atan2_168game
042F29 ED 4B 09 24 0465*      ld bc,(dx168)
       04          
042F2E ED 5B 0F 24 0466*      ld de,(dy168)
       04          
042F33 FD E1       0467*      pop iy ; restore table pointer
042F35 C9          0468*      ret
042F36             0469*  
042F36             0470*  
042F36             0471*  ; targeting_computer scratch variables
042F36 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
042F38 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
042F3A 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
042F3C 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
042F3E 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
042F40 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
042F42 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
042F44 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
042F46             0480*  
042F46             0481*  
042F46             0482*  ; ; Inputs:   see scratch variables
042F46             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
042F46             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
042F46             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
042F46             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
042F46             0487*  ; targeting_computer:
042F46             0488*  ; ; compute target velocity from x,y component velocities
042F46             0489*  ;     ld bc,(player_xvel)
042F46             0490*  ;     ld de,(player_yvel)
042F46             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
042F46             0492*  
042F46             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
042F46             0494*  ;     ld (Heading_t),bc
042F46             0495*  ;     ld (Vt),de
042F46             0496*  
042F46             0497*  ; ; compute Heading_t-Bearing_t
042F46             0498*  ;     ld h,b
042F46             0499*  ;     ld l,c
042F46             0500*  ;     ld bc,(Bearing_t)
042F46             0501*  ;     and a ; clear carry
042F46             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
042F46             0503*  
042F46             0504*  ; ; compute sin(Heading_t-Bearing_t)
042F46             0505*  ;     ld b,h
042F46             0506*  ;     ld c,l
042F46             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
042F46             0508*  
042F46             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
042F46             0510*  ;     ex de,hl
042F46             0511*  ;     ld bc,(Vt)
042F46             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
042F46             0513*  
042F46             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
042F46             0515*  ;     ld b,h
042F46             0516*  ;     ld c,l
042F46             0517*  ;     ld de,(Vp)
042F46             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
042F46             0519*  ; ; answer is in radians, convert to degrees256
042F46             0520*  ;     ex de,hl
042F46             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
042F46             0522*  ;     call BC_Mul_DE_88
042F46             0523*  
042F46             0524*  ; ; add lead angle to target bearing
042F46             0525*  ;     ld de,(Bearing_t)
042F46             0526*  ;     add hl,de ; h.l=lead angle+target bearing
042F46             0527*  ;     push hl
042F46             0528*  
042F46             0529*  ; ; compute component projectile velocities
042F46             0530*  ;     ld b,h
042F46             0531*  ;     ld c,l
042F46             0532*  ;     ld de,(Vp)
042F46             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
042F46             0534*  
042F46             0535*  ;     ld (Vp_x),bc
042F46             0536*  ;     ld (Vp_y),de
042F46             0537*  ;     pop hl ; h.l=lead angle+target bearing
042F46             0538*  ;     ret
042F46             0539*  
042F46             0540*  ; this routine vanquishes the enemy sprite
042F46             0541*  ; and replaces it with an animated explosion
042F46             0542*  ; we jump here instead of call because
042F46             0543*  ; we want to return to differing locations in the loop
042F46             0544*  ; depending on whether we're still sploding
042F46             0545*  ; destroys: everything except index registers
042F46             0546*  ; returns: an incandescent ball of debris and gas
042F46             0547*  kill_nurple:
042F46             0548*  ; ; tally up points
042F46             0549*  ;     ld bc,0
042F46             0550*  ;     ld a,(sprite_points)
042F46             0551*  ;     ld e,a
042F46             0552*  ;     ld d,0
042F46             0553*  ;     ld hl,add_bcd_arg2
042F46             0554*  ;     call set_bcd
042F46             0555*  ;     ld hl,player_score
042F46             0556*  ;     ld de,add_bcd_arg2
042F46             0557*  ;     ld a,3 ; number of bytes to add
042F46             0558*  ;     call add_bcd
042F46             0559*  ; ; initialize explosion
042F46             0560*  ; init_explosion:
042F46             0561*  ;     ld hl,explosion
042F46             0562*  ;     ld (sprite_base_bufferId),hl
042F46             0563*  ;     ld hl,move_explosion
042F46             0564*  ;     ld (sprite_move_program),hl
042F46             0565*  ;     ld a,%00000000 ; collides with nothing
042F46             0566*  ;     ld (iy+sprite_collisions),a
042F46             0567*  ;     ld hl,0 ; north
042F46             0568*  ;     ld (sprite_heading),hl
042F46             0569*  ;     ld a,0x04 ; will decrement to 03
042F46             0570*  ;     ld (sprite_animation),a
042F46             0571*  ;     ld a,0x07 ; 7/60th of a second timer
042F46             0572*  ;     ld (sprite_animation_timer),a
042F46             0573*  ;     xor a
042F46             0574*  ;     ld (sprite_move_timer),a
042F46             0575*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F46             0576*  ; ; fall through to next_explosion
042F46             0577*  ; next_explosion:
042F46             0578*  ;     ld a,(sprite_animation)
042F46             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
042F46             0580*  ;     jp m,done_explosion
042F46             0581*  ;     ld (sprite_animation),a
042F46             0582*  ;     ld a,0x7 ; 7/60th of a second timer
042F46             0583*  ;     ld (sprite_animation_timer),a
042F46             0584*  ; ; fall through to animate_explosion
042F46             0585*  ; animate_explosion:
042F46             0586*  ;     ld hl,sprite_y+1
042F46             0587*  ;     inc (hl) ; move explosion down 1 pixel
042F46             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
042F46             0589*  ;     ld hl,sprite_animation_timer
042F46             0590*  ;     dec (hl) ; if timer is zero,we do next animation
042F46             0591*  ;     jr z,next_explosion
042F46             0592*  ;     ;otherwise we fall through to draw the current one
042F46             0593*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F46             0594*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042F46             0595*  ;     ret ; now we go back to caller
042F46             0596*  ; done_explosion:
042F46 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
042F48 FD 2A 7A 16 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
042F4D FD 77 08    0599*      ld (iy+sprite_collisions),a
042F50 C9          0600*      ret ; now we go back to caller
042F51             0601*  
042F51             0602*  ; game_over:
042F51             0603*  ;     jp new_game
042F51             0604*  
042F51             0605*  ; it's presumed we've already checked that laser is alive
042F51             0606*  collision_enemy_with_laser:
042F51 DD 2A DE 2F 0607*      ld ix,(laser_x)
       04          
042F56 FD 2A E1 2F 0608*      ld iy,(laser_y)
       04          
042F5B 3A DC 2F 04 0609*      ld a,(laser_dim_x)
042F5F CB 2F       0610*      sra a ; divide by 2
042F61 F5          0611*      push af ; we need this later
042F62             0612*      ; ld de,0
042F62             0613*      ; ld d,a
042F62             0614*      ; add ix,de
042F62             0615*      ; add iy,de
042F62 18 11       0616*      jr collision_enemy
042F64             0617*  
042F64             0618*  ; it's presumed we've already checked that player is alive
042F64             0619*  collision_enemy_with_player:
042F64 DD 2A C1 2B 0620*      ld ix,(player_x)
       04          
042F69 FD 2A C4 2B 0621*      ld iy,(player_y)
       04          
042F6E 3A BF 2B 04 0622*      ld a,(player_dim_x)
042F72             0623*  
042F72             0624*      ; call dumpRegistersHex
042F72             0625*  
042F72 CB 2F       0626*      sra a ; divide by 2
042F74 F5          0627*      push af ; we need this later
042F75             0628*      ; ld de,0
042F75             0629*      ; ld d,a
042F75             0630*      ; add ix,de
042F75             0631*      ; add iy,de
042F75             0632*      ; fall through to collision_enemy
042F75             0633*  
042F75             0634*  ; compute the distance between the two sprites' centers
042F75             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
042F75             0636*  collision_enemy:
042F75             0637*  ; back up iy because we need it as the sprite table pointer
042F75 FD E5       0638*      push iy
042F77 FD 2A 7A 16 0639*      ld iy,(table_pointer)
       04          
042F7C FD 27 0B    0640*      ld hl,(iy+sprite_x)
042F7F FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
042F82 CB 2F       0642*      sra a
042F84 F5          0643*      push af ; we need this later
042F85             0644*      ; ld de,0
042F85             0645*      ; ld d,a
042F85             0646*      ; add hl,de
042F85 E5          0647*      push hl
042F86 C1          0648*      pop bc ; bc = x0
042F87 FD 27 0E    0649*      ld hl,(iy+sprite_y)
042F8A FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
042F8D             0651*      ; sra a
042F8D             0652*      ; ld de,0
042F8D             0653*      ; ld d,a
042F8D             0654*      ; add hl,de
042F8D EB          0655*      ex de,hl ; de = y0
042F8E F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
042F8F FD E1       0657*      pop iy
042F91 F5          0658*      push af
042F92             0659*  
042F92             0660*      ; call dumpRegistersHex
042F92             0661*  
042F92 CD C9 23 04 0662*      call distance168
042F96             0663*      ; CALL dumpRegistersHex
042F96             0664*  ; ; subtract sum of radii from distance between centers
042F96             0665*  ;     ld de,0
042F96             0666*  ;     pop af ; radius of enemy sprite
042F96             0667*  ;     ld e,a
042F96             0668*  ;     pop af ; radius of player or laser sprite
042F96             0669*  ;     add a,e
042F96             0670*  ;     ld e,a
042F96             0671*  ;     and a ; clear carry
042F96             0672*  ;     sbc hl,de
042F96             0673*  ;     jr c,collision_enemy_is
042F96             0674*  ;     xor a
042F96             0675*  ;     ret
042F96             0676*  ; temp fix TODO: remove this
042F96 F1          0677*      pop af
042F97 F1          0678*      pop af
042F98 11 00 10 00 0679*      ld de,16*256
042F9C A7          0680*      and a
042F9D ED 52       0681*      sbc hl,de
042F9F 38 02       0682*      jr c,collision_enemy_is
042FA1 AF          0683*      xor a
042FA2             0684*      ; call dumpRegistersHex
042FA2 C9          0685*      ret
042FA3             0686*  collision_enemy_is:
042FA3 AF          0687*      xor a
042FA4 3C          0688*      inc a
042FA5             0689*      ; call dumpRegistersHex
042FA5 C9          0690*      ret
042FA6             0691*  
042FA6             0692*  ; ; looks up what enemy sprite collides with
042FA6             0693*  ; ; detects collisions
042FA6             0694*  ; ; and sets things to sploding accordingly
042FA6             0695*  ; check_collisions:
042FA6             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
042FA6             0697*  ;     and a ; if this is zero,
042FA6             0698*  ;     ret z ; there's nothing to do
042FA6             0699*  ;     and %01 ; do we collide with player?
042FA6             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
042FA6             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
042FA6             0702*  ;     and a ; was there a collision?
042FA6             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
042FA6             0704*  ; ; yes collision with player
042FA6             0705*  ;     ; deduct shield damage
042FA6             0706*  ;     ld hl,sprite_shield_damage
042FA6             0707*  ;     ld a,(player_shields)
042FA6             0708*  ;     sub (hl)
042FA6             0709*  ;     ld (player_shields),a
042FA6             0710*  ; ; if shields >= 0,player survives
042FA6             0711*  ;     jp p,check_collisions_kill_nurple
042FA6             0712*  ; ; otherwise update player status so it will die
042FA6             0713*  ;     ld a,(player_collisions)
042FA6             0714*  ;     or %10 ; sets bit 1,meaning player just died
042FA6             0715*  ;     ld (player_collisions),a
042FA6             0716*  ;     ; fall through
042FA6             0717*  ; check_collisions_kill_nurple:
042FA6             0718*  ; ; kill enemy and replace with explosion
042FA6             0719*  ;     call kill_nurple
042FA6             0720*  ;     ret ; and out
042FA6             0721*  
042FA6             0722*  check_collisions:
042FA6 CD 64 2F 04 0723*      call collision_enemy_with_player ; did we hit the player?
042FAA A7          0724*      and a ; was there a collision?
042FAB C8          0725*      ret z ; if not,we're done
042FAC CD 46 2F 04 0726*      call kill_nurple ; otherwise kill enemy
042FB0 C9          0727*      ret
042FB1             0728*  
042FB1             0729*  ; did we hit the laser?
042FB1             0730*  move_enemies_laser:
042FB1 FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
042FB4 E6 02       0732*      and %10 ; do we even collide with laser?
042FB6 C8          0733*      ret z ; if not,we're out
042FB7 3A DB 2F 04 0734*      ld a,(laser_collisions) ; is laser alive?
042FBB E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
042FBD C8          0736*      ret z ; so we're out
042FBE CD 51 2F 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
042FC2 A7          0738*      and a ; was there a collision?
042FC3 C8          0739*      ret z ; if not,we're done
042FC4             0740*  ; otherwise we mark laser for termination and kill enemy
042FC4             0741*  ; update laser status so it will die
042FC4 3A DB 2F 04 0742*      ld a,(laser_collisions)
042FC8 F6 02       0743*      or %10 ; bit 1 set means laser just died
042FCA 32 DB 2F 04 0744*      ld (laser_collisions),a
042FCE CD 46 2F 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
042FD2 C9          0746*      ret ; we're outta' here
042FD3             0064   	include "laser.inc"
042FD3             0001*  ; ##### LASER SPRITE PARAMETERS #####
042FD3             0002*  ; uses the same offsets from its table base as the main sprite table:
042FD3             0003*  laser_start_variables: ; label marking beginning of table
042FD3 05          0004*  laser_id:               db table_max_records+1
042FD4 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
042FD5 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
042FD8 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
042FDB 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042FDC 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042FDD 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042FDE 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042FE1 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042FE4 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042FE7 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042FEA 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
042FED 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042FF0 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
042FF3 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
042FF4 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
042FF5 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
042FF6 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
042FF7 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
042FF8 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
042FF9             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
042FF9             0025*  
042FF9             0026*  ; laser_control:
042FF9             0027*  ; ; is laser already active?
042FF9             0028*  ;     ld a,(laser_collisions)
042FF9             0029*  ;     and %00000001 ; bit zero is lit if laser is active
042FF9             0030*  ;     jr nz,laser_move ; move laser if not zero
042FF9             0031*  ; ; otherwise check if laser fired
042FF9             0032*  ;     in a,(#82) ; keyboard
042FF9             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
042FF9             0034*  ;     ret z ; go back if laser not fired
042FF9             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
042FF9             0036*  ; ; set laser status to active (set bit 0)
042FF9             0037*  ;     ld a,%1
042FF9             0038*  ;     ld (laser_collisions),a
042FF9             0039*  ; ; initialize laser position
042FF9             0040*  ;     ld a,(player_x+1) ; we only need the integer part
042FF9             0041*  ;     ; add a,6 ; horizontal center with player sprite
042FF9             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
042FF9             0043*  ;     ld a,(player_y+1) ; we only need the integer part
042FF9             0044*  ;     add a,-6 ; set laser y a few pixels above player
042FF9             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
042FF9             0046*  ;     ; fall through to laser_move
042FF9             0047*  
042FF9             0048*  ; laser_move:
042FF9             0049*  ; ; begin setting laser to active sprite
042FF9             0050*  ;     ld hl,lasers
042FF9             0051*  ;     ld (sprite_base_bufferId),hl
042FF9             0052*  ;     ld hl,0 ; north
042FF9             0053*  ;     ld (sprite_heading),hl
042FF9             0054*  ;     xor a ; laser has no animations yet :-(
042FF9             0055*  ;     ld (sprite_animation),a
042FF9             0056*  ;     ; we set position here for the time being as a default
042FF9             0057*  ;     ; in case the laser is flagged for deletion
042FF9             0058*  ;     ; load sprite_x with laser x position (we do y further down)
042FF9             0059*  ;     ld hl,(laser_x)
042FF9             0060*  ;     ld (sprite_x),hl
042FF9             0061*  ; ; did laser just die?
042FF9             0062*  ;     ld a,(laser_collisions)
042FF9             0063*  ;     bit 1,a ; z if laser didn't just die
042FF9             0064*  ;     jr z,laser_not_dead_yet
042FF9             0065*  ; ; yes laser died
042FF9             0066*  ;     call kill_laser
042FF9             0067*  ;     ret ; done
042FF9             0068*  ; laser_not_dead_yet:
042FF9             0069*  ; ; draw it
042FF9             0070*  ; ; update laser y position
042FF9             0071*  ;     ld hl,(laser_y) ; grab laser y position
042FF9             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
042FF9             0073*  ;     add hl,de ; add y velocity to y pos
042FF9             0074*  ;     ld (sprite_y),hl ; update laser y position
042FF9             0075*  ;     ld (laser_y),hl ; update laser y position
042FF9             0076*  ; ; are we at top of screen?
042FF9             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
042FF9             0078*  ;     sub h ; no carry if above threshold
042FF9             0079*  ;     jr c,finally_draw_the_frikken_laser
042FF9             0080*  ;     ; if at top of screen,laser dies
042FF9             0081*  ;     call kill_laser
042FF9             0082*  ;     ret
042FF9             0083*  ; ; otherwise,finally draw the frikken laser
042FF9             0084*  ; finally_draw_the_frikken_laser:
042FF9             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042FF9             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042FF9             0087*  ; ; all done
042FF9             0088*  ;     ret
042FF9             0089*  
042FF9             0090*  ; kill_laser:
042FF9             0091*  ; ; update status to inactive
042FF9             0092*  ;     xor a ; zero out a
042FF9             0093*  ;     ld (laser_collisions),a
042FF9             0094*  ;     ret
042FF9             0065   	include "timer.inc"
042FF9             0001*  ; Table 32. Timer Control Registers
042FF9             0002*  ; this constant is the base address of the timer control registers
042FF9             0003*  ; each timer takes three bytes:
042FF9             0004*  ;   0: control register
042FF9             0005*  ;   1: low byte of timer reset value
042FF9             0006*  ;   2: high byte of timer reset value
042FF9             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
042FF9             0008*  ; which correctly force the high and upper bytes of the address bus to zero
042FF9             0009*  TMR_CTL:     equ 80h
042FF9             0010*  
042FF9             0011*  ; Timer Control Register Bit Definitions
042FF9             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
042FF9             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
042FF9             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
042FF9             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
042FF9             0016*                              ; the TMRx_CTL register is read.
042FF9             0017*  
042FF9             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
042FF9             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
042FF9             0020*  
042FF9             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
042FF9             0022*                              ;  0,and counting stops when the end-of-count value is reached.
042FF9             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
042FF9             0024*                              ; written to the counter when the end-of-count value is reached.
042FF9             0025*  
042FF9             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
042FF9             0027*  CLK_DIV_256:  equ %00001100 ;
042FF9             0028*  CLK_DIV_64:   equ %00001000 ;
042FF9             0029*  CLK_DIV_16:   equ %00000100 ;
042FF9             0030*  CLK_DIV_4:    equ %00000000 ;
042FF9             0031*  
042FF9             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
042FF9             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
042FF9             0034*                              ; When a 1 is written to this bit,the values in the reload registers
042FF9             0035*                              ;  are loaded into the downcounter when the timer restarts. The
042FF9             0036*                              ; programmer must ensure that this bit is set to 1 each time
042FF9             0037*                              ; SINGLE-PASS mode is used.
042FF9             0038*  
042FF9             0039*  ; disable/enable the programmable reload timer
042FF9             0040*  PRT_EN_0:     equ %00000000 ;
042FF9             0041*  PRT_EN_1:     equ %00000001 ;
042FF9             0042*  
042FF9             0043*  ; Table 37. Timer Input Source Select Register
042FF9             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
042FF9             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
042FF9             0046*  ;   00: System clock / CLK_DIV
042FF9             0047*  ;   01: RTC / CLK_DIV
042FF9             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
042FF9             0049*  ;   10: GPIO port B pin 1.
042FF9             0050*  ;   11: GPIO port B pin 1.
042FF9             0051*  TMR_ISS:   equ 92h ; register address
042FF9             0052*  
042FF9             0053*  ; Table 51. Real-Time Clock Control Register
042FF9             0054*  RTC_CTRL: equ EDh ; register address
042FF9             0055*  
042FF9             0056*  ; alarm interrupt disable/enable
042FF9             0057*  RTC_ALARM_0:    equ %00000000
042FF9             0058*  RTC_ALARM_1:    equ %10000000
042FF9             0059*  
042FF9             0060*  ; interrupt on alarm disable/enable
042FF9             0061*  RTC_INT_ENT_0:  equ %00000000
042FF9             0062*  RTC_INT_ENT_1:  equ %01000000
042FF9             0063*  
042FF9             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
042FF9             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
042FF9             0066*  
042FF9             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
042FF9             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
042FF9             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
042FF9             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
042FF9             0071*  
042FF9             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
042FF9             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
042FF9             0074*  
042FF9             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
042FF9             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
042FF9             0077*  
042FF9             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
042FF9             0079*                                  ; RTC counter is enabled.
042FF9             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
042FF9             0081*                                  ; RTC counter is disabled.
042FF9             0082*  
042FF9             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
042FF9             0084*  
042FF9             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
042FF9             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
042FF9 00 00 00    0087*  prt_reload: dl 0x000000
042FFC             0088*  
042FFC             0089*  ; returns: a = 0 if running on hardware,1 if running on emulator
042FFC             0090*  ;          de = number PRT interrupts during test interval
042FFC             0091*  prt_calibrate:
042FFC CD A5 1B 04 0092*      call vdu_vblank
043000             0093*  ; set a MOS timer
043000 21 78 00 00 0094*      ld hl,120*1 ; 1 second
043004 FD 21 57 31 0095*      ld iy,tmr_test
       04          
043009 CD 35 31 04 0096*      call tmr_set
04300D             0097*  ; set a PRT timer
04300D             0098*      ; ld hl,prt_reload_hardware
04300D             0099*      ; ld hl,prt_reload_emulator
04300D 21 05 2D 00 0100*      ld hl,prt_reload_emulator + prt_reload_hardware / 2
043011 22 F9 2F 04 0101*      ld (prt_reload),hl
043015 CD 70 30 04 0102*      call prt_set
043019             0103*  @loop:
043019             0104*  ; check time remaining on MOS timer
043019 CD 43 31 04 0105*      call tmr_get
04301D CA 27 30 04 0106*      jp z,@done ; time expired,so quit
043021 FA 27 30 04 0107*      jp m,@done ; time past expiration (negative),so quit
043025 18 F2       0108*      jr @loop
043027             0109*  @done:
043027 ED 5B BE 30 0110*      ld de,(prt_irq_counter)
       04          
04302C 01 0C 2D 00 0111*      ld bc,prt_reload_hardware ; default value for running on hardware
043030 ED 43 F9 2F 0112*      ld (prt_reload),bc
       04          
043035 21 64 00 00 0113*      ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
043039 AF          0114*      xor a ; clear carry,zero is default value for running on hardware
04303A 32 25 42 04 0115*      ld (is_emulator),a
04303E ED 52       0116*      sbc hl,de
043040 21 3D 42 04 0117*      ld hl,on_hardware ; default message for running on hardware
043044 CA FC 2F 04 0118*      jp z,prt_calibrate ; zero result is indeterminate so we try again
043048 F8          0119*      ret m ; negative result means we're on hardware
043049 3C          0120*      inc a ; we're on emulator
04304A 32 25 42 04 0121*      ld (is_emulator),a
04304E 01 FF 2C 00 0122*      ld bc,prt_reload_emulator
043052 ED 43 F9 2F 0123*      ld (prt_reload),bc
       04          
043057 21 26 42 04 0124*      ld hl,on_emulator
04305B C9          0125*      ret
04305C             0126*  
04305C 43 61 6C 69 0127*  calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
043070             0128*  
043070             0129*  ; set PRT timer
043070             0130*  prt_set:
043070 21 00 00 00 0131*      ld hl,0
043074 22 BE 30 04 0132*      ld (prt_irq_counter),hl
043078 2A F9 2F 04 0133*      ld hl,(prt_reload)
04307C ED 29 84    0134*      out0 ($84),l
04307F ED 21 85    0135*  	out0 ($85),h
043082             0136*  ; disable timer
043082 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
043084 ED 39 83    0138*  	out0 ($83),a
043087             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043087 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
043089 ED 39 83    0141*  	out0 ($83),a
04308C C9          0142*      ret
04308D             0143*  
04308D             0144*  ; ===============================================
04308D             0145*  ; PRT Timer Interrupt Handling
04308D             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
04308D             0147*  ; -----------------------------------------------
04308D             0148*  prt_irq_init:
04308D             0149*      ; set up interrupt vector table 2
04308D 21 00 00 00 0150*  	ld hl,0
043091 3A 0C 01 00 0151*  	ld a,($10c)
043095 6F          0152*  	ld l,a
043096 3A 0D 01 00 0153*  	ld a,($10d)
04309A 67          0154*  	ld h,a
04309B             0155*  
04309B             0156*  	; skip over CALL ($c3)
04309B 23          0157*  	inc hl
04309C             0158*  	; load address of jump into vector table 2 (in ram)
04309C ED 27       0159*  	ld hl,(hl)
04309E             0160*  
04309E             0161*  	; write CALL prt_irq_handler to vector table 2
04309E 3E C3       0162*  	ld a,$c3
0430A0 77          0163*  	ld (hl),a
0430A1 23          0164*  	inc hl
0430A2 11 A9 30 04 0165*  	ld de,prt_irq_handler
0430A6 ED 1F       0166*  	ld (hl),de
0430A8             0167*  
0430A8 C9          0168*      ret
0430A9             0169*  
0430A9             0170*  prt_irq_handler:
0430A9 F3          0171*  	di
0430AA F5          0172*  	push af
0430AB E5          0173*      push hl
0430AC ED 38 83    0174*  	in0 a,($83)
0430AF 2A BE 30 04 0175*  	ld hl,(prt_irq_counter)
0430B3 23          0176*  	inc hl
0430B4 22 BE 30 04 0177*  	ld (prt_irq_counter),hl
0430B8 E1          0178*      pop hl
0430B9 F1          0179*  	pop af
0430BA FB          0180*  	ei
0430BB 5B ED 4D    0181*  	reti.l
0430BE             0182*  
0430BE             0183*  prt_irq_counter:
0430BE 00 00 00    0184*  	.dl 0
0430C1             0185*  prt_irq_counter_saved:
0430C1 00 00 00    0186*      .dl 0
0430C4             0187*  
0430C4             0188*  prt_loop_reset:
0430C4 E5          0189*      push hl
0430C5 21 00 00 00 0190*  	ld hl,0
0430C9 22 BE 30 04 0191*  	ld (prt_irq_counter),hl
0430CD 22 2F 31 04 0192*      ld (prt_loop_counter),hl
0430D1 22 32 31 04 0193*      ld (prt_loops),hl
0430D5 CD 70 30 04 0194*      call prt_set
0430D9 E1          0195*      pop hl
0430DA C9          0196*      ret
0430DB             0197*  
0430DB             0198*  prt_loop_start:
0430DB E5          0199*      push hl
0430DC 21 00 00 00 0200*  	ld hl,0
0430E0 22 BE 30 04 0201*  	ld (prt_irq_counter),hl
0430E4 E1          0202*      pop hl
0430E5 C9          0203*      ret
0430E6             0204*  
0430E6             0205*  prt_loop_stop:
0430E6 E5          0206*      push hl
0430E7 D5          0207*      push de
0430E8 2A BE 30 04 0208*      ld hl,(prt_irq_counter)
0430EC ED 5B 2F 31 0209*      ld de,(prt_loop_counter)
       04          
0430F1 19          0210*      add hl,de
0430F2 22 2F 31 04 0211*      ld (prt_loop_counter),hl
0430F6 21 00 00 00 0212*      ld hl,0
0430FA 22 BE 30 04 0213*      ld (prt_irq_counter),hl
0430FE 2A 32 31 04 0214*      ld hl,(prt_loops)
043102 23          0215*      inc hl
043103 22 32 31 04 0216*      ld (prt_loops),hl
043107 D1          0217*      pop de
043108 E1          0218*      pop hl
043109 C9          0219*      ret
04310A             0220*  
04310A             0221*  ; inputs: bc = y,x text coordinates to print
04310A             0222*  prt_loop_print:
04310A F5          0223*      push af
04310B E5          0224*      push hl
04310C C5          0225*      push bc
04310D D5          0226*      push de
04310E DD E5       0227*      push ix
043110 FD E5       0228*      push iy
043112 CD 1D 1B 04 0229*      call vdu_move_cursor
043116             0230*  
043116 2A 2F 31 04 0231*      ld hl,(prt_loop_counter)
04311A CD 3B 17 04 0232*      call printDec
04311E             0233*  
04311E 2A 32 31 04 0234*      ld hl,(prt_loops)
043122 CD 3B 17 04 0235*      call printDec
043126             0236*  
043126 FD E1       0237*      pop iy
043128 DD E1       0238*      pop ix
04312A D1          0239*      pop de
04312B C1          0240*      pop bc
04312C E1          0241*      pop hl
04312D F1          0242*      pop af
04312E C9          0243*      ret
04312F             0244*  
04312F             0245*  prt_loop_counter:
04312F 00 00 00    0246*      .dl 0
043132             0247*  prt_loops:
043132 00 00 00    0248*      .dl 0
043135             0249*  
043135             0250*  ; ===============================================
043135             0251*  ; Timer functions
043135             0252*  ; -----------------------------------------------
043135             0253*  ; set a countdown timer
043135             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043135             0255*  ; returns: hl = current time
043135             0256*  tmr_set:
043135 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
043138             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
043138 3E 08       0001*M 			LD	A, function
04313A 5B CF       0002*M 			RST.LIL	08h
04313C DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
04313F FD 2F 00    0260*      ld (iy+0),hl            ; set start time
043142 C9          0261*      ret
043143             0262*  
043143             0263*  ; gets time remaining on a countdown timer
043143             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043143             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043143             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
043143             0267*  tmr_get:
043143             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
043143 3E 08       0001*M 			LD	A, function
043145 5B CF       0002*M 			RST.LIL	08h
043147 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
04314A FD 27 00    0270*      ld hl,(iy+0)            ; get start time
04314D AF          0271*      xor a                   ; clear carry
04314E ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043150 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
043153 AF          0274*      xor a                   ; clear carry
043154 ED 5A       0275*      adc hl,de               ; hl = time remaining
043156             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043156 C9          0277*      ret
043157             0278*  
043157             0279*  tmr_test: ds 6 ; example of a buffer to hold timer data
04315D             0280*  
04315D 00 00 00    0281*  timestamp_now: dl 0
043160 00 00 00    0282*  timestamp_old: dl 0
043163 00 00 00    0283*  timestamp_chg: dl 0
043166             0284*  
043166             0285*  ; update the global timestamp from the system clock
043166             0286*  ; inputs: none
043166             0287*  ; returns: hl = time elapsed in 1/120ths of a second
043166             0288*  ;          de = current time
043166             0289*  ;          ix = pointer to syvars table
043166             0290*  ; destroys: af,hl,de,ix
043166             0291*  timestamp_tick:
043166 ED 5B 5D 31 0292*      ld de,(timestamp_now)   ; get previous time
       04          
04316B ED 53 60 31 0293*      ld (timestamp_old),de   ; save previous time
       04          
043170             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
043170 3E 08       0001*M 			LD	A, function
043172 5B CF       0002*M 			RST.LIL	08h
043174 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043177 22 5D 31 04 0296*      ld (timestamp_now),hl   ; save current time
04317B AF          0297*      xor a                   ; clear carry
04317C ED 52       0298*      sbc hl,de               ; hl = time elapsed
04317E 22 63 31 04 0299*      ld (timestamp_chg),hl   ; save elapsed time
043182 C9          0300*      ret
043183             0301*  
043183             0302*  ; set a countdown timer
043183             0303*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043183             0304*  ; requires: timestamp_tick to be called at least once before this function
043183             0305*  ; returns: hl = current time
043183             0306*  ; destroys: hl
043183             0307*  timestamp_tmr_set:
043183 FD 2F 03    0308*      ld (iy+3),hl            ; set time remaining
043186 2A 5D 31 04 0309*      ld hl,(timestamp_now)   ; get current timestamp
04318A FD 2F 00    0310*      ld (iy+0),hl            ; set start time
04318D C9          0311*      ret
04318E             0312*  
04318E             0313*  ; gets time remaining on a countdown timer following the global timestamp
04318E             0314*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04318E             0315*  ; requires: timestamp_tick to be called at least once before this function
04318E             0316*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04318E             0317*  ;          sign flags: pos = time not expired,zero or neg = time expired
04318E             0318*  ; destroys: af,hl,de
04318E             0319*  timestamp_tmr_get:
04318E ED 5B 5D 31 0320*      ld de,(timestamp_now)   ; get current timestamp
       04          
043193 FD 27 00    0321*      ld hl,(iy+0)            ; get start time
043196 AF          0322*      xor a                   ; clear carry
043197 ED 52       0323*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043199 FD 17 03    0324*      ld de,(iy+3)            ; get timer set value
04319C AF          0325*      xor a                   ; clear carry
04319D ED 5A       0326*      adc hl,de               ; hl = time remaining
04319F             0327*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04319F C9          0328*      ret
0431A0             0329*  
0431A0             0330*  ; set a stopwatch
0431A0             0331*  ; returns: hl = start time
0431A0             0332*  ; destroys: hl,ix
0431A0             0333*  stopwatch_set:
0431A0             0334*      MOSCALL mos_sysvars     ; ix points to syvars table
0431A0 3E 08       0001*M 			LD	A, function
0431A2 5B CF       0002*M 			RST.LIL	08h
0431A4 DD 27 00    0335*      ld hl,(ix+sysvar_time)  ; get current time
0431A7 22 BC 31 04 0336*      ld (stopwatch_started),hl            ; set start time
0431AB C9          0337*      ret
0431AC             0338*  
0431AC             0339*  ; gets time elapsed on a stopwatch
0431AC             0340*  ; returns: hl = time elapsed in 1/120ths of a second
0431AC             0341*  ; destroys: af,hl,de,ix
0431AC             0342*  stopwatch_get:
0431AC             0343*      MOSCALL mos_sysvars     ; ix points to syvars table
0431AC 3E 08       0001*M 			LD	A, function
0431AE 5B CF       0002*M 			RST.LIL	08h
0431B0 DD 27 00    0344*      ld hl,(ix+sysvar_time)  ; get current time
0431B3 ED 5B BC 31 0345*      ld de,(stopwatch_started)            ; get start time
       04          
0431B8 AF          0346*      xor a                   ; clear carry
0431B9 ED 52       0347*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0431BB C9          0348*      ret
0431BC             0349*  
0431BC             0350*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0431BF             0351*  
0431BF             0352*  ; ------------------
0431BF             0353*  ; delay routine
0431BF             0354*  ; Author: Richard Turrnidge
0431BF             0355*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0431BF             0356*  ; routine waits a fixed time,then returns
0431BF             0357*  ; arrive with A =  the delay byte. One bit to be set only.
0431BF             0358*  ; eg. ld A,00000100b
0431BF             0359*  
0431BF             0360*  multiPurposeDelay:
0431BF F5          0361*      push af
0431C0 C5          0362*      push bc
0431C1 DD E5       0363*      push ix
0431C3 47          0364*      ld b,a
0431C4 3E 08       0365*      ld a,$08
0431C6 5B CF       0366*      RST.LIL	08h                 ; get IX pointer to sysvars
0431C8             0367*  
0431C8             0368*  waitLoop:
0431C8             0369*  
0431C8 DD 7E 00    0370*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0431CB             0371*  
0431CB             0372*                                  ;   we check if bit set is same as last time we checked.
0431CB             0373*                                  ;   bit 0 - don't use
0431CB             0374*                                  ;   bit 1 - changes 64 times per second
0431CB             0375*                                  ;   bit 2 - changes 32 times per second
0431CB             0376*                                  ;   bit 3 - changes 16 times per second
0431CB             0377*  
0431CB             0378*                                  ;   bit 4 - changes 8 times per second
0431CB             0379*                                  ;   bit 5 - changes 4 times per second
0431CB             0380*                                  ;   bit 6 - changes 2 times per second
0431CB             0381*                                  ;   bit 7 - changes 1 times per second
0431CB A0          0382*      and b
0431CC 4F          0383*      ld c,a
0431CD 3A DE 31 04 0384*      ld a,(oldTimeStamp)
0431D1 B9          0385*      cp c                        ; is A same as last value?
0431D2 28 F4       0386*      jr z,waitLoop              ; loop here if it is
0431D4 79          0387*      ld a,c
0431D5 32 DE 31 04 0388*      ld (oldTimeStamp),a        ; set new value
0431D9             0389*  
0431D9 DD E1       0390*      pop ix
0431DB C1          0391*      pop bc
0431DC F1          0392*      pop af
0431DD C9          0393*      ret
0431DE             0394*  
0431DE 00          0395*  oldTimeStamp:   .db 00h
0431DF             0066   
0431DF             0067   ; new includes
0431DF             0068   	include "images.inc"
0431DF             0001*  image_type: equ 0
0431DF             0002*  image_width: equ image_type+3
0431DF             0003*  image_height: equ image_width+3
0431DF             0004*  image_filesize: equ image_height+3
0431DF             0005*  image_filename: equ image_filesize+3
0431DF             0006*  image_bufferId: equ image_filename+3
0431DF             0007*  image_record_size: equ image_bufferId+3
0431DF             0008*  
0431DF 00 00 00    0009*  cur_image_list: dl 0
0431E2 00 00 00    0010*  cur_file_idx: dl 0
0431E5 00 00 00    0011*  cur_filename: dl 0
0431E8 00 00 00    0012*  cur_buffer_id: dl 0
0431EB             0013*  
0431EB             0014*  load_ui_images:
0431EB             0015*  ; initialize image loading variables
0431EB 21 00 00 00 0016*  	ld hl,0
0431EF 22 E2 31 04 0017*  	ld (cur_file_idx),hl
0431F3 21 C9 41 04 0018*  	ld hl,ui_image_list
0431F7 22 DF 31 04 0019*  	ld (cur_image_list),hl
0431FB             0020*  ; load images
0431FB 06 02       0021*  	ld b,ui_num_images
0431FD             0022*  @loop:
0431FD C5          0023*  	push bc
0431FE CD 5C 32 04 0024*  	call load_next_image
043202 C1          0025*  	pop bc
043203 10 F8       0026*  	djnz @loop
043205 C9          0027*  	ret
043206             0028*  
043206             0029*  load_sprite_images:
043206             0030*  ; initialize image loading variables
043206 21 00 00 00 0031*  	ld hl,0
04320A 22 E2 31 04 0032*  	ld (cur_file_idx),hl
04320E 21 ED 32 04 0033*  	ld hl,sprites_image_list
043212 22 DF 31 04 0034*  	ld (cur_image_list),hl
043216 01 59 00 00 0035*  	ld bc,sprites_num_images
04321A             0036*  ; load images
04321A CD 1F 32 04 0037*  	call img_load_main
04321E C9          0038*  	ret
04321F             0039*  
04321F             0040*  ; inputs: bc is the number of images to load, cur_image_list set
04321F             0041*  img_load_main:
04321F AF          0042*  	xor a
043220 32 E2 31 04 0043*      ld (cur_file_idx),a
043224             0044*  
043224             0045*  img_load_main_loop:
043224             0046*  ; back up loop counter
043224 C5          0047*      push bc
043225             0048*  
043225             0049*  ; load the next image
043225 CD 5C 32 04 0050*      call load_next_image
043229             0051*  
043229             0052*  ; plot the background
043229 CD 31 1B 04 0053*  	call vdu_cls
04322D 21 00 00 00 0054*      ld hl,BUF_SPLASH_BG
043231 CD 1E 1C 04 0055*      call vdu_buff_select
043235 01 00 00 00 0056*      ld bc,0
043239 11 00 00 00 0057*      ld de,0
04323D CD E7 1E 04 0058*      call vdu_plot_bmp
043241             0059*  
043241             0060*  ; ; draw the most recently loaded image
043241             0061*  ; 	ld hl,(cur_buffer_id)
043241             0062*  ; 	call vdu_buff_select
043241             0063*  ; 	ld bc,0
043241             0064*  ; 	ld de,0
043241             0065*  ; 	call vdu_plot_bmp
043241             0066*  
043241             0067*  ; move logo
043241 CD BC 32 04 0068*  	call move_logo
043245             0069*  
043245             0070*  ; print current filename
043245 2A E5 31 04 0071*  	ld hl,(cur_filename)
043249 CD ED 16 04 0072*  	call printString
04324D             0073*  
04324D             0074*  ; flip the framebuffer
04324D             0075*  	; call vdu_flip
04324D             0076*  
04324D             0077*  ; decrement loop counter
04324D C1          0078*      pop bc
04324E 0B          0079*  	dec bc
04324F 79          0080*      ld a,c
043250 B7          0081*      or a
043251 C2 24 32 04 0082*      jp nz,img_load_main_loop
043255 78          0083*      ld a,b
043256 B7          0084*      or a
043257 C2 24 32 04 0085*      jp nz,img_load_main_loop
04325B C9          0086*      ret
04325C             0087*  
04325C             0088*  load_next_image:
04325C 16 12       0089*      ld d,image_record_size
04325E 3A E2 31 04 0090*  	ld a,(cur_file_idx)
043262 5F          0091*  	ld e,a
043263 ED 5C       0092*      mlt de
043265 FD 2A DF 31 0093*      ld iy,(cur_image_list)
       04          
04326A FD 19       0094*      add iy,de
04326C             0095*  
04326C FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
04326F FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
043272 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
043275 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
043278 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
04327B 22 E8 31 04 0101*  	ld (cur_buffer_id),hl
04327F FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
043282 FD 22 E5 31 0103*  	ld (cur_filename),iy
       04          
043287 CD 3C 1D 04 0104*      call vdu_load_img
04328B FD 21 E2 31 0105*      ld iy,cur_file_idx
       04          
043290 FD 34 00    0106*  	inc (iy)
043293 C9          0107*  	ret
043294             0108*  
043294             0109*  img_load_init:
043294             0110*  ; initialize logo's position parameters
043294 21 00 00 00 0111*  	ld hl,0
043298 22 E1 32 04 0112*  	ld (logo_xvel),hl
04329C 22 E4 32 04 0113*  	ld (logo_xpos),hl
0432A0             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0432A0 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
0432A4 22 EA 32 04 0116*  	ld (logo_ypos),hl
0432A8 EB          0117*  	ex de,hl
0432A9 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
0432AD 19          0119*  	add hl,de ; distance for logo to travel
0432AE 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
0432B2 CD EA 20 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
0432B6 ED 53 E7 32 0122*  	ld (logo_yvel),de
       04          
0432BB             0123*  ; all done
0432BB C9          0124*      ret
0432BC             0125*  
0432BC             0126*  move_logo:
0432BC             0127*  ; activate logo bitmap
0432BC 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
0432C0 CD 1E 1C 04 0129*  	call vdu_buff_select
0432C4             0130*  ; update position based on velocity parameters
0432C4 2A EA 32 04 0131*  	ld hl,(logo_ypos)
0432C8 ED 5B E7 32 0132*  	ld de,(logo_yvel)
       04          
0432CD 19          0133*  	add hl,de
0432CE 22 EA 32 04 0134*  	ld (logo_ypos),hl
0432D2             0135*  ; draw logo
0432D2 ED 4B E4 32 0136*  	ld bc,(logo_xpos)
       04          
0432D7 ED 5B EA 32 0137*  	ld de,(logo_ypos)
       04          
0432DC CD 03 1F 04 0138*  	call vdu_plot_bmp168
0432E0 C9          0139*  	ret
0432E1             0140*  
0432E1 00 00 00    0141*  logo_xvel: dl 0
0432E4 00 00 00    0142*  logo_xpos: dl 0
0432E7             0143*  
0432E7 00 00 00    0144*  logo_yvel: dl 0
0432EA 00 00 00    0145*  logo_ypos: dl 0
0432ED             0069   	include "images_sprites.inc"
0432ED             0001*  ; Generated by make_images.py
0432ED             0002*  
0432ED             0003*  sprites_num_images: equ 89
0432ED             0004*  
0432ED             0005*  ; buffer_ids:
0432ED             0006*  BUF_0TILE_EMPTY: equ 256
0432ED             0007*  BUF_1TILE_CROSS: equ 257
0432ED             0008*  BUF_2TILE_HORIZ: equ 258
0432ED             0009*  BUF_3TILE_VERT: equ 259
0432ED             0010*  BUF_4TILE_SQUARE: equ 260
0432ED             0011*  BUF_5TILE_CIRCLE: equ 261
0432ED             0012*  BUF_6TILE_PAD: equ 262
0432ED             0013*  BUF_7TILE_TURRET: equ 263
0432ED             0014*  BUF_CIRCLE: equ 264
0432ED             0015*  BUF_CRATER: equ 265
0432ED             0016*  BUF_EXPLOSION_A: equ 266
0432ED             0017*  BUF_EXPLOSION_B: equ 267
0432ED             0018*  BUF_EXPLOSION_C: equ 268
0432ED             0019*  BUF_EXPLOSION_D: equ 269
0432ED             0020*  BUF_EXPLOSION_E: equ 270
0432ED             0021*  BUF_FIREBALL_A: equ 271
0432ED             0022*  BUF_FIREBALL_B: equ 272
0432ED             0023*  BUF_LASER_A: equ 273
0432ED             0024*  BUF_LASER_B: equ 274
0432ED             0025*  BUF_PAD: equ 275
0432ED             0026*  BUF_SEEKER_000: equ 276
0432ED             0027*  BUF_SEEKER_008: equ 277
0432ED             0028*  BUF_SEEKER_016: equ 278
0432ED             0029*  BUF_SEEKER_024: equ 279
0432ED             0030*  BUF_SEEKER_032: equ 280
0432ED             0031*  BUF_SEEKER_040: equ 281
0432ED             0032*  BUF_SEEKER_048: equ 282
0432ED             0033*  BUF_SEEKER_056: equ 283
0432ED             0034*  BUF_SEEKER_064: equ 284
0432ED             0035*  BUF_SEEKER_072: equ 285
0432ED             0036*  BUF_SEEKER_080: equ 286
0432ED             0037*  BUF_SEEKER_088: equ 287
0432ED             0038*  BUF_SEEKER_096: equ 288
0432ED             0039*  BUF_SEEKER_104: equ 289
0432ED             0040*  BUF_SEEKER_112: equ 290
0432ED             0041*  BUF_SEEKER_120: equ 291
0432ED             0042*  BUF_SEEKER_128: equ 292
0432ED             0043*  BUF_SEEKER_136: equ 293
0432ED             0044*  BUF_SEEKER_144: equ 294
0432ED             0045*  BUF_SEEKER_152: equ 295
0432ED             0046*  BUF_SEEKER_160: equ 296
0432ED             0047*  BUF_SEEKER_168: equ 297
0432ED             0048*  BUF_SEEKER_176: equ 298
0432ED             0049*  BUF_SEEKER_184: equ 299
0432ED             0050*  BUF_SEEKER_192: equ 300
0432ED             0051*  BUF_SEEKER_200: equ 301
0432ED             0052*  BUF_SEEKER_208: equ 302
0432ED             0053*  BUF_SEEKER_216: equ 303
0432ED             0054*  BUF_SEEKER_224: equ 304
0432ED             0055*  BUF_SEEKER_232: equ 305
0432ED             0056*  BUF_SEEKER_240: equ 306
0432ED             0057*  BUF_SEEKER_248: equ 307
0432ED             0058*  BUF_SHIP_0L: equ 308
0432ED             0059*  BUF_SHIP_1C: equ 309
0432ED             0060*  BUF_SHIP_2R: equ 310
0432ED             0061*  BUF_SHIP_SMALL: equ 311
0432ED             0062*  BUF_STAR: equ 312
0432ED             0063*  BUF_TURRET_000: equ 313
0432ED             0064*  BUF_TURRET_008: equ 314
0432ED             0065*  BUF_TURRET_016: equ 315
0432ED             0066*  BUF_TURRET_024: equ 316
0432ED             0067*  BUF_TURRET_032: equ 317
0432ED             0068*  BUF_TURRET_040: equ 318
0432ED             0069*  BUF_TURRET_048: equ 319
0432ED             0070*  BUF_TURRET_056: equ 320
0432ED             0071*  BUF_TURRET_064: equ 321
0432ED             0072*  BUF_TURRET_072: equ 322
0432ED             0073*  BUF_TURRET_080: equ 323
0432ED             0074*  BUF_TURRET_088: equ 324
0432ED             0075*  BUF_TURRET_096: equ 325
0432ED             0076*  BUF_TURRET_104: equ 326
0432ED             0077*  BUF_TURRET_112: equ 327
0432ED             0078*  BUF_TURRET_120: equ 328
0432ED             0079*  BUF_TURRET_128: equ 329
0432ED             0080*  BUF_TURRET_136: equ 330
0432ED             0081*  BUF_TURRET_144: equ 331
0432ED             0082*  BUF_TURRET_152: equ 332
0432ED             0083*  BUF_TURRET_160: equ 333
0432ED             0084*  BUF_TURRET_168: equ 334
0432ED             0085*  BUF_TURRET_176: equ 335
0432ED             0086*  BUF_TURRET_184: equ 336
0432ED             0087*  BUF_TURRET_192: equ 337
0432ED             0088*  BUF_TURRET_200: equ 338
0432ED             0089*  BUF_TURRET_208: equ 339
0432ED             0090*  BUF_TURRET_216: equ 340
0432ED             0091*  BUF_TURRET_224: equ 341
0432ED             0092*  BUF_TURRET_232: equ 342
0432ED             0093*  BUF_TURRET_240: equ 343
0432ED             0094*  BUF_TURRET_248: equ 344
0432ED             0095*  
0432ED             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
0432ED 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       2F 39 04 00 
       01 00       
0432FF 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       49 39 04 01 
       01 00       
043311 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       63 39 04 02 
       01 00       
043323 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       7D 39 04 03 
       01 00       
043335 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       96 39 04 04 
       01 00       
043347 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       B1 39 04 05 
       01 00       
043359 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       CC 39 04 06 
       01 00       
04336B 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       E4 39 04 07 
       01 00       
04337D 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       FF 39 04 08 
       01 00       
04338F 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       14 3A 04 09 
       01 00       
0433A1 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       29 3A 04 0A 
       01 00       
0433B3 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       43 3A 04 0B 
       01 00       
0433C5 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       5D 3A 04 0C 
       01 00       
0433D7 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       77 3A 04 0D 
       01 00       
0433E9 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       91 3A 04 0E 
       01 00       
0433FB 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       AB 3A 04 0F 
       01 00       
04340D 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       C4 3A 04 10 
       01 00       
04341F 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       DD 3A 04 11 
       01 00       
043431 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       F3 3A 04 12 
       01 00       
043443 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       09 3B 04 13 
       01 00       
043455 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       1B 3B 04 14 
       01 00       
043467 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       34 3B 04 15 
       01 00       
043479 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       4D 3B 04 16 
       01 00       
04348B 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       66 3B 04 17 
       01 00       
04349D 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       7F 3B 04 18 
       01 00       
0434AF 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       98 3B 04 19 
       01 00       
0434C1 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       B1 3B 04 1A 
       01 00       
0434D3 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       CA 3B 04 1B 
       01 00       
0434E5 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       E3 3B 04 1C 
       01 00       
0434F7 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       FC 3B 04 1D 
       01 00       
043509 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       15 3C 04 1E 
       01 00       
04351B 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       2E 3C 04 1F 
       01 00       
04352D 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       47 3C 04 20 
       01 00       
04353F 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       60 3C 04 21 
       01 00       
043551 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       79 3C 04 22 
       01 00       
043563 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       92 3C 04 23 
       01 00       
043575 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       AB 3C 04 24 
       01 00       
043587 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       C4 3C 04 25 
       01 00       
043599 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       DD 3C 04 26 
       01 00       
0435AB 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       F6 3C 04 27 
       01 00       
0435BD 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       0F 3D 04 28 
       01 00       
0435CF 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       28 3D 04 29 
       01 00       
0435E1 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       41 3D 04 2A 
       01 00       
0435F3 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       5A 3D 04 2B 
       01 00       
043605 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       73 3D 04 2C 
       01 00       
043617 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       8C 3D 04 2D 
       01 00       
043629 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       A5 3D 04 2E 
       01 00       
04363B 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       BE 3D 04 2F 
       01 00       
04364D 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       D7 3D 04 30 
       01 00       
04365F 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       F0 3D 04 31 
       01 00       
043671 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       09 3E 04 32 
       01 00       
043683 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       22 3E 04 33 
       01 00       
043695 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       3B 3E 04 34 
       01 00       
0436A7 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       51 3E 04 35 
       01 00       
0436B9 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       67 3E 04 36 
       01 00       
0436CB 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       7D 3E 04 37 
       01 00       
0436DD 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       96 3E 04 38 
       01 00       
0436EF 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       A9 3E 04 39 
       01 00       
043701 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       C2 3E 04 3A 
       01 00       
043713 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       DB 3E 04 3B 
       01 00       
043725 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       F4 3E 04 3C 
       01 00       
043737 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       0D 3F 04 3D 
       01 00       
043749 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       26 3F 04 3E 
       01 00       
04375B 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       3F 3F 04 3F 
       01 00       
04376D 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       58 3F 04 40 
       01 00       
04377F 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       71 3F 04 41 
       01 00       
043791 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       8A 3F 04 42 
       01 00       
0437A3 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       A3 3F 04 43 
       01 00       
0437B5 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       BC 3F 04 44 
       01 00       
0437C7 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       D5 3F 04 45 
       01 00       
0437D9 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       EE 3F 04 46 
       01 00       
0437EB 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       07 40 04 47 
       01 00       
0437FD 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       20 40 04 48 
       01 00       
04380F 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       39 40 04 49 
       01 00       
043821 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       52 40 04 4A 
       01 00       
043833 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       6B 40 04 4B 
       01 00       
043845 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       84 40 04 4C 
       01 00       
043857 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       9D 40 04 4D 
       01 00       
043869 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       B6 40 04 4E 
       01 00       
04387B 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       CF 40 04 4F 
       01 00       
04388D 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       E8 40 04 50 
       01 00       
04389F 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       01 41 04 51 
       01 00       
0438B1 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       1A 41 04 52 
       01 00       
0438C3 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       33 41 04 53 
       01 00       
0438D5 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       4C 41 04 54 
       01 00       
0438E7 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       65 41 04 55 
       01 00       
0438F9 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       7E 41 04 56 
       01 00       
04390B 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       97 41 04 57 
       01 00       
04391D 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       B0 41 04 58 
       01 00       
04392F             0186*  
04392F             0187*  ; files_list: ; filename:
04392F 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043949 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043963 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
04397D 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043996 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
0439B1 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
0439CC 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
0439E4 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
0439FF 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043A14 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043A29 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043A43 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043A5D 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043A77 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043A91 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043AAB 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043AC4 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043ADD 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043AF3 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043B09 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043B1B 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043B34 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043B4D 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043B66 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043B7F 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043B98 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043BB1 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043BCA 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043BE3 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043BFC 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043C15 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043C2E 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043C47 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043C60 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043C79 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043C92 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043CAB 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043CC4 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043CDD 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043CF6 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043D0F 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043D28 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043D41 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043D5A 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043D73 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043D8C 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
043DA5 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
043DBE 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
043DD7 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
043DF0 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
043E09 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
043E22 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
043E3B 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
043E51 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
043E67 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
043E7D 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
043E96 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
043EA9 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043EC2 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043EDB 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043EF4 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043F0D 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043F26 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043F3F 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043F58 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043F71 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043F8A 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043FA3 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043FBC 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043FD5 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043FEE 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044007 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
044020 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044039 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
044052 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
04406B 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044084 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
04409D 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0440B6 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0440CF 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0440E8 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044101 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
04411A 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
044133 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04414C 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044165 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04417E 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044197 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0441B0 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0441C9             0070   	include "images_ui.inc"
0441C9             0001*  ; Generated by make_images.py
0441C9             0002*  
0441C9             0003*  ui_num_images: equ 2
0441C9             0004*  
0441C9             0005*  ; buffer_ids:
0441C9             0006*  BUF_SPLASH_BG: equ 0
0441C9             0007*  BUF_SPLASH_LOGO: equ 1
0441C9             0008*  
0441C9             0009*  ui_image_list: ; type; width; height; filename; bufferId:
0441C9 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       ED 41 04 00 
       00 00       
0441DB 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       00 42 04 01 
       00 00       
0441ED             0012*  
0441ED             0013*  ; files_list: ; filename:
0441ED 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
044200 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
044215             0071   	include "files.inc"
044215             0001*  ; load to onboard 8k sram
044215             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
044215             0072   
044215 48 65 6C 6C 0073   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
044225 00          0074   is_emulator: defb 0
044226 52 75 6E 6E 0075   on_emulator: defb "Running on emulator.\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 2E 
       0D 0A 00    
04423D 52 75 6E 6E 0076   on_hardware: defb "Running on hardware.\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 2E 
       0D 0A 00    
044254             0077   
044254             0078   init:
044254             0079   ; ; set fonts
044254             0080   ; 	ld hl,font_nurples
044254             0081   ; 	ld b,144 ; loop counter for 96 chars
044254             0082   ; 	ld a,32 ; first char to define (space)
044254             0083   ; @loop:
044254             0084   ; 	push bc
044254             0085   ; 	push hl
044254             0086   ; 	push af
044254             0087   ; 	call vdu_define_character
044254             0088   ; 	pop af
044254             0089   ; 	inc a
044254             0090   ; 	pop hl
044254             0091   ; 	ld de,8
044254             0092   ; 	add hl,de
044254             0093   ; 	pop bc
044254             0094   ; 	djnz @loop
044254             0095   
044254             0096   ; set up the display
044254 3E 08       0097       ld a,8
044256 CD FA 1B 04 0098       call vdu_set_screen_mode
04425A AF          0099       xor a
04425B CD 0B 1C 04 0100       call vdu_set_scaling
04425F 01 20 00 00 0101   	ld bc,32
044263 11 10 00 00 0102   	ld de,16
044267 CD B6 1B 04 0103   	call vdu_set_gfx_origin
04426B             0104   
04426B             0105   	; call vdu_init ; grab a bunch of sysvars and stuff ; TODO: DEPRECATE
04426B CD F9 1A 04 0106   	call vdu_cursor_off
04426F             0107   
04426F             0108   ; ; TESTING SOME MATHS
04426F             0109   ; 	ld bc,0x00A000 ; 160
04426F             0110   ; 	ld de,0x007800 ; 120
04426F             0111   ; 	ld ix,0x011F80 ; 287.5
04426F             0112   ; 	ld iy,0xFF9B2A ; -100.836
04426F             0113   ; 	;  hl=0x00FF00 255
04426F             0114   ; 	call distance168
04426F             0115   ; 	call dumpRegistersHex
04426F             0116   ; 	halt
04426F             0117   ; ; END TESTING SOME MATHS
04426F             0118   
04426F             0119   ; ; print a hello message
04426F             0120   ; 	ld hl,hello_world
04426F             0121   ; 	call printString
04426F             0122   
04426F             0123   ; load the bitmaps
04426F             0124   ; 	call bmp2_init
04426F CD EB 31 04 0125   	call load_ui_images
044273 CD 94 32 04 0126   	call img_load_init ; sets up the animated load screen
044277 CD 06 32 04 0127   	call load_sprite_images
04427B             0128   
04427B             0129   ; initialize the first level
04427B AF          0130   	xor a
04427C 32 B2 2C 04 0131   	ld (cur_level),a
044280 CD 3A 2D 04 0132   	call init_level
044284             0133   
044284             0134   ; set gfx viewport to scrolling window
044284 01 00 00 00 0135   	ld bc,0
044288 11 00 00 00 0136   	ld de,0
04428C DD 21 FF 00 0137   	ld ix,255
       00          
044291 FD 21 DF 00 0138   	ld iy,239-16
       00          
044296 CD D1 1B 04 0139   	call vdu_set_gfx_viewport
04429A             0140   
04429A             0141   ; initialize sprites
04429A CD B4 20 04 0142   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
04429E AF          0143   	xor a
04429F             0144   @sprite_loop:
04429F F5          0145   	push af
0442A0 CD 88 1F 04 0146   	call vdu_sprite_select
0442A4 21 00 01 00 0147   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0442A8 CD D5 20 04 0148   	call vdu_sprite_add_buff
0442AC F1          0149   	pop af
0442AD 3C          0150   	inc a
0442AE FE 05       0151   	cp table_max_records+1 ; tack on sprites for player and laser
0442B0 20 ED       0152   	jr nz,@sprite_loop
0442B2 3C          0153   	inc a
0442B3 CD BC 1F 04 0154   	call vdu_sprite_activate
0442B7             0155   
0442B7             0156   ; define player sprite
0442B7 3E 10       0157   	ld a,16
0442B9 CD 88 1F 04 0158   	call vdu_sprite_select
0442BD CD 9B 1F 04 0159   	call vdu_sprite_clear_frames
0442C1 21 34 01 00 0160   	ld hl,BUF_SHIP_0L
0442C5 01 03 00 00 0161   	ld bc,3 ; three bitmaps for player ship
0442C9             0162   @sprite_player_loop:
0442C9 C5          0163   	push bc
0442CA E5          0164   	push hl
0442CB CD D5 20 04 0165   	call vdu_sprite_add_buff
0442CF E1          0166   	pop hl
0442D0 23          0167   	inc hl
0442D1 C1          0168   	pop bc
0442D2 10 F5       0169   	djnz @sprite_player_loop
0442D4 CD FE 1F 04 0170   	call vdu_sprite_show
0442D8             0171   
0442D8             0172   ; initialize player
0442D8 CD DC 2B 04 0173   	call player_init
0442DC             0174   
0442DC             0175   ; spawn an enemy sprite
0442DC 06 04       0176   	ld b,table_max_records
0442DE             0177   @spawn_enemy_loop:
0442DE C5          0178   	push bc
0442DF CD 87 2E 04 0179   	call enemy_init_from_landing_pad
0442E3 C1          0180   	pop bc
0442E4 10 F8       0181   	djnz @spawn_enemy_loop
0442E6             0182   
0442E6 C9          0183   	ret
0442E7             0184   
0442E7             0185   ; new_game:
0442E7             0186   ; ; ###### INITIALIZE GAME #######
0442E7             0187   ; ; clear the screen
0442E7             0188   ;     ld a,3
0442E7             0189   ;     out (81h),a
0442E7             0190   
0442E7             0191   ; ; reset the sprite table
0442E7             0192   ;     xor a
0442E7             0193   ;     ld (table_active_sprites),a
0442E7             0194   ;     ld hl,table_limit
0442E7             0195   ;     ld (table_base),hl
0442E7             0196   ;     ld (table_pointer),hl
0442E7             0197   
0442E7             0198   ; ; draw a starfield over the entire screen
0442E7             0199   ;     ld b,#50 ; first row of visible screen
0442E7             0200   ; new_game_draw_stars_loop:
0442E7             0201   ;     push bc
0442E7             0202   ;     call draw_stars
0442E7             0203   ;     pop bc
0442E7             0204   ;     ld a,#10
0442E7             0205   ;     add a,b
0442E7             0206   ;     ld b,a
0442E7             0207   ;     jr nz,new_game_draw_stars_loop
0442E7             0208   
0442E7             0209   ; ; ; print a welcome message
0442E7             0210   ; ;     ld de,msg_welcome
0442E7             0211   ; ;     ld hl,#581C
0442E7             0212   ; ;     ld c,218 ; a bright pastel purple d677e3
0442E7             0213   ; ;     call print_string
0442E7             0214   
0442E7             0215   ; ; push all that to frame buffer
0442E7             0216   ;     ld a,#01 ; send video to frame buffer
0442E7             0217   ;     out (81h),a
0442E7             0218   
0442E7             0219   ; ; reset score, lives, shields
0442E7             0220   ;     xor a
0442E7             0221   ;     ld hl,player_score
0442E7             0222   ;     ld (hl),a ; player_score 0
0442E7             0223   ;     inc hl
0442E7             0224   ;     ld (hl),a ; player_score 1
0442E7             0225   ;     inc hl
0442E7             0226   ;     ld (hl),a ; player_score 3
0442E7             0227   ;     inc hl
0442E7             0228   ;     ld a,16
0442E7             0229   ;     ld (hl),a ; player_shields
0442E7             0230   ;     inc hl
0442E7             0231   ;     ld (hl),a ; player_max_shields
0442E7             0232   ;     inc hl
0442E7             0233   ;     ld a,3
0442E7             0234   ;     ld (hl),a ; player_ships
0442E7             0235   ;     inc hl
0442E7             0236   
0442E7             0237   ; ; initialize first level
0442E7             0238   ;     ld a,1 ; levels are zero-based, so this will wrap around
0442E7             0239   ;     ld (cur_level),a
0442E7             0240   ;     ld a,3 ; set max enemy sprites to easy street
0442E7             0241   ;     ; ld a,64 ; DEBUG: BRING IT
0442E7             0242   ;     ld (max_enemy_sprites),a
0442E7             0243   ;     call dt_next_level
0442E7             0244   ;     call dt
0442E7             0245   
0442E7             0246   ; ; spawn our intrepid hero
0442E7             0247   ;     call player_init
0442E7             0248   
0442E7             0249   ; ; #### BEGIN GAME VARIABLES ####
0442E7             0250   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
0442E7             0251   speed_player: equ 0x000300 ; 3 pixels per frame
0442E7             0252   
0442E7             0253   main:
0442E7             0254   ; move the background down one pixel
0442E7 3E 02       0255   	ld a,2 ; current gfx viewport
0442E9 2E 02       0256   	ld l,2 ; direction=down
0442EB 26 01       0257   	ld h,1 ; speed=1 px
0442ED CD 49 1B 04 0258   	call vdu_scroll_down
0442F1             0259   
0442F1             0260   ; scroll tiles
0442F1 CD BF 2C 04 0261   	call tiles_plot
0442F5             0262   
0442F5             0263   ; get player input and update sprite position
0442F5 CD 19 2C 04 0264   	call player_input
0442F9             0265   
0442F9             0266   ; move enemies
0442F9 CD 99 2D 04 0267   	call move_enemies
0442FD             0268   
0442FD             0269   ; wait for the next vblank mitigate flicker and for loop timing
0442FD CD A5 1B 04 0270   	call vdu_vblank
044301             0271   
044301             0272   ; poll keyboard
044301 3E 08       0273       ld a, $08                           ; code to send to MOS
044303 5B CF       0274       rst.lil $08                         ; get IX pointer to System Variables
044305             0275   
044305 DD 7E 05    0276       ld a, (ix + $05)                    ; get ASCII code of key pressed
044308 FE 1B       0277       cp 27                               ; check if 27 (ascii code for ESC)
04430A CA 12 43 04 0278       jp z, main_end                     ; if pressed, jump to exit
04430E             0279   
04430E C3 E7 42 04 0280       jp main
044312             0281   
044312             0282   main_end:
044312 CD EB 1A 04 0283       call vdu_cursor_on
044316 C9          0284   	ret
044317             0285   
044317             0286   
044317             0287   ; ; #### BEGIN GAME MAIN LOOP ####
044317             0288   ; main_loop:
044317             0289   ; ; ; debug: start execution counter
044317             0290   ; ;     ld a,1
044317             0291   ; ;     out (#e0),a ; start counting instructions
044317             0292   
044317             0293   ; ; refresh background from frame buffer
044317             0294   ;     ld a,#02
044317             0295   ;     out (81h),a
044317             0296   ;     call move_background ; now move it
044317             0297   ;     ld a,#01
044317             0298   ;     out (81h),a ; save it back to buffer
044317             0299   ; ; do all the things
044317             0300   ;     call move_enemies
044317             0301   ;     call player_move
044317             0302   ;     call laser_control
044317             0303   ;     call print_score
044317             0304   ;     call draw_shields
044317             0305   ;     call draw_lives
044317             0306   ; ; ; debug: stop execution counter and print results
044317             0307   ; ;     ld a,0
044317             0308   ; ;     out (#e0),a ; stop counting instructions
044317             0309   
044317             0310   ; ; ; debug: start execution counter
044317             0311   ; ;     ld a,1
044317             0312   ; ;     out (#e0),a ; start counting instructions
044317             0313   
044317             0314   ;     call vdu_vblank
044317             0315   ; ; ; debug: stop execution counter and print results
044317             0316   ; ;     ld a,0
044317             0317   ; ;     out (#e0),a ; stop counting instructions
044317             0318   
044317             0319   ;     jr main_loop
044317             0320   ; #### END GAME MAIN LOOP ####
044317             0321   
044317             0322   ; draws the player's shields level
044317             0323   ; draw_shields:
044317             0324   ; TODO: Agonize this routine
044317             0325   ; ; prep the loop to draw the bars
044317             0326   ;     ld a,(player_shields) ; snag shields
044317             0327   ;     and a
044317             0328   ;     ret z ; don't draw if zero shields
044317             0329   ; ; set loop counter and drawing position
044317             0330   ;     ld b,a ; loop counter
044317             0331   ;     ld hl,#5300+48+12
044317             0332   ; ; set color based on bars remaining
044317             0333   ;     ld c,103 ; bright green 28fe0a
044317             0334   ;     cp 9
044317             0335   ;     jp p,draw_shields_loop
044317             0336   ;     ld c,74 ; bright yellow eafe5b
044317             0337   ;     cp 3
044317             0338   ;     jp p,draw_shields_loop
044317             0339   ;     ld c,28 ; bright red fe0a0a
044317             0340   ; draw_shields_loop:
044317             0341   ;     push bc ; yup,outta
044317             0342   ;     push hl ; registers again
044317             0343   ;     ; ld a,#A8 ; ▀,168
044317             0344   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
044317             0345   ;     ; call draw_char
044317             0346   ;     call draw_num ; we nuked draw_char for the time being
044317             0347   ;     pop hl
044317             0348   ;     ld a,8
044317             0349   ;     add a,l
044317             0350   ;     ld l,a
044317             0351   ;     pop bc
044317             0352   ;     djnz draw_shields_loop
044317             0353       ; ret
044317             0354   
044317             0355   ; prints the player's score
044317             0356   ; print_score:
044317             0357   ; TODO: Agonize this
044317             0358   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
044317             0359   ;     ld c,42 ; dark orange b74400
044317             0360   ;     ld hl,#5200+1+8+6*6
044317             0361   ;     ld a,3 ; print 6 bdc digits
044317             0362   ;     ld de,player_score
044317             0363   ;     call print_num
044317             0364   
044317             0365   ;     ld c,58 ; golden yellow fec10a
044317             0366   ;     ld hl,#5100+8+6*6
044317             0367   ;     ld a,3 ; print 6 bdc digits
044317             0368   ;     ld de,player_score
044317             0369   ;     call print_num
044317             0370       ; ret
044317             0371   
044317             0372   ; draw_lives:
044317             0373   ;     ld hl,player_small ; make small yellow ship the active sprite
044317             0374   ;     ld (sprite_base_bufferId),hl
044317             0375   ;     ; ld a,#80 ; northern orientation
044317             0376   ;     ; ld (sprite_orientation),a
044317             0377   ;     ld hl,0 ; north
044317             0378   ;     ld (sprite_heading),hl
044317             0379   ;     xor a
044317             0380   ;     ld (sprite_animation),a
044317             0381   ;     ld a,#56 ; top of visible screen
044317             0382   ;     ld (sprite_y+1),a
044317             0383   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
044317             0384   ;     ld a,(player_ships)
044317             0385   ;     dec a ; we draw one fewer ships than lives
044317             0386   ;     ret z ; nothing to draw here, move along
044317             0387   ;     ld b,a ; loop counter
044317             0388   ;     ld a,256-16 ; initial x position
044317             0389   ; draw_lives_loop:
044317             0390   ;     ld (sprite_x+1),a
044317             0391   ;     push af
044317             0392   ;     push bc
044317             0393   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
044317             0394   ;     pop bc
044317             0395   ;     pop af
044317             0396   ;     sub 10
044317             0397   ;     djnz draw_lives_loop
044317             0398   ;     ret
