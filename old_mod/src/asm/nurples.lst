PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD AE 44 04 0030   	call	init			; Initialization code
040050 CD 5E 45 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 1 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
041608             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041608             0033*  
041608             0034*  ; pointer to top address of current record, initialized to table_base
041608 E2 15 04    0035*  table_pointer: dl table_base
04160B             0036*  ; how many active sprites
04160B 00          0037*  table_active_sprites: db 0x00
04160C             0038*  ; flag indicating collision with screen edge
04160C             0039*  ; uses orientation codes to specify which edge(s)
04160C 00          0040*  sprite_screen_edge: db #00
04160D             0041*  ; next sprite id to use
04160D 00          0042*  sprite_next_id: db 0
04160E             0043*  
04160E             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
04160E             0045*  ; integer coordinates are all that are needed for collision calculations
04160E 00          0046*  collision_x: db 0x00
04160F 00          0047*  collision_y: db 0x00
041610 00          0048*  collision_dim_x: db 0x00
041611 00          0049*  collision_dim_y: db 0x00
041612             0050*  
041612             0051*  ; scratch variables
041612 00          0052*  x: db 0x00 ; 8-bit signed integer
041613 00          0053*  y: db 0x00 ; 8-bit signed integer
041614 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041617 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04161A 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04161D 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041620 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041623 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041626             0060*  
041626             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041626 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041629 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162C 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162F             0065*  
04162F             0066*  ; gets the next available sprite id
04162F             0067*  ; inputs; none
04162F             0068*  ; returns: if new sprite available, a = sprite id,
04162F             0069*  ;           ix pointing to new sprite vars, carry set
04162F             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
04162F             0071*  ; destroys: a,b,hl,ix
04162F             0072*  ; affects: bumps table_active_sprites by one
04162F             0073*  table_get_next_id:
04162F DD 21 E2 15 0074*      ld ix,table_base
       04          
041634 11 26 00 00 0075*      ld de,table_bytes_per_record
041638 06 01       0076*      ld b,table_max_records
04163A             0077*  @loop:
04163A DD 7E 01    0078*      ld a,(ix+sprite_type)
04163D A7          0079*      and a
04163E 28 06       0080*      jr z,@found
041640 DD 19       0081*      add ix,de
041642 10 F6       0082*      djnz @loop
041644             0083*  @notfound:
041644 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
041645 C9          0085*      ret
041646             0086*  @found:
041646             0087*  ; bump number of active sprites
041646 21 0B 16 04 0088*      ld hl,table_active_sprites
04164A 34          0089*      inc (hl)
04164B             0090*  ; return sprite id
04164B 3E 01       0091*      ld a,table_max_records
04164D 90          0092*      sub b
04164E 32 0D 16 04 0093*      ld (sprite_next_id),a
041652 37          0094*      scf ; sets carry flag indicating we found a free sprite
041653 C9          0095*      ret ; done
041654             0096*  
041654             0097*  ; deactivate the sprite with the given id
041654             0098*  ; inputs: a = sprite id
041654             0099*  ; outputs: nothing
041654             0100*  ; destroys: a,ix,de
041654             0101*  ; affects: decrements table_active_sprites by one
041654             0102*  table_deactivate_sprite:
041654 F5          0103*      push af ; save sprite id bc we need it later
041655 CD 8C 21 04 0104*      call vdu_sprite_select
041659 CD 10 22 04 0105*      call vdu_sprite_hide
04165D F1          0106*      pop af ; restore sprite id
04165E 11 00 00 00 0107*      ld de,0 ; clear deu
041662 57          0108*      ld d,a
041663 1E 26       0109*      ld e,table_bytes_per_record
041665 ED 5C       0110*      mlt de
041667 DD 21 E2 15 0111*      ld ix,table_base
       04          
04166C DD 19       0112*      add ix,de
04166E AF          0113*      xor a
04166F DD 77 01    0114*      ld (ix+sprite_type),a
041672 DD 21 0B 16 0115*      ld ix,table_active_sprites
       04          
041677 DD 35 00    0116*      dec (ix)
04167A C9          0117*      ret
04167B             0118*  
04167B             0119*  sprites_init:
04167B             0120*  ; initialize sprites
04167B CD B8 22 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
04167F AF          0122*  	xor a
041680             0123*  @sprite_loop:
041680 F5          0124*  	push af
041681 CD 8C 21 04 0125*  	call vdu_sprite_select
041685 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
041689 CD D9 22 04 0127*  	call vdu_sprite_add_buff
04168D F1          0128*  	pop af
04168E 3C          0129*  	inc a
04168F FE 02       0130*  	cp table_max_records+1 ; tack on sprites for player and laser
041691 20 ED       0131*  	jr nz,@sprite_loop
041693 3C          0132*  	inc a
041694 CD C0 21 04 0133*  	call vdu_sprite_activate
041698             0134*  
041698             0135*  ; define player sprite
041698 3A 8E 2E 04 0136*  	ld a,(player_id)
04169C CD 8C 21 04 0137*  	call vdu_sprite_select
0416A0 CD 9F 21 04 0138*  	call vdu_sprite_clear_frames
0416A4 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0416A8 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0416AC             0141*  @sprite_player_loop:
0416AC C5          0142*  	push bc
0416AD E5          0143*  	push hl
0416AE CD D9 22 04 0144*  	call vdu_sprite_add_buff
0416B2 E1          0145*  	pop hl
0416B3 23          0146*  	inc hl
0416B4 C1          0147*  	pop bc
0416B5 10 F5       0148*  	djnz @sprite_player_loop
0416B7 CD 02 22 04 0149*  	call vdu_sprite_show
0416BB             0150*  
0416BB             0151*  ; all done
0416BB C9          0152*      ret
0416BC             0050   ; API includes
0416BC             0051       include "mos_api.inc"
0416BC             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0416BC             0002*  ; Title:	AGON MOS - API for user projects
0416BC             0003*  ; Author:	Dean Belfield
0416BC             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0416BC             0005*  ;			Added MOS error codes for return in HL
0416BC             0006*  ; Created:	03/08/2022
0416BC             0007*  ; Last Updated:	10/08/2023
0416BC             0008*  ;
0416BC             0009*  ; Modinfo:
0416BC             0010*  ; 05/08/2022:	Added mos_feof
0416BC             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0416BC             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0416BC             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0416BC             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0416BC             0015*  ; 13/10/2022:	Added mos_oscli
0416BC             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0416BC             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0416BC             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0416BC             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0416BC             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0416BC             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0416BC             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0416BC             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0416BC             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0416BC             0025*  ; 19/05/2023:	Added sysvar_scrMode
0416BC             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0416BC             0027*  ; 03/08/2023:	Added mos_setkbvector
0416BC             0028*  ; 10/08/2023:	Added mos_getkbmap
0416BC             0029*  
0416BC             0030*  ; VDP control (VDU 23, 0, n)
0416BC             0031*  ;
0416BC             0032*  vdp_gp:				EQU 80h
0416BC             0033*  vdp_keycode:		EQU 81h
0416BC             0034*  vdp_cursor:			EQU	82h
0416BC             0035*  vdp_scrchar:		EQU	83h
0416BC             0036*  vdp_scrpixel:		EQU	84h
0416BC             0037*  vdp_audio:			EQU	85h
0416BC             0038*  vdp_mode:			EQU	86h
0416BC             0039*  vdp_rtc:			EQU	87h
0416BC             0040*  vdp_keystate:		EQU	88h
0416BC             0041*  vdp_logicalcoords:	EQU	C0h
0416BC             0042*  vdp_terminalmode:	EQU	FFh
0416BC             0043*  
0416BC             0044*  ; MOS high level functions
0416BC             0045*  ;
0416BC             0046*  mos_getkey:			EQU	00h
0416BC             0047*  mos_load:			EQU	01h
0416BC             0048*  mos_save:			EQU	02h
0416BC             0049*  mos_cd:				EQU	03h
0416BC             0050*  mos_dir:			EQU	04h
0416BC             0051*  mos_del:			EQU	05h
0416BC             0052*  mos_ren:			EQU	06h
0416BC             0053*  mos_mkdir:			EQU	07h
0416BC             0054*  mos_sysvars:		EQU	08h
0416BC             0055*  mos_editline:		EQU	09h
0416BC             0056*  mos_fopen:			EQU	0Ah
0416BC             0057*  mos_fclose:			EQU	0Bh
0416BC             0058*  mos_fgetc:			EQU	0Ch
0416BC             0059*  mos_fputc:			EQU	0Dh
0416BC             0060*  mos_feof:			EQU	0Eh
0416BC             0061*  mos_getError:		EQU	0Fh
0416BC             0062*  mos_oscli:			EQU	10h
0416BC             0063*  mos_copy:			EQU	11h
0416BC             0064*  mos_getrtc:			EQU	12h
0416BC             0065*  mos_setrtc:			EQU	13h
0416BC             0066*  mos_setintvector:	EQU	14h
0416BC             0067*  mos_uopen:			EQU	15h
0416BC             0068*  mos_uclose:			EQU	16h
0416BC             0069*  mos_ugetc:			EQU	17h
0416BC             0070*  mos_uputc:			EQU	18h
0416BC             0071*  mos_getfil:			EQU	19h
0416BC             0072*  mos_fread:			EQU	1Ah
0416BC             0073*  mos_fwrite:			EQU	1Bh
0416BC             0074*  mos_flseek:			EQU	1Ch
0416BC             0075*  mos_setkbvector:	EQU	1Dh
0416BC             0076*  mos_getkbmap:		EQU	1Eh
0416BC             0077*  
0416BC             0078*  ; MOS program exit codes
0416BC             0079*  ;
0416BC             0080*  EXIT_OK:				EQU  0;	"OK",
0416BC             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0416BC             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0416BC             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0416BC             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0416BC             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0416BC             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0416BC             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0416BC             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0416BC             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0416BC             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0416BC             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0416BC             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0416BC             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0416BC             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0416BC             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0416BC             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0416BC             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0416BC             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0416BC             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0416BC             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0416BC             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0416BC             0102*  ; FatFS file access functions
0416BC             0103*  ;
0416BC             0104*  ffs_fopen:			EQU	80h
0416BC             0105*  ffs_fclose:			EQU	81h
0416BC             0106*  ffs_fread:			EQU	82h
0416BC             0107*  ffs_fwrite:			EQU	83h
0416BC             0108*  ffs_flseek:			EQU	84h
0416BC             0109*  ffs_ftruncate:		EQU	85h
0416BC             0110*  ffs_fsync:			EQU	86h
0416BC             0111*  ffs_fforward:		EQU	87h
0416BC             0112*  ffs_fexpand:		EQU	88h
0416BC             0113*  ffs_fgets:			EQU	89h
0416BC             0114*  ffs_fputc:			EQU	8Ah
0416BC             0115*  ffs_fputs:			EQU	8Bh
0416BC             0116*  ffs_fprintf:		EQU	8Ch
0416BC             0117*  ffs_ftell:			EQU	8Dh
0416BC             0118*  ffs_feof:			EQU	8Eh
0416BC             0119*  ffs_fsize:			EQU	8Fh
0416BC             0120*  ffs_ferror:			EQU	90h
0416BC             0121*  
0416BC             0122*  ; FatFS directory access functions
0416BC             0123*  ;
0416BC             0124*  ffs_dopen:			EQU	91h
0416BC             0125*  ffs_dclose:			EQU	92h
0416BC             0126*  ffs_dread:			EQU	93h
0416BC             0127*  ffs_dfindfirst:		EQU	94h
0416BC             0128*  ffs_dfindnext:		EQU	95h
0416BC             0129*  
0416BC             0130*  ; FatFS file and directory management functions
0416BC             0131*  ;
0416BC             0132*  ffs_stat:			EQU	96h
0416BC             0133*  ffs_unlink:			EQU	97h
0416BC             0134*  ffs_rename:			EQU	98h
0416BC             0135*  ffs_chmod:			EQU	99h
0416BC             0136*  ffs_utime:			EQU	9Ah
0416BC             0137*  ffs_mkdir:			EQU	9Bh
0416BC             0138*  ffs_chdir:			EQU	9Ch
0416BC             0139*  ffs_chdrive:		EQU	9Dh
0416BC             0140*  ffs_getcwd:			EQU	9Eh
0416BC             0141*  
0416BC             0142*  ; FatFS volume management and system configuration functions
0416BC             0143*  ;
0416BC             0144*  ffs_mount:			EQU	9Fh
0416BC             0145*  ffs_mkfs:			EQU	A0h
0416BC             0146*  ffs_fdisk:			EQU	A1h
0416BC             0147*  ffs_getfree:		EQU	A2h
0416BC             0148*  ffs_getlabel:		EQU	A3h
0416BC             0149*  ffs_setlabel:		EQU	A4h
0416BC             0150*  ffs_setcp:			EQU	A5h
0416BC             0151*  
0416BC             0152*  ; File access modes
0416BC             0153*  ;
0416BC             0154*  fa_read:			EQU	01h
0416BC             0155*  fa_write:			EQU	02h
0416BC             0156*  fa_open_existing:	EQU	00h
0416BC             0157*  fa_create_new:		EQU	04h
0416BC             0158*  fa_create_always:	EQU	08h
0416BC             0159*  fa_open_always:		EQU	10h
0416BC             0160*  fa_open_append:		EQU	30h
0416BC             0161*  
0416BC             0162*  ; System variable indexes for api_sysvars
0416BC             0163*  ; Index into _sysvars in globals.inc
0416BC             0164*  ;
0416BC             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0416BC             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0416BC             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0416BC             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0416BC             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0416BC             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0416BC             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0416BC             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0416BC             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0416BC             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0416BC             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0416BC             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0416BC             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0416BC             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0416BC             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0416BC             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0416BC             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0416BC             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0416BC             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0416BC             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0416BC             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0416BC             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0416BC             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0416BC             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0416BC             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0416BC             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0416BC             0191*  
0416BC             0192*  ; Flags for the VPD protocol
0416BC             0193*  ;
0416BC             0194*  vdp_pflag_cursor:		EQU	00000001b
0416BC             0195*  vdp_pflag_scrchar:		EQU	00000010b
0416BC             0196*  vdp_pflag_point:		EQU	00000100b
0416BC             0197*  vdp_pflag_audio:		EQU	00001000b
0416BC             0198*  vdp_pflag_mode:			EQU	00010000b
0416BC             0199*  vdp_pflag_rtc:			EQU	00100000b
0416BC             0200*  
0416BC             0201*  ;
0416BC             0202*  ; FatFS structures
0416BC             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0416BC             0204*  ;
0416BC             0205*  ; Object ID and allocation information (FFOBJID)
0416BC             0206*  ;
0416BC             0207*  ; Indexes into FFOBJID structure
0416BC             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0416BC             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0416BC             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0416BC             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0416BC             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0416BC             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0416BC             0214*  ;
0416BC             0215*  ; File object structure (FIL)
0416BC             0216*  ;
0416BC             0217*  ; Indexes into FIL structure
0416BC             0218*  fil_obj:		EQU 0	; 15: Object identifier
0416BC             0219*  fil_flag:		EQU	15 	;  1: File status flags
0416BC             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0416BC             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0416BC             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0416BC             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0416BC             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0416BC             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0416BC             0226*  ;
0416BC             0227*  ; Directory object structure (DIR)
0416BC             0228*  ; Indexes into DIR structure
0416BC             0229*  dir_obj:		EQU  0	; 15: Object identifier
0416BC             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0416BC             0231*  dir_clust:		EQU	19	;  4: Current cluster
0416BC             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0416BC             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0416BC             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0416BC             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0416BC             0236*  ;
0416BC             0237*  ; File information structure (FILINFO)
0416BC             0238*  ;
0416BC             0239*  ; Indexes into FILINFO structure
0416BC             0240*  filinfo_fsize:		EQU 0	;   4: File size
0416BC             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0416BC             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0416BC             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0416BC             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0416BC             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0416BC             0246*  ;
0416BC             0247*  ; Macro for calling the API
0416BC             0248*  ; Parameters:
0416BC             0249*  ; - function: One of the function numbers listed above
0416BC             0250*  ;
0416BC             0251*  	MACRO	MOSCALL	function
0416BC             0252*  			LD	A, function
0416BC             0253*  			RST.LIL	08h
0416BC             0254*  	ENDMACRO
0416BC             0052       include "functions.inc"
0416BC             0001*  
0416BC             0002*      MACRO printChar char
0416BC             0003*          LD A, char
0416BC             0004*          RST.LIL 10h
0416BC             0005*      ENDMACRO
0416BC             0006*  
0416BC             0007*  ; Simulated call to subroutine at HL
0416BC             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0416BC             0009*  ; outputs: whatever the subroutine does, including HL and BC
0416BC             0010*  ; destroys: only what the subroutine does, but always BC
0416BC             0011*      MACRO callHL
0416BC             0012*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0013*          push bc       ; which constitutes the return address
0416BC             0014*          jp   (hl)     ; Jump to the address in HL
0416BC             0015*      ENDMACRO
0416BC             0016*  
0416BC             0017*  ; Simulated call to subroutine at IX
0416BC             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0416BC             0019*  ; outputs: whatever the subroutine does, including IX and BC
0416BC             0020*  ; destroys: only what the subroutine does, but always BC
0416BC             0021*      MACRO callIX
0416BC             0022*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0023*          push bc       ; which constitutes the return address
0416BC             0024*          jp   (ix)     ; Jump to the address in IX
0416BC             0025*      ENDMACRO
0416BC             0026*  
0416BC             0027*  ; Simulated call to soubroutinte at IY
0416BC             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0416BC             0029*  ; outputs: whatever the subroutine does, including IY and BC
0416BC             0030*  ; destroys: only what the subroutine does, but always BC
0416BC             0031*      MACRO callIY
0416BC             0032*          ld bc,$+7     ; Address of first instruction after the jump
0416BC             0033*          push bc       ; which constitutes the return address
0416BC             0034*          jp   (iy)     ; Jump to the address in IY
0416BC             0035*      ENDMACRO
0416BC             0036*  
0416BC             0037*  ; put the value in HLU into the accumulator
0416BC             0038*  ; destroys: af
0416BC             0039*      MACRO HLU_TO_A
0416BC             0040*          push hl ; 4 cycles
0416BC             0041*          inc sp ; 1 cycle
0416BC             0042*          pop af  ; 4 cycles
0416BC             0043*          dec sp ; 1 cycle
0416BC             0044*                 ; 10 cycles total
0416BC             0045*      ENDMACRO
0416BC             0046*  
0416BC             0047*  A_TO_HLU:
0416BC             0048*      ; call is 7 cycles
0416BC 22 C9 16 04 0049*      ld (@scratch),hl ; 7 cycles
0416C0 32 CB 16 04 0050*      ld (@scratch+2),a ; 5 cycles
0416C4 2A C9 16 04 0051*      ld hl,(@scratch) ; 7 cycles
0416C8 C9          0052*      ret ; 6 cycles
0416C9             0053*          ; 25 cycles total
0416C9 00 00 00    0054*  @scratch: dl 0
0416CC             0055*  
0416CC             0056*      ; TODO: implement this
0416CC             0057*      ; MACRO A_TO_HLU
0416CC             0058*      ;     push.s af
0416CC             0059*      ;     inc sp
0416CC             0060*      ;     push.s hl
0416CC             0061*      ;     pop hl
0416CC             0062*      ;     inc sp
0416CC             0063*      ;     inc sp
0416CC             0064*      ; ENDMACRO
0416CC             0065*  
0416CC             0066*      MACRO PUSH_ALL
0416CC             0067*          ex af,af'
0416CC             0068*          exx
0416CC             0069*          push af
0416CC             0070*          push hl
0416CC             0071*          push bc
0416CC             0072*          push de
0416CC             0073*  
0416CC             0074*          ex af,af'
0416CC             0075*          exx
0416CC             0076*          push af
0416CC             0077*          push hl
0416CC             0078*          push bc
0416CC             0079*          push de
0416CC             0080*          push ix
0416CC             0081*          push iy
0416CC             0082*      ENDMACRO
0416CC             0083*  
0416CC             0084*      MACRO POP_ALL
0416CC             0085*          pop iy
0416CC             0086*          pop ix
0416CC             0087*          pop de
0416CC             0088*          pop bc
0416CC             0089*          pop hl
0416CC             0090*          pop af
0416CC             0091*          ex af,af'
0416CC             0092*          exx
0416CC             0093*  
0416CC             0094*          pop de
0416CC             0095*          pop bc
0416CC             0096*          pop hl
0416CC             0097*          pop af
0416CC             0098*          ex af,af'
0416CC             0099*          exx
0416CC             0100*      ENDMACRO
0416CC             0101*  
0416CC             0102*  ; Print a zero-terminated string inline with code, e.g.:
0416CC             0103*  ;
0416CC             0104*  ;    call printInline
0416CC             0105*  ;    ASCIZ "Hello, world!\r\n"
0416CC             0106*  ;
0416CC             0107*  ; Destroys: HL,AF
0416CC             0108*  printInline:
0416CC E1          0109*      pop hl ; get the return address = pointer to start of string
0416CD CD D3 16 04 0110*      call printString ; HL advances to end of string
0416D1 E5          0111*      push hl ; restore the return address = pointer to end of string
0416D2 C9          0112*      ret
0416D3             0113*  
0416D3             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0416D3             0115*  ; Print a zero-terminated string
0416D3             0116*  ; HL: Pointer to string
0416D3             0117*  printString:
0416D3 C5          0118*  	PUSH	BC
0416D4 01 00 00 00 0119*  	LD		BC,0
0416D8 3E 00       0120*  	LD 	 	A,0
0416DA 5B DF       0121*  	RST.LIL 18h
0416DC C1          0122*  	POP		BC
0416DD C9          0123*  	RET
0416DE             0124*  ; print a VDU sequence
0416DE             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0416DE             0126*  sendVDUsequence:
0416DE C5          0127*  	PUSH	BC
0416DF 01 00 00 00 0128*  	LD		BC, 0
0416E3 4E          0129*  	LD		C, (HL)
0416E4 5B DF       0130*  	RST.LIL	18h
0416E6 C1          0131*  	POP		BC
0416E7 C9          0132*  	RET
0416E8             0133*  ; Print Newline sequence to VDP
0416E8             0134*  printNewLine:
0416E8 F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
0416E9 3E 0D       0136*  	LD	A, '\r'
0416EB 5B D7       0137*  	RST.LIL 10h
0416ED 3E 0A       0138*  	LD	A, '\n'
0416EF 5B D7       0139*  	RST.LIL 10h
0416F1 F1          0140*      pop af
0416F2 C9          0141*  	RET
0416F3             0142*  
0416F3             0143*  ; Print a 24-bit HEX number
0416F3             0144*  ; HLU: Number to print
0416F3             0145*  printHex24:
0416F3             0146*      HLU_TO_A
0416F3 E5          0001*M         push hl ; 4 cycles
0416F4 33          0002*M         inc sp ; 1 cycle
0416F5 F1          0003*M         pop af  ; 4 cycles
0416F6 3B          0004*M         dec sp ; 1 cycle
0416F7             0005*M                ; 10 cycles total
0416F7 CD 01 17 04 0147*  	CALL	printHex8
0416FB             0148*  ; Print a 16-bit HEX number
0416FB             0149*  ; HL: Number to print
0416FB             0150*  printHex16:
0416FB 7C          0151*  	LD		A,H
0416FC CD 01 17 04 0152*  	CALL	printHex8
041700 7D          0153*  	LD		A,L
041701             0154*  ; Print an 8-bit HEX number
041701             0155*  ; A: Number to print
041701             0156*  printHex8:
041701 4F          0157*  	LD		C,A
041702 1F          0158*  	RRA
041703 1F          0159*  	RRA
041704 1F          0160*  	RRA
041705 1F          0161*  	RRA
041706 CD 0B 17 04 0162*  	CALL	@F
04170A 79          0163*  	LD		A,C
04170B             0164*  @@:
04170B E6 0F       0165*  	AND		0Fh
04170D C6 90       0166*  	ADD		A,90h
04170F 27          0167*  	DAA
041710 CE 40       0168*  	ADC		A,40h
041712 27          0169*  	DAA
041713 5B D7       0170*  	RST.LIL	10h
041715 C9          0171*  	RET
041716             0172*  
041716             0173*  printHexA:
041716 F5          0174*      push af
041717 C5          0175*      push bc
041718 CD 01 17 04 0176*      call printHex8
04171C 3E 20       0177*      ld a,' '
04171E 5B D7       0178*      rst.lil 10h
041720 C1          0179*      pop bc
041721 F1          0180*      pop af
041722 C9          0181*      ret
041723             0182*  
041723             0183*  printHexHL:
041723 F5          0184*      push af
041724 C5          0185*      push bc
041725 CD FB 16 04 0186*      call printHex16
041729 3E 20       0187*      ld a,' '
04172B 5B D7       0188*      rst.lil 10h
04172D C1          0189*      pop bc
04172E F1          0190*      pop af
04172F C9          0191*      ret
041730             0192*  
041730             0193*  printHexUHL:
041730 F5          0194*      push af
041731 C5          0195*      push bc
041732 CD F3 16 04 0196*      call printHex24
041736 3E 20       0197*      ld a,' '
041738 5B D7       0198*      rst.lil 10h
04173A C1          0199*      pop bc
04173B F1          0200*      pop af
04173C C9          0201*      ret
04173D             0202*  
04173D             0203*  printHexAUHL:
04173D F5          0204*      push af
04173E C5          0205*      push bc
04173F CD 01 17 04 0206*      call printHex8
041743 3E 2E       0207*      ld a,'.'
041745 5B D7       0208*      rst.lil 10h
041747 CD F3 16 04 0209*      call printHex24
04174B 3E 20       0210*      ld a,' '
04174D 5B D7       0211*      rst.lil 10h
04174F C1          0212*      pop bc
041750 F1          0213*      pop af
041751 C9          0214*      ret
041752             0215*  
041752             0216*  printHexABHL:
041752             0217*  ; preserve registers
041752 C5          0218*      push bc ; b will be ok c will not
041753 F5          0219*      push af ; will get totally destroyed
041754             0220*  ; print a
041754 CD 01 17 04 0221*      call printHex8
041758             0222*  ; print b
041758 78          0223*      ld a,b
041759 CD 01 17 04 0224*      call printHex8
04175D             0225*  ; print hl
04175D CD FB 16 04 0226*      call printHex16
041761             0227*  ; restore registers
041761 F1          0228*      pop af
041762 C1          0229*      pop bc
041763 C9          0230*      ret
041764             0231*  
041764             0232*  printHexBHL:
041764             0233*  ; preserve registers
041764 C5          0234*      push bc ; b will be ok c will not
041765 F5          0235*      push af ; will get totally destroyed
041766             0236*  ; print b
041766 78          0237*      ld a,b
041767 CD 01 17 04 0238*      call printHex8
04176B             0239*  ; print hl
04176B CD FB 16 04 0240*      call printHex16
04176F             0241*  ; restore registers
04176F F1          0242*      pop af
041770 C1          0243*      pop bc
041771 C9          0244*      ret
041772             0245*  
041772             0246*  printHexCDE:
041772             0247*  ; preserve registers
041772 C5          0248*      push bc ; b will be ok c will not
041773 F5          0249*      push af ; will get totally destroyed
041774             0250*  ; print c
041774 79          0251*      ld a,c
041775 CD 01 17 04 0252*      call printHex8
041779             0253*  ; print de
041779 EB          0254*      ex de,hl
04177A CD FB 16 04 0255*      call printHex16
04177E EB          0256*      ex de,hl
04177F             0257*  ; restore registers
04177F F1          0258*      pop af
041780 C1          0259*      pop bc
041781 C9          0260*      ret
041782             0261*  
041782             0262*  printHexUIX:
041782             0263*  ; store everything in scratch
041782 22 FB 1B 04 0264*      ld (uhl),hl
041786 ED 43 FE 1B 0265*      ld (ubc),bc
       04          
04178B ED 53 01 1C 0266*      ld (ude),de
       04          
041790 DD 22 04 1C 0267*      ld (uix),ix
       04          
041795 FD 22 07 1C 0268*      ld (uiy),iy
       04          
04179A F5          0269*      push af ; fml
04179B             0270*  
04179B 21 92 1B 04 0271*      ld hl,str_ixu
04179F CD D3 16 04 0272*      call printString
0417A3 2A 04 1C 04 0273*      ld hl,(uix)
0417A7 CD F3 16 04 0274*      call printHex24
0417AB CD E8 16 04 0275*      call printNewLine
0417AF             0276*  
0417AF             0277*  ; restore everything
0417AF 2A FB 1B 04 0278*      ld hl, (uhl)
0417B3 ED 4B FE 1B 0279*      ld bc, (ubc)
       04          
0417B8 ED 5B 01 1C 0280*      ld de, (ude)
       04          
0417BD DD 2A 04 1C 0281*      ld ix, (uix)
       04          
0417C2 FD 2A 07 1C 0282*      ld iy, (uiy)
       04          
0417C7 F1          0283*      pop af
0417C8             0284*  ; all done
0417C8 C9          0285*      ret
0417C9             0286*  
0417C9             0287*  ; Print a 0x HEX prefix
0417C9             0288*  DisplayHexPrefix:
0417C9 3E 30       0289*  	LD	A, '0'
0417CB 5B D7       0290*  	RST.LIL 10h
0417CD 3E 78       0291*  	LD	A, 'x'
0417CF 5B D7       0292*  	RST.LIL 10h
0417D1 C9          0293*  	RET
0417D2             0294*  
0417D2             0295*      MACRO printDecBC
0417D2             0296*          push hl
0417D2             0297*          push bc
0417D2             0298*          pop hl
0417D2             0299*          call printDec
0417D2             0300*          pop hl
0417D2             0301*      ENDMACRO
0417D2             0302*  
0417D2             0303*      MACRO printDecDE
0417D2             0304*          push hl
0417D2             0305*          push de
0417D2             0306*          pop hl
0417D2             0307*          call printDec
0417D2             0308*          pop hl
0417D2             0309*      ENDMACRO
0417D2             0310*  
0417D2             0311*      MACRO printDecHL
0417D2             0312*          call printDec
0417D2             0313*      ENDMACRO
0417D2             0314*  
0417D2             0315*      MACRO printDecIX
0417D2             0316*          push hl
0417D2             0317*          push ix
0417D2             0318*          pop hl
0417D2             0319*          call printDec
0417D2             0320*          pop hl
0417D2             0321*      ENDMACRO
0417D2             0322*  
0417D2             0323*      MACRO printDecIY
0417D2             0324*          push hl
0417D2             0325*          push iy
0417D2             0326*          pop hl
0417D2             0327*          call printDec
0417D2             0328*          pop hl
0417D2             0329*      ENDMACRO
0417D2             0330*  
0417D2             0331*  
0417D2             0332*  ; Prints the right justified decimal value in HL without leading zeroes
0417D2             0333*  ; HL : Value to print
0417D2             0334*  ; preserves all registers and flags
0417D2             0335*  printDec:
0417D2             0336*  ; BEGIN MY CODE
0417D2             0337*  ; back up all the things
0417D2 F5          0338*      push af
0417D3 C5          0339*      push bc
0417D4 D5          0340*      push de
0417D5 E5          0341*      push hl
0417D6             0342*  ; END MY CODE
0417D6 11 FE 17 04 0343*  	LD	 DE, _printDecBuffer
0417DA CD 0E 18 04 0344*  	CALL u24_to_ascii
0417DE             0345*  ; BEGIN MY CODE
0417DE             0346*  ; replace leading zeroes with spaces
0417DE 21 FE 17 04 0347*      LD	 HL, _printDecBuffer
0417E2 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0417E4             0349*  @loop:
0417E4 7E          0350*      LD	 A, (HL)
0417E5 FE 30       0351*      CP	 '0'
0417E7 C2 F1 17 04 0352*      JP	 NZ, @done
0417EB 3E 20       0353*      LD   A, ' '
0417ED 77          0354*      LD	 (HL), A
0417EE 23          0355*      INC	 HL
0417EF             0356*      ; CALL vdu_cursor_forward
0417EF 10 F3       0357*      DJNZ @loop
0417F1             0358*  @done:
0417F1             0359*  ; END MY CODE
0417F1 21 FE 17 04 0360*  	LD	 HL, _printDecBuffer
0417F5 CD D3 16 04 0361*  	CALL printString
0417F9             0362*  ; BEGIN MY CODE
0417F9             0363*  ; restore all the things
0417F9 E1          0364*      pop hl
0417FA D1          0365*      pop de
0417FB C1          0366*      pop bc
0417FC F1          0367*      pop af
0417FD             0368*  ; END MY CODE
0417FD C9          0369*  	RET
0417FE 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04180E             0371*  
04180E             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
04180E             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
04180E             0374*  ; so it will allways be 8 characters length
04180E             0375*  ; HL : Value to convert to string
04180E             0376*  ; DE : pointer to buffer, at least 8 byte + 0
04180E             0377*  u24_to_ascii:
04180E 01 80 69 67 0378*  	LD	 BC,-10000000
041812 CD 45 18 04 0379*  	CALL @one_digit
041816 01 C0 BD F0 0380*  	LD	 BC,-1000000
04181A CD 45 18 04 0381*  	CALL @one_digit
04181E 01 60 79 FE 0382*  	LD	 BC,-100000
041822 CD 45 18 04 0383*  	CALL @one_digit
041826 01 F0 D8 FF 0384*  	LD   BC,-10000
04182A CD 45 18 04 0385*  	CALL @one_digit
04182E 01 18 FC FF 0386*  	LD   BC,-1000
041832 CD 45 18 04 0387*  	CALL @one_digit
041836 01 9C FF FF 0388*  	LD   BC,-100
04183A CD 45 18 04 0389*  	CALL @one_digit
04183E 0E F6       0390*  	LD   C,-10
041840 CD 45 18 04 0391*  	CALL @one_digit
041844 48          0392*  	LD   C,B
041845             0393*  @one_digit:
041845 3E 2F       0394*  	LD   A,'0'-1
041847             0395*  @divide_me:
041847 3C          0396*  	INC  A
041848 09          0397*  	ADD  HL,BC
041849 38 FC       0398*  	JR   C,@divide_me
04184B ED 42       0399*  	SBC  HL,BC
04184D 12          0400*  	LD   (DE),A
04184E 13          0401*  	INC  DE
04184F C9          0402*  	RET
041850             0403*  
041850             0404*  print_u24:
041850 D5          0405*      push de
041851 E5          0406*      push hl
041852 11 FE 17 04 0407*      ld de,_printDecBuffer
041856 CD 0E 18 04 0408*      call u24_to_ascii
04185A 21 FE 17 04 0409*      ld hl,_printDecBuffer
04185E CD D3 16 04 0410*      call printString
041862 3E 20       0411*      ld a,' '
041864 5B D7       0412*      rst.lil 10h
041866 E1          0413*      pop hl
041867 D1          0414*      pop de
041868 C9          0415*      ret
041869             0416*  
041869             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
041869             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
041869             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
041869             0420*  u168_to_ascii:
041869             0421*  ; add a leading space to make room for sign flag if needed
041869 3E 20       0422*      ld a,' '
04186B 12          0423*      ld (de),a
04186C 13          0424*      inc de
04186D             0425*  ; Convert integer part
04186D E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
04186E CD 5B 23 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
041872 01 F0 D8 FF 0428*      ld   bc, -10000
041876 CD 99 18 04 0429*      call @one_int
04187A 01 18 FC FF 0430*      ld   bc, -1000
04187E CD 99 18 04 0431*      call @one_int
041882 01 9C FF FF 0432*      ld   bc, -100
041886 CD 99 18 04 0433*      call @one_int
04188A 0E F6       0434*      ld   c, -10
04188C CD 99 18 04 0435*      call @one_int
041890 48          0436*      ld   c, b
041891 CD 99 18 04 0437*      call @one_int
041895 C3 A4 18 04 0438*      jp   @frac            ; Jump to fractional part conversion
041899             0439*  @one_int:
041899 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
04189B             0441*  @divide_me:
04189B 3C          0442*      inc  a
04189C 09          0443*      add  hl, bc           ; Accumulate until overflow
04189D 38 FC       0444*      jr   c, @divide_me
04189F ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
0418A1 12          0446*      ld   (de), a          ; Store ASCII digit
0418A2 13          0447*      inc  de
0418A3 C9          0448*      ret
0418A4             0449*  ; Convert fractional part
0418A4             0450*  @frac:
0418A4 3E 2E       0451*      ld   a, '.'           ; Decimal point
0418A6 12          0452*      ld   (de), a
0418A7 13          0453*      inc  de
0418A8 E1          0454*      pop  hl               ; Restore HL with original fraction
0418A9 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
0418AB             0456*  @frac_loop:
0418AB 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
0418AD ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0418AF 3E 30       0459*      ld   a, '0'
0418B1 84          0460*      add  a, h             ; Convert integer part to ASCII
0418B2 12          0461*      ld   (de), a
0418B3 13          0462*      inc  de
0418B4 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
0418B6             0464*  ; Add null terminator
0418B6 AF          0465*      xor  a                ; Null terminator
0418B7 12          0466*      ld   (de), a
0418B8 C9          0467*      ret
0418B9             0468*  
0418B9             0469*  print_u168:
0418B9 D5          0470*      push de
0418BA E5          0471*      push hl
0418BB 11 FE 17 04 0472*      ld de,_printDecBuffer
0418BF CD 69 18 04 0473*      call u168_to_ascii
0418C3 21 FE 17 04 0474*      ld hl,_printDecBuffer
0418C7 CD D3 16 04 0475*      call printString
0418CB E1          0476*      pop hl
0418CC D1          0477*      pop de
0418CD C9          0478*      ret
0418CE             0479*  
0418CE             0480*  ; signed version of u168_to_ascii
0418CE             0481*  s168_to_ascii:
0418CE D5          0482*      push de ; save starting address of buffer
0418CF CD F4 22 04 0483*      call hlu_abs
0418D3 F5          0484*      push af ; save sign flag
0418D4 CD 69 18 04 0485*      call u168_to_ascii
0418D8 F1          0486*      pop af ; restore sign flag
0418D9 D1          0487*      pop de ; restore starting address of buffer
0418DA F0          0488*      ret p ; hlu was positive so nothing to do
0418DB 3E 2D       0489*      ld a,'-'
0418DD 12          0490*      ld (de),a
0418DE C9          0491*      ret
0418DF             0492*  
0418DF             0493*  print_s168:
0418DF D5          0494*      push de
0418E0 E5          0495*      push hl
0418E1 11 FE 17 04 0496*      ld de,_printDecBuffer
0418E5 CD CE 18 04 0497*      call s168_to_ascii
0418E9 21 FE 17 04 0498*      ld hl,_printDecBuffer
0418ED CD D3 16 04 0499*      call printString
0418F1 E1          0500*      pop hl
0418F2 D1          0501*      pop de
0418F3 C9          0502*      ret
0418F4             0503*  
0418F4             0504*  print_s168_hl:
0418F4 F5          0505*      push af
0418F5 E5          0506*      push hl
0418F6 CD DF 18 04 0507*      call print_s168
0418FA 3E 20       0508*      ld a,' '
0418FC 5B D7       0509*      rst.lil 10h
0418FE E1          0510*      pop hl
0418FF F1          0511*      pop af
041900 C9          0512*      ret
041901             0513*  
041901             0514*  print_s168_bc:
041901 F5          0515*      push af
041902 C5          0516*      push bc
041903 E5          0517*      push hl
041904 C5          0518*      push bc
041905 E1          0519*      pop hl
041906 CD DF 18 04 0520*      call print_s168
04190A 3E 20       0521*      ld a,' '
04190C 5B D7       0522*      rst.lil 10h
04190E E1          0523*      pop hl
04190F C1          0524*      pop bc
041910 F1          0525*      pop af
041911 C9          0526*      ret
041912             0527*  
041912             0528*  print_s168_de:
041912 F5          0529*      push af
041913 D5          0530*      push de
041914 E5          0531*      push hl
041915 EB          0532*      ex de,hl
041916 CD DF 18 04 0533*      call print_s168
04191A 3E 20       0534*      ld a,' '
04191C 5B D7       0535*      rst.lil 10h
04191E E1          0536*      pop hl
04191F D1          0537*      pop de
041920 F1          0538*      pop af
041921 C9          0539*      ret
041922             0540*  
041922             0541*  print_s168_hl_bc_de:
041922 F5          0542*      push af
041923 C5          0543*      push bc
041924 D5          0544*      push de
041925 E5          0545*      push hl
041926 CD DF 18 04 0546*      call print_s168
04192A 3E 20       0547*      ld a,' '
04192C 5B D7       0548*      rst.lil 10h
04192E C5          0549*      push bc
04192F E1          0550*      pop hl
041930 CD DF 18 04 0551*      call print_s168
041934 3E 20       0552*      ld a,' '
041936 5B D7       0553*      rst.lil 10h
041938 EB          0554*      ex de,hl
041939 CD DF 18 04 0555*      call print_s168
04193D 3E 20       0556*      ld a,' '
04193F 5B D7       0557*      rst.lil 10h
041941 E1          0558*      pop hl
041942 D1          0559*      pop de
041943 C1          0560*      pop bc
041944 F1          0561*      pop af
041945 C9          0562*      ret
041946             0563*  
041946             0564*  print_s168_bc_de:
041946 F5          0565*      push af
041947 C5          0566*      push bc
041948 D5          0567*      push de
041949 C5          0568*      push bc
04194A E1          0569*      pop hl
04194B CD DF 18 04 0570*      call print_s168
04194F 3E 20       0571*      ld a,' '
041951 5B D7       0572*      rst.lil 10h
041953 EB          0573*      ex de,hl
041954 CD DF 18 04 0574*      call print_s168
041958 3E 20       0575*      ld a,' '
04195A 5B D7       0576*      rst.lil 10h
04195C E1          0577*      pop hl
04195D D1          0578*      pop de
04195E C1          0579*      pop bc
04195F F1          0580*      pop af
041960 C9          0581*      ret
041961             0582*  
041961             0583*  print_s168_a:
041961 F5          0584*      push af
041962 C5          0585*      push bc
041963 E5          0586*      push hl
041964 21 00 00 00 0587*      ld hl,0
041968 6F          0588*      ld l,a
041969 CD F4 18 04 0589*      call print_s168_hl
04196D E1          0590*      pop hl
04196E C1          0591*      pop bc
04196F F1          0592*      pop af
041970 C9          0593*      ret
041971             0594*  
041971             0595*  ; #### new functions added by Brandon R. Gates ####
041971             0596*  
041971             0597*  ; print the binary representation of the 8-bit value in a
041971             0598*  ; destroys a, hl, bc
041971             0599*  printBin8:
041971 06 08       0600*      ld b,8      ; loop counter for 8 bits
041973 21 8E 19 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
041977             0602*                  ; (which will be the high bit of the value in a)
041977             0603*  @loop:
041977 07          0604*      rlca ; put the next highest bit into carry
041978 38 04       0605*      jr c,@one
04197A 36 30       0606*      ld (hl),'0'
04197C 18 02       0607*      jr @next_bit
04197E             0608*  @one:
04197E 36 31       0609*      ld (hl),'1'
041980             0610*  @next_bit:
041980 23          0611*      inc hl
041981 10 F4       0612*      djnz @loop
041983             0613*  ; print it
041983 21 8E 19 04 0614*  	ld hl,@cmd
041987 01 08 00 00 0615*  	ld bc,@end-@cmd
04198B 5B DF       0616*  	rst.lil $18
04198D C9          0617*  	ret
04198E             0618*  @cmd: ds 8 ; eight bytes for eight bits
041996             0619*  @end:
041996             0620*  
041996             0621*  ; print the binary representation of the 8-bit value in a
041996             0622*  ; in reverse order (lsb first)
041996             0623*  ; destroys a, hl, bc
041996             0624*  printBin8Rev:
041996 06 08       0625*      ld b,8      ; loop counter for 8 bits
041998 21 B3 19 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
04199C             0627*                  ; (which will be the high bit of the value in a)
04199C             0628*  @loop:
04199C 0F          0629*      rrca ; put the next lowest bit into carry
04199D 38 04       0630*      jr c,@one
04199F 36 30       0631*      ld (hl),'0'
0419A1 18 02       0632*      jr @next_bit
0419A3             0633*  @one:
0419A3 36 31       0634*      ld (hl),'1'
0419A5             0635*  @next_bit:
0419A5 23          0636*      inc hl
0419A6 10 F4       0637*      djnz @loop
0419A8             0638*  ; print it
0419A8 21 B3 19 04 0639*  	ld hl,@cmd
0419AC 01 08 00 00 0640*  	ld bc,@end-@cmd
0419B0 5B DF       0641*  	rst.lil $18
0419B2 C9          0642*  	ret
0419B3             0643*  @cmd: ds 8 ; eight bytes for eight bits
0419BB             0644*  @end:
0419BB             0645*  
0419BB             0646*  ; print registers to screen in hexidecimal format
0419BB             0647*  ; inputs: none
0419BB             0648*  ; outputs: values of every register printed to screen
0419BB             0649*  ;    values of each register in global scratch memory
0419BB             0650*  ; destroys: nothing
0419BB             0651*  stepRegistersHex:
0419BB             0652*  ; store everything in scratch
0419BB 22 FB 1B 04 0653*      ld (uhl),hl
0419BF ED 43 FE 1B 0654*      ld (ubc),bc
       04          
0419C4 ED 53 01 1C 0655*      ld (ude),de
       04          
0419C9 DD 22 04 1C 0656*      ld (uix),ix
       04          
0419CE FD 22 07 1C 0657*      ld (uiy),iy
       04          
0419D3 F5          0658*      push af ; fml
0419D4 E1          0659*      pop hl  ; thanks, zilog
0419D5 22 F8 1B 04 0660*      ld (uaf),hl
0419D9 F5          0661*      push af ; dammit
0419DA             0662*  
0419DA             0663*  ; home the cursor
0419DA             0664*      ; call vdu_home_cursor
0419DA             0665*  
0419DA             0666*  ; print each register
0419DA 21 7E 1B 04 0667*      ld hl,str_afu
0419DE CD D3 16 04 0668*      call printString
0419E2 2A F8 1B 04 0669*      ld hl,(uaf)
0419E6 CD F3 16 04 0670*      call printHex24
0419EA CD E8 16 04 0671*      call printNewLine
0419EE             0672*  
0419EE 21 83 1B 04 0673*      ld hl,str_hlu
0419F2 CD D3 16 04 0674*      call printString
0419F6 2A FB 1B 04 0675*      ld hl,(uhl)
0419FA CD F3 16 04 0676*      call printHex24
0419FE CD E8 16 04 0677*      call printNewLine
041A02             0678*  
041A02 21 88 1B 04 0679*      ld hl,str_bcu
041A06 CD D3 16 04 0680*      call printString
041A0A 2A FE 1B 04 0681*      ld hl,(ubc)
041A0E CD F3 16 04 0682*      call printHex24
041A12 CD E8 16 04 0683*      call printNewLine
041A16             0684*  
041A16 21 8D 1B 04 0685*      ld hl,str_deu
041A1A CD D3 16 04 0686*      call printString
041A1E 2A 01 1C 04 0687*      ld hl,(ude)
041A22 CD F3 16 04 0688*      call printHex24
041A26 CD E8 16 04 0689*      call printNewLine
041A2A             0690*  
041A2A 21 92 1B 04 0691*      ld hl,str_ixu
041A2E CD D3 16 04 0692*      call printString
041A32 2A 04 1C 04 0693*      ld hl,(uix)
041A36 CD F3 16 04 0694*      call printHex24
041A3A CD E8 16 04 0695*      call printNewLine
041A3E             0696*  
041A3E 21 97 1B 04 0697*      ld hl,str_iyu
041A42 CD D3 16 04 0698*      call printString
041A46 2A 07 1C 04 0699*      ld hl,(uiy)
041A4A CD F3 16 04 0700*      call printHex24
041A4E CD E8 16 04 0701*      call printNewLine
041A52             0702*  
041A52             0703*      ; call vsync
041A52             0704*  
041A52 CD E8 16 04 0705*      call printNewLine
041A56             0706*  
041A56             0707*  ; check for right shift key and quit if pressed
041A56             0708*  	MOSCALL mos_getkbmap
041A56 3E 1E       0001*M 			LD	A, function
041A58 5B CF       0002*M 			RST.LIL	08h
041A5A             0709*  @stayhere:
041A5A             0710*  ; 7 RightShift
041A5A DD CB 00 76 0711*      bit 6,(ix+0)
041A5E 20 02       0712*      jr nz,@RightShift
041A60 18 F8       0713*      jr @stayhere
041A62             0714*  @RightShift:
041A62 DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
041A66 3E 80       0716*      ld a,%10000000
041A68             0717*      ; call multiPurposeDelay
041A68             0718*  
041A68             0719*  ; restore everything
041A68 2A FB 1B 04 0720*      ld hl, (uhl)
041A6C ED 4B FE 1B 0721*      ld bc, (ubc)
       04          
041A71 ED 5B 01 1C 0722*      ld de, (ude)
       04          
041A76 DD 2A 04 1C 0723*      ld ix, (uix)
       04          
041A7B FD 2A 07 1C 0724*      ld iy, (uiy)
       04          
041A80 F1          0725*      pop af
041A81             0726*  ; all done
041A81 C9          0727*      ret
041A82             0728*  
041A82             0729*  ; print registers to screen in hexidecimal format
041A82             0730*  ; inputs: none
041A82             0731*  ; outputs: values of every register printed to screen
041A82             0732*  ;    values of each register in global scratch memory
041A82             0733*  ; destroys: nothing
041A82             0734*  dumpRegistersHex:
041A82             0735*  ; store everything in scratch
041A82 22 FB 1B 04 0736*      ld (uhl),hl
041A86 ED 43 FE 1B 0737*      ld (ubc),bc
       04          
041A8B ED 53 01 1C 0738*      ld (ude),de
       04          
041A90 DD 22 04 1C 0739*      ld (uix),ix
       04          
041A95 FD 22 07 1C 0740*      ld (uiy),iy
       04          
041A9A F5          0741*      push af ; fml
041A9B E1          0742*      pop hl  ; thanks, zilog
041A9C 22 F8 1B 04 0743*      ld (uaf),hl
041AA0 F5          0744*      push af ; dammit
041AA1             0745*  
041AA1             0746*  ; home the cursor
041AA1             0747*      ; call vdu_home_cursor
041AA1             0748*      ; call printNewLine
041AA1             0749*  
041AA1             0750*  ; print each register
041AA1 21 7E 1B 04 0751*      ld hl,str_afu
041AA5 CD D3 16 04 0752*      call printString
041AA9 2A F8 1B 04 0753*      ld hl,(uaf)
041AAD CD F3 16 04 0754*      call printHex24
041AB1             0755*      ; call printNewLine
041AB1             0756*  
041AB1 21 83 1B 04 0757*      ld hl,str_hlu
041AB5 CD D3 16 04 0758*      call printString
041AB9 2A FB 1B 04 0759*      ld hl,(uhl)
041ABD CD F3 16 04 0760*      call printHex24
041AC1             0761*      ; call printNewLine
041AC1             0762*  
041AC1 21 88 1B 04 0763*      ld hl,str_bcu
041AC5 CD D3 16 04 0764*      call printString
041AC9 2A FE 1B 04 0765*      ld hl,(ubc)
041ACD CD F3 16 04 0766*      call printHex24
041AD1             0767*      ; call printNewLine
041AD1             0768*  
041AD1 21 8D 1B 04 0769*      ld hl,str_deu
041AD5 CD D3 16 04 0770*      call printString
041AD9 2A 01 1C 04 0771*      ld hl,(ude)
041ADD CD F3 16 04 0772*      call printHex24
041AE1             0773*      ; call printNewLine
041AE1             0774*  
041AE1 21 92 1B 04 0775*      ld hl,str_ixu
041AE5 CD D3 16 04 0776*      call printString
041AE9 2A 04 1C 04 0777*      ld hl,(uix)
041AED CD F3 16 04 0778*      call printHex24
041AF1             0779*      ; call printNewLine
041AF1             0780*  
041AF1 21 97 1B 04 0781*      ld hl,str_iyu
041AF5 CD D3 16 04 0782*      call printString
041AF9 2A 07 1C 04 0783*      ld hl,(uiy)
041AFD CD F3 16 04 0784*      call printHex24
041B01             0785*      ; call printNewLine
041B01             0786*  
041B01             0787*      ; call vdu_vblank
041B01             0788*  
041B01 CD E8 16 04 0789*      call printNewLine
041B05             0790*  ; restore everything
041B05 2A FB 1B 04 0791*      ld hl, (uhl)
041B09 ED 4B FE 1B 0792*      ld bc, (ubc)
       04          
041B0E ED 5B 01 1C 0793*      ld de, (ude)
       04          
041B13 DD 2A 04 1C 0794*      ld ix, (uix)
       04          
041B18 FD 2A 07 1C 0795*      ld iy, (uiy)
       04          
041B1D F1          0796*      pop af
041B1E             0797*  ; all done
041B1E C9          0798*      ret
041B1F             0799*  
041B1F             0800*  dumpRegistersHexPrime:
041B1F D9          0801*      exx
041B20 08          0802*      ex af,af'
041B21 CD 82 1A 04 0803*      call dumpRegistersHex
041B25 08          0804*      ex af,af'
041B26 D9          0805*      exx
041B27 C9          0806*      ret
041B28             0807*  
041B28             0808*  ; additionally dump prime registers
041B28             0809*  ; inputs: none
041B28             0810*  ; outputs: values of every register printed to screen
041B28             0811*  ; destroys: nothing
041B28             0812*  dumpRegistersHexAll:
041B28 CD 82 1A 04 0813*      call dumpRegistersHex
041B2C 08          0814*      ex af,af'
041B2D D9          0815*      exx
041B2E CD 82 1A 04 0816*      call dumpRegistersHex
041B32 08          0817*      ex af,af'
041B33 D9          0818*      exx
041B34 C9          0819*      ret
041B35             0820*  
041B35             0821*  ; print hlu to screen in hexidecimal format
041B35             0822*  ; inputs: none
041B35             0823*  ; destroys: nothing
041B35             0824*  print_hex_hl:
041B35 F5          0825*      push af
041B36 E5          0826*      push hl
041B37 21 83 1B 04 0827*      ld hl,str_hlu
041B3B CD D3 16 04 0828*      call printString
041B3F E1          0829*      pop hl
041B40 E5          0830*      push hl
041B41 CD F3 16 04 0831*      call printHex24
041B45 3E 20       0832*      ld a,' '
041B47 5B D7       0833*      rst.lil 10h
041B49 E1          0834*      pop hl
041B4A F1          0835*      pop af
041B4B C9          0836*      ret
041B4C             0837*  
041B4C             0838*  ; print bcu to screen in hexidecimal format
041B4C             0839*  ; inputs: none
041B4C             0840*  ; destroys: nothing
041B4C             0841*  print_hex_bc:
041B4C F5          0842*      push af
041B4D E5          0843*      push hl
041B4E C5          0844*      push bc
041B4F 21 88 1B 04 0845*      ld hl,str_bcu
041B53 CD D3 16 04 0846*      call printString
041B57 E1          0847*      pop hl
041B58 E5          0848*      push hl
041B59 CD F3 16 04 0849*      call printHex24
041B5D 3E 20       0850*      ld a,' '
041B5F 5B D7       0851*      rst.lil 10h
041B61 C1          0852*      pop bc
041B62 E1          0853*      pop hl
041B63 F1          0854*      pop af
041B64 C9          0855*      ret
041B65             0856*  
041B65             0857*  ; print deu to screen in hexidecimal format
041B65             0858*  ; inputs: none
041B65             0859*  ; destroys: nothing
041B65             0860*  print_hex_de:
041B65 F5          0861*      push af
041B66 E5          0862*      push hl
041B67 D5          0863*      push de
041B68 21 8D 1B 04 0864*      ld hl,str_deu
041B6C CD D3 16 04 0865*      call printString
041B70 E1          0866*      pop hl
041B71 E5          0867*      push hl
041B72 CD F3 16 04 0868*      call printHex24
041B76 3E 20       0869*      ld a,' '
041B78 5B D7       0870*      rst.lil 10h
041B7A D1          0871*      pop de
041B7B E1          0872*      pop hl
041B7C F1          0873*      pop af
041B7D C9          0874*      ret
041B7E             0875*  
041B7E 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
041B83 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
041B88 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
041B8D 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
041B92 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
041B97 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
041B9C             0882*  
041B9C             0883*  ; print udeuhl to screen in hexidecimal format
041B9C             0884*  ; inputs: none
041B9C             0885*  ; outputs: concatenated hexidecimal udeuhl
041B9C             0886*  ; destroys: nothing
041B9C             0887*  dumpUDEUHLHex:
041B9C             0888*  ; store everything in scratch
041B9C 22 FB 1B 04 0889*      ld (uhl),hl
041BA0 ED 43 FE 1B 0890*      ld (ubc),bc
       04          
041BA5 ED 53 01 1C 0891*      ld (ude),de
       04          
041BAA DD 22 04 1C 0892*      ld (uix),ix
       04          
041BAF FD 22 07 1C 0893*      ld (uiy),iy
       04          
041BB4 F5          0894*      push af
041BB5             0895*  
041BB5             0896*  ; print each register
041BB5             0897*  
041BB5 21 EF 1B 04 0898*      ld hl,str_udeuhl
041BB9 CD D3 16 04 0899*      call printString
041BBD 2A 01 1C 04 0900*      ld hl,(ude)
041BC1 CD F3 16 04 0901*      call printHex24
041BC5 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
041BC7 5B D7       0903*  	rst.lil 10h
041BC9 2A FB 1B 04 0904*      ld hl,(uhl)
041BCD CD F3 16 04 0905*      call printHex24
041BD1 CD E8 16 04 0906*      call printNewLine
041BD5             0907*  
041BD5             0908*  ; restore everything
041BD5 2A FB 1B 04 0909*      ld hl, (uhl)
041BD9 ED 4B FE 1B 0910*      ld bc, (ubc)
       04          
041BDE ED 5B 01 1C 0911*      ld de, (ude)
       04          
041BE3 DD 2A 04 1C 0912*      ld ix, (uix)
       04          
041BE8 FD 2A 07 1C 0913*      ld iy, (uiy)
       04          
041BED F1          0914*      pop af
041BEE             0915*  ; all done
041BEE C9          0916*      ret
041BEF             0917*  
041BEF 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041BF8             0919*  
041BF8             0920*  ; global scratch memory for registers
041BF8 00 00 00    0921*  uaf: dl 0
041BFB 00 00 00    0922*  uhl: dl 0
041BFE 00 00 00    0923*  ubc: dl 0
041C01 00 00 00    0924*  ude: dl 0
041C04 00 00 00    0925*  uix: dl 0
041C07 00 00 00    0926*  uiy: dl 0
041C0A 00 00 00    0927*  usp: dl 0
041C0D 00 00 00    0928*  upc: dl 0
041C10             0929*  
041C10             0930*  ; inputs: whatever is in the flags register
041C10             0931*  ; outputs: binary representation of flags
041C10             0932*  ;          with a header so we know which is what
041C10             0933*  ; destroys: nothing
041C10             0934*  ; preserves: everything
041C10             0935*  dumpFlags:
041C10             0936*  ; first we curse zilog for not giving direct access to flags
041C10 F5          0937*      push af ; this is so we can send it back unharmed
041C11 F5          0938*      push af ; this is so we can pop it to hl
041C12             0939*  ; store everything in scratch
041C12 22 FB 1B 04 0940*      ld (uhl),hl
041C16 ED 43 FE 1B 0941*      ld (ubc),bc
       04          
041C1B ED 53 01 1C 0942*      ld (ude),de
       04          
041C20 DD 22 04 1C 0943*      ld (uix),ix
       04          
041C25 FD 22 07 1C 0944*      ld (uiy),iy
       04          
041C2A             0945*  ; next we print the header
041C2A 21 56 1C 04 0946*      ld hl,@header
041C2E CD D3 16 04 0947*      call printString
041C32 E1          0948*      pop hl ; flags are now in l
041C33 7D          0949*      ld a,l ; flags are now in a
041C34 CD 71 19 04 0950*      call printBin8
041C38 CD E8 16 04 0951*  	call printNewLine
041C3C             0952*  ; restore everything
041C3C 2A FB 1B 04 0953*      ld hl, (uhl)
041C40 ED 4B FE 1B 0954*      ld bc, (ubc)
       04          
041C45 ED 5B 01 1C 0955*      ld de, (ude)
       04          
041C4A DD 2A 04 1C 0956*      ld ix, (uix)
       04          
041C4F FD 2A 07 1C 0957*      ld iy, (uiy)
       04          
041C54 F1          0958*      pop af ; send her home the way she came
041C55 C9          0959*      ret
041C56             0960*  ; Bit 7 (S): Sign flag
041C56             0961*  ; Bit 6 (Z): Zero flag
041C56             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041C56             0963*  ; Bit 4 (H): Half Carry flag
041C56             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041C56             0965*  ; Bit 2 (PV): Parity/Overflow flag
041C56             0966*  ; Bit 1 (N): Subtract flag
041C56             0967*  ; Bit 0 (C): Carry flag
041C56 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041C61             0969*  
041C61             0970*  ; set all the bits in the flag register
041C61             0971*  ; more of an academic exercise than anything useful
041C61             0972*  ; inputs; none
041C61             0973*  ; outputs; a=0,f=255
041C61             0974*  ; destroys: flags, hl
041C61             0975*  ; preserves: a, because why not
041C61             0976*  setAllFlags:
041C61 21 FF 00 00 0977*      ld hl,255
041C65 67          0978*      ld h,a ; four cycles to preserve a is cheap
041C66 E5          0979*      push hl
041C67 F1          0980*      pop af
041C68 C9          0981*      ret
041C69             0982*  
041C69             0983*  ; reset all the bits in the flag register
041C69             0984*  ; unlike its inverse counterpart, this may actually be useful
041C69             0985*  ; inputs; none
041C69             0986*  ; outputs; a=0,f=0
041C69             0987*  ; destroys: flags, hl
041C69             0988*  ; preserves: a, because why not
041C69             0989*  resetAllFlags:
041C69 21 00 00 00 0990*      ld hl,0
041C6D 67          0991*      ld h,a ; four cycles to preserve a is cheap
041C6E E5          0992*      push hl
041C6F F1          0993*      pop af
041C70 C9          0994*      ret
041C71             0995*  
041C71             0996*  ; wait until user presses a key
041C71             0997*  ; inputs: none
041C71             0998*  ; outputs: ascii code of key pressed in a
041C71             0999*  ; destroys: af,ix
041C71             1000*  waitKeypress:
041C71             1001*      MOSCALL mos_getkey
041C71 3E 00       0001*M 			LD	A, function
041C73 5B CF       0002*M 			RST.LIL	08h
041C75 C9          1002*      ret
041C76             1003*  
041C76             1004*  ; print bytes from an address to the screen in hexidecimal format
041C76             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041C76             1006*  ; outputs: values of each byte printed to screen separated by spaces
041C76             1007*  ; destroys: nothing
041C76             1008*  dumpMemoryHex:
041C76             1009*  ; save registers to the stack
041C76 C5          1010*      push bc
041C77 E5          1011*      push hl
041C78 F5          1012*      push af
041C79             1013*  
041C79             1014*  ; print the address and separator
041C79 CD F3 16 04 1015*      call printHex24
041C7D 3E 3A       1016*      ld a,':'
041C7F 5B D7       1017*      rst.lil 10h
041C81 3E 20       1018*      ld a,' '
041C83 5B D7       1019*      rst.lil 10h
041C85             1020*  
041C85             1021*  ; set b to be our loop counter
041C85 F1          1022*      pop af
041C86 47          1023*      ld b,a
041C87 E1          1024*      pop hl
041C88 E5          1025*      push hl
041C89 F5          1026*      push af
041C8A             1027*  @loop:
041C8A             1028*  ; print the byte
041C8A 7E          1029*      ld a,(hl)
041C8B CD 01 17 04 1030*      call printHex8
041C8F             1031*  ; print a space
041C8F 3E 20       1032*      ld a,' '
041C91 5B D7       1033*      rst.lil 10h
041C93 23          1034*      inc hl
041C94 10 F4       1035*      djnz @loop
041C96 CD E8 16 04 1036*      call printNewLine
041C9A             1037*  
041C9A             1038*  ; restore everything
041C9A F1          1039*      pop af
041C9B E1          1040*      pop hl
041C9C C1          1041*      pop bc
041C9D             1042*  
041C9D             1043*  ; all done
041C9D C9          1044*      ret
041C9E             1045*  
041C9E             1046*  
041C9E             1047*  ; print bytes from an address to the screen in binary format
041C9E             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041C9E             1049*  ; outputs: values of each byte printed to screen separated by spaces
041C9E             1050*  ; destroys: nothing
041C9E             1051*  dumpMemoryBin:
041C9E             1052*  ; save all registers to the stack
041C9E F5          1053*      push af
041C9F C5          1054*      push bc
041CA0 D5          1055*      push de
041CA1 E5          1056*      push hl
041CA2 DD E5       1057*      push ix
041CA4 FD E5       1058*      push iy
041CA6             1059*  
041CA6             1060*  ; set b to be our loop counter
041CA6 47          1061*      ld b,a
041CA7             1062*  @loop:
041CA7             1063*  ; print the byte
041CA7 7E          1064*      ld a,(hl)
041CA8 E5          1065*      push hl
041CA9 C5          1066*      push bc
041CAA CD 71 19 04 1067*      call printBin8
041CAE C1          1068*      pop bc
041CAF             1069*  ; print a space
041CAF 3E 20       1070*      ld a,' '
041CB1 5B D7       1071*      rst.lil 10h
041CB3 E1          1072*      pop hl
041CB4 23          1073*      inc hl
041CB5 10 F0       1074*      djnz @loop
041CB7 CD E8 16 04 1075*      call printNewLine
041CBB             1076*  
041CBB             1077*  ; restore everything
041CBB FD E1       1078*      pop iy
041CBD DD E1       1079*      pop ix
041CBF E1          1080*      pop hl
041CC0 D1          1081*      pop de
041CC1 C1          1082*      pop bc
041CC2 F1          1083*      pop af
041CC3             1084*  ; all done
041CC3 C9          1085*      ret
041CC4             1086*  
041CC4             1087*  ; print bytes from an address to the screen in binary format
041CC4             1088*  ; with the bits of each byte in reverse order (lsb first)
041CC4             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041CC4             1090*  ; outputs: values of each byte printed to screen separated by spaces
041CC4             1091*  ; destroys: nothing
041CC4             1092*  dumpMemoryBinRev:
041CC4             1093*  ; save all registers to the stack
041CC4 F5          1094*      push af
041CC5 C5          1095*      push bc
041CC6 D5          1096*      push de
041CC7 E5          1097*      push hl
041CC8 DD E5       1098*      push ix
041CCA FD E5       1099*      push iy
041CCC             1100*  
041CCC             1101*  ; set b to be our loop counter
041CCC 47          1102*      ld b,a
041CCD             1103*  @loop:
041CCD             1104*  ; print the byte
041CCD 7E          1105*      ld a,(hl)
041CCE E5          1106*      push hl
041CCF C5          1107*      push bc
041CD0 CD 96 19 04 1108*      call printBin8Rev
041CD4 C1          1109*      pop bc
041CD5             1110*  ; print a space
041CD5 3E 20       1111*      ld a,' '
041CD7 5B D7       1112*      rst.lil 10h
041CD9 E1          1113*      pop hl
041CDA 23          1114*      inc hl
041CDB 10 F0       1115*      djnz @loop
041CDD CD E8 16 04 1116*      call printNewLine
041CE1             1117*  
041CE1             1118*  ; restore everything
041CE1 FD E1       1119*      pop iy
041CE3 DD E1       1120*      pop ix
041CE5 E1          1121*      pop hl
041CE6 D1          1122*      pop de
041CE7 C1          1123*      pop bc
041CE8 F1          1124*      pop af
041CE9             1125*  ; all done
041CE9 C9          1126*      ret
041CEA             0053       include "vdu.inc"
041CEA             0001*  
041CEA             0002*  ; VDU 30: Home cursor
041CEA             0003*  vdu_home_cursor:
041CEA 3E 1E       0004*      ld a,30
041CEC 5B D7       0005*  	rst.lil $10
041CEE C9          0006*  	ret
041CEF             0007*  
041CEF             0008*  vdu_cursor_on:
041CEF 21 FA 1C 04 0009*  	ld hl,@cmd
041CF3 01 03 00 00 0010*  	ld bc,@end-@cmd
041CF7 5B DF       0011*  	rst.lil $18
041CF9 C9          0012*  	ret
041CFA             0013*  @cmd:
041CFA 17 01 01    0014*  	db 23,1,1
041CFD             0015*  @end:
041CFD             0016*  
041CFD             0017*  vdu_cursor_off:
041CFD 21 08 1D 04 0018*  	ld hl,@cmd
041D01 01 03 00 00 0019*  	ld bc,@end-@cmd
041D05 5B DF       0020*  	rst.lil $18
041D07 C9          0021*  	ret
041D08             0022*  @cmd:
041D08 17 01 00    0023*  	db 23,1,0
041D0B             0024*  @end:
041D0B             0025*  
041D0B             0026*  ; VDU 5: Write text at graphics cursor
041D0B             0027*  ; inputs: a is the character to write to the screen
041D0B             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041D0B             0029*  ; outputs: see the name of the function
041D0B             0030*  ; destroys: a, hl, bc
041D0B             0031*  vdu_char_to_gfx_cursor:
041D0B 32 1B 1D 04 0032*  	ld (@arg),a
041D0F 21 1A 1D 04 0033*  	ld hl,@cmd
041D13 01 02 00 00 0034*  	ld bc,@end-@cmd
041D17 5B DF       0035*  	rst.lil $18
041D19 C9          0036*  	ret
041D1A 05          0037*  @cmd: db 5
041D1B 00          0038*  @arg: db 0
041D1C             0039*  @end:
041D1C             0040*  ; VDU 9: Move cursor forward one character
041D1C             0041*  vdu_cursor_forward:
041D1C 3E 09       0042*      ld a,9
041D1E 5B D7       0043*  	rst.lil $10
041D20 C9          0044*  	ret
041D21             0045*  
041D21             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041D21             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041D21             0048*  vdu_move_cursor:
041D21 ED 43 32 1D 0049*      ld (@x0),bc
       04          
041D26 21 31 1D 04 0050*  	ld hl,@cmd
041D2A 01 03 00 00 0051*  	ld bc,@end-@cmd
041D2E 5B DF       0052*  	rst.lil $18
041D30 C9          0053*  	ret
041D31 1F          0054*  @cmd: 	db 31
041D32 00          0055*  @x0:	db 0
041D33 00          0056*  @y0: 	db 0
041D34 00          0057*  @end: 	db 0 ; padding
041D35             0058*  
041D35             0059*  ; VDU 12: Clear text area (CLS)
041D35             0060*  vdu_cls:
041D35 3E 0C       0061*      ld a,12
041D37 5B D7       0062*  	rst.lil $10
041D39 C9          0063*  	ret
041D3A             0064*  
041D3A             0065*  vdu_flip:
041D3A 21 45 1D 04 0066*  	ld hl,@cmd
041D3E 01 03 00 00 0067*  	ld bc,@end-@cmd
041D42 5B DF       0068*  	rst.lil $18
041D44 C9          0069*  	ret
041D45 17 00 C3    0070*  @cmd: db 23,0,0xC3
041D48             0071*  @end:
041D48             0072*  
041D48             0073*  ; VDU 16: Clear graphics area (CLG)
041D48             0074*  vdu_clg:
041D48 3E 10       0075*      ld a,16
041D4A 5B D7       0076*  	rst.lil $10
041D4C C9          0077*  	ret
041D4D             0078*  
041D4D             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041D4D             0080*  ; VDU 23, 7: Scrolling
041D4D             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041D4D             0082*  ; inputs: a, extent; l, direction; h; speed
041D4D             0083*  vdu_scroll_down:
041D4D 32 62 1D 04 0084*  	ld (@extent),a
041D51 22 63 1D 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041D55 21 60 1D 04 0086*  	ld hl,@cmd
041D59 01 05 00 00 0087*  	ld bc,@end-@cmd
041D5D 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041D5F C9          0089*  	ret
041D60 17 07       0090*  @cmd:       db 23,7
041D62 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041D63 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041D64 00          0093*  @speed:     db 0x00 ; pixels
041D65 00          0094*  @end:		db 0x00 ; padding
041D66             0095*  
041D66             0096*  ; COLOUR MODES
041D66             0097*  ; Mode	Effect
041D66             0098*  ; 0	Set on-screen pixel to target colour value
041D66             0099*  ; 1	OR value with the on-screen pixel
041D66             0100*  ; 2	AND value with the on-screen pixel
041D66             0101*  ; 3	XOR value with the on-screen pixel
041D66             0102*  ; 4	Invert the on-screen pixel
041D66             0103*  ; 5	No operation
041D66             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041D66             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041D66             0106*  
041D66             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041D66             0108*  vdu_colour_text:
041D66 32 76 1D 04 0109*  	ld (@arg),a
041D6A 21 75 1D 04 0110*  	ld hl,@cmd
041D6E 01 02 00 00 0111*  	ld bc,@end-@cmd
041D72 5B DF       0112*  	rst.lil $18
041D74 C9          0113*  	ret
041D75 11          0114*  @cmd: db 17
041D76 00          0115*  @arg: db 0
041D77             0116*  @end:
041D77             0117*  
041D77             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041D77             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041D77             0120*  vdu_gcol:
041D77 32 8C 1D 04 0121*  	ld (@mode),a
041D7B 79          0122*      ld a,c
041D7C 32 8D 1D 04 0123*      ld (@col),a
041D80 21 8B 1D 04 0124*  	ld hl,@cmd
041D84 01 03 00 00 0125*  	ld bc,@end-@cmd
041D88 5B DF       0126*  	rst.lil $18
041D8A C9          0127*  	ret
041D8B 12          0128*  @cmd:  db 18
041D8C 00          0129*  @mode: db 0
041D8D 00          0130*  @col:  db 0
041D8E             0131*  @end:
041D8E             0132*  
041D8E             0133*  
041D8E             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041D8E             0135*  ; MIND THE LITTLE-ENDIANESS
041D8E             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041D8E             0137*  ; outputs; nothing
041D8E             0138*  ; destroys: a might make it out alive
041D8E             0139*  vdu_set_txt_viewport:
041D8E ED 43 A4 1D 0140*      ld (@lb),bc
       04          
041D93 ED 53 A6 1D 0141*  	ld (@rt),de
       04          
041D98 21 A3 1D 04 0142*  	ld hl,@cmd
041D9C 01 05 00 00 0143*  	ld bc,@end-@cmd
041DA0 5B DF       0144*  	rst.lil $18
041DA2 C9          0145*  	ret
041DA3 1C          0146*  @cmd:   db 28 ; set text viewport command
041DA4 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041DA6 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041DA8 00          0149*  @end:   db 0x00	  ; padding
041DA9             0150*  
041DA9             0151*  ; Wait for VBLANK interrupt
041DA9             0152*  vdu_vblank:
041DA9 DD E5       0153*      PUSH 	IX
041DAB             0154*  	MOSCALL	mos_sysvars
041DAB 3E 08       0001*M 			LD	A, function
041DAD 5B CF       0002*M 			RST.LIL	08h
041DAF DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041DB2             0156*  @wait:
041DB2 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041DB5 28 FB       0158*      JR	Z, @wait
041DB7 DD E1       0159*      POP	IX
041DB9 C9          0160*      RET
041DBA             0161*  
041DBA             0162*  ; VDU 29, x; y;: Set graphics origin
041DBA             0163*  ; This command sets the graphics origin.
041DBA             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041DBA             0165*  ; inputs: bc=x0,de=y0
041DBA             0166*  ; outputs; nothing
041DBA             0167*  ; destroys: a might make it out alive
041DBA             0168*  vdu_set_gfx_origin:
041DBA ED 43 D0 1D 0169*      ld (@x0),bc
       04          
041DBF ED 53 D2 1D 0170*      ld (@y0),de
       04          
041DC4 21 CF 1D 04 0171*      ld hl,@cmd
041DC8 01 05 00 00 0172*      ld bc,@end-@cmd
041DCC 5B DF       0173*      rst.lil $18
041DCE C9          0174*      ret
041DCF 1D          0175*  @cmd:   db 29 ; set graphics origin command
041DD0 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041DD2 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041DD4 00          0178*  @end:   db 0x00	  ; padding
041DD5             0179*  
041DD5             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041DD5             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041DD5             0182*  ; 	because we have turned off logical screen scaling
041DD5             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041DD5             0184*  ; outputs; nothing
041DD5             0185*  ; destroys: a might make it out alive
041DD5             0186*  vdu_set_gfx_viewport:
041DD5 ED 43 F5 1D 0187*      ld (@x0),bc
       04          
041DDA FD 22 F7 1D 0188*      ld (@y1),iy
       04          
041DDF DD 22 F9 1D 0189*  	ld (@x1),ix
       04          
041DE4 ED 53 FB 1D 0190*  	ld (@y0),de
       04          
041DE9 21 F4 1D 04 0191*  	ld hl,@cmd
041DED 01 09 00 00 0192*  	ld bc,@end-@cmd
041DF1 5B DF       0193*  	rst.lil $18
041DF3 C9          0194*  	ret
041DF4 18          0195*  @cmd:   db 24 ; set graphics viewport command
041DF5 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041DF7 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041DF9 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041DFB 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041DFD 00          0200*  @end:   db 0x00	  ; padding
041DFE             0201*  
041DFE             0202*  ; SCREEN MODES
041DFE             0203*  ; ===============================
041DFE             0204*  ; Mode  Horz  Vert  Cols  Refresh
041DFE             0205*  ; ---   ----  ----  ----  -------
041DFE             0206*  ; 11    320   240   2     60hz
041DFE             0207*  ; 139   320   240   2     60hz
041DFE             0208*  ; 23    512   384   2     60hz
041DFE             0209*  ; 151   512   384   2     60hz
041DFE             0210*  ; 6     640   240   2     60hz
041DFE             0211*  ; 134   640   240   2     60hz
041DFE             0212*  ; 2     640   480   2     60hz
041DFE             0213*  ; 130   640   480   2     60hz
041DFE             0214*  ; 17    800   600   2     60hz
041DFE             0215*  ; 145   800   600   2     60hz
041DFE             0216*  ; 18    1024  768   2     60hz
041DFE             0217*  ; 146   1024  768   2     60hz
041DFE             0218*  ; ---   ----  ----  ----  -------
041DFE             0219*  ; 10    320   240   4     60hz
041DFE             0220*  ; 138   320   240   4     60hz
041DFE             0221*  ; 22    512   384   4     60hz
041DFE             0222*  ; 150   512   384   4     60hz
041DFE             0223*  ; 5     640   240   4     60hz
041DFE             0224*  ; 133   640   240   4     60hz
041DFE             0225*  ; 1     640   480   4     60hz
041DFE             0226*  ; 129   640   480   4     60hz
041DFE             0227*  ; 16    800   600   4     60hz
041DFE             0228*  ; 19    1024  768   4     60hz
041DFE             0229*  ; ---   ----  ----  ----  -------
041DFE             0230*  ; 9     320   240   16    60hz
041DFE             0231*  ; 137   320   240   16    60hz
041DFE             0232*  ; 21    512   384   16    60hz
041DFE             0233*  ; 149   512   384   16    60hz
041DFE             0234*  ; 4     640   240   16    60hz
041DFE             0235*  ; 132   640   240   16    60hz
041DFE             0236*  ; 0     640   480   16    60hz
041DFE             0237*  ; 7     n/a   n/a   16    60hz
041DFE             0238*  ; ---   ----  ----  ----  -------
041DFE             0239*  ; 8     320   240   64    60hz
041DFE             0240*  ; 136   320   240   64    60hz
041DFE             0241*  ; 20    512   384   64    60hz
041DFE             0242*  ; 3     640   240   64    60hz
041DFE             0243*  ; ---   ----  ----  ----  -------
041DFE             0244*  vdu_set_screen_mode:
041DFE 32 0E 1E 04 0245*  	ld (@arg),a
041E02 21 0D 1E 04 0246*  	ld hl,@cmd
041E06 01 02 00 00 0247*  	ld bc,@end-@cmd
041E0A 5B DF       0248*  	rst.lil $18
041E0C C9          0249*  	ret
041E0D 16          0250*  @cmd: db 22 ; set screen mode
041E0E 00          0251*  @arg: db 0  ; screen mode parameter
041E0F             0252*  @end:
041E0F             0253*  
041E0F             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041E0F             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041E0F             0256*  ; note: default setting on boot is scaling ON
041E0F             0257*  vdu_set_scaling:
041E0F 32 21 1E 04 0258*  	ld (@arg),a
041E13 21 1E 1E 04 0259*  	ld hl,@cmd
041E17 01 04 00 00 0260*  	ld bc,@end-@cmd
041E1B 5B DF       0261*  	rst.lil $18
041E1D C9          0262*  	ret
041E1E 17 00 C0    0263*  @cmd: db 23,0,0xC0
041E21 00          0264*  @arg: db 0  ; scaling on/off
041E22             0265*  @end:
041E22             0266*  
041E22             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041E22             0268*  ; inputs: hl=bufferId
041E22             0269*  vdu_buff_select:
041E22 22 34 1E 04 0270*  	ld (@bufferId),hl
041E26 21 31 1E 04 0271*  	ld hl,@cmd
041E2A 01 05 00 00 0272*  	ld bc,@end-@cmd
041E2E 5B DF       0273*  	rst.lil $18
041E30 C9          0274*  	ret
041E31 17 1B 20    0275*  @cmd: db 23,27,0x20
041E34 00 00       0276*  @bufferId: dw 0x0000
041E36 00          0277*  @end: db 0x00 ; padding
041E37             0278*  
041E37             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041E37             0280*  ; inputs: a=format; bc=width; de=height
041E37             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041E37             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041E37             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041E37             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041E37             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041E37             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041E37             0287*  vdu_bmp_create:
041E37 ED 43 53 1E 0288*      ld (@width),bc
       04          
041E3C ED 53 55 1E 0289*      ld (@height),de
       04          
041E41 32 57 1E 04 0290*      ld (@fmt),a
041E45 21 50 1E 04 0291*  	ld hl,@cmd
041E49 01 08 00 00 0292*  	ld bc,@end-@cmd
041E4D 5B DF       0293*  	rst.lil $18
041E4F C9          0294*  	ret
041E50 17 1B 21    0295*  @cmd:       db 23,27,0x21
041E53 00 00       0296*  @width:     dw 0x0000
041E55 00 00       0297*  @height:    dw 0x0000
041E57 00          0298*  @fmt:       db 0x00
041E58             0299*  @end:
041E58             0300*  
041E58             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041E58             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041E58             0303*  vdu_load_img_rgba2_to_8:
041E58             0304*  ; backup the target buffer id and image dimensions
041E58 E5          0305*      push hl
041E59 D5          0306*      push de
041E5A C5          0307*      push bc
041E5B             0308*  ; load the rgba2 image to working buffer 65534
041E5B 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041E5F CD 62 1F 04 0310*  	call vdu_load_buffer_from_file
041E63             0311*  ; restore the image dimensions and target buffer id
041E63 C1          0312*      pop bc
041E64 D1          0313*      pop de
041E65 E1          0314*      pop hl
041E66             0315*  ; fall through to vdu_rgba2_to_8
041E66             0316*  
041E66             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041E66             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041E66             0319*  ; the "expand bitmap" command is:
041E66             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041E66             0321*  ; and then to reverse the byte order to fix endian-ness:
041E66             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041E66             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041E66             0324*  ; VDU 23,27,&20,targetBufferID%;
041E66             0325*  ; VDU 23,27,&21,width%;height%;0
041E66             0326*  ; -------------------------------------------------------------------
041E66             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041E66             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041E66             0329*  vdu_rgba2_to_8:
041E66             0330*  ; load the image dimensions and buffer id parameters
041E66 ED 43 C2 1E 0331*      ld (@width),bc
       04          
041E6B ED 53 C4 1E 0332*      ld (@height),de
       04          
041E70 22 A7 1E 04 0333*      ld (@bufferId0),hl
041E74 22 B4 1E 04 0334*      ld (@bufferId2),hl
041E78 22 BD 1E 04 0335*      ld (@bufferId1),hl
041E7C             0336*  ; clean up bytes that got stomped on by the ID loads
041E7C 3E 48       0337*      ld a,0x48
041E7E 32 A9 1E 04 0338*      ld (@bufferId0+2),a
041E82 3E 17       0339*      ld a,23
041E84 32 BF 1E 04 0340*      ld (@bufferId1+2),a
041E88 3E 18       0341*      ld a,24
041E8A 32 B6 1E 04 0342*      ld (@bufferId2+2),a
041E8E AF          0343*      xor a
041E8F 32 C6 1E 04 0344*      ld (@height+2),a
041E93             0345*  ; send the vdu command strings
041E93 21 9E 1E 04 0346*      ld hl,@beg
041E97 01 29 00 00 0347*      ld bc,@end-@beg
041E9B 5B DF       0348*      rst.lil $18
041E9D C9          0349*      ret
041E9E             0350*  @beg:
041E9E             0351*  ; Command 14: Consolidate blocks in a buffer
041E9E             0352*  ; VDU 23, 0, &A0, bufferId; 14
041E9E 17 00 A0    0353*      db 23,0,0xA0
041EA1 FE FF       0354*      dw 65534 ; workingBufferId
041EA3 0E          0355*      db 14 ; consolidate blocks
041EA4             0356*  ; the "expand bitmap" command is:
041EA4             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041EA4 17 00 A0    0358*      db 23,0,0xA0
041EA7 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041EA9 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041EAA 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041EAB FE FF       0362*      dw 65534 ; sourceBufferId
041EAD 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041EB1             0364*  ; reverse the byte order to fix endian-ness:
041EB1             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041EB1             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041EB1             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041EB1 17 00 A0    0368*      db 23,0,0xA0
041EB4 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041EB6 18          0370*      db 24 ; reverse byte order
041EB7 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041EB8 04 00       0372*      dw 4 ; size (4 bytes)
041EBA             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041EBA             0374*  ; VDU 23,27,&20,targetBufferID%;
041EBA 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041EBD 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041EBF             0377*  ; VDU 23,27,&21,width%;height%;0
041EBF 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041EC2 00 00       0379*  @width: dw 0x0000
041EC4 00 00       0380*  @height: dw 0x0000
041EC6 00          0381*      db 0x00 ; rgba8888 format
041EC7             0382*  @end:
041EC7             0383*  
041EC7             0384*  ; scratch variables
041EC7 00 00 00    0385*  bufferId0: dl 0x000000
041ECA 00 00 00    0386*  bufferId1: dl 0x000000
041ECD             0387*  
041ECD             0388*  ; load a vdu buffer from local memory
041ECD             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041ECD             0390*  vdu_load_buffer:
041ECD ED 43 F6 1E 0391*      ld (@length),bc
       04          
041ED2 D5          0392*      push de ; save data pointer
041ED3             0393*  ; send the vdu command string
041ED3 7D          0394*      ld a,l
041ED4 32 F3 1E 04 0395*      ld (@bufferId),a
041ED8 7C          0396*      ld a,h
041ED9 32 F4 1E 04 0397*      ld (@bufferId+1),a
041EDD 21 F0 1E 04 0398*      ld hl,@cmd
041EE1 01 08 00 00 0399*      ld bc,@end-@cmd
041EE5 5B DF       0400*      rst.lil $18
041EE7             0401*  ; send the buffer data
041EE7 E1          0402*      pop hl ; pointer to data
041EE8 ED 4B F6 1E 0403*      ld bc,(@length)
       04          
041EED 5B DF       0404*      rst.lil $18 ; send it
041EEF C9          0405*      ret
041EF0             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041EF0 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041EF3 00 00       0408*  @bufferId:	dw 0x0000
041EF5 00          0409*  		    db 0 ; load buffer
041EF6 00 00       0410*  @length:	dw 0x0000
041EF8 00          0411*  @end: db 0 ; padding
041EF9             0412*  
041EF9             0413*  ; clear a buffer
041EF9             0414*  ; inputs: hl = bufferId
041EF9             0415*  vdu_clear_buffer:
041EF9 7D          0416*      ld a,l
041EFA 32 11 1F 04 0417*      ld (@bufferId),a
041EFE 7C          0418*      ld a,h
041EFF 32 12 1F 04 0419*      ld (@bufferId+1),a
041F03 21 0E 1F 04 0420*      ld hl,@cmd
041F07 01 06 00 00 0421*      ld bc,@end-@cmd
041F0B 5B DF       0422*      rst.lil $18
041F0D C9          0423*      ret
041F0E 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041F11 00 00       0425*  @bufferId:	dw 0x0000
041F13 02          0426*  		    db 2 ; clear buffer
041F14             0427*  @end:
041F14             0428*  
041F14             0429*  vdu_clear_all_buffers:
041F14             0430*  ; clear all buffers
041F14 21 1F 1F 04 0431*      ld hl,@beg
041F18 01 06 00 00 0432*      ld bc,@end-@beg
041F1C 5B DF       0433*      rst.lil $18
041F1E C9          0434*      ret
041F1F 17 00 A0    0435*  @beg: db 23,0,$A0
041F22 FF FF       0436*        dw -1 ; clear all buffers
041F24 02          0437*        db 2  ; command 2: clear a buffer
041F25             0438*  @end:
041F25             0439*  
041F25             0440*  ; Command 14: Consolidate blocks in a buffer
041F25             0441*  vdu_consolidate_buffer:
041F25             0442*  ; set parameters for vdu call
041F25 7D          0443*      ld a,l
041F26 32 3D 1F 04 0444*      ld (@bufferId),a
041F2A 7C          0445*      ld a,h
041F2B 32 3E 1F 04 0446*      ld (@bufferId+1),a
041F2F 21 3A 1F 04 0447*      ld hl,@beg
041F33 01 06 00 00 0448*      ld bc,@end-@beg
041F37 5B DF       0449*      rst.lil $18
041F39 C9          0450*      ret
041F3A             0451*  ; VDU 23, 0, &A0, bufferId; 14
041F3A 17 00 A0    0452*  @beg: db 23,0,0xA0
041F3D 00 00       0453*  @bufferId: dw 0x0000
041F3F 0E          0454*             db 14
041F40             0455*  @end:
041F40             0456*  
041F40             0457*  ; load an image file to a buffer and make it a bitmap
041F40             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041F40             0459*  vdu_load_img:
041F40             0460*  ; back up image type and dimension parameters
041F40 22 C7 1E 04 0461*      ld (bufferId0),hl
041F44 F5          0462*      push af
041F45 C5          0463*  	push bc
041F46 D5          0464*  	push de
041F47             0465*  ; load the image
041F47 CD 62 1F 04 0466*  	call vdu_load_buffer_from_file
041F4B             0467*  ; now make it a bitmap
041F4B 2A C7 1E 04 0468*      ld hl,(bufferId0)
041F4F CD 25 1F 04 0469*      call vdu_consolidate_buffer
041F53 2A C7 1E 04 0470*      ld hl,(bufferId0)
041F57 CD 22 1E 04 0471*      call vdu_buff_select
041F5B D1          0472*  	pop de ; image height
041F5C C1          0473*  	pop bc ; image width
041F5D F1          0474*  	pop af ; image type
041F5E C3 37 1E 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041F62             0476*  
041F62             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041F62             0478*  vdu_load_buffer_from_file:
041F62 22 C7 1E 04 0479*      ld (bufferId0),hl
041F66             0480*  
041F66             0481*  ; clear target buffer
041F66 CD F9 1E 04 0482*      call vdu_clear_buffer
041F6A             0483*  
041F6A             0484*  ; open the file in read mode
041F6A             0485*  ; Open a file
041F6A             0486*  ; HLU: Filename
041F6A             0487*  ;   C: Mode
041F6A             0488*  ; Returns:
041F6A             0489*  ;   A: Filehandle, or 0 if couldn't open
041F6A FD E5       0490*  	push iy ; pointer to filename
041F6C E1          0491*  	pop hl
041F6D 0E 01       0492*  	ld c,fa_read
041F6F             0493*      MOSCALL mos_fopen
041F6F 3E 0A       0001*M 			LD	A, function
041F71 5B CF       0002*M 			RST.LIL	08h
041F73 32 AE 1F 04 0494*      ld (@filehandle),a
041F77             0495*  
041F77             0496*  @read_file:
041F77             0497*  ; Read a block of data from a file
041F77             0498*  ;   C: Filehandle
041F77             0499*  ; HLU: Pointer to where to write the data to
041F77             0500*  ; DEU: Number of bytes to read
041F77             0501*  ; Returns:
041F77             0502*  ; DEU: Number of bytes read
041F77 3A AE 1F 04 0503*      ld a,(@filehandle)
041F7B 4F          0504*      ld c,a
041F7C 21 00 E0 B7 0505*      ld hl,filedata
041F80 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041F84             0507*      MOSCALL mos_fread
041F84 3E 1A       0001*M 			LD	A, function
041F86 5B CF       0002*M 			RST.LIL	08h
041F88             0508*  
041F88             0509*  ; test de for zero bytes read
041F88 21 00 00 00 0510*      ld hl,0
041F8C AF          0511*      xor a ; clear carry
041F8D ED 52       0512*      sbc hl,de
041F8F CA A5 1F 04 0513*      jp z,@close_file
041F93             0514*  
041F93             0515*  ; load a vdu buffer from local memory
041F93             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041F93 2A C7 1E 04 0517*      ld hl,(bufferId0)
041F97 D5          0518*      push de ; chunksize
041F98 C1          0519*      pop bc
041F99 11 00 E0 B7 0520*      ld de,filedata
041F9D CD CD 1E 04 0521*      call vdu_load_buffer
041FA1             0522*  
041FA1             0523*  ; read the next block
041FA1 C3 77 1F 04 0524*      jp @read_file
041FA5             0525*  
041FA5             0526*  ; close the file
041FA5             0527*  @close_file:
041FA5 3A AE 1F 04 0528*      ld a,(@filehandle)
041FA9             0529*      MOSCALL mos_fclose
041FA9 3E 0B       0001*M 			LD	A, function
041FAB 5B CF       0002*M 			RST.LIL	08h
041FAD C9          0530*      ret ; vdu_load_buffer_from_file
041FAE             0531*  
041FAE 00          0532*  @filehandle: db 0 ; file handle
041FAF 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
041FB2             0534*  
041FB2 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
041FB5             0536*  
041FB5             0537*  ; File information structure (FILINFO)
041FB5             0538*  @filinfo:
041FB5 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041FB9 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041FBB 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041FBD 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041FBE 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041FCB 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0420CB             0054       include "vdu_buff.inc"
0420CB             0001*  ; VDP Buffered Commands API
0420CB             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
0420CB             0003*  
0420CB             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420CB             0005*  ; This command is used to store a data block (a sequence of bytes)
0420CB             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
0420CB             0007*  ; It could be a sequence of VDU commands which can be executed
0420CB             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
0420CB             0009*  ; When used for a sequence of VDU commands, this effectively
0420CB             0010*  ; allows for functions or stored procedures to be created.
0420CB             0011*  
0420CB             0012*  ; This is the most common command to use to send data to the VDP.
0420CB             0013*  ; Typically you will call command 2 first to ensure that the
0420CB             0014*  ; buffer is empty, and then make a series of calls to this command
0420CB             0015*  ; to send data to the buffer.
0420CB             0016*  
0420CB             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
0420CB             0018*  ; write to. Writing to the same buffer ID multiple times will add
0420CB             0019*  ; new blocks to that buffer. This allows a buffer to be built up
0420CB             0020*  ; over time, essentially allowing for a command to be sent across
0420CB             0021*  ; to the VDP in multiple separate packets.
0420CB             0022*  
0420CB             0023*  ; Whilst the length of an individual block added using this command
0420CB             0024*  ; is restricted to 65535 bytes (as the largest value that can be
0420CB             0025*  ; sent in a 16-bit number) the total size of a buffer is not
0420CB             0026*  ; restricted to this size, as multiple blocks can be added to a
0420CB             0027*  ; buffer. Given how long it takes to send data to the VDP it is
0420CB             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
0420CB             0029*  ; data or less at a time.
0420CB             0030*  
0420CB             0031*  ; As writing to a single buffer ID is cumulative with this command,
0420CB             0032*  ; care should be taken to ensure that the buffer is cleared out
0420CB             0033*  ; before writing to it.
0420CB             0034*  
0420CB             0035*  ; When building up a complex sequence of commands it is often
0420CB             0036*  ; advisable to use multiple blocks within a buffer. Typically
0420CB             0037*  ; this is easier to code, as otherwise working out exactly how
0420CB             0038*  ; many bytes long a command sequence is can be can be onerously
0420CB             0039*  ; difficult. It is also easier to modify a command sequences that
0420CB             0040*  ; are broken up into multiple blocks.
0420CB             0041*  
0420CB             0042*  ; As mentioned above it is advisable to send large pieces of data,
0420CB             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
0420CB             0044*  ; each packet of data sent to a buffer, the user can then perform
0420CB             0045*  ; other operations, such as updating the screen to indicate
0420CB             0046*  ; progress. This allows for long-running operations to be performed
0420CB             0047*  ; without blocking the screen, and larger amounts of data to be
0420CB             0048*  ; transferred over to the VDP than may otherwise be practical given
0420CB             0049*  ; the limitations of the eZ80.
0420CB             0050*  
0420CB             0051*  ; If a buffer ID of 65535 is used then this command will be
0420CB             0052*  ; ignored, and the data discarded. This is because this buffer ID
0420CB             0053*  ; is reserved for special functions.
0420CB             0054*  
0420CB             0055*  ; Using buffers for bitmaps
0420CB             0056*  
0420CB             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
0420CB             0058*  ; they cannot be used if they are spread over multiple blocks.
0420CB             0059*  ; To use a bitmap its data must be in a single contiguous block,
0420CB             0060*  ; and this is achieved by using the “consolidate” command &0E.
0420CB             0061*  
0420CB             0062*  ; Once you have a block that is ready to be used for a bitmap,
0420CB             0063*  ; the buffer must be selected, and then a bitmap created for that
0420CB             0064*  ; buffer using the bitmap and sprites API. This is done with the
0420CB             0065*  ; following commands:
0420CB             0066*  
0420CB             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
0420CB             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
0420CB             0069*  
0420CB             0070*  ; Until the “create bitmap” call has been made the buffer cannot
0420CB             0071*  ; be used as a bitmap. That is because the system needs to
0420CB             0072*  ; understand the dimensions of the bitmap, as well as the format
0420CB             0073*  ; of the data. Usually this only needs to be done once. The format
0420CB             0074*  ; is given as an 8-bit value, with the following values supported:
0420CB             0075*  ; Value 	Type 	Description
0420CB             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
0420CB             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
0420CB             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
0420CB             0079*  
0420CB             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
0420CB             0081*  ; and these are automatically stored in buffers numbered 64000-64255
0420CB             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
0420CB             0083*  ; simply a matter of adding 64000. All bitmaps created with that
0420CB             0084*  ; API will be RGBA8888 format.
0420CB             0085*  
0420CB             0086*  ; There is one other additional call added to the bitmap and
0420CB             0087*  ; sprites API, which allows for bitmaps referenced with a
0420CB             0088*  ; buffer ID to be added to sprites. This is done with the
0420CB             0089*  ; following command:
0420CB             0090*  
0420CB             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
0420CB             0092*  
0420CB             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
0420CB             0094*  
0420CB             0095*  ; It should be noted that it is possible to modify the buffer
0420CB             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
0420CB             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
0420CB             0098*  ; can allow you to do things such as changing colours in a bitmap,
0420CB             0099*  ; or flipping an image horizontally or vertically. This will even
0420CB             0100*  ; work on bitmaps that are being used inside sprites.
0420CB             0101*  
0420CB             0102*  ; Using commands targetting a buffer that create new blocks,
0420CB             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
0420CB             0104*  ; and remove it from use.
0420CB             0105*  
0420CB             0106*  ; Using buffers for sound samples
0420CB             0107*  
0420CB             0108*  ; Much like with bitmaps, it is advisable to send samples over
0420CB             0109*  ; to the VDP in multiple blocks for the same reasons.
0420CB             0110*  
0420CB             0111*  ; In contrast to bitmaps, the sound system can play back samples
0420CB             0112*  ; that are spread over multiple blocks, so there is no need to
0420CB             0113*  ; consolidate buffers. As a result of this, the sample playback
0420CB             0114*  ; system is also more tolerant of modifications being made to
0420CB             0115*  ; the buffer after a sample has been created from it, even if
0420CB             0116*  ; the sample is currently playing. It should be noted that
0420CB             0117*  ; splitting a buffer may result in unexpected behaviour if
0420CB             0118*  ; the sample is currently playing, such as skipping to other
0420CB             0119*  ; parts of the sample.
0420CB             0120*  
0420CB             0121*  ; Once you have a buffer that contains block(s) that are ready
0420CB             0122*  ; to be used for a sound sample, the following command must be
0420CB             0123*  ; used to indicate that a sample should be created from that buffer:
0420CB             0124*  
0420CB             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
0420CB             0126*  
0420CB             0127*  ; The format parameter is an 8-bit value that indicates the
0420CB             0128*  ; format of the sample data. The following values are supported:
0420CB             0129*  ; Value 	Description
0420CB             0130*  ; 0 	8-bit signed, 16KHz
0420CB             0131*  ; 1 	8-bit unsigned, 16KHz
0420CB             0132*  
0420CB             0133*  ; Once a sample has been created in this way, the sample can
0420CB             0134*  ; be selected for use on a channel using the following command:
0420CB             0135*  
0420CB             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
0420CB             0137*  
0420CB             0138*  ; Samples uploaded using the existing “load sample” command
0420CB             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
0420CB             0140*  ; are also stored in buffers automatically. A sample number using this system is in
0420CB             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
0420CB             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
0420CB             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
0420CB             0144*  ; buffer 64257, and so on.
0420CB             0145*  ; Command 1: Call a buffer
0420CB             0146*  
0420CB             0147*  ; VDU 23, 0 &A0, bufferId; 1
0420CB             0148*  
0420CB             0149*  ; This command will attempt to execute all of the commands
0420CB             0150*  ; stored in the buffer with the given ID. If the buffer does
0420CB             0151*  ; not exist, or is empty, then this command will do nothing.
0420CB             0152*  
0420CB             0153*  ; Essentially, this command passes the contents of the buffer
0420CB             0154*  ; to the VDP’s VDU command processor system, and executes them
0420CB             0155*  ; as if they were sent directly to the VDP.
0420CB             0156*  
0420CB             0157*  ; As noted against command 0, it is possible to build up a
0420CB             0158*  ; buffer over time by sending across multiple commands to write
0420CB             0159*  ; to the same buffer ID. When calling a buffer with multiple
0420CB             0160*  ; blocks, the blocks are executed in order.
0420CB             0161*  
0420CB             0162*  ; Care should be taken when using this command within a buffer,
0420CB             0163*  ; as it is possible to create an infinite loop. For instance,
0420CB             0164*  ; if a buffer contains a command to call itself, then this will
0420CB             0165*  ; result in an infinite loop. This will cause the VDP to hang,
0420CB             0166*  ; and the only way to recover from this is to reset the VDP.
0420CB             0167*  
0420CB             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
0420CB             0169*  ; to be executed. This can be useful for creating loops within
0420CB             0170*  ; a buffer. It will be ignored if used outside of a buffered
0420CB             0171*  ; command sequence.
0420CB             0172*  
0420CB             0173*  ; Command 2: Clear a buffer
0420CB             0174*  ; VDU 23, 0 &A0, bufferId; 2
0420CB             0175*  
0420CB             0176*  ; This command will clear the buffer with the given ID. If
0420CB             0177*  ; the buffer does not exist then this command will do nothing.
0420CB             0178*  
0420CB             0179*  ; Please note that this clears out all of the blocks sent to
0420CB             0180*  ; a buffer via command 0, not just the last one. i.e. if you
0420CB             0181*  ; have built up a buffer over time by sending multiple commands
0420CB             0182*  ; to write to the same buffer ID, this command will clear out
0420CB             0183*  ; all of those commands.
0420CB             0184*  
0420CB             0185*  ; Calling this command with a bufferId value of -1 (65535) will
0420CB             0186*  ; clear out all buffers.
0420CB             0187*  
0420CB             0188*  ; Command 3: Create a writeable buffer
0420CB             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
0420CB             0190*  ; This command will create a new writeable buffer with the given
0420CB             0191*  ; ID. If a buffer with the given ID already exists then this
0420CB             0192*  ; command will do nothing. This command is primarily intended
0420CB             0193*  ; for use to create a buffer that can be used to capture output
0420CB             0194*  ; using the “set output stream” command (see below), or to store
0420CB             0195*  ; data that can be used for other commands.
0420CB             0196*  
0420CB             0197*  ; It is generally quite rare that you will want to use this
0420CB             0198*  ; command. Typically you will instead want to use command 0
0420CB             0199*  ; to write data to a buffer. It is not necessary to use this
0420CB             0200*  ; command before using command 0, and indeed doing so will
0420CB             0201*  ; lead to errors as you will end up with two blocks in the
0420CB             0202*  ; buffer, the first of which will be empty. If you do wish
0420CB             0203*  ; to use this command to create a buffer for data and then
0420CB             0204*  ; write to it, you would need to use operation 2 of command 5,
0420CB             0205*  ; the “set” operation in the “buffer adjust” command, to set a
0420CB             0206*  ; sequence of bytes in the buffer to the data you want to write.
0420CB             0207*  ; This is not recommended, as it is much easier to just use
0420CB             0208*  ; command 0 to write a data block to a buffer.
0420CB             0209*  
0420CB             0210*  ; This new buffer will be a single empty single block upon
0420CB             0211*  ; creation, containing zeros.
0420CB             0212*  
0420CB             0213*  ; The length parameter is a 16-bit integer that specifies
0420CB             0214*  ; the maximum size of the buffer. This is the maximum number
0420CB             0215*  ; of bytes that can be stored in the buffer. If the buffer
0420CB             0216*  ; is full then no more data can be written to it, and subsequent
0420CB             0217*  ; writes will be ignored.
0420CB             0218*  
0420CB             0219*  ; After creating a buffer with this command it is possible to
0420CB             0220*  ; use command 0 to write further blocks to the buffer, however
0420CB             0221*  ; this is probably not advisable.
0420CB             0222*  
0420CB             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
0420CB             0224*  ; values have special meanings for writable buffers. See command 4.
0420CB             0225*  
0420CB             0226*  ; Command 4: Set output stream to a buffer
0420CB             0227*  ; VDU 23, 0 &A0, bufferId; 4
0420CB             0228*  
0420CB             0229*  ; Sets then current output stream to the buffer with the given ID.
0420CB             0230*  ; With two exceptions, noted below, this needs to be a writable
0420CB             0231*  ; buffer created with command 3. If the buffer does not exist,
0420CB             0232*  ; or the first block within the buffer is not writable, then
0420CB             0233*  ; this command will do nothing.
0420CB             0234*  
0420CB             0235*  ; Following this command, any subsequent VDU commands that send
0420CB             0236*  ; response packets will have those packets written to the specified
0420CB             0237*  ; output buffer. This allows the user to capture the response
0420CB             0238*  ; packets from a command sent to the VDP.
0420CB             0239*  
0420CB             0240*  ; By default, the output stream (for the main VDU command processor)
0420CB             0241*  ; is the communications channel from the VDP to MOS running on the
0420CB             0242*  ; eZ80.
0420CB             0243*  
0420CB             0244*  ; Passing a buffer ID of -1 (65535) to this command will
0420CB             0245*  ; remove/detach the output buffer. From that point onwards,
0420CB             0246*  ; any subsequent VDU commands that send response packets will
0420CB             0247*  ; have those responses discarded/ignored.
0420CB             0248*  
0420CB             0249*  ; Passing a buffer ID of 0 to this command will set the output
0420CB             0250*  ; buffer back to its original value for the current command stream.
0420CB             0251*  ; Typically that will be the communications channel from the VDP to
0420CB             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
0420CB             0253*  ; call has been made.
0420CB             0254*  
0420CB             0255*  ; When used inside a buffered command sequence, this command will
0420CB             0256*  ; only affect the output stream for that sequence of commands, and
0420CB             0257*  ; any other buffered command sequences that are called from within
0420CB             0258*  ; that sequence. Once the buffered command sequence has completed,
0420CB             0259*  ; the output stream will effectively be reset to its original value.
0420CB             0260*  
0420CB             0261*  ; It is strongly recommended to only use this command from within a
0420CB             0262*  ; buffered command sequence. Whilst it is possible to use this
0420CB             0263*  ; command from within a normal VDU command sequence, it is not
0420CB             0264*  ; recommended as it may cause unexpected behaviour. If you do use
0420CB             0265*  ; it in that context, it is very important to remember to restore
0420CB             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
0420CB             0267*  ; future, this command may be disabled from being used outside of
0420CB             0268*  ; a buffered command sequence.)
0420CB             0269*  
0420CB             0270*  ; At present, writable buffers can only be written to until the end
0420CB             0271*  ; of the buffer has been reached; once that happens no more data
0420CB             0272*  ; will be written to the buffer. It is not currently possible to
0420CB             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
0420CB             0274*  ; that the buffer is large enough to capture all of the data that
0420CB             0275*  ; is expected to be written to it. The only current way to “rewind”
0420CB             0276*  ; an output stream would be to clear the buffer and create a new
0420CB             0277*  ; one, and then call set output stream again with the newly created
0420CB             0278*  ; buffer.
0420CB             0279*  
0420CB             0280*  ; Command 5: Adjust buffer contents
0420CB             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
0420CB             0282*  
0420CB             0283*  ; This command will adjust the contents of a buffer, at a given
0420CB             0284*  ; offset. The exact nature of the adjustment will depend on the
0420CB             0285*  ; operation used.
0420CB             0286*  
0420CB             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
0420CB             0288*  ; the contents of the current buffer. This will only work if this
0420CB             0289*  ; command is used within a buffered command sequence, otherwise the
0420CB             0290*  ; command will not do anything.
0420CB             0291*  
0420CB             0292*  ; The basic set of adjustment operations are as follows:
0420CB             0293*  ; Operation 	Description
0420CB             0294*  ; 0 	NOT
0420CB             0295*  ; 1 	Negate
0420CB             0296*  ; 2 	Set value
0420CB             0297*  ; 3 	Add
0420CB             0298*  ; 4 	Add with carry
0420CB             0299*  ; 5 	AND
0420CB             0300*  ; 6 	OR
0420CB             0301*  ; 7 	XOR
0420CB             0302*  
0420CB             0303*  ; All of these operations will modify a byte found at the given
0420CB             0304*  ; offset in the buffer. The only exception to that is the “Add with
0420CB             0305*  ; carry” operation, which will also store the “carry” value in the
0420CB             0306*  ; byte at the next offset. With the exception of NOT and Negate,
0420CB             0307*  ; each command requires an operand value to be specified.
0420CB             0308*  
0420CB             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
0420CB             0310*  ; need to use the NOT operation, and so the following command would
0420CB             0311*  ; be used:
0420CB             0312*  
0420CB             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
0420CB             0314*  
0420CB             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
0420CB             0316*  ; to use the Add operation, and so the following command would be
0420CB             0317*  ; used:
0420CB             0318*  
0420CB             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
0420CB             0320*  
0420CB             0321*  ; When using add with carry, the carry value is stored in the byte
0420CB             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
0420CB             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
0420CB             0324*  ; you would need to use the Add with carry operation, and so the
0420CB             0325*  ; following command would be used:
0420CB             0326*  
0420CB             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
0420CB             0328*  
0420CB             0329*  ; Advanced operations
0420CB             0330*  
0420CB             0331*  ; Whilst these operations are useful, they are not particularly
0420CB             0332*  ; powerful as they only operate one one byte at a time, with a
0420CB             0333*  ; fixed operand value, and potentially cannot reach all bytes in
0420CB             0334*  ; a buffer. To address this, the API supports a number of advanced
0420CB             0335*  ; operations.
0420CB             0336*  
0420CB             0337*  ; The operation value used is an 8-bit value that can have bits
0420CB             0338*  ; set to modify the behaviour of the operation. The following bits
0420CB             0339*  ; are defined:
0420CB             0340*  ; Bit 	Description
0420CB             0341*  ; &10 	Use “advanced” offsets
0420CB             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
0420CB             0343*  ; &40 	Multiple target values should be adjusted
0420CB             0344*  ; &80 	Multiple operand values should be used
0420CB             0345*  
0420CB             0346*  ; These bits can be combined together to modify the behaviour of
0420CB             0347*  ; the operation.
0420CB             0348*  
0420CB             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
0420CB             0350*  ; offset one byte at a time. When either of the “multiple” variants
0420CB             0351*  ; are used, a 16-bit count must be provided to indicate how many
0420CB             0352*  ; bytes should be altered.
0420CB             0353*  
0420CB             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
0420CB             0355*  ; order, which can allow for buffers that are larger than 64kb
0420CB             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
0420CB             0357*  ; the 16-bit value immediately following the offset is used as a
0420CB             0358*  ; block index number, and the remaining 23-bits of the offset value
0420CB             0359*  ; are used as an offset within that block. When the “advanced”
0420CB             0360*  ; offset mode bit has been set then all offsets associated with
0420CB             0361*  ; this command must be sent as advanced offsets.
0420CB             0362*  
0420CB             0363*  ; The “buffer-fetched value” mode allows for the operand value to
0420CB             0364*  ; be fetched from a buffer. The operand sent as part of the
0420CB             0365*  ; command in this case is a pair of 16-bit values giving the
0420CB             0366*  ; buffer ID and offset to indicate where the actual operand value
0420CB             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
0420CB             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
0420CB             0369*  ; used inside a buffered command sequence. If the advanced offset
0420CB             0370*  ; mode is used, then the operand value is an advanced offset value.
0420CB             0371*  
0420CB             0372*  ; The “multiple target values” mode allows for multiple bytes to
0420CB             0373*  ; be adjusted at once. When this mode is used, the count value
0420CB             0374*  ; must be provided to indicate how many bytes should be adjusted.
0420CB             0375*  ; Unless the “multiple operand values” mode is also used, the
0420CB             0376*  ; operand value is used for all bytes adjusted.
0420CB             0377*  
0420CB             0378*  ; The “multiple operand values” mode allows for multiple operand
0420CB             0379*  ; values to be used. When this mode is used, the count value must
0420CB             0380*  ; be provided to indicate how many operand values should be used.
0420CB             0381*  ; This can allow, for instance, to add together several bytes in a
0420CB             0382*  ; buffer. When this mode is used in conjunction with the “multiple
0420CB             0383*  ; target values” mode, the number of operand values must match the
0420CB             0384*  ; number of target values, and the operation happens one byte at a
0420CB             0385*  ; time.
0420CB             0386*  
0420CB             0387*  ; Some examples of advanced operations are as follows:
0420CB             0388*  
0420CB             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
0420CB             0390*  
0420CB             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
0420CB             0392*  
0420CB             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
0420CB             0394*  ; modifier (&40).
0420CB             0395*  
0420CB             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
0420CB             0397*  
0420CB             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
0420CB             0399*  
0420CB             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
0420CB             0401*  
0420CB             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
0420CB             0403*  
0420CB             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
0420CB             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
0420CB             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
0420CB             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
0420CB             0408*  ; in little-endian order. As the top bit of the offset is set, this
0420CB             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
0420CB             0410*  ; Finally the value to write is sent, 42.
0420CB             0411*  
0420CB             0412*  ; An operation like this could be used to set the position as part
0420CB             0413*  ; of a draw command.
0420CB             0414*  
0420CB             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
0420CB             0416*  ; values 1, 2, 3, 4, 5:
0420CB             0417*  
0420CB             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
0420CB             0419*  ; offset 12 (set it to 0)
0420CB             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
0420CB             0421*  
0420CB             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
0420CB             0423*  ; 7 bytes in buffer 4 starting at offset 42:
0420CB             0424*  
0420CB             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
0420CB             0426*  
0420CB             0427*  ; As we are working on a little-endian system, integers longer
0420CB             0428*  ; than one byte are sent with their least significant byte first.
0420CB             0429*  ; This means that the add with carry operation can be used to add
0420CB             0430*  ; together integers of any size, so long as they are the same size.
0420CB             0431*  ; To do this, both the “multiple target values” and “multiple
0420CB             0432*  ; operand values” modes must be used.
0420CB             0433*  
0420CB             0434*  ; The following commands will add together a 16-bit, 24-bit,
0420CB             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
0420CB             0436*  ; in buffer 3 starting at offset 12, and all using the operand
0420CB             0437*  ; value of 42:
0420CB             0438*  
0420CB             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
0420CB             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
0420CB             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
0420CB             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
0420CB             0443*  
0420CB             0444*  ; Take note of how the operand value is padded out with zeros
0420CB             0445*  ; to match the size of the target value. 42; is used as a base
0420CB             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
0420CB             0447*  ; 16-bits to pad it out to the required size. The “carry” value
0420CB             0448*  ; will be stored at the next offset in the target buffer after
0420CB             0449*  ; the complete target value. So for a 16-bit value, the carry
0420CB             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
0420CB             0451*  ; at offset 15, and so on.
0420CB             0452*  
0420CB             0453*  ; Command 6: Conditionally call a buffer
0420CB             0454*  
0420CB             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
0420CB             0456*  
0420CB             0457*  ; This command will conditionally call a buffer if the condition
0420CB             0458*  ; operation passes. This command works in a similar manner to the
0420CB             0459*  ; “Adjust buffer contents” command.
0420CB             0460*  
0420CB             0461*  ; With this command a buffer ID of 65535 (-1) is always
0420CB             0462*  ; interpretted as “current buffer”, and so can only be used
0420CB             0463*  ; within a buffered command sequence. If used outside of a
0420CB             0464*  ; buffered command sequence then this command will do nothing.
0420CB             0465*  
0420CB             0466*  ; The basic set of condition operations are as follows:
0420CB             0467*  ; Operation 	Description
0420CB             0468*  ; 0 	Exists (value is non-zero)
0420CB             0469*  ; 1 	Not exists (value is zero)
0420CB             0470*  ; 2 	Equal
0420CB             0471*  ; 3 	Not equal
0420CB             0472*  ; 4 	Less than
0420CB             0473*  ; 5 	Greater than
0420CB             0474*  ; 6 	Less than or equal
0420CB             0475*  ; 7 	Greater than or equal
0420CB             0476*  ; 8 	AND
0420CB             0477*  ; 9 	OR
0420CB             0478*  
0420CB             0479*  ; The value that is being checked is fetched from the specified
0420CB             0480*  ; check buffer ID and offset. With the exception of “Exists” and
0420CB             0481*  ; “Not exists”, each command requires an operand value to be
0420CB             0482*  ; specified to check against.
0420CB             0483*  
0420CB             0484*  ; The operation value used is an 8-bit value that can have bits
0420CB             0485*  ; set to modify the behaviour of the operation. The following bits
0420CB             0486*  ; are defined:
0420CB             0487*  ; Bit value 	Description
0420CB             0488*  ; &10 	Use advanced offsets
0420CB             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
0420CB             0490*  
0420CB             0491*  ; These modifiers can be combined together to modify the behaviour
0420CB             0492*  ; of the operation.
0420CB             0493*  
0420CB             0494*  ; At this time, unlike with the “adjust” command, multiple target
0420CB             0495*  ; values and multiple operand values are not supported. All
0420CB             0496*  ; comparisons are therefore only conducted on single 8-bit values.
0420CB             0497*  ; (If comparisons of 16-bit values are required, multiple calls
0420CB             0498*  ; can be combined.) Support for them may be added in the future.
0420CB             0499*  
0420CB             0500*  ; The AND and OR operations are logical operations, and so the
0420CB             0501*  ; operand value is used as a boolean value. Any non-zero value is
0420CB             0502*  ; considered to be true, and zero is considered to be false. These
0420CB             0503*  ; operations therefore are most useful when used with buffer-fetched
0420CB             0504*  ; operand values (operations &28, &29, &38 and &39).
0420CB             0505*  
0420CB             0506*  ; Some examples of condition operations are as follows:
0420CB             0507*  
0420CB             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
0420CB             0509*  ; (is non-zero):
0420CB             0510*  
0420CB             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
0420CB             0512*  
0420CB             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
0420CB             0514*  ; exist (is zero):
0420CB             0515*  
0420CB             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
0420CB             0517*  
0420CB             0518*  ; Combining the above two examples is effectively equivalent to
0420CB             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
0420CB             0520*  
0420CB             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
0420CB             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
0420CB             0523*  
0420CB             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
0420CB             0525*  
0420CB             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
0420CB             0527*  
0420CB             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
0420CB             0529*  ; the value in buffer 2 at offset 8:
0420CB             0530*  
0420CB             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
0420CB             0532*  
0420CB             0533*  ; Command 7: Jump to a buffer
0420CB             0534*  
0420CB             0535*  ; VDU 23, 0, &A0, bufferId; 7
0420CB             0536*  
0420CB             0537*  ; This command will jump to the buffer with the given ID. If
0420CB             0538*  ; the buffer does not exist, or is empty, then this command will
0420CB             0539*  ; do nothing.
0420CB             0540*  
0420CB             0541*  ; This essentially works the same as the call command (command 1),
0420CB             0542*  ;  except that it does not return to the caller. This command is
0420CB             0543*  ;  therefore useful for creating loops.
0420CB             0544*  
0420CB             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
0420CB             0546*  ; treated as a “jump to end of current buffer”. This will return
0420CB             0547*  ; execution to the caller, and can be useful for exiting a loop.
0420CB             0548*  
0420CB             0549*  ; ## Command 8: Conditional Jump to a buffer
0420CB             0550*  
0420CB             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0420CB             0552*  
0420CB             0553*  ; This command operates in a similar manner to the “Conditionally
0420CB             0554*  ; call a buffer” command (command 6), except that it will jump to
0420CB             0555*  ; the buffer if the condition operation passes.
0420CB             0556*  
0420CB             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
0420CB             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
0420CB             0559*  ; Command 9: Jump to an offset in a buffer
0420CB             0560*  
0420CB             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0420CB             0562*  
0420CB             0563*  ; This command will jump to the given offset in the buffer with the
0420CB             0564*  ; given ID. If the buffer does not exist, or is empty, then this
0420CB             0565*  ; command will do nothing.
0420CB             0566*  
0420CB             0567*  ; The offset in this command is always an “advanced” offset, given
0420CB             0568*  ; as a 24-bit value in little-endian order. As with other uses of
0420CB             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
0420CB             0570*  ; offset value, a block number must also be provided.
0420CB             0571*  
0420CB             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
0420CB             0573*  ; meaning “jump within current buffer”. This can be useful for
0420CB             0574*  ; creating loops within a buffer, or when building up command
0420CB             0575*  ; sequences that may be copied across multiple buffers.
0420CB             0576*  
0420CB             0577*  ; Jumping to an offset that is beyond the end of the buffer is
0420CB             0578*  ; equivalent to jumping to the end of the buffer.
0420CB             0579*  ; Command 10: Conditional jump to an offset in a buffer
0420CB             0580*  
0420CB             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0420CB             0582*  
0420CB             0583*  ; A conditional jump with an offset works in a similar manner to
0420CB             0584*  ; the “Conditional call a buffer” command (command 6), except that
0420CB             0585*  ; it will jump to the given offset in the buffer if the condition
0420CB             0586*  ; operation passes.
0420CB             0587*  
0420CB             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
0420CB             0589*  ; the offset in this command is always an “advanced” offset, given
0420CB             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
0420CB             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
0420CB             0592*  ; treated as meaning “jump within current buffer”.
0420CB             0593*  ; Command 11: Call buffer with an offset
0420CB             0594*  
0420CB             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0420CB             0596*  
0420CB             0597*  ; Works just like “Call a buffer” (command 1), except that it also
0420CB             0598*  ; accepts an advanced offset.
0420CB             0599*  
0420CB             0600*  ; Command 12: Conditional call buffer with an offset
0420CB             0601*  
0420CB             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
0420CB             0603*  
0420CB             0604*  ; Works just like the “Conditional call a buffer” command
0420CB             0605*  ; (command 6), except that it also accepts an advanced offset.
0420CB             0606*  
0420CB             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
0420CB             0608*  
0420CB             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
0420CB             0610*  
0420CB             0611*  ; This command will copy the contents of multiple buffers into a
0420CB             0612*  ; single buffer. The buffers to copy from are specified as a list
0420CB             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
0420CB             0614*  ; buffers are copied in the order they are specified.
0420CB             0615*  
0420CB             0616*  ; This is a block-wise copy, so the blocks from the source buffers
0420CB             0617*  ; are copied into the target buffer. The blocks are copied in the
0420CB             0618*  ; order they are found in the source buffers.
0420CB             0619*  
0420CB             0620*  ; The target buffer will be overwritten with the contents of the
0420CB             0621*  ; source buffers. This will not be done however until after all the
0420CB             0622*  ; data has been gathered and copied. The target buffer can therefore
0420CB             0623*  ; included in the list of the source buffers.
0420CB             0624*  
0420CB             0625*  ; If a source buffer that does not exist is specified, or a source
0420CB             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
0420CB             0627*  
0420CB             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
0420CB             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
0420CB             0630*  ; copied multiple times into the target buffer.
0420CB             0631*  
0420CB             0632*  ; If there is insufficient memory available on the VDP to complete
0420CB             0633*  ; this command then it will fail, and the target buffer will be
0420CB             0634*  ; left unchanged.
0420CB             0635*  
0420CB             0636*  
0420CB             0637*  ; Command 14: Consolidate blocks in a buffer
0420CB             0638*  
0420CB             0639*  ; VDU 23, 0, &A0, bufferId; 14
0420CB             0640*  
0420CB             0641*  ; Takes all the blocks in a buffer and consolidates them into a
0420CB             0642*  ; single block. This is useful for bitmaps, as it allows for a
0420CB             0643*  ; bitmap to be built up over time in multiple blocks, and then
0420CB             0644*  ; consolidated into a single block for use as a bitmap.
0420CB             0645*  
0420CB             0646*  ; If there is insufficient memory available on the VDP to complete
0420CB             0647*  ; this command then it will fail, and the buffer will be left
0420CB             0648*  ; unchanged.
0420CB             0649*  
0420CB             0650*  ; Command 15: Split a buffer into multiple blocks
0420CB             0651*  
0420CB             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
0420CB             0653*  
0420CB             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
0420CB             0655*  ; is a 16-bit integer that specifies the target size of each block.
0420CB             0656*  ; If the source data is not a multiple of the block size then the
0420CB             0657*  ; last block will be smaller than the specified block size.
0420CB             0658*  
0420CB             0659*  ; If this command is used on a buffer that is already split into
0420CB             0660*  ; multiple blocks, then the blocks will be consolidated first,
0420CB             0661*  ; and then re-split into the new block size.
0420CB             0662*  
0420CB             0663*  ; If there is insufficient memory available on the VDP to complete
0420CB             0664*  ; this command then it will fail, and the buffer will be left
0420CB             0665*  ; unchanged.
0420CB             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
0420CB             0667*  ; multiple buffers
0420CB             0668*  
0420CB             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0670*  
0420CB             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
0420CB             0672*  ; then spreads the resultant blocks across the target buffers.
0420CB             0673*  ; The target buffers are specified as a list of buffer IDs,
0420CB             0674*  ; terminated by a buffer ID of -1 (65535).
0420CB             0675*  
0420CB             0676*  ; The blocks are spread across the target buffers in the order
0420CB             0677*  ; they are specified, and the spread will loop around the buffers
0420CB             0678*  ; until all the blocks have been distributed. The target buffers
0420CB             0679*  ; will be cleared out before the blocks are spread across them.
0420CB             0680*  
0420CB             0681*  ; What this means is that if the source buffer is, let’s say,
0420CB             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
0420CB             0683*  ; then we will end up with 10 blocks. If we then spread those
0420CB             0684*  ; blocks across 3 target buffers, then the first buffer will
0420CB             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
0420CB             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
0420CB             0687*  ; blocks 3, 6 and 9.
0420CB             0688*  
0420CB             0689*  ; This command attempts to ensure that, in the event of
0420CB             0690*  ; insufficient memory being available on the VDP to complete
0420CB             0691*  ; the command, it will leave the targets as they were before
0420CB             0692*  ; the command was executed. However this may not always be
0420CB             0693*  ; possible. The first step of this command is to consolidate
0420CB             0694*  ; the source buffer into a single block, and this may fail from
0420CB             0695*  ; insufficient memory. If that happens then all the buffers will
0420CB             0696*  ; be left as they were. After this however the target buffers
0420CB             0697*  ; will be cleared. If there is insufficient memory to successfully
0420CB             0698*  ; split the buffer into multiple blocks then the call will exit,
0420CB             0699*  ; and the target buffers will be left empty.
0420CB             0700*  ; Command 17: Split a buffer and spread across blocks, starting
0420CB             0701*  ; at target buffer ID
0420CB             0702*  
0420CB             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
0420CB             0704*  
0420CB             0705*  ; As per the above two commands, this will split a buffer into
0420CB             0706*  ; multiple blocks. It will then spread the blocks across buffers
0420CB             0707*  ; starting at the target buffer ID, incrementing the target buffer
0420CB             0708*  ; ID until all the blocks have been distributed.
0420CB             0709*  
0420CB             0710*  ; Target blocks will be cleared before a block is stored in them.
0420CB             0711*  ; Each target will contain a single block. The exception to this
0420CB             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
0420CB             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
0420CB             0714*  ; will be placed into buffer 65534.
0420CB             0715*  
0420CB             0716*  ; With this command if there is insufficient memory available on
0420CB             0717*  ; the VDP to complete the command then it will fail, and the target
0420CB             0718*  ; buffers will be left unchanged.
0420CB             0719*  
0420CB             0720*  ; Command 18: Split a buffer into blocks by width
0420CB             0721*  
0420CB             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
0420CB             0723*  
0420CB             0724*  ; This command splits a buffer into a given number of blocks by
0420CB             0725*  ; first of all splitting the buffer into blocks of a given width
0420CB             0726*  ; (number of bytes), and then consolidating those blocks into the
0420CB             0727*  ; given number of blocks.
0420CB             0728*  
0420CB             0729*  ; This is useful for splitting a bitmap into a number of separate
0420CB             0730*  ; columns, which can then be manipulated individually. This can be
0420CB             0731*  ; useful for dealing with sprite sheets.
0420CB             0732*  ; Command 19: Split by width into blocks and spread across target
0420CB             0733*  ; buffers
0420CB             0734*  
0420CB             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0736*  
0420CB             0737*  ; This command essentially operates the same as command 18, but the
0420CB             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
0420CB             0739*  
0420CB             0740*  ; Command 20: Split by width into blocks and spread across blocks
0420CB             0741*  ; starting at target buffer ID
0420CB             0742*  
0420CB             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
0420CB             0744*  
0420CB             0745*  ; This command essentially operates the same as command 18, but
0420CB             0746*  ; the generated blocks are spread across blocks starting at the
0420CB             0747*  ; target buffer ID, as per command 17.
0420CB             0748*  
0420CB             0749*  ; Command 21: Spread blocks from a buffer across multiple target
0420CB             0750*  ; buffers
0420CB             0751*  
0420CB             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
0420CB             0753*  
0420CB             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
0420CB             0755*  ; The target buffers are specified as a list of buffer IDs,
0420CB             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
0420CB             0757*  ; across the target buffers in the order they are specified, and
0420CB             0758*  ; the spread will loop around the buffers until all the blocks have
0420CB             0759*  ; been distributed.
0420CB             0760*  
0420CB             0761*  ; It should be noted that this command does not copy the blocks,
0420CB             0762*  ; and nor does it move them. Unless the source buffer has been
0420CB             0763*  ; included in the list of targets, it will remain completely
0420CB             0764*  ; intact. The blocks distributed across the target buffers will
0420CB             0765*  ; point to the same memory as the blocks in the source buffer.
0420CB             0766*  ; Operations to modify data in the source buffer will also modify
0420CB             0767*  ; the data in the target buffers. Clearing the source buffer
0420CB             0768*  ; however will not clear the target buffers.
0420CB             0769*  
0420CB             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
0420CB             0771*  ; at target buffer ID
0420CB             0772*  
0420CB             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
0420CB             0774*  
0420CB             0775*  ; Spreads the blocks from a buffer across blocks starting at
0420CB             0776*  ; the target buffer ID.
0420CB             0777*  
0420CB             0778*  ; This essentially works the same as command 21, and the same
0420CB             0779*  ; notes about copying and moving blocks apply. Blocks are spread
0420CB             0780*  ; in the same manner as commands 17 and 20.
0420CB             0781*  
0420CB             0782*  ; Command 23: Reverse the order of blocks in a buffer
0420CB             0783*  
0420CB             0784*  ; VDU 23, 0, &A0, bufferId; 23
0420CB             0785*  
0420CB             0786*  ; Reverses the order of the blocks in a buffer.
0420CB             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
0420CB             0788*  
0420CB             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0420CB             0790*  
0420CB             0791*  ; Reverses the order of the data within the blocks of a buffer.
0420CB             0792*  ; The options parameter is an 8-bit value that can have bits set
0420CB             0793*  ; to modify the behaviour of the operation. The following bits
0420CB             0794*  ; are defined:
0420CB             0795*  ; Bit value 	Description
0420CB             0796*  ; 1 	Values are 16-bits in size
0420CB             0797*  ; 2 	Values are 32-bits in size
0420CB             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
0420CB             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
0420CB             0800*  ; 8 	Reverse blocks
0420CB             0801*  
0420CB             0802*  ; These modifiers can be combined together to modify the behaviour
0420CB             0803*  ; of the operation.
0420CB             0804*  
0420CB             0805*  ; If no value size is set in the options (i.e. the value of the
0420CB             0806*  ; bottom two bits of the options is zero) then the value size is
0420CB             0807*  ; assumed to be 8-bits.
0420CB             0808*  
0420CB             0809*  ; It is probably easiest to understand what this operation is
0420CB             0810*  ; capable of by going through some examples of how it can be used
0420CB             0811*  ; to manipulate bitmaps. The VDP supports two different formats
0420CB             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
0420CB             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
0420CB             0814*  ; pixel.
0420CB             0815*  
0420CB             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
0420CB             0817*  ; degrees, which can be done by just reversing the order of
0420CB             0818*  ; bytes in the buffer:
0420CB             0819*  
0420CB             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
0420CB             0821*  
0420CB             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
0420CB             0823*  ; little more complex, as each pixel is made up of 4 bytes.
0420CB             0824*  ; However with this command it is still a simple operation, as
0420CB             0825*  ; we can just reverse the order of the 32-bit values that make
0420CB             0826*  ; up the bitmap by using an options value of 2:
0420CB             0827*  
0420CB             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
0420CB             0829*  
0420CB             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
0420CB             0831*  ; the order of rows of pixels. To do this we can set a custom
0420CB             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
0420CB             0833*  ; bitmap we can just set a custom value size to our bitmap width:
0420CB             0834*  
0420CB             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
0420CB             0836*  
0420CB             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
0420CB             0838*  ; our width by 4:
0420CB             0839*  
0420CB             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
0420CB             0841*  
0420CB             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
0420CB             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
0420CB             0844*  ; just set a custom chunk size to our bitmap width:
0420CB             0845*  
0420CB             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
0420CB             0847*  
0420CB             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
0420CB             0849*  ; 32-bit values as well as a custom chunk size:
0420CB             0850*  
0420CB             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
0420CB             0852*  
0420CB             0853*  ; Command 25: Copy blocks from multiple buffers by reference
0420CB             0854*  
0420CB             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
0420CB             0856*  
0420CB             0857*  ; This command is essentially a version of command 13 that copies
0420CB             0858*  ; blocks by reference rather than by value. The parameters for
0420CB             0859*  ; this command are the same as for command 13, and the same rules
0420CB             0860*  ; apply.
0420CB             0861*  
0420CB             0862*  ; If the target buffer is included in the list of source buffers
0420CB             0863*  ; then it will be skipped to prevent a reference loop.
0420CB             0864*  
0420CB             0865*  ; Copying by reference means that the blocks in the target buffer
0420CB             0866*  ; will point to the same memory as the blocks in the source
0420CB             0867*  ; buffers. Operations to modify data blocks in the source buffers
0420CB             0868*  ; will therefore also modify those blocks in the target buffer.
0420CB             0869*  ; Clearing the source buffers will not clear the target buffer -
0420CB             0870*  ; it will still point to the original data blocks. Data blocks
0420CB             0871*  ; are only freed from memory when no buffers are left with any
0420CB             0872*  ; references to them.
0420CB             0873*  
0420CB             0874*  ; Buffers that get consolidated become new blocks, so will lose
0420CB             0875*  ; their links to the original blocks, thus after a “consolidate”
0420CB             0876*  ; operation modifications to the original blocks will no longer be
0420CB             0877*  ; reflected in the consolidated buffer.
0420CB             0878*  
0420CB             0879*  ; This command is useful to construct a single buffer from multiple
0420CB             0880*  ; sources without the copy overhead, which can be costly. For
0420CB             0881*  ; example, this can be useful for constructing a bitmap from
0420CB             0882*  ; multiple constituent parts before consolidating it into a
0420CB             0883*  ; single block. In such an example, using command 13 instead
0420CB             0884*  ; would first make a copy of the contents of the source buffers,
0420CB             0885*  ; and then consolidate them into a single block. Using this
0420CB             0886*  ; command does not make that first copy, and so would be faster.
0420CB             0887*  
0420CB             0888*  ; This command is also useful for creating multiple buffers that
0420CB             0889*  ; all point to the same data.
0420CB             0890*  
0420CB             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
0420CB             0892*  
0420CB             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
0420CB             0055       include "vdu_plot.inc"
0420CB             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0420CB             0002*  ; PLOT code 	(Decimal) 	Effect
0420CB             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0420CB             0004*  plot_sl_both: equ 0x00
0420CB             0005*  
0420CB             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0420CB             0007*  plot_sl_first: equ 0x08
0420CB             0008*  
0420CB             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0420CB             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0420CB             0011*  
0420CB             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0420CB             0013*  plot_sl_last: equ 0x20
0420CB             0014*  
0420CB             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0420CB             0016*  plot_sl_none: equ 0x28
0420CB             0017*  
0420CB             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0420CB             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0420CB             0020*  
0420CB             0021*  ; &40-&47 	64-71 	Point plot
0420CB             0022*  plot_pt: equ 0x40
0420CB             0023*  
0420CB             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0420CB             0025*  plot_lf_lr_non_bg: equ 0x48
0420CB             0026*  
0420CB             0027*  ; &50-&57 	80-87 	Triangle fill
0420CB             0028*  plot_tf: equ 0x50
0420CB             0029*  
0420CB             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0420CB             0031*  plot_lf_r_bg: equ 0x58
0420CB             0032*  
0420CB             0033*  ; &60-&67 	96-103 	Rectangle fill
0420CB             0034*  plot_rf: equ 0x60
0420CB             0035*  
0420CB             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0420CB             0037*  plot_lf_lr_fg: equ 0x60
0420CB             0038*  
0420CB             0039*  ; &70-&77 	112-119 	Parallelogram fill
0420CB             0040*  plot_pf: equ 0x70
0420CB             0041*  
0420CB             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0420CB             0043*  plot_lf_r_non_fg: equ 0x78
0420CB             0044*  
0420CB             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0420CB             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0420CB             0047*  
0420CB             0048*  ; &90-&97 	144-151 	Circle outline
0420CB             0049*  plot_co: equ 0x90
0420CB             0050*  
0420CB             0051*  ; &98-&9F 	152-159 	Circle fill
0420CB             0052*  plot_cf: equ 0x98
0420CB             0053*  
0420CB             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0420CB             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0420CB             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0420CB             0057*  
0420CB             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0420CB             0059*  plot_rcm: equ 0xB8
0420CB             0060*  
0420CB             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0420CB             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0420CB             0063*  ; &D0-&D7 	208-215 	Not defined
0420CB             0064*  ; &D8-&DF 	216-223 	Not defined
0420CB             0065*  ; &E0-&E7 	224-231 	Not defined
0420CB             0066*  
0420CB             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0420CB             0068*  plot_bmp: equ 0xE8
0420CB             0069*  
0420CB             0070*  ; &F0-&F7 	240-247 	Not defined
0420CB             0071*  ; &F8-&FF 	248-255 	Not defined
0420CB             0072*  
0420CB             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0420CB             0074*  ; Agon Console8 VDP 2.2.0
0420CB             0075*  
0420CB             0076*  ; Within each group of eight plot codes, the effects are as follows:
0420CB             0077*  ; Plot code 	Effect
0420CB             0078*  ; 0 	Move relative
0420CB             0079*  mv_rel: equ 0
0420CB             0080*  
0420CB             0081*  ; 1 	Plot relative in current foreground colour
0420CB             0082*  dr_rel_fg: equ 1
0420CB             0083*  
0420CB             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0420CB             0085*  ; 3 	Plot relative in current background colour
0420CB             0086*  dr_rel_bg: equ 3
0420CB             0087*  
0420CB             0088*  ; 4 	Move absolute
0420CB             0089*  mv_abs: equ 4
0420CB             0090*  
0420CB             0091*  ; 5 	Plot absolute in current foreground colour
0420CB             0092*  dr_abs_fg: equ 5
0420CB             0093*  
0420CB             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0420CB             0095*  ; 7 	Plot absolute in current background colour
0420CB             0096*  dr_abs_bg: equ 7
0420CB             0097*  
0420CB             0098*  ; Codes 0-3 use the position data provided as part of the command
0420CB             0099*  ; as a relative position, adding the position given to the current
0420CB             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0420CB             0101*  ; as part of the command as an absolute position, setting the current
0420CB             0102*  ; graphical cursor position to the position given.
0420CB             0103*  
0420CB             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0420CB             0105*  ; current pixel colour. These operations cannot currently be supported
0420CB             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0420CB             0107*  ; supported. Support for these codes may be added in a future version
0420CB             0108*  ; of the VDP firmware.
0420CB             0109*  
0420CB             0110*  ; 16 colour palette constants
0420CB             0111*  c_black: equ 0
0420CB             0112*  c_red_dk: equ 1
0420CB             0113*  c_green_dk: equ 2
0420CB             0114*  c_yellow_dk: equ 3
0420CB             0115*  c_blue_dk: equ 4
0420CB             0116*  c_magenta_dk: equ 5
0420CB             0117*  c_cyan_dk: equ 6
0420CB             0118*  c_grey: equ 7
0420CB             0119*  c_grey_dk: equ 8
0420CB             0120*  c_red: equ 9
0420CB             0121*  c_green: equ 10
0420CB             0122*  c_yellow: equ 11
0420CB             0123*  c_blue: equ 12
0420CB             0124*  c_magenta: equ 13
0420CB             0125*  c_cyan: equ 14
0420CB             0126*  c_white: equ 15
0420CB             0127*  
0420CB             0128*  ; VDU 25, mode, x; y;: PLOT command
0420CB             0129*  ; inputs: a=mode, bc=x0, de=y0
0420CB             0130*  vdu_plot:
0420CB 32 E5 20 04 0131*      ld (@mode),a
0420CF ED 43 E6 20 0132*      ld (@x0),bc
       04          
0420D4 ED 53 E8 20 0133*      ld (@y0),de
       04          
0420D9 21 E4 20 04 0134*  	ld hl,@cmd
0420DD 01 06 00 00 0135*  	ld bc,@end-@cmd
0420E1 5B DF       0136*  	rst.lil $18
0420E3 C9          0137*  	ret
0420E4 19          0138*  @cmd:   db 25
0420E5 00          0139*  @mode:  db 0
0420E6 00 00       0140*  @x0: 	dw 0
0420E8 00 00       0141*  @y0: 	dw 0
0420EA 00          0142*  @end:   db 0 ; extra byte to soak up deu
0420EB             0143*  
0420EB             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0420EB             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
0420EB             0146*  ; VDU 25, mode, x; y;: PLOT command
0420EB             0147*  ; inputs: bc=x0, de=y0
0420EB             0148*  ; prerequisites: vdu_buff_select
0420EB             0149*  vdu_plot_bmp:
0420EB ED 43 02 21 0150*      ld (@x0),bc
       04          
0420F0 ED 53 04 21 0151*      ld (@y0),de
       04          
0420F5 21 00 21 04 0152*  	ld hl,@cmd
0420F9 01 06 00 00 0153*  	ld bc,@end-@cmd
0420FD 5B DF       0154*  	rst.lil $18
0420FF C9          0155*  	ret
042100 19          0156*  @cmd:   db 25
042101 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
042102 00 00       0158*  @x0: 	dw 0x0000
042104 00 00       0159*  @y0: 	dw 0x0000
042106 00          0160*  @end:   db 0x00 ; padding
042107             0161*  
042107             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042107             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
042107             0164*  ; VDU 25, mode, x; y;: PLOT command
042107             0165*  ; inputs: bc=x0, de=y0
042107             0166*  ; USING 16.8 FIXED POINT COORDINATES
042107             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042107             0168*  ;   the fractional portiion of the inputs are truncated
042107             0169*  ;   leaving only the 16-bit integer portion
042107             0170*  ; prerequisites: vdu_buff_select
042107             0171*  vdu_plot_bmp168:
042107             0172*  ; populate in the reverse of normal to keep the
042107             0173*  ; inputs from stomping on each other
042107 ED 53 25 21 0174*      ld (@y0-1),de
       04          
04210C ED 43 23 21 0175*      ld (@x0-1),bc
       04          
042111 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
042113 32 23 21 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
042117 21 22 21 04 0178*  	ld hl,@cmd
04211B 01 06 00 00 0179*  	ld bc,@end-@cmd
04211F 5B DF       0180*  	rst.lil $18
042121 C9          0181*  	ret
042122 19          0182*  @cmd:   db 25
042123 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
042124 00 00       0184*  @x0: 	dw 0x0000
042126 00 00       0185*  @y0: 	dw 0x0000
042128             0186*  @end:  ; no padding required b/c we shifted de right
042128             0187*  
042128             0188*  ; draw a filled rectangle
042128             0189*  vdu_plot_rf:
042128 ED 43 4F 21 0190*      ld (@x0),bc
       04          
04212D ED 53 51 21 0191*      ld (@y0),de
       04          
042132 DD 22 55 21 0192*      ld (@x1),ix
       04          
042137 FD 22 57 21 0193*      ld (@y1),iy
       04          
04213C 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
04213E 32 53 21 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042142 21 4D 21 04 0196*  	ld hl,@cmd0
042146 01 0C 00 00 0197*  	ld bc,@end-@cmd0
04214A 5B DF       0198*  	rst.lil $18
04214C C9          0199*      ret
04214D 19          0200*  @cmd0:  db 25 ; plot
04214E 04          0201*  @arg0:  db plot_sl_both+mv_abs
04214F 00 00       0202*  @x0:    dw 0x0000
042151 00 00       0203*  @y0:    dw 0x0000
042153 19          0204*  @cmd1:  db 25 ; plot
042154 65          0205*  @arg1:  db plot_rf+dr_abs_fg
042155 00 00       0206*  @x1:    dw 0x0000
042157 00 00       0207*  @y1:    dw 0x0000
042159 00          0208*  @end:   db 0x00 ; padding
04215A             0209*  
04215A             0210*  ; draw a filled circle
04215A             0211*  vdu_plot_cf:
04215A ED 43 81 21 0212*      ld (@x0),bc
       04          
04215F ED 53 83 21 0213*      ld (@y0),de
       04          
042164 DD 22 87 21 0214*      ld (@x1),ix
       04          
042169 FD 22 89 21 0215*      ld (@y1),iy
       04          
04216E 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
042170 32 85 21 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042174 21 7F 21 04 0218*  	ld hl,@cmd0
042178 01 0C 00 00 0219*  	ld bc,@end-@cmd0
04217C 5B DF       0220*  	rst.lil $18
04217E C9          0221*      ret
04217F 19          0222*  @cmd0:  db 25 ; plot
042180 04          0223*  @arg0:  db plot_sl_both+mv_abs
042181 00 00       0224*  @x0:    dw 0x0000
042183 00 00       0225*  @y0:    dw 0x0000
042185 19          0226*  @cmd1:  db 25 ; plot
042186 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
042187 00 00       0228*  @x1:    dw 0x0000
042189 00 00       0229*  @y1:    dw 0x0000
04218B 00          0230*  @end:   db 0x00 ; padding
04218C             0056   	include "vdu_sprites.inc"
04218C             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
04218C             0002*  ; the VDP can support up to 256 sprites. They must be defined
04218C             0003*  ; contiguously, and so the first sprite is sprite 0.
04218C             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
04218C             0005*  ; Once a selection of sprites have been defined, you can activate
04218C             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
04218C             0007*  ; of sprites to activate. This will activate the first n sprites,
04218C             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
04218C             0009*  
04218C             0010*  ; A single sprite can have multiple "frames", referring to
04218C             0011*  ; different bitmaps.
04218C             0012*  ; (These bitmaps do not need to be the same size.)
04218C             0013*  ; This allows a sprite to include an animation sequence,
04218C             0014*  ; which can be stepped through one frame at a time, or picked
04218C             0015*  ; in any order.
04218C             0016*  
04218C             0017*  ; Any format of bitmap can be used as a sprite frame. It should
04218C             0018*  ; be noted however that "native" format bitmaps are not
04218C             0019*  ; recommended for use as sprite frames, as they cannot get
04218C             0020*  ; erased from the screen. (As noted above, the "native" bitmap
04218C             0021*  ; format is not really intended for general use.) This is part
04218C             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
04218C             0023*  ; screen are now stored in RGBA2222 format.
04218C             0024*  
04218C             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
04218C             0026*  ; and then later shown again.
04218C             0027*  
04218C             0028*  ; Moving sprites around the screen is done by changing the
04218C             0029*  ; position of the sprite. This can be done either by setting
04218C             0030*  ; the absolute position of the sprite, or by moving the sprite
04218C             0031*  ; by a given number of pixels. (Sprites are positioned using
04218C             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
04218C             0033*  ; In the current sprite system, sprites will not update their
04218C             0034*  ; position on-screen until either another drawing operation is
04218C             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
04218C             0036*  
04218C             0037*  ; VDU 23, 27, 4, n: Select sprite n
04218C             0038*  ; inputs: a is the 8-bit sprite id
04218C             0039*  vdu_sprite_select:
04218C 32 9E 21 04 0040*      ld (@sprite),a
042190 21 9B 21 04 0041*      ld hl,@cmd
042194 01 04 00 00 0042*      ld bc,@end-@cmd
042198 5B DF       0043*      rst.lil $18
04219A C9          0044*      ret
04219B 17 1B 04    0045*  @cmd:    db 23,27,4
04219E 00          0046*  @sprite: db 0x00
04219F             0047*  @end:
04219F             0048*  
04219F             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
04219F             0050*  ; inputs: none
04219F             0051*  ; prerequisites: vdu_sprite_select
04219F             0052*  vdu_sprite_clear_frames:
04219F 21 AA 21 04 0053*      ld hl,@cmd
0421A3 01 03 00 00 0054*      ld bc,@end-@cmd
0421A7 5B DF       0055*      rst.lil $18
0421A9 C9          0056*      ret
0421AA 17 1B 05    0057*  @cmd: db 23,27,5
0421AD             0058*  @end:
0421AD             0059*  
0421AD             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0421AD             0061*  ; inputs: a is the 8-bit bitmap number
0421AD             0062*  ; prerequisites: vdu_sprite_select
0421AD             0063*  vdu_sprite_add_bmp:
0421AD 32 BF 21 04 0064*      ld (@bmp),a
0421B1 21 BC 21 04 0065*      ld hl,@cmd
0421B5 01 04 00 00 0066*      ld bc,@end-@cmd
0421B9 5B DF       0067*      rst.lil $18
0421BB C9          0068*      ret
0421BC 17 1B 06    0069*  @cmd: db 23,27,6
0421BF 00          0070*  @bmp: db 0x00
0421C0             0071*  @end:
0421C0             0072*  
0421C0             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0421C0             0074*  ; inputs: a is the number of sprites to activate
0421C0             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0421C0             0076*  vdu_sprite_activate:
0421C0 32 D2 21 04 0077*      ld (@num),a
0421C4 21 CF 21 04 0078*      ld hl,@cmd
0421C8 01 04 00 00 0079*      ld bc,@end-@cmd
0421CC 5B DF       0080*      rst.lil $18
0421CE C9          0081*      ret
0421CF 17 1B 07    0082*  @cmd: db 23,27,7
0421D2 00          0083*  @num: db 0x00
0421D3             0084*  @end:
0421D3             0085*  
0421D3             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
0421D3             0087*  ; inputs: none
0421D3             0088*  ; prerequisites: vdu_sprite_select
0421D3             0089*  vdu_sprite_next_frame:
0421D3 21 DE 21 04 0090*      ld hl,@cmd
0421D7 01 03 00 00 0091*      ld bc,@end-@cmd
0421DB 5B DF       0092*      rst.lil $18
0421DD C9          0093*      ret
0421DE 17 1B 08    0094*  @cmd: db 23,27,8
0421E1             0095*  @end:
0421E1             0096*  
0421E1             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
0421E1             0098*  ; inputs: none
0421E1             0099*  ; prerequisites: vdu_sprite_select
0421E1             0100*  vdu_sprite_prev_frame:
0421E1 21 EC 21 04 0101*      ld hl,@cmd
0421E5 01 03 00 00 0102*      ld bc,@end-@cmd
0421E9 5B DF       0103*      rst.lil $18
0421EB C9          0104*      ret
0421EC 17 1B 09    0105*  @cmd: db 23,27,9
0421EF             0106*  @end:
0421EF             0107*  
0421EF             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0421EF             0109*  ; inputs: a is frame number to select
0421EF             0110*  ; prerequisites: vdu_sprite_select
0421EF             0111*  vdu_sprite_select_frame:
0421EF 32 01 22 04 0112*      ld (@frame),a
0421F3 21 FE 21 04 0113*      ld hl,@cmd
0421F7 01 04 00 00 0114*      ld bc,@end-@cmd
0421FB 5B DF       0115*      rst.lil $18
0421FD C9          0116*      ret
0421FE 17 1B 0A    0117*  @cmd:    db 23,27,10
042201 00          0118*  @frame:  db 0x00
042202             0119*  @end:
042202             0120*  
042202             0121*  ; VDU 23, 27, 11: Show current sprite
042202             0122*  ; inputs: none
042202             0123*  ; prerequisites: vdu_sprite_select
042202             0124*  vdu_sprite_show:
042202 21 0D 22 04 0125*      ld hl,@cmd
042206 01 03 00 00 0126*      ld bc,@end-@cmd
04220A 5B DF       0127*      rst.lil $18
04220C C9          0128*      ret
04220D 17 1B 0B    0129*  @cmd: db 23,27,11
042210             0130*  @end:
042210             0131*  
042210             0132*  ; VDU 23, 27, 12: Hide current sprite
042210             0133*  ; inputs: none
042210             0134*  ; prerequisites: vdu_sprite_select
042210             0135*  vdu_sprite_hide:
042210 21 1B 22 04 0136*      ld hl,@cmd
042214 01 03 00 00 0137*      ld bc,@end-@cmd
042218 5B DF       0138*      rst.lil $18
04221A C9          0139*      ret
04221B 17 1B 0C    0140*  @cmd: db 23,27,12
04221E             0141*  @end:
04221E             0142*  
04221E             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04221E             0144*  ; inputs: bc is x coordinate, de is y coordinate
04221E             0145*  ; prerequisites: vdu_sprite_select
04221E             0146*  vdu_sprite_move_abs:
04221E ED 43 36 22 0147*      ld (@xpos),bc
       04          
042223 ED 53 38 22 0148*      ld (@ypos),de
       04          
042228 21 33 22 04 0149*      ld hl,@cmd
04222C 01 07 00 00 0150*      ld bc,@end-@cmd
042230 5B DF       0151*      rst.lil $18
042232 C9          0152*      ret
042233 17 1B 0D    0153*  @cmd:  db 23,27,13
042236 00 00       0154*  @xpos: dw 0x0000
042238 00 00       0155*  @ypos: dw 0x0000
04223A 00          0156*  @end:  db 0x00 ; padding
04223B             0157*  
04223B             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04223B             0159*  ; inputs: bc is x coordinate, de is y coordinate
04223B             0160*  ; prerequisites: vdu_sprite_select
04223B             0161*  vdu_sprite_move_rel:
04223B ED 43 53 22 0162*      ld (@dx),bc
       04          
042240 ED 53 55 22 0163*      ld (@dy),de
       04          
042245 21 50 22 04 0164*      ld hl,@cmd
042249 01 07 00 00 0165*      ld bc,@end-@cmd
04224D 5B DF       0166*      rst.lil $18
04224F C9          0167*      ret
042250 17 1B 0E    0168*  @cmd: db 23,27,14
042253 00 00       0169*  @dx:  dw 0x0000
042255 00 00       0170*  @dy:  dw 0x0000
042257 00          0171*  @end: db 0x00 ; padding
042258             0172*  
042258             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042258             0174*  ; USING 16.8 FIXED POINT COORDINATES
042258             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042258             0176*  ;   the fractional portiion of the inputs are truncated
042258             0177*  ;   leaving only the 16-bit integer portion
042258             0178*  ; prerequisites: vdu_sprite_select
042258             0179*  vdu_sprite_move_abs168:
042258             0180*  ; populate in the reverse of normal to keep the
042258             0181*  ; inputs from stomping on each other
042258 ED 53 77 22 0182*      ld (@ypos-1),de
       04          
04225D ED 43 75 22 0183*      ld (@xpos-1),bc
       04          
042262 3E 0D       0184*      ld a,13       ; restore the final byte of the command
042264 32 75 22 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
042268 21 73 22 04 0186*      ld hl,@cmd
04226C 01 07 00 00 0187*      ld bc,@end-@cmd
042270 5B DF       0188*      rst.lil $18
042272 C9          0189*      ret
042273 17 1B 0D    0190*  @cmd:  db 23,27,13
042276 00 00       0191*  @xpos: dw 0x0000
042278 00 00       0192*  @ypos: dw 0x0000
04227A             0193*  @end:  ; no padding required b/c we shifted de right
04227A             0194*  
04227A             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04227A             0196*  ; USING 16.8 FIXED POINT COORDINATES
04227A             0197*  ; inputs: ub.c is dx, ud.e is dy
04227A             0198*  ;   the fractional portiion of the inputs are truncated
04227A             0199*  ;   leaving only the 16-bit integer portion
04227A             0200*  ; prerequisites: vdu_sprite_select
04227A             0201*  vdu_sprite_move_rel168:
04227A             0202*  ; populate in the reverse of normal to keep the
04227A             0203*  ; inputs from stomping on each other
04227A ED 53 99 22 0204*      ld (@dy-1),de
       04          
04227F ED 43 97 22 0205*      ld (@dx-1),bc
       04          
042284 3E 0E       0206*      ld a,14       ; restore the final byte of the command
042286 32 97 22 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
04228A 21 95 22 04 0208*      ld hl,@cmd
04228E 01 07 00 00 0209*      ld bc,@end-@cmd
042292 5B DF       0210*      rst.lil $18
042294 C9          0211*      ret
042295 17 1B 0E    0212*  @cmd:  db 23,27,14
042298 00 00       0213*  @dx: dw 0x0000
04229A 00 00       0214*  @dy: dw 0x0000
04229C             0215*  @end:  ; no padding required b/c we shifted de right
04229C             0216*  
04229C             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
04229C             0218*  ; inputs: none
04229C             0219*  vdu_sprite_update:
04229C 21 A7 22 04 0220*      ld hl,@cmd
0422A0 01 03 00 00 0221*      ld bc,@end-@cmd
0422A4 5B DF       0222*      rst.lil $18
0422A6 C9          0223*      ret
0422A7 17 1B 0F    0224*  @cmd: db 23,27,15
0422AA             0225*  @end:
0422AA             0226*  
0422AA             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0422AA             0228*  ; inputs: none
0422AA             0229*  vdu_sprite_bmp_reset:
0422AA 21 B5 22 04 0230*      ld hl,@cmd
0422AE 01 03 00 00 0231*      ld bc,@end-@cmd
0422B2 5B DF       0232*      rst.lil $18
0422B4 C9          0233*      ret
0422B5 17 1B 10    0234*  @cmd: db 23,27,16
0422B8             0235*  @end:
0422B8             0236*  
0422B8             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0422B8             0238*  ; inputs: none
0422B8             0239*  vdu_sprite_reset:
0422B8 21 C3 22 04 0240*      ld hl,@cmd
0422BC 01 03 00 00 0241*      ld bc,@end-@cmd
0422C0 5B DF       0242*      rst.lil $18
0422C2 C9          0243*      ret
0422C3 17 1B 11    0244*  @cmd: db 23,27,17
0422C6             0245*  @end:
0422C6             0246*  
0422C6             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0422C6             0248*  ; inputs: a is the GCOL paint mode
0422C6             0249*  ; prerequisites: vdu_sprite_select
0422C6             0250*  vdu_sprite_set_gcol:
0422C6 32 D8 22 04 0251*      ld (@mode),a
0422CA 21 D5 22 04 0252*      ld hl,@cmd
0422CE 01 04 00 00 0253*      ld bc,@end-@cmd
0422D2 5B DF       0254*      rst.lil $18
0422D4 C9          0255*      ret
0422D5 17 1B 12    0256*  @cmd:  db 23,27,18
0422D8 00          0257*  @mode: db 0x00
0422D9             0258*  @end:
0422D9             0259*  
0422D9             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0422D9             0261*  ; inputs: hl=bufferId
0422D9             0262*  ; prerequisites: vdu_sprite_select
0422D9             0263*  vdu_sprite_add_buff:
0422D9 22 EB 22 04 0264*      ld (@bufferId),hl
0422DD 21 E8 22 04 0265*      ld hl,@cmd
0422E1 01 05 00 00 0266*      ld bc,@end-@cmd
0422E5 5B DF       0267*      rst.lil $18
0422E7 C9          0268*      ret
0422E8 17 1B 26    0269*  @cmd:      db 23,27,0x26
0422EB 00 00       0270*  @bufferId: dw 0x0000
0422ED 00          0271*  @end:      db 0x00 ; padding
0422EE             0057   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
0422EE             0058   	include "maths.inc"
0422EE             0001*  ; test the sign of HL
0422EE             0002*  ; inputs: HL obviously
0422EE             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0422EE             0004*  ; destroys: flags
0422EE             0005*      MACRO sign_hlu
0422EE             0006*          add hl,de
0422EE             0007*          or a
0422EE             0008*          sbc hl,de
0422EE             0009*      ENDMACRO
0422EE             0010*  
0422EE             0011*  
0422EE             0012*  ;------------------------------------------------------------------------
0422EE             0013*  ; Scratch area for calculations
0422EE             0014*  ;------------------------------------------------------------------------
0422EE 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
0422F1 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
0422F4             0017*  
0422F4             0018*  ; absolute value of hlu
0422F4             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0422F4             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0422F4             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0422F4             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0422F4             0023*  ; destroys: a
0422F4             0024*  hlu_abs:
0422F4 19          0025*      add hl,de
0422F5 B7          0026*      or a
0422F6 ED 52       0027*      sbc hl,de
0422F8 FA FD 22 04 0028*      jp m,@is_neg
0422FC C9          0029*      ret         ; hlu is positive or zero so we're done
0422FD             0030*  @is_neg:
0422FD F5          0031*      push af     ; otherwise, save current flags for return
0422FE CD 04 23 04 0032*      call neg_hlu ; negate hlu
042302 F1          0033*      pop af      ; get back flags
042303 C9          0034*      ret
042304             0035*  
042304             0036*  ; flip the sign of hlu
042304             0037*  ; inputs: hlu
042304             0038*  ; returns: 0-hlu, flags set appropriately for the result:
042304             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
042304             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
042304             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
042304             0042*  ; destroys a
042304             0043*  neg_hlu:
042304 D5          0044*      push de     ; save de
042305 EB          0045*      ex de,hl    ; put hl into de
042306 21 00 00 00 0046*      ld hl,0     ; clear hl
04230A AF          0047*      xor a       ; clear carry
04230B ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
04230D D1          0049*      pop de      ; get de back
04230E C9          0050*      ret         ; easy peasy
04230F             0051*  
04230F             0052*  ;------------------------------------------------------------------------
04230F             0053*  ; divide hlu by 2, inspired by above
04230F             0054*  ;------------------------------------------------------------------------
04230F             0055*  hlu_div2:
04230F 22 EE 22 04 0056*  	ld		(scratch1),hl
042313 21 F0 22 04 0057*  	ld		hl,scratch1+2
042317 CB 1E       0058*  	rr		(hl)
042319 2B          0059*  	dec		hl
04231A CB 1E       0060*  	rr		(hl)
04231C 2B          0061*  	dec		hl
04231D CB 1E       0062*  	rr		(hl)
04231F 23          0063*  	inc		hl
042320 23          0064*  	inc		hl
042321 2A EE 22 04 0065*      ld hl,(scratch1)
042325 C9          0066*      ret
042326             0067*  
042326             0068*  ; this is my little hack to divide by 16
042326             0069*  hlu_div16:
042326 AF          0070*      xor a
042327 29          0071*      add hl,hl
042328 17          0072*      rla
042329 29          0073*      add hl,hl
04232A 17          0074*      rla
04232B 29          0075*      add hl,hl
04232C 17          0076*      rla
04232D 29          0077*      add hl,hl
04232E 17          0078*      rla
04232F 22 3C 23 04 0079*      ld (@scratch),hl
042333 32 3F 23 04 0080*      ld (@scratch+3),a
042337 2A 3D 23 04 0081*      ld hl,(@scratch+1)
04233B C9          0082*      ret
04233C             0083*  @scratch: ds 4
042340             0084*  
042340             0085*  ; hlu signed division by 256
042340             0086*  ; returns: hlu / 256
042340             0087*  ; destroys: af
042340             0088*  hlu_sdiv256:
042340 AF          0089*      xor a ; assume hl is positive
042341 22 57 23 04 0090*      ld (@buffer),hl
042345             0091*      sign_hlu
042345 19          0001*M         add hl,de
042346 B7          0002*M         or a
042347 ED 52       0003*M         sbc hl,de
042349 F2 4E 23 04 0092*      jp p,@hl_pos
04234D 3D          0093*      dec a
04234E             0094*  @hl_pos:
04234E 32 5A 23 04 0095*      ld (@buffer+3),a
042352 2A 58 23 04 0096*      ld hl,(@buffer+1)
042356 C9          0097*      ret
042357             0098*  @buffer: ds 4
04235B             0099*  
04235B             0100*  ; hlu 1 byte right shift, unsigned
04235B             0101*  ; returns: hlu / 256, fractional portion in a
04235B             0102*  ; destroys: af
04235B             0103*  hlu_udiv256:
04235B AF          0104*  	xor a
04235C 32 6D 23 04 0105*  	ld (@buffer+3),a
042360 7D          0106*  	ld a,l ; save the fractional portion
042361 22 6A 23 04 0107*  	ld (@buffer),hl
042365 2A 6B 23 04 0108*  	ld hl,(@buffer+1)
042369 C9          0109*  	ret
04236A             0110*  @buffer: ds 4
04236E             0111*  
04236E             0112*      MACRO hlu_mul256
04236E             0113*          add hl,hl ; * 2
04236E             0114*          add hl,hl ; * 4
04236E             0115*          add hl,hl ; * 8
04236E             0116*          add hl,hl ; * 16
04236E             0117*          add hl,hl ; * 32
04236E             0118*          add hl,hl ; * 64
04236E             0119*          add hl,hl ; * 128
04236E             0120*          add hl,hl ; * 256
04236E             0121*      ENDMACRO
04236E             0122*  
04236E             0123*  ; compute the modulo of hlu by deu
04236E             0124*  ; outputs: hlu = hlu % deu
04236E             0125*  ; destroys: f, hl
04236E             0126*  hlu_mod:
04236E B7          0127*  	or a ; clear carry
04236F             0128*  @loop:
04236F ED 52       0129*      sbc hl,de
042371 DA 79 23 04 0130*      jp c, @end
042375 C3 6F 23 04 0131*      jp @loop
042379             0132*  @end:
042379 19          0133*      add hl,de
04237A C9          0134*  	ret
04237B             0135*  
04237B             0136*  
04237B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04237F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
042383             0139*  
042383             0140*  ; set bcd values in a scratch memory address from registers bcde
042383             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
042383             0142*  ; destroys ; hl
042383             0143*  set_bcd:
042383 73          0144*      ld (hl),e
042384 23          0145*      inc hl
042385 72          0146*      ld (hl),d
042386 23          0147*      inc hl
042387 71          0148*      ld (hl),c
042388 23          0149*      inc hl
042389 70          0150*      ld (hl),b
04238A C9          0151*      ret
04238B             0152*  
04238B             0153*  ; load bcd values from a scratch memory address to bcde
04238B             0154*  ; input: hl; scratch address
04238B             0155*  ; output: bcde; 8-place bcd number
04238B             0156*  ; destroys: hl
04238B             0157*  get_bcd:
04238B 5E          0158*      ld e,(hl)
04238C 23          0159*      inc hl
04238D 56          0160*      ld d,(hl)
04238E 23          0161*      inc hl
04238F 4E          0162*      ld c,(hl)
042390 23          0163*      inc hl
042391 46          0164*      ld b,(hl)
042392 C9          0165*      ret
042393             0166*  
042393             0167*  ; BCD addition
042393             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
042393             0169*  ;       a is the number of bytes holding each number (number of places/2)
042393             0170*  ; outputs: (hl) + (de) --> (hl)
042393             0171*  ; destroys: a,b,de,hl
042393             0172*  add_bcd:
042393 47          0173*      ld b,a ; loop counter
042394 AF          0174*      xor a ; reset a, clear carry flag
042395             0175*  adcec:
042395 1A          0176*      ld a,(de) ; addend to acc
042396 8E          0177*      adc a,(hl) ; add (hl) to acc
042397 27          0178*      daa ; adjust result to bcd
042398 77          0179*      ld (hl),a ; store result
042399 23          0180*      inc hl ; advance memory pointers
04239A 13          0181*      inc de
04239B 10 F8       0182*      djnz adcec ; loop until b == 0
04239D C9          0183*      ret
04239E             0184*  
04239E             0185*  ; BCD subtraction
04239E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04239E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04239E             0188*  ; outputs: (hl) - (de) --> (hl)
04239E             0189*  ; destroys: a,b,de,hl
04239E             0190*  sub_bcd:
04239E 47          0191*      ld b,a ; loop counter
04239F AF          0192*      xor a ; reset a,clear carry flag
0423A0             0193*  subdec:
0423A0 1A          0194*      ld a,(de) ; subtrahend to acc
0423A1 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0423A2 27          0196*      daa ; adjust result to bcd
0423A3 77          0197*      ld (hl),a ; store result
0423A4 23          0198*      inc hl ; advance memory pointers
0423A5 13          0199*      inc de
0423A6 10 F8       0200*      djnz subdec ; loop until b == 0
0423A8 C9          0201*      ret
0423A9             0202*  
0423A9             0203*  ; http://www.z80.info/pseudo-random.txt
0423A9             0204*  rand_8:
0423A9 C5          0205*      push bc
0423AA 3A BD 23 04 0206*      ld a,(r_seed)
0423AE 4F          0207*      ld c,a
0423AF             0208*  
0423AF 0F          0209*      rrca ; multiply by 32
0423B0 0F          0210*      rrca
0423B1 0F          0211*      rrca
0423B2 EE 1F       0212*      xor 0x1f
0423B4             0213*  
0423B4 81          0214*      add a,c
0423B5 DE FF       0215*      sbc a,255 ; carry
0423B7             0216*  
0423B7 32 BD 23 04 0217*      ld (r_seed),a
0423BB C1          0218*      pop bc
0423BC C9          0219*      ret
0423BD 50          0220*  r_seed: defb $50
0423BE             0059   	include "trig24fast.inc"
0423BE             0001*  
0423BE             0002*  ; convert signed angles from a 360 to 256 degree circle
0423BE             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0423BE             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0423BE             0005*  ; destroys: TODO
0423BE             0006*  deg_360_to_256:
0423BE D5          0007*  	push de ; preserve de
0423BF             0008*  ; make angle positive and store sign flag
0423BF CD F4 22 04 0009*  	call hlu_abs
0423C3 F5          0010*  	push af
0423C4             0011*  ; multiply by 256 first to keep precision
0423C4             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0423C4 29          0001*M         add hl,hl ; * 2
0423C5 29          0002*M         add hl,hl ; * 4
0423C6 29          0003*M         add hl,hl ; * 8
0423C7 29          0004*M         add hl,hl ; * 16
0423C8 29          0005*M         add hl,hl ; * 32
0423C9 29          0006*M         add hl,hl ; * 64
0423CA 29          0007*M         add hl,hl ; * 128
0423CB 29          0008*M         add hl,hl ; * 256
0423CC             0013*  ; divide uh.l by 360
0423CC 11 68 01 00 0014*  	ld de,360
0423D0 CD 64 2E 04 0015*  	call udiv24 ; ud.e = degrees / 360
0423D4 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0423D5             0017*  ; restore sign flag and adjust output accordingly
0423D5 F1          0018*  	pop af
0423D6 F2 DE 23 04 0019*  	jp p,@pos ; positive number
0423DA CD 04 23 04 0020*  	call neg_hlu
0423DE             0021*  @pos:
0423DE             0022*  ; restore de and return uh.l as the result
0423DE D1          0023*  	pop de
0423DF C9          0024*  	ret
0423E0             0025*  
0423E0             0026*  ; fixed 16.8 routine
0423E0             0027*  ; cos(uh.l) --> uh.l
0423E0             0028*  ; destroys: f, hl
0423E0             0029*  cos168:
0423E0 D5          0030*      push de ; preserve de
0423E1             0031*  ; for cos we simply increment the angle by 90 degrees
0423E1             0032*  ; or 0x004000 in 16.8 degrees256
0423E1             0033*  ; which makes it a sin problem
0423E1 11 00 40 00 0034*      ld de,0x004000
0423E5 19          0035*      add hl,de ; modulo 256 happens below
0423E6 D1          0036*      pop de ; restore de
0423E7             0037*  ; fall through to sin168
0423E7             0038*  
0423E7             0039*  ; ---------------------
0423E7             0040*  ; fixed 16.8 routine
0423E7             0041*  ; sin(uh.l) --> uh.l
0423E7             0042*  ; destroys: f, hl
0423E7             0043*  sin168:
0423E7 D5          0044*  	push de
0423E8             0045*  ; handle negative angles appropriately
0423E8 CD F4 22 04 0046*  	call hlu_abs
0423EC F2 F5 23 04 0047*  	jp p,@F
0423F0 11 00 00 FF 0048*  	ld de,-256*256
0423F4 19          0049*  	add hl,de
0423F5             0050*  @@:
0423F5 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
0423F7 ED 6C       0052*      mlt hl
0423F9 11 2F 26 04 0053*      ld de,sin_lut_168 ; grab the lut address
0423FD 19          0054*      add hl,de ; bump hl by the index
0423FE ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
042400 D1          0056*      pop de
042401 C9          0057*      ret
042402             0058*  
042402             0059*  ; 16.8 fixed inputs / outputs
042402             0060*  ; takes: uh.l as angle in degrees 256
042402             0061*  ;        ud.e as radius
042402             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
042402             0063*  ;        displacements from origin (0,0)
042402             0064*  ; destroys: everything except indexes
042402             0065*  polar_to_cartesian:
042402             0066*  ; back up input parameters
042402 22 31 24 04 0067*      ld (@angle), hl
042406 ED 53 34 24 0068*      ld (@radius), de
       04          
04240B             0069*  ; compute dx = sin(uh.l) * ud.e
04240B CD E7 23 04 0070*      call sin168 ; uh.l = sin(uh.l)
04240F ED 5B 34 24 0071*  	ld de,(@radius)
       04          
042414 CD D9 2D 04 0072*  	call smul168 ; uh.l = dx
042418 E5          0073*      push hl
042419             0074*  ; compute dy = -cos(uh.l) * ud.e
042419 2A 31 24 04 0075*      ld hl,(@angle)
04241D CD E0 23 04 0076*      call cos168 ; uh.l = cos(uh.l)
042421 ED 5B 34 24 0077*      ld de,(@radius)
       04          
042426 CD D9 2D 04 0078*      call smul168    ; uh.l = dy
04242A CD 04 23 04 0079*      call neg_hlu ; invert dy for screen coords convention
04242E EB          0080*      ex de,hl       ; de = dy for output
04242F C1          0081*      pop bc          ; bc = dx for output
042430             0082*  ; and out
042430 C9          0083*      ret
042431             0084*  @angle: ds 3
042434             0085*  @radius: ds 3
042437             0086*  
042437             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042437             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042437             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042437             0090*  ;         also populates scratch locations dx168 and dy168
042437             0091*  ; destroys: a,hl,bc,de
042437             0092*  dxy168:
042437             0093*  ; compute dx = x1-x0
042437 AF          0094*      xor a ; clear carry
042438 DD E5       0095*      push ix ; move ix to hl via the stack
04243A E1          0096*      pop hl ; hl = x1
04243B ED 42       0097*      sbc hl,bc ; hl = dx
04243D 22 52 24 04 0098*      ld (dx168),hl ; dx to scratch
042441             0099*  ; compute dy = y1-y0
042441 AF          0100*      xor a ; clear carry
042442 FD E5       0101*      push iy ; move iy to hl via the stack
042444 E1          0102*      pop hl ; hl = y1
042445 ED 52       0103*      sbc hl,de ; hl = dy
042447 22 58 24 04 0104*      ld (dy168),hl ; dy to scratch
04244B             0105*  ; populate output registers and return
04244B EB          0106*      ex de,hl        ; ud.e = dy
04244C ED 4B 52 24 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
042451 C9          0108*      ret
042452 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
042458 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
04245E             0111*  
04245E             0112*  ; compute the euclidian distance between two cartesian coordinates
04245E             0113*  ; using the formula d = sqrt(dx^2+dy^2
04245E             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04245E             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04245E             0116*  ; output; uh.l is the 16.8 fixed format distance
04245E             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
04245E             0118*  ; destroys: a,hl,bc,de
04245E             0119*  distance168:
04245E CD 37 24 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
042462             0121*  ; compute dy^2
042462 EB          0122*  	ex de,hl
042463 CD F4 22 04 0123*  	call hlu_abs
042467 E5          0124*  	push hl
042468 D1          0125*  	pop de
042469 CD D1 2D 04 0126*  	call umul168 ; hl = dy^2
04246D E5          0127*  	push hl ; save dy^2
04246E             0128*  ; compute dx^2
04246E 2A 52 24 04 0129*  	ld hl,(dx168)
042472 CD F4 22 04 0130*  	call hlu_abs
042476 E5          0131*  	push hl
042477 D1          0132*  	pop de
042478 CD D1 2D 04 0133*  	call umul168 ; hl = dx^2
04247C             0134*  ; add dx^2 and dy^2
04247C D1          0135*  	pop de ; de = dy^2
04247D 19          0136*  	add hl,de ; hl = dx^2 + dy^2
04247E             0137*  ; compute the square root
04247E CD 44 25 04 0138*  	call sqrt168
042482 C9          0139*  	ret
042483             0140*  
042483             0141*  ; atan2_(ub.c,ud.e) --> uh.l
042483             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042483             0143*  ;   whether inputs are integers or fractional doesn't matter
042483             0144*  ;   so long as the sign bit of the upper byte is correct
042483             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
042483             0146*  ; angles are COMPASS HEADINGS based on
042483             0147*  ; screen coordinate conventions,where the y axis is flipped
042483             0148*  ; #E0 315      0       45 #20
042483             0149*  ;        -x,-y | +x,-y
042483             0150*  ; #C0 270------+------ 90 #40
042483             0151*  ;        -x,+y | +x,+y
042483             0152*  ; #A0 225   180 #80   135 #60
042483             0153*  atan2_168fast:
042483             0154*  ; get signs and make everything positive
042483             0155*  ; get abs(x) and store its original sign
042483 C5          0156*      push bc
042484 E1          0157*      pop hl
042485 CD F4 22 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
042489 E5          0159*      push hl ; store abs(x)
04248A C1          0160*      pop bc ; bc = abs(x)
04248B F5          0161*      push af ; store sign of x
04248C             0162*  ; get abs(y) and store its original sign
04248C EB          0163*      ex de,hl ; hl = y
04248D CD F4 22 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
042491 EB          0165*      ex de,hl ; de = abs(y)
042492 F5          0166*      push af ; store sign of y
042493             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
042493             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
042493 AF          0169*      xor a ; clear the carry flag
042494 D5          0170*      push de
042495 E1          0171*      pop hl
042496 ED 42       0172*      sbc hl,bc
042498 F5          0173*      push af ; save sign of de - bc
042499 F2 A2 24 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
04249D             0175*  ; otherwise we swap bc and de
04249D C5          0176*      push bc
04249E E1          0177*      pop hl
04249F EB          0178*      ex de,hl
0424A0 E5          0179*      push hl
0424A1 C1          0180*      pop bc
0424A2             0181*  @1:
0424A2             0182*  ; now we're ready to snag our preliminary result
0424A2 C5          0183*  	push bc
0424A3 E1          0184*  	pop hl
0424A4 CD 12 25 04 0185*      call atan_168fast ; uh.l comes back with prelim result
0424A8             0186*  ; now we adjust uh.l based on sign of de - bc
0424A8 F1          0187*      pop af
0424A9 F2 B5 24 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
0424AD EB          0189*      ex de,hl
0424AE 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
0424B2 AF          0191*      xor a ; clear the carry flag
0424B3 ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
0424B5             0193*  @2:
0424B5             0194*  ; now the fun part of adjusting the result
0424B5             0195*  ; based on which quadrant (x,y) is in
0424B5             0196*  ; #E0 315      0       45 #20
0424B5             0197*  ;        -x,-y | +x,-y
0424B5             0198*  ; #C0 270------+------ 90 #40
0424B5             0199*  ;        -x,+y | +x,+y
0424B5             0200*  ; #A0 225   180 #80   135 #60
0424B5 F1          0201*      pop af ; sign of y
0424B6 CA F3 24 04 0202*      jp z,@y_zero
0424BA F2 D3 24 04 0203*      jp p,@y_pos
0424BE             0204*  ; y neg,check x
0424BE F1          0205*      pop af ; sign of x
0424BF CA CD 24 04 0206*      jp z,@y_neg_x_zero
0424C3 F2 D2 24 04 0207*      jp p,@y_neg_x_pos
0424C7             0208*  ; y neg,x neg
0424C7             0209*  ; angle is 270-360
0424C7             0210*  ; negating the intermediate does the trick
0424C7 CD 04 23 04 0211*      call neg_hlu
0424CB 18 31       0212*      jr @zero_hlu
0424CD             0213*  
0424CD             0214*  @y_neg_x_zero:
0424CD             0215*  ; y neg,x zero
0424CD             0216*  ; angle is 0
0424CD 21 00 00 00 0217*      ld hl,0
0424D1 C9          0218*      ret
0424D2             0219*  @y_neg_x_pos:
0424D2             0220*  ; y neg,x pos
0424D2             0221*  ; angle is 0 to 90
0424D2             0222*  ; so we're good
0424D2 C9          0223*      ret
0424D3             0224*  
0424D3             0225*  @y_pos:
0424D3 F1          0226*      pop af ; sign of x
0424D4 CA E3 24 04 0227*      jp z,@y_pos_x_zero
0424D8 F2 E8 24 04 0228*      jp p,@y_pos_x_pos
0424DC             0229*  ; y pos,x neg
0424DC             0230*  ; angle is 180-270
0424DC             0231*  ; so we add 180 to intermediate
0424DC 11 00 80 00 0232*      ld de,0x008000
0424E0 19          0233*      add hl,de
0424E1 18 1B       0234*      jr @zero_hlu
0424E3             0235*  @y_pos_x_zero:
0424E3             0236*  ; y pos,x zero
0424E3             0237*  ; angle is 180
0424E3 21 00 80 00 0238*      ld hl,0x008000
0424E7 C9          0239*      ret
0424E8             0240*  @y_pos_x_pos:
0424E8             0241*  ; y pos,x pos
0424E8             0242*  ; angle is 90-180
0424E8             0243*  ; neg the intermediate and add 180 degrees
0424E8 CD 04 23 04 0244*      call neg_hlu
0424EC 11 00 80 00 0245*      ld de,0x008000
0424F0 19          0246*      add hl,de
0424F1 18 0B       0247*      jr @zero_hlu
0424F3             0248*  
0424F3             0249*  @y_zero:
0424F3 F1          0250*      pop af ; sign of x
0424F4 FA F9 24 04 0251*      jp m,@y_zero_x_neg
0424F8             0252*  ; y zero,x pos
0424F8             0253*  ; angle is 90,nothing to do
0424F8 C9          0254*      ret
0424F9             0255*  @y_zero_x_neg:
0424F9             0256*  ; y zero ,x neg
0424F9             0257*  ; angle is 270
0424F9 21 00 C0 00 0258*      ld hl,0x00C000
0424FD C9          0259*      ret
0424FE             0260*  @zero_hlu:
0424FE AF          0261*      xor a
0424FF 22 0C 25 04 0262*      ld (@scratch),hl
042503 32 0E 25 04 0263*      ld (@scratch+2),a
042507 2A 0C 25 04 0264*      ld hl,(@scratch)
04250B C9          0265*      ret
04250C             0266*  @scratch: ds 6
042512             0267*  
042512             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
042512             0269*  ; output: uh.l is the 16.8 fixed format angle
042512             0270*  ; destroys: a,hl,bc,de
042512             0271*  ; the following note was written by github copilot:
042512             0272*  ; note: this routine is a bit of a hack
042512             0273*  ;      but it works
042512             0274*  ;      and it's fast
042512             0275*  ;      and it's small
042512             0276*  ;      and it's accurate
042512             0277*  ;      and it's easy to understand
042512             0278*  ;      and it's easy to modify
042512             0279*  ;      and it's easy to use
042512             0280*  ;      and it's easy to remember
042512             0281*  ;      and it's easy to love
042512             0282*  ;      and it's easy to hate
042512             0283*  ;      and it's easy to ignore
042512             0284*  ;      and it's easy to forget
042512             0285*  ;      and it's easy to remember
042512             0286*  ;      and it's easy to forget
042512             0287*  ;      and it's easy to remember
042512             0288*  ;      (ok the bot is stuck in a loop)
042512             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
042512             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
042512             0291*  atan_168fast:
042512             0292*  ; because we use compass headings instead of geometric angles
042512             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
042512             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
042512 CD FC 2D 04 0295*  	call udiv168 ; ud.e = dx/dy
042516 EB          0296*  	ex de,hl ; uh.l = dx/dy
042517             0297*  ; test uh.l for 0
042517 19          0298*      add hl,de
042518 B7          0299*      or a
042519 ED 52       0300*      sbc hl,de
04251B 28 22       0301*      jr z,@is_zero
04251D             0302*  ; test uh.l for 1
04251D AF          0303*      xor a ; clear carry
04251E EB          0304*      ex de,hl
04251F 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
042523 ED 52       0306*      sbc hl,de
042525 28 13       0307*      jr z,@is_45
042527 EB          0308*  	ex de,hl
042528             0309*  ; no special cases so we move on
042528             0310*  ; l contains the fractional portion of tan(uh.l)
042528             0311*  ; we multiply it by three to get our lookup table index
042528 26 03       0312*      ld h,3
04252A ED 6C       0313*      mlt hl ; gosh that is handy
04252C 11 00 00 00 0314*      ld de,0 ; clear deu
042530 54          0315*      ld d,h ; copy hl to de
042531 5D          0316*      ld e,l ; de contains our index
042532 21 32 29 04 0317*      ld hl,atan_lut_168 ; grab the lut address
042536 19          0318*      add hl,de ; bump hl by the index
042537 ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
042539 C9          0320*      ret ; and out
04253A             0321*  @is_45:
04253A 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
04253E C9          0323*      ret
04253F             0324*  ; for the case tan(0)
04253F             0325*  @is_zero:
04253F 21 00 00 00 0326*      ld hl,0x000000
042543 C9          0327*      ret
042544             0328*  
042544             0329*  ; Expects  ADL mode
042544             0330*  ; Inputs:  UH.L
042544             0331*  ; Outputs: UH.L is the 16.8 square root
042544             0332*  ;          UD.E is the difference inputHL-DE^2
042544             0333*  ;          c flag reset
042544             0334*  sqrt168:
042544 CD 4E 25 04 0335*      call sqrt24
042548 EB          0336*      ex de,hl
042549 29          0337*      add hl,hl
04254A 29          0338*      add hl,hl
04254B 29          0339*      add hl,hl
04254C 29          0340*      add hl,hl
04254D C9          0341*      ret
04254E             0342*  
04254E             0343*  ; Expects  ADL mode
04254E             0344*  ; Inputs:  HL
04254E             0345*  ; Outputs: DE is the integer square root
04254E             0346*  ;          HL is the difference inputHL-DE^2
04254E             0347*  ;          c flag reset
04254E             0348*  sqrt24:
04254E AF          0349*      xor a
04254F 45          0350*      ld b,l
042550 C5          0351*      push bc
042551 47          0352*      ld b,a
042552 57          0353*      ld d,a
042553 4F          0354*      ld c,a
042554 6F          0355*      ld l,a
042555 5F          0356*      ld e,a
042556             0357*  
042556             0358*      ;Iteration 1
042556 29          0359*      add hl,hl
042557 CB 11       0360*      rl c
042559 29          0361*      add hl,hl
04255A CB 11       0362*      rl c
04255C 91          0363*      sub c
04255D 30 04       0364*      jr nc,$+6
04255F 1C          0365*      inc e
042560 1C          0366*      inc e
042561 2F          0367*      cpl
042562 4F          0368*      ld c,a
042563             0369*  
042563             0370*      ;Iteration 2
042563 29          0371*      add hl,hl
042564 CB 11       0372*      rl c
042566 29          0373*      add hl,hl
042567 CB 11       0374*      rl c
042569 CB 13       0375*      rl e
04256B 7B          0376*      ld a,e
04256C 91          0377*      sub c
04256D 30 04       0378*      jr nc,$+6
04256F 1C          0379*      inc e
042570 1C          0380*      inc e
042571 2F          0381*      cpl
042572 4F          0382*      ld c,a
042573             0383*  
042573             0384*      ;Iteration 3
042573 29          0385*      add hl,hl
042574 CB 11       0386*      rl c
042576 29          0387*      add hl,hl
042577 CB 11       0388*      rl c
042579 CB 13       0389*      rl e
04257B 7B          0390*      ld a,e
04257C 91          0391*      sub c
04257D 30 04       0392*      jr nc,$+6
04257F 1C          0393*      inc e
042580 1C          0394*      inc e
042581 2F          0395*      cpl
042582 4F          0396*      ld c,a
042583             0397*  
042583             0398*      ;Iteration 4
042583 29          0399*      add hl,hl
042584 CB 11       0400*      rl c
042586 29          0401*      add hl,hl
042587 CB 11       0402*      rl c
042589 CB 13       0403*      rl e
04258B 7B          0404*      ld a,e
04258C 91          0405*      sub c
04258D 30 04       0406*      jr nc,$+6
04258F 1C          0407*      inc e
042590 1C          0408*      inc e
042591 2F          0409*      cpl
042592 4F          0410*      ld c,a
042593             0411*  
042593             0412*      ;Iteration 5
042593 29          0413*      add hl,hl
042594 CB 11       0414*      rl c
042596 29          0415*      add hl,hl
042597 CB 11       0416*      rl c
042599 CB 13       0417*      rl e
04259B 7B          0418*      ld a,e
04259C 91          0419*      sub c
04259D 30 04       0420*      jr nc,$+6
04259F 1C          0421*      inc e
0425A0 1C          0422*      inc e
0425A1 2F          0423*      cpl
0425A2 4F          0424*      ld c,a
0425A3             0425*  
0425A3             0426*      ;Iteration 6
0425A3 29          0427*      add hl,hl
0425A4 CB 11       0428*      rl c
0425A6 29          0429*      add hl,hl
0425A7 CB 11       0430*      rl c
0425A9 CB 13       0431*      rl e
0425AB 7B          0432*      ld a,e
0425AC 91          0433*      sub c
0425AD 30 04       0434*      jr nc,$+6
0425AF 1C          0435*      inc e
0425B0 1C          0436*      inc e
0425B1 2F          0437*      cpl
0425B2 4F          0438*      ld c,a
0425B3             0439*  
0425B3             0440*      ;Iteration 7
0425B3 29          0441*      add hl,hl
0425B4 CB 11       0442*      rl c
0425B6 29          0443*      add hl,hl
0425B7 CB 11       0444*      rl c
0425B9 CB 10       0445*      rl b
0425BB EB          0446*      ex de,hl
0425BC 29          0447*      add hl,hl
0425BD E5          0448*      push hl
0425BE ED 42       0449*      sbc hl,bc
0425C0 30 06       0450*      jr nc,$+8
0425C2 7C          0451*      ld a,h
0425C3 2F          0452*      cpl
0425C4 47          0453*      ld b,a
0425C5 7D          0454*      ld a,l
0425C6 2F          0455*      cpl
0425C7 4F          0456*      ld c,a
0425C8 E1          0457*      pop hl
0425C9 30 02       0458*      jr nc,$+4
0425CB 23          0459*      inc hl
0425CC 23          0460*      inc hl
0425CD EB          0461*      ex de,hl
0425CE             0462*  
0425CE             0463*      ;Iteration 8
0425CE 29          0464*      add hl,hl
0425CF 69          0465*      ld l,c
0425D0 60          0466*      ld h,b
0425D1 ED 6A       0467*      adc hl,hl
0425D3 ED 6A       0468*      adc hl,hl
0425D5 EB          0469*      ex de,hl
0425D6 29          0470*      add hl,hl
0425D7 ED 52       0471*      sbc hl,de
0425D9 19          0472*      add hl,de
0425DA EB          0473*      ex de,hl
0425DB 30 04       0474*      jr nc,$+6
0425DD ED 52       0475*      sbc hl,de
0425DF 13          0476*      inc de
0425E0 13          0477*      inc de
0425E1             0478*  
0425E1             0479*      ;Iteration 9
0425E1 F1          0480*      pop af
0425E2 17          0481*      rla
0425E3 ED 6A       0482*      adc hl,hl
0425E5 17          0483*      rla
0425E6 ED 6A       0484*      adc hl,hl
0425E8 EB          0485*      ex de,hl
0425E9 29          0486*      add hl,hl
0425EA ED 52       0487*      sbc hl,de
0425EC 19          0488*      add hl,de
0425ED EB          0489*      ex de,hl
0425EE 30 04       0490*      jr nc,$+6
0425F0 ED 52       0491*      sbc hl,de
0425F2 13          0492*      inc de
0425F3 13          0493*      inc de
0425F4             0494*  
0425F4             0495*      ;Iteration 10
0425F4 17          0496*      rla
0425F5 ED 6A       0497*      adc hl,hl
0425F7 17          0498*      rla
0425F8 ED 6A       0499*      adc hl,hl
0425FA EB          0500*      ex de,hl
0425FB 29          0501*      add hl,hl
0425FC ED 52       0502*      sbc hl,de
0425FE 19          0503*      add hl,de
0425FF EB          0504*      ex de,hl
042600 30 04       0505*      jr nc,$+6
042602 ED 52       0506*      sbc hl,de
042604 13          0507*      inc de
042605 13          0508*      inc de
042606             0509*  
042606             0510*      ;Iteration 11
042606 17          0511*      rla
042607 ED 6A       0512*      adc hl,hl
042609 17          0513*      rla
04260A ED 6A       0514*      adc hl,hl
04260C EB          0515*      ex de,hl
04260D 29          0516*      add hl,hl
04260E ED 52       0517*      sbc hl,de
042610 19          0518*      add hl,de
042611 EB          0519*      ex de,hl
042612 30 04       0520*      jr nc,$+6
042614 ED 52       0521*      sbc hl,de
042616 13          0522*      inc de
042617 13          0523*      inc de
042618             0524*  
042618             0525*      ;Iteration 11
042618 17          0526*      rla
042619 ED 6A       0527*      adc hl,hl
04261B 17          0528*      rla
04261C ED 6A       0529*      adc hl,hl
04261E EB          0530*      ex de,hl
04261F 29          0531*      add hl,hl
042620 ED 52       0532*      sbc hl,de
042622 19          0533*      add hl,de
042623 EB          0534*      ex de,hl
042624 30 04       0535*      jr nc,$+6
042626 ED 52       0536*      sbc hl,de
042628 13          0537*      inc de
042629 13          0538*      inc de
04262A             0539*  
04262A CB 1A       0540*      rr d
04262C CB 1B       0541*      rr e
04262E C9          0542*      ret
04262F             0543*  
04262F             0544*  sin_lut_168:
04262F 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
042632 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
042635 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
042638 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
04263B 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
04263E 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
042641 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
042644 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
042647 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
04264A 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
04264D 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
042650 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
042653 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
042656 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
042659 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
04265C 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
04265F 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
042662 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
042665 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
042668 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
04266B 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
04266E 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
042671 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
042674 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
042677 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
04267A 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
04267D 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
042680 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
042683 A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
042686 A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
042689 AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
04268C B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
04268F B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
042692 B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
042695 BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
042698 C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
04269B C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
04269E C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
0426A1 CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
0426A4 D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
0426A7 D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
0426AA D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
0426AD DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
0426B0 DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
0426B3 E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
0426B6 E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
0426B9 E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
0426BC EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
0426BF EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
0426C2 EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
0426C5 F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
0426C8 F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
0426CB F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
0426CE F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
0426D1 F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
0426D4 F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
0426D7 FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
0426DA FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
0426DD FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
0426E0 FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
0426E3 FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
0426E6 FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
0426E9 FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
0426EC FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
0426EF 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
0426F2 FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
0426F5 FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
0426F8 FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
0426FB FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
0426FE FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
042701 FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
042704 FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
042707 FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
04270A F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
04270D F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
042710 F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
042713 F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
042716 F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
042719 F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
04271C EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
04271F EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
042722 EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
042725 E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
042728 E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
04272B E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
04272E DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
042731 DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
042734 D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
042737 D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
04273A D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
04273D CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
042740 C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
042743 C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
042746 C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
042749 BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
04274C B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
04274F B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
042752 B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
042755 AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
042758 A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
04275B A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
04275E 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
042761 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
042764 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
042767 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
04276A 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
04276D 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
042770 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
042773 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
042776 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
042779 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
04277C 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
04277F 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
042782 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
042785 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
042788 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
04278B 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
04278E 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
042791 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
042794 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
042797 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
04279A 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
04279D 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
0427A0 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
0427A3 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
0427A6 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
0427A9 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
0427AC 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
0427AF 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
0427B2 FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
0427B5 F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0427B8 EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
0427BB E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0427BE E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0427C1 DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
0427C4 D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0427C7 CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
0427CA C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0427CD C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0427D0 BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0427D3 B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0427D6 B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0427D9 AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0427DC A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0427DF 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
0427E2 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
0427E5 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
0427E8 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
0427EB 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
0427EE 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
0427F1 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
0427F4 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
0427F7 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
0427FA 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
0427FD 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042800 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042803 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
042806 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042809 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04280C 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
04280F 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042812 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
042815 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
042818 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04281B 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
04281E 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042821 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
042824 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
042827 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04282A 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
04282D 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042830 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042833 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
042836 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
042839 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04283C 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
04283F 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042842 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
042845 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
042848 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04284B 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
04284E 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042851 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042854 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
042857 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
04285A 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
04285D 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042860 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042863 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
042866 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042869 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04286C 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
04286F 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042872 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
042875 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
042878 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04287B 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04287E 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042881 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042884 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042887 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04288A 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04288D 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
042890 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042893 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042896 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042899 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04289C 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
04289F 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0428A2 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0428A5 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0428A8 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0428AB 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0428AE 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0428B1 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0428B4 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0428B7 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0428BA 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0428BD 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0428C0 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0428C3 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0428C6 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0428C9 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0428CC 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0428CF 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0428D2 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0428D5 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0428D8 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0428DB 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0428DE 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0428E1 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0428E4 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0428E7 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0428EA 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0428ED 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0428F0 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0428F3 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0428F6 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0428F9 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0428FC 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0428FF 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042902 A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
042905 AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
042908 B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04290B B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
04290E BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042911 C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042914 C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
042917 CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04291A D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04291D DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042920 E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
042923 E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
042926 EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
042929 F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
04292C FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
04292F 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042932             0802*  
042932             0803*  atan_lut_168:
042932 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
042935 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
042938 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
04293B 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
04293E A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
042941 CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
042944 F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
042947 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
04294A 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
04294D 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
042950 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
042953 BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
042956 E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
042959 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
04295C 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
04295F 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
042962 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
042965 B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
042968 DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
04296B 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
04296E 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
042971 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
042974 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
042977 A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
04297A CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
04297D F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
042980 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
042983 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
042986 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
042989 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
04298C C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
04298F E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
042992 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
042995 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
042998 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
04299B 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
04299E B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
0429A1 D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
0429A4 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
0429A7 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
0429AA 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
0429AD 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
0429B0 A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
0429B3 C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
0429B6 EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
0429B9 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
0429BC 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
0429BF 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
0429C2 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
0429C5 B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
0429C8 DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
0429CB 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
0429CE 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
0429D1 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
0429D4 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
0429D7 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
0429DA C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
0429DD ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
0429E0 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
0429E3 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
0429E6 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
0429E9 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
0429EC AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
0429EF D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
0429F2 FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
0429F5 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
0429F8 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
0429FB 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
0429FE 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
042A01 BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
042A04 E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
042A07 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
042A0A 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
042A0D 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
042A10 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
042A13 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
042A16 C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
042A19 E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
042A1C 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
042A1F 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
042A22 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
042A25 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
042A28 A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
042A2B C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
042A2E EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
042A31 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
042A34 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
042A37 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
042A3A 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
042A3D A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
042A40 C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
042A43 EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
042A46 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
042A49 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
042A4C 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
042A4F 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
042A52 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
042A55 C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
042A58 E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
042A5B 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
042A5E 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
042A61 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
042A64 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
042A67 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
042A6A B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
042A6D DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
042A70 FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
042A73 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
042A76 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
042A79 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
042A7C 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
042A7F AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
042A82 CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
042A85 EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
042A88 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
042A8B 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
042A8E 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
042A91 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
042A94 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
042A97 BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
042A9A DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
042A9D FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
042AA0 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
042AA3 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
042AA6 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
042AA9 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
042AAC A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
042AAF C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
042AB2 E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
042AB5 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
042AB8 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
042ABB 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
042ABE 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
042AC1 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
042AC4 A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
042AC7 C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
042ACA E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
042ACD 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
042AD0 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
042AD3 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
042AD6 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
042AD9 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
042ADC A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
042ADF C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
042AE2 E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
042AE5 FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
042AE8 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
042AEB 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
042AEE 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
042AF1 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
042AF4 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
042AF7 B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
042AFA D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
042AFD F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
042B00 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
042B03 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
042B06 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
042B09 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
042B0C 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
042B0F A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
042B12 C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
042B15 DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
042B18 FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
042B1B 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
042B1E 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
042B21 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
042B24 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
042B27 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
042B2A A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
042B2D C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
042B30 E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
042B33 FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
042B36 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
042B39 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
042B3C 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
042B3F 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
042B42 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
042B45 A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
042B48 C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
042B4B DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
042B4E F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
042B51 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
042B54 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
042B57 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
042B5A 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
042B5D 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
042B60 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
042B63 B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
042B66 CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
042B69 E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
042B6C 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
042B6F 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
042B72 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
042B75 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
042B78 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
042B7B 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
042B7E 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
042B81 B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
042B84 D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
042B87 EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
042B8A 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
042B8D 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
042B90 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
042B93 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
042B96 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
042B99 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
042B9C 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
042B9F B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
042BA2 CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
042BA5 E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
042BA8 FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
042BAB 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
042BAE 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
042BB1 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
042BB4 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
042BB7 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
042BBA 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
042BBD A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
042BC0 BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
042BC3 D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
042BC6 EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
042BC9 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
042BCC 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
042BCF 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
042BD2 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
042BD5 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
042BD8 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
042BDB 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
042BDE A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
042BE1 BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
042BE4 D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
042BE7 E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
042BEA FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
042BED 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
042BF0 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
042BF3 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
042BF6 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
042BF9 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
042BFC 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
042BFF 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
042C02 AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
042C05 C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
042C08 DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
042C0B F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
042C0E 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
042C11 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
042C14 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
042C17 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
042C1A 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
042C1D 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
042C20 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
042C23 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
042C26 AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
042C29 C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
042C2C D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
042C2F EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
042C32 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042C35             0060   	include "fixed24.inc"
042C35             0001*  arith24uaf: ds 6
042C3B             0002*  arith24uhl: ds 6
042C41             0003*  arith24ubc: ds 6
042C47             0004*  arith24ude: ds 6
042C4D             0005*  arith24uix: ds 6
042C53             0006*  arith24uiy: ds 6
042C59             0007*  arith24usp: ds 6
042C5F             0008*  arith24upc: ds 6
042C65             0009*  
042C65             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042C65             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042C65             0012*  ; inputs: hlu = 24-bit number to shift
042C65             0013*  ;         a = signed number of bits to shift
042C65             0014*  ;         ix = output buffer address
042C65             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042C65             0016*  shift_hlu:
042C65 C5          0017*      push bc ; preserve
042C66 47          0018*      ld b,a            ; store shift value in b for later
042C67             0019*  
042C67             0020*  ; Initialize DE to zero and clear output buffer
042C67 11 00 00 00 0021*      ld de, 0
042C6B DD 1F FD    0022*      ld (ix-3), de
042C6E DD 1F 03    0023*      ld (ix+3), de
042C71             0024*  
042C71             0025*  ; Get absolute value of a and save its original sign
042C71 B7          0026*      or a
042C72 F5          0027*      push af ; save sign flag
042C73 F2 79 2C 04 0028*      jp p,@F ; If a is positive do nothing
042C77 ED 44       0029*      neg ; If a is negative, negate it
042C79             0030*  @@:
042C79             0031*  
042C79             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042C79 CD F4 22 04 0033*      call hlu_abs
042C7D F5          0034*      push af ; save sign of HLU
042C7E DD 2F 00    0035*      ld (ix), hl
042C81             0036*  
042C81             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042C81 78          0038*      ld a,b            ; Restore original shift value into 'a'
042C82 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042C84 CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042C86 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042C88 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042C89             0043*  
042C89             0044*  ; Calculate remainder of a (original shift) mod 8
042C89 E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042C8B 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042C8C 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042C90             0048*  
042C90             0049*  ; Get back the original sign of the byte shift
042C90 F1          0050*      pop af            ; Restore sign flag
042C91 F2 9F 2C 04 0051*      jp p,@F           ; If a was positive, we're done
042C95 79          0052*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042C96 ED 44       0053*      neg               ; Negate the number of whole bytes to shift
042C98 3D          0054*      dec a             ; Subtract 1 because that's just how this works
042C99 4F          0055*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042C9A 1B          0056*      dec de            ; DE = -1 to make the signed addition below work
042C9B 3E 08       0057*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042C9D 90          0058*      sub b
042C9E 47          0059*      ld b,a            ; b is the number of bits to shift back up
042C9F             0060*  
042C9F             0061*  @@:
042C9F             0062*  
042C9F             0063*  ; Add the byte offset to the base address of output buffer
042C9F 59          0064*      ld e,c            ; DEU and D were properly signed above
042CA0 DD 19       0065*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042CA2             0066*  
042CA2             0067*  ; Read the byte-aligned result into HL and shift in the required number of bits
042CA2 DD 27 00    0068*      ld hl,(ix)        ; Byte-aligned result
042CA5             0069*  
042CA5             0070*  ; Check whether we're already byte-aligned
042CA5 AF          0071*      xor a
042CA6 B0          0072*      or b
042CA7 28 08       0073*      jr z,@end         ; If no bits to shift, we're done
042CA9             0074*  
042CA9             0075*  ; Otherwise shiften zee bitzen
042CA9 DD 7E FF    0076*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042CAC             0077*  @loop:
042CAC 07          0078*      rlca              ; One bit to carry
042CAD             0079*  
042CAD ED 6A       0080*      adc hl,hl         ; Shift the carry into the result
042CAF             0081*  
042CAF 10 FB       0082*      djnz @loop        ; Loop until all bits are shifted up
042CB1             0083*  
042CB1             0084*  @end:
042CB1             0085*  
042CB1             0086*  ; get back HLU's original sign and negate if necessary
042CB1 F1          0087*      pop af
042CB2 F2 BA 2C 04 0088*      jp p,@F
042CB6 CD 04 23 04 0089*      call neg_hlu
042CBA             0090*  @@:
042CBA             0091*  ; return the result
042CBA DD 2F 00    0092*      ld (ix),hl        ; Store the shifted result
042CBD C1          0093*      pop bc              ; Restore BC
042CBE C9          0094*      ret
042CBF             0095*  
042CBF             0096*  ; operation: UHL * UDE --> UHL
042CBF             0097*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042CBF             0098*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042CBF             0099*  ; inputs: hl = 24-bit number, de = 24-bit number,
042CBF             0100*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042CBF             0101*  ; outputs: umulfxout = 48-bit intermediate
042CBF             0102*  ; destroys: af, hl, bc, de
042CBF             0103*  umulfx:
042CBF DD E5       0104*      push ix ; preserve
042CC1 F5          0105*      push af ; need later
042CC2             0106*  
042CC2             0107*  ; do the multiplication
042CC2 CD 79 2D 04 0108*      call umul24x24
042CC6             0109*  
042CC6             0110*  ; shift the result to the required output precision
042CC6 78          0111*      ld a,b
042CC7 81          0112*      add a,c ; a is left shift from the multiplication
042CC8 C1          0113*      pop bc ; b is the output precision (was a)
042CC9 90          0114*      sub b ; a is the net shift of the output
042CCA             0115*  
042CCA             0116*  ; Get absolute value of a and save its original sign
042CCA B7          0117*      or a
042CCB F5          0118*      push af ; save sign flag
042CCC F2 D2 2C 04 0119*      jp p,@F ; If a is positive do nothing
042CD0 ED 44       0120*      neg ; If a is negative, negate it
042CD2             0121*  @@:
042CD2             0122*  
042CD2             0123*  ; Divide a by 8 to get the whole byte shift and bit remainder
042CD2 47          0124*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042CD3 CB 3F       0125*      srl a             ; a = a / 2 (shift right 1 bit)
042CD5 CB 3F       0126*      srl a             ; a = a / 4 (shift right another bit)
042CD7 CB 3F       0127*      srl a             ; a = a / 8 (final shift for division by 8)
042CD9 4F          0128*      ld c,a            ; c holds the number of whole bytes to shift
042CDA             0129*  
042CDA             0130*  ; Calculate remainder of a (original shift) mod 8
042CDA 78          0131*      ld a,b            ; Restore original shift value into 'a'
042CDB E6 07       0132*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042CDD 47          0133*      ld b,a            ; 'b' now holds the number of bits to shift back up
042CDE 11 00 00 00 0134*      ld de,0           ; Clear deu for computing the offset address later
042CE2             0135*  
042CE2             0136*  ; Get back the original sign of the byte shift
042CE2 F1          0137*      pop af            ; Restore sign flag
042CE3 F2 F1 2C 04 0138*      jp p,@F           ; If a was positive, we're done
042CE7 79          0139*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042CE8 ED 44       0140*      neg               ; Negate the number of whole bytes to shift
042CEA 3D          0141*      dec a             ; Subtract 1 because that's just how this works
042CEB 4F          0142*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042CEC 1B          0143*      dec de            ; DE = -1 to make the signed addition below work
042CED 3E 08       0144*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042CEF 90          0145*      sub b
042CF0 47          0146*      ld b,a            ; b is the number of bits to shift back up
042CF1             0147*  
042CF1             0148*  @@:
042CF1             0149*  
042CF1             0150*  ; Add the byte offset to the base address of umulfxout
042CF1 59          0151*      ld e,c            ; DEU and D were properly signed above
042CF2 DD 21 0E 2D 0152*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042CF7 DD 19       0153*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042CF9             0154*  
042CF9             0155*  ; Read the byte-aligned result into HL and shift in the required number of bits
042CF9 DD 27 00    0156*      ld hl,(ix)        ; Byte-aligned result
042CFC DD 7E FF    0157*      ld a,(ix-1)       ; One byte below
042CFF             0158*  
042CFF             0159*  ; Check whether we're already byte-aligned
042CFF AF          0160*      xor a
042D00 B0          0161*      or b
042D01 28 05       0162*      jr z,@end         ; If no bits to shift, we're done
042D03             0163*  
042D03             0164*  ; Otherwise shiften zee bitzen
042D03             0165*  @loop:
042D03             0166*  
042D03 07          0167*      rlca              ; One bit to carry
042D04 ED 6A       0168*      adc hl,hl         ; Shift the carry into the result
042D06             0169*  
042D06 10 FB       0170*      djnz @loop        ; Loop until all bits are shifted up
042D08             0171*  
042D08             0172*  @end:
042D08             0173*  ; return the result
042D08 DD E1       0174*      pop ix ; restore
042D0A C9          0175*      ret
042D0B             0176*  
042D0B 00 00 00    0177*      dl 0 ; padding
042D0E 00 00 00 00 0178*  umulfxout: blkb 6,0
       00 00       
042D14 00 00 00    0179*      dl 0 ; padding
042D17             0180*  
042D17             0181*  ; operation: UHL * UDE --> UHL
042D17             0182*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042D17             0183*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042D17             0184*  ; inputs: hl = 24-bit number, de = 24-bit number,
042D17             0185*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042D17             0186*  ; outputs: umulfxout = 48-bit intermediate
042D17             0187*  ; destroys: af, hl, bc, de
042D17             0188*  smulfx:
042D17             0189*  ; make everything positive and store sign flags
042D17 CD F4 22 04 0190*  	call hlu_abs
042D1B F5          0191*  	push af
042D1C EB          0192*  	ex de,hl
042D1D CD F4 22 04 0193*  	call hlu_abs
042D21 EB          0194*  	ex de,hl
042D22 F5          0195*  	push af
042D23             0196*  ; do the division
042D23 CD BF 2C 04 0197*      call umulfx ; hl = product
042D27             0198*  ; adjust sign of result
042D27 F1          0199*  	pop af ; sign de
042D28 FA 33 2D 04 0200*  	jp m,@de_neg
042D2C F1          0201*  	pop af ; sign hl
042D2D F0          0202*  	ret p ; both positive, nothing to do
042D2E             0203*  @hl_neg:
042D2E CD 04 23 04 0204*      call neg_hlu ; de pos, hl neg, result is negative
042D32 C9          0205*      ret
042D33             0206*  @de_neg:
042D33 F1          0207*  	pop af
042D34 F8          0208*  	ret m ; both negative, nothing to do
042D35 CD 04 23 04 0209*  	call neg_hlu ; result is negative
042D39 C9          0210*  	ret
042D3A             0211*  
042D3A             0212*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042D3A             0213*  ; uses EZ80 MLT instruction for speed
042D3A             0214*  ; operation: UHL * A --> UHL
042D3A             0215*  ; destroys: AF, HL
042D3A             0216*  smul24x8:
042D3A             0217*  ; make hl positive and store sign flag
042D3A CD F4 22 04 0218*  	call hlu_abs
042D3E F5          0219*  	push af
042D3F             0220*  ; do the division
042D3F CD 4A 2D 04 0221*      call umul24x8 ; hl = product
042D43             0222*  ; adjust sign of result
042D43 F1          0223*  	pop af ; sign de
042D44 F0          0224*  	ret p ; hl was positive, nothing to do
042D45 CD 04 23 04 0225*  	call neg_hlu ; result is negative
042D49 C9          0226*  	ret
042D4A             0227*  
042D4A             0228*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042D4A             0229*  ; uses EZ80 MLT instruction for speed
042D4A             0230*  ; operation: UHL * A --> AUHL
042D4A             0231*  ; destroys: AF, HL
042D4A             0232*  umul24x8:
042D4A D5          0233*  	push de ; preserve de
042D4B             0234*  ; low byte
042D4B 5D          0235*  	ld e,l
042D4C 57          0236*  	ld d,a
042D4D ED 5C       0237*  	mlt de
042D4F 6B          0238*  	ld l,e ; product low byte
042D50 08          0239*  	ex af,af' ; save multiplier
042D51 7A          0240*  	ld a,d ; carry
042D52 08          0241*  	ex af,af' ; save carry, restore multiplier
042D53             0242*  ; high byte
042D53 5C          0243*  	ld e,h
042D54 57          0244*  	ld d,a
042D55 ED 5C       0245*  	mlt de
042D57 08          0246*  	ex af,af' ; save multiplier, restore carry
042D58 83          0247*  	add a,e ; add carry
042D59 67          0248*  	ld h,a ; product middle byte
042D5A 7A          0249*  	ld a,d ; carry
042D5B 08          0250*  	ex af,af' ; save carry, restore multiplier
042D5C             0251*  ; upper byte
042D5C E5          0252*  	push hl
042D5D 33          0253*  	inc sp
042D5E D1          0254*  	pop de ; d = hlu
042D5F 3B          0255*  	dec sp
042D60 5F          0256*  	ld e,a
042D61 ED 5C       0257*  	mlt de
042D63 08          0258*  	ex af,af' ; restore carry
042D64 8B          0259*  	adc a,e ; add carry
042D65 22 76 2D 04 0260*      ld (@scratch),hl ; 7 cycles
042D69 32 78 2D 04 0261*      ld (@scratch+2),a ; 5 cycles
042D6D 2A 76 2D 04 0262*      ld hl,(@scratch) ; 7 cycles
042D71             0263*  ; highest byte
042D71 3E 00       0264*  	ld a,0 ; preserve carry flag
042D73 8A          0265*  	adc a,d ; product highest byte
042D74 D1          0266*  	pop de ; restore de
042D75 C9          0267*  	ret
042D76             0268*  @scratch: ds 3
042D79             0269*  
042D79             0270*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042D79             0271*  ; operation: UHL * UDE --> umulfxout
042D79             0272*  umul24x24:
042D79 FD 21 0E 2D 0273*  	ld iy,umulfxout ; point to output buffer
       04          
042D7E C5          0274*  	push bc
042D7F 01 00 00 00 0275*  	ld bc,0
042D83 FD 0F 00    0276*  	ld (iy),bc
042D86 FD 0F 03    0277*  	ld (iy+3),bc
042D89 C1          0278*  	pop bc
042D8A             0279*  
042D8A             0280*  ; STEP 1: UHL * E
042D8A 7B          0281*  	ld a,e
042D8B E5          0282*  	push hl
042D8C CD 4A 2D 04 0283*  	call umul24x8
042D90 FD 2F 00    0284*  	ld (iy+0),hl
042D93 FD 77 03    0285*  	ld (iy+3),a
042D96             0286*  
042D96             0287*  ; STEP 2: UHL * D
042D96 E1          0288*  	pop hl
042D97 E5          0289*  	push hl
042D98 7A          0290*  	ld a,d
042D99 CD 4A 2D 04 0291*  	call umul24x8
042D9D CD AA 2D 04 0292*  	call @accumulate
042DA1             0293*  
042DA1             0294*  ; STEP 3: UHL * DEU
042DA1 E1          0295*  	pop hl
042DA2 D5          0296*  	push de
042DA3 33          0297*  	inc sp
042DA4 F1          0298*  	pop af
042DA5 3B          0299*  	dec sp
042DA6 CD 4A 2D 04 0300*  	call umul24x8
042DAA             0301*  
042DAA             0302*  @accumulate:
042DAA FD 23       0303*  	inc iy
042DAC             0304*  ; highest byte of product to carry
042DAC FD 77 03    0305*  	ld (iy+3),a
042DAF             0306*  ; low byte of product
042DAF 7D          0307*  	ld a,l
042DB0 FD 86 00    0308*  	add a,(iy+0)
042DB3 FD 77 00    0309*  	ld (iy+0),a
042DB6             0310*  ; high byte of product
042DB6 7C          0311*  	ld a,h
042DB7 FD 8E 01    0312*  	adc a,(iy+1)
042DBA FD 77 01    0313*  	ld (iy+1),a
042DBD             0314*  ; uppper byte of product
042DBD E5          0315*  	push hl
042DBE 33          0316*  	inc sp
042DBF E1          0317*  	pop hl
042DC0 3B          0318*  	dec sp
042DC1 7C          0319*  	ld a,h
042DC2 FD 8E 02    0320*  	adc a,(iy+2)
042DC5 FD 77 02    0321*  	ld (iy+2),a
042DC8             0322*  ; carry
042DC8 3E 00       0323*  	ld a,0 ; preserve flags
042DCA FD 8E 03    0324*  	adc a,(iy+3)
042DCD FD 77 03    0325*  	ld (iy+3),a
042DD0 C9          0326*  	ret
042DD1             0327*  
042DD1             0328*  ; UH.L = UH.L*UD.E (unsigned)
042DD1             0329*  umul168:
042DD1 CD 79 2D 04 0330*  	call umul24x24
042DD5 FD 27 FF    0331*  	ld hl,(iy-1)
042DD8 C9          0332*  	ret
042DD9             0333*  
042DD9             0334*  ; UH.L * UD.E --> UH.L (signed)
042DD9             0335*  smul168:
042DD9             0336*  ; make everything positive and store sign flags
042DD9 CD F4 22 04 0337*  	call hlu_abs
042DDD F5          0338*  	push af
042DDE EB          0339*  	ex de,hl
042DDF CD F4 22 04 0340*  	call hlu_abs
042DE3 EB          0341*  	ex de,hl
042DE4 F5          0342*  	push af
042DE5             0343*  ; do the division
042DE5 CD D1 2D 04 0344*      call umul168 ; hl = product
042DE9             0345*  ; adjust sign of result
042DE9 F1          0346*  	pop af ; sign de
042DEA FA F5 2D 04 0347*  	jp m,@de_neg
042DEE F1          0348*  	pop af ; sign hl
042DEF F0          0349*  	ret p ; both positive, nothing to do
042DF0             0350*  @hl_neg:
042DF0 CD 04 23 04 0351*      call neg_hlu ; de pos, hl neg, result is negative
042DF4 C9          0352*      ret
042DF5             0353*  @de_neg:
042DF5 F1          0354*  	pop af
042DF6 F8          0355*  	ret m ; both negative, nothing to do
042DF7 CD 04 23 04 0356*  	call neg_hlu ; result is negative
042DFB C9          0357*  	ret
042DFC             0358*  
042DFC             0359*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
042DFC             0360*  ; perform unsigned division of 16.8 fixed place values
042DFC             0361*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
042DFC             0362*  udiv168:
042DFC             0363*  ; back up divisor
042DFC ED 53 33 2E 0364*  	ld (@ude),de
       04          
042E01             0365*  ; get the 16-bit integer part of the quotient
042E01 CD 64 2E 04 0366*      call udiv24 ; de = quotient, hl = remainder
042E05             0367*  ; load quotient to upper three bytes of output
042E05 ED 53 3A 2E 0368*      ld (div168_out+1),de
       04          
042E0A             0369*  @div256:
042E0A             0370*  ; multiply remainder by 256
042E0A             0371*  	hlu_mul256
042E0A 29          0001*M         add hl,hl ; * 2
042E0B 29          0002*M         add hl,hl ; * 4
042E0C 29          0003*M         add hl,hl ; * 8
042E0D 29          0004*M         add hl,hl ; * 16
042E0E 29          0005*M         add hl,hl ; * 32
042E0F 29          0006*M         add hl,hl ; * 64
042E10 29          0007*M         add hl,hl ; * 128
042E11 29          0008*M         add hl,hl ; * 256
042E12             0372*  ; skip fractional computation if remainder is zero
042E12             0373*      sign_hlu
042E12 19          0001*M         add hl,de
042E13 B7          0002*M         or a
042E14 ED 52       0003*M         sbc hl,de
042E16 20 03       0374*      jr nz,@div_frac
042E18 AF          0375*      xor a
042E19 18 0A       0376*      jr @write_frac
042E1B             0377*  ; now divide the shifted remainder by the divisor
042E1B             0378*  @div_frac:
042E1B ED 5B 33 2E 0379*  	ld de,(@ude) ; get back divisor
       04          
042E20 CD 64 2E 04 0380*      call udiv24 ; de = quotient, hl = remainder
042E24             0381*  ; load low byte of quotient to low byte of output
042E24 7B          0382*      ld a,e
042E25             0383*  @write_frac:
042E25 32 39 2E 04 0384*      ld (div168_out),a
042E29             0385*  ; load de with return value
042E29 ED 5B 39 2E 0386*      ld de,(div168_out)
       04          
042E2E             0387*  ; load a with any overflow
042E2E 3A 3C 2E 04 0388*      ld a,(div168_out+3)
042E32 C9          0389*      ret ; ud.e is the 16.8 result
042E33             0390*  @ude: ds 6
042E39             0391*  div168_out: ds 4 ; the extra byte is for overflow
042E3D             0392*  
042E3D             0393*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
042E3D             0394*  ; perform signed division of 16.8 fixed place values
042E3D             0395*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
042E3D             0396*  sdiv168:
042E3D             0397*  ; make everything positive and store sign flags
042E3D CD F4 22 04 0398*  	call hlu_abs
042E41 F5          0399*  	push af
042E42 EB          0400*  	ex de,hl
042E43 CD F4 22 04 0401*  	call hlu_abs
042E47 EB          0402*  	ex de,hl
042E48 F5          0403*  	push af
042E49             0404*  ; do the division
042E49 CD FC 2D 04 0405*      call udiv168 ; de = quotient, hl = remainder
042E4D             0406*  ; adjust sign of result
042E4D F1          0407*  	pop af ; sign de
042E4E FA 5B 2E 04 0408*  	jp m,@de_neg
042E52 F1          0409*  	pop af ; sign hl
042E53 F0          0410*  	ret p ; both positive, nothing to do
042E54             0411*  @hl_neg:
042E54 EB          0412*      ex de,hl ; hl = quotient, de = remainder
042E55 CD 04 23 04 0413*      call neg_hlu ; de pos, hl neg, result is negative
042E59 EB          0414*      ex de,hl ; de = negated quotient, hl = remainder
042E5A C9          0415*      ret
042E5B             0416*  @de_neg:
042E5B F1          0417*  	pop af
042E5C F8          0418*  	ret m ; both negative, nothing to do
042E5D EB          0419*      ex de,hl ; hl = quotient, de = remainder
042E5E CD 04 23 04 0420*  	call neg_hlu ; result is negative
042E62 EB          0421*      ex de,hl ; de = negated quotient, hl = remainder
042E63 C9          0422*  	ret
042E64             0423*  
042E64             0424*  ;------------------------------------------------------------------------
042E64             0425*  ;  arith24.asm
042E64             0426*  ;  24-bit ez80 arithmetic routines
042E64             0427*  ;  Copyright (c) Shawn Sijnstra 2024
042E64             0428*  ;  MIT license
042E64             0429*  ;
042E64             0430*  ;  This library was created as a tool to help make ez80
042E64             0431*  ;  24-bit native assembly routines for simple mathematical problems
042E64             0432*  ;  more widely available.
042E64             0433*  ;
042E64             0434*  ;------------------------------------------------------------------------
042E64             0435*  ;
042E64             0436*  ;------------------------------------------------------------------------
042E64             0437*  ; udiv24
042E64             0438*  ; Unsigned 24-bit division
042E64             0439*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
042E64             0440*  ;
042E64             0441*  ; Uses AF BC DE HL
042E64             0442*  ; Uses Restoring Division algorithm
042E64             0443*  ;------------------------------------------------------------------------
042E64             0444*  
042E64             0445*  udiv24:
042E64 E5          0446*  	push	hl
042E65 C1          0447*  	pop		bc	;move dividend to BCU
042E66 21 00 00 00 0448*  	ld		hl,0	;result
042E6A A7          0449*  	and		a
042E6B ED 52       0450*  	sbc		hl,de	;test for div by 0
042E6D C8          0451*  	ret		z		;it's zero, carry flag is clear
042E6E 19          0452*  	add		hl,de	;HL is 0 again
042E6F 3E 18       0453*  	ld		a,24	;number of loops through.
042E71             0454*  udiv1:
042E71 C5          0455*  	push	bc	;complicated way of doing this because of lack of access to top bits
042E72 E3          0456*  	ex		(sp),hl
042E73 37          0457*  	scf
042E74 ED 6A       0458*  	adc	hl,hl
042E76 E3          0459*  	ex	(sp),hl
042E77 C1          0460*  	pop	bc		;we now have bc = (bc * 2) + 1
042E78             0461*  
042E78 ED 6A       0462*  	adc	hl,hl
042E7A A7          0463*  	and	a		;is this the bug
042E7B ED 52       0464*  	sbc	hl,de
042E7D 30 02       0465*  	jr	nc,udiv2
042E7F 19          0466*  	add	hl,de
042E80             0467*  ;	dec	c
042E80 0B          0468*  	dec	bc
042E81             0469*  udiv2:
042E81 3D          0470*  	dec	a
042E82 20 ED       0471*  	jr	nz,udiv1
042E84 37          0472*  	scf		;flag used for div0 error
042E85 C5          0473*  	push	bc
042E86 D1          0474*  	pop		de	;remainder
042E87 C9          0475*  	ret
042E88             0061   ; App-specific includes
042E88             0062   	include "player.inc"
042E88             0001*  ; ######## GAME STATE VARIABLES #######
042E88             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042E88 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042E8B             0004*  ; player current shields,binary
042E8B             0005*  ; when < 0 player splodes
042E8B             0006*  ; restores to player_max_shields when new ship spawns
042E8B 10          0007*  player_shields: db 16 ; binary
042E8C             0008*  ; max player shields,binary
042E8C             0009*  ; can increase with power-ups (todo)
042E8C 10          0010*  player_max_shields: db 16 ; binary
042E8D             0011*  ; when reaches zero,game ends
042E8D             0012*  ; can increase based on TODO
042E8D 03          0013*  player_ships: db 0x03 ; binary
042E8E             0014*  
042E8E             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042E8E             0016*  ; uses the same offsets from its table base as the main sprite table:
042E8E             0017*  player_start_variables: ; label marking beginning of table
042E8E 01          0018*  player_id:               db table_max_records
042E8F 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042E90 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042E93 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042E96 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042E97 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042E98 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042E99 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042E9C 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042E9F 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042EA2 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042EA5 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042EA8 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042EAB 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042EAE 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042EAF 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042EB0 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042EB1 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042EB2 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042EB3 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042EB4             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042EB4             0039*  
042EB4             0040*  ; set initial player position
042EB4             0041*  ; inputs: none,everything is hardcoded
042EB4             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042EB4             0043*  ; destroys: a
042EB4             0044*  player_init:
042EB4 3A 8E 2E 04 0045*  	ld a,(player_id)
042EB8 CD 8C 21 04 0046*  	call vdu_sprite_select
042EBC CD 9F 21 04 0047*      call vdu_sprite_clear_frames
042EC0 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042EC4 CD D9 22 04 0049*      call vdu_sprite_add_buff
042EC8 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042ECC CD D9 22 04 0051*      call vdu_sprite_add_buff
042ED0 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042ED4 CD D9 22 04 0053*      call vdu_sprite_add_buff
042ED8 01 00 00 00 0054*      ld bc,0
042EDC ED 43 99 2E 0055*      ld (player_x),bc
       04          
042EE1 11 00 DF 00 0056*      ld de,0x00DF00
042EE5 ED 53 9C 2E 0057*      ld (player_y),de
       04          
042EEA CD 58 22 04 0058*      call vdu_sprite_move_abs168
042EEE CD 02 22 04 0059*      call vdu_sprite_show
042EF2 C9          0060*      ret
042EF3             0061*  
042EF3             0062*  ; process player keyboard input, set player bitmap
042EF3             0063*  ; velocities and draw player bitmap at updated coordinates
042EF3             0064*  ; Inputs: player_x/y set at desired position
042EF3             0065*  ; Returns: player bitmap drawn at updated position
042EF3             0066*  ; Destroys: probably everything except maybe iy
042EF3             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042EF3             0068*  ; TODO: requires sprite implementation
042EF3             0069*  player_input:
042EF3             0070*  ; reset player component velocities to zero as the default
042EF3 21 00 00 00 0071*  	ld hl,0
042EF7 22 9F 2E 04 0072*  	ld (player_xvel),hl
042EFB 22 A2 2E 04 0073*  	ld (player_yvel),hl
042EFF             0074*  ; make ship the active sprite
042EFF 3A 8E 2E 04 0075*      ld a,(player_id)
042F03 CD 8C 21 04 0076*      call vdu_sprite_select
042F07             0077*  ; check for keypresses and branch accordingly
042F07             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042F07             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042F07 3E 1E       0001*M 			LD	A, function
042F09 5B CF       0002*M 			RST.LIL	08h
042F0B             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042F0B             0081*  ; this handles the case where two opposing movement keys
042F0B             0082*  ; are down simultaneously (velocities will net to zero)
042F0B             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042F0B             0084*  ; it also allows movement and action keys to be detected simultaneously
042F0B             0085*  ; so we can walk and chew gum at the same time
042F0B 3E 01       0086*      ld a,1 ; set ship's default animation to center
042F0D             0087*          ; if left and right are both down a will net to
042F0D             0088*  
042F0D             0089*  @left:
042F0D DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042F11 28 0E       0091*      jr z,@right
042F13 2A 9F 2E 04 0092*      ld hl,(player_xvel)
042F17 01 00 FD FF 0093*      ld bc,-speed_player
042F1B 09          0094*      add hl,bc
042F1C 22 9F 2E 04 0095*      ld (player_xvel),hl
042F20 3D          0096*      dec a ; set ship's animation to left
042F21             0097*  @right:
042F21 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042F25 28 0E       0099*  	jr z,@up
042F27 2A 9F 2E 04 0100*      ld hl,(player_xvel)
042F2B 01 00 03 00 0101*      ld bc,speed_player
042F2F 09          0102*      add hl,bc
042F30 22 9F 2E 04 0103*      ld (player_xvel),hl
042F34 3C          0104*      inc a ; set ship's animation to right
042F35             0105*  @up:
042F35 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042F39 28 0D       0107*  	jr z,@down
042F3B 2A A2 2E 04 0108*      ld hl,(player_yvel)
042F3F 01 00 FD FF 0109*      ld bc,-speed_player
042F43 09          0110*      add hl,bc
042F44 22 A2 2E 04 0111*      ld (player_yvel),hl
042F48             0112*  @down:
042F48 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042F4C 28 0D       0114*  	jr z,@done_keyboard
042F4E 2A A2 2E 04 0115*      ld hl,(player_yvel)
042F52 01 00 03 00 0116*      ld bc,speed_player
042F56 09          0117*      add hl,bc
042F57 22 A2 2E 04 0118*      ld (player_yvel),hl
042F5B             0119*  @done_keyboard:
042F5B             0120*  ; move player sprite according to velocities set by keypresses
042F5B 2A 9F 2E 04 0121*      ld hl,(player_xvel)
042F5F             0122*  ; compute new x position
042F5F ED 5B 99 2E 0123*      ld de,(player_x)
       04          
042F64 19          0124*      add hl,de ; hl = player_x + player_xvel
042F65             0125*      ; check for horizontal screen edge collisions
042F65             0126*      ; and adjust coordinate as necessary
042F65             0127*  ; TODO: make this work using 24-bit registers
042F65             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042F65             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042F65             0130*      ; ld a,8 ; set x to leftmost allowable position
042F65             0131*  ; @check_right:
042F65             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042F65             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042F65             0134*  ;     ld a,248 ; set x to rightmost allowable position
042F65             0135*  @x_ok:
042F65             0136*  ; save the updated drawing coordinate
042F65 22 99 2E 04 0137*      ld (player_x),hl
042F69             0138*  ;compute new y position
042F69 2A 9C 2E 04 0139*      ld hl,(player_y)
042F6D ED 5B A2 2E 0140*      ld de,(player_yvel)
       04          
042F72 19          0141*      add hl,de ; hl = player_y + player_yvel
042F73             0142*  ; TODO: make this work using 24-bit registers
042F73             0143*  ;     ; check for vertical screen edge collisions
042F73             0144*  ;     ; and adjust coordinate as necessary
042F73             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042F73             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042F73             0147*  ;     ld a,8 ; set y to topmost allowable position
042F73             0148*  ; @check_top:
042F73             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042F73             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042F73             0151*  ;     ld a,232 ; set y to bottommost allowable position
042F73             0152*  @y_ok:
042F73 22 9C 2E 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042F77             0154*  ; a should land here loaded with the correct frame
042F77 CD EF 21 04 0155*      call vdu_sprite_select_frame
042F7B             0156*  ; draw player at updated position
042F7B ED 4B 99 2E 0157*      ld bc,(player_x)
       04          
042F80 ED 5B 9C 2E 0158*  	ld de,(player_y)
       04          
042F85             0159*  
042F85             0160*      ; call dumpRegistersHex
042F85             0161*  
042F85 CD 58 22 04 0162*  	call vdu_sprite_move_abs168
042F89             0163*  
042F89             0164*  ; end player_input
042F89 C9          0165*  	ret
042F8A             0166*  
042F8A             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042F8A             0168*  ; ; INSTEAD OF FRACTIONAL
042F8A             0169*  ; ; ----------------------------------------------------------------
042F8A             0170*  ; ; process player keyboard input, set player bitmap
042F8A             0171*  ; ; velocities and draw player bitmap at updated coordinates
042F8A             0172*  ; ; Inputs: player_x/y set at desired position
042F8A             0173*  ; ; Returns: player bitmap drawn at updated position
042F8A             0174*  ; ; Destroys: probably everything except maybe iy
042F8A             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042F8A             0176*  ; ; TODO: requires sprite implementation
042F8A             0177*  ; player_input:
042F8A             0178*  ; ; reset player component velocities to zero as the default
042F8A             0179*  ; 	ld hl,0
042F8A             0180*  ; 	ld (player_xvel),hl
042F8A             0181*  ; 	ld (player_yvel),hl
042F8A             0182*  ; ; check for keypresses and branch accordingly
042F8A             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042F8A             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042F8A             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042F8A             0186*  ; ; this handles the case where two opposing movement keys
042F8A             0187*  ; ; are down simultaneously (velocities will net to zero)
042F8A             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042F8A             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042F8A             0190*  ; ; so we can walk and chew gum at the same time
042F8A             0191*  ; @left:
042F8A             0192*  ;     bit 1,(ix+3) ; keycode 26
042F8A             0193*  ;     jr z,@right
042F8A             0194*  ;     ld hl,(player_xvel)
042F8A             0195*  ;     ld bc,-3
042F8A             0196*  ;     add hl,bc
042F8A             0197*  ;     ld (player_xvel),hl
042F8A             0198*  ; @right:
042F8A             0199*  ;     bit 1,(ix+15) ; keycode 122
042F8A             0200*  ; 	jr z,@up
042F8A             0201*  ;     ld hl,(player_xvel)
042F8A             0202*  ;     ld bc,3
042F8A             0203*  ;     add hl,bc
042F8A             0204*  ;     ld (player_xvel),hl
042F8A             0205*  ; @up:
042F8A             0206*  ;     bit 1,(ix+7) ; keycode 58
042F8A             0207*  ; 	jr z,@down
042F8A             0208*  ;     ld hl,(player_yvel)
042F8A             0209*  ;     ld bc,-3
042F8A             0210*  ;     add hl,bc
042F8A             0211*  ;     ld (player_yvel),hl
042F8A             0212*  ; @down:
042F8A             0213*  ;     bit 1,(ix+5) ; keycode 42
042F8A             0214*  ; 	jr z,@done_keyboard
042F8A             0215*  ;     ld hl,(player_yvel)
042F8A             0216*  ;     ld bc,3
042F8A             0217*  ;     add hl,bc
042F8A             0218*  ;     ld (player_yvel),hl
042F8A             0219*  ; @done_keyboard:
042F8A             0220*  ; ; move player sprite according to velocities set by keypresses
042F8A             0221*  ;     ld hl,(player_xvel)
042F8A             0222*  ; ; compute new x position
042F8A             0223*  ;     ld de,(player_x)
042F8A             0224*  ;     add hl,de ; hl = player_x + player_xvel
042F8A             0225*  ;     ; check for horizontal screen edge collisions
042F8A             0226*  ;     ; and adjust coordinate as necessary
042F8A             0227*  ; ; TODO: make this work using 24-bit registers
042F8A             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042F8A             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042F8A             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042F8A             0231*  ; ; @check_right:
042F8A             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042F8A             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042F8A             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042F8A             0235*  ; @x_ok:
042F8A             0236*  ;     ; save the updated drawing coordinate
042F8A             0237*  ;     ld (player_x),hl
042F8A             0238*  ; ;compute new y position
042F8A             0239*  ;     ld hl,(player_y)
042F8A             0240*  ;     ld de,(player_yvel)
042F8A             0241*  ;     add hl,de ; hl = player_y + player_yvel
042F8A             0242*  ; ; TODO: make this work using 24-bit registers
042F8A             0243*  ; ;     ; check for vertical screen edge collisions
042F8A             0244*  ; ;     ; and adjust coordinate as necessary
042F8A             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042F8A             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042F8A             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042F8A             0248*  ; ; @check_top:
042F8A             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042F8A             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042F8A             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042F8A             0252*  ; @y_ok:
042F8A             0253*  ;     ld (player_y),hl
042F8A             0254*  ; ; draw player at updated position
042F8A             0255*  ;     ld a,(player_id)
042F8A             0256*  ;     call vdu_sprite_select
042F8A             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042F8A             0258*  ;     call get_sign_hlu ; to set the proper animation
042F8A             0259*  ;     add a,1 ; ...
042F8A             0260*  ;     call vdu_sprite_select_frame
042F8A             0261*  ;     ld bc,(player_x)
042F8A             0262*  ; 	ld de,(player_y)
042F8A             0263*  ; 	call vdu_sprite_move_abs
042F8A             0264*  ; ; end player_input
042F8A             0265*  ; 	ret
042F8A             0266*  
042F8A             0267*  
042F8A             0268*  ; ###################################################################
042F8A             0269*  ; TODO: the below is all stuff from the original code we need to port
042F8A             0270*  ; ###################################################################
042F8A             0271*  
042F8A             0272*  ; kill_player:
042F8A             0273*  ; ; set player status to dead
042F8A             0274*  ;     xor a; sets all player flags to zero
042F8A             0275*  ;     ld (player_collisions),a
042F8A             0276*  ; ; deduct a ship from the inventory
042F8A             0277*  ;     ld a,(player_ships)
042F8A             0278*  ;     dec a
042F8A             0279*  ;     ld (player_ships),a
042F8A             0280*  ; ; are we out of ships?
042F8A             0281*  ;     jp z,game_over
042F8A             0282*  ; ; wait a few ticks
042F8A             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042F8A             0284*  ;     ld (player_move_timer),a
042F8A             0285*  ; kill_player_loop:
042F8A             0286*  ;     call vdu_vblank
042F8A             0287*  ;     ld a,(player_move_timer)
042F8A             0288*  ;     dec a
042F8A             0289*  ;     ld (player_move_timer),a
042F8A             0290*  ;     jr nz,kill_player_loop
042F8A             0291*  ;     call player_init ; player respawn if timer zero
042F8A             0292*  ;     ret ; and out
042F8A             0293*  
042F8A             0294*  
042F8A             0295*  ; player_move:
042F8A             0296*  ; ; begin setting player to active sprite
042F8A             0297*  ;     ld hl,player
042F8A             0298*  ;     ld (sprite_base_bufferId),hl
042F8A             0299*  ;     ld hl,0 ; north
042F8A             0300*  ;     ld (sprite_heading),hl
042F8A             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042F8A             0302*  ;     ld (sprite_animation),a
042F8A             0303*  ;     ; we set position here for the time being as a default
042F8A             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042F8A             0305*  ;     ld hl,(player_x)
042F8A             0306*  ;     ld (sprite_x),hl
042F8A             0307*  ;     ld hl,(player_y)
042F8A             0308*  ;     ld (sprite_y),hl
042F8A             0309*  ; ; did we just die?
042F8A             0310*  ;     ld a,(player_collisions)
042F8A             0311*  ;     and %00000010 ; zero flag will be set if not dead
042F8A             0312*  ;     jr z,player_not_dead
042F8A             0313*  ; ; yes we died
042F8A             0314*  ;     call kill_player
042F8A             0315*  ;     ret ; done
042F8A             0316*  ; ; yay we didn't die
042F8A             0317*  ; player_not_dead:
042F8A             0318*  ; ; set player movements to zero by default
042F8A             0319*  ;     ld hl,0
042F8A             0320*  ;     ld (player_xvel),hl
042F8A             0321*  ;     ld (player_yvel),hl
042F8A             0322*  ; ; do we move it?
042F8A             0323*  ;     in a,(#82) ; keyboard
042F8A             0324*  ;     or a ; if zero,don't move
042F8A             0325*  ;     jr z,player_draw
042F8A             0326*  ; ; move it
042F8A             0327*  ;     call player_move_calc
042F8A             0328*  ; player_draw:
042F8A             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042F8A             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042F8A             0331*  ; player_move_done:
042F8A             0332*  ;     ; write updated x,y coordinates back to player table
042F8A             0333*  ;     ld hl,(sprite_x)
042F8A             0334*  ;     ld (player_x),hl
042F8A             0335*  ;     ld hl,(sprite_y)
042F8A             0336*  ;     ld (player_y),hl
042F8A             0337*  ;     ret
042F8A             0063   	include "tiles.inc"
042F8A             0001*  ; ######### TILES #########
042F8A             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042F8A             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042F8A 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042F8D 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042F8E             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042F8E 00          0007*  cur_level: db 0
042F8F             0008*  num_levels: equ 2 ; number of levels,duh
042F8F             0009*  
042F8F             0010*  ; lookup table for level definitions
042F8F E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042F95             0012*  
042F95             0013*  ; tiles_bufferId: dl 0
042F95 00 00 00    0014*  tiles_x_plot: dl 0
042F98 F1 FF FF    0015*  tiles_y_plot: dl -15
042F9B             0016*  
042F9B             0017*  
042F9B             0018*  tiles_plot:
042F9B             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042F9B             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042F9B             0021*  ; ;       but don't want
042F9B             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042F9B             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042F9B             0024*  ; 	ld bc,0 ; leftmost x-coord
042F9B             0025*  ; 	ld de,0 ; topmost y-coord
042F9B             0026*  ; 	ld ix,255 ; rightmost x-coord
042F9B             0027*  ; 	ld iy,1 ; bottommost y-coord
042F9B             0028*  ; 	call vdu_set_gfx_viewport
042F9B             0029*  
042F9B 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042F9F 22 95 2F 04 0031*      ld (tiles_x_plot),hl
042FA3 2A 8A 2F 04 0032*      ld hl,(tiles_row_defs)
042FA7 06 10       0033*  	ld b,16 ; loop counter
042FA9             0034*  @loop:
042FA9 C5          0035*  	push bc ; save the loop counter
042FAA             0036*  ; read the tile defintion for the current column
042FAA 7E          0037*      ld a,(hl) ; a has tile definition
042FAB E5          0038*      push hl  ; save pointer to tile definition
042FAC 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042FB0 6F          0040*      ld l,a ; l is tile defintion
042FB1 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042FB3 CD 22 1E 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042FB7             0043*  
042FB7             0044*  ; plot the active bitmap
042FB7 ED 4B 95 2F 0045*      ld bc,(tiles_x_plot)
       04          
042FBC ED 5B 98 2F 0046*      ld de,(tiles_y_plot)
       04          
042FC1 CD EB 20 04 0047*      call vdu_plot_bmp
042FC5             0048*  
042FC5             0049*  ; bump x-coords the width of one tile and save it
042FC5 2A 95 2F 04 0050*      ld hl,(tiles_x_plot)
042FC9 01 10 00 00 0051*      ld bc,16
042FCD 09          0052*      add hl,bc
042FCE 22 95 2F 04 0053*      ld (tiles_x_plot),hl
042FD2             0054*  
042FD2             0055*  ; prepare to loop to next column
042FD2 E1          0056*      pop hl ; get back pointer to tile def
042FD3 23          0057*      inc hl ; bump it to the next column
042FD4 C1          0058*  	pop bc ; snag our loop counter
042FD5 10 D2       0059*      djnz @loop
042FD7             0060*  
042FD7             0061*  ; increment tiles plotting y-coordinate
042FD7             0062*  ; when it hits zero, we go to next row of tiles in the map
042FD7             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042FD7 DD 21 98 2F 0064*  	ld ix,tiles_y_plot
       04          
042FDC DD 34 00    0065*  	inc (ix)
042FDF C0          0066*  	ret nz
042FE0             0067*  
042FE0             0068*  ; time to bump tiles_row_defs to next row
042FE0             0069*  ; (hl was already there at the end of the loop)
042FE0 22 8A 2F 04 0070*      ld (tiles_row_defs),hl
042FE4             0071*  
042FE4             0072*  ; reset coords to plot next row of tiles
042FE4 21 00 00 00 0073*      ld hl,0
042FE8 22 95 2F 04 0074*      ld (tiles_x_plot),hl
042FEC 21 F1 FF FF 0075*      ld hl,-15
042FF0 22 98 2F 04 0076*      ld (tiles_y_plot),hl
042FF4             0077*  
042FF4             0078*  ; decrement tiles row counter
042FF4 21 8D 2F 04 0079*      ld hl,tiles_row
042FF8 35          0080*      dec (hl)
042FF9 C0          0081*      ret nz
042FFA             0082*  
042FFA             0083*  ; queue up next level
042FFA 3A 8E 2F 04 0084*      ld a,(cur_level)
042FFE FE 01       0085*      cp num_levels-1
043000 20 02       0086*      jr nz,@inc_level
043002 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
043004             0088*  
043004             0089*  @inc_level:
043004 3C          0090*      inc a
043005 32 8E 2F 04 0091*      ld (cur_level),a
043009             0092*  
043009             0093*  ; increase the number of enemy sprites
043009 3A 50 30 04 0094*      ld a,(max_enemy_sprites)
04300D 3C          0095*      inc a
04300E FE 01       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
043010 28 04       0097*      jr z,init_level
043012 32 50 30 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
043016             0099*  ; fall through to init_level
043016             0100*  
043016             0101*  init_level:
043016             0102*  ; look up address of level's tile defintion
043016 21 8F 2F 04 0103*      ld hl,tiles_levels
04301A 3A 8E 2F 04 0104*      ld a,(cur_level)
04301E 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
043022 57          0106*      ld d,a
043023 1E 03       0107*      ld e,3
043025 ED 5C       0108*      mlt de
043027 19          0109*      add hl,de
043028 ED 37       0110*      ld ix,(hl)
04302A DD 22 8A 2F 0111*      ld (tiles_row_defs),ix
       04          
04302F             0112*  
04302F             0113*  ; set tiles_row counter
04302F DD 7E 00    0114*      ld a,(ix)
043032 32 8D 2F 04 0115*      ld (tiles_row),a
043036 DD 23       0116*      inc ix ; now ix points first element of first row tile def
043038 DD 22 8A 2F 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
04303D C9          0118*      ret
04303E             0119*  
04303E             0120*  
04303E             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
04303E             0122*  ; dt_is_active:
04303E             0123*  ; ; a lands here containing a tile index in the low nibble
04303E             0124*  ; ; we test the values for the tiles which are active
04303E             0125*  ;     cp #07
04303E             0126*  ;     call z,ld_act_landing_pad
04303E             0127*  ;     cp #08
04303E             0128*  ;     call z,ld_act_laser_turret
04303E             0129*  ;     ; fall through
04303E             0130*  ;     ret
04303E             0131*  
04303E             0132*  ; ; some tiles become active sprites,so we load those here
04303E             0133*  ; ; sprite_x/y have already been loaded
04303E             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
04303E             0135*  ; ; we don't want sprite drawn to background like other tiles
04303E             0136*  ; ; so this routine only adds them to the sprite table
04303E             0137*  ; dt_ld_act:
04303E             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
04303E             0139*  ;     ld (sprite_y+1),a ; just the integer part
04303E             0140*  ;     ld (sprite_base_bufferId),hl
04303E             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04303E             0142*  ;     call table_add_record
04303E             0143*  ;     call sprite_variables_from_stack
04303E             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
04303E             0145*  ;     ret ; and back
04303E             0146*  
04303E             0147*  ; ld_act_landing_pad:
04303E             0148*  ;     call sprite_variables_to_stack
04303E             0149*  
04303E             0150*  ;     ld hl,move_landing_pad
04303E             0151*  ;     ld (sprite_move_program),hl
04303E             0152*  
04303E             0153*  ;     xor a
04303E             0154*  ;     ld (sprite_animation),a ; animation 0
04303E             0155*  
04303E             0156*  ;     call rand_8     ; snag a random number
04303E             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04303E             0158*  ;     add a,64 ; range is now 64-127
04303E             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04303E             0160*  
04303E             0161*  ;     ld a,%10 ; collides with laser but not player
04303E             0162*  ;     ld (iy+sprite_collisions),a
04303E             0163*  
04303E             0164*  ;     ld a,#05 ; BCD
04303E             0165*  ;     ld (sprite_points),a
04303E             0166*  ;     ld a,0 ; binary
04303E             0167*  ;     ld (sprite_shield_damage),a
04303E             0168*  
04303E             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
04303E             0170*  ;     jr dt_ld_act
04303E             0171*  
04303E             0172*  ; ld_act_laser_turret:
04303E             0173*  ;     call sprite_variables_to_stack
04303E             0174*  
04303E             0175*  ;     ld hl,move_laser_turret
04303E             0176*  ;     ld (sprite_move_program),hl
04303E             0177*  
04303E             0178*  ;     xor a
04303E             0179*  ;     ld (sprite_animation),a
04303E             0180*  ;     ld (sprite_move_step),a
04303E             0181*  
04303E             0182*  ;     call rand_8     ; snag a random number
04303E             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04303E             0184*  ;     add a,64 ; range is now 64-127
04303E             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04303E             0186*  
04303E             0187*  ;     ld a,%10 ; collides with laser but not player
04303E             0188*  ;     ld (iy+sprite_collisions),a
04303E             0189*  
04303E             0190*  ;     ld a,#10 ; BCD
04303E             0191*  ;     ld (sprite_points),a
04303E             0192*  ;     ld a,0 ; binary
04303E             0193*  ;     ld (sprite_shield_damage),a
04303E             0194*  
04303E             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
04303E             0196*  ;     jp dt_ld_act
04303E             0197*  
04303E             0198*  
04303E             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
04303E             0200*  ; deletes sprites from table when they wrap around to top of screen
04303E             0201*  move_active_tiles:
04303E             0202*  ; get current position
04303E 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
043042 3C          0204*      inc a
043043             0205*  ; are we at the bottom of the screen?
043043 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
043045             0207*  ; otherwise kill sprite
043045 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
043047 FD 77 08    0209*      ld (iy+sprite_collisions),a
04304A C9          0210*      ret ; debug
04304B             0211*  move_active_tiles_draw_sprite:
04304B 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
04304F             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04304F             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
04304F C9          0215*      ret ; and done
043050             0064   	include "enemies.inc"
043050 10          0001*  max_enemy_sprites: db 16
043051             0002*  
043051             0003*  ; sprite_type
043051             0004*  enemy_dead: equ 0
043051             0005*  enemy_small: equ 1
043051             0006*  enemy_medium: equ 2
043051             0007*  enemy_large: equ 3
043051             0008*  landing_pad: equ 4
043051             0009*  laser_turret: equ 5
043051             0010*  fireballs: equ 6
043051             0011*  explosion: equ 7
043051             0012*  
043051             0013*  
043051             0014*  respawn_countdown:
043051 2A 72 30 04 0015*      ld hl,(respawn_timer)
043055 2B          0016*      dec hl
043056 22 72 30 04 0017*      ld (respawn_timer),hl
04305A             0018*  ; check hl for zero
04305A 19          0019*      add hl,de
04305B B7          0020*      or a
04305C ED 52       0021*      sbc hl,de
04305E C0          0022*      ret nz
04305F 06 01       0023*      ld b,table_max_records
043061             0024*  @respawn_loop:
043061 C5          0025*      push bc
043062 CD 6D 31 04 0026*      call enemy_init_from_landing_pad
043066 C1          0027*      pop bc
043067 10 F8       0028*      djnz @respawn_loop
043069 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
04306D 22 72 30 04 0030*      ld (respawn_timer),hl
043071 C9          0031*      ret
043072 3C 00 00    0032*  respawn_timer: dl 1*60
043075             0033*  
043075             0034*  move_enemies:
043075             0035*  ; are there any active enemies or explosions?
043075 21 00 00 00 0036*      ld hl,0
043079 3A 0B 16 04 0037*      ld a,(table_active_sprites)
04307D 6F          0038*      ld l,a
04307E             0039*      ; call dumpRegistersHex
04307E A7          0040*      and a ; will be zero if no alive enemies or explosions
04307F             0041*      ; ret z ; so nothing to do but go back
04307F             0042*      ; ld hl,(respawn_timer)
04307F             0043*      ; call dumpRegistersHex
04307F 20 05       0044*      jr nz,move_enemies_do
043081 CD 51 30 04 0045*      call respawn_countdown
043085 C9          0046*      ret
043086             0047*  move_enemies_do:
043086             0048*  ; initialize pointers and loop counter
043086 FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
04308B 06 01       0050*      ld b,table_max_records ; loop counter
04308D             0051*  move_enemies_loop:
04308D FD 22 08 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
043092 C5          0053*      push bc ; backup loop counter
043093             0054*  ; check sprite_type to see if sprite is active
043093 FD 7E 01    0055*      ld a,(iy+sprite_type)
043096 A7          0056*      and a ; if zero, sprite is dead
043097 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
043099             0058*  ; otherwise we prepare to move the sprite
043099 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
04309C CD 8C 21 04 0060*      call vdu_sprite_select ; select sprite
0430A0 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
0430A3 E9          0062*      jp (hl)  ; ... and jump to it
0430A4             0063*  ; we always jp back here from behavior subroutines
0430A4             0064*  move_enemies_loop_return:
0430A4 FD 2A 08 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
0430A9             0066*  ; now we check results of all the moves
0430A9 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
0430AC E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
0430AE FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
0430B1 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
0430B3 CD 54 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
0430B7 AF          0072*      xor a ; zero a so that we can ...
0430B8 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
0430BB 18 0A       0074*      jr move_enemies_next_record ; and to the next record
0430BD             0075*  move_enemies_draw_sprite:
0430BD             0076*  ; if we got here sprite will have already been activated
0430BD             0077*  ; so all we need to do is set its coordinates and draw it
0430BD FD 07 0B    0078*      ld bc,(iy+sprite_x)
0430C0 FD 17 0E    0079*      ld de,(iy+sprite_y)
0430C3 CD 58 22 04 0080*      call vdu_sprite_move_abs168
0430C7             0081*  ; fall through to next record
0430C7             0082*  move_enemies_next_record:
0430C7 11 26 00 00 0083*      ld de,table_bytes_per_record
0430CB FD 19       0084*      add iy,de ; point to next record
0430CD AF          0085*      xor a ; clears carry flag
0430CE 32 0C 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
0430D2 C1          0087*      pop bc ; get back our loop counter
0430D3 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
0430D5 C9          0089*      ret ; and we're out
0430D6             0090*  
0430D6             0091*  en_nav_zigzag_start:
0430D6 FD 2A 08 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0430DB CD A9 23 04 0093*      call rand_8
0430DF E6 3F       0094*      and %00111111 ; limit it to 64
0430E1 CB DF       0095*      set 3,a ; make sure it's at least 8
0430E3 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
0430E6             0097*      ; fall through to en_nav_zigzag
0430E6             0098*  en_nav_zigzag:
0430E6 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
0430E9 3D          0100*      dec a
0430EA FD 77 22    0101*      ld (iy+sprite_move_timer),a
0430ED 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
0430EF             0103*      ; otherwise flip direction and restart timer
0430EF FD 7E 23    0104*      ld a,(iy+sprite_move_step)
0430F2 EE 01       0105*      xor %1 ; flips bit one
0430F4 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
0430F7 20 09       0107*      jr nz,en_nav_zigzag_right
0430F9             0108*  ;otherwise zag left
0430F9 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
0430FD FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
043100 18 D4       0111*      jr en_nav_zigzag_start
043102             0112*  en_nav_zigzag_right:
043102 21 00 60 00 0113*      ld hl,0x006000; southeast heading
043106 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
043109 18 CB       0115*      jr en_nav_zigzag_start
04310B             0116*  en_nav_zigzag_no_switch:
04310B             0117*      ; ld a,(sprite_orientation)
04310B FD 27 1A    0118*      ld hl,(iy+sprite_heading)
04310E 18 13       0119*      jr en_nav_computevelocities
043110             0120*  
043110             0121*  ; contains the logic for how to move the enemy
043110             0122*  ; and then does the moving
043110             0123*  ; inputs: a fully-populated active sprite table
043110             0124*  ;         player position variables
043110             0125*  ; destroys: everything except index registers
043110             0126*  ; outputs: moving enemies
043110             0127*  en_nav:
043110             0128*  ; set velocity and orientation by player's relative location
043110             0129*  ; move enemies y-axis
043110             0130*  ; where is player relative to us?
043110 CD F0 31 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
043114             0132*  ; is player above or below us?
043114 ED 53 01 1C 0133*      ld (ude),de ; dy
       04          
043119 3A 03 1C 04 0134*      ld a,(ude+2) ; deu
04311D 17          0135*      rla ; shift sign bit into carry
04311E 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
043120             0137*  ; player is even or above,so home in on current heading
043120 FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
043123             0139*  
043123             0140*  ; we land here from zig-zag program so as not to
043123             0141*  ; redundantly save orientation and heading
043123             0142*  en_nav_computevelocities:
043123             0143*  ; set x/y component velocities based on bearing to player
043123 FD 2A 08 16 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043128 E5          0145*      push hl ; we need it back to set rotation frame
043129 FD 17 17    0146*      ld de,(iy+sprite_vel)
04312C CD 02 24 04 0147*      call polar_to_cartesian
043130 FD 2A 08 16 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043135 FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
043138 FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
04313B             0151*  ; change the animation frame to match heading
04313B             0152*  ; by dividng the heading by 8
04313B E1          0153*      pop hl ; get back Heading
04313C 7C          0154*      ld a,h
04313D CB 3F       0155*      srl a
04313F CB 3F       0156*      srl a
043141 CB 3F       0157*      srl a
043143 CD EF 21 04 0158*      call vdu_sprite_select_frame
043147             0159*  
043147             0160*  move_enemy_sprite:
043147 FD 2A 08 16 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04314C FD 27 0B    0162*      ld hl,(iy+sprite_x)
04314F FD 17 11    0163*      ld de,(iy+sprite_xvel)
043152 19          0164*      add hl,de
043153 FD 2F 0B    0165*      ld (iy+sprite_x),hl
043156 FD 27 0E    0166*      ld hl,(iy+sprite_y)
043159 FD 17 14    0167*      ld de,(iy+sprite_yvel)
04315C 19          0168*      add hl,de
04315D FD 2F 0E    0169*      ld (iy+sprite_y),hl
043160 C9          0170*      ret
043161             0171*  
043161             0172*  ; ; TODO: IMPLEMENT THIS PROPERLY
043161             0173*  ; move_enemy_sprite:
043161             0174*  ; ; x-axis movement first
043161             0175*  ;     ld hl,(iy+sprite_x)
043161             0176*  ;     push hl ; save pre-move position
043161             0177*  ;     pop bc ; to detect screen edge collision
043161             0178*  ;     ld de,(iy+sprite_xvel)
043161             0179*  ;     add hl,de ;compute new x position
043161             0180*  ;     ld (iy+sprite_x),hl ; store it
043161             0181*  ;     and a ; clear the carry flag
043161             0182*  ;     sbc hl,bc ; test which direction was our movement
043161             0183*  ;     jr z,@move_y ; zero flag means no horizontal movement
043161             0184*  ;     jp p,@move_right ; sign positive means moved right
043161             0185*  ; @move_left: ; otherwise we moved left
043161             0186*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
043161             0187*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
043161             0188*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
043161             0189*  ;     ld a,#20 ; west
043161             0190*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043161             0191*  ;     jr @move_y
043161             0192*  ; @move_right:
043161             0193*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
043161             0194*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
043161             0195*  ;     ld l,0x00
043161             0196*  ;     ld a,(iy+sprite_dim_x)
043161             0197*  ;     ld h,a
043161             0198*  ;     ld a,0x00
043161             0199*  ;     sub h
043161             0200*  ;     ld h,a
043161             0201*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
043161             0202*  ;     ld a,0x02 ; east
043161             0203*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043161             0204*  ; @move_y:
043161             0205*  ;     ld hl,(iy+sprite_y)
043161             0206*  ;     ld b,h ; save pre-move position
043161             0207*  ;     ld c,l ; to detect screen edge collision
043161             0208*  ;     ld de,(iy+sprite_yvel)
043161             0209*  ;     add hl,de ;compute new y position
043161             0210*  ;     ld (iy+sprite_y),hl ; store it
043161             0211*  ;     and a ; clear the carry flag
043161             0212*  ;     sbc hl,bc ; test which direction was our movement
043161             0213*  ;     jr z,@move_ret ; zero flag means no vertical movement
043161             0214*  ;     jp p,@move_dn ; sign positive means moved down
043161             0215*  ; @move_up:
043161             0216*  ;     add hl,bc ; get back new y position
043161             0217*  ;     ld de,0x5000 ; top edge of visible screen
043161             0218*  ;     and a ; clear the carry flag
043161             0219*  ;     sbc hl,de
043161             0220*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
043161             0221*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
043161             0222*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
043161             0223*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
043161             0224*  ;     or 0x80 ; north
043161             0225*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043161             0226*  ;     jr @move_ret
043161             0227*  ; @move_dn:
043161             0228*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
043161             0229*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
043161             0230*  ;     ld l,0x00
043161             0231*  ;     ld a,(iy+sprite_dim_y)
043161             0232*  ;     ld h,a
043161             0233*  ;     ld a,0x00
043161             0234*  ;     sub h
043161             0235*  ;     ld h,a
043161             0236*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
043161             0237*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
043161             0238*  ;     or 0x08 ; south
043161             0239*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
043161             0240*  ; @move_ret:
043161             0241*  ;     ret
043161             0242*  
043161             0243*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
043161             0244*  ; ; each sprite in the table must have one of these defined
043161             0245*  ; ; but they need not be unique to a particular sprite
043161             0246*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
043161             0247*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
043161             0248*  ; ; but they can call anything they want between those two endpoints
043161             0249*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
043161             0250*  
043161             0251*  ; move_nop: ; does nothing but burn a few cycles changing the PC
043161             0252*  ;     jp move_enemies_loop_return
043161             0253*  
043161             0254*  ; move_explosion:
043161             0255*  ;     call animate_explosion
043161             0256*  ;     jp move_enemies_loop_return
043161             0257*  
043161             0258*  move_enemy_small:
043161 CD 10 31 04 0259*      call en_nav
043165 CD 88 32 04 0260*      call check_collisions
043169 C3 A4 30 04 0261*      jp move_enemies_loop_return
04316D             0262*  
04316D             0263*  ; move_enemy_medium:
04316D             0264*  ;     call en_nav
04316D             0265*  ;     call check_collisions
04316D             0266*  ;     jp move_enemies_loop_return
04316D             0267*  
04316D             0268*  ; move_enemy_large:
04316D             0269*  ;     call en_nav
04316D             0270*  ;     call check_collisions
04316D             0271*  ;     jp move_enemies_loop_return
04316D             0272*  
04316D             0273*  ; move_landing_pad:
04316D             0274*  ;     call move_active_tiles
04316D             0275*  ;     call check_collisions
04316D             0276*  ; ; is it time to launch an enemy?
04316D             0277*  ;     ld hl,sprite_move_timer
04316D             0278*  ;     dec (hl)
04316D             0279*  ;     jp nz,move_enemies_loop_return
04316D             0280*  ;     call enemy_init_from_landing_pad
04316D             0281*  ;     ; reset move timer so can spawn again if player doesn't take us out
04316D             0282*  ;     call rand_8     ; snag a random number
04316D             0283*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04316D             0284*  ;     add a,64 ; range is now 64-127
04316D             0285*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04316D             0286*  ;     jp move_enemies_loop_return
04316D             0287*  
04316D             0288*  enemy_init_from_landing_pad:
04316D             0289*  ; get next available spriteId
04316D CD 2F 16 04 0290*      call table_get_next_id
043171 D0          0291*      ret nc ; no carry means no free sprite slots, so we go home
043172             0292*  ; ix comes back with the pointer to the new sprite variables
043172 DD E5       0293*      push ix ; de picks it up when we're ready for the copy to the table
043174             0294*  ; a comes back with the spriteId of the new sprite
043174 32 CA 31 04 0295*      ld (@id),a
043178             0296*  ; initialize the new sprite
043178 CD 8C 21 04 0297*      call vdu_sprite_select
04317C CD 9F 21 04 0298*      call vdu_sprite_clear_frames
043180 21 14 01 00 0299*      ld hl,BUF_SEEKER_000
043184 06 20       0300*      ld b,32
043186             0301*  @load_frames:
043186 C5          0302*      push bc
043187 E5          0303*      push hl
043188 CD D9 22 04 0304*      call vdu_sprite_add_buff
04318C E1          0305*      pop hl
04318D 23          0306*      inc hl
04318E C1          0307*      pop bc
04318F 10 F5       0308*      djnz @load_frames
043191             0309*  ; copy coordinates of active sprite to new sprite
043191 FD 2A 08 16 0310*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043196             0311*      ; ld hl,(iy+sprite_x)
043196             0312*  	; ld hl,0x008000 ; debug
043196             0313*  
043196 CD A9 23 04 0314*      call rand_8
04319A 21 00 00 00 0315*      ld hl,0
04319E 67          0316*      ld h,a
04319F             0317*  
04319F 22 D5 31 04 0318*      ld (@x),hl
0431A3             0319*      ; ld hl,(iy+sprite_y)
0431A3             0320*      ; ld hl,0x002000 ; debug
0431A3             0321*  
0431A3 CD A9 23 04 0322*      call rand_8
0431A7 21 00 00 00 0323*      ld hl,0
0431AB 67          0324*      ld h,a
0431AC             0325*  
0431AC 22 D8 31 04 0326*      ld (@y),hl
0431B0 CD A9 23 04 0327*      call rand_8
0431B4 E6 01       0328*      and %00000001 ; 50/50 chance of moving left or right on spanw
0431B6 32 ED 31 04 0329*      ld (@move_step),a
0431BA             0330*  ; now copy to the table
0431BA 21 CA 31 04 0331*      ld hl,@id ; address to copy from
0431BE D1          0332*      pop de ; address to copy to (was ix)
0431BF 01 26 00 00 0333*      ld bc,table_bytes_per_record ; number of bytes to copy
0431C3 ED B0       0334*      ldir ; copy the records from local scratch to sprite table
0431C5             0335*  ; finally, make the new sprite visible
0431C5 CD 02 22 04 0336*      call vdu_sprite_show
0431C9 C9          0337*      ret
0431CA 00          0338*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
0431CB 01          0339*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
0431CC 14 01 00    0340*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0431CF 61 31 04    0341*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0431D2 03          0342*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
0431D3 10          0343*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
0431D4 10          0344*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
0431D5 00 00 00    0345*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0431D8 00 00 00    0346*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0431DB 00 00 00    0347*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0431DE 00 00 00    0348*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0431E1 80 02 00    0349*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
0431E4 00 80 00    0350*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0431E7 00 80 00    0351*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
0431EA 00          0352*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
0431EB 00          0353*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
0431EC 01          0354*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
0431ED 00          0355*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
0431EE 20          0356*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
0431EF 02          0357*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
0431F0             0358*  
0431F0             0359*  ; move_laser_turret:
0431F0             0360*  ; ; compute orientation to player
0431F0             0361*  ;     call orientation_to_player
0431F0             0362*  ; ; h.l 8.8 fixed angle256 to player
0431F0             0363*  ; ; bc and de as signed 16-bit integers
0431F0             0364*  ; ; representing delta-x/y *to* target respectively
0431F0             0365*  ;     ld (Bearing_t),hl
0431F0             0366*  ;     ld hl,0x0400
0431F0             0367*  ;     ld (Vp),hl
0431F0             0368*  ;     call targeting_computer
0431F0             0369*  ;     ld (sprite_heading),hl ; store bearing to player
0431F0             0370*  ; ; is it time to launch a fireball?
0431F0             0371*  ;     ld hl,sprite_move_timer
0431F0             0372*  ;     dec (hl)
0431F0             0373*  ;     jp nz,move_laser_turret_boilerplate
0431F0             0374*  ;     call fireballs_init
0431F0             0375*  ;     ; reset move timer so can fire again if player doesn't take us out
0431F0             0376*  ;     call rand_8     ; snag a random number
0431F0             0377*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0431F0             0378*  ;     add a,64 ; range is now 64-127
0431F0             0379*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0431F0             0380*  ; move_laser_turret_boilerplate:
0431F0             0381*  ;     call move_active_tiles
0431F0             0382*  ;     call check_collisions
0431F0             0383*  ;     jp move_enemies_loop_return
0431F0             0384*  
0431F0             0385*  ; fireballs_init:
0431F0             0386*  ;     call sprite_variables_to_stack
0431F0             0387*  
0431F0             0388*  ;     ld hl,fireballs
0431F0             0389*  ;     ld (sprite_base_bufferId),hl
0431F0             0390*  
0431F0             0391*  ;     ld hl,move_fireballs
0431F0             0392*  ;     ld (sprite_move_program),hl
0431F0             0393*  
0431F0             0394*  ;     ld a,%11 ; collides with laser and player
0431F0             0395*  ;     ; ld a,%10 ; collides with laser DEBUG
0431F0             0396*  ;     ld (iy+sprite_collisions),a
0431F0             0397*  
0431F0             0398*  ;     ld hl,(Vp)
0431F0             0399*  ;     ld (sprite_vel),hl
0431F0             0400*  ;     ld hl,(Vp_x)
0431F0             0401*  ;     ld (sprite_xvel),hl
0431F0             0402*  ;     ld hl,(Vp_y)
0431F0             0403*  ;     inc h ; account for ground movement
0431F0             0404*  ;     ld (sprite_yvel),hl
0431F0             0405*  
0431F0             0406*  ;     xor a ; zero a
0431F0             0407*  ;     ld (sprite_animation),a
0431F0             0408*  ;     ld (sprite_move_step),a
0431F0             0409*  ;     ld (sprite_move_timer),a
0431F0             0410*  
0431F0             0411*  ;     ld a,6 ; 1/10th of a second timer
0431F0             0412*  ;     ld (sprite_animation_timer),a
0431F0             0413*  
0431F0             0414*  ;     ld a,0x00 ; BCD
0431F0             0415*  ;     ld (sprite_points),a
0431F0             0416*  ;     ld a,1 ; binary
0431F0             0417*  ;     ld (sprite_shield_damage),a
0431F0             0418*  
0431F0             0419*  ;     call table_add_record ; plops that on the sprite stack for later
0431F0             0420*  ;     call sprite_variables_from_stack ; come back to where we started
0431F0             0421*  ;     ret
0431F0             0422*  
0431F0             0423*  ; move_fireballs:
0431F0             0424*  ;     call move_enemy_sprite ; move sprite
0431F0             0425*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
0431F0             0426*  ;     and a ; if zero we're still within screen bounds
0431F0             0427*  ;     jr z,move_fireballs_alive
0431F0             0428*  ; ; otherwise kill sprite
0431F0             0429*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
0431F0             0430*  ;     ld (iy+sprite_collisions),a
0431F0             0431*  ;     jp move_enemies_loop_return
0431F0             0432*  ; move_fireballs_alive:
0431F0             0433*  ;     ld a,(sprite_animation_timer)
0431F0             0434*  ;     dec a
0431F0             0435*  ;     ld (sprite_animation_timer),a
0431F0             0436*  ;     jr nz,move_fireballs_draw
0431F0             0437*  ;     ld a,(sprite_animation)
0431F0             0438*  ;     xor %1
0431F0             0439*  ;     ld (sprite_animation),a
0431F0             0440*  ;     ld a,6 ; 1/10th of a second timer
0431F0             0441*  ;     ld (sprite_animation_timer),a
0431F0             0442*  ;     ; fall through
0431F0             0443*  
0431F0             0444*  ; move_fireballs_draw:
0431F0             0445*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0431F0             0446*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0431F0             0447*  ;     call check_collisions
0431F0             0448*  ;     jp move_enemies_loop_return
0431F0             0449*  
0431F0             0450*  ; compute orientation to player
0431F0             0451*  ; based on relative positions
0431F0             0452*  ; returns: h.l 16.8 fixed angle256 to player
0431F0             0453*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0431F0             0454*  ;    representing delta-x/y *to* target respectively
0431F0             0455*  orientation_to_player:
0431F0 FD 2A 08 16 0456*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0431F5 FD E5       0457*      push iy ; so we can send it back intact
0431F7 FD 07 0B    0458*      ld bc,(iy+sprite_x)
0431FA FD 17 0E    0459*      ld de,(iy+sprite_y)
0431FD DD 2A 99 2E 0460*      ld ix,(player_x)
       04          
043202 FD 2A 9C 2E 0461*      ld iy,(player_y)
       04          
043207 CD 37 24 04 0462*      call dxy168
04320B C5          0463*      push bc
04320C D5          0464*      push de
04320D CD 83 24 04 0465*      call atan2_168fast
043211 D1          0466*      pop de
043212 C1          0467*      pop bc
043213 FD E1       0468*      pop iy ; restore table pointer
043215 C9          0469*      ret
043216             0470*  
043216             0471*  
043216             0472*  ; targeting_computer scratch variables
043216 00 00       0473*  Bearing_t: dw #0000 ; 8.8 fixed
043218 00 00       0474*  Heading_t: dw #0000 ; 8.8 fixed
04321A 00 00       0475*  Vp: dw #0000 ; 8.8 fixed
04321C 00 00       0476*  Vp_x: dw #0000 ; 8.8 fixed
04321E 00 00       0477*  Vp_y: dw #0000 ; 8.8 fixed
043220 00 00       0478*  Vt: dw #0000 ; 8.8 fixed
043222 00 00       0479*  Vt_x: dw #0000 ; 8.8 fixed
043224 00 00       0480*  Vt_y: dw #0000 ; 8.8 fixed
043226             0481*  
043226             0482*  
043226             0483*  ; ; Inputs:   see scratch variables
043226             0484*  ; ; Note:     a call to orientation_to_player provides these inputs
043226             0485*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
043226             0486*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
043226             0487*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
043226             0488*  ; targeting_computer:
043226             0489*  ; ; compute target velocity from x,y component velocities
043226             0490*  ;     ld bc,(player_xvel)
043226             0491*  ;     ld de,(player_yvel)
043226             0492*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
043226             0493*  
043226             0494*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
043226             0495*  ;     ld (Heading_t),bc
043226             0496*  ;     ld (Vt),de
043226             0497*  
043226             0498*  ; ; compute Heading_t-Bearing_t
043226             0499*  ;     ld h,b
043226             0500*  ;     ld l,c
043226             0501*  ;     ld bc,(Bearing_t)
043226             0502*  ;     and a ; clear carry
043226             0503*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
043226             0504*  
043226             0505*  ; ; compute sin(Heading_t-Bearing_t)
043226             0506*  ;     ld b,h
043226             0507*  ;     ld c,l
043226             0508*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
043226             0509*  
043226             0510*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
043226             0511*  ;     ex de,hl
043226             0512*  ;     ld bc,(Vt)
043226             0513*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
043226             0514*  
043226             0515*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
043226             0516*  ;     ld b,h
043226             0517*  ;     ld c,l
043226             0518*  ;     ld de,(Vp)
043226             0519*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
043226             0520*  ; ; answer is in radians, convert to degrees256
043226             0521*  ;     ex de,hl
043226             0522*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
043226             0523*  ;     call BC_Mul_DE_88
043226             0524*  
043226             0525*  ; ; add lead angle to target bearing
043226             0526*  ;     ld de,(Bearing_t)
043226             0527*  ;     add hl,de ; h.l=lead angle+target bearing
043226             0528*  ;     push hl
043226             0529*  
043226             0530*  ; ; compute component projectile velocities
043226             0531*  ;     ld b,h
043226             0532*  ;     ld c,l
043226             0533*  ;     ld de,(Vp)
043226             0534*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
043226             0535*  
043226             0536*  ;     ld (Vp_x),bc
043226             0537*  ;     ld (Vp_y),de
043226             0538*  ;     pop hl ; h.l=lead angle+target bearing
043226             0539*  ;     ret
043226             0540*  
043226             0541*  ; this routine vanquishes the enemy sprite
043226             0542*  ; and replaces it with an animated explosion
043226             0543*  ; we jump here instead of call because
043226             0544*  ; we want to return to differing locations in the loop
043226             0545*  ; depending on whether we're still sploding
043226             0546*  ; destroys: everything except index registers
043226             0547*  ; returns: an incandescent ball of debris and gas
043226             0548*  kill_nurple:
043226             0549*  ; ; tally up points
043226             0550*  ;     ld bc,0
043226             0551*  ;     ld a,(sprite_points)
043226             0552*  ;     ld e,a
043226             0553*  ;     ld d,0
043226             0554*  ;     ld hl,add_bcd_arg2
043226             0555*  ;     call set_bcd
043226             0556*  ;     ld hl,player_score
043226             0557*  ;     ld de,add_bcd_arg2
043226             0558*  ;     ld a,3 ; number of bytes to add
043226             0559*  ;     call add_bcd
043226             0560*  ; ; initialize explosion
043226             0561*  ; init_explosion:
043226             0562*  ;     ld hl,explosion
043226             0563*  ;     ld (sprite_base_bufferId),hl
043226             0564*  ;     ld hl,move_explosion
043226             0565*  ;     ld (sprite_move_program),hl
043226             0566*  ;     ld a,%00000000 ; collides with nothing
043226             0567*  ;     ld (iy+sprite_collisions),a
043226             0568*  ;     ld hl,0 ; north
043226             0569*  ;     ld (sprite_heading),hl
043226             0570*  ;     ld a,0x04 ; will decrement to 03
043226             0571*  ;     ld (sprite_animation),a
043226             0572*  ;     ld a,0x07 ; 7/60th of a second timer
043226             0573*  ;     ld (sprite_animation_timer),a
043226             0574*  ;     xor a
043226             0575*  ;     ld (sprite_move_timer),a
043226             0576*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043226             0577*  ; ; fall through to next_explosion
043226             0578*  ; next_explosion:
043226             0579*  ;     ld a,(sprite_animation)
043226             0580*  ;     dec a ; if rolled negative from zero,we're done sploding
043226             0581*  ;     jp m,done_explosion
043226             0582*  ;     ld (sprite_animation),a
043226             0583*  ;     ld a,0x7 ; 7/60th of a second timer
043226             0584*  ;     ld (sprite_animation_timer),a
043226             0585*  ; ; fall through to animate_explosion
043226             0586*  ; animate_explosion:
043226             0587*  ;     ld hl,sprite_y+1
043226             0588*  ;     inc (hl) ; move explosion down 1 pixel
043226             0589*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
043226             0590*  ;     ld hl,sprite_animation_timer
043226             0591*  ;     dec (hl) ; if timer is zero,we do next animation
043226             0592*  ;     jr z,next_explosion
043226             0593*  ;     ;otherwise we fall through to draw the current one
043226             0594*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043226             0595*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043226             0596*  ;     ret ; now we go back to caller
043226             0597*  ; done_explosion:
043226 3E 80       0598*      ld a,%10000000 ; high bit set is non-specific kill-me flag
043228 FD 2A 08 16 0599*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
04322D FD 77 08    0600*      ld (iy+sprite_collisions),a
043230 C9          0601*      ret ; now we go back to caller
043231             0602*  
043231             0603*  ; game_over:
043231             0604*  ;     jp new_game
043231             0605*  
043231             0606*  ; it's presumed we've already checked that laser is alive
043231             0607*  collision_enemy_with_laser:
043231 DD 2A C0 32 0608*      ld ix,(laser_x)
       04          
043236 FD 2A C3 32 0609*      ld iy,(laser_y)
       04          
04323B 3A BE 32 04 0610*      ld a,(laser_dim_x)
04323F CB 2F       0611*      sra a ; divide by 2
043241 F5          0612*      push af ; we need this later
043242 C3 57 32 04 0613*      jp collision_enemy
043246             0614*  
043246             0615*  ; it's presumed we've already checked that player is alive
043246             0616*  collision_enemy_with_player:
043246 DD 2A 99 2E 0617*      ld ix,(player_x)
       04          
04324B FD 2A 9C 2E 0618*      ld iy,(player_y)
       04          
043250 3A 97 2E 04 0619*      ld a,(player_dim_x)
043254 CB 2F       0620*      sra a ; divide by 2
043256 F5          0621*      push af ; we need this later
043257             0622*      ; fall through to collision_enemy
043257             0623*  
043257             0624*  ; compute the distance between the two sprites' centers
043257             0625*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
043257             0626*  collision_enemy:
043257             0627*  ; back up iy because we need it as the sprite table pointer
043257 FD E5       0628*      push iy
043259 FD 2A 08 16 0629*      ld iy,(table_pointer)
       04          
04325E FD 27 0B    0630*      ld hl,(iy+sprite_x)
043261 FD 7E 09    0631*      ld a,(iy+sprite_dim_x)
043264 CB 2F       0632*      sra a
043266 F5          0633*      push af ; we need this later
043267 E5          0634*      push hl
043268 C1          0635*      pop bc ; bc = x0
043269 FD 27 0E    0636*      ld hl,(iy+sprite_y)
04326C FD 7E 0A    0637*      ld a,(iy+sprite_dim_y)
04326F EB          0638*      ex de,hl ; de = y0
043270 F1          0639*      pop af ; TODO: srsly, this is the best way to do this?
043271 FD E1       0640*      pop iy
043273 F5          0641*      push af
043274 CD 5E 24 04 0642*      call distance168
043278             0643*  
043278             0644*  ; ; subtract sum of radii from distance between centers
043278             0645*  ;     ld de,0
043278             0646*  ;     pop af ; radius of enemy sprite
043278             0647*  ;     ld e,a
043278             0648*  ;     pop af ; radius of player or laser sprite
043278             0649*  ;     add a,e
043278             0650*  ;     ld e,a
043278             0651*  ;     and a ; clear carry
043278             0652*  ;     sbc hl,de
043278             0653*  ;     jr c,collision_enemy_is
043278             0654*  ;     xor a
043278             0655*  ;     ret
043278             0656*  ; temp fix TODO: remove this
043278 F1          0657*      pop af
043279 F1          0658*      pop af
04327A 11 00 10 00 0659*      ld de,16*256
04327E A7          0660*      and a
04327F ED 52       0661*      sbc hl,de
043281 38 02       0662*      jr c,collision_enemy_is
043283 AF          0663*      xor a
043284 C9          0664*      ret
043285             0665*  collision_enemy_is:
043285 AF          0666*      xor a
043286 3C          0667*      inc a
043287 C9          0668*      ret
043288             0669*  
043288             0670*  ; ; looks up what enemy sprite collides with
043288             0671*  ; ; detects collisions
043288             0672*  ; ; and sets things to sploding accordingly
043288             0673*  ; check_collisions:
043288             0674*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
043288             0675*  ;     and a ; if this is zero,
043288             0676*  ;     ret z ; there's nothing to do
043288             0677*  ;     and %01 ; do we collide with player?
043288             0678*  ;     jr z,move_enemies_laser ; if not,check laser collision
043288             0679*  ;     call collision_enemy_with_player ; otherwise see if we hit player
043288             0680*  ;     and a ; was there a collision?
043288             0681*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
043288             0682*  ; ; yes collision with player
043288             0683*  ;     ; deduct shield damage
043288             0684*  ;     ld hl,sprite_shield_damage
043288             0685*  ;     ld a,(player_shields)
043288             0686*  ;     sub (hl)
043288             0687*  ;     ld (player_shields),a
043288             0688*  ; ; if shields >= 0,player survives
043288             0689*  ;     jp p,check_collisions_kill_nurple
043288             0690*  ; ; otherwise update player status so it will die
043288             0691*  ;     ld a,(player_collisions)
043288             0692*  ;     or %10 ; sets bit 1,meaning player just died
043288             0693*  ;     ld (player_collisions),a
043288             0694*  ;     ; fall through
043288             0695*  ; check_collisions_kill_nurple:
043288             0696*  ; ; kill enemy and replace with explosion
043288             0697*  ;     call kill_nurple
043288             0698*  ;     ret ; and out
043288             0699*  
043288             0700*  check_collisions:
043288 CD 46 32 04 0701*      call collision_enemy_with_player ; did we hit the player?
04328C A7          0702*      and a ; was there a collision?
04328D C8          0703*      ret z ; if not,we're done
04328E CD 26 32 04 0704*      call kill_nurple ; otherwise kill enemy
043292 C9          0705*      ret
043293             0706*  
043293             0707*  ; did we hit the laser?
043293             0708*  move_enemies_laser:
043293 FD 7E 08    0709*      ld a,(iy+sprite_collisions) ; snag what we collide with again
043296 E6 02       0710*      and %10 ; do we even collide with laser?
043298 C8          0711*      ret z ; if not,we're out
043299 3A BD 32 04 0712*      ld a,(laser_collisions) ; is laser alive?
04329D E6 01       0713*      and %1 ; if bit 0 is not set laser is dead
04329F C8          0714*      ret z ; so we're out
0432A0 CD 31 32 04 0715*      call collision_enemy_with_laser ; otherwise check for collision
0432A4 A7          0716*      and a ; was there a collision?
0432A5 C8          0717*      ret z ; if not,we're done
0432A6             0718*  ; otherwise we mark laser for termination and kill enemy
0432A6             0719*  ; update laser status so it will die
0432A6 3A BD 32 04 0720*      ld a,(laser_collisions)
0432AA F6 02       0721*      or %10 ; bit 1 set means laser just died
0432AC 32 BD 32 04 0722*      ld (laser_collisions),a
0432B0 CD 26 32 04 0723*      call kill_nurple ; yes there was a collision,so kill enemy
0432B4 C9          0724*      ret ; we're outta' here
0432B5             0065   	include "laser.inc"
0432B5             0001*  ; ##### LASER SPRITE PARAMETERS #####
0432B5             0002*  ; uses the same offsets from its table base as the main sprite table:
0432B5             0003*  laser_start_variables: ; label marking beginning of table
0432B5 02          0004*  laser_id:               db table_max_records+1
0432B6 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
0432B7 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0432BA 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0432BD 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0432BE 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0432BF 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0432C0 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0432C3 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0432C6 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0432C9 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0432CC 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
0432CF 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0432D2 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
0432D5 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
0432D6 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
0432D7 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
0432D8 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
0432D9 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
0432DA 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
0432DB             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
0432DB             0025*  
0432DB             0026*  ; laser_control:
0432DB             0027*  ; ; is laser already active?
0432DB             0028*  ;     ld a,(laser_collisions)
0432DB             0029*  ;     and %00000001 ; bit zero is lit if laser is active
0432DB             0030*  ;     jr nz,laser_move ; move laser if not zero
0432DB             0031*  ; ; otherwise check if laser fired
0432DB             0032*  ;     in a,(#82) ; keyboard
0432DB             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
0432DB             0034*  ;     ret z ; go back if laser not fired
0432DB             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
0432DB             0036*  ; ; set laser status to active (set bit 0)
0432DB             0037*  ;     ld a,%1
0432DB             0038*  ;     ld (laser_collisions),a
0432DB             0039*  ; ; initialize laser position
0432DB             0040*  ;     ld a,(player_x+1) ; we only need the integer part
0432DB             0041*  ;     ; add a,6 ; horizontal center with player sprite
0432DB             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
0432DB             0043*  ;     ld a,(player_y+1) ; we only need the integer part
0432DB             0044*  ;     add a,-6 ; set laser y a few pixels above player
0432DB             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
0432DB             0046*  ;     ; fall through to laser_move
0432DB             0047*  
0432DB             0048*  ; laser_move:
0432DB             0049*  ; ; begin setting laser to active sprite
0432DB             0050*  ;     ld hl,lasers
0432DB             0051*  ;     ld (sprite_base_bufferId),hl
0432DB             0052*  ;     ld hl,0 ; north
0432DB             0053*  ;     ld (sprite_heading),hl
0432DB             0054*  ;     xor a ; laser has no animations yet :-(
0432DB             0055*  ;     ld (sprite_animation),a
0432DB             0056*  ;     ; we set position here for the time being as a default
0432DB             0057*  ;     ; in case the laser is flagged for deletion
0432DB             0058*  ;     ; load sprite_x with laser x position (we do y further down)
0432DB             0059*  ;     ld hl,(laser_x)
0432DB             0060*  ;     ld (sprite_x),hl
0432DB             0061*  ; ; did laser just die?
0432DB             0062*  ;     ld a,(laser_collisions)
0432DB             0063*  ;     bit 1,a ; z if laser didn't just die
0432DB             0064*  ;     jr z,laser_not_dead_yet
0432DB             0065*  ; ; yes laser died
0432DB             0066*  ;     call kill_laser
0432DB             0067*  ;     ret ; done
0432DB             0068*  ; laser_not_dead_yet:
0432DB             0069*  ; ; draw it
0432DB             0070*  ; ; update laser y position
0432DB             0071*  ;     ld hl,(laser_y) ; grab laser y position
0432DB             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
0432DB             0073*  ;     add hl,de ; add y velocity to y pos
0432DB             0074*  ;     ld (sprite_y),hl ; update laser y position
0432DB             0075*  ;     ld (laser_y),hl ; update laser y position
0432DB             0076*  ; ; are we at top of screen?
0432DB             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
0432DB             0078*  ;     sub h ; no carry if above threshold
0432DB             0079*  ;     jr c,finally_draw_the_frikken_laser
0432DB             0080*  ;     ; if at top of screen,laser dies
0432DB             0081*  ;     call kill_laser
0432DB             0082*  ;     ret
0432DB             0083*  ; ; otherwise,finally draw the frikken laser
0432DB             0084*  ; finally_draw_the_frikken_laser:
0432DB             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0432DB             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0432DB             0087*  ; ; all done
0432DB             0088*  ;     ret
0432DB             0089*  
0432DB             0090*  ; kill_laser:
0432DB             0091*  ; ; update status to inactive
0432DB             0092*  ;     xor a ; zero out a
0432DB             0093*  ;     ld (laser_collisions),a
0432DB             0094*  ;     ret
0432DB             0066   	include "timer.inc"
0432DB             0001*  ; Table 32. Timer Control Registers
0432DB             0002*  ; this constant is the base address of the timer control registers
0432DB             0003*  ; each timer takes three bytes:
0432DB             0004*  ;   0: control register
0432DB             0005*  ;   1: low byte of timer reset value
0432DB             0006*  ;   2: high byte of timer reset value
0432DB             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0432DB             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0432DB             0009*  TMR_CTL:     equ 80h
0432DB             0010*  
0432DB             0011*  ; Timer Control Register Bit Definitions
0432DB             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0432DB             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0432DB             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0432DB             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0432DB             0016*                              ; the TMRx_CTL register is read.
0432DB             0017*  
0432DB             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0432DB             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0432DB             0020*  
0432DB             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0432DB             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0432DB             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0432DB             0024*                              ; written to the counter when the end-of-count value is reached.
0432DB             0025*  
0432DB             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0432DB             0027*  CLK_DIV_256:  equ %00001100 ;
0432DB             0028*  CLK_DIV_64:   equ %00001000 ;
0432DB             0029*  CLK_DIV_16:   equ %00000100 ;
0432DB             0030*  CLK_DIV_4:    equ %00000000 ;
0432DB             0031*  
0432DB             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0432DB             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0432DB             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0432DB             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0432DB             0036*                              ; programmer must ensure that this bit is set to 1 each time
0432DB             0037*                              ; SINGLE-PASS mode is used.
0432DB             0038*  
0432DB             0039*  ; disable/enable the programmable reload timer
0432DB             0040*  PRT_EN_0:     equ %00000000 ;
0432DB             0041*  PRT_EN_1:     equ %00000001 ;
0432DB             0042*  
0432DB             0043*  ; Table 37. Timer Input Source Select Register
0432DB             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0432DB             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0432DB             0046*  ;   00: System clock / CLK_DIV
0432DB             0047*  ;   01: RTC / CLK_DIV
0432DB             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0432DB             0049*  ;   10: GPIO port B pin 1.
0432DB             0050*  ;   11: GPIO port B pin 1.
0432DB             0051*  TMR_ISS:   equ 92h ; register address
0432DB             0052*  
0432DB             0053*  ; Table 51. Real-Time Clock Control Register
0432DB             0054*  RTC_CTRL: equ EDh ; register address
0432DB             0055*  
0432DB             0056*  ; alarm interrupt disable/enable
0432DB             0057*  RTC_ALARM_0:    equ %00000000
0432DB             0058*  RTC_ALARM_1:    equ %10000000
0432DB             0059*  
0432DB             0060*  ; interrupt on alarm disable/enable
0432DB             0061*  RTC_INT_ENT_0:  equ %00000000
0432DB             0062*  RTC_INT_ENT_1:  equ %01000000
0432DB             0063*  
0432DB             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0432DB             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0432DB             0066*  
0432DB             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0432DB             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0432DB             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0432DB             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0432DB             0071*  
0432DB             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0432DB             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0432DB             0074*  
0432DB             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0432DB             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0432DB             0077*  
0432DB             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0432DB             0079*                                  ; RTC counter is enabled.
0432DB             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0432DB             0081*                                  ; RTC counter is disabled.
0432DB             0082*  
0432DB             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0432DB             0084*  
0432DB             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0432DB             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0432DB 00 00 00    0087*  prt_reload: dl 0x000000
0432DE             0088*  
0432DE             0089*  ; set PRT timer
0432DE             0090*  prt_set:
0432DE 21 00 00 00 0091*      ld hl,0
0432E2 22 2C 33 04 0092*      ld (prt_irq_counter),hl
0432E6 2A DB 32 04 0093*      ld hl,(prt_reload)
0432EA ED 29 84    0094*      out0 ($84),l
0432ED ED 21 85    0095*  	out0 ($85),h
0432F0             0096*  ; disable timer
0432F0 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0432F2 ED 39 83    0098*  	out0 ($83),a
0432F5             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0432F5 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0432F7 ED 39 83    0101*  	out0 ($83),a
0432FA C9          0102*      ret
0432FB             0103*  
0432FB             0104*  ; ===============================================
0432FB             0105*  ; PRT Timer Interrupt Handling
0432FB             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0432FB             0107*  ; -----------------------------------------------
0432FB             0108*  prt_irq_init:
0432FB             0109*      ; set up interrupt vector table 2
0432FB 21 00 00 00 0110*  	ld hl,0
0432FF 3A 0C 01 00 0111*  	ld a,($10c)
043303 6F          0112*  	ld l,a
043304 3A 0D 01 00 0113*  	ld a,($10d)
043308 67          0114*  	ld h,a
043309             0115*  
043309             0116*  	; skip over CALL ($c3)
043309 23          0117*  	inc hl
04330A             0118*  	; load address of jump into vector table 2 (in ram)
04330A ED 27       0119*  	ld hl,(hl)
04330C             0120*  
04330C             0121*  	; write CALL prt_irq_handler to vector table 2
04330C 3E C3       0122*  	ld a,$c3
04330E 77          0123*  	ld (hl),a
04330F 23          0124*  	inc hl
043310 11 17 33 04 0125*  	ld de,prt_irq_handler
043314 ED 1F       0126*  	ld (hl),de
043316             0127*  
043316 C9          0128*      ret
043317             0129*  
043317             0130*  prt_irq_handler:
043317 F3          0131*  	di
043318 F5          0132*  	push af
043319 E5          0133*      push hl
04331A ED 38 83    0134*  	in0 a,($83)
04331D 2A 2C 33 04 0135*  	ld hl,(prt_irq_counter)
043321 23          0136*  	inc hl
043322 22 2C 33 04 0137*  	ld (prt_irq_counter),hl
043326 E1          0138*      pop hl
043327 F1          0139*  	pop af
043328 FB          0140*  	ei
043329 5B ED 4D    0141*  	reti.l
04332C             0142*  
04332C             0143*  prt_irq_counter:
04332C 00 00 00    0144*  	.dl 0
04332F             0145*  prt_irq_counter_saved:
04332F 00 00 00    0146*      .dl 0
043332             0147*  
043332             0148*  prt_loop_reset:
043332 E5          0149*      push hl
043333 21 00 00 00 0150*  	ld hl,0
043337 22 2C 33 04 0151*  	ld (prt_irq_counter),hl
04333B 22 9D 33 04 0152*      ld (prt_loop_counter),hl
04333F 22 A0 33 04 0153*      ld (prt_loops),hl
043343 CD DE 32 04 0154*      call prt_set
043347 E1          0155*      pop hl
043348 C9          0156*      ret
043349             0157*  
043349             0158*  prt_loop_start:
043349 E5          0159*      push hl
04334A 21 00 00 00 0160*  	ld hl,0
04334E 22 2C 33 04 0161*  	ld (prt_irq_counter),hl
043352 E1          0162*      pop hl
043353 C9          0163*      ret
043354             0164*  
043354             0165*  prt_loop_stop:
043354 E5          0166*      push hl
043355 D5          0167*      push de
043356 2A 2C 33 04 0168*      ld hl,(prt_irq_counter)
04335A ED 5B 9D 33 0169*      ld de,(prt_loop_counter)
       04          
04335F 19          0170*      add hl,de
043360 22 9D 33 04 0171*      ld (prt_loop_counter),hl
043364 21 00 00 00 0172*      ld hl,0
043368 22 2C 33 04 0173*      ld (prt_irq_counter),hl
04336C 2A A0 33 04 0174*      ld hl,(prt_loops)
043370 23          0175*      inc hl
043371 22 A0 33 04 0176*      ld (prt_loops),hl
043375 D1          0177*      pop de
043376 E1          0178*      pop hl
043377 C9          0179*      ret
043378             0180*  
043378             0181*  ; inputs: bc = y,x text coordinates to print
043378             0182*  prt_loop_print:
043378 F5          0183*      push af
043379 E5          0184*      push hl
04337A C5          0185*      push bc
04337B D5          0186*      push de
04337C DD E5       0187*      push ix
04337E FD E5       0188*      push iy
043380 CD 21 1D 04 0189*      call vdu_move_cursor
043384             0190*  
043384 2A 9D 33 04 0191*      ld hl,(prt_loop_counter)
043388 CD D2 17 04 0192*      call printDec
04338C             0193*  
04338C 2A A0 33 04 0194*      ld hl,(prt_loops)
043390 CD D2 17 04 0195*      call printDec
043394             0196*  
043394 FD E1       0197*      pop iy
043396 DD E1       0198*      pop ix
043398 D1          0199*      pop de
043399 C1          0200*      pop bc
04339A E1          0201*      pop hl
04339B F1          0202*      pop af
04339C C9          0203*      ret
04339D             0204*  
04339D             0205*  prt_loop_counter:
04339D 00 00 00    0206*      .dl 0
0433A0             0207*  prt_loops:
0433A0 00 00 00    0208*      .dl 0
0433A3             0209*  
0433A3             0210*  ; ===============================================
0433A3             0211*  ; Timer functions
0433A3             0212*  ; -----------------------------------------------
0433A3             0213*  ; set a countdown timer
0433A3             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433A3             0215*  ; returns: hl = current time
0433A3             0216*  tmr_set:
0433A3 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0433A6             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0433A6 3E 08       0001*M 			LD	A, function
0433A8 5B CF       0002*M 			RST.LIL	08h
0433AA DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0433AD FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0433B0 C9          0221*      ret
0433B1             0222*  
0433B1             0223*  ; gets time remaining on a countdown timer
0433B1             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433B1             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0433B1             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0433B1             0227*  tmr_get:
0433B1             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0433B1 3E 08       0001*M 			LD	A, function
0433B3 5B CF       0002*M 			RST.LIL	08h
0433B5 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0433B8 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0433BB AF          0231*      xor a                   ; clear carry
0433BC ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0433BE FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0433C1 AF          0234*      xor a                   ; clear carry
0433C2 ED 5A       0235*      adc hl,de               ; hl = time remaining
0433C4             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0433C4 C9          0237*      ret
0433C5             0238*  
0433C5             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0433CB             0240*  
0433CB 00 00 00    0241*  timestamp_now: dl 0
0433CE 00 00 00    0242*  timestamp_old: dl 0
0433D1 00 00 00    0243*  timestamp_chg: dl 0
0433D4             0244*  
0433D4             0245*  ; update the global timestamp from the system clock
0433D4             0246*  ; inputs: none
0433D4             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0433D4             0248*  ;          de = current time
0433D4             0249*  ;          ix = pointer to syvars table
0433D4             0250*  ; destroys: af,hl,de,ix
0433D4             0251*  timestamp_tick:
0433D4 ED 5B CB 33 0252*      ld de,(timestamp_now)   ; get previous time
       04          
0433D9 ED 53 CE 33 0253*      ld (timestamp_old),de   ; save previous time
       04          
0433DE             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
0433DE 3E 08       0001*M 			LD	A, function
0433E0 5B CF       0002*M 			RST.LIL	08h
0433E2 DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
0433E5 22 CB 33 04 0256*      ld (timestamp_now),hl   ; save current time
0433E9 AF          0257*      xor a                   ; clear carry
0433EA ED 52       0258*      sbc hl,de               ; hl = time elapsed
0433EC 22 D1 33 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
0433F0 C9          0260*      ret
0433F1             0261*  
0433F1             0262*  ; set a countdown timer
0433F1             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433F1             0264*  ; requires: timestamp_tick to be called at least once before this function
0433F1             0265*  ; returns: hl = current time
0433F1             0266*  ; destroys: hl
0433F1             0267*  timestamp_tmr_set:
0433F1 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
0433F4 2A CB 33 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
0433F8 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
0433FB C9          0271*      ret
0433FC             0272*  
0433FC             0273*  ; gets time remaining on a countdown timer following the global timestamp
0433FC             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0433FC             0275*  ; requires: timestamp_tick to be called at least once before this function
0433FC             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0433FC             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
0433FC             0278*  ; destroys: af,hl,de
0433FC             0279*  timestamp_tmr_get:
0433FC ED 5B CB 33 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
043401 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043404 AF          0282*      xor a                   ; clear carry
043405 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043407 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
04340A AF          0285*      xor a                   ; clear carry
04340B ED 5A       0286*      adc hl,de               ; hl = time remaining
04340D             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04340D C9          0288*      ret
04340E             0289*  
04340E             0290*  ; set a stopwatch
04340E             0291*  ; returns: hl = start time
04340E             0292*  ; destroys: hl,ix
04340E             0293*  stopwatch_set:
04340E             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
04340E 3E 08       0001*M 			LD	A, function
043410 5B CF       0002*M 			RST.LIL	08h
043412 DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
043415 22 2A 34 04 0296*      ld (stopwatch_started),hl            ; set start time
043419 C9          0297*      ret
04341A             0298*  
04341A             0299*  ; gets time elapsed on a stopwatch
04341A             0300*  ; returns: hl = time elapsed in 1/120ths of a second
04341A             0301*  ; destroys: af,hl,de,ix
04341A             0302*  stopwatch_get:
04341A             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
04341A 3E 08       0001*M 			LD	A, function
04341C 5B CF       0002*M 			RST.LIL	08h
04341E DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
043421 ED 5B 2A 34 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043426 AF          0306*      xor a                   ; clear carry
043427 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
043429 C9          0308*      ret
04342A             0309*  
04342A             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04342D             0311*  
04342D             0312*  ; ------------------
04342D             0313*  ; delay routine
04342D             0314*  ; Author: Richard Turrnidge
04342D             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04342D             0316*  ; routine waits a fixed time,then returns
04342D             0317*  ; arrive with A =  the delay byte. One bit to be set only.
04342D             0318*  ; eg. ld A,00000100b
04342D             0319*  
04342D             0320*  multiPurposeDelay:
04342D F5          0321*      push af
04342E C5          0322*      push bc
04342F DD E5       0323*      push ix
043431 47          0324*      ld b,a
043432 3E 08       0325*      ld a,$08
043434 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043436             0327*  
043436             0328*  waitLoop:
043436             0329*  
043436 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
043439             0331*  
043439             0332*                                  ;   we check if bit set is same as last time we checked.
043439             0333*                                  ;   bit 0 - don't use
043439             0334*                                  ;   bit 1 - changes 64 times per second
043439             0335*                                  ;   bit 2 - changes 32 times per second
043439             0336*                                  ;   bit 3 - changes 16 times per second
043439             0337*  
043439             0338*                                  ;   bit 4 - changes 8 times per second
043439             0339*                                  ;   bit 5 - changes 4 times per second
043439             0340*                                  ;   bit 6 - changes 2 times per second
043439             0341*                                  ;   bit 7 - changes 1 times per second
043439 A0          0342*      and b
04343A 4F          0343*      ld c,a
04343B 3A 4C 34 04 0344*      ld a,(oldTimeStamp)
04343F B9          0345*      cp c                        ; is A same as last value?
043440 28 F4       0346*      jr z,waitLoop              ; loop here if it is
043442 79          0347*      ld a,c
043443 32 4C 34 04 0348*      ld (oldTimeStamp),a        ; set new value
043447             0349*  
043447 DD E1       0350*      pop ix
043449 C1          0351*      pop bc
04344A F1          0352*      pop af
04344B C9          0353*      ret
04344C             0354*  
04344C 00          0355*  oldTimeStamp:   .db 00h
04344D             0067   
04344D             0068   ; new includes
04344D             0069   	include "images.inc"
04344D             0001*  image_type: equ 0
04344D             0002*  image_width: equ image_type+3
04344D             0003*  image_height: equ image_width+3
04344D             0004*  image_filesize: equ image_height+3
04344D             0005*  image_filename: equ image_filesize+3
04344D             0006*  image_bufferId: equ image_filename+3
04344D             0007*  image_record_size: equ image_bufferId+3
04344D             0008*  
04344D 00 00 00    0009*  cur_image_list: dl 0
043450 00 00 00    0010*  cur_file_idx: dl 0
043453 00 00 00    0011*  cur_filename: dl 0
043456 00 00 00    0012*  cur_buffer_id: dl 0
043459             0013*  
043459             0014*  load_ui_images:
043459             0015*  ; initialize image loading variables
043459 21 00 00 00 0016*  	ld hl,0
04345D 22 50 34 04 0017*  	ld (cur_file_idx),hl
043461 21 13 44 04 0018*  	ld hl,ui_image_list
043465 22 4D 34 04 0019*  	ld (cur_image_list),hl
043469             0020*  ; load images
043469 06 02       0021*  	ld b,ui_num_images
04346B             0022*  @loop:
04346B C5          0023*  	push bc
04346C CD A6 34 04 0024*  	call load_next_image
043470 C1          0025*  	pop bc
043471 10 F8       0026*  	djnz @loop
043473 C9          0027*  	ret
043474             0028*  
043474             0029*  load_sprite_images:
043474             0030*  ; initialize image loading variables
043474 21 00 00 00 0031*  	ld hl,0
043478 22 50 34 04 0032*  	ld (cur_file_idx),hl
04347C 21 37 35 04 0033*  	ld hl,sprites_image_list
043480 22 4D 34 04 0034*  	ld (cur_image_list),hl
043484 01 59 00 00 0035*  	ld bc,sprites_num_images
043488             0036*  ; load images
043488 CD 8D 34 04 0037*  	call img_load_main
04348C C9          0038*  	ret
04348D             0039*  
04348D             0040*  ; inputs: bc is the number of images to load, cur_image_list set
04348D             0041*  img_load_main:
04348D AF          0042*  	xor a
04348E 32 50 34 04 0043*      ld (cur_file_idx),a
043492             0044*  
043492             0045*  img_load_main_loop:
043492             0046*  ; back up loop counter
043492 C5          0047*      push bc
043493             0048*  
043493             0049*  ; load the next image
043493 CD A6 34 04 0050*      call load_next_image
043497             0051*  
043497             0052*  ; ; plot the background
043497             0053*  ; 	call vdu_cls
043497             0054*  ;     ld hl,BUF_SPLASH_BG
043497             0055*  ;     call vdu_buff_select
043497             0056*  ;     ld bc,0
043497             0057*  ;     ld de,0
043497             0058*  ;     call vdu_plot_bmp
043497             0059*  
043497             0060*  ; ; ; draw the most recently loaded image
043497             0061*  ; ; 	ld hl,(cur_buffer_id)
043497             0062*  ; ; 	call vdu_buff_select
043497             0063*  ; ; 	ld bc,0
043497             0064*  ; ; 	ld de,0
043497             0065*  ; ; 	call vdu_plot_bmp
043497             0066*  
043497             0067*  ; ; move logo
043497             0068*  ; 	call move_logo
043497             0069*  
043497             0070*  ; ; print current filename
043497             0071*  ; 	ld hl,(cur_filename)
043497             0072*  ; 	call printString
043497             0073*  
043497             0074*  ; ; flip the framebuffer
043497             0075*  ; 	call vdu_flip
043497             0076*  
043497             0077*  ; decrement loop counter
043497 C1          0078*      pop bc
043498 0B          0079*  	dec bc
043499 79          0080*      ld a,c
04349A B7          0081*      or a
04349B C2 92 34 04 0082*      jp nz,img_load_main_loop
04349F 78          0083*      ld a,b
0434A0 B7          0084*      or a
0434A1 C2 92 34 04 0085*      jp nz,img_load_main_loop
0434A5 C9          0086*      ret
0434A6             0087*  
0434A6             0088*  load_next_image:
0434A6 16 12       0089*      ld d,image_record_size
0434A8 3A 50 34 04 0090*  	ld a,(cur_file_idx)
0434AC 5F          0091*  	ld e,a
0434AD ED 5C       0092*      mlt de
0434AF FD 2A 4D 34 0093*      ld iy,(cur_image_list)
       04          
0434B4 FD 19       0094*      add iy,de
0434B6             0095*  
0434B6 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0434B9 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0434BC FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0434BF FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0434C2 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
0434C5 22 56 34 04 0101*  	ld (cur_buffer_id),hl
0434C9 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0434CC FD 22 53 34 0103*  	ld (cur_filename),iy
       04          
0434D1 CD 40 1F 04 0104*      call vdu_load_img
0434D5 FD 21 50 34 0105*      ld iy,cur_file_idx
       04          
0434DA FD 34 00    0106*  	inc (iy)
0434DD C9          0107*  	ret
0434DE             0108*  
0434DE             0109*  img_load_init:
0434DE             0110*  ; initialize logo's position parameters
0434DE 21 00 00 00 0111*  	ld hl,0
0434E2 22 2B 35 04 0112*  	ld (logo_xvel),hl
0434E6 22 2E 35 04 0113*  	ld (logo_xpos),hl
0434EA             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0434EA 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
0434EE 22 34 35 04 0116*  	ld (logo_ypos),hl
0434F2 EB          0117*  	ex de,hl
0434F3 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
0434F7 19          0119*  	add hl,de ; distance for logo to travel
0434F8 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
0434FC CD 3D 2E 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
043500 ED 53 31 35 0122*  	ld (logo_yvel),de
       04          
043505             0123*  ; all done
043505 C9          0124*      ret
043506             0125*  
043506             0126*  move_logo:
043506             0127*  ; activate logo bitmap
043506 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
04350A CD 22 1E 04 0129*  	call vdu_buff_select
04350E             0130*  ; update position based on velocity parameters
04350E 2A 34 35 04 0131*  	ld hl,(logo_ypos)
043512 ED 5B 31 35 0132*  	ld de,(logo_yvel)
       04          
043517 19          0133*  	add hl,de
043518 22 34 35 04 0134*  	ld (logo_ypos),hl
04351C             0135*  ; draw logo
04351C ED 4B 2E 35 0136*  	ld bc,(logo_xpos)
       04          
043521 ED 5B 34 35 0137*  	ld de,(logo_ypos)
       04          
043526 CD 07 21 04 0138*  	call vdu_plot_bmp168
04352A C9          0139*  	ret
04352B             0140*  
04352B 00 00 00    0141*  logo_xvel: dl 0
04352E 00 00 00    0142*  logo_xpos: dl 0
043531             0143*  
043531 00 00 00    0144*  logo_yvel: dl 0
043534 00 00 00    0145*  logo_ypos: dl 0
043537             0070   	include "images_sprites.inc"
043537             0001*  ; Generated by make_images.py
043537             0002*  
043537             0003*  sprites_num_images: equ 89
043537             0004*  
043537             0005*  ; buffer_ids:
043537             0006*  BUF_0TILE_EMPTY: equ 256
043537             0007*  BUF_1TILE_CROSS: equ 257
043537             0008*  BUF_2TILE_HORIZ: equ 258
043537             0009*  BUF_3TILE_VERT: equ 259
043537             0010*  BUF_4TILE_SQUARE: equ 260
043537             0011*  BUF_5TILE_CIRCLE: equ 261
043537             0012*  BUF_6TILE_PAD: equ 262
043537             0013*  BUF_7TILE_TURRET: equ 263
043537             0014*  BUF_CIRCLE: equ 264
043537             0015*  BUF_CRATER: equ 265
043537             0016*  BUF_EXPLOSION_A: equ 266
043537             0017*  BUF_EXPLOSION_B: equ 267
043537             0018*  BUF_EXPLOSION_C: equ 268
043537             0019*  BUF_EXPLOSION_D: equ 269
043537             0020*  BUF_EXPLOSION_E: equ 270
043537             0021*  BUF_FIREBALL_A: equ 271
043537             0022*  BUF_FIREBALL_B: equ 272
043537             0023*  BUF_LASER_A: equ 273
043537             0024*  BUF_LASER_B: equ 274
043537             0025*  BUF_PAD: equ 275
043537             0026*  BUF_SEEKER_000: equ 276
043537             0027*  BUF_SEEKER_008: equ 277
043537             0028*  BUF_SEEKER_016: equ 278
043537             0029*  BUF_SEEKER_024: equ 279
043537             0030*  BUF_SEEKER_032: equ 280
043537             0031*  BUF_SEEKER_040: equ 281
043537             0032*  BUF_SEEKER_048: equ 282
043537             0033*  BUF_SEEKER_056: equ 283
043537             0034*  BUF_SEEKER_064: equ 284
043537             0035*  BUF_SEEKER_072: equ 285
043537             0036*  BUF_SEEKER_080: equ 286
043537             0037*  BUF_SEEKER_088: equ 287
043537             0038*  BUF_SEEKER_096: equ 288
043537             0039*  BUF_SEEKER_104: equ 289
043537             0040*  BUF_SEEKER_112: equ 290
043537             0041*  BUF_SEEKER_120: equ 291
043537             0042*  BUF_SEEKER_128: equ 292
043537             0043*  BUF_SEEKER_136: equ 293
043537             0044*  BUF_SEEKER_144: equ 294
043537             0045*  BUF_SEEKER_152: equ 295
043537             0046*  BUF_SEEKER_160: equ 296
043537             0047*  BUF_SEEKER_168: equ 297
043537             0048*  BUF_SEEKER_176: equ 298
043537             0049*  BUF_SEEKER_184: equ 299
043537             0050*  BUF_SEEKER_192: equ 300
043537             0051*  BUF_SEEKER_200: equ 301
043537             0052*  BUF_SEEKER_208: equ 302
043537             0053*  BUF_SEEKER_216: equ 303
043537             0054*  BUF_SEEKER_224: equ 304
043537             0055*  BUF_SEEKER_232: equ 305
043537             0056*  BUF_SEEKER_240: equ 306
043537             0057*  BUF_SEEKER_248: equ 307
043537             0058*  BUF_SHIP_0L: equ 308
043537             0059*  BUF_SHIP_1C: equ 309
043537             0060*  BUF_SHIP_2R: equ 310
043537             0061*  BUF_SHIP_SMALL: equ 311
043537             0062*  BUF_STAR: equ 312
043537             0063*  BUF_TURRET_000: equ 313
043537             0064*  BUF_TURRET_008: equ 314
043537             0065*  BUF_TURRET_016: equ 315
043537             0066*  BUF_TURRET_024: equ 316
043537             0067*  BUF_TURRET_032: equ 317
043537             0068*  BUF_TURRET_040: equ 318
043537             0069*  BUF_TURRET_048: equ 319
043537             0070*  BUF_TURRET_056: equ 320
043537             0071*  BUF_TURRET_064: equ 321
043537             0072*  BUF_TURRET_072: equ 322
043537             0073*  BUF_TURRET_080: equ 323
043537             0074*  BUF_TURRET_088: equ 324
043537             0075*  BUF_TURRET_096: equ 325
043537             0076*  BUF_TURRET_104: equ 326
043537             0077*  BUF_TURRET_112: equ 327
043537             0078*  BUF_TURRET_120: equ 328
043537             0079*  BUF_TURRET_128: equ 329
043537             0080*  BUF_TURRET_136: equ 330
043537             0081*  BUF_TURRET_144: equ 331
043537             0082*  BUF_TURRET_152: equ 332
043537             0083*  BUF_TURRET_160: equ 333
043537             0084*  BUF_TURRET_168: equ 334
043537             0085*  BUF_TURRET_176: equ 335
043537             0086*  BUF_TURRET_184: equ 336
043537             0087*  BUF_TURRET_192: equ 337
043537             0088*  BUF_TURRET_200: equ 338
043537             0089*  BUF_TURRET_208: equ 339
043537             0090*  BUF_TURRET_216: equ 340
043537             0091*  BUF_TURRET_224: equ 341
043537             0092*  BUF_TURRET_232: equ 342
043537             0093*  BUF_TURRET_240: equ 343
043537             0094*  BUF_TURRET_248: equ 344
043537             0095*  
043537             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
043537 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       79 3B 04 00 
       01 00       
043549 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       93 3B 04 01 
       01 00       
04355B 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       AD 3B 04 02 
       01 00       
04356D 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       C7 3B 04 03 
       01 00       
04357F 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       E0 3B 04 04 
       01 00       
043591 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       FB 3B 04 05 
       01 00       
0435A3 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       16 3C 04 06 
       01 00       
0435B5 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       2E 3C 04 07 
       01 00       
0435C7 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       49 3C 04 08 
       01 00       
0435D9 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       5E 3C 04 09 
       01 00       
0435EB 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       73 3C 04 0A 
       01 00       
0435FD 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       8D 3C 04 0B 
       01 00       
04360F 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       A7 3C 04 0C 
       01 00       
043621 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       C1 3C 04 0D 
       01 00       
043633 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       DB 3C 04 0E 
       01 00       
043645 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       F5 3C 04 0F 
       01 00       
043657 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       0E 3D 04 10 
       01 00       
043669 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       27 3D 04 11 
       01 00       
04367B 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       3D 3D 04 12 
       01 00       
04368D 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       53 3D 04 13 
       01 00       
04369F 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       65 3D 04 14 
       01 00       
0436B1 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       7E 3D 04 15 
       01 00       
0436C3 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       97 3D 04 16 
       01 00       
0436D5 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       B0 3D 04 17 
       01 00       
0436E7 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       C9 3D 04 18 
       01 00       
0436F9 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       E2 3D 04 19 
       01 00       
04370B 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       FB 3D 04 1A 
       01 00       
04371D 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       14 3E 04 1B 
       01 00       
04372F 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       2D 3E 04 1C 
       01 00       
043741 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       46 3E 04 1D 
       01 00       
043753 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       5F 3E 04 1E 
       01 00       
043765 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       78 3E 04 1F 
       01 00       
043777 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       91 3E 04 20 
       01 00       
043789 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       AA 3E 04 21 
       01 00       
04379B 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       C3 3E 04 22 
       01 00       
0437AD 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       DC 3E 04 23 
       01 00       
0437BF 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       F5 3E 04 24 
       01 00       
0437D1 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       0E 3F 04 25 
       01 00       
0437E3 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       27 3F 04 26 
       01 00       
0437F5 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       40 3F 04 27 
       01 00       
043807 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       59 3F 04 28 
       01 00       
043819 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       72 3F 04 29 
       01 00       
04382B 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       8B 3F 04 2A 
       01 00       
04383D 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       A4 3F 04 2B 
       01 00       
04384F 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       BD 3F 04 2C 
       01 00       
043861 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       D6 3F 04 2D 
       01 00       
043873 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       EF 3F 04 2E 
       01 00       
043885 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       08 40 04 2F 
       01 00       
043897 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       21 40 04 30 
       01 00       
0438A9 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       3A 40 04 31 
       01 00       
0438BB 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       53 40 04 32 
       01 00       
0438CD 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       6C 40 04 33 
       01 00       
0438DF 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       85 40 04 34 
       01 00       
0438F1 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       9B 40 04 35 
       01 00       
043903 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       B1 40 04 36 
       01 00       
043915 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       C7 40 04 37 
       01 00       
043927 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       E0 40 04 38 
       01 00       
043939 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       F3 40 04 39 
       01 00       
04394B 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       0C 41 04 3A 
       01 00       
04395D 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       25 41 04 3B 
       01 00       
04396F 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       3E 41 04 3C 
       01 00       
043981 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       57 41 04 3D 
       01 00       
043993 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       70 41 04 3E 
       01 00       
0439A5 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       89 41 04 3F 
       01 00       
0439B7 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       A2 41 04 40 
       01 00       
0439C9 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       BB 41 04 41 
       01 00       
0439DB 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       D4 41 04 42 
       01 00       
0439ED 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       ED 41 04 43 
       01 00       
0439FF 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       06 42 04 44 
       01 00       
043A11 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       1F 42 04 45 
       01 00       
043A23 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       38 42 04 46 
       01 00       
043A35 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       51 42 04 47 
       01 00       
043A47 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       6A 42 04 48 
       01 00       
043A59 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       83 42 04 49 
       01 00       
043A6B 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       9C 42 04 4A 
       01 00       
043A7D 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       B5 42 04 4B 
       01 00       
043A8F 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       CE 42 04 4C 
       01 00       
043AA1 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       E7 42 04 4D 
       01 00       
043AB3 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       00 43 04 4E 
       01 00       
043AC5 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       19 43 04 4F 
       01 00       
043AD7 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       32 43 04 50 
       01 00       
043AE9 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       4B 43 04 51 
       01 00       
043AFB 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       64 43 04 52 
       01 00       
043B0D 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       7D 43 04 53 
       01 00       
043B1F 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       96 43 04 54 
       01 00       
043B31 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       AF 43 04 55 
       01 00       
043B43 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       C8 43 04 56 
       01 00       
043B55 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       E1 43 04 57 
       01 00       
043B67 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       FA 43 04 58 
       01 00       
043B79             0186*  
043B79             0187*  ; files_list: ; filename:
043B79 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043B93 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043BAD 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043BC7 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043BE0 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043BFB 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043C16 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043C2E 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043C49 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043C5E 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043C73 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043C8D 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043CA7 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043CC1 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043CDB 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043CF5 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043D0E 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043D27 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043D3D 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043D53 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043D65 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043D7E 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043D97 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043DB0 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043DC9 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043DE2 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043DFB 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043E14 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043E2D 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043E46 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043E5F 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043E78 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043E91 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043EAA 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043EC3 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043EDC 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043EF5 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043F0E 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043F27 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043F40 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043F59 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043F72 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043F8B 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043FA4 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043FBD 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043FD6 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
043FEF 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044008 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044021 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04403A 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044053 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04406C 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044085 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
04409B 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0440B1 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
0440C7 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
0440E0 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
0440F3 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
04410C 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
044125 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
04413E 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
044157 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
044170 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
044189 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
0441A2 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
0441BB 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
0441D4 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0441ED 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
044206 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
04421F 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
044238 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044251 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
04426A 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044283 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04429C 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0442B5 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0442CE 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0442E7 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
044300 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
044319 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044332 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
04434B 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
044364 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04437D 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044396 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0443AF 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
0443C8 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0443E1 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0443FA 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044413             0071   	include "images_ui.inc"
044413             0001*  ; Generated by make_images.py
044413             0002*  
044413             0003*  ui_num_images: equ 2
044413             0004*  
044413             0005*  ; buffer_ids:
044413             0006*  BUF_SPLASH_BG: equ 0
044413             0007*  BUF_SPLASH_LOGO: equ 1
044413             0008*  
044413             0009*  ui_image_list: ; type; width; height; filename; bufferId:
044413 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       37 44 04 00 
       00 00       
044425 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       4A 44 04 01 
       00 00       
044437             0012*  
044437             0013*  ; files_list: ; filename:
044437 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04444A 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
04445F             0072   	include "files.inc"
04445F             0001*  ; load to onboard 8k sram
04445F             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04445F             0073   
04445F 57 65 6C 63 0074   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
04447A 4C 6F 61 64 0075   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044485 4C 6F 61 64 0076   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
044493 50 72 65 73 0077   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0444AE             0078   
0444AE             0079   init:
0444AE             0080   ; clear all buffers
0444AE CD 14 1F 04 0081       call vdu_clear_all_buffers
0444B2             0082   
0444B2             0083   ; set up the display
0444B2 3E 88       0084       ld a,8+128 ; 136   320   240   64    60hz double-buffered
0444B4 CD FE 1D 04 0085       call vdu_set_screen_mode
0444B8 AF          0086       xor a
0444B9 CD 0F 1E 04 0087       call vdu_set_scaling
0444BD             0088   
0444BD             0089   ; ; enable additional audio channels
0444BD             0090   ; 	call vdu_enable_channels
0444BD             0091   
0444BD             0092   ; set text background color
0444BD 3E 84       0093   	ld a,4 + 128
0444BF CD 66 1D 04 0094   	call vdu_colour_text
0444C3             0095   
0444C3             0096   ; set text foreground color
0444C3 3E 2F       0097   	ld a,47 ; aaaaff lavenderish
0444C5 CD 66 1D 04 0098   	call vdu_colour_text
0444C9             0099   
0444C9             0100   ; set gfx bg color
0444C9 AF          0101   	xor a ; plotting mode 0
0444CA 0E 84       0102   	ld c,4+128 ; dark blue bg
0444CC CD 77 1D 04 0103   	call vdu_gcol
0444D0 CD 48 1D 04 0104   	call vdu_clg
0444D4             0105   
0444D4             0106   ; set the cursor off
0444D4 CD FD 1C 04 0107   	call vdu_cursor_off
0444D8             0108   
0444D8             0109   ; VDU 28, left, bottom, right, top: Set text viewport **
0444D8             0110   ; MIND THE LITTLE-ENDIANESS
0444D8             0111   ; inputs: c=left,b=bottom,e=right,d=top
0444D8 0E 00       0112   	ld c,0 ; left
0444DA 16 1D       0113   	ld d,29 ; top
0444DC 1E 27       0114   	ld e,39 ; right
0444DE 06 1D       0115   	ld b,29; bottom
0444E0 CD 8E 1D 04 0116   	call vdu_set_txt_viewport
0444E4             0117   
0444E4             0118   ; print loading ui message
0444E4 21 7A 44 04 0119   	ld hl,loading_ui
0444E8 CD D3 16 04 0120   	call printString
0444EC CD 3A 1D 04 0121   	call vdu_flip
0444F0             0122   
0444F0             0123   ; load UI images
0444F0 CD 59 34 04 0124   	call load_ui_images
0444F4             0125   
0444F4             0126   ; ; load fonts ; TODO
0444F4             0127   ; 	call load_font_rc
0444F4             0128   
0444F4             0129   ; load sprites
0444F4 CD DE 34 04 0130   	call img_load_init ; sets up the animated load screen
0444F8 CD 74 34 04 0131   	call load_sprite_images
0444FC             0132   
0444FC             0133   ; ; load sound effects ; TODO
0444FC             0134   ; 	ld bc,SFX_num_buffers
0444FC             0135   ; 	ld hl,SFX_buffer_id_lut
0444FC             0136   ; 	ld (cur_buffer_id_lut),hl
0444FC             0137   ; 	ld hl,SFX_load_routines_table
0444FC             0138   ; 	ld (cur_load_jump_table),hl
0444FC             0139   ; 	call sfx_load_main
0444FC             0140   
0444FC             0141   ; print loading complete message and wait for user keypress
0444FC CD 35 1D 04 0142   	call vdu_cls
044500 21 93 44 04 0143   	ld hl,loading_complete
044504 CD D3 16 04 0144   	call printString
044508 CD 3A 1D 04 0145   	call vdu_flip
04450C CD 71 1C 04 0146   	call waitKeypress
044510             0147   
044510             0148   ; set up display for gameplay
044510             0149       ; ld a,8
044510 3E 14       0150   	ld a,20
044512 CD FE 1D 04 0151       call vdu_set_screen_mode
044516 AF          0152       xor a
044517 CD 0F 1E 04 0153       call vdu_set_scaling
04451B 01 20 00 00 0154   	ld bc,32
04451F 11 10 00 00 0155   	ld de,16
044523 CD BA 1D 04 0156   	call vdu_set_gfx_origin
044527 CD FD 1C 04 0157   	call vdu_cursor_off
04452B             0158   ; set gfx viewport to scrolling window
04452B 01 00 00 00 0159   	ld bc,0
04452F 11 00 00 00 0160   	ld de,0
044533 DD 21 FF 00 0161   	ld ix,255
       00          
044538 FD 21 DF 00 0162   	ld iy,239-16
       00          
04453D CD D5 1D 04 0163   	call vdu_set_gfx_viewport
044541             0164   
044541 C9          0165   	ret
044542             0166   
044542             0167   new_game:
044542             0168   ; initialize sprites
044542 CD 7B 16 04 0169   	call sprites_init
044546             0170   
044546             0171   ; initialize the first level
044546 AF          0172   	xor a
044547 32 8E 2F 04 0173   	ld (cur_level),a
04454B CD 16 30 04 0174   	call init_level
04454F             0175   
04454F             0176   ; initialize player
04454F CD B4 2E 04 0177   	call player_init
044553             0178   
044553             0179   ; spawn an enemy sprite
044553 06 01       0180   	ld b,table_max_records
044555             0181   @spawn_enemy_loop:
044555 C5          0182   	push bc
044556 CD 6D 31 04 0183   	call enemy_init_from_landing_pad
04455A C1          0184   	pop bc
04455B 10 F8       0185   	djnz @spawn_enemy_loop
04455D             0186   
04455D C9          0187   	ret
04455E             0188   
04455E             0189   ; ; ###### INITIALIZE GAME #######
04455E             0190   ; ; clear the screen
04455E             0191   ;     ld a,3
04455E             0192   ;     out (81h),a
04455E             0193   
04455E             0194   ; ; reset the sprite table
04455E             0195   ;     xor a
04455E             0196   ;     ld (table_active_sprites),a
04455E             0197   ;     ld hl,table_limit
04455E             0198   ;     ld (table_base),hl
04455E             0199   ;     ld (table_pointer),hl
04455E             0200   
04455E             0201   ; ; draw a starfield over the entire screen
04455E             0202   ;     ld b,#50 ; first row of visible screen
04455E             0203   ; new_game_draw_stars_loop:
04455E             0204   ;     push bc
04455E             0205   ;     call draw_stars
04455E             0206   ;     pop bc
04455E             0207   ;     ld a,#10
04455E             0208   ;     add a,b
04455E             0209   ;     ld b,a
04455E             0210   ;     jr nz,new_game_draw_stars_loop
04455E             0211   
04455E             0212   ; ; ; print a welcome message
04455E             0213   ; ;     ld de,msg_welcome
04455E             0214   ; ;     ld hl,#581C
04455E             0215   ; ;     ld c,218 ; a bright pastel purple d677e3
04455E             0216   ; ;     call print_string
04455E             0217   
04455E             0218   ; ; push all that to frame buffer
04455E             0219   ;     ld a,#01 ; send video to frame buffer
04455E             0220   ;     out (81h),a
04455E             0221   
04455E             0222   ; ; reset score, lives, shields
04455E             0223   ;     xor a
04455E             0224   ;     ld hl,player_score
04455E             0225   ;     ld (hl),a ; player_score 0
04455E             0226   ;     inc hl
04455E             0227   ;     ld (hl),a ; player_score 1
04455E             0228   ;     inc hl
04455E             0229   ;     ld (hl),a ; player_score 3
04455E             0230   ;     inc hl
04455E             0231   ;     ld a,16
04455E             0232   ;     ld (hl),a ; player_shields
04455E             0233   ;     inc hl
04455E             0234   ;     ld (hl),a ; player_max_shields
04455E             0235   ;     inc hl
04455E             0236   ;     ld a,3
04455E             0237   ;     ld (hl),a ; player_ships
04455E             0238   ;     inc hl
04455E             0239   
04455E             0240   ; ; initialize first level
04455E             0241   ;     ld a,1 ; levels are zero-based, so this will wrap around
04455E             0242   ;     ld (cur_level),a
04455E             0243   ;     ld a,3 ; set max enemy sprites to easy street
04455E             0244   ;     ld (max_enemy_sprites),a
04455E             0245   ;     call dt_next_level
04455E             0246   ;     call dt
04455E             0247   
04455E             0248   ; ; spawn our intrepid hero
04455E             0249   ;     call player_init
04455E             0250   
04455E             0251   ; ; #### BEGIN GAME VARIABLES ####
04455E             0252   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
04455E             0253   speed_player: equ 0x000300 ; 3 pixels per frame
04455E             0254   
04455E             0255   main:
04455E             0256   ; start a new game
04455E CD 42 45 04 0257   	call new_game
044562             0258   
044562             0259   main_loop:
044562             0260   ; move the background down one pixel
044562 3E 02       0261   	ld a,2 ; current gfx viewport
044564 2E 02       0262   	ld l,2 ; direction=down
044566 26 01       0263   	ld h,1 ; speed=1 px
044568 CD 4D 1D 04 0264   	call vdu_scroll_down
04456C             0265   
04456C             0266   ; scroll tiles
04456C CD 9B 2F 04 0267   	call tiles_plot
044570             0268   
044570             0269   ; get player input and update sprite position
044570 CD F3 2E 04 0270   	call player_input
044574             0271   
044574             0272   ; move enemies
044574 CD 75 30 04 0273   	call move_enemies
044578             0274   
044578             0275   ; wait for the next vblank mitigate flicker and for loop timing
044578 CD A9 1D 04 0276   	call vdu_vblank
04457C             0277   
04457C             0278   ; poll keyboard
04457C 3E 08       0279       ld a, $08                           ; code to send to MOS
04457E 5B CF       0280       rst.lil $08                         ; get IX pointer to System Variables
044580             0281   
044580 DD 7E 05    0282       ld a, (ix + $05)                    ; get ASCII code of key pressed
044583 FE 1B       0283       cp 27                               ; check if 27 (ascii code for ESC)
044585 CA 8D 45 04 0284       jp z, main_end                     ; if pressed, jump to exit
044589             0285   
044589 C3 62 45 04 0286       jp main_loop
04458D             0287   
04458D             0288   main_end:
04458D CD EF 1C 04 0289       call vdu_cursor_on
044591 C9          0290   	ret
044592             0291   
044592             0292   
044592             0293   ; ; #### BEGIN GAME MAIN LOOP ####
044592             0294   ; main_loop:
044592             0295   ; ; ; debug: start execution counter
044592             0296   ; ;     ld a,1
044592             0297   ; ;     out (#e0),a ; start counting instructions
044592             0298   
044592             0299   ; ; refresh background from frame buffer
044592             0300   ;     ld a,#02
044592             0301   ;     out (81h),a
044592             0302   ;     call move_background ; now move it
044592             0303   ;     ld a,#01
044592             0304   ;     out (81h),a ; save it back to buffer
044592             0305   ; ; do all the things
044592             0306   ;     call move_enemies
044592             0307   ;     call player_move
044592             0308   ;     call laser_control
044592             0309   ;     call print_score
044592             0310   ;     call draw_shields
044592             0311   ;     call draw_lives
044592             0312   ; ; ; debug: stop execution counter and print results
044592             0313   ; ;     ld a,0
044592             0314   ; ;     out (#e0),a ; stop counting instructions
044592             0315   
044592             0316   ; ; ; debug: start execution counter
044592             0317   ; ;     ld a,1
044592             0318   ; ;     out (#e0),a ; start counting instructions
044592             0319   
044592             0320   ;     call vdu_vblank
044592             0321   ; ; ; debug: stop execution counter and print results
044592             0322   ; ;     ld a,0
044592             0323   ; ;     out (#e0),a ; stop counting instructions
044592             0324   
044592             0325   ;     jr main_loop
044592             0326   ; #### END GAME MAIN LOOP ####
044592             0327   
044592             0328   ; draws the player's shields level
044592             0329   ; draw_shields:
044592             0330   ; TODO: Agonize this routine
044592             0331   ; ; prep the loop to draw the bars
044592             0332   ;     ld a,(player_shields) ; snag shields
044592             0333   ;     and a
044592             0334   ;     ret z ; don't draw if zero shields
044592             0335   ; ; set loop counter and drawing position
044592             0336   ;     ld b,a ; loop counter
044592             0337   ;     ld hl,#5300+48+12
044592             0338   ; ; set color based on bars remaining
044592             0339   ;     ld c,103 ; bright green 28fe0a
044592             0340   ;     cp 9
044592             0341   ;     jp p,draw_shields_loop
044592             0342   ;     ld c,74 ; bright yellow eafe5b
044592             0343   ;     cp 3
044592             0344   ;     jp p,draw_shields_loop
044592             0345   ;     ld c,28 ; bright red fe0a0a
044592             0346   ; draw_shields_loop:
044592             0347   ;     push bc ; yup,outta
044592             0348   ;     push hl ; registers again
044592             0349   ;     ; ld a,#A8 ; ▀,168
044592             0350   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
044592             0351   ;     ; call draw_char
044592             0352   ;     call draw_num ; we nuked draw_char for the time being
044592             0353   ;     pop hl
044592             0354   ;     ld a,8
044592             0355   ;     add a,l
044592             0356   ;     ld l,a
044592             0357   ;     pop bc
044592             0358   ;     djnz draw_shields_loop
044592             0359       ; ret
044592             0360   
044592             0361   ; prints the player's score
044592             0362   ; print_score:
044592             0363   ; TODO: Agonize this
044592             0364   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
044592             0365   ;     ld c,42 ; dark orange b74400
044592             0366   ;     ld hl,#5200+1+8+6*6
044592             0367   ;     ld a,3 ; print 6 bdc digits
044592             0368   ;     ld de,player_score
044592             0369   ;     call print_num
044592             0370   
044592             0371   ;     ld c,58 ; golden yellow fec10a
044592             0372   ;     ld hl,#5100+8+6*6
044592             0373   ;     ld a,3 ; print 6 bdc digits
044592             0374   ;     ld de,player_score
044592             0375   ;     call print_num
044592             0376       ; ret
044592             0377   
044592             0378   ; draw_lives:
044592             0379   ;     ld hl,player_small ; make small yellow ship the active sprite
044592             0380   ;     ld (sprite_base_bufferId),hl
044592             0381   ;     ; ld a,#80 ; northern orientation
044592             0382   ;     ; ld (sprite_orientation),a
044592             0383   ;     ld hl,0 ; north
044592             0384   ;     ld (sprite_heading),hl
044592             0385   ;     xor a
044592             0386   ;     ld (sprite_animation),a
044592             0387   ;     ld a,#56 ; top of visible screen
044592             0388   ;     ld (sprite_y+1),a
044592             0389   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
044592             0390   ;     ld a,(player_ships)
044592             0391   ;     dec a ; we draw one fewer ships than lives
044592             0392   ;     ret z ; nothing to draw here, move along
044592             0393   ;     ld b,a ; loop counter
044592             0394   ;     ld a,256-16 ; initial x position
044592             0395   ; draw_lives_loop:
044592             0396   ;     ld (sprite_x+1),a
044592             0397   ;     push af
044592             0398   ;     push bc
044592             0399   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
044592             0400   ;     pop bc
044592             0401   ;     pop af
044592             0402   ;     sub 10
044592             0403   ;     djnz draw_lives_loop
044592             0404   ;     ret
