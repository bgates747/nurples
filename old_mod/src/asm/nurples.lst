PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD BC 48 04 0030   	call	init			; Initialization code
040050 CD 9E 49 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041842             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041842             0033*  
041842             0034*  ; pointer to top address of current record, initialized to table_base
041842 E2 15 04    0035*  table_pointer: dl table_base
041845             0036*  ; how many active sprites
041845 00          0037*  table_active_sprites: db 0x00
041846             0038*  ; flag indicating collision with screen edge
041846             0039*  ; uses orientation codes to specify which edge(s)
041846 00          0040*  sprite_screen_edge: db #00
041847             0041*  ; next sprite id to use
041847 00          0042*  sprite_next_id: db 0
041848             0043*  
041848             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
041848             0045*  ; integer coordinates are all that are needed for collision calculations
041848 00          0046*  collision_x: db 0x00
041849 00          0047*  collision_y: db 0x00
04184A 00          0048*  collision_dim_x: db 0x00
04184B 00          0049*  collision_dim_y: db 0x00
04184C             0050*  
04184C             0051*  ; scratch variables
04184C 00          0052*  x: db 0x00 ; 8-bit signed integer
04184D 00          0053*  y: db 0x00 ; 8-bit signed integer
04184E 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041851 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
041854 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
041857 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
04185A 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
04185D 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041860             0060*  
041860             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041860 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041863 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
041866 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
041869             0065*  
041869             0066*  ; gets the next available sprite id
041869             0067*  ; inputs; none
041869             0068*  ; returns: if new sprite available, a = sprite id,
041869             0069*  ;           ix pointing to new sprite vars, carry set
041869             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
041869             0071*  ; destroys: a,b,hl,ix
041869             0072*  ; affects: bumps table_active_sprites by one
041869             0073*  table_get_next_id:
041869 DD 21 E2 15 0074*      ld ix,table_base
       04          
04186E 11 26 00 00 0075*      ld de,table_bytes_per_record
041872 06 10       0076*      ld b,table_max_records
041874             0077*  @loop:
041874 DD 7E 01    0078*      ld a,(ix+sprite_type)
041877 A7          0079*      and a
041878 28 06       0080*      jr z,@found
04187A DD 19       0081*      add ix,de
04187C 10 F6       0082*      djnz @loop
04187E             0083*  @notfound:
04187E AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
04187F C9          0085*      ret
041880             0086*  @found:
041880             0087*  ; bump number of active sprites
041880 21 45 18 04 0088*      ld hl,table_active_sprites
041884 34          0089*      inc (hl)
041885             0090*  ; return sprite id
041885 3E 10       0091*      ld a,table_max_records
041887 90          0092*      sub b
041888 32 47 18 04 0093*      ld (sprite_next_id),a
04188C 37          0094*      scf ; sets carry flag indicating we found a free sprite
04188D C9          0095*      ret ; done
04188E             0096*  
04188E             0097*  ; deactivate the sprite with the given id
04188E             0098*  ; inputs: a = sprite id
04188E             0099*  ; outputs: nothing
04188E             0100*  ; destroys: a,ix,de
04188E             0101*  ; affects: decrements table_active_sprites by one
04188E             0102*  table_deactivate_sprite:
04188E F5          0103*      push af ; save sprite id bc we need it later
04188F CD C6 23 04 0104*      call vdu_sprite_select
041893 CD 4A 24 04 0105*      call vdu_sprite_hide
041897 F1          0106*      pop af ; restore sprite id
041898 11 00 00 00 0107*      ld de,0 ; clear deu
04189C 57          0108*      ld d,a
04189D 1E 26       0109*      ld e,table_bytes_per_record
04189F ED 5C       0110*      mlt de
0418A1 DD 21 E2 15 0111*      ld ix,table_base
       04          
0418A6 DD 19       0112*      add ix,de
0418A8 AF          0113*      xor a
0418A9 DD 77 01    0114*      ld (ix+sprite_type),a
0418AC DD 21 45 18 0115*      ld ix,table_active_sprites
       04          
0418B1 DD 35 00    0116*      dec (ix)
0418B4 C9          0117*      ret
0418B5             0118*  
0418B5             0119*  sprites_init:
0418B5             0120*  ; initialize sprites
0418B5 CD F2 24 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0418B9 AF          0122*  	xor a
0418BA             0123*  @sprite_loop:
0418BA F5          0124*  	push af
0418BB CD C6 23 04 0125*  	call vdu_sprite_select
0418BF 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0418C3 CD 13 25 04 0127*  	call vdu_sprite_add_buff
0418C7 F1          0128*  	pop af
0418C8 3C          0129*  	inc a
0418C9 FE 12       0130*  	cp table_max_records+2 ; tack on sprites for player and laser
0418CB 20 ED       0131*  	jr nz,@sprite_loop
0418CD 3C          0132*  	inc a
0418CE CD FA 23 04 0133*  	call vdu_sprite_activate
0418D2             0134*  
0418D2             0135*  ; define player sprite
0418D2 3A C8 30 04 0136*  	ld a,(player_id)
0418D6 CD C6 23 04 0137*  	call vdu_sprite_select
0418DA CD D9 23 04 0138*  	call vdu_sprite_clear_frames
0418DE 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0418E2 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0418E6             0141*  @sprite_player_loop:
0418E6 C5          0142*  	push bc
0418E7 E5          0143*  	push hl
0418E8 CD 13 25 04 0144*  	call vdu_sprite_add_buff
0418EC E1          0145*  	pop hl
0418ED 23          0146*  	inc hl
0418EE C1          0147*  	pop bc
0418EF 10 F5       0148*  	djnz @sprite_player_loop
0418F1 CD 3C 24 04 0149*  	call vdu_sprite_show
0418F5             0150*  
0418F5             0151*  ; all done
0418F5 C9          0152*      ret
0418F6             0050   ; API includes
0418F6             0051       include "mos_api.inc"
0418F6             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0418F6             0002*  ; Title:	AGON MOS - API for user projects
0418F6             0003*  ; Author:	Dean Belfield
0418F6             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0418F6             0005*  ;			Added MOS error codes for return in HL
0418F6             0006*  ; Created:	03/08/2022
0418F6             0007*  ; Last Updated:	10/08/2023
0418F6             0008*  ;
0418F6             0009*  ; Modinfo:
0418F6             0010*  ; 05/08/2022:	Added mos_feof
0418F6             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0418F6             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0418F6             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0418F6             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0418F6             0015*  ; 13/10/2022:	Added mos_oscli
0418F6             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0418F6             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0418F6             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0418F6             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0418F6             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0418F6             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0418F6             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0418F6             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0418F6             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0418F6             0025*  ; 19/05/2023:	Added sysvar_scrMode
0418F6             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0418F6             0027*  ; 03/08/2023:	Added mos_setkbvector
0418F6             0028*  ; 10/08/2023:	Added mos_getkbmap
0418F6             0029*  
0418F6             0030*  ; VDP control (VDU 23, 0, n)
0418F6             0031*  ;
0418F6             0032*  vdp_gp:				EQU 80h
0418F6             0033*  vdp_keycode:		EQU 81h
0418F6             0034*  vdp_cursor:			EQU	82h
0418F6             0035*  vdp_scrchar:		EQU	83h
0418F6             0036*  vdp_scrpixel:		EQU	84h
0418F6             0037*  vdp_audio:			EQU	85h
0418F6             0038*  vdp_mode:			EQU	86h
0418F6             0039*  vdp_rtc:			EQU	87h
0418F6             0040*  vdp_keystate:		EQU	88h
0418F6             0041*  vdp_logicalcoords:	EQU	C0h
0418F6             0042*  vdp_terminalmode:	EQU	FFh
0418F6             0043*  
0418F6             0044*  ; MOS high level functions
0418F6             0045*  ;
0418F6             0046*  mos_getkey:			EQU	00h
0418F6             0047*  mos_load:			EQU	01h
0418F6             0048*  mos_save:			EQU	02h
0418F6             0049*  mos_cd:				EQU	03h
0418F6             0050*  mos_dir:			EQU	04h
0418F6             0051*  mos_del:			EQU	05h
0418F6             0052*  mos_ren:			EQU	06h
0418F6             0053*  mos_mkdir:			EQU	07h
0418F6             0054*  mos_sysvars:		EQU	08h
0418F6             0055*  mos_editline:		EQU	09h
0418F6             0056*  mos_fopen:			EQU	0Ah
0418F6             0057*  mos_fclose:			EQU	0Bh
0418F6             0058*  mos_fgetc:			EQU	0Ch
0418F6             0059*  mos_fputc:			EQU	0Dh
0418F6             0060*  mos_feof:			EQU	0Eh
0418F6             0061*  mos_getError:		EQU	0Fh
0418F6             0062*  mos_oscli:			EQU	10h
0418F6             0063*  mos_copy:			EQU	11h
0418F6             0064*  mos_getrtc:			EQU	12h
0418F6             0065*  mos_setrtc:			EQU	13h
0418F6             0066*  mos_setintvector:	EQU	14h
0418F6             0067*  mos_uopen:			EQU	15h
0418F6             0068*  mos_uclose:			EQU	16h
0418F6             0069*  mos_ugetc:			EQU	17h
0418F6             0070*  mos_uputc:			EQU	18h
0418F6             0071*  mos_getfil:			EQU	19h
0418F6             0072*  mos_fread:			EQU	1Ah
0418F6             0073*  mos_fwrite:			EQU	1Bh
0418F6             0074*  mos_flseek:			EQU	1Ch
0418F6             0075*  mos_setkbvector:	EQU	1Dh
0418F6             0076*  mos_getkbmap:		EQU	1Eh
0418F6             0077*  
0418F6             0078*  ; MOS program exit codes
0418F6             0079*  ;
0418F6             0080*  EXIT_OK:				EQU  0;	"OK",
0418F6             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0418F6             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0418F6             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0418F6             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0418F6             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0418F6             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0418F6             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0418F6             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0418F6             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0418F6             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0418F6             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0418F6             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0418F6             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0418F6             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0418F6             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0418F6             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0418F6             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0418F6             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0418F6             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0418F6             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0418F6             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0418F6             0102*  ; FatFS file access functions
0418F6             0103*  ;
0418F6             0104*  ffs_fopen:			EQU	80h
0418F6             0105*  ffs_fclose:			EQU	81h
0418F6             0106*  ffs_fread:			EQU	82h
0418F6             0107*  ffs_fwrite:			EQU	83h
0418F6             0108*  ffs_flseek:			EQU	84h
0418F6             0109*  ffs_ftruncate:		EQU	85h
0418F6             0110*  ffs_fsync:			EQU	86h
0418F6             0111*  ffs_fforward:		EQU	87h
0418F6             0112*  ffs_fexpand:		EQU	88h
0418F6             0113*  ffs_fgets:			EQU	89h
0418F6             0114*  ffs_fputc:			EQU	8Ah
0418F6             0115*  ffs_fputs:			EQU	8Bh
0418F6             0116*  ffs_fprintf:		EQU	8Ch
0418F6             0117*  ffs_ftell:			EQU	8Dh
0418F6             0118*  ffs_feof:			EQU	8Eh
0418F6             0119*  ffs_fsize:			EQU	8Fh
0418F6             0120*  ffs_ferror:			EQU	90h
0418F6             0121*  
0418F6             0122*  ; FatFS directory access functions
0418F6             0123*  ;
0418F6             0124*  ffs_dopen:			EQU	91h
0418F6             0125*  ffs_dclose:			EQU	92h
0418F6             0126*  ffs_dread:			EQU	93h
0418F6             0127*  ffs_dfindfirst:		EQU	94h
0418F6             0128*  ffs_dfindnext:		EQU	95h
0418F6             0129*  
0418F6             0130*  ; FatFS file and directory management functions
0418F6             0131*  ;
0418F6             0132*  ffs_stat:			EQU	96h
0418F6             0133*  ffs_unlink:			EQU	97h
0418F6             0134*  ffs_rename:			EQU	98h
0418F6             0135*  ffs_chmod:			EQU	99h
0418F6             0136*  ffs_utime:			EQU	9Ah
0418F6             0137*  ffs_mkdir:			EQU	9Bh
0418F6             0138*  ffs_chdir:			EQU	9Ch
0418F6             0139*  ffs_chdrive:		EQU	9Dh
0418F6             0140*  ffs_getcwd:			EQU	9Eh
0418F6             0141*  
0418F6             0142*  ; FatFS volume management and system configuration functions
0418F6             0143*  ;
0418F6             0144*  ffs_mount:			EQU	9Fh
0418F6             0145*  ffs_mkfs:			EQU	A0h
0418F6             0146*  ffs_fdisk:			EQU	A1h
0418F6             0147*  ffs_getfree:		EQU	A2h
0418F6             0148*  ffs_getlabel:		EQU	A3h
0418F6             0149*  ffs_setlabel:		EQU	A4h
0418F6             0150*  ffs_setcp:			EQU	A5h
0418F6             0151*  
0418F6             0152*  ; File access modes
0418F6             0153*  ;
0418F6             0154*  fa_read:			EQU	01h
0418F6             0155*  fa_write:			EQU	02h
0418F6             0156*  fa_open_existing:	EQU	00h
0418F6             0157*  fa_create_new:		EQU	04h
0418F6             0158*  fa_create_always:	EQU	08h
0418F6             0159*  fa_open_always:		EQU	10h
0418F6             0160*  fa_open_append:		EQU	30h
0418F6             0161*  
0418F6             0162*  ; System variable indexes for api_sysvars
0418F6             0163*  ; Index into _sysvars in globals.inc
0418F6             0164*  ;
0418F6             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0418F6             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0418F6             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0418F6             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0418F6             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0418F6             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0418F6             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0418F6             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0418F6             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0418F6             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0418F6             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0418F6             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0418F6             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0418F6             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0418F6             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0418F6             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0418F6             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0418F6             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0418F6             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0418F6             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0418F6             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0418F6             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0418F6             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0418F6             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0418F6             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0418F6             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0418F6             0191*  
0418F6             0192*  ; Flags for the VPD protocol
0418F6             0193*  ;
0418F6             0194*  vdp_pflag_cursor:		EQU	00000001b
0418F6             0195*  vdp_pflag_scrchar:		EQU	00000010b
0418F6             0196*  vdp_pflag_point:		EQU	00000100b
0418F6             0197*  vdp_pflag_audio:		EQU	00001000b
0418F6             0198*  vdp_pflag_mode:			EQU	00010000b
0418F6             0199*  vdp_pflag_rtc:			EQU	00100000b
0418F6             0200*  
0418F6             0201*  ;
0418F6             0202*  ; FatFS structures
0418F6             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0418F6             0204*  ;
0418F6             0205*  ; Object ID and allocation information (FFOBJID)
0418F6             0206*  ;
0418F6             0207*  ; Indexes into FFOBJID structure
0418F6             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0418F6             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0418F6             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0418F6             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0418F6             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0418F6             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0418F6             0214*  ;
0418F6             0215*  ; File object structure (FIL)
0418F6             0216*  ;
0418F6             0217*  ; Indexes into FIL structure
0418F6             0218*  fil_obj:		EQU 0	; 15: Object identifier
0418F6             0219*  fil_flag:		EQU	15 	;  1: File status flags
0418F6             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0418F6             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0418F6             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0418F6             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0418F6             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0418F6             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0418F6             0226*  ;
0418F6             0227*  ; Directory object structure (DIR)
0418F6             0228*  ; Indexes into DIR structure
0418F6             0229*  dir_obj:		EQU  0	; 15: Object identifier
0418F6             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0418F6             0231*  dir_clust:		EQU	19	;  4: Current cluster
0418F6             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0418F6             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0418F6             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0418F6             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0418F6             0236*  ;
0418F6             0237*  ; File information structure (FILINFO)
0418F6             0238*  ;
0418F6             0239*  ; Indexes into FILINFO structure
0418F6             0240*  filinfo_fsize:		EQU 0	;   4: File size
0418F6             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0418F6             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0418F6             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0418F6             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0418F6             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0418F6             0246*  ;
0418F6             0247*  ; Macro for calling the API
0418F6             0248*  ; Parameters:
0418F6             0249*  ; - function: One of the function numbers listed above
0418F6             0250*  ;
0418F6             0251*  	MACRO	MOSCALL	function
0418F6             0252*  			LD	A, function
0418F6             0253*  			RST.LIL	08h
0418F6             0254*  	ENDMACRO
0418F6             0052       include "functions.inc"
0418F6             0001*  
0418F6             0002*      MACRO printChar char
0418F6             0003*          LD A, char
0418F6             0004*          RST.LIL 10h
0418F6             0005*      ENDMACRO
0418F6             0006*  
0418F6             0007*  ; Simulated call to subroutine at HL
0418F6             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0418F6             0009*  ; outputs: whatever the subroutine does, including HL and BC
0418F6             0010*  ; destroys: only what the subroutine does, but always BC
0418F6             0011*      MACRO callHL
0418F6             0012*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0013*          push bc       ; which constitutes the return address
0418F6             0014*          jp   (hl)     ; Jump to the address in HL
0418F6             0015*      ENDMACRO
0418F6             0016*  
0418F6             0017*  ; Simulated call to subroutine at IX
0418F6             0018*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0418F6             0019*  ; outputs: whatever the subroutine does, including IX and BC
0418F6             0020*  ; destroys: only what the subroutine does, but always BC
0418F6             0021*      MACRO callIX
0418F6             0022*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0023*          push bc       ; which constitutes the return address
0418F6             0024*          jp   (ix)     ; Jump to the address in IX
0418F6             0025*      ENDMACRO
0418F6             0026*  
0418F6             0027*  ; Simulated call to soubroutinte at IY
0418F6             0028*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0418F6             0029*  ; outputs: whatever the subroutine does, including IY and BC
0418F6             0030*  ; destroys: only what the subroutine does, but always BC
0418F6             0031*      MACRO callIY
0418F6             0032*          ld bc,$+7     ; Address of first instruction after the jump
0418F6             0033*          push bc       ; which constitutes the return address
0418F6             0034*          jp   (iy)     ; Jump to the address in IY
0418F6             0035*      ENDMACRO
0418F6             0036*  
0418F6             0037*  ; put the value in HLU into the accumulator
0418F6             0038*  ; destroys: af
0418F6             0039*      MACRO HLU_TO_A
0418F6             0040*          push hl ; 4 cycles
0418F6             0041*          inc sp ; 1 cycle
0418F6             0042*          pop af  ; 4 cycles
0418F6             0043*          dec sp ; 1 cycle
0418F6             0044*                 ; 10 cycles total
0418F6             0045*      ENDMACRO
0418F6             0046*  
0418F6             0047*  A_TO_HLU:
0418F6             0048*      ; call is 7 cycles
0418F6 22 03 19 04 0049*      ld (@scratch),hl ; 7 cycles
0418FA 32 05 19 04 0050*      ld (@scratch+2),a ; 5 cycles
0418FE 2A 03 19 04 0051*      ld hl,(@scratch) ; 7 cycles
041902 C9          0052*      ret ; 6 cycles
041903             0053*          ; 25 cycles total
041903 00 00 00    0054*  @scratch: dl 0
041906             0055*  
041906             0056*      ; TODO: implement this
041906             0057*      ; MACRO A_TO_HLU
041906             0058*      ;     push.s af
041906             0059*      ;     inc sp
041906             0060*      ;     push.s hl
041906             0061*      ;     pop hl
041906             0062*      ;     inc sp
041906             0063*      ;     inc sp
041906             0064*      ; ENDMACRO
041906             0065*  
041906             0066*      MACRO PUSH_ALL
041906             0067*          ex af,af'
041906             0068*          exx
041906             0069*          push af
041906             0070*          push hl
041906             0071*          push bc
041906             0072*          push de
041906             0073*  
041906             0074*          ex af,af'
041906             0075*          exx
041906             0076*          push af
041906             0077*          push hl
041906             0078*          push bc
041906             0079*          push de
041906             0080*          push ix
041906             0081*          push iy
041906             0082*      ENDMACRO
041906             0083*  
041906             0084*      MACRO POP_ALL
041906             0085*          pop iy
041906             0086*          pop ix
041906             0087*          pop de
041906             0088*          pop bc
041906             0089*          pop hl
041906             0090*          pop af
041906             0091*          ex af,af'
041906             0092*          exx
041906             0093*  
041906             0094*          pop de
041906             0095*          pop bc
041906             0096*          pop hl
041906             0097*          pop af
041906             0098*          ex af,af'
041906             0099*          exx
041906             0100*      ENDMACRO
041906             0101*  
041906             0102*  ; Print a zero-terminated string inline with code, e.g.:
041906             0103*  ;
041906             0104*  ;    call printInline
041906             0105*  ;    ASCIZ "Hello, world!\r\n"
041906             0106*  ;
041906             0107*  ; Destroys: HL,AF
041906             0108*  printInline:
041906 E1          0109*      pop hl ; get the return address = pointer to start of string
041907 CD 0D 19 04 0110*      call printString ; HL advances to end of string
04190B E5          0111*      push hl ; restore the return address = pointer to end of string
04190C C9          0112*      ret
04190D             0113*  
04190D             0114*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04190D             0115*  ; Print a zero-terminated string
04190D             0116*  ; HL: Pointer to string
04190D             0117*  printString:
04190D C5          0118*  	PUSH	BC
04190E 01 00 00 00 0119*  	LD		BC,0
041912 3E 00       0120*  	LD 	 	A,0
041914 5B DF       0121*  	RST.LIL 18h
041916 C1          0122*  	POP		BC
041917 C9          0123*  	RET
041918             0124*  ; print a VDU sequence
041918             0125*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
041918             0126*  sendVDUsequence:
041918 C5          0127*  	PUSH	BC
041919 01 00 00 00 0128*  	LD		BC, 0
04191D 4E          0129*  	LD		C, (HL)
04191E 5B DF       0130*  	RST.LIL	18h
041920 C1          0131*  	POP		BC
041921 C9          0132*  	RET
041922             0133*  ; Print Newline sequence to VDP
041922             0134*  printNewLine:
041922 F5          0135*      push af ; for some reason rst.lil 10h sets carry flag
041923 3E 0D       0136*  	LD	A, '\r'
041925 5B D7       0137*  	RST.LIL 10h
041927 3E 0A       0138*  	LD	A, '\n'
041929 5B D7       0139*  	RST.LIL 10h
04192B F1          0140*      pop af
04192C C9          0141*  	RET
04192D             0142*  
04192D             0143*  ; Print a 24-bit HEX number
04192D             0144*  ; HLU: Number to print
04192D             0145*  printHex24:
04192D             0146*      HLU_TO_A
04192D E5          0001*M         push hl ; 4 cycles
04192E 33          0002*M         inc sp ; 1 cycle
04192F F1          0003*M         pop af  ; 4 cycles
041930 3B          0004*M         dec sp ; 1 cycle
041931             0005*M                ; 10 cycles total
041931 CD 3B 19 04 0147*  	CALL	printHex8
041935             0148*  ; Print a 16-bit HEX number
041935             0149*  ; HL: Number to print
041935             0150*  printHex16:
041935 7C          0151*  	LD		A,H
041936 CD 3B 19 04 0152*  	CALL	printHex8
04193A 7D          0153*  	LD		A,L
04193B             0154*  ; Print an 8-bit HEX number
04193B             0155*  ; A: Number to print
04193B             0156*  printHex8:
04193B 4F          0157*  	LD		C,A
04193C 1F          0158*  	RRA
04193D 1F          0159*  	RRA
04193E 1F          0160*  	RRA
04193F 1F          0161*  	RRA
041940 CD 45 19 04 0162*  	CALL	@F
041944 79          0163*  	LD		A,C
041945             0164*  @@:
041945 E6 0F       0165*  	AND		0Fh
041947 C6 90       0166*  	ADD		A,90h
041949 27          0167*  	DAA
04194A CE 40       0168*  	ADC		A,40h
04194C 27          0169*  	DAA
04194D 5B D7       0170*  	RST.LIL	10h
04194F C9          0171*  	RET
041950             0172*  
041950             0173*  printHexA:
041950 F5          0174*      push af
041951 C5          0175*      push bc
041952 CD 3B 19 04 0176*      call printHex8
041956 3E 20       0177*      ld a,' '
041958 5B D7       0178*      rst.lil 10h
04195A C1          0179*      pop bc
04195B F1          0180*      pop af
04195C C9          0181*      ret
04195D             0182*  
04195D             0183*  printHexHL:
04195D F5          0184*      push af
04195E C5          0185*      push bc
04195F CD 35 19 04 0186*      call printHex16
041963 3E 20       0187*      ld a,' '
041965 5B D7       0188*      rst.lil 10h
041967 C1          0189*      pop bc
041968 F1          0190*      pop af
041969 C9          0191*      ret
04196A             0192*  
04196A             0193*  printHexUHL:
04196A F5          0194*      push af
04196B C5          0195*      push bc
04196C CD 2D 19 04 0196*      call printHex24
041970 3E 20       0197*      ld a,' '
041972 5B D7       0198*      rst.lil 10h
041974 C1          0199*      pop bc
041975 F1          0200*      pop af
041976 C9          0201*      ret
041977             0202*  
041977             0203*  printHexAUHL:
041977 F5          0204*      push af
041978 C5          0205*      push bc
041979 CD 3B 19 04 0206*      call printHex8
04197D 3E 2E       0207*      ld a,'.'
04197F 5B D7       0208*      rst.lil 10h
041981 CD 2D 19 04 0209*      call printHex24
041985 3E 20       0210*      ld a,' '
041987 5B D7       0211*      rst.lil 10h
041989 C1          0212*      pop bc
04198A F1          0213*      pop af
04198B C9          0214*      ret
04198C             0215*  
04198C             0216*  printHexABHL:
04198C             0217*  ; preserve registers
04198C C5          0218*      push bc ; b will be ok c will not
04198D F5          0219*      push af ; will get totally destroyed
04198E             0220*  ; print a
04198E CD 3B 19 04 0221*      call printHex8
041992             0222*  ; print b
041992 78          0223*      ld a,b
041993 CD 3B 19 04 0224*      call printHex8
041997             0225*  ; print hl
041997 CD 35 19 04 0226*      call printHex16
04199B             0227*  ; restore registers
04199B F1          0228*      pop af
04199C C1          0229*      pop bc
04199D C9          0230*      ret
04199E             0231*  
04199E             0232*  printHexBHL:
04199E             0233*  ; preserve registers
04199E C5          0234*      push bc ; b will be ok c will not
04199F F5          0235*      push af ; will get totally destroyed
0419A0             0236*  ; print b
0419A0 78          0237*      ld a,b
0419A1 CD 3B 19 04 0238*      call printHex8
0419A5             0239*  ; print hl
0419A5 CD 35 19 04 0240*      call printHex16
0419A9             0241*  ; restore registers
0419A9 F1          0242*      pop af
0419AA C1          0243*      pop bc
0419AB C9          0244*      ret
0419AC             0245*  
0419AC             0246*  printHexCDE:
0419AC             0247*  ; preserve registers
0419AC C5          0248*      push bc ; b will be ok c will not
0419AD F5          0249*      push af ; will get totally destroyed
0419AE             0250*  ; print c
0419AE 79          0251*      ld a,c
0419AF CD 3B 19 04 0252*      call printHex8
0419B3             0253*  ; print de
0419B3 EB          0254*      ex de,hl
0419B4 CD 35 19 04 0255*      call printHex16
0419B8 EB          0256*      ex de,hl
0419B9             0257*  ; restore registers
0419B9 F1          0258*      pop af
0419BA C1          0259*      pop bc
0419BB C9          0260*      ret
0419BC             0261*  
0419BC             0262*  printHexUIX:
0419BC             0263*  ; store everything in scratch
0419BC 22 35 1E 04 0264*      ld (uhl),hl
0419C0 ED 43 38 1E 0265*      ld (ubc),bc
       04          
0419C5 ED 53 3B 1E 0266*      ld (ude),de
       04          
0419CA DD 22 3E 1E 0267*      ld (uix),ix
       04          
0419CF FD 22 41 1E 0268*      ld (uiy),iy
       04          
0419D4 F5          0269*      push af ; fml
0419D5             0270*  
0419D5 21 CC 1D 04 0271*      ld hl,str_ixu
0419D9 CD 0D 19 04 0272*      call printString
0419DD 2A 3E 1E 04 0273*      ld hl,(uix)
0419E1 CD 2D 19 04 0274*      call printHex24
0419E5 CD 22 19 04 0275*      call printNewLine
0419E9             0276*  
0419E9             0277*  ; restore everything
0419E9 2A 35 1E 04 0278*      ld hl, (uhl)
0419ED ED 4B 38 1E 0279*      ld bc, (ubc)
       04          
0419F2 ED 5B 3B 1E 0280*      ld de, (ude)
       04          
0419F7 DD 2A 3E 1E 0281*      ld ix, (uix)
       04          
0419FC FD 2A 41 1E 0282*      ld iy, (uiy)
       04          
041A01 F1          0283*      pop af
041A02             0284*  ; all done
041A02 C9          0285*      ret
041A03             0286*  
041A03             0287*  ; Print a 0x HEX prefix
041A03             0288*  DisplayHexPrefix:
041A03 3E 30       0289*  	LD	A, '0'
041A05 5B D7       0290*  	RST.LIL 10h
041A07 3E 78       0291*  	LD	A, 'x'
041A09 5B D7       0292*  	RST.LIL 10h
041A0B C9          0293*  	RET
041A0C             0294*  
041A0C             0295*      MACRO printDecBC
041A0C             0296*          push hl
041A0C             0297*          push bc
041A0C             0298*          pop hl
041A0C             0299*          call printDec
041A0C             0300*          pop hl
041A0C             0301*      ENDMACRO
041A0C             0302*  
041A0C             0303*      MACRO printDecDE
041A0C             0304*          push hl
041A0C             0305*          push de
041A0C             0306*          pop hl
041A0C             0307*          call printDec
041A0C             0308*          pop hl
041A0C             0309*      ENDMACRO
041A0C             0310*  
041A0C             0311*      MACRO printDecHL
041A0C             0312*          call printDec
041A0C             0313*      ENDMACRO
041A0C             0314*  
041A0C             0315*      MACRO printDecIX
041A0C             0316*          push hl
041A0C             0317*          push ix
041A0C             0318*          pop hl
041A0C             0319*          call printDec
041A0C             0320*          pop hl
041A0C             0321*      ENDMACRO
041A0C             0322*  
041A0C             0323*      MACRO printDecIY
041A0C             0324*          push hl
041A0C             0325*          push iy
041A0C             0326*          pop hl
041A0C             0327*          call printDec
041A0C             0328*          pop hl
041A0C             0329*      ENDMACRO
041A0C             0330*  
041A0C             0331*  
041A0C             0332*  ; Prints the right justified decimal value in HL without leading zeroes
041A0C             0333*  ; HL : Value to print
041A0C             0334*  ; preserves all registers and flags
041A0C             0335*  printDec:
041A0C             0336*  ; BEGIN MY CODE
041A0C             0337*  ; back up all the things
041A0C F5          0338*      push af
041A0D C5          0339*      push bc
041A0E D5          0340*      push de
041A0F E5          0341*      push hl
041A10             0342*  ; END MY CODE
041A10 11 38 1A 04 0343*  	LD	 DE, _printDecBuffer
041A14 CD 48 1A 04 0344*  	CALL u24_to_ascii
041A18             0345*  ; BEGIN MY CODE
041A18             0346*  ; replace leading zeroes with spaces
041A18 21 38 1A 04 0347*      LD	 HL, _printDecBuffer
041A1C 06 07       0348*      ld   B, 7 ; if HL was 0, we want to keep the final zero
041A1E             0349*  @loop:
041A1E 7E          0350*      LD	 A, (HL)
041A1F FE 30       0351*      CP	 '0'
041A21 C2 2B 1A 04 0352*      JP	 NZ, @done
041A25 3E 20       0353*      LD   A, ' '
041A27 77          0354*      LD	 (HL), A
041A28 23          0355*      INC	 HL
041A29             0356*      ; CALL vdu_cursor_forward
041A29 10 F3       0357*      DJNZ @loop
041A2B             0358*  @done:
041A2B             0359*  ; END MY CODE
041A2B 21 38 1A 04 0360*  	LD	 HL, _printDecBuffer
041A2F CD 0D 19 04 0361*  	CALL printString
041A33             0362*  ; BEGIN MY CODE
041A33             0363*  ; restore all the things
041A33 E1          0364*      pop hl
041A34 D1          0365*      pop de
041A35 C1          0366*      pop bc
041A36 F1          0367*      pop af
041A37             0368*  ; END MY CODE
041A37 C9          0369*  	RET
041A38 00 00 00 00 0370*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041A48             0371*  
041A48             0372*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
041A48             0373*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041A48             0374*  ; so it will allways be 8 characters length
041A48             0375*  ; HL : Value to convert to string
041A48             0376*  ; DE : pointer to buffer, at least 8 byte + 0
041A48             0377*  u24_to_ascii:
041A48 01 80 69 67 0378*  	LD	 BC,-10000000
041A4C CD 7F 1A 04 0379*  	CALL @one_digit
041A50 01 C0 BD F0 0380*  	LD	 BC,-1000000
041A54 CD 7F 1A 04 0381*  	CALL @one_digit
041A58 01 60 79 FE 0382*  	LD	 BC,-100000
041A5C CD 7F 1A 04 0383*  	CALL @one_digit
041A60 01 F0 D8 FF 0384*  	LD   BC,-10000
041A64 CD 7F 1A 04 0385*  	CALL @one_digit
041A68 01 18 FC FF 0386*  	LD   BC,-1000
041A6C CD 7F 1A 04 0387*  	CALL @one_digit
041A70 01 9C FF FF 0388*  	LD   BC,-100
041A74 CD 7F 1A 04 0389*  	CALL @one_digit
041A78 0E F6       0390*  	LD   C,-10
041A7A CD 7F 1A 04 0391*  	CALL @one_digit
041A7E 48          0392*  	LD   C,B
041A7F             0393*  @one_digit:
041A7F 3E 2F       0394*  	LD   A,'0'-1
041A81             0395*  @divide_me:
041A81 3C          0396*  	INC  A
041A82 09          0397*  	ADD  HL,BC
041A83 38 FC       0398*  	JR   C,@divide_me
041A85 ED 42       0399*  	SBC  HL,BC
041A87 12          0400*  	LD   (DE),A
041A88 13          0401*  	INC  DE
041A89 C9          0402*  	RET
041A8A             0403*  
041A8A             0404*  print_u24:
041A8A D5          0405*      push de
041A8B E5          0406*      push hl
041A8C 11 38 1A 04 0407*      ld de,_printDecBuffer
041A90 CD 48 1A 04 0408*      call u24_to_ascii
041A94 21 38 1A 04 0409*      ld hl,_printDecBuffer
041A98 CD 0D 19 04 0410*      call printString
041A9C 3E 20       0411*      ld a,' '
041A9E 5B D7       0412*      rst.lil 10h
041AA0 E1          0413*      pop hl
041AA1 D1          0414*      pop de
041AA2 C9          0415*      ret
041AA3             0416*  
041AA3             0417*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
041AA3             0418*  ; HL : Value to convert to string (integer part in H, fractional part in L)
041AA3             0419*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
041AA3             0420*  u168_to_ascii:
041AA3             0421*  ; add a leading space to make room for sign flag if needed
041AA3 3E 20       0422*      ld a,' '
041AA5 12          0423*      ld (de),a
041AA6 13          0424*      inc de
041AA7             0425*  ; Convert integer part
041AA7 E5          0426*      push hl               ; Save HL (we’ll need the fractional part later)
041AA8 CD 95 25 04 0427*      call hlu_udiv256    ; Shift to get integer portion in HL
041AAC 01 F0 D8 FF 0428*      ld   bc, -10000
041AB0 CD D3 1A 04 0429*      call @one_int
041AB4 01 18 FC FF 0430*      ld   bc, -1000
041AB8 CD D3 1A 04 0431*      call @one_int
041ABC 01 9C FF FF 0432*      ld   bc, -100
041AC0 CD D3 1A 04 0433*      call @one_int
041AC4 0E F6       0434*      ld   c, -10
041AC6 CD D3 1A 04 0435*      call @one_int
041ACA 48          0436*      ld   c, b
041ACB CD D3 1A 04 0437*      call @one_int
041ACF C3 DE 1A 04 0438*      jp   @frac            ; Jump to fractional part conversion
041AD3             0439*  @one_int:
041AD3 3E 2F       0440*      ld   a, '0' - 1       ; Start ASCII character at '0'
041AD5             0441*  @divide_me:
041AD5 3C          0442*      inc  a
041AD6 09          0443*      add  hl, bc           ; Accumulate until overflow
041AD7 38 FC       0444*      jr   c, @divide_me
041AD9 ED 42       0445*      sbc  hl, bc           ; Remove excess after overflow
041ADB 12          0446*      ld   (de), a          ; Store ASCII digit
041ADC 13          0447*      inc  de
041ADD C9          0448*      ret
041ADE             0449*  ; Convert fractional part
041ADE             0450*  @frac:
041ADE 3E 2E       0451*      ld   a, '.'           ; Decimal point
041AE0 12          0452*      ld   (de), a
041AE1 13          0453*      inc  de
041AE2 E1          0454*      pop  hl               ; Restore HL with original fraction
041AE3 06 03       0455*      ld   b, 3             ; Loop counter for 3 fractional digits
041AE5             0456*  @frac_loop:
041AE5 26 0A       0457*      ld   h, 10            ; Load multiplier for fractional part
041AE7 ED 6C       0458*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
041AE9 3E 30       0459*      ld   a, '0'
041AEB 84          0460*      add  a, h             ; Convert integer part to ASCII
041AEC 12          0461*      ld   (de), a
041AED 13          0462*      inc  de
041AEE 10 F5       0463*      djnz @frac_loop       ; Repeat for each fractional digit
041AF0             0464*  ; Add null terminator
041AF0 AF          0465*      xor  a                ; Null terminator
041AF1 12          0466*      ld   (de), a
041AF2 C9          0467*      ret
041AF3             0468*  
041AF3             0469*  print_u168:
041AF3 D5          0470*      push de
041AF4 E5          0471*      push hl
041AF5 11 38 1A 04 0472*      ld de,_printDecBuffer
041AF9 CD A3 1A 04 0473*      call u168_to_ascii
041AFD 21 38 1A 04 0474*      ld hl,_printDecBuffer
041B01 CD 0D 19 04 0475*      call printString
041B05 E1          0476*      pop hl
041B06 D1          0477*      pop de
041B07 C9          0478*      ret
041B08             0479*  
041B08             0480*  ; signed version of u168_to_ascii
041B08             0481*  s168_to_ascii:
041B08 D5          0482*      push de ; save starting address of buffer
041B09 CD 2E 25 04 0483*      call hlu_abs
041B0D F5          0484*      push af ; save sign flag
041B0E CD A3 1A 04 0485*      call u168_to_ascii
041B12 F1          0486*      pop af ; restore sign flag
041B13 D1          0487*      pop de ; restore starting address of buffer
041B14 F0          0488*      ret p ; hlu was positive so nothing to do
041B15 3E 2D       0489*      ld a,'-'
041B17 12          0490*      ld (de),a
041B18 C9          0491*      ret
041B19             0492*  
041B19             0493*  print_s168:
041B19 D5          0494*      push de
041B1A E5          0495*      push hl
041B1B 11 38 1A 04 0496*      ld de,_printDecBuffer
041B1F CD 08 1B 04 0497*      call s168_to_ascii
041B23 21 38 1A 04 0498*      ld hl,_printDecBuffer
041B27 CD 0D 19 04 0499*      call printString
041B2B E1          0500*      pop hl
041B2C D1          0501*      pop de
041B2D C9          0502*      ret
041B2E             0503*  
041B2E             0504*  print_s168_hl:
041B2E F5          0505*      push af
041B2F E5          0506*      push hl
041B30 CD 19 1B 04 0507*      call print_s168
041B34 3E 20       0508*      ld a,' '
041B36 5B D7       0509*      rst.lil 10h
041B38 E1          0510*      pop hl
041B39 F1          0511*      pop af
041B3A C9          0512*      ret
041B3B             0513*  
041B3B             0514*  print_s168_bc:
041B3B F5          0515*      push af
041B3C C5          0516*      push bc
041B3D E5          0517*      push hl
041B3E C5          0518*      push bc
041B3F E1          0519*      pop hl
041B40 CD 19 1B 04 0520*      call print_s168
041B44 3E 20       0521*      ld a,' '
041B46 5B D7       0522*      rst.lil 10h
041B48 E1          0523*      pop hl
041B49 C1          0524*      pop bc
041B4A F1          0525*      pop af
041B4B C9          0526*      ret
041B4C             0527*  
041B4C             0528*  print_s168_de:
041B4C F5          0529*      push af
041B4D D5          0530*      push de
041B4E E5          0531*      push hl
041B4F EB          0532*      ex de,hl
041B50 CD 19 1B 04 0533*      call print_s168
041B54 3E 20       0534*      ld a,' '
041B56 5B D7       0535*      rst.lil 10h
041B58 E1          0536*      pop hl
041B59 D1          0537*      pop de
041B5A F1          0538*      pop af
041B5B C9          0539*      ret
041B5C             0540*  
041B5C             0541*  print_s168_hl_bc_de:
041B5C F5          0542*      push af
041B5D C5          0543*      push bc
041B5E D5          0544*      push de
041B5F E5          0545*      push hl
041B60 CD 19 1B 04 0546*      call print_s168
041B64 3E 20       0547*      ld a,' '
041B66 5B D7       0548*      rst.lil 10h
041B68 C5          0549*      push bc
041B69 E1          0550*      pop hl
041B6A CD 19 1B 04 0551*      call print_s168
041B6E 3E 20       0552*      ld a,' '
041B70 5B D7       0553*      rst.lil 10h
041B72 EB          0554*      ex de,hl
041B73 CD 19 1B 04 0555*      call print_s168
041B77 3E 20       0556*      ld a,' '
041B79 5B D7       0557*      rst.lil 10h
041B7B E1          0558*      pop hl
041B7C D1          0559*      pop de
041B7D C1          0560*      pop bc
041B7E F1          0561*      pop af
041B7F C9          0562*      ret
041B80             0563*  
041B80             0564*  print_s168_bc_de:
041B80 F5          0565*      push af
041B81 C5          0566*      push bc
041B82 D5          0567*      push de
041B83 C5          0568*      push bc
041B84 E1          0569*      pop hl
041B85 CD 19 1B 04 0570*      call print_s168
041B89 3E 20       0571*      ld a,' '
041B8B 5B D7       0572*      rst.lil 10h
041B8D EB          0573*      ex de,hl
041B8E CD 19 1B 04 0574*      call print_s168
041B92 3E 20       0575*      ld a,' '
041B94 5B D7       0576*      rst.lil 10h
041B96 E1          0577*      pop hl
041B97 D1          0578*      pop de
041B98 C1          0579*      pop bc
041B99 F1          0580*      pop af
041B9A C9          0581*      ret
041B9B             0582*  
041B9B             0583*  print_s168_a:
041B9B F5          0584*      push af
041B9C C5          0585*      push bc
041B9D E5          0586*      push hl
041B9E 21 00 00 00 0587*      ld hl,0
041BA2 6F          0588*      ld l,a
041BA3 CD 2E 1B 04 0589*      call print_s168_hl
041BA7 E1          0590*      pop hl
041BA8 C1          0591*      pop bc
041BA9 F1          0592*      pop af
041BAA C9          0593*      ret
041BAB             0594*  
041BAB             0595*  ; #### new functions added by Brandon R. Gates ####
041BAB             0596*  
041BAB             0597*  ; print the binary representation of the 8-bit value in a
041BAB             0598*  ; destroys a, hl, bc
041BAB             0599*  printBin8:
041BAB 06 08       0600*      ld b,8      ; loop counter for 8 bits
041BAD 21 C8 1B 04 0601*      ld hl,@cmd  ; set hl to the low byte of the output string
041BB1             0602*                  ; (which will be the high bit of the value in a)
041BB1             0603*  @loop:
041BB1 07          0604*      rlca ; put the next highest bit into carry
041BB2 38 04       0605*      jr c,@one
041BB4 36 30       0606*      ld (hl),'0'
041BB6 18 02       0607*      jr @next_bit
041BB8             0608*  @one:
041BB8 36 31       0609*      ld (hl),'1'
041BBA             0610*  @next_bit:
041BBA 23          0611*      inc hl
041BBB 10 F4       0612*      djnz @loop
041BBD             0613*  ; print it
041BBD 21 C8 1B 04 0614*  	ld hl,@cmd
041BC1 01 08 00 00 0615*  	ld bc,@end-@cmd
041BC5 5B DF       0616*  	rst.lil $18
041BC7 C9          0617*  	ret
041BC8             0618*  @cmd: ds 8 ; eight bytes for eight bits
041BD0             0619*  @end:
041BD0             0620*  
041BD0             0621*  ; print the binary representation of the 8-bit value in a
041BD0             0622*  ; in reverse order (lsb first)
041BD0             0623*  ; destroys a, hl, bc
041BD0             0624*  printBin8Rev:
041BD0 06 08       0625*      ld b,8      ; loop counter for 8 bits
041BD2 21 ED 1B 04 0626*      ld hl,@cmd  ; set hl to the low byte of the output string
041BD6             0627*                  ; (which will be the high bit of the value in a)
041BD6             0628*  @loop:
041BD6 0F          0629*      rrca ; put the next lowest bit into carry
041BD7 38 04       0630*      jr c,@one
041BD9 36 30       0631*      ld (hl),'0'
041BDB 18 02       0632*      jr @next_bit
041BDD             0633*  @one:
041BDD 36 31       0634*      ld (hl),'1'
041BDF             0635*  @next_bit:
041BDF 23          0636*      inc hl
041BE0 10 F4       0637*      djnz @loop
041BE2             0638*  ; print it
041BE2 21 ED 1B 04 0639*  	ld hl,@cmd
041BE6 01 08 00 00 0640*  	ld bc,@end-@cmd
041BEA 5B DF       0641*  	rst.lil $18
041BEC C9          0642*  	ret
041BED             0643*  @cmd: ds 8 ; eight bytes for eight bits
041BF5             0644*  @end:
041BF5             0645*  
041BF5             0646*  ; print registers to screen in hexidecimal format
041BF5             0647*  ; inputs: none
041BF5             0648*  ; outputs: values of every register printed to screen
041BF5             0649*  ;    values of each register in global scratch memory
041BF5             0650*  ; destroys: nothing
041BF5             0651*  stepRegistersHex:
041BF5             0652*  ; store everything in scratch
041BF5 22 35 1E 04 0653*      ld (uhl),hl
041BF9 ED 43 38 1E 0654*      ld (ubc),bc
       04          
041BFE ED 53 3B 1E 0655*      ld (ude),de
       04          
041C03 DD 22 3E 1E 0656*      ld (uix),ix
       04          
041C08 FD 22 41 1E 0657*      ld (uiy),iy
       04          
041C0D F5          0658*      push af ; fml
041C0E E1          0659*      pop hl  ; thanks, zilog
041C0F 22 32 1E 04 0660*      ld (uaf),hl
041C13 F5          0661*      push af ; dammit
041C14             0662*  
041C14             0663*  ; home the cursor
041C14             0664*      ; call vdu_home_cursor
041C14             0665*  
041C14             0666*  ; print each register
041C14 21 B8 1D 04 0667*      ld hl,str_afu
041C18 CD 0D 19 04 0668*      call printString
041C1C 2A 32 1E 04 0669*      ld hl,(uaf)
041C20 CD 2D 19 04 0670*      call printHex24
041C24 CD 22 19 04 0671*      call printNewLine
041C28             0672*  
041C28 21 BD 1D 04 0673*      ld hl,str_hlu
041C2C CD 0D 19 04 0674*      call printString
041C30 2A 35 1E 04 0675*      ld hl,(uhl)
041C34 CD 2D 19 04 0676*      call printHex24
041C38 CD 22 19 04 0677*      call printNewLine
041C3C             0678*  
041C3C 21 C2 1D 04 0679*      ld hl,str_bcu
041C40 CD 0D 19 04 0680*      call printString
041C44 2A 38 1E 04 0681*      ld hl,(ubc)
041C48 CD 2D 19 04 0682*      call printHex24
041C4C CD 22 19 04 0683*      call printNewLine
041C50             0684*  
041C50 21 C7 1D 04 0685*      ld hl,str_deu
041C54 CD 0D 19 04 0686*      call printString
041C58 2A 3B 1E 04 0687*      ld hl,(ude)
041C5C CD 2D 19 04 0688*      call printHex24
041C60 CD 22 19 04 0689*      call printNewLine
041C64             0690*  
041C64 21 CC 1D 04 0691*      ld hl,str_ixu
041C68 CD 0D 19 04 0692*      call printString
041C6C 2A 3E 1E 04 0693*      ld hl,(uix)
041C70 CD 2D 19 04 0694*      call printHex24
041C74 CD 22 19 04 0695*      call printNewLine
041C78             0696*  
041C78 21 D1 1D 04 0697*      ld hl,str_iyu
041C7C CD 0D 19 04 0698*      call printString
041C80 2A 41 1E 04 0699*      ld hl,(uiy)
041C84 CD 2D 19 04 0700*      call printHex24
041C88 CD 22 19 04 0701*      call printNewLine
041C8C             0702*  
041C8C             0703*      ; call vsync
041C8C             0704*  
041C8C CD 22 19 04 0705*      call printNewLine
041C90             0706*  
041C90             0707*  ; check for right shift key and quit if pressed
041C90             0708*  	MOSCALL mos_getkbmap
041C90 3E 1E       0001*M 			LD	A, function
041C92 5B CF       0002*M 			RST.LIL	08h
041C94             0709*  @stayhere:
041C94             0710*  ; 7 RightShift
041C94 DD CB 00 76 0711*      bit 6,(ix+0)
041C98 20 02       0712*      jr nz,@RightShift
041C9A 18 F8       0713*      jr @stayhere
041C9C             0714*  @RightShift:
041C9C DD CB 0E 86 0715*      res 0,(ix+14) ; debounce the key (hopefully)
041CA0 3E 80       0716*      ld a,%10000000
041CA2             0717*      ; call multiPurposeDelay
041CA2             0718*  
041CA2             0719*  ; restore everything
041CA2 2A 35 1E 04 0720*      ld hl, (uhl)
041CA6 ED 4B 38 1E 0721*      ld bc, (ubc)
       04          
041CAB ED 5B 3B 1E 0722*      ld de, (ude)
       04          
041CB0 DD 2A 3E 1E 0723*      ld ix, (uix)
       04          
041CB5 FD 2A 41 1E 0724*      ld iy, (uiy)
       04          
041CBA F1          0725*      pop af
041CBB             0726*  ; all done
041CBB C9          0727*      ret
041CBC             0728*  
041CBC             0729*  ; print registers to screen in hexidecimal format
041CBC             0730*  ; inputs: none
041CBC             0731*  ; outputs: values of every register printed to screen
041CBC             0732*  ;    values of each register in global scratch memory
041CBC             0733*  ; destroys: nothing
041CBC             0734*  dumpRegistersHex:
041CBC             0735*  ; store everything in scratch
041CBC 22 35 1E 04 0736*      ld (uhl),hl
041CC0 ED 43 38 1E 0737*      ld (ubc),bc
       04          
041CC5 ED 53 3B 1E 0738*      ld (ude),de
       04          
041CCA DD 22 3E 1E 0739*      ld (uix),ix
       04          
041CCF FD 22 41 1E 0740*      ld (uiy),iy
       04          
041CD4 F5          0741*      push af ; fml
041CD5 E1          0742*      pop hl  ; thanks, zilog
041CD6 22 32 1E 04 0743*      ld (uaf),hl
041CDA F5          0744*      push af ; dammit
041CDB             0745*  
041CDB             0746*  ; home the cursor
041CDB             0747*      ; call vdu_home_cursor
041CDB             0748*      ; call printNewLine
041CDB             0749*  
041CDB             0750*  ; print each register
041CDB 21 B8 1D 04 0751*      ld hl,str_afu
041CDF CD 0D 19 04 0752*      call printString
041CE3 2A 32 1E 04 0753*      ld hl,(uaf)
041CE7 CD 2D 19 04 0754*      call printHex24
041CEB             0755*      ; call printNewLine
041CEB             0756*  
041CEB 21 BD 1D 04 0757*      ld hl,str_hlu
041CEF CD 0D 19 04 0758*      call printString
041CF3 2A 35 1E 04 0759*      ld hl,(uhl)
041CF7 CD 2D 19 04 0760*      call printHex24
041CFB             0761*      ; call printNewLine
041CFB             0762*  
041CFB 21 C2 1D 04 0763*      ld hl,str_bcu
041CFF CD 0D 19 04 0764*      call printString
041D03 2A 38 1E 04 0765*      ld hl,(ubc)
041D07 CD 2D 19 04 0766*      call printHex24
041D0B             0767*      ; call printNewLine
041D0B             0768*  
041D0B 21 C7 1D 04 0769*      ld hl,str_deu
041D0F CD 0D 19 04 0770*      call printString
041D13 2A 3B 1E 04 0771*      ld hl,(ude)
041D17 CD 2D 19 04 0772*      call printHex24
041D1B             0773*      ; call printNewLine
041D1B             0774*  
041D1B 21 CC 1D 04 0775*      ld hl,str_ixu
041D1F CD 0D 19 04 0776*      call printString
041D23 2A 3E 1E 04 0777*      ld hl,(uix)
041D27 CD 2D 19 04 0778*      call printHex24
041D2B             0779*      ; call printNewLine
041D2B             0780*  
041D2B 21 D1 1D 04 0781*      ld hl,str_iyu
041D2F CD 0D 19 04 0782*      call printString
041D33 2A 41 1E 04 0783*      ld hl,(uiy)
041D37 CD 2D 19 04 0784*      call printHex24
041D3B             0785*      ; call printNewLine
041D3B             0786*  
041D3B             0787*      ; call vdu_vblank
041D3B             0788*  
041D3B CD 22 19 04 0789*      call printNewLine
041D3F             0790*  ; restore everything
041D3F 2A 35 1E 04 0791*      ld hl, (uhl)
041D43 ED 4B 38 1E 0792*      ld bc, (ubc)
       04          
041D48 ED 5B 3B 1E 0793*      ld de, (ude)
       04          
041D4D DD 2A 3E 1E 0794*      ld ix, (uix)
       04          
041D52 FD 2A 41 1E 0795*      ld iy, (uiy)
       04          
041D57 F1          0796*      pop af
041D58             0797*  ; all done
041D58 C9          0798*      ret
041D59             0799*  
041D59             0800*  dumpRegistersHexPrime:
041D59 D9          0801*      exx
041D5A 08          0802*      ex af,af'
041D5B CD BC 1C 04 0803*      call dumpRegistersHex
041D5F 08          0804*      ex af,af'
041D60 D9          0805*      exx
041D61 C9          0806*      ret
041D62             0807*  
041D62             0808*  ; additionally dump prime registers
041D62             0809*  ; inputs: none
041D62             0810*  ; outputs: values of every register printed to screen
041D62             0811*  ; destroys: nothing
041D62             0812*  dumpRegistersHexAll:
041D62 CD BC 1C 04 0813*      call dumpRegistersHex
041D66 08          0814*      ex af,af'
041D67 D9          0815*      exx
041D68 CD BC 1C 04 0816*      call dumpRegistersHex
041D6C 08          0817*      ex af,af'
041D6D D9          0818*      exx
041D6E C9          0819*      ret
041D6F             0820*  
041D6F             0821*  ; print hlu to screen in hexidecimal format
041D6F             0822*  ; inputs: none
041D6F             0823*  ; destroys: nothing
041D6F             0824*  print_hex_hl:
041D6F F5          0825*      push af
041D70 E5          0826*      push hl
041D71 21 BD 1D 04 0827*      ld hl,str_hlu
041D75 CD 0D 19 04 0828*      call printString
041D79 E1          0829*      pop hl
041D7A E5          0830*      push hl
041D7B CD 2D 19 04 0831*      call printHex24
041D7F 3E 20       0832*      ld a,' '
041D81 5B D7       0833*      rst.lil 10h
041D83 E1          0834*      pop hl
041D84 F1          0835*      pop af
041D85 C9          0836*      ret
041D86             0837*  
041D86             0838*  ; print bcu to screen in hexidecimal format
041D86             0839*  ; inputs: none
041D86             0840*  ; destroys: nothing
041D86             0841*  print_hex_bc:
041D86 F5          0842*      push af
041D87 E5          0843*      push hl
041D88 C5          0844*      push bc
041D89 21 C2 1D 04 0845*      ld hl,str_bcu
041D8D CD 0D 19 04 0846*      call printString
041D91 E1          0847*      pop hl
041D92 E5          0848*      push hl
041D93 CD 2D 19 04 0849*      call printHex24
041D97 3E 20       0850*      ld a,' '
041D99 5B D7       0851*      rst.lil 10h
041D9B C1          0852*      pop bc
041D9C E1          0853*      pop hl
041D9D F1          0854*      pop af
041D9E C9          0855*      ret
041D9F             0856*  
041D9F             0857*  ; print deu to screen in hexidecimal format
041D9F             0858*  ; inputs: none
041D9F             0859*  ; destroys: nothing
041D9F             0860*  print_hex_de:
041D9F F5          0861*      push af
041DA0 E5          0862*      push hl
041DA1 D5          0863*      push de
041DA2 21 C7 1D 04 0864*      ld hl,str_deu
041DA6 CD 0D 19 04 0865*      call printString
041DAA E1          0866*      pop hl
041DAB E5          0867*      push hl
041DAC CD 2D 19 04 0868*      call printHex24
041DB0 3E 20       0869*      ld a,' '
041DB2 5B D7       0870*      rst.lil 10h
041DB4 D1          0871*      pop de
041DB5 E1          0872*      pop hl
041DB6 F1          0873*      pop af
041DB7 C9          0874*      ret
041DB8             0875*  
041DB8 20 61 66 3D 0876*  str_afu: db " af=",0
       00          
041DBD 20 68 6C 3D 0877*  str_hlu: db " hl=",0
       00          
041DC2 20 62 63 3D 0878*  str_bcu: db " bc=",0
       00          
041DC7 20 64 65 3D 0879*  str_deu: db " de=",0
       00          
041DCC 20 69 78 3D 0880*  str_ixu: db " ix=",0
       00          
041DD1 20 69 79 3D 0881*  str_iyu: db " iy=",0
       00          
041DD6             0882*  
041DD6             0883*  ; print udeuhl to screen in hexidecimal format
041DD6             0884*  ; inputs: none
041DD6             0885*  ; outputs: concatenated hexidecimal udeuhl
041DD6             0886*  ; destroys: nothing
041DD6             0887*  dumpUDEUHLHex:
041DD6             0888*  ; store everything in scratch
041DD6 22 35 1E 04 0889*      ld (uhl),hl
041DDA ED 43 38 1E 0890*      ld (ubc),bc
       04          
041DDF ED 53 3B 1E 0891*      ld (ude),de
       04          
041DE4 DD 22 3E 1E 0892*      ld (uix),ix
       04          
041DE9 FD 22 41 1E 0893*      ld (uiy),iy
       04          
041DEE F5          0894*      push af
041DEF             0895*  
041DEF             0896*  ; print each register
041DEF             0897*  
041DEF 21 29 1E 04 0898*      ld hl,str_udeuhl
041DF3 CD 0D 19 04 0899*      call printString
041DF7 2A 3B 1E 04 0900*      ld hl,(ude)
041DFB CD 2D 19 04 0901*      call printHex24
041DFF 3E 2E       0902*  	ld a,'.'	; print a dot to separate the values
041E01 5B D7       0903*  	rst.lil 10h
041E03 2A 35 1E 04 0904*      ld hl,(uhl)
041E07 CD 2D 19 04 0905*      call printHex24
041E0B CD 22 19 04 0906*      call printNewLine
041E0F             0907*  
041E0F             0908*  ; restore everything
041E0F 2A 35 1E 04 0909*      ld hl, (uhl)
041E13 ED 4B 38 1E 0910*      ld bc, (ubc)
       04          
041E18 ED 5B 3B 1E 0911*      ld de, (ude)
       04          
041E1D DD 2A 3E 1E 0912*      ld ix, (uix)
       04          
041E22 FD 2A 41 1E 0913*      ld iy, (uiy)
       04          
041E27 F1          0914*      pop af
041E28             0915*  ; all done
041E28 C9          0916*      ret
041E29             0917*  
041E29 75 64 65 2E 0918*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041E32             0919*  
041E32             0920*  ; global scratch memory for registers
041E32 00 00 00    0921*  uaf: dl 0
041E35 00 00 00    0922*  uhl: dl 0
041E38 00 00 00    0923*  ubc: dl 0
041E3B 00 00 00    0924*  ude: dl 0
041E3E 00 00 00    0925*  uix: dl 0
041E41 00 00 00    0926*  uiy: dl 0
041E44 00 00 00    0927*  usp: dl 0
041E47 00 00 00    0928*  upc: dl 0
041E4A             0929*  
041E4A             0930*  ; inputs: whatever is in the flags register
041E4A             0931*  ; outputs: binary representation of flags
041E4A             0932*  ;          with a header so we know which is what
041E4A             0933*  ; destroys: nothing
041E4A             0934*  ; preserves: everything
041E4A             0935*  dumpFlags:
041E4A             0936*  ; first we curse zilog for not giving direct access to flags
041E4A F5          0937*      push af ; this is so we can send it back unharmed
041E4B F5          0938*      push af ; this is so we can pop it to hl
041E4C             0939*  ; store everything in scratch
041E4C 22 35 1E 04 0940*      ld (uhl),hl
041E50 ED 43 38 1E 0941*      ld (ubc),bc
       04          
041E55 ED 53 3B 1E 0942*      ld (ude),de
       04          
041E5A DD 22 3E 1E 0943*      ld (uix),ix
       04          
041E5F FD 22 41 1E 0944*      ld (uiy),iy
       04          
041E64             0945*  ; next we print the header
041E64 21 90 1E 04 0946*      ld hl,@header
041E68 CD 0D 19 04 0947*      call printString
041E6C E1          0948*      pop hl ; flags are now in l
041E6D 7D          0949*      ld a,l ; flags are now in a
041E6E CD AB 1B 04 0950*      call printBin8
041E72 CD 22 19 04 0951*  	call printNewLine
041E76             0952*  ; restore everything
041E76 2A 35 1E 04 0953*      ld hl, (uhl)
041E7A ED 4B 38 1E 0954*      ld bc, (ubc)
       04          
041E7F ED 5B 3B 1E 0955*      ld de, (ude)
       04          
041E84 DD 2A 3E 1E 0956*      ld ix, (uix)
       04          
041E89 FD 2A 41 1E 0957*      ld iy, (uiy)
       04          
041E8E F1          0958*      pop af ; send her home the way she came
041E8F C9          0959*      ret
041E90             0960*  ; Bit 7 (S): Sign flag
041E90             0961*  ; Bit 6 (Z): Zero flag
041E90             0962*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041E90             0963*  ; Bit 4 (H): Half Carry flag
041E90             0964*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041E90             0965*  ; Bit 2 (PV): Parity/Overflow flag
041E90             0966*  ; Bit 1 (N): Subtract flag
041E90             0967*  ; Bit 0 (C): Carry flag
041E90 53 5A 78 48 0968*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041E9B             0969*  
041E9B             0970*  ; set all the bits in the flag register
041E9B             0971*  ; more of an academic exercise than anything useful
041E9B             0972*  ; inputs; none
041E9B             0973*  ; outputs; a=0,f=255
041E9B             0974*  ; destroys: flags, hl
041E9B             0975*  ; preserves: a, because why not
041E9B             0976*  setAllFlags:
041E9B 21 FF 00 00 0977*      ld hl,255
041E9F 67          0978*      ld h,a ; four cycles to preserve a is cheap
041EA0 E5          0979*      push hl
041EA1 F1          0980*      pop af
041EA2 C9          0981*      ret
041EA3             0982*  
041EA3             0983*  ; reset all the bits in the flag register
041EA3             0984*  ; unlike its inverse counterpart, this may actually be useful
041EA3             0985*  ; inputs; none
041EA3             0986*  ; outputs; a=0,f=0
041EA3             0987*  ; destroys: flags, hl
041EA3             0988*  ; preserves: a, because why not
041EA3             0989*  resetAllFlags:
041EA3 21 00 00 00 0990*      ld hl,0
041EA7 67          0991*      ld h,a ; four cycles to preserve a is cheap
041EA8 E5          0992*      push hl
041EA9 F1          0993*      pop af
041EAA C9          0994*      ret
041EAB             0995*  
041EAB             0996*  ; wait until user presses a key
041EAB             0997*  ; inputs: none
041EAB             0998*  ; outputs: ascii code of key pressed in a
041EAB             0999*  ; destroys: af,ix
041EAB             1000*  waitKeypress:
041EAB             1001*      MOSCALL mos_getkey
041EAB 3E 00       0001*M 			LD	A, function
041EAD 5B CF       0002*M 			RST.LIL	08h
041EAF C9          1002*      ret
041EB0             1003*  
041EB0             1004*  ; print bytes from an address to the screen in hexidecimal format
041EB0             1005*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EB0             1006*  ; outputs: values of each byte printed to screen separated by spaces
041EB0             1007*  ; destroys: nothing
041EB0             1008*  dumpMemoryHex:
041EB0             1009*  ; save registers to the stack
041EB0 C5          1010*      push bc
041EB1 E5          1011*      push hl
041EB2 F5          1012*      push af
041EB3             1013*  
041EB3             1014*  ; print the address and separator
041EB3 CD 2D 19 04 1015*      call printHex24
041EB7 3E 3A       1016*      ld a,':'
041EB9 5B D7       1017*      rst.lil 10h
041EBB 3E 20       1018*      ld a,' '
041EBD 5B D7       1019*      rst.lil 10h
041EBF             1020*  
041EBF             1021*  ; set b to be our loop counter
041EBF F1          1022*      pop af
041EC0 47          1023*      ld b,a
041EC1 E1          1024*      pop hl
041EC2 E5          1025*      push hl
041EC3 F5          1026*      push af
041EC4             1027*  @loop:
041EC4             1028*  ; print the byte
041EC4 7E          1029*      ld a,(hl)
041EC5 CD 3B 19 04 1030*      call printHex8
041EC9             1031*  ; print a space
041EC9 3E 20       1032*      ld a,' '
041ECB 5B D7       1033*      rst.lil 10h
041ECD 23          1034*      inc hl
041ECE 10 F4       1035*      djnz @loop
041ED0 CD 22 19 04 1036*      call printNewLine
041ED4             1037*  
041ED4             1038*  ; restore everything
041ED4 F1          1039*      pop af
041ED5 E1          1040*      pop hl
041ED6 C1          1041*      pop bc
041ED7             1042*  
041ED7             1043*  ; all done
041ED7 C9          1044*      ret
041ED8             1045*  
041ED8             1046*  
041ED8             1047*  ; print bytes from an address to the screen in binary format
041ED8             1048*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041ED8             1049*  ; outputs: values of each byte printed to screen separated by spaces
041ED8             1050*  ; destroys: nothing
041ED8             1051*  dumpMemoryBin:
041ED8             1052*  ; save all registers to the stack
041ED8 F5          1053*      push af
041ED9 C5          1054*      push bc
041EDA D5          1055*      push de
041EDB E5          1056*      push hl
041EDC DD E5       1057*      push ix
041EDE FD E5       1058*      push iy
041EE0             1059*  
041EE0             1060*  ; set b to be our loop counter
041EE0 47          1061*      ld b,a
041EE1             1062*  @loop:
041EE1             1063*  ; print the byte
041EE1 7E          1064*      ld a,(hl)
041EE2 E5          1065*      push hl
041EE3 C5          1066*      push bc
041EE4 CD AB 1B 04 1067*      call printBin8
041EE8 C1          1068*      pop bc
041EE9             1069*  ; print a space
041EE9 3E 20       1070*      ld a,' '
041EEB 5B D7       1071*      rst.lil 10h
041EED E1          1072*      pop hl
041EEE 23          1073*      inc hl
041EEF 10 F0       1074*      djnz @loop
041EF1 CD 22 19 04 1075*      call printNewLine
041EF5             1076*  
041EF5             1077*  ; restore everything
041EF5 FD E1       1078*      pop iy
041EF7 DD E1       1079*      pop ix
041EF9 E1          1080*      pop hl
041EFA D1          1081*      pop de
041EFB C1          1082*      pop bc
041EFC F1          1083*      pop af
041EFD             1084*  ; all done
041EFD C9          1085*      ret
041EFE             1086*  
041EFE             1087*  ; print bytes from an address to the screen in binary format
041EFE             1088*  ; with the bits of each byte in reverse order (lsb first)
041EFE             1089*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041EFE             1090*  ; outputs: values of each byte printed to screen separated by spaces
041EFE             1091*  ; destroys: nothing
041EFE             1092*  dumpMemoryBinRev:
041EFE             1093*  ; save all registers to the stack
041EFE F5          1094*      push af
041EFF C5          1095*      push bc
041F00 D5          1096*      push de
041F01 E5          1097*      push hl
041F02 DD E5       1098*      push ix
041F04 FD E5       1099*      push iy
041F06             1100*  
041F06             1101*  ; set b to be our loop counter
041F06 47          1102*      ld b,a
041F07             1103*  @loop:
041F07             1104*  ; print the byte
041F07 7E          1105*      ld a,(hl)
041F08 E5          1106*      push hl
041F09 C5          1107*      push bc
041F0A CD D0 1B 04 1108*      call printBin8Rev
041F0E C1          1109*      pop bc
041F0F             1110*  ; print a space
041F0F 3E 20       1111*      ld a,' '
041F11 5B D7       1112*      rst.lil 10h
041F13 E1          1113*      pop hl
041F14 23          1114*      inc hl
041F15 10 F0       1115*      djnz @loop
041F17 CD 22 19 04 1116*      call printNewLine
041F1B             1117*  
041F1B             1118*  ; restore everything
041F1B FD E1       1119*      pop iy
041F1D DD E1       1120*      pop ix
041F1F E1          1121*      pop hl
041F20 D1          1122*      pop de
041F21 C1          1123*      pop bc
041F22 F1          1124*      pop af
041F23             1125*  ; all done
041F23 C9          1126*      ret
041F24             0053       include "vdu.inc"
041F24             0001*  
041F24             0002*  ; VDU 30: Home cursor
041F24             0003*  vdu_home_cursor:
041F24 3E 1E       0004*      ld a,30
041F26 5B D7       0005*  	rst.lil $10
041F28 C9          0006*  	ret
041F29             0007*  
041F29             0008*  vdu_cursor_on:
041F29 21 34 1F 04 0009*  	ld hl,@cmd
041F2D 01 03 00 00 0010*  	ld bc,@end-@cmd
041F31 5B DF       0011*  	rst.lil $18
041F33 C9          0012*  	ret
041F34             0013*  @cmd:
041F34 17 01 01    0014*  	db 23,1,1
041F37             0015*  @end:
041F37             0016*  
041F37             0017*  vdu_cursor_off:
041F37 21 42 1F 04 0018*  	ld hl,@cmd
041F3B 01 03 00 00 0019*  	ld bc,@end-@cmd
041F3F 5B DF       0020*  	rst.lil $18
041F41 C9          0021*  	ret
041F42             0022*  @cmd:
041F42 17 01 00    0023*  	db 23,1,0
041F45             0024*  @end:
041F45             0025*  
041F45             0026*  ; VDU 5: Write text at graphics cursor
041F45             0027*  ; inputs: a is the character to write to the screen
041F45             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041F45             0029*  ; outputs: see the name of the function
041F45             0030*  ; destroys: a, hl, bc
041F45             0031*  vdu_char_to_gfx_cursor:
041F45 32 55 1F 04 0032*  	ld (@arg),a
041F49 21 54 1F 04 0033*  	ld hl,@cmd
041F4D 01 02 00 00 0034*  	ld bc,@end-@cmd
041F51 5B DF       0035*  	rst.lil $18
041F53 C9          0036*  	ret
041F54 05          0037*  @cmd: db 5
041F55 00          0038*  @arg: db 0
041F56             0039*  @end:
041F56             0040*  ; VDU 9: Move cursor forward one character
041F56             0041*  vdu_cursor_forward:
041F56 3E 09       0042*      ld a,9
041F58 5B D7       0043*  	rst.lil $10
041F5A C9          0044*  	ret
041F5B             0045*  
041F5B             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041F5B             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041F5B             0048*  vdu_move_cursor:
041F5B ED 43 6C 1F 0049*      ld (@x0),bc
       04          
041F60 21 6B 1F 04 0050*  	ld hl,@cmd
041F64 01 03 00 00 0051*  	ld bc,@end-@cmd
041F68 5B DF       0052*  	rst.lil $18
041F6A C9          0053*  	ret
041F6B 1F          0054*  @cmd: 	db 31
041F6C 00          0055*  @x0:	db 0
041F6D 00          0056*  @y0: 	db 0
041F6E 00          0057*  @end: 	db 0 ; padding
041F6F             0058*  
041F6F             0059*  ; VDU 12: Clear text area (CLS)
041F6F             0060*  vdu_cls:
041F6F 3E 0C       0061*      ld a,12
041F71 5B D7       0062*  	rst.lil $10
041F73 C9          0063*  	ret
041F74             0064*  
041F74             0065*  vdu_flip:
041F74 21 7F 1F 04 0066*  	ld hl,@cmd
041F78 01 03 00 00 0067*  	ld bc,@end-@cmd
041F7C 5B DF       0068*  	rst.lil $18
041F7E C9          0069*  	ret
041F7F 17 00 C3    0070*  @cmd: db 23,0,0xC3
041F82             0071*  @end:
041F82             0072*  
041F82             0073*  ; VDU 16: Clear graphics area (CLG)
041F82             0074*  vdu_clg:
041F82 3E 10       0075*      ld a,16
041F84 5B D7       0076*  	rst.lil $10
041F86 C9          0077*  	ret
041F87             0078*  
041F87             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041F87             0080*  ; VDU 23, 7: Scrolling
041F87             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041F87             0082*  ; inputs: a, extent; l, direction; h; speed
041F87             0083*  vdu_scroll_down:
041F87 32 9C 1F 04 0084*  	ld (@extent),a
041F8B 22 9D 1F 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041F8F 21 9A 1F 04 0086*  	ld hl,@cmd
041F93 01 05 00 00 0087*  	ld bc,@end-@cmd
041F97 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041F99 C9          0089*  	ret
041F9A 17 07       0090*  @cmd:       db 23,7
041F9C 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041F9D 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041F9E 00          0093*  @speed:     db 0x00 ; pixels
041F9F 00          0094*  @end:		db 0x00 ; padding
041FA0             0095*  
041FA0             0096*  ; COLOUR MODES
041FA0             0097*  ; Mode	Effect
041FA0             0098*  ; 0	Set on-screen pixel to target colour value
041FA0             0099*  ; 1	OR value with the on-screen pixel
041FA0             0100*  ; 2	AND value with the on-screen pixel
041FA0             0101*  ; 3	XOR value with the on-screen pixel
041FA0             0102*  ; 4	Invert the on-screen pixel
041FA0             0103*  ; 5	No operation
041FA0             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041FA0             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041FA0             0106*  
041FA0             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041FA0             0108*  vdu_colour_text:
041FA0 32 B0 1F 04 0109*  	ld (@arg),a
041FA4 21 AF 1F 04 0110*  	ld hl,@cmd
041FA8 01 02 00 00 0111*  	ld bc,@end-@cmd
041FAC 5B DF       0112*  	rst.lil $18
041FAE C9          0113*  	ret
041FAF 11          0114*  @cmd: db 17
041FB0 00          0115*  @arg: db 0
041FB1             0116*  @end:
041FB1             0117*  
041FB1             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041FB1             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041FB1             0120*  vdu_gcol:
041FB1 32 C6 1F 04 0121*  	ld (@mode),a
041FB5 79          0122*      ld a,c
041FB6 32 C7 1F 04 0123*      ld (@col),a
041FBA 21 C5 1F 04 0124*  	ld hl,@cmd
041FBE 01 03 00 00 0125*  	ld bc,@end-@cmd
041FC2 5B DF       0126*  	rst.lil $18
041FC4 C9          0127*  	ret
041FC5 12          0128*  @cmd:  db 18
041FC6 00          0129*  @mode: db 0
041FC7 00          0130*  @col:  db 0
041FC8             0131*  @end:
041FC8             0132*  
041FC8             0133*  
041FC8             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041FC8             0135*  ; MIND THE LITTLE-ENDIANESS
041FC8             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041FC8             0137*  ; outputs; nothing
041FC8             0138*  ; destroys: a might make it out alive
041FC8             0139*  vdu_set_txt_viewport:
041FC8 ED 43 DE 1F 0140*      ld (@lb),bc
       04          
041FCD ED 53 E0 1F 0141*  	ld (@rt),de
       04          
041FD2 21 DD 1F 04 0142*  	ld hl,@cmd
041FD6 01 05 00 00 0143*  	ld bc,@end-@cmd
041FDA 5B DF       0144*  	rst.lil $18
041FDC C9          0145*  	ret
041FDD 1C          0146*  @cmd:   db 28 ; set text viewport command
041FDE 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041FE0 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041FE2 00          0149*  @end:   db 0x00	  ; padding
041FE3             0150*  
041FE3             0151*  ; Wait for VBLANK interrupt
041FE3             0152*  vdu_vblank:
041FE3 DD E5       0153*      PUSH 	IX
041FE5             0154*  	MOSCALL	mos_sysvars
041FE5 3E 08       0001*M 			LD	A, function
041FE7 5B CF       0002*M 			RST.LIL	08h
041FE9 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041FEC             0156*  @wait:
041FEC DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041FEF 28 FB       0158*      JR	Z, @wait
041FF1 DD E1       0159*      POP	IX
041FF3 C9          0160*      RET
041FF4             0161*  
041FF4             0162*  ; VDU 29, x; y;: Set graphics origin
041FF4             0163*  ; This command sets the graphics origin.
041FF4             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041FF4             0165*  ; inputs: bc=x0,de=y0
041FF4             0166*  ; outputs; nothing
041FF4             0167*  ; destroys: a might make it out alive
041FF4             0168*  vdu_set_gfx_origin:
041FF4 ED 43 0A 20 0169*      ld (@x0),bc
       04          
041FF9 ED 53 0C 20 0170*      ld (@y0),de
       04          
041FFE 21 09 20 04 0171*      ld hl,@cmd
042002 01 05 00 00 0172*      ld bc,@end-@cmd
042006 5B DF       0173*      rst.lil $18
042008 C9          0174*      ret
042009 1D          0175*  @cmd:   db 29 ; set graphics origin command
04200A 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
04200C 00 00       0177*  @y0: 	dw 0x0000 ; set by de
04200E 00          0178*  @end:   db 0x00	  ; padding
04200F             0179*  
04200F             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04200F             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04200F             0182*  ; 	because we have turned off logical screen scaling
04200F             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04200F             0184*  ; outputs; nothing
04200F             0185*  ; destroys: a might make it out alive
04200F             0186*  vdu_set_gfx_viewport:
04200F ED 43 2F 20 0187*      ld (@x0),bc
       04          
042014 FD 22 31 20 0188*      ld (@y1),iy
       04          
042019 DD 22 33 20 0189*  	ld (@x1),ix
       04          
04201E ED 53 35 20 0190*  	ld (@y0),de
       04          
042023 21 2E 20 04 0191*  	ld hl,@cmd
042027 01 09 00 00 0192*  	ld bc,@end-@cmd
04202B 5B DF       0193*  	rst.lil $18
04202D C9          0194*  	ret
04202E 18          0195*  @cmd:   db 24 ; set graphics viewport command
04202F 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
042031 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
042033 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
042035 00 00       0199*  @y0: 	dw 0x0000 ; set by de
042037 00          0200*  @end:   db 0x00	  ; padding
042038             0201*  
042038             0202*  ; SCREEN MODES
042038             0203*  ; ===============================
042038             0204*  ; Mode  Horz  Vert  Cols  Refresh
042038             0205*  ; ---   ----  ----  ----  -------
042038             0206*  ; 11    320   240   2     60hz
042038             0207*  ; 139   320   240   2     60hz
042038             0208*  ; 23    512   384   2     60hz
042038             0209*  ; 151   512   384   2     60hz
042038             0210*  ; 6     640   240   2     60hz
042038             0211*  ; 134   640   240   2     60hz
042038             0212*  ; 2     640   480   2     60hz
042038             0213*  ; 130   640   480   2     60hz
042038             0214*  ; 17    800   600   2     60hz
042038             0215*  ; 145   800   600   2     60hz
042038             0216*  ; 18    1024  768   2     60hz
042038             0217*  ; 146   1024  768   2     60hz
042038             0218*  ; ---   ----  ----  ----  -------
042038             0219*  ; 10    320   240   4     60hz
042038             0220*  ; 138   320   240   4     60hz
042038             0221*  ; 22    512   384   4     60hz
042038             0222*  ; 150   512   384   4     60hz
042038             0223*  ; 5     640   240   4     60hz
042038             0224*  ; 133   640   240   4     60hz
042038             0225*  ; 1     640   480   4     60hz
042038             0226*  ; 129   640   480   4     60hz
042038             0227*  ; 16    800   600   4     60hz
042038             0228*  ; 19    1024  768   4     60hz
042038             0229*  ; ---   ----  ----  ----  -------
042038             0230*  ; 9     320   240   16    60hz
042038             0231*  ; 137   320   240   16    60hz
042038             0232*  ; 21    512   384   16    60hz
042038             0233*  ; 149   512   384   16    60hz
042038             0234*  ; 4     640   240   16    60hz
042038             0235*  ; 132   640   240   16    60hz
042038             0236*  ; 0     640   480   16    60hz
042038             0237*  ; 7     n/a   n/a   16    60hz
042038             0238*  ; ---   ----  ----  ----  -------
042038             0239*  ; 8     320   240   64    60hz
042038             0240*  ; 136   320   240   64    60hz
042038             0241*  ; 20    512   384   64    60hz
042038             0242*  ; 3     640   240   64    60hz
042038             0243*  ; ---   ----  ----  ----  -------
042038             0244*  vdu_set_screen_mode:
042038 32 48 20 04 0245*  	ld (@arg),a
04203C 21 47 20 04 0246*  	ld hl,@cmd
042040 01 02 00 00 0247*  	ld bc,@end-@cmd
042044 5B DF       0248*  	rst.lil $18
042046 C9          0249*  	ret
042047 16          0250*  @cmd: db 22 ; set screen mode
042048 00          0251*  @arg: db 0  ; screen mode parameter
042049             0252*  @end:
042049             0253*  
042049             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
042049             0255*  ; inputs: a is scaling mode, 1=on, 0=off
042049             0256*  ; note: default setting on boot is scaling ON
042049             0257*  vdu_set_scaling:
042049 32 5B 20 04 0258*  	ld (@arg),a
04204D 21 58 20 04 0259*  	ld hl,@cmd
042051 01 04 00 00 0260*  	ld bc,@end-@cmd
042055 5B DF       0261*  	rst.lil $18
042057 C9          0262*  	ret
042058 17 00 C0    0263*  @cmd: db 23,0,0xC0
04205B 00          0264*  @arg: db 0  ; scaling on/off
04205C             0265*  @end:
04205C             0266*  
04205C             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04205C             0268*  ; inputs: hl=bufferId
04205C             0269*  vdu_buff_select:
04205C 22 6E 20 04 0270*  	ld (@bufferId),hl
042060 21 6B 20 04 0271*  	ld hl,@cmd
042064 01 05 00 00 0272*  	ld bc,@end-@cmd
042068 5B DF       0273*  	rst.lil $18
04206A C9          0274*  	ret
04206B 17 1B 20    0275*  @cmd: db 23,27,0x20
04206E 00 00       0276*  @bufferId: dw 0x0000
042070 00          0277*  @end: db 0x00 ; padding
042071             0278*  
042071             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
042071             0280*  ; inputs: a=format; bc=width; de=height
042071             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
042071             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
042071             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
042071             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
042071             0285*  ; 2 	Mono/Mask (1-bit per pixel)
042071             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
042071             0287*  vdu_bmp_create:
042071 ED 43 8D 20 0288*      ld (@width),bc
       04          
042076 ED 53 8F 20 0289*      ld (@height),de
       04          
04207B 32 91 20 04 0290*      ld (@fmt),a
04207F 21 8A 20 04 0291*  	ld hl,@cmd
042083 01 08 00 00 0292*  	ld bc,@end-@cmd
042087 5B DF       0293*  	rst.lil $18
042089 C9          0294*  	ret
04208A 17 1B 21    0295*  @cmd:       db 23,27,0x21
04208D 00 00       0296*  @width:     dw 0x0000
04208F 00 00       0297*  @height:    dw 0x0000
042091 00          0298*  @fmt:       db 0x00
042092             0299*  @end:
042092             0300*  
042092             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
042092             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
042092             0303*  vdu_load_img_rgba2_to_8:
042092             0304*  ; backup the target buffer id and image dimensions
042092 E5          0305*      push hl
042093 D5          0306*      push de
042094 C5          0307*      push bc
042095             0308*  ; load the rgba2 image to working buffer 65534
042095 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
042099 CD 9C 21 04 0310*  	call vdu_load_buffer_from_file
04209D             0311*  ; restore the image dimensions and target buffer id
04209D C1          0312*      pop bc
04209E D1          0313*      pop de
04209F E1          0314*      pop hl
0420A0             0315*  ; fall through to vdu_rgba2_to_8
0420A0             0316*  
0420A0             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0420A0             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0420A0             0319*  ; the "expand bitmap" command is:
0420A0             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420A0             0321*  ; and then to reverse the byte order to fix endian-ness:
0420A0             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420A0             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420A0             0324*  ; VDU 23,27,&20,targetBufferID%;
0420A0             0325*  ; VDU 23,27,&21,width%;height%;0
0420A0             0326*  ; -------------------------------------------------------------------
0420A0             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0420A0             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0420A0             0329*  vdu_rgba2_to_8:
0420A0             0330*  ; load the image dimensions and buffer id parameters
0420A0 ED 43 FC 20 0331*      ld (@width),bc
       04          
0420A5 ED 53 FE 20 0332*      ld (@height),de
       04          
0420AA 22 E1 20 04 0333*      ld (@bufferId0),hl
0420AE 22 EE 20 04 0334*      ld (@bufferId2),hl
0420B2 22 F7 20 04 0335*      ld (@bufferId1),hl
0420B6             0336*  ; clean up bytes that got stomped on by the ID loads
0420B6 3E 48       0337*      ld a,0x48
0420B8 32 E3 20 04 0338*      ld (@bufferId0+2),a
0420BC 3E 17       0339*      ld a,23
0420BE 32 F9 20 04 0340*      ld (@bufferId1+2),a
0420C2 3E 18       0341*      ld a,24
0420C4 32 F0 20 04 0342*      ld (@bufferId2+2),a
0420C8 AF          0343*      xor a
0420C9 32 00 21 04 0344*      ld (@height+2),a
0420CD             0345*  ; send the vdu command strings
0420CD 21 D8 20 04 0346*      ld hl,@beg
0420D1 01 29 00 00 0347*      ld bc,@end-@beg
0420D5 5B DF       0348*      rst.lil $18
0420D7 C9          0349*      ret
0420D8             0350*  @beg:
0420D8             0351*  ; Command 14: Consolidate blocks in a buffer
0420D8             0352*  ; VDU 23, 0, &A0, bufferId; 14
0420D8 17 00 A0    0353*      db 23,0,0xA0
0420DB FE FF       0354*      dw 65534 ; workingBufferId
0420DD 0E          0355*      db 14 ; consolidate blocks
0420DE             0356*  ; the "expand bitmap" command is:
0420DE             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0420DE 17 00 A0    0358*      db 23,0,0xA0
0420E1 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
0420E3 48          0360*      db 0x48 ; given as decimal command 72 in the docs
0420E4 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0420E5 FE FF       0362*      dw 65534 ; sourceBufferId
0420E7 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0420EB             0364*  ; reverse the byte order to fix endian-ness:
0420EB             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
0420EB             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0420EB             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0420EB 17 00 A0    0368*      db 23,0,0xA0
0420EE 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
0420F0 18          0370*      db 24 ; reverse byte order
0420F1 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0420F2 04 00       0372*      dw 4 ; size (4 bytes)
0420F4             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0420F4             0374*  ; VDU 23,27,&20,targetBufferID%;
0420F4 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
0420F7 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
0420F9             0377*  ; VDU 23,27,&21,width%;height%;0
0420F9 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
0420FC 00 00       0379*  @width: dw 0x0000
0420FE 00 00       0380*  @height: dw 0x0000
042100 00          0381*      db 0x00 ; rgba8888 format
042101             0382*  @end:
042101             0383*  
042101             0384*  ; scratch variables
042101 00 00 00    0385*  bufferId0: dl 0x000000
042104 00 00 00    0386*  bufferId1: dl 0x000000
042107             0387*  
042107             0388*  ; load a vdu buffer from local memory
042107             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042107             0390*  vdu_load_buffer:
042107 ED 43 30 21 0391*      ld (@length),bc
       04          
04210C D5          0392*      push de ; save data pointer
04210D             0393*  ; send the vdu command string
04210D 7D          0394*      ld a,l
04210E 32 2D 21 04 0395*      ld (@bufferId),a
042112 7C          0396*      ld a,h
042113 32 2E 21 04 0397*      ld (@bufferId+1),a
042117 21 2A 21 04 0398*      ld hl,@cmd
04211B 01 08 00 00 0399*      ld bc,@end-@cmd
04211F 5B DF       0400*      rst.lil $18
042121             0401*  ; send the buffer data
042121 E1          0402*      pop hl ; pointer to data
042122 ED 4B 30 21 0403*      ld bc,(@length)
       04          
042127 5B DF       0404*      rst.lil $18 ; send it
042129 C9          0405*      ret
04212A             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04212A 17 00 A0    0407*  @cmd:       db 23,0,0xA0
04212D 00 00       0408*  @bufferId:	dw 0x0000
04212F 00          0409*  		    db 0 ; load buffer
042130 00 00       0410*  @length:	dw 0x0000
042132 00          0411*  @end: db 0 ; padding
042133             0412*  
042133             0413*  ; clear a buffer
042133             0414*  ; inputs: hl = bufferId
042133             0415*  vdu_clear_buffer:
042133 7D          0416*      ld a,l
042134 32 4B 21 04 0417*      ld (@bufferId),a
042138 7C          0418*      ld a,h
042139 32 4C 21 04 0419*      ld (@bufferId+1),a
04213D 21 48 21 04 0420*      ld hl,@cmd
042141 01 06 00 00 0421*      ld bc,@end-@cmd
042145 5B DF       0422*      rst.lil $18
042147 C9          0423*      ret
042148 17 00 A0    0424*  @cmd:       db 23,0,0xA0
04214B 00 00       0425*  @bufferId:	dw 0x0000
04214D 02          0426*  		    db 2 ; clear buffer
04214E             0427*  @end:
04214E             0428*  
04214E             0429*  vdu_clear_all_buffers:
04214E             0430*  ; clear all buffers
04214E 21 59 21 04 0431*      ld hl,@beg
042152 01 06 00 00 0432*      ld bc,@end-@beg
042156 5B DF       0433*      rst.lil $18
042158 C9          0434*      ret
042159 17 00 A0    0435*  @beg: db 23,0,$A0
04215C FF FF       0436*        dw -1 ; clear all buffers
04215E 02          0437*        db 2  ; command 2: clear a buffer
04215F             0438*  @end:
04215F             0439*  
04215F             0440*  ; Command 14: Consolidate blocks in a buffer
04215F             0441*  vdu_consolidate_buffer:
04215F             0442*  ; set parameters for vdu call
04215F 7D          0443*      ld a,l
042160 32 77 21 04 0444*      ld (@bufferId),a
042164 7C          0445*      ld a,h
042165 32 78 21 04 0446*      ld (@bufferId+1),a
042169 21 74 21 04 0447*      ld hl,@beg
04216D 01 06 00 00 0448*      ld bc,@end-@beg
042171 5B DF       0449*      rst.lil $18
042173 C9          0450*      ret
042174             0451*  ; VDU 23, 0, &A0, bufferId; 14
042174 17 00 A0    0452*  @beg: db 23,0,0xA0
042177 00 00       0453*  @bufferId: dw 0x0000
042179 0E          0454*             db 14
04217A             0455*  @end:
04217A             0456*  
04217A             0457*  ; load an image file to a buffer and make it a bitmap
04217A             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
04217A             0459*  vdu_load_img:
04217A             0460*  ; back up image type and dimension parameters
04217A 22 01 21 04 0461*      ld (bufferId0),hl
04217E F5          0462*      push af
04217F C5          0463*  	push bc
042180 D5          0464*  	push de
042181             0465*  ; load the image
042181 CD 9C 21 04 0466*  	call vdu_load_buffer_from_file
042185             0467*  ; now make it a bitmap
042185 2A 01 21 04 0468*      ld hl,(bufferId0)
042189 CD 5F 21 04 0469*      call vdu_consolidate_buffer
04218D 2A 01 21 04 0470*      ld hl,(bufferId0)
042191 CD 5C 20 04 0471*      call vdu_buff_select
042195 D1          0472*  	pop de ; image height
042196 C1          0473*  	pop bc ; image width
042197 F1          0474*  	pop af ; image type
042198 C3 71 20 04 0475*  	jp vdu_bmp_create ; will return to caller from there
04219C             0476*  
04219C             0477*  ; inputs: hl = bufferId; iy = pointer to filename
04219C             0478*  vdu_load_buffer_from_file:
04219C 22 01 21 04 0479*      ld (bufferId0),hl
0421A0             0480*  
0421A0             0481*  ; clear target buffer
0421A0 CD 33 21 04 0482*      call vdu_clear_buffer
0421A4             0483*  
0421A4             0484*  ; open the file in read mode
0421A4             0485*  ; Open a file
0421A4             0486*  ; HLU: Filename
0421A4             0487*  ;   C: Mode
0421A4             0488*  ; Returns:
0421A4             0489*  ;   A: Filehandle, or 0 if couldn't open
0421A4 FD E5       0490*  	push iy ; pointer to filename
0421A6 E1          0491*  	pop hl
0421A7 0E 01       0492*  	ld c,fa_read
0421A9             0493*      MOSCALL mos_fopen
0421A9 3E 0A       0001*M 			LD	A, function
0421AB 5B CF       0002*M 			RST.LIL	08h
0421AD 32 E8 21 04 0494*      ld (@filehandle),a
0421B1             0495*  
0421B1             0496*  @read_file:
0421B1             0497*  ; Read a block of data from a file
0421B1             0498*  ;   C: Filehandle
0421B1             0499*  ; HLU: Pointer to where to write the data to
0421B1             0500*  ; DEU: Number of bytes to read
0421B1             0501*  ; Returns:
0421B1             0502*  ; DEU: Number of bytes read
0421B1 3A E8 21 04 0503*      ld a,(@filehandle)
0421B5 4F          0504*      ld c,a
0421B6 21 00 E0 B7 0505*      ld hl,filedata
0421BA 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0421BE             0507*      MOSCALL mos_fread
0421BE 3E 1A       0001*M 			LD	A, function
0421C0 5B CF       0002*M 			RST.LIL	08h
0421C2             0508*  
0421C2             0509*  ; test de for zero bytes read
0421C2 21 00 00 00 0510*      ld hl,0
0421C6 AF          0511*      xor a ; clear carry
0421C7 ED 52       0512*      sbc hl,de
0421C9 CA DF 21 04 0513*      jp z,@close_file
0421CD             0514*  
0421CD             0515*  ; load a vdu buffer from local memory
0421CD             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0421CD 2A 01 21 04 0517*      ld hl,(bufferId0)
0421D1 D5          0518*      push de ; chunksize
0421D2 C1          0519*      pop bc
0421D3 11 00 E0 B7 0520*      ld de,filedata
0421D7 CD 07 21 04 0521*      call vdu_load_buffer
0421DB             0522*  
0421DB             0523*  ; read the next block
0421DB C3 B1 21 04 0524*      jp @read_file
0421DF             0525*  
0421DF             0526*  ; close the file
0421DF             0527*  @close_file:
0421DF 3A E8 21 04 0528*      ld a,(@filehandle)
0421E3             0529*      MOSCALL mos_fclose
0421E3 3E 0B       0001*M 			LD	A, function
0421E5 5B CF       0002*M 			RST.LIL	08h
0421E7 C9          0530*      ret ; vdu_load_buffer_from_file
0421E8             0531*  
0421E8 00          0532*  @filehandle: db 0 ; file handle
0421E9 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
0421EC             0534*  
0421EC 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
0421EF             0536*  
0421EF             0537*  ; File information structure (FILINFO)
0421EF             0538*  @filinfo:
0421EF 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0421F3 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0421F5 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0421F7 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0421F8 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
042205 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042305             0054       include "vdu_buff.inc"
042305             0001*  ; VDP Buffered Commands API
042305             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
042305             0003*  
042305             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042305             0005*  ; This command is used to store a data block (a sequence of bytes)
042305             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
042305             0007*  ; It could be a sequence of VDU commands which can be executed
042305             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
042305             0009*  ; When used for a sequence of VDU commands, this effectively
042305             0010*  ; allows for functions or stored procedures to be created.
042305             0011*  
042305             0012*  ; This is the most common command to use to send data to the VDP.
042305             0013*  ; Typically you will call command 2 first to ensure that the
042305             0014*  ; buffer is empty, and then make a series of calls to this command
042305             0015*  ; to send data to the buffer.
042305             0016*  
042305             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
042305             0018*  ; write to. Writing to the same buffer ID multiple times will add
042305             0019*  ; new blocks to that buffer. This allows a buffer to be built up
042305             0020*  ; over time, essentially allowing for a command to be sent across
042305             0021*  ; to the VDP in multiple separate packets.
042305             0022*  
042305             0023*  ; Whilst the length of an individual block added using this command
042305             0024*  ; is restricted to 65535 bytes (as the largest value that can be
042305             0025*  ; sent in a 16-bit number) the total size of a buffer is not
042305             0026*  ; restricted to this size, as multiple blocks can be added to a
042305             0027*  ; buffer. Given how long it takes to send data to the VDP it is
042305             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
042305             0029*  ; data or less at a time.
042305             0030*  
042305             0031*  ; As writing to a single buffer ID is cumulative with this command,
042305             0032*  ; care should be taken to ensure that the buffer is cleared out
042305             0033*  ; before writing to it.
042305             0034*  
042305             0035*  ; When building up a complex sequence of commands it is often
042305             0036*  ; advisable to use multiple blocks within a buffer. Typically
042305             0037*  ; this is easier to code, as otherwise working out exactly how
042305             0038*  ; many bytes long a command sequence is can be can be onerously
042305             0039*  ; difficult. It is also easier to modify a command sequences that
042305             0040*  ; are broken up into multiple blocks.
042305             0041*  
042305             0042*  ; As mentioned above it is advisable to send large pieces of data,
042305             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
042305             0044*  ; each packet of data sent to a buffer, the user can then perform
042305             0045*  ; other operations, such as updating the screen to indicate
042305             0046*  ; progress. This allows for long-running operations to be performed
042305             0047*  ; without blocking the screen, and larger amounts of data to be
042305             0048*  ; transferred over to the VDP than may otherwise be practical given
042305             0049*  ; the limitations of the eZ80.
042305             0050*  
042305             0051*  ; If a buffer ID of 65535 is used then this command will be
042305             0052*  ; ignored, and the data discarded. This is because this buffer ID
042305             0053*  ; is reserved for special functions.
042305             0054*  
042305             0055*  ; Using buffers for bitmaps
042305             0056*  
042305             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
042305             0058*  ; they cannot be used if they are spread over multiple blocks.
042305             0059*  ; To use a bitmap its data must be in a single contiguous block,
042305             0060*  ; and this is achieved by using the “consolidate” command &0E.
042305             0061*  
042305             0062*  ; Once you have a block that is ready to be used for a bitmap,
042305             0063*  ; the buffer must be selected, and then a bitmap created for that
042305             0064*  ; buffer using the bitmap and sprites API. This is done with the
042305             0065*  ; following commands:
042305             0066*  
042305             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
042305             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
042305             0069*  
042305             0070*  ; Until the “create bitmap” call has been made the buffer cannot
042305             0071*  ; be used as a bitmap. That is because the system needs to
042305             0072*  ; understand the dimensions of the bitmap, as well as the format
042305             0073*  ; of the data. Usually this only needs to be done once. The format
042305             0074*  ; is given as an 8-bit value, with the following values supported:
042305             0075*  ; Value 	Type 	Description
042305             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
042305             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
042305             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
042305             0079*  
042305             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
042305             0081*  ; and these are automatically stored in buffers numbered 64000-64255
042305             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
042305             0083*  ; simply a matter of adding 64000. All bitmaps created with that
042305             0084*  ; API will be RGBA8888 format.
042305             0085*  
042305             0086*  ; There is one other additional call added to the bitmap and
042305             0087*  ; sprites API, which allows for bitmaps referenced with a
042305             0088*  ; buffer ID to be added to sprites. This is done with the
042305             0089*  ; following command:
042305             0090*  
042305             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
042305             0092*  
042305             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
042305             0094*  
042305             0095*  ; It should be noted that it is possible to modify the buffer
042305             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
042305             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
042305             0098*  ; can allow you to do things such as changing colours in a bitmap,
042305             0099*  ; or flipping an image horizontally or vertically. This will even
042305             0100*  ; work on bitmaps that are being used inside sprites.
042305             0101*  
042305             0102*  ; Using commands targetting a buffer that create new blocks,
042305             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
042305             0104*  ; and remove it from use.
042305             0105*  
042305             0106*  ; Using buffers for sound samples
042305             0107*  
042305             0108*  ; Much like with bitmaps, it is advisable to send samples over
042305             0109*  ; to the VDP in multiple blocks for the same reasons.
042305             0110*  
042305             0111*  ; In contrast to bitmaps, the sound system can play back samples
042305             0112*  ; that are spread over multiple blocks, so there is no need to
042305             0113*  ; consolidate buffers. As a result of this, the sample playback
042305             0114*  ; system is also more tolerant of modifications being made to
042305             0115*  ; the buffer after a sample has been created from it, even if
042305             0116*  ; the sample is currently playing. It should be noted that
042305             0117*  ; splitting a buffer may result in unexpected behaviour if
042305             0118*  ; the sample is currently playing, such as skipping to other
042305             0119*  ; parts of the sample.
042305             0120*  
042305             0121*  ; Once you have a buffer that contains block(s) that are ready
042305             0122*  ; to be used for a sound sample, the following command must be
042305             0123*  ; used to indicate that a sample should be created from that buffer:
042305             0124*  
042305             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
042305             0126*  
042305             0127*  ; The format parameter is an 8-bit value that indicates the
042305             0128*  ; format of the sample data. The following values are supported:
042305             0129*  ; Value 	Description
042305             0130*  ; 0 	8-bit signed, 16KHz
042305             0131*  ; 1 	8-bit unsigned, 16KHz
042305             0132*  
042305             0133*  ; Once a sample has been created in this way, the sample can
042305             0134*  ; be selected for use on a channel using the following command:
042305             0135*  
042305             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
042305             0137*  
042305             0138*  ; Samples uploaded using the existing “load sample” command
042305             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
042305             0140*  ; are also stored in buffers automatically. A sample number using this system is in
042305             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
042305             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
042305             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
042305             0144*  ; buffer 64257, and so on.
042305             0145*  ; Command 1: Call a buffer
042305             0146*  
042305             0147*  ; VDU 23, 0 &A0, bufferId; 1
042305             0148*  
042305             0149*  ; This command will attempt to execute all of the commands
042305             0150*  ; stored in the buffer with the given ID. If the buffer does
042305             0151*  ; not exist, or is empty, then this command will do nothing.
042305             0152*  
042305             0153*  ; Essentially, this command passes the contents of the buffer
042305             0154*  ; to the VDP’s VDU command processor system, and executes them
042305             0155*  ; as if they were sent directly to the VDP.
042305             0156*  
042305             0157*  ; As noted against command 0, it is possible to build up a
042305             0158*  ; buffer over time by sending across multiple commands to write
042305             0159*  ; to the same buffer ID. When calling a buffer with multiple
042305             0160*  ; blocks, the blocks are executed in order.
042305             0161*  
042305             0162*  ; Care should be taken when using this command within a buffer,
042305             0163*  ; as it is possible to create an infinite loop. For instance,
042305             0164*  ; if a buffer contains a command to call itself, then this will
042305             0165*  ; result in an infinite loop. This will cause the VDP to hang,
042305             0166*  ; and the only way to recover from this is to reset the VDP.
042305             0167*  
042305             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
042305             0169*  ; to be executed. This can be useful for creating loops within
042305             0170*  ; a buffer. It will be ignored if used outside of a buffered
042305             0171*  ; command sequence.
042305             0172*  
042305             0173*  ; Command 2: Clear a buffer
042305             0174*  ; VDU 23, 0 &A0, bufferId; 2
042305             0175*  
042305             0176*  ; This command will clear the buffer with the given ID. If
042305             0177*  ; the buffer does not exist then this command will do nothing.
042305             0178*  
042305             0179*  ; Please note that this clears out all of the blocks sent to
042305             0180*  ; a buffer via command 0, not just the last one. i.e. if you
042305             0181*  ; have built up a buffer over time by sending multiple commands
042305             0182*  ; to write to the same buffer ID, this command will clear out
042305             0183*  ; all of those commands.
042305             0184*  
042305             0185*  ; Calling this command with a bufferId value of -1 (65535) will
042305             0186*  ; clear out all buffers.
042305             0187*  
042305             0188*  ; Command 3: Create a writeable buffer
042305             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
042305             0190*  ; This command will create a new writeable buffer with the given
042305             0191*  ; ID. If a buffer with the given ID already exists then this
042305             0192*  ; command will do nothing. This command is primarily intended
042305             0193*  ; for use to create a buffer that can be used to capture output
042305             0194*  ; using the “set output stream” command (see below), or to store
042305             0195*  ; data that can be used for other commands.
042305             0196*  
042305             0197*  ; It is generally quite rare that you will want to use this
042305             0198*  ; command. Typically you will instead want to use command 0
042305             0199*  ; to write data to a buffer. It is not necessary to use this
042305             0200*  ; command before using command 0, and indeed doing so will
042305             0201*  ; lead to errors as you will end up with two blocks in the
042305             0202*  ; buffer, the first of which will be empty. If you do wish
042305             0203*  ; to use this command to create a buffer for data and then
042305             0204*  ; write to it, you would need to use operation 2 of command 5,
042305             0205*  ; the “set” operation in the “buffer adjust” command, to set a
042305             0206*  ; sequence of bytes in the buffer to the data you want to write.
042305             0207*  ; This is not recommended, as it is much easier to just use
042305             0208*  ; command 0 to write a data block to a buffer.
042305             0209*  
042305             0210*  ; This new buffer will be a single empty single block upon
042305             0211*  ; creation, containing zeros.
042305             0212*  
042305             0213*  ; The length parameter is a 16-bit integer that specifies
042305             0214*  ; the maximum size of the buffer. This is the maximum number
042305             0215*  ; of bytes that can be stored in the buffer. If the buffer
042305             0216*  ; is full then no more data can be written to it, and subsequent
042305             0217*  ; writes will be ignored.
042305             0218*  
042305             0219*  ; After creating a buffer with this command it is possible to
042305             0220*  ; use command 0 to write further blocks to the buffer, however
042305             0221*  ; this is probably not advisable.
042305             0222*  
042305             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
042305             0224*  ; values have special meanings for writable buffers. See command 4.
042305             0225*  
042305             0226*  ; Command 4: Set output stream to a buffer
042305             0227*  ; VDU 23, 0 &A0, bufferId; 4
042305             0228*  
042305             0229*  ; Sets then current output stream to the buffer with the given ID.
042305             0230*  ; With two exceptions, noted below, this needs to be a writable
042305             0231*  ; buffer created with command 3. If the buffer does not exist,
042305             0232*  ; or the first block within the buffer is not writable, then
042305             0233*  ; this command will do nothing.
042305             0234*  
042305             0235*  ; Following this command, any subsequent VDU commands that send
042305             0236*  ; response packets will have those packets written to the specified
042305             0237*  ; output buffer. This allows the user to capture the response
042305             0238*  ; packets from a command sent to the VDP.
042305             0239*  
042305             0240*  ; By default, the output stream (for the main VDU command processor)
042305             0241*  ; is the communications channel from the VDP to MOS running on the
042305             0242*  ; eZ80.
042305             0243*  
042305             0244*  ; Passing a buffer ID of -1 (65535) to this command will
042305             0245*  ; remove/detach the output buffer. From that point onwards,
042305             0246*  ; any subsequent VDU commands that send response packets will
042305             0247*  ; have those responses discarded/ignored.
042305             0248*  
042305             0249*  ; Passing a buffer ID of 0 to this command will set the output
042305             0250*  ; buffer back to its original value for the current command stream.
042305             0251*  ; Typically that will be the communications channel from the VDP to
042305             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
042305             0253*  ; call has been made.
042305             0254*  
042305             0255*  ; When used inside a buffered command sequence, this command will
042305             0256*  ; only affect the output stream for that sequence of commands, and
042305             0257*  ; any other buffered command sequences that are called from within
042305             0258*  ; that sequence. Once the buffered command sequence has completed,
042305             0259*  ; the output stream will effectively be reset to its original value.
042305             0260*  
042305             0261*  ; It is strongly recommended to only use this command from within a
042305             0262*  ; buffered command sequence. Whilst it is possible to use this
042305             0263*  ; command from within a normal VDU command sequence, it is not
042305             0264*  ; recommended as it may cause unexpected behaviour. If you do use
042305             0265*  ; it in that context, it is very important to remember to restore
042305             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
042305             0267*  ; future, this command may be disabled from being used outside of
042305             0268*  ; a buffered command sequence.)
042305             0269*  
042305             0270*  ; At present, writable buffers can only be written to until the end
042305             0271*  ; of the buffer has been reached; once that happens no more data
042305             0272*  ; will be written to the buffer. It is not currently possible to
042305             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
042305             0274*  ; that the buffer is large enough to capture all of the data that
042305             0275*  ; is expected to be written to it. The only current way to “rewind”
042305             0276*  ; an output stream would be to clear the buffer and create a new
042305             0277*  ; one, and then call set output stream again with the newly created
042305             0278*  ; buffer.
042305             0279*  
042305             0280*  ; Command 5: Adjust buffer contents
042305             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
042305             0282*  
042305             0283*  ; This command will adjust the contents of a buffer, at a given
042305             0284*  ; offset. The exact nature of the adjustment will depend on the
042305             0285*  ; operation used.
042305             0286*  
042305             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
042305             0288*  ; the contents of the current buffer. This will only work if this
042305             0289*  ; command is used within a buffered command sequence, otherwise the
042305             0290*  ; command will not do anything.
042305             0291*  
042305             0292*  ; The basic set of adjustment operations are as follows:
042305             0293*  ; Operation 	Description
042305             0294*  ; 0 	NOT
042305             0295*  ; 1 	Negate
042305             0296*  ; 2 	Set value
042305             0297*  ; 3 	Add
042305             0298*  ; 4 	Add with carry
042305             0299*  ; 5 	AND
042305             0300*  ; 6 	OR
042305             0301*  ; 7 	XOR
042305             0302*  
042305             0303*  ; All of these operations will modify a byte found at the given
042305             0304*  ; offset in the buffer. The only exception to that is the “Add with
042305             0305*  ; carry” operation, which will also store the “carry” value in the
042305             0306*  ; byte at the next offset. With the exception of NOT and Negate,
042305             0307*  ; each command requires an operand value to be specified.
042305             0308*  
042305             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
042305             0310*  ; need to use the NOT operation, and so the following command would
042305             0311*  ; be used:
042305             0312*  
042305             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
042305             0314*  
042305             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
042305             0316*  ; to use the Add operation, and so the following command would be
042305             0317*  ; used:
042305             0318*  
042305             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
042305             0320*  
042305             0321*  ; When using add with carry, the carry value is stored in the byte
042305             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
042305             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
042305             0324*  ; you would need to use the Add with carry operation, and so the
042305             0325*  ; following command would be used:
042305             0326*  
042305             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
042305             0328*  
042305             0329*  ; Advanced operations
042305             0330*  
042305             0331*  ; Whilst these operations are useful, they are not particularly
042305             0332*  ; powerful as they only operate one one byte at a time, with a
042305             0333*  ; fixed operand value, and potentially cannot reach all bytes in
042305             0334*  ; a buffer. To address this, the API supports a number of advanced
042305             0335*  ; operations.
042305             0336*  
042305             0337*  ; The operation value used is an 8-bit value that can have bits
042305             0338*  ; set to modify the behaviour of the operation. The following bits
042305             0339*  ; are defined:
042305             0340*  ; Bit 	Description
042305             0341*  ; &10 	Use “advanced” offsets
042305             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
042305             0343*  ; &40 	Multiple target values should be adjusted
042305             0344*  ; &80 	Multiple operand values should be used
042305             0345*  
042305             0346*  ; These bits can be combined together to modify the behaviour of
042305             0347*  ; the operation.
042305             0348*  
042305             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
042305             0350*  ; offset one byte at a time. When either of the “multiple” variants
042305             0351*  ; are used, a 16-bit count must be provided to indicate how many
042305             0352*  ; bytes should be altered.
042305             0353*  
042305             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
042305             0355*  ; order, which can allow for buffers that are larger than 64kb
042305             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
042305             0357*  ; the 16-bit value immediately following the offset is used as a
042305             0358*  ; block index number, and the remaining 23-bits of the offset value
042305             0359*  ; are used as an offset within that block. When the “advanced”
042305             0360*  ; offset mode bit has been set then all offsets associated with
042305             0361*  ; this command must be sent as advanced offsets.
042305             0362*  
042305             0363*  ; The “buffer-fetched value” mode allows for the operand value to
042305             0364*  ; be fetched from a buffer. The operand sent as part of the
042305             0365*  ; command in this case is a pair of 16-bit values giving the
042305             0366*  ; buffer ID and offset to indicate where the actual operand value
042305             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
042305             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
042305             0369*  ; used inside a buffered command sequence. If the advanced offset
042305             0370*  ; mode is used, then the operand value is an advanced offset value.
042305             0371*  
042305             0372*  ; The “multiple target values” mode allows for multiple bytes to
042305             0373*  ; be adjusted at once. When this mode is used, the count value
042305             0374*  ; must be provided to indicate how many bytes should be adjusted.
042305             0375*  ; Unless the “multiple operand values” mode is also used, the
042305             0376*  ; operand value is used for all bytes adjusted.
042305             0377*  
042305             0378*  ; The “multiple operand values” mode allows for multiple operand
042305             0379*  ; values to be used. When this mode is used, the count value must
042305             0380*  ; be provided to indicate how many operand values should be used.
042305             0381*  ; This can allow, for instance, to add together several bytes in a
042305             0382*  ; buffer. When this mode is used in conjunction with the “multiple
042305             0383*  ; target values” mode, the number of operand values must match the
042305             0384*  ; number of target values, and the operation happens one byte at a
042305             0385*  ; time.
042305             0386*  
042305             0387*  ; Some examples of advanced operations are as follows:
042305             0388*  
042305             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
042305             0390*  
042305             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
042305             0392*  
042305             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
042305             0394*  ; modifier (&40).
042305             0395*  
042305             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
042305             0397*  
042305             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
042305             0399*  
042305             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
042305             0401*  
042305             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
042305             0403*  
042305             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
042305             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
042305             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
042305             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
042305             0408*  ; in little-endian order. As the top bit of the offset is set, this
042305             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
042305             0410*  ; Finally the value to write is sent, 42.
042305             0411*  
042305             0412*  ; An operation like this could be used to set the position as part
042305             0413*  ; of a draw command.
042305             0414*  
042305             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
042305             0416*  ; values 1, 2, 3, 4, 5:
042305             0417*  
042305             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
042305             0419*  ; offset 12 (set it to 0)
042305             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
042305             0421*  
042305             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
042305             0423*  ; 7 bytes in buffer 4 starting at offset 42:
042305             0424*  
042305             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
042305             0426*  
042305             0427*  ; As we are working on a little-endian system, integers longer
042305             0428*  ; than one byte are sent with their least significant byte first.
042305             0429*  ; This means that the add with carry operation can be used to add
042305             0430*  ; together integers of any size, so long as they are the same size.
042305             0431*  ; To do this, both the “multiple target values” and “multiple
042305             0432*  ; operand values” modes must be used.
042305             0433*  
042305             0434*  ; The following commands will add together a 16-bit, 24-bit,
042305             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
042305             0436*  ; in buffer 3 starting at offset 12, and all using the operand
042305             0437*  ; value of 42:
042305             0438*  
042305             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
042305             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
042305             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
042305             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
042305             0443*  
042305             0444*  ; Take note of how the operand value is padded out with zeros
042305             0445*  ; to match the size of the target value. 42; is used as a base
042305             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
042305             0447*  ; 16-bits to pad it out to the required size. The “carry” value
042305             0448*  ; will be stored at the next offset in the target buffer after
042305             0449*  ; the complete target value. So for a 16-bit value, the carry
042305             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
042305             0451*  ; at offset 15, and so on.
042305             0452*  
042305             0453*  ; Command 6: Conditionally call a buffer
042305             0454*  
042305             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
042305             0456*  
042305             0457*  ; This command will conditionally call a buffer if the condition
042305             0458*  ; operation passes. This command works in a similar manner to the
042305             0459*  ; “Adjust buffer contents” command.
042305             0460*  
042305             0461*  ; With this command a buffer ID of 65535 (-1) is always
042305             0462*  ; interpretted as “current buffer”, and so can only be used
042305             0463*  ; within a buffered command sequence. If used outside of a
042305             0464*  ; buffered command sequence then this command will do nothing.
042305             0465*  
042305             0466*  ; The basic set of condition operations are as follows:
042305             0467*  ; Operation 	Description
042305             0468*  ; 0 	Exists (value is non-zero)
042305             0469*  ; 1 	Not exists (value is zero)
042305             0470*  ; 2 	Equal
042305             0471*  ; 3 	Not equal
042305             0472*  ; 4 	Less than
042305             0473*  ; 5 	Greater than
042305             0474*  ; 6 	Less than or equal
042305             0475*  ; 7 	Greater than or equal
042305             0476*  ; 8 	AND
042305             0477*  ; 9 	OR
042305             0478*  
042305             0479*  ; The value that is being checked is fetched from the specified
042305             0480*  ; check buffer ID and offset. With the exception of “Exists” and
042305             0481*  ; “Not exists”, each command requires an operand value to be
042305             0482*  ; specified to check against.
042305             0483*  
042305             0484*  ; The operation value used is an 8-bit value that can have bits
042305             0485*  ; set to modify the behaviour of the operation. The following bits
042305             0486*  ; are defined:
042305             0487*  ; Bit value 	Description
042305             0488*  ; &10 	Use advanced offsets
042305             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
042305             0490*  
042305             0491*  ; These modifiers can be combined together to modify the behaviour
042305             0492*  ; of the operation.
042305             0493*  
042305             0494*  ; At this time, unlike with the “adjust” command, multiple target
042305             0495*  ; values and multiple operand values are not supported. All
042305             0496*  ; comparisons are therefore only conducted on single 8-bit values.
042305             0497*  ; (If comparisons of 16-bit values are required, multiple calls
042305             0498*  ; can be combined.) Support for them may be added in the future.
042305             0499*  
042305             0500*  ; The AND and OR operations are logical operations, and so the
042305             0501*  ; operand value is used as a boolean value. Any non-zero value is
042305             0502*  ; considered to be true, and zero is considered to be false. These
042305             0503*  ; operations therefore are most useful when used with buffer-fetched
042305             0504*  ; operand values (operations &28, &29, &38 and &39).
042305             0505*  
042305             0506*  ; Some examples of condition operations are as follows:
042305             0507*  
042305             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
042305             0509*  ; (is non-zero):
042305             0510*  
042305             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
042305             0512*  
042305             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
042305             0514*  ; exist (is zero):
042305             0515*  
042305             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
042305             0517*  
042305             0518*  ; Combining the above two examples is effectively equivalent to
042305             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
042305             0520*  
042305             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
042305             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
042305             0523*  
042305             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
042305             0525*  
042305             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
042305             0527*  
042305             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
042305             0529*  ; the value in buffer 2 at offset 8:
042305             0530*  
042305             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
042305             0532*  
042305             0533*  ; Command 7: Jump to a buffer
042305             0534*  
042305             0535*  ; VDU 23, 0, &A0, bufferId; 7
042305             0536*  
042305             0537*  ; This command will jump to the buffer with the given ID. If
042305             0538*  ; the buffer does not exist, or is empty, then this command will
042305             0539*  ; do nothing.
042305             0540*  
042305             0541*  ; This essentially works the same as the call command (command 1),
042305             0542*  ;  except that it does not return to the caller. This command is
042305             0543*  ;  therefore useful for creating loops.
042305             0544*  
042305             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
042305             0546*  ; treated as a “jump to end of current buffer”. This will return
042305             0547*  ; execution to the caller, and can be useful for exiting a loop.
042305             0548*  
042305             0549*  ; ## Command 8: Conditional Jump to a buffer
042305             0550*  
042305             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
042305             0552*  
042305             0553*  ; This command operates in a similar manner to the “Conditionally
042305             0554*  ; call a buffer” command (command 6), except that it will jump to
042305             0555*  ; the buffer if the condition operation passes.
042305             0556*  
042305             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
042305             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
042305             0559*  ; Command 9: Jump to an offset in a buffer
042305             0560*  
042305             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
042305             0562*  
042305             0563*  ; This command will jump to the given offset in the buffer with the
042305             0564*  ; given ID. If the buffer does not exist, or is empty, then this
042305             0565*  ; command will do nothing.
042305             0566*  
042305             0567*  ; The offset in this command is always an “advanced” offset, given
042305             0568*  ; as a 24-bit value in little-endian order. As with other uses of
042305             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
042305             0570*  ; offset value, a block number must also be provided.
042305             0571*  
042305             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
042305             0573*  ; meaning “jump within current buffer”. This can be useful for
042305             0574*  ; creating loops within a buffer, or when building up command
042305             0575*  ; sequences that may be copied across multiple buffers.
042305             0576*  
042305             0577*  ; Jumping to an offset that is beyond the end of the buffer is
042305             0578*  ; equivalent to jumping to the end of the buffer.
042305             0579*  ; Command 10: Conditional jump to an offset in a buffer
042305             0580*  
042305             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
042305             0582*  
042305             0583*  ; A conditional jump with an offset works in a similar manner to
042305             0584*  ; the “Conditional call a buffer” command (command 6), except that
042305             0585*  ; it will jump to the given offset in the buffer if the condition
042305             0586*  ; operation passes.
042305             0587*  
042305             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
042305             0589*  ; the offset in this command is always an “advanced” offset, given
042305             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
042305             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
042305             0592*  ; treated as meaning “jump within current buffer”.
042305             0593*  ; Command 11: Call buffer with an offset
042305             0594*  
042305             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
042305             0596*  
042305             0597*  ; Works just like “Call a buffer” (command 1), except that it also
042305             0598*  ; accepts an advanced offset.
042305             0599*  
042305             0600*  ; Command 12: Conditional call buffer with an offset
042305             0601*  
042305             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
042305             0603*  
042305             0604*  ; Works just like the “Conditional call a buffer” command
042305             0605*  ; (command 6), except that it also accepts an advanced offset.
042305             0606*  
042305             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
042305             0608*  
042305             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
042305             0610*  
042305             0611*  ; This command will copy the contents of multiple buffers into a
042305             0612*  ; single buffer. The buffers to copy from are specified as a list
042305             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
042305             0614*  ; buffers are copied in the order they are specified.
042305             0615*  
042305             0616*  ; This is a block-wise copy, so the blocks from the source buffers
042305             0617*  ; are copied into the target buffer. The blocks are copied in the
042305             0618*  ; order they are found in the source buffers.
042305             0619*  
042305             0620*  ; The target buffer will be overwritten with the contents of the
042305             0621*  ; source buffers. This will not be done however until after all the
042305             0622*  ; data has been gathered and copied. The target buffer can therefore
042305             0623*  ; included in the list of the source buffers.
042305             0624*  
042305             0625*  ; If a source buffer that does not exist is specified, or a source
042305             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
042305             0627*  
042305             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
042305             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
042305             0630*  ; copied multiple times into the target buffer.
042305             0631*  
042305             0632*  ; If there is insufficient memory available on the VDP to complete
042305             0633*  ; this command then it will fail, and the target buffer will be
042305             0634*  ; left unchanged.
042305             0635*  
042305             0636*  
042305             0637*  ; Command 14: Consolidate blocks in a buffer
042305             0638*  
042305             0639*  ; VDU 23, 0, &A0, bufferId; 14
042305             0640*  
042305             0641*  ; Takes all the blocks in a buffer and consolidates them into a
042305             0642*  ; single block. This is useful for bitmaps, as it allows for a
042305             0643*  ; bitmap to be built up over time in multiple blocks, and then
042305             0644*  ; consolidated into a single block for use as a bitmap.
042305             0645*  
042305             0646*  ; If there is insufficient memory available on the VDP to complete
042305             0647*  ; this command then it will fail, and the buffer will be left
042305             0648*  ; unchanged.
042305             0649*  
042305             0650*  ; Command 15: Split a buffer into multiple blocks
042305             0651*  
042305             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
042305             0653*  
042305             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
042305             0655*  ; is a 16-bit integer that specifies the target size of each block.
042305             0656*  ; If the source data is not a multiple of the block size then the
042305             0657*  ; last block will be smaller than the specified block size.
042305             0658*  
042305             0659*  ; If this command is used on a buffer that is already split into
042305             0660*  ; multiple blocks, then the blocks will be consolidated first,
042305             0661*  ; and then re-split into the new block size.
042305             0662*  
042305             0663*  ; If there is insufficient memory available on the VDP to complete
042305             0664*  ; this command then it will fail, and the buffer will be left
042305             0665*  ; unchanged.
042305             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
042305             0667*  ; multiple buffers
042305             0668*  
042305             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
042305             0670*  
042305             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
042305             0672*  ; then spreads the resultant blocks across the target buffers.
042305             0673*  ; The target buffers are specified as a list of buffer IDs,
042305             0674*  ; terminated by a buffer ID of -1 (65535).
042305             0675*  
042305             0676*  ; The blocks are spread across the target buffers in the order
042305             0677*  ; they are specified, and the spread will loop around the buffers
042305             0678*  ; until all the blocks have been distributed. The target buffers
042305             0679*  ; will be cleared out before the blocks are spread across them.
042305             0680*  
042305             0681*  ; What this means is that if the source buffer is, let’s say,
042305             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
042305             0683*  ; then we will end up with 10 blocks. If we then spread those
042305             0684*  ; blocks across 3 target buffers, then the first buffer will
042305             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
042305             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
042305             0687*  ; blocks 3, 6 and 9.
042305             0688*  
042305             0689*  ; This command attempts to ensure that, in the event of
042305             0690*  ; insufficient memory being available on the VDP to complete
042305             0691*  ; the command, it will leave the targets as they were before
042305             0692*  ; the command was executed. However this may not always be
042305             0693*  ; possible. The first step of this command is to consolidate
042305             0694*  ; the source buffer into a single block, and this may fail from
042305             0695*  ; insufficient memory. If that happens then all the buffers will
042305             0696*  ; be left as they were. After this however the target buffers
042305             0697*  ; will be cleared. If there is insufficient memory to successfully
042305             0698*  ; split the buffer into multiple blocks then the call will exit,
042305             0699*  ; and the target buffers will be left empty.
042305             0700*  ; Command 17: Split a buffer and spread across blocks, starting
042305             0701*  ; at target buffer ID
042305             0702*  
042305             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
042305             0704*  
042305             0705*  ; As per the above two commands, this will split a buffer into
042305             0706*  ; multiple blocks. It will then spread the blocks across buffers
042305             0707*  ; starting at the target buffer ID, incrementing the target buffer
042305             0708*  ; ID until all the blocks have been distributed.
042305             0709*  
042305             0710*  ; Target blocks will be cleared before a block is stored in them.
042305             0711*  ; Each target will contain a single block. The exception to this
042305             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
042305             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
042305             0714*  ; will be placed into buffer 65534.
042305             0715*  
042305             0716*  ; With this command if there is insufficient memory available on
042305             0717*  ; the VDP to complete the command then it will fail, and the target
042305             0718*  ; buffers will be left unchanged.
042305             0719*  
042305             0720*  ; Command 18: Split a buffer into blocks by width
042305             0721*  
042305             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
042305             0723*  
042305             0724*  ; This command splits a buffer into a given number of blocks by
042305             0725*  ; first of all splitting the buffer into blocks of a given width
042305             0726*  ; (number of bytes), and then consolidating those blocks into the
042305             0727*  ; given number of blocks.
042305             0728*  
042305             0729*  ; This is useful for splitting a bitmap into a number of separate
042305             0730*  ; columns, which can then be manipulated individually. This can be
042305             0731*  ; useful for dealing with sprite sheets.
042305             0732*  ; Command 19: Split by width into blocks and spread across target
042305             0733*  ; buffers
042305             0734*  
042305             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
042305             0736*  
042305             0737*  ; This command essentially operates the same as command 18, but the
042305             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
042305             0739*  
042305             0740*  ; Command 20: Split by width into blocks and spread across blocks
042305             0741*  ; starting at target buffer ID
042305             0742*  
042305             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
042305             0744*  
042305             0745*  ; This command essentially operates the same as command 18, but
042305             0746*  ; the generated blocks are spread across blocks starting at the
042305             0747*  ; target buffer ID, as per command 17.
042305             0748*  
042305             0749*  ; Command 21: Spread blocks from a buffer across multiple target
042305             0750*  ; buffers
042305             0751*  
042305             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
042305             0753*  
042305             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
042305             0755*  ; The target buffers are specified as a list of buffer IDs,
042305             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
042305             0757*  ; across the target buffers in the order they are specified, and
042305             0758*  ; the spread will loop around the buffers until all the blocks have
042305             0759*  ; been distributed.
042305             0760*  
042305             0761*  ; It should be noted that this command does not copy the blocks,
042305             0762*  ; and nor does it move them. Unless the source buffer has been
042305             0763*  ; included in the list of targets, it will remain completely
042305             0764*  ; intact. The blocks distributed across the target buffers will
042305             0765*  ; point to the same memory as the blocks in the source buffer.
042305             0766*  ; Operations to modify data in the source buffer will also modify
042305             0767*  ; the data in the target buffers. Clearing the source buffer
042305             0768*  ; however will not clear the target buffers.
042305             0769*  
042305             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
042305             0771*  ; at target buffer ID
042305             0772*  
042305             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
042305             0774*  
042305             0775*  ; Spreads the blocks from a buffer across blocks starting at
042305             0776*  ; the target buffer ID.
042305             0777*  
042305             0778*  ; This essentially works the same as command 21, and the same
042305             0779*  ; notes about copying and moving blocks apply. Blocks are spread
042305             0780*  ; in the same manner as commands 17 and 20.
042305             0781*  
042305             0782*  ; Command 23: Reverse the order of blocks in a buffer
042305             0783*  
042305             0784*  ; VDU 23, 0, &A0, bufferId; 23
042305             0785*  
042305             0786*  ; Reverses the order of the blocks in a buffer.
042305             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
042305             0788*  
042305             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
042305             0790*  
042305             0791*  ; Reverses the order of the data within the blocks of a buffer.
042305             0792*  ; The options parameter is an 8-bit value that can have bits set
042305             0793*  ; to modify the behaviour of the operation. The following bits
042305             0794*  ; are defined:
042305             0795*  ; Bit value 	Description
042305             0796*  ; 1 	Values are 16-bits in size
042305             0797*  ; 2 	Values are 32-bits in size
042305             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
042305             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
042305             0800*  ; 8 	Reverse blocks
042305             0801*  
042305             0802*  ; These modifiers can be combined together to modify the behaviour
042305             0803*  ; of the operation.
042305             0804*  
042305             0805*  ; If no value size is set in the options (i.e. the value of the
042305             0806*  ; bottom two bits of the options is zero) then the value size is
042305             0807*  ; assumed to be 8-bits.
042305             0808*  
042305             0809*  ; It is probably easiest to understand what this operation is
042305             0810*  ; capable of by going through some examples of how it can be used
042305             0811*  ; to manipulate bitmaps. The VDP supports two different formats
042305             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
042305             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
042305             0814*  ; pixel.
042305             0815*  
042305             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
042305             0817*  ; degrees, which can be done by just reversing the order of
042305             0818*  ; bytes in the buffer:
042305             0819*  
042305             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
042305             0821*  
042305             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
042305             0823*  ; little more complex, as each pixel is made up of 4 bytes.
042305             0824*  ; However with this command it is still a simple operation, as
042305             0825*  ; we can just reverse the order of the 32-bit values that make
042305             0826*  ; up the bitmap by using an options value of 2:
042305             0827*  
042305             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
042305             0829*  
042305             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
042305             0831*  ; the order of rows of pixels. To do this we can set a custom
042305             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
042305             0833*  ; bitmap we can just set a custom value size to our bitmap width:
042305             0834*  
042305             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
042305             0836*  
042305             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
042305             0838*  ; our width by 4:
042305             0839*  
042305             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
042305             0841*  
042305             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
042305             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
042305             0844*  ; just set a custom chunk size to our bitmap width:
042305             0845*  
042305             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
042305             0847*  
042305             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
042305             0849*  ; 32-bit values as well as a custom chunk size:
042305             0850*  
042305             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
042305             0852*  
042305             0853*  ; Command 25: Copy blocks from multiple buffers by reference
042305             0854*  
042305             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
042305             0856*  
042305             0857*  ; This command is essentially a version of command 13 that copies
042305             0858*  ; blocks by reference rather than by value. The parameters for
042305             0859*  ; this command are the same as for command 13, and the same rules
042305             0860*  ; apply.
042305             0861*  
042305             0862*  ; If the target buffer is included in the list of source buffers
042305             0863*  ; then it will be skipped to prevent a reference loop.
042305             0864*  
042305             0865*  ; Copying by reference means that the blocks in the target buffer
042305             0866*  ; will point to the same memory as the blocks in the source
042305             0867*  ; buffers. Operations to modify data blocks in the source buffers
042305             0868*  ; will therefore also modify those blocks in the target buffer.
042305             0869*  ; Clearing the source buffers will not clear the target buffer -
042305             0870*  ; it will still point to the original data blocks. Data blocks
042305             0871*  ; are only freed from memory when no buffers are left with any
042305             0872*  ; references to them.
042305             0873*  
042305             0874*  ; Buffers that get consolidated become new blocks, so will lose
042305             0875*  ; their links to the original blocks, thus after a “consolidate”
042305             0876*  ; operation modifications to the original blocks will no longer be
042305             0877*  ; reflected in the consolidated buffer.
042305             0878*  
042305             0879*  ; This command is useful to construct a single buffer from multiple
042305             0880*  ; sources without the copy overhead, which can be costly. For
042305             0881*  ; example, this can be useful for constructing a bitmap from
042305             0882*  ; multiple constituent parts before consolidating it into a
042305             0883*  ; single block. In such an example, using command 13 instead
042305             0884*  ; would first make a copy of the contents of the source buffers,
042305             0885*  ; and then consolidate them into a single block. Using this
042305             0886*  ; command does not make that first copy, and so would be faster.
042305             0887*  
042305             0888*  ; This command is also useful for creating multiple buffers that
042305             0889*  ; all point to the same data.
042305             0890*  
042305             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
042305             0892*  
042305             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
042305             0055       include "vdu_plot.inc"
042305             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042305             0002*  ; PLOT code 	(Decimal) 	Effect
042305             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
042305             0004*  plot_sl_both: equ 0x00
042305             0005*  
042305             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
042305             0007*  plot_sl_first: equ 0x08
042305             0008*  
042305             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
042305             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
042305             0011*  
042305             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
042305             0013*  plot_sl_last: equ 0x20
042305             0014*  
042305             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
042305             0016*  plot_sl_none: equ 0x28
042305             0017*  
042305             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
042305             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
042305             0020*  
042305             0021*  ; &40-&47 	64-71 	Point plot
042305             0022*  plot_pt: equ 0x40
042305             0023*  
042305             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
042305             0025*  plot_lf_lr_non_bg: equ 0x48
042305             0026*  
042305             0027*  ; &50-&57 	80-87 	Triangle fill
042305             0028*  plot_tf: equ 0x50
042305             0029*  
042305             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
042305             0031*  plot_lf_r_bg: equ 0x58
042305             0032*  
042305             0033*  ; &60-&67 	96-103 	Rectangle fill
042305             0034*  plot_rf: equ 0x60
042305             0035*  
042305             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
042305             0037*  plot_lf_lr_fg: equ 0x60
042305             0038*  
042305             0039*  ; &70-&77 	112-119 	Parallelogram fill
042305             0040*  plot_pf: equ 0x70
042305             0041*  
042305             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
042305             0043*  plot_lf_r_non_fg: equ 0x78
042305             0044*  
042305             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
042305             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
042305             0047*  
042305             0048*  ; &90-&97 	144-151 	Circle outline
042305             0049*  plot_co: equ 0x90
042305             0050*  
042305             0051*  ; &98-&9F 	152-159 	Circle fill
042305             0052*  plot_cf: equ 0x98
042305             0053*  
042305             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
042305             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
042305             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
042305             0057*  
042305             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
042305             0059*  plot_rcm: equ 0xB8
042305             0060*  
042305             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
042305             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
042305             0063*  ; &D0-&D7 	208-215 	Not defined
042305             0064*  ; &D8-&DF 	216-223 	Not defined
042305             0065*  ; &E0-&E7 	224-231 	Not defined
042305             0066*  
042305             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
042305             0068*  plot_bmp: equ 0xE8
042305             0069*  
042305             0070*  ; &F0-&F7 	240-247 	Not defined
042305             0071*  ; &F8-&FF 	248-255 	Not defined
042305             0072*  
042305             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
042305             0074*  ; Agon Console8 VDP 2.2.0
042305             0075*  
042305             0076*  ; Within each group of eight plot codes, the effects are as follows:
042305             0077*  ; Plot code 	Effect
042305             0078*  ; 0 	Move relative
042305             0079*  mv_rel: equ 0
042305             0080*  
042305             0081*  ; 1 	Plot relative in current foreground colour
042305             0082*  dr_rel_fg: equ 1
042305             0083*  
042305             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
042305             0085*  ; 3 	Plot relative in current background colour
042305             0086*  dr_rel_bg: equ 3
042305             0087*  
042305             0088*  ; 4 	Move absolute
042305             0089*  mv_abs: equ 4
042305             0090*  
042305             0091*  ; 5 	Plot absolute in current foreground colour
042305             0092*  dr_abs_fg: equ 5
042305             0093*  
042305             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
042305             0095*  ; 7 	Plot absolute in current background colour
042305             0096*  dr_abs_bg: equ 7
042305             0097*  
042305             0098*  ; Codes 0-3 use the position data provided as part of the command
042305             0099*  ; as a relative position, adding the position given to the current
042305             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
042305             0101*  ; as part of the command as an absolute position, setting the current
042305             0102*  ; graphical cursor position to the position given.
042305             0103*  
042305             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
042305             0105*  ; current pixel colour. These operations cannot currently be supported
042305             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
042305             0107*  ; supported. Support for these codes may be added in a future version
042305             0108*  ; of the VDP firmware.
042305             0109*  
042305             0110*  ; 16 colour palette constants
042305             0111*  c_black: equ 0
042305             0112*  c_red_dk: equ 1
042305             0113*  c_green_dk: equ 2
042305             0114*  c_yellow_dk: equ 3
042305             0115*  c_blue_dk: equ 4
042305             0116*  c_magenta_dk: equ 5
042305             0117*  c_cyan_dk: equ 6
042305             0118*  c_grey: equ 7
042305             0119*  c_grey_dk: equ 8
042305             0120*  c_red: equ 9
042305             0121*  c_green: equ 10
042305             0122*  c_yellow: equ 11
042305             0123*  c_blue: equ 12
042305             0124*  c_magenta: equ 13
042305             0125*  c_cyan: equ 14
042305             0126*  c_white: equ 15
042305             0127*  
042305             0128*  ; VDU 25, mode, x; y;: PLOT command
042305             0129*  ; inputs: a=mode, bc=x0, de=y0
042305             0130*  vdu_plot:
042305 32 1F 23 04 0131*      ld (@mode),a
042309 ED 43 20 23 0132*      ld (@x0),bc
       04          
04230E ED 53 22 23 0133*      ld (@y0),de
       04          
042313 21 1E 23 04 0134*  	ld hl,@cmd
042317 01 06 00 00 0135*  	ld bc,@end-@cmd
04231B 5B DF       0136*  	rst.lil $18
04231D C9          0137*  	ret
04231E 19          0138*  @cmd:   db 25
04231F 00          0139*  @mode:  db 0
042320 00 00       0140*  @x0: 	dw 0
042322 00 00       0141*  @y0: 	dw 0
042324 00          0142*  @end:   db 0 ; extra byte to soak up deu
042325             0143*  
042325             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042325             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
042325             0146*  ; VDU 25, mode, x; y;: PLOT command
042325             0147*  ; inputs: bc=x0, de=y0
042325             0148*  ; prerequisites: vdu_buff_select
042325             0149*  vdu_plot_bmp:
042325 ED 43 3C 23 0150*      ld (@x0),bc
       04          
04232A ED 53 3E 23 0151*      ld (@y0),de
       04          
04232F 21 3A 23 04 0152*  	ld hl,@cmd
042333 01 06 00 00 0153*  	ld bc,@end-@cmd
042337 5B DF       0154*  	rst.lil $18
042339 C9          0155*  	ret
04233A 19          0156*  @cmd:   db 25
04233B ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04233C 00 00       0158*  @x0: 	dw 0x0000
04233E 00 00       0159*  @y0: 	dw 0x0000
042340 00          0160*  @end:   db 0x00 ; padding
042341             0161*  
042341             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042341             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
042341             0164*  ; VDU 25, mode, x; y;: PLOT command
042341             0165*  ; inputs: bc=x0, de=y0
042341             0166*  ; USING 16.8 FIXED POINT COORDINATES
042341             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042341             0168*  ;   the fractional portiion of the inputs are truncated
042341             0169*  ;   leaving only the 16-bit integer portion
042341             0170*  ; prerequisites: vdu_buff_select
042341             0171*  vdu_plot_bmp168:
042341             0172*  ; populate in the reverse of normal to keep the
042341             0173*  ; inputs from stomping on each other
042341 ED 53 5F 23 0174*      ld (@y0-1),de
       04          
042346 ED 43 5D 23 0175*      ld (@x0-1),bc
       04          
04234B 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
04234D 32 5D 23 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
042351 21 5C 23 04 0178*  	ld hl,@cmd
042355 01 06 00 00 0179*  	ld bc,@end-@cmd
042359 5B DF       0180*  	rst.lil $18
04235B C9          0181*  	ret
04235C 19          0182*  @cmd:   db 25
04235D ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04235E 00 00       0184*  @x0: 	dw 0x0000
042360 00 00       0185*  @y0: 	dw 0x0000
042362             0186*  @end:  ; no padding required b/c we shifted de right
042362             0187*  
042362             0188*  ; draw a filled rectangle
042362             0189*  vdu_plot_rf:
042362 ED 43 89 23 0190*      ld (@x0),bc
       04          
042367 ED 53 8B 23 0191*      ld (@y0),de
       04          
04236C DD 22 8F 23 0192*      ld (@x1),ix
       04          
042371 FD 22 91 23 0193*      ld (@y1),iy
       04          
042376 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
042378 32 8D 23 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04237C 21 87 23 04 0196*  	ld hl,@cmd0
042380 01 0C 00 00 0197*  	ld bc,@end-@cmd0
042384 5B DF       0198*  	rst.lil $18
042386 C9          0199*      ret
042387 19          0200*  @cmd0:  db 25 ; plot
042388 04          0201*  @arg0:  db plot_sl_both+mv_abs
042389 00 00       0202*  @x0:    dw 0x0000
04238B 00 00       0203*  @y0:    dw 0x0000
04238D 19          0204*  @cmd1:  db 25 ; plot
04238E 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04238F 00 00       0206*  @x1:    dw 0x0000
042391 00 00       0207*  @y1:    dw 0x0000
042393 00          0208*  @end:   db 0x00 ; padding
042394             0209*  
042394             0210*  ; draw a filled circle
042394             0211*  vdu_plot_cf:
042394 ED 43 BB 23 0212*      ld (@x0),bc
       04          
042399 ED 53 BD 23 0213*      ld (@y0),de
       04          
04239E DD 22 C1 23 0214*      ld (@x1),ix
       04          
0423A3 FD 22 C3 23 0215*      ld (@y1),iy
       04          
0423A8 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0423AA 32 BF 23 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0423AE 21 B9 23 04 0218*  	ld hl,@cmd0
0423B2 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0423B6 5B DF       0220*  	rst.lil $18
0423B8 C9          0221*      ret
0423B9 19          0222*  @cmd0:  db 25 ; plot
0423BA 04          0223*  @arg0:  db plot_sl_both+mv_abs
0423BB 00 00       0224*  @x0:    dw 0x0000
0423BD 00 00       0225*  @y0:    dw 0x0000
0423BF 19          0226*  @cmd1:  db 25 ; plot
0423C0 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0423C1 00 00       0228*  @x1:    dw 0x0000
0423C3 00 00       0229*  @y1:    dw 0x0000
0423C5 00          0230*  @end:   db 0x00 ; padding
0423C6             0056   	include "vdu_sprites.inc"
0423C6             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
0423C6             0002*  ; the VDP can support up to 256 sprites. They must be defined
0423C6             0003*  ; contiguously, and so the first sprite is sprite 0.
0423C6             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
0423C6             0005*  ; Once a selection of sprites have been defined, you can activate
0423C6             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
0423C6             0007*  ; of sprites to activate. This will activate the first n sprites,
0423C6             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
0423C6             0009*  
0423C6             0010*  ; A single sprite can have multiple "frames", referring to
0423C6             0011*  ; different bitmaps.
0423C6             0012*  ; (These bitmaps do not need to be the same size.)
0423C6             0013*  ; This allows a sprite to include an animation sequence,
0423C6             0014*  ; which can be stepped through one frame at a time, or picked
0423C6             0015*  ; in any order.
0423C6             0016*  
0423C6             0017*  ; Any format of bitmap can be used as a sprite frame. It should
0423C6             0018*  ; be noted however that "native" format bitmaps are not
0423C6             0019*  ; recommended for use as sprite frames, as they cannot get
0423C6             0020*  ; erased from the screen. (As noted above, the "native" bitmap
0423C6             0021*  ; format is not really intended for general use.) This is part
0423C6             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
0423C6             0023*  ; screen are now stored in RGBA2222 format.
0423C6             0024*  
0423C6             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
0423C6             0026*  ; and then later shown again.
0423C6             0027*  
0423C6             0028*  ; Moving sprites around the screen is done by changing the
0423C6             0029*  ; position of the sprite. This can be done either by setting
0423C6             0030*  ; the absolute position of the sprite, or by moving the sprite
0423C6             0031*  ; by a given number of pixels. (Sprites are positioned using
0423C6             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
0423C6             0033*  ; In the current sprite system, sprites will not update their
0423C6             0034*  ; position on-screen until either another drawing operation is
0423C6             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
0423C6             0036*  
0423C6             0037*  ; VDU 23, 27, 4, n: Select sprite n
0423C6             0038*  ; inputs: a is the 8-bit sprite id
0423C6             0039*  vdu_sprite_select:
0423C6 32 D8 23 04 0040*      ld (@sprite),a
0423CA 21 D5 23 04 0041*      ld hl,@cmd
0423CE 01 04 00 00 0042*      ld bc,@end-@cmd
0423D2 5B DF       0043*      rst.lil $18
0423D4 C9          0044*      ret
0423D5 17 1B 04    0045*  @cmd:    db 23,27,4
0423D8 00          0046*  @sprite: db 0x00
0423D9             0047*  @end:
0423D9             0048*  
0423D9             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
0423D9             0050*  ; inputs: none
0423D9             0051*  ; prerequisites: vdu_sprite_select
0423D9             0052*  vdu_sprite_clear_frames:
0423D9 21 E4 23 04 0053*      ld hl,@cmd
0423DD 01 03 00 00 0054*      ld bc,@end-@cmd
0423E1 5B DF       0055*      rst.lil $18
0423E3 C9          0056*      ret
0423E4 17 1B 05    0057*  @cmd: db 23,27,5
0423E7             0058*  @end:
0423E7             0059*  
0423E7             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0423E7             0061*  ; inputs: a is the 8-bit bitmap number
0423E7             0062*  ; prerequisites: vdu_sprite_select
0423E7             0063*  vdu_sprite_add_bmp:
0423E7 32 F9 23 04 0064*      ld (@bmp),a
0423EB 21 F6 23 04 0065*      ld hl,@cmd
0423EF 01 04 00 00 0066*      ld bc,@end-@cmd
0423F3 5B DF       0067*      rst.lil $18
0423F5 C9          0068*      ret
0423F6 17 1B 06    0069*  @cmd: db 23,27,6
0423F9 00          0070*  @bmp: db 0x00
0423FA             0071*  @end:
0423FA             0072*  
0423FA             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0423FA             0074*  ; inputs: a is the number of sprites to activate
0423FA             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0423FA             0076*  vdu_sprite_activate:
0423FA 32 0C 24 04 0077*      ld (@num),a
0423FE 21 09 24 04 0078*      ld hl,@cmd
042402 01 04 00 00 0079*      ld bc,@end-@cmd
042406 5B DF       0080*      rst.lil $18
042408 C9          0081*      ret
042409 17 1B 07    0082*  @cmd: db 23,27,7
04240C 00          0083*  @num: db 0x00
04240D             0084*  @end:
04240D             0085*  
04240D             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
04240D             0087*  ; inputs: none
04240D             0088*  ; prerequisites: vdu_sprite_select
04240D             0089*  vdu_sprite_next_frame:
04240D 21 18 24 04 0090*      ld hl,@cmd
042411 01 03 00 00 0091*      ld bc,@end-@cmd
042415 5B DF       0092*      rst.lil $18
042417 C9          0093*      ret
042418 17 1B 08    0094*  @cmd: db 23,27,8
04241B             0095*  @end:
04241B             0096*  
04241B             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
04241B             0098*  ; inputs: none
04241B             0099*  ; prerequisites: vdu_sprite_select
04241B             0100*  vdu_sprite_prev_frame:
04241B 21 26 24 04 0101*      ld hl,@cmd
04241F 01 03 00 00 0102*      ld bc,@end-@cmd
042423 5B DF       0103*      rst.lil $18
042425 C9          0104*      ret
042426 17 1B 09    0105*  @cmd: db 23,27,9
042429             0106*  @end:
042429             0107*  
042429             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
042429             0109*  ; inputs: a is frame number to select
042429             0110*  ; prerequisites: vdu_sprite_select
042429             0111*  vdu_sprite_select_frame:
042429 32 3B 24 04 0112*      ld (@frame),a
04242D 21 38 24 04 0113*      ld hl,@cmd
042431 01 04 00 00 0114*      ld bc,@end-@cmd
042435 5B DF       0115*      rst.lil $18
042437 C9          0116*      ret
042438 17 1B 0A    0117*  @cmd:    db 23,27,10
04243B 00          0118*  @frame:  db 0x00
04243C             0119*  @end:
04243C             0120*  
04243C             0121*  ; VDU 23, 27, 11: Show current sprite
04243C             0122*  ; inputs: none
04243C             0123*  ; prerequisites: vdu_sprite_select
04243C             0124*  vdu_sprite_show:
04243C 21 47 24 04 0125*      ld hl,@cmd
042440 01 03 00 00 0126*      ld bc,@end-@cmd
042444 5B DF       0127*      rst.lil $18
042446 C9          0128*      ret
042447 17 1B 0B    0129*  @cmd: db 23,27,11
04244A             0130*  @end:
04244A             0131*  
04244A             0132*  ; VDU 23, 27, 12: Hide current sprite
04244A             0133*  ; inputs: none
04244A             0134*  ; prerequisites: vdu_sprite_select
04244A             0135*  vdu_sprite_hide:
04244A 21 55 24 04 0136*      ld hl,@cmd
04244E 01 03 00 00 0137*      ld bc,@end-@cmd
042452 5B DF       0138*      rst.lil $18
042454 C9          0139*      ret
042455 17 1B 0C    0140*  @cmd: db 23,27,12
042458             0141*  @end:
042458             0142*  
042458             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042458             0144*  ; inputs: bc is x coordinate, de is y coordinate
042458             0145*  ; prerequisites: vdu_sprite_select
042458             0146*  vdu_sprite_move_abs:
042458 ED 43 70 24 0147*      ld (@xpos),bc
       04          
04245D ED 53 72 24 0148*      ld (@ypos),de
       04          
042462 21 6D 24 04 0149*      ld hl,@cmd
042466 01 07 00 00 0150*      ld bc,@end-@cmd
04246A 5B DF       0151*      rst.lil $18
04246C C9          0152*      ret
04246D 17 1B 0D    0153*  @cmd:  db 23,27,13
042470 00 00       0154*  @xpos: dw 0x0000
042472 00 00       0155*  @ypos: dw 0x0000
042474 00          0156*  @end:  db 0x00 ; padding
042475             0157*  
042475             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042475             0159*  ; inputs: bc is x coordinate, de is y coordinate
042475             0160*  ; prerequisites: vdu_sprite_select
042475             0161*  vdu_sprite_move_rel:
042475 ED 43 8D 24 0162*      ld (@dx),bc
       04          
04247A ED 53 8F 24 0163*      ld (@dy),de
       04          
04247F 21 8A 24 04 0164*      ld hl,@cmd
042483 01 07 00 00 0165*      ld bc,@end-@cmd
042487 5B DF       0166*      rst.lil $18
042489 C9          0167*      ret
04248A 17 1B 0E    0168*  @cmd: db 23,27,14
04248D 00 00       0169*  @dx:  dw 0x0000
04248F 00 00       0170*  @dy:  dw 0x0000
042491 00          0171*  @end: db 0x00 ; padding
042492             0172*  
042492             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042492             0174*  ; USING 16.8 FIXED POINT COORDINATES
042492             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042492             0176*  ;   the fractional portiion of the inputs are truncated
042492             0177*  ;   leaving only the 16-bit integer portion
042492             0178*  ; prerequisites: vdu_sprite_select
042492             0179*  vdu_sprite_move_abs168:
042492             0180*  ; populate in the reverse of normal to keep the
042492             0181*  ; inputs from stomping on each other
042492 ED 53 B1 24 0182*      ld (@ypos-1),de
       04          
042497 ED 43 AF 24 0183*      ld (@xpos-1),bc
       04          
04249C 3E 0D       0184*      ld a,13       ; restore the final byte of the command
04249E 32 AF 24 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
0424A2 21 AD 24 04 0186*      ld hl,@cmd
0424A6 01 07 00 00 0187*      ld bc,@end-@cmd
0424AA 5B DF       0188*      rst.lil $18
0424AC C9          0189*      ret
0424AD 17 1B 0D    0190*  @cmd:  db 23,27,13
0424B0 00 00       0191*  @xpos: dw 0x0000
0424B2 00 00       0192*  @ypos: dw 0x0000
0424B4             0193*  @end:  ; no padding required b/c we shifted de right
0424B4             0194*  
0424B4             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0424B4             0196*  ; USING 16.8 FIXED POINT COORDINATES
0424B4             0197*  ; inputs: ub.c is dx, ud.e is dy
0424B4             0198*  ;   the fractional portiion of the inputs are truncated
0424B4             0199*  ;   leaving only the 16-bit integer portion
0424B4             0200*  ; prerequisites: vdu_sprite_select
0424B4             0201*  vdu_sprite_move_rel168:
0424B4             0202*  ; populate in the reverse of normal to keep the
0424B4             0203*  ; inputs from stomping on each other
0424B4 ED 53 D3 24 0204*      ld (@dy-1),de
       04          
0424B9 ED 43 D1 24 0205*      ld (@dx-1),bc
       04          
0424BE 3E 0E       0206*      ld a,14       ; restore the final byte of the command
0424C0 32 D1 24 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
0424C4 21 CF 24 04 0208*      ld hl,@cmd
0424C8 01 07 00 00 0209*      ld bc,@end-@cmd
0424CC 5B DF       0210*      rst.lil $18
0424CE C9          0211*      ret
0424CF 17 1B 0E    0212*  @cmd:  db 23,27,14
0424D2 00 00       0213*  @dx: dw 0x0000
0424D4 00 00       0214*  @dy: dw 0x0000
0424D6             0215*  @end:  ; no padding required b/c we shifted de right
0424D6             0216*  
0424D6             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
0424D6             0218*  ; inputs: none
0424D6             0219*  vdu_sprite_update:
0424D6 21 E1 24 04 0220*      ld hl,@cmd
0424DA 01 03 00 00 0221*      ld bc,@end-@cmd
0424DE 5B DF       0222*      rst.lil $18
0424E0 C9          0223*      ret
0424E1 17 1B 0F    0224*  @cmd: db 23,27,15
0424E4             0225*  @end:
0424E4             0226*  
0424E4             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0424E4             0228*  ; inputs: none
0424E4             0229*  vdu_sprite_bmp_reset:
0424E4 21 EF 24 04 0230*      ld hl,@cmd
0424E8 01 03 00 00 0231*      ld bc,@end-@cmd
0424EC 5B DF       0232*      rst.lil $18
0424EE C9          0233*      ret
0424EF 17 1B 10    0234*  @cmd: db 23,27,16
0424F2             0235*  @end:
0424F2             0236*  
0424F2             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0424F2             0238*  ; inputs: none
0424F2             0239*  vdu_sprite_reset:
0424F2 21 FD 24 04 0240*      ld hl,@cmd
0424F6 01 03 00 00 0241*      ld bc,@end-@cmd
0424FA 5B DF       0242*      rst.lil $18
0424FC C9          0243*      ret
0424FD 17 1B 11    0244*  @cmd: db 23,27,17
042500             0245*  @end:
042500             0246*  
042500             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042500             0248*  ; inputs: a is the GCOL paint mode
042500             0249*  ; prerequisites: vdu_sprite_select
042500             0250*  vdu_sprite_set_gcol:
042500 32 12 25 04 0251*      ld (@mode),a
042504 21 0F 25 04 0252*      ld hl,@cmd
042508 01 04 00 00 0253*      ld bc,@end-@cmd
04250C 5B DF       0254*      rst.lil $18
04250E C9          0255*      ret
04250F 17 1B 12    0256*  @cmd:  db 23,27,18
042512 00          0257*  @mode: db 0x00
042513             0258*  @end:
042513             0259*  
042513             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
042513             0261*  ; inputs: hl=bufferId
042513             0262*  ; prerequisites: vdu_sprite_select
042513             0263*  vdu_sprite_add_buff:
042513 22 25 25 04 0264*      ld (@bufferId),hl
042517 21 22 25 04 0265*      ld hl,@cmd
04251B 01 05 00 00 0266*      ld bc,@end-@cmd
04251F 5B DF       0267*      rst.lil $18
042521 C9          0268*      ret
042522 17 1B 26    0269*  @cmd:      db 23,27,0x26
042525 00 00       0270*  @bufferId: dw 0x0000
042527 00          0271*  @end:      db 0x00 ; padding
042528             0057   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
042528             0058   	include "maths.inc"
042528             0001*  ; test the sign of HL
042528             0002*  ; inputs: HL obviously
042528             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
042528             0004*  ; destroys: flags
042528             0005*      MACRO sign_hlu
042528             0006*          add hl,de
042528             0007*          or a
042528             0008*          sbc hl,de
042528             0009*      ENDMACRO
042528             0010*  
042528             0011*  
042528             0012*  ;------------------------------------------------------------------------
042528             0013*  ; Scratch area for calculations
042528             0014*  ;------------------------------------------------------------------------
042528 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
04252B 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
04252E             0017*  
04252E             0018*  ; absolute value of hlu
04252E             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
04252E             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
04252E             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
04252E             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
04252E             0023*  ; destroys: a
04252E             0024*  hlu_abs:
04252E 19          0025*      add hl,de
04252F B7          0026*      or a
042530 ED 52       0027*      sbc hl,de
042532 FA 37 25 04 0028*      jp m,@is_neg
042536 C9          0029*      ret         ; hlu is positive or zero so we're done
042537             0030*  @is_neg:
042537 F5          0031*      push af     ; otherwise, save current flags for return
042538 CD 3E 25 04 0032*      call neg_hlu ; negate hlu
04253C F1          0033*      pop af      ; get back flags
04253D C9          0034*      ret
04253E             0035*  
04253E             0036*  ; flip the sign of hlu
04253E             0037*  ; inputs: hlu
04253E             0038*  ; returns: 0-hlu, flags set appropriately for the result:
04253E             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
04253E             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
04253E             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
04253E             0042*  ; destroys a
04253E             0043*  neg_hlu:
04253E D5          0044*      push de     ; save de
04253F EB          0045*      ex de,hl    ; put hl into de
042540 21 00 00 00 0046*      ld hl,0     ; clear hl
042544 AF          0047*      xor a       ; clear carry
042545 ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
042547 D1          0049*      pop de      ; get de back
042548 C9          0050*      ret         ; easy peasy
042549             0051*  
042549             0052*  ;------------------------------------------------------------------------
042549             0053*  ; divide hlu by 2, inspired by above
042549             0054*  ;------------------------------------------------------------------------
042549             0055*  hlu_div2:
042549 22 28 25 04 0056*  	ld		(scratch1),hl
04254D 21 2A 25 04 0057*  	ld		hl,scratch1+2
042551 CB 1E       0058*  	rr		(hl)
042553 2B          0059*  	dec		hl
042554 CB 1E       0060*  	rr		(hl)
042556 2B          0061*  	dec		hl
042557 CB 1E       0062*  	rr		(hl)
042559 23          0063*  	inc		hl
04255A 23          0064*  	inc		hl
04255B 2A 28 25 04 0065*      ld hl,(scratch1)
04255F C9          0066*      ret
042560             0067*  
042560             0068*  ; this is my little hack to divide by 16
042560             0069*  hlu_div16:
042560 AF          0070*      xor a
042561 29          0071*      add hl,hl
042562 17          0072*      rla
042563 29          0073*      add hl,hl
042564 17          0074*      rla
042565 29          0075*      add hl,hl
042566 17          0076*      rla
042567 29          0077*      add hl,hl
042568 17          0078*      rla
042569 22 76 25 04 0079*      ld (@scratch),hl
04256D 32 79 25 04 0080*      ld (@scratch+3),a
042571 2A 77 25 04 0081*      ld hl,(@scratch+1)
042575 C9          0082*      ret
042576             0083*  @scratch: ds 4
04257A             0084*  
04257A             0085*  ; hlu signed division by 256
04257A             0086*  ; returns: hlu / 256
04257A             0087*  ; destroys: af
04257A             0088*  hlu_sdiv256:
04257A AF          0089*      xor a ; assume hl is positive
04257B 22 91 25 04 0090*      ld (@buffer),hl
04257F             0091*      sign_hlu
04257F 19          0001*M         add hl,de
042580 B7          0002*M         or a
042581 ED 52       0003*M         sbc hl,de
042583 F2 88 25 04 0092*      jp p,@hl_pos
042587 3D          0093*      dec a
042588             0094*  @hl_pos:
042588 32 94 25 04 0095*      ld (@buffer+3),a
04258C 2A 92 25 04 0096*      ld hl,(@buffer+1)
042590 C9          0097*      ret
042591             0098*  @buffer: ds 4
042595             0099*  
042595             0100*  ; hlu 1 byte right shift, unsigned
042595             0101*  ; returns: hlu / 256, fractional portion in a
042595             0102*  ; destroys: af
042595             0103*  hlu_udiv256:
042595 AF          0104*  	xor a
042596 32 A7 25 04 0105*  	ld (@buffer+3),a
04259A 7D          0106*  	ld a,l ; save the fractional portion
04259B 22 A4 25 04 0107*  	ld (@buffer),hl
04259F 2A A5 25 04 0108*  	ld hl,(@buffer+1)
0425A3 C9          0109*  	ret
0425A4             0110*  @buffer: ds 4
0425A8             0111*  
0425A8             0112*      MACRO hlu_mul256
0425A8             0113*          add hl,hl ; * 2
0425A8             0114*          add hl,hl ; * 4
0425A8             0115*          add hl,hl ; * 8
0425A8             0116*          add hl,hl ; * 16
0425A8             0117*          add hl,hl ; * 32
0425A8             0118*          add hl,hl ; * 64
0425A8             0119*          add hl,hl ; * 128
0425A8             0120*          add hl,hl ; * 256
0425A8             0121*      ENDMACRO
0425A8             0122*  
0425A8             0123*  ; compute the modulo of hlu by deu
0425A8             0124*  ; outputs: hlu = hlu % deu
0425A8             0125*  ; destroys: f, hl
0425A8             0126*  hlu_mod:
0425A8 B7          0127*  	or a ; clear carry
0425A9             0128*  @loop:
0425A9 ED 52       0129*      sbc hl,de
0425AB DA B3 25 04 0130*      jp c, @end
0425AF C3 A9 25 04 0131*      jp @loop
0425B3             0132*  @end:
0425B3 19          0133*      add hl,de
0425B4 C9          0134*  	ret
0425B5             0135*  
0425B5             0136*  
0425B5 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
0425B9 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
0425BD             0139*  
0425BD             0140*  ; set bcd values in a scratch memory address from registers bcde
0425BD             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
0425BD             0142*  ; destroys ; hl
0425BD             0143*  set_bcd:
0425BD 73          0144*      ld (hl),e
0425BE 23          0145*      inc hl
0425BF 72          0146*      ld (hl),d
0425C0 23          0147*      inc hl
0425C1 71          0148*      ld (hl),c
0425C2 23          0149*      inc hl
0425C3 70          0150*      ld (hl),b
0425C4 C9          0151*      ret
0425C5             0152*  
0425C5             0153*  ; load bcd values from a scratch memory address to bcde
0425C5             0154*  ; input: hl; scratch address
0425C5             0155*  ; output: bcde; 8-place bcd number
0425C5             0156*  ; destroys: hl
0425C5             0157*  get_bcd:
0425C5 5E          0158*      ld e,(hl)
0425C6 23          0159*      inc hl
0425C7 56          0160*      ld d,(hl)
0425C8 23          0161*      inc hl
0425C9 4E          0162*      ld c,(hl)
0425CA 23          0163*      inc hl
0425CB 46          0164*      ld b,(hl)
0425CC C9          0165*      ret
0425CD             0166*  
0425CD             0167*  ; BCD addition
0425CD             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425CD             0169*  ;       a is the number of bytes holding each number (number of places/2)
0425CD             0170*  ; outputs: (hl) + (de) --> (hl)
0425CD             0171*  ; destroys: a,b,de,hl
0425CD             0172*  add_bcd:
0425CD 47          0173*      ld b,a ; loop counter
0425CE AF          0174*      xor a ; reset a, clear carry flag
0425CF             0175*  adcec:
0425CF 1A          0176*      ld a,(de) ; addend to acc
0425D0 8E          0177*      adc a,(hl) ; add (hl) to acc
0425D1 27          0178*      daa ; adjust result to bcd
0425D2 77          0179*      ld (hl),a ; store result
0425D3 23          0180*      inc hl ; advance memory pointers
0425D4 13          0181*      inc de
0425D5 10 F8       0182*      djnz adcec ; loop until b == 0
0425D7 C9          0183*      ret
0425D8             0184*  
0425D8             0185*  ; BCD subtraction
0425D8             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425D8             0187*  ;       a is the number of bytes holding each number (number of places/2)
0425D8             0188*  ; outputs: (hl) - (de) --> (hl)
0425D8             0189*  ; destroys: a,b,de,hl
0425D8             0190*  sub_bcd:
0425D8 47          0191*      ld b,a ; loop counter
0425D9 AF          0192*      xor a ; reset a,clear carry flag
0425DA             0193*  subdec:
0425DA 1A          0194*      ld a,(de) ; subtrahend to acc
0425DB 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
0425DC 27          0196*      daa ; adjust result to bcd
0425DD 77          0197*      ld (hl),a ; store result
0425DE 23          0198*      inc hl ; advance memory pointers
0425DF 13          0199*      inc de
0425E0 10 F8       0200*      djnz subdec ; loop until b == 0
0425E2 C9          0201*      ret
0425E3             0202*  
0425E3             0203*  ; http://www.z80.info/pseudo-random.txt
0425E3             0204*  rand_8:
0425E3 C5          0205*      push bc
0425E4 3A F7 25 04 0206*      ld a,(r_seed)
0425E8 4F          0207*      ld c,a
0425E9             0208*  
0425E9 0F          0209*      rrca ; multiply by 32
0425EA 0F          0210*      rrca
0425EB 0F          0211*      rrca
0425EC EE 1F       0212*      xor 0x1f
0425EE             0213*  
0425EE 81          0214*      add a,c
0425EF DE FF       0215*      sbc a,255 ; carry
0425F1             0216*  
0425F1 32 F7 25 04 0217*      ld (r_seed),a
0425F5 C1          0218*      pop bc
0425F6 C9          0219*      ret
0425F7 50          0220*  r_seed: defb $50
0425F8             0059   	include "trig24fast.inc"
0425F8             0001*  
0425F8             0002*  ; convert signed angles from a 360 to 256 degree circle
0425F8             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0425F8             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0425F8             0005*  ; destroys: TODO
0425F8             0006*  deg_360_to_256:
0425F8 D5          0007*  	push de ; preserve de
0425F9             0008*  ; make angle positive and store sign flag
0425F9 CD 2E 25 04 0009*  	call hlu_abs
0425FD F5          0010*  	push af
0425FE             0011*  ; multiply by 256 first to keep precision
0425FE             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0425FE 29          0001*M         add hl,hl ; * 2
0425FF 29          0002*M         add hl,hl ; * 4
042600 29          0003*M         add hl,hl ; * 8
042601 29          0004*M         add hl,hl ; * 16
042602 29          0005*M         add hl,hl ; * 32
042603 29          0006*M         add hl,hl ; * 64
042604 29          0007*M         add hl,hl ; * 128
042605 29          0008*M         add hl,hl ; * 256
042606             0013*  ; divide uh.l by 360
042606 11 68 01 00 0014*  	ld de,360
04260A CD 9E 30 04 0015*  	call udiv24 ; ud.e = degrees / 360
04260E EB          0016*  	ex de,hl    ; uh.l = degrees / 360
04260F             0017*  ; restore sign flag and adjust output accordingly
04260F F1          0018*  	pop af
042610 F2 18 26 04 0019*  	jp p,@pos ; positive number
042614 CD 3E 25 04 0020*  	call neg_hlu
042618             0021*  @pos:
042618             0022*  ; restore de and return uh.l as the result
042618 D1          0023*  	pop de
042619 C9          0024*  	ret
04261A             0025*  
04261A             0026*  ; fixed 16.8 routine
04261A             0027*  ; cos(uh.l) --> uh.l
04261A             0028*  ; destroys: f, hl
04261A             0029*  cos168:
04261A D5          0030*      push de ; preserve de
04261B             0031*  ; for cos we simply increment the angle by 90 degrees
04261B             0032*  ; or 0x004000 in 16.8 degrees256
04261B             0033*  ; which makes it a sin problem
04261B 11 00 40 00 0034*      ld de,0x004000
04261F 19          0035*      add hl,de ; modulo 256 happens below
042620 D1          0036*      pop de ; restore de
042621             0037*  ; fall through to sin168
042621             0038*  
042621             0039*  ; ---------------------
042621             0040*  ; fixed 16.8 routine
042621             0041*  ; sin(uh.l) --> uh.l
042621             0042*  ; destroys: f, hl
042621             0043*  sin168:
042621 D5          0044*  	push de
042622             0045*  ; handle negative angles appropriately
042622 CD 2E 25 04 0046*  	call hlu_abs
042626 F2 2F 26 04 0047*  	jp p,@F
04262A 11 00 00 FF 0048*  	ld de,-256*256
04262E 19          0049*  	add hl,de
04262F             0050*  @@:
04262F 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
042631 ED 6C       0052*      mlt hl
042633 11 69 28 04 0053*      ld de,sin_lut_168 ; grab the lut address
042637 19          0054*      add hl,de ; bump hl by the index
042638 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
04263A D1          0056*      pop de
04263B C9          0057*      ret
04263C             0058*  
04263C             0059*  ; 16.8 fixed inputs / outputs
04263C             0060*  ; takes: uh.l as angle in degrees 256
04263C             0061*  ;        ud.e as radius
04263C             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
04263C             0063*  ;        displacements from origin (0,0)
04263C             0064*  ; destroys: everything except indexes
04263C             0065*  polar_to_cartesian:
04263C             0066*  ; back up input parameters
04263C 22 6B 26 04 0067*      ld (@angle), hl
042640 ED 53 6E 26 0068*      ld (@radius), de
       04          
042645             0069*  ; compute dx = sin(uh.l) * ud.e
042645 CD 21 26 04 0070*      call sin168 ; uh.l = sin(uh.l)
042649 ED 5B 6E 26 0071*  	ld de,(@radius)
       04          
04264E CD 13 30 04 0072*  	call smul168 ; uh.l = dx
042652 E5          0073*      push hl
042653             0074*  ; compute dy = -cos(uh.l) * ud.e
042653 2A 6B 26 04 0075*      ld hl,(@angle)
042657 CD 1A 26 04 0076*      call cos168 ; uh.l = cos(uh.l)
04265B ED 5B 6E 26 0077*      ld de,(@radius)
       04          
042660 CD 13 30 04 0078*      call smul168    ; uh.l = dy
042664 CD 3E 25 04 0079*      call neg_hlu ; invert dy for screen coords convention
042668 EB          0080*      ex de,hl       ; de = dy for output
042669 C1          0081*      pop bc          ; bc = dx for output
04266A             0082*  ; and out
04266A C9          0083*      ret
04266B             0084*  @angle: ds 3
04266E             0085*  @radius: ds 3
042671             0086*  
042671             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042671             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042671             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042671             0090*  ;         also populates scratch locations dx168 and dy168
042671             0091*  ; destroys: a,hl,bc,de
042671             0092*  dxy168:
042671             0093*  ; compute dx = x1-x0
042671 AF          0094*      xor a ; clear carry
042672 DD E5       0095*      push ix ; move ix to hl via the stack
042674 E1          0096*      pop hl ; hl = x1
042675 ED 42       0097*      sbc hl,bc ; hl = dx
042677 22 8C 26 04 0098*      ld (dx168),hl ; dx to scratch
04267B             0099*  ; compute dy = y1-y0
04267B AF          0100*      xor a ; clear carry
04267C FD E5       0101*      push iy ; move iy to hl via the stack
04267E E1          0102*      pop hl ; hl = y1
04267F ED 52       0103*      sbc hl,de ; hl = dy
042681 22 92 26 04 0104*      ld (dy168),hl ; dy to scratch
042685             0105*  ; populate output registers and return
042685 EB          0106*      ex de,hl        ; ud.e = dy
042686 ED 4B 8C 26 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
04268B C9          0108*      ret
04268C 00 00 00 00 0109*  dx168: blkb 6,0
       00 00       
042692 00 00 00 00 0110*  dy168: blkb 6,0
       00 00       
042698             0111*  
042698             0112*  ; compute the euclidian distance between two cartesian coordinates
042698             0113*  ; using the formula d = sqrt(dx^2+dy^2
042698             0114*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042698             0115*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042698             0116*  ; output; uh.l is the 16.8 fixed format distance
042698             0117*  ;       dx168/y are the 16.8 fixed format dx and dy
042698             0118*  ; destroys: a,hl,bc,de
042698             0119*  distance168:
042698 CD 71 26 04 0120*  	call dxy168 ; ub.c = dx, ud.e = dy
04269C             0121*  ; compute dy^2
04269C EB          0122*  	ex de,hl
04269D CD 2E 25 04 0123*  	call hlu_abs
0426A1 E5          0124*  	push hl
0426A2 D1          0125*  	pop de
0426A3 CD 0B 30 04 0126*  	call umul168 ; hl = dy^2
0426A7 E5          0127*  	push hl ; save dy^2
0426A8             0128*  ; compute dx^2
0426A8 2A 8C 26 04 0129*  	ld hl,(dx168)
0426AC CD 2E 25 04 0130*  	call hlu_abs
0426B0 E5          0131*  	push hl
0426B1 D1          0132*  	pop de
0426B2 CD 0B 30 04 0133*  	call umul168 ; hl = dx^2
0426B6             0134*  ; add dx^2 and dy^2
0426B6 D1          0135*  	pop de ; de = dy^2
0426B7 19          0136*  	add hl,de ; hl = dx^2 + dy^2
0426B8             0137*  ; compute the square root
0426B8 CD 7E 27 04 0138*  	call sqrt168
0426BC C9          0139*  	ret
0426BD             0140*  
0426BD             0141*  ; atan2_(ub.c,ud.e) --> uh.l
0426BD             0142*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0426BD             0143*  ;   whether inputs are integers or fractional doesn't matter
0426BD             0144*  ;   so long as the sign bit of the upper byte is correct
0426BD             0145*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0426BD             0146*  ; angles are COMPASS HEADINGS based on
0426BD             0147*  ; screen coordinate conventions,where the y axis is flipped
0426BD             0148*  ; #E0 315      0       45 #20
0426BD             0149*  ;        -x,-y | +x,-y
0426BD             0150*  ; #C0 270------+------ 90 #40
0426BD             0151*  ;        -x,+y | +x,+y
0426BD             0152*  ; #A0 225   180 #80   135 #60
0426BD             0153*  atan2_168fast:
0426BD             0154*  ; get signs and make everything positive
0426BD             0155*  ; get abs(x) and store its original sign
0426BD C5          0156*      push bc
0426BE E1          0157*      pop hl
0426BF CD 2E 25 04 0158*      call hlu_abs ; if x was negative this also sets the sign flag
0426C3 E5          0159*      push hl ; store abs(x)
0426C4 C1          0160*      pop bc ; bc = abs(x)
0426C5 F5          0161*      push af ; store sign of x
0426C6             0162*  ; get abs(y) and store its original sign
0426C6 EB          0163*      ex de,hl ; hl = y
0426C7 CD 2E 25 04 0164*      call hlu_abs ; if y was negative this also sets the sign flag
0426CB EB          0165*      ex de,hl ; de = abs(y)
0426CC F5          0166*      push af ; store sign of y
0426CD             0167*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0426CD             0168*  ; this ensures that our lookup value is between 0 and 1 inclusive
0426CD AF          0169*      xor a ; clear the carry flag
0426CE D5          0170*      push de
0426CF E1          0171*      pop hl
0426D0 ED 42       0172*      sbc hl,bc
0426D2 F5          0173*      push af ; save sign of de - bc
0426D3 F2 DC 26 04 0174*      jp p,@1 ; bc <= de, so we skip ahead
0426D7             0175*  ; otherwise we swap bc and de
0426D7 C5          0176*      push bc
0426D8 E1          0177*      pop hl
0426D9 EB          0178*      ex de,hl
0426DA E5          0179*      push hl
0426DB C1          0180*      pop bc
0426DC             0181*  @1:
0426DC             0182*  ; now we're ready to snag our preliminary result
0426DC C5          0183*  	push bc
0426DD E1          0184*  	pop hl
0426DE CD 4C 27 04 0185*      call atan_168fast ; uh.l comes back with prelim result
0426E2             0186*  ; now we adjust uh.l based on sign of de - bc
0426E2 F1          0187*      pop af
0426E3 F2 EF 26 04 0188*      jp p,@2 ; bc <= de,so we skip ahead
0426E7 EB          0189*      ex de,hl
0426E8 21 00 40 00 0190*      ld hl,0x004000 ; 90 degrees
0426EC AF          0191*      xor a ; clear the carry flag
0426ED ED 52       0192*      sbc hl,de ; subtract result from 90 degrees
0426EF             0193*  @2:
0426EF             0194*  ; now the fun part of adjusting the result
0426EF             0195*  ; based on which quadrant (x,y) is in
0426EF             0196*  ; #E0 315      0       45 #20
0426EF             0197*  ;        -x,-y | +x,-y
0426EF             0198*  ; #C0 270------+------ 90 #40
0426EF             0199*  ;        -x,+y | +x,+y
0426EF             0200*  ; #A0 225   180 #80   135 #60
0426EF F1          0201*      pop af ; sign of y
0426F0 CA 2D 27 04 0202*      jp z,@y_zero
0426F4 F2 0D 27 04 0203*      jp p,@y_pos
0426F8             0204*  ; y neg,check x
0426F8 F1          0205*      pop af ; sign of x
0426F9 CA 07 27 04 0206*      jp z,@y_neg_x_zero
0426FD F2 0C 27 04 0207*      jp p,@y_neg_x_pos
042701             0208*  ; y neg,x neg
042701             0209*  ; angle is 270-360
042701             0210*  ; negating the intermediate does the trick
042701 CD 3E 25 04 0211*      call neg_hlu
042705 18 31       0212*      jr @zero_hlu
042707             0213*  
042707             0214*  @y_neg_x_zero:
042707             0215*  ; y neg,x zero
042707             0216*  ; angle is 0
042707 21 00 00 00 0217*      ld hl,0
04270B C9          0218*      ret
04270C             0219*  @y_neg_x_pos:
04270C             0220*  ; y neg,x pos
04270C             0221*  ; angle is 0 to 90
04270C             0222*  ; so we're good
04270C C9          0223*      ret
04270D             0224*  
04270D             0225*  @y_pos:
04270D F1          0226*      pop af ; sign of x
04270E CA 1D 27 04 0227*      jp z,@y_pos_x_zero
042712 F2 22 27 04 0228*      jp p,@y_pos_x_pos
042716             0229*  ; y pos,x neg
042716             0230*  ; angle is 180-270
042716             0231*  ; so we add 180 to intermediate
042716 11 00 80 00 0232*      ld de,0x008000
04271A 19          0233*      add hl,de
04271B 18 1B       0234*      jr @zero_hlu
04271D             0235*  @y_pos_x_zero:
04271D             0236*  ; y pos,x zero
04271D             0237*  ; angle is 180
04271D 21 00 80 00 0238*      ld hl,0x008000
042721 C9          0239*      ret
042722             0240*  @y_pos_x_pos:
042722             0241*  ; y pos,x pos
042722             0242*  ; angle is 90-180
042722             0243*  ; neg the intermediate and add 180 degrees
042722 CD 3E 25 04 0244*      call neg_hlu
042726 11 00 80 00 0245*      ld de,0x008000
04272A 19          0246*      add hl,de
04272B 18 0B       0247*      jr @zero_hlu
04272D             0248*  
04272D             0249*  @y_zero:
04272D F1          0250*      pop af ; sign of x
04272E FA 33 27 04 0251*      jp m,@y_zero_x_neg
042732             0252*  ; y zero,x pos
042732             0253*  ; angle is 90,nothing to do
042732 C9          0254*      ret
042733             0255*  @y_zero_x_neg:
042733             0256*  ; y zero ,x neg
042733             0257*  ; angle is 270
042733 21 00 C0 00 0258*      ld hl,0x00C000
042737 C9          0259*      ret
042738             0260*  @zero_hlu:
042738 AF          0261*      xor a
042739 22 46 27 04 0262*      ld (@scratch),hl
04273D 32 48 27 04 0263*      ld (@scratch+2),a
042741 2A 46 27 04 0264*      ld hl,(@scratch)
042745 C9          0265*      ret
042746             0266*  @scratch: ds 6
04274C             0267*  
04274C             0268*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04274C             0269*  ; output: uh.l is the 16.8 fixed format angle
04274C             0270*  ; destroys: a,hl,bc,de
04274C             0271*  ; the following note was written by github copilot:
04274C             0272*  ; note: this routine is a bit of a hack
04274C             0273*  ;      but it works
04274C             0274*  ;      and it's fast
04274C             0275*  ;      and it's small
04274C             0276*  ;      and it's accurate
04274C             0277*  ;      and it's easy to understand
04274C             0278*  ;      and it's easy to modify
04274C             0279*  ;      and it's easy to use
04274C             0280*  ;      and it's easy to remember
04274C             0281*  ;      and it's easy to love
04274C             0282*  ;      and it's easy to hate
04274C             0283*  ;      and it's easy to ignore
04274C             0284*  ;      and it's easy to forget
04274C             0285*  ;      and it's easy to remember
04274C             0286*  ;      and it's easy to forget
04274C             0287*  ;      and it's easy to remember
04274C             0288*  ;      (ok the bot is stuck in a loop)
04274C             0289*  ; REAL NOTE: only works for angles from 0 to 45 degrees
04274C             0290*  ;   use atan2__168 (which calls this proc) to handle the full 360 degrees
04274C             0291*  atan_168fast:
04274C             0292*  ; because we use compass headings instead of geometric angles
04274C             0293*  ; we compute dx/dy which is 1/tan(theta) in the maths world
04274C             0294*  ; we can do faster unsigned division here because we know dx and dy are positive
04274C CD 36 30 04 0295*  	call udiv168 ; ud.e = dx/dy
042750 EB          0296*  	ex de,hl ; uh.l = dx/dy
042751             0297*  ; test uh.l for 0
042751 19          0298*      add hl,de
042752 B7          0299*      or a
042753 ED 52       0300*      sbc hl,de
042755 28 22       0301*      jr z,@is_zero
042757             0302*  ; test uh.l for 1
042757 AF          0303*      xor a ; clear carry
042758 EB          0304*      ex de,hl
042759 21 00 01 00 0305*      ld hl,0x000100 ; 1 in 16.8 fixed format
04275D ED 52       0306*      sbc hl,de
04275F 28 13       0307*      jr z,@is_45
042761 EB          0308*  	ex de,hl
042762             0309*  ; no special cases so we move on
042762             0310*  ; l contains the fractional portion of tan(uh.l)
042762             0311*  ; we multiply it by three to get our lookup table index
042762 26 03       0312*      ld h,3
042764 ED 6C       0313*      mlt hl ; gosh that is handy
042766 11 00 00 00 0314*      ld de,0 ; clear deu
04276A 54          0315*      ld d,h ; copy hl to de
04276B 5D          0316*      ld e,l ; de contains our index
04276C 21 6C 2B 04 0317*      ld hl,atan_lut_168 ; grab the lut address
042770 19          0318*      add hl,de ; bump hl by the index
042771 ED 27       0319*      ld hl,(hl) ; don't try this on a z80!
042773 C9          0320*      ret ; and out
042774             0321*  @is_45:
042774 21 00 20 00 0322*      ld hl,0x002000 ; 45 degrees decimal
042778 C9          0323*      ret
042779             0324*  ; for the case tan(0)
042779             0325*  @is_zero:
042779 21 00 00 00 0326*      ld hl,0x000000
04277D C9          0327*      ret
04277E             0328*  
04277E             0329*  ; Expects  ADL mode
04277E             0330*  ; Inputs:  UH.L
04277E             0331*  ; Outputs: UH.L is the 16.8 square root
04277E             0332*  ;          UD.E is the difference inputHL-DE^2
04277E             0333*  ;          c flag reset
04277E             0334*  sqrt168:
04277E CD 88 27 04 0335*      call sqrt24
042782 EB          0336*      ex de,hl
042783 29          0337*      add hl,hl
042784 29          0338*      add hl,hl
042785 29          0339*      add hl,hl
042786 29          0340*      add hl,hl
042787 C9          0341*      ret
042788             0342*  
042788             0343*  ; Expects  ADL mode
042788             0344*  ; Inputs:  HL
042788             0345*  ; Outputs: DE is the integer square root
042788             0346*  ;          HL is the difference inputHL-DE^2
042788             0347*  ;          c flag reset
042788             0348*  sqrt24:
042788 AF          0349*      xor a
042789 45          0350*      ld b,l
04278A C5          0351*      push bc
04278B 47          0352*      ld b,a
04278C 57          0353*      ld d,a
04278D 4F          0354*      ld c,a
04278E 6F          0355*      ld l,a
04278F 5F          0356*      ld e,a
042790             0357*  
042790             0358*      ;Iteration 1
042790 29          0359*      add hl,hl
042791 CB 11       0360*      rl c
042793 29          0361*      add hl,hl
042794 CB 11       0362*      rl c
042796 91          0363*      sub c
042797 30 04       0364*      jr nc,$+6
042799 1C          0365*      inc e
04279A 1C          0366*      inc e
04279B 2F          0367*      cpl
04279C 4F          0368*      ld c,a
04279D             0369*  
04279D             0370*      ;Iteration 2
04279D 29          0371*      add hl,hl
04279E CB 11       0372*      rl c
0427A0 29          0373*      add hl,hl
0427A1 CB 11       0374*      rl c
0427A3 CB 13       0375*      rl e
0427A5 7B          0376*      ld a,e
0427A6 91          0377*      sub c
0427A7 30 04       0378*      jr nc,$+6
0427A9 1C          0379*      inc e
0427AA 1C          0380*      inc e
0427AB 2F          0381*      cpl
0427AC 4F          0382*      ld c,a
0427AD             0383*  
0427AD             0384*      ;Iteration 3
0427AD 29          0385*      add hl,hl
0427AE CB 11       0386*      rl c
0427B0 29          0387*      add hl,hl
0427B1 CB 11       0388*      rl c
0427B3 CB 13       0389*      rl e
0427B5 7B          0390*      ld a,e
0427B6 91          0391*      sub c
0427B7 30 04       0392*      jr nc,$+6
0427B9 1C          0393*      inc e
0427BA 1C          0394*      inc e
0427BB 2F          0395*      cpl
0427BC 4F          0396*      ld c,a
0427BD             0397*  
0427BD             0398*      ;Iteration 4
0427BD 29          0399*      add hl,hl
0427BE CB 11       0400*      rl c
0427C0 29          0401*      add hl,hl
0427C1 CB 11       0402*      rl c
0427C3 CB 13       0403*      rl e
0427C5 7B          0404*      ld a,e
0427C6 91          0405*      sub c
0427C7 30 04       0406*      jr nc,$+6
0427C9 1C          0407*      inc e
0427CA 1C          0408*      inc e
0427CB 2F          0409*      cpl
0427CC 4F          0410*      ld c,a
0427CD             0411*  
0427CD             0412*      ;Iteration 5
0427CD 29          0413*      add hl,hl
0427CE CB 11       0414*      rl c
0427D0 29          0415*      add hl,hl
0427D1 CB 11       0416*      rl c
0427D3 CB 13       0417*      rl e
0427D5 7B          0418*      ld a,e
0427D6 91          0419*      sub c
0427D7 30 04       0420*      jr nc,$+6
0427D9 1C          0421*      inc e
0427DA 1C          0422*      inc e
0427DB 2F          0423*      cpl
0427DC 4F          0424*      ld c,a
0427DD             0425*  
0427DD             0426*      ;Iteration 6
0427DD 29          0427*      add hl,hl
0427DE CB 11       0428*      rl c
0427E0 29          0429*      add hl,hl
0427E1 CB 11       0430*      rl c
0427E3 CB 13       0431*      rl e
0427E5 7B          0432*      ld a,e
0427E6 91          0433*      sub c
0427E7 30 04       0434*      jr nc,$+6
0427E9 1C          0435*      inc e
0427EA 1C          0436*      inc e
0427EB 2F          0437*      cpl
0427EC 4F          0438*      ld c,a
0427ED             0439*  
0427ED             0440*      ;Iteration 7
0427ED 29          0441*      add hl,hl
0427EE CB 11       0442*      rl c
0427F0 29          0443*      add hl,hl
0427F1 CB 11       0444*      rl c
0427F3 CB 10       0445*      rl b
0427F5 EB          0446*      ex de,hl
0427F6 29          0447*      add hl,hl
0427F7 E5          0448*      push hl
0427F8 ED 42       0449*      sbc hl,bc
0427FA 30 06       0450*      jr nc,$+8
0427FC 7C          0451*      ld a,h
0427FD 2F          0452*      cpl
0427FE 47          0453*      ld b,a
0427FF 7D          0454*      ld a,l
042800 2F          0455*      cpl
042801 4F          0456*      ld c,a
042802 E1          0457*      pop hl
042803 30 02       0458*      jr nc,$+4
042805 23          0459*      inc hl
042806 23          0460*      inc hl
042807 EB          0461*      ex de,hl
042808             0462*  
042808             0463*      ;Iteration 8
042808 29          0464*      add hl,hl
042809 69          0465*      ld l,c
04280A 60          0466*      ld h,b
04280B ED 6A       0467*      adc hl,hl
04280D ED 6A       0468*      adc hl,hl
04280F EB          0469*      ex de,hl
042810 29          0470*      add hl,hl
042811 ED 52       0471*      sbc hl,de
042813 19          0472*      add hl,de
042814 EB          0473*      ex de,hl
042815 30 04       0474*      jr nc,$+6
042817 ED 52       0475*      sbc hl,de
042819 13          0476*      inc de
04281A 13          0477*      inc de
04281B             0478*  
04281B             0479*      ;Iteration 9
04281B F1          0480*      pop af
04281C 17          0481*      rla
04281D ED 6A       0482*      adc hl,hl
04281F 17          0483*      rla
042820 ED 6A       0484*      adc hl,hl
042822 EB          0485*      ex de,hl
042823 29          0486*      add hl,hl
042824 ED 52       0487*      sbc hl,de
042826 19          0488*      add hl,de
042827 EB          0489*      ex de,hl
042828 30 04       0490*      jr nc,$+6
04282A ED 52       0491*      sbc hl,de
04282C 13          0492*      inc de
04282D 13          0493*      inc de
04282E             0494*  
04282E             0495*      ;Iteration 10
04282E 17          0496*      rla
04282F ED 6A       0497*      adc hl,hl
042831 17          0498*      rla
042832 ED 6A       0499*      adc hl,hl
042834 EB          0500*      ex de,hl
042835 29          0501*      add hl,hl
042836 ED 52       0502*      sbc hl,de
042838 19          0503*      add hl,de
042839 EB          0504*      ex de,hl
04283A 30 04       0505*      jr nc,$+6
04283C ED 52       0506*      sbc hl,de
04283E 13          0507*      inc de
04283F 13          0508*      inc de
042840             0509*  
042840             0510*      ;Iteration 11
042840 17          0511*      rla
042841 ED 6A       0512*      adc hl,hl
042843 17          0513*      rla
042844 ED 6A       0514*      adc hl,hl
042846 EB          0515*      ex de,hl
042847 29          0516*      add hl,hl
042848 ED 52       0517*      sbc hl,de
04284A 19          0518*      add hl,de
04284B EB          0519*      ex de,hl
04284C 30 04       0520*      jr nc,$+6
04284E ED 52       0521*      sbc hl,de
042850 13          0522*      inc de
042851 13          0523*      inc de
042852             0524*  
042852             0525*      ;Iteration 11
042852 17          0526*      rla
042853 ED 6A       0527*      adc hl,hl
042855 17          0528*      rla
042856 ED 6A       0529*      adc hl,hl
042858 EB          0530*      ex de,hl
042859 29          0531*      add hl,hl
04285A ED 52       0532*      sbc hl,de
04285C 19          0533*      add hl,de
04285D EB          0534*      ex de,hl
04285E 30 04       0535*      jr nc,$+6
042860 ED 52       0536*      sbc hl,de
042862 13          0537*      inc de
042863 13          0538*      inc de
042864             0539*  
042864 CB 1A       0540*      rr d
042866 CB 1B       0541*      rr e
042868 C9          0542*      ret
042869             0543*  
042869             0544*  sin_lut_168:
042869 00 00 00    0545*  	dl 0x000000 ; 0.000 00, 0.000
04286C 06 00 00    0546*  	dl 0x000006 ; 1.406 01, 0.025
04286F 0C 00 00    0547*  	dl 0x00000C ; 2.813 02, 0.049
042872 12 00 00    0548*  	dl 0x000012 ; 4.219 03, 0.074
042875 19 00 00    0549*  	dl 0x000019 ; 5.625 04, 0.098
042878 1F 00 00    0550*  	dl 0x00001F ; 7.031 05, 0.122
04287B 25 00 00    0551*  	dl 0x000025 ; 8.438 06, 0.147
04287E 2B 00 00    0552*  	dl 0x00002B ; 9.844 07, 0.171
042881 31 00 00    0553*  	dl 0x000031 ; 11.250 08, 0.195
042884 38 00 00    0554*  	dl 0x000038 ; 12.656 09, 0.219
042887 3E 00 00    0555*  	dl 0x00003E ; 14.063 0A, 0.243
04288A 44 00 00    0556*  	dl 0x000044 ; 15.469 0B, 0.267
04288D 4A 00 00    0557*  	dl 0x00004A ; 16.875 0C, 0.290
042890 50 00 00    0558*  	dl 0x000050 ; 18.281 0D, 0.314
042893 56 00 00    0559*  	dl 0x000056 ; 19.688 0E, 0.337
042896 5C 00 00    0560*  	dl 0x00005C ; 21.094 0F, 0.360
042899 61 00 00    0561*  	dl 0x000061 ; 22.500 10, 0.383
04289C 67 00 00    0562*  	dl 0x000067 ; 23.906 11, 0.405
04289F 6D 00 00    0563*  	dl 0x00006D ; 25.313 12, 0.428
0428A2 73 00 00    0564*  	dl 0x000073 ; 26.719 13, 0.450
0428A5 78 00 00    0565*  	dl 0x000078 ; 28.125 14, 0.471
0428A8 7E 00 00    0566*  	dl 0x00007E ; 29.531 15, 0.493
0428AB 83 00 00    0567*  	dl 0x000083 ; 30.938 16, 0.514
0428AE 88 00 00    0568*  	dl 0x000088 ; 32.344 17, 0.535
0428B1 8E 00 00    0569*  	dl 0x00008E ; 33.750 18, 0.556
0428B4 93 00 00    0570*  	dl 0x000093 ; 35.156 19, 0.576
0428B7 98 00 00    0571*  	dl 0x000098 ; 36.563 1A, 0.596
0428BA 9D 00 00    0572*  	dl 0x00009D ; 37.969 1B, 0.615
0428BD A2 00 00    0573*  	dl 0x0000A2 ; 39.375 1C, 0.634
0428C0 A7 00 00    0574*  	dl 0x0000A7 ; 40.781 1D, 0.653
0428C3 AB 00 00    0575*  	dl 0x0000AB ; 42.188 1E, 0.672
0428C6 B0 00 00    0576*  	dl 0x0000B0 ; 43.594 1F, 0.690
0428C9 B5 00 00    0577*  	dl 0x0000B5 ; 45.000 20, 0.707
0428CC B9 00 00    0578*  	dl 0x0000B9 ; 46.406 21, 0.724
0428CF BD 00 00    0579*  	dl 0x0000BD ; 47.813 22, 0.741
0428D2 C1 00 00    0580*  	dl 0x0000C1 ; 49.219 23, 0.757
0428D5 C5 00 00    0581*  	dl 0x0000C5 ; 50.625 24, 0.773
0428D8 C9 00 00    0582*  	dl 0x0000C9 ; 52.031 25, 0.788
0428DB CD 00 00    0583*  	dl 0x0000CD ; 53.438 26, 0.803
0428DE D1 00 00    0584*  	dl 0x0000D1 ; 54.844 27, 0.818
0428E1 D4 00 00    0585*  	dl 0x0000D4 ; 56.250 28, 0.831
0428E4 D8 00 00    0586*  	dl 0x0000D8 ; 57.656 29, 0.845
0428E7 DB 00 00    0587*  	dl 0x0000DB ; 59.063 2A, 0.858
0428EA DE 00 00    0588*  	dl 0x0000DE ; 60.469 2B, 0.870
0428ED E1 00 00    0589*  	dl 0x0000E1 ; 61.875 2C, 0.882
0428F0 E4 00 00    0590*  	dl 0x0000E4 ; 63.281 2D, 0.893
0428F3 E7 00 00    0591*  	dl 0x0000E7 ; 64.688 2E, 0.904
0428F6 EA 00 00    0592*  	dl 0x0000EA ; 66.094 2F, 0.914
0428F9 EC 00 00    0593*  	dl 0x0000EC ; 67.500 30, 0.924
0428FC EE 00 00    0594*  	dl 0x0000EE ; 68.906 31, 0.933
0428FF F1 00 00    0595*  	dl 0x0000F1 ; 70.313 32, 0.942
042902 F3 00 00    0596*  	dl 0x0000F3 ; 71.719 33, 0.950
042905 F4 00 00    0597*  	dl 0x0000F4 ; 73.125 34, 0.957
042908 F6 00 00    0598*  	dl 0x0000F6 ; 74.531 35, 0.964
04290B F8 00 00    0599*  	dl 0x0000F8 ; 75.938 36, 0.970
04290E F9 00 00    0600*  	dl 0x0000F9 ; 77.344 37, 0.976
042911 FB 00 00    0601*  	dl 0x0000FB ; 78.750 38, 0.981
042914 FC 00 00    0602*  	dl 0x0000FC ; 80.156 39, 0.985
042917 FD 00 00    0603*  	dl 0x0000FD ; 81.563 3A, 0.989
04291A FE 00 00    0604*  	dl 0x0000FE ; 82.969 3B, 0.992
04291D FE 00 00    0605*  	dl 0x0000FE ; 84.375 3C, 0.995
042920 FF 00 00    0606*  	dl 0x0000FF ; 85.781 3D, 0.997
042923 FF 00 00    0607*  	dl 0x0000FF ; 87.188 3E, 0.999
042926 FF 00 00    0608*  	dl 0x0000FF ; 88.594 3F, 1.000
042929 00 01 00    0609*  	dl 0x000100 ; 90.000 40, 1.000
04292C FF 00 00    0610*  	dl 0x0000FF ; 91.406 41, 1.000
04292F FF 00 00    0611*  	dl 0x0000FF ; 92.813 42, 0.999
042932 FF 00 00    0612*  	dl 0x0000FF ; 94.219 43, 0.997
042935 FE 00 00    0613*  	dl 0x0000FE ; 95.625 44, 0.995
042938 FE 00 00    0614*  	dl 0x0000FE ; 97.031 45, 0.992
04293B FD 00 00    0615*  	dl 0x0000FD ; 98.438 46, 0.989
04293E FC 00 00    0616*  	dl 0x0000FC ; 99.844 47, 0.985
042941 FB 00 00    0617*  	dl 0x0000FB ; 101.250 48, 0.981
042944 F9 00 00    0618*  	dl 0x0000F9 ; 102.656 49, 0.976
042947 F8 00 00    0619*  	dl 0x0000F8 ; 104.063 4A, 0.970
04294A F6 00 00    0620*  	dl 0x0000F6 ; 105.469 4B, 0.964
04294D F4 00 00    0621*  	dl 0x0000F4 ; 106.875 4C, 0.957
042950 F3 00 00    0622*  	dl 0x0000F3 ; 108.281 4D, 0.950
042953 F1 00 00    0623*  	dl 0x0000F1 ; 109.688 4E, 0.942
042956 EE 00 00    0624*  	dl 0x0000EE ; 111.094 4F, 0.933
042959 EC 00 00    0625*  	dl 0x0000EC ; 112.500 50, 0.924
04295C EA 00 00    0626*  	dl 0x0000EA ; 113.906 51, 0.914
04295F E7 00 00    0627*  	dl 0x0000E7 ; 115.313 52, 0.904
042962 E4 00 00    0628*  	dl 0x0000E4 ; 116.719 53, 0.893
042965 E1 00 00    0629*  	dl 0x0000E1 ; 118.125 54, 0.882
042968 DE 00 00    0630*  	dl 0x0000DE ; 119.531 55, 0.870
04296B DB 00 00    0631*  	dl 0x0000DB ; 120.938 56, 0.858
04296E D8 00 00    0632*  	dl 0x0000D8 ; 122.344 57, 0.845
042971 D4 00 00    0633*  	dl 0x0000D4 ; 123.750 58, 0.831
042974 D1 00 00    0634*  	dl 0x0000D1 ; 125.156 59, 0.818
042977 CD 00 00    0635*  	dl 0x0000CD ; 126.563 5A, 0.803
04297A C9 00 00    0636*  	dl 0x0000C9 ; 127.969 5B, 0.788
04297D C5 00 00    0637*  	dl 0x0000C5 ; 129.375 5C, 0.773
042980 C1 00 00    0638*  	dl 0x0000C1 ; 130.781 5D, 0.757
042983 BD 00 00    0639*  	dl 0x0000BD ; 132.188 5E, 0.741
042986 B9 00 00    0640*  	dl 0x0000B9 ; 133.594 5F, 0.724
042989 B5 00 00    0641*  	dl 0x0000B5 ; 135.000 60, 0.707
04298C B0 00 00    0642*  	dl 0x0000B0 ; 136.406 61, 0.690
04298F AB 00 00    0643*  	dl 0x0000AB ; 137.813 62, 0.672
042992 A7 00 00    0644*  	dl 0x0000A7 ; 139.219 63, 0.653
042995 A2 00 00    0645*  	dl 0x0000A2 ; 140.625 64, 0.634
042998 9D 00 00    0646*  	dl 0x00009D ; 142.031 65, 0.615
04299B 98 00 00    0647*  	dl 0x000098 ; 143.438 66, 0.596
04299E 93 00 00    0648*  	dl 0x000093 ; 144.844 67, 0.576
0429A1 8E 00 00    0649*  	dl 0x00008E ; 146.250 68, 0.556
0429A4 88 00 00    0650*  	dl 0x000088 ; 147.656 69, 0.535
0429A7 83 00 00    0651*  	dl 0x000083 ; 149.063 6A, 0.514
0429AA 7E 00 00    0652*  	dl 0x00007E ; 150.469 6B, 0.493
0429AD 78 00 00    0653*  	dl 0x000078 ; 151.875 6C, 0.471
0429B0 73 00 00    0654*  	dl 0x000073 ; 153.281 6D, 0.450
0429B3 6D 00 00    0655*  	dl 0x00006D ; 154.688 6E, 0.428
0429B6 67 00 00    0656*  	dl 0x000067 ; 156.094 6F, 0.405
0429B9 61 00 00    0657*  	dl 0x000061 ; 157.500 70, 0.383
0429BC 5C 00 00    0658*  	dl 0x00005C ; 158.906 71, 0.360
0429BF 56 00 00    0659*  	dl 0x000056 ; 160.313 72, 0.337
0429C2 50 00 00    0660*  	dl 0x000050 ; 161.719 73, 0.314
0429C5 4A 00 00    0661*  	dl 0x00004A ; 163.125 74, 0.290
0429C8 44 00 00    0662*  	dl 0x000044 ; 164.531 75, 0.267
0429CB 3E 00 00    0663*  	dl 0x00003E ; 165.938 76, 0.243
0429CE 38 00 00    0664*  	dl 0x000038 ; 167.344 77, 0.219
0429D1 31 00 00    0665*  	dl 0x000031 ; 168.750 78, 0.195
0429D4 2B 00 00    0666*  	dl 0x00002B ; 170.156 79, 0.171
0429D7 25 00 00    0667*  	dl 0x000025 ; 171.563 7A, 0.147
0429DA 1F 00 00    0668*  	dl 0x00001F ; 172.969 7B, 0.122
0429DD 19 00 00    0669*  	dl 0x000019 ; 174.375 7C, 0.098
0429E0 12 00 00    0670*  	dl 0x000012 ; 175.781 7D, 0.074
0429E3 0C 00 00    0671*  	dl 0x00000C ; 177.188 7E, 0.049
0429E6 06 00 00    0672*  	dl 0x000006 ; 178.594 7F, 0.025
0429E9 00 00 00    0673*  	dl 0x000000 ; 180.000 80, 0.000
0429EC FA FF FF    0674*  	dl 0xFFFFFA ; 181.406 81, -0.025
0429EF F4 FF FF    0675*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0429F2 EE FF FF    0676*  	dl 0xFFFFEE ; 184.219 83, -0.074
0429F5 E7 FF FF    0677*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0429F8 E1 FF FF    0678*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0429FB DB FF FF    0679*  	dl 0xFFFFDB ; 188.438 86, -0.147
0429FE D5 FF FF    0680*  	dl 0xFFFFD5 ; 189.844 87, -0.171
042A01 CF FF FF    0681*  	dl 0xFFFFCF ; 191.250 88, -0.195
042A04 C8 FF FF    0682*  	dl 0xFFFFC8 ; 192.656 89, -0.219
042A07 C2 FF FF    0683*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
042A0A BC FF FF    0684*  	dl 0xFFFFBC ; 195.469 8B, -0.267
042A0D B6 FF FF    0685*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
042A10 B0 FF FF    0686*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
042A13 AA FF FF    0687*  	dl 0xFFFFAA ; 199.688 8E, -0.337
042A16 A4 FF FF    0688*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
042A19 9F FF FF    0689*  	dl 0xFFFF9F ; 202.500 90, -0.383
042A1C 99 FF FF    0690*  	dl 0xFFFF99 ; 203.906 91, -0.405
042A1F 93 FF FF    0691*  	dl 0xFFFF93 ; 205.313 92, -0.428
042A22 8D FF FF    0692*  	dl 0xFFFF8D ; 206.719 93, -0.450
042A25 88 FF FF    0693*  	dl 0xFFFF88 ; 208.125 94, -0.471
042A28 82 FF FF    0694*  	dl 0xFFFF82 ; 209.531 95, -0.493
042A2B 7D FF FF    0695*  	dl 0xFFFF7D ; 210.938 96, -0.514
042A2E 78 FF FF    0696*  	dl 0xFFFF78 ; 212.344 97, -0.535
042A31 72 FF FF    0697*  	dl 0xFFFF72 ; 213.750 98, -0.556
042A34 6D FF FF    0698*  	dl 0xFFFF6D ; 215.156 99, -0.576
042A37 68 FF FF    0699*  	dl 0xFFFF68 ; 216.563 9A, -0.596
042A3A 63 FF FF    0700*  	dl 0xFFFF63 ; 217.969 9B, -0.615
042A3D 5E FF FF    0701*  	dl 0xFFFF5E ; 219.375 9C, -0.634
042A40 59 FF FF    0702*  	dl 0xFFFF59 ; 220.781 9D, -0.653
042A43 55 FF FF    0703*  	dl 0xFFFF55 ; 222.188 9E, -0.672
042A46 50 FF FF    0704*  	dl 0xFFFF50 ; 223.594 9F, -0.690
042A49 4B FF FF    0705*  	dl 0xFFFF4B ; 225.000 A0, -0.707
042A4C 47 FF FF    0706*  	dl 0xFFFF47 ; 226.406 A1, -0.724
042A4F 43 FF FF    0707*  	dl 0xFFFF43 ; 227.813 A2, -0.741
042A52 3F FF FF    0708*  	dl 0xFFFF3F ; 229.219 A3, -0.757
042A55 3B FF FF    0709*  	dl 0xFFFF3B ; 230.625 A4, -0.773
042A58 37 FF FF    0710*  	dl 0xFFFF37 ; 232.031 A5, -0.788
042A5B 33 FF FF    0711*  	dl 0xFFFF33 ; 233.438 A6, -0.803
042A5E 2F FF FF    0712*  	dl 0xFFFF2F ; 234.844 A7, -0.818
042A61 2C FF FF    0713*  	dl 0xFFFF2C ; 236.250 A8, -0.831
042A64 28 FF FF    0714*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042A67 25 FF FF    0715*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042A6A 22 FF FF    0716*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042A6D 1F FF FF    0717*  	dl 0xFFFF1F ; 241.875 AC, -0.882
042A70 1C FF FF    0718*  	dl 0xFFFF1C ; 243.281 AD, -0.893
042A73 19 FF FF    0719*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042A76 16 FF FF    0720*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042A79 14 FF FF    0721*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042A7C 12 FF FF    0722*  	dl 0xFFFF12 ; 248.906 B1, -0.933
042A7F 0F FF FF    0723*  	dl 0xFFFF0F ; 250.313 B2, -0.942
042A82 0D FF FF    0724*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042A85 0C FF FF    0725*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042A88 0A FF FF    0726*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042A8B 08 FF FF    0727*  	dl 0xFFFF08 ; 255.938 B6, -0.970
042A8E 07 FF FF    0728*  	dl 0xFFFF07 ; 257.344 B7, -0.976
042A91 05 FF FF    0729*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042A94 04 FF FF    0730*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042A97 03 FF FF    0731*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042A9A 02 FF FF    0732*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042A9D 02 FF FF    0733*  	dl 0xFFFF02 ; 264.375 BC, -0.995
042AA0 01 FF FF    0734*  	dl 0xFFFF01 ; 265.781 BD, -0.997
042AA3 01 FF FF    0735*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042AA6 01 FF FF    0736*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042AA9 00 FF FF    0737*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042AAC 01 FF FF    0738*  	dl 0xFFFF01 ; 271.406 C1, -1.000
042AAF 01 FF FF    0739*  	dl 0xFFFF01 ; 272.813 C2, -0.999
042AB2 01 FF FF    0740*  	dl 0xFFFF01 ; 274.219 C3, -0.997
042AB5 02 FF FF    0741*  	dl 0xFFFF02 ; 275.625 C4, -0.995
042AB8 02 FF FF    0742*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042ABB 03 FF FF    0743*  	dl 0xFFFF03 ; 278.438 C6, -0.989
042ABE 04 FF FF    0744*  	dl 0xFFFF04 ; 279.844 C7, -0.985
042AC1 05 FF FF    0745*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042AC4 07 FF FF    0746*  	dl 0xFFFF07 ; 282.656 C9, -0.976
042AC7 08 FF FF    0747*  	dl 0xFFFF08 ; 284.063 CA, -0.970
042ACA 0A FF FF    0748*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042ACD 0C FF FF    0749*  	dl 0xFFFF0C ; 286.875 CC, -0.957
042AD0 0D FF FF    0750*  	dl 0xFFFF0D ; 288.281 CD, -0.950
042AD3 0F FF FF    0751*  	dl 0xFFFF0F ; 289.688 CE, -0.942
042AD6 12 FF FF    0752*  	dl 0xFFFF12 ; 291.094 CF, -0.933
042AD9 14 FF FF    0753*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042ADC 16 FF FF    0754*  	dl 0xFFFF16 ; 293.906 D1, -0.914
042ADF 19 FF FF    0755*  	dl 0xFFFF19 ; 295.313 D2, -0.904
042AE2 1C FF FF    0756*  	dl 0xFFFF1C ; 296.719 D3, -0.893
042AE5 1F FF FF    0757*  	dl 0xFFFF1F ; 298.125 D4, -0.882
042AE8 22 FF FF    0758*  	dl 0xFFFF22 ; 299.531 D5, -0.870
042AEB 25 FF FF    0759*  	dl 0xFFFF25 ; 300.938 D6, -0.858
042AEE 28 FF FF    0760*  	dl 0xFFFF28 ; 302.344 D7, -0.845
042AF1 2C FF FF    0761*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042AF4 2F FF FF    0762*  	dl 0xFFFF2F ; 305.156 D9, -0.818
042AF7 33 FF FF    0763*  	dl 0xFFFF33 ; 306.563 DA, -0.803
042AFA 37 FF FF    0764*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042AFD 3B FF FF    0765*  	dl 0xFFFF3B ; 309.375 DC, -0.773
042B00 3F FF FF    0766*  	dl 0xFFFF3F ; 310.781 DD, -0.757
042B03 43 FF FF    0767*  	dl 0xFFFF43 ; 312.188 DE, -0.741
042B06 47 FF FF    0768*  	dl 0xFFFF47 ; 313.594 DF, -0.724
042B09 4B FF FF    0769*  	dl 0xFFFF4B ; 315.000 E0, -0.707
042B0C 50 FF FF    0770*  	dl 0xFFFF50 ; 316.406 E1, -0.690
042B0F 55 FF FF    0771*  	dl 0xFFFF55 ; 317.813 E2, -0.672
042B12 59 FF FF    0772*  	dl 0xFFFF59 ; 319.219 E3, -0.653
042B15 5E FF FF    0773*  	dl 0xFFFF5E ; 320.625 E4, -0.634
042B18 63 FF FF    0774*  	dl 0xFFFF63 ; 322.031 E5, -0.615
042B1B 68 FF FF    0775*  	dl 0xFFFF68 ; 323.438 E6, -0.596
042B1E 6D FF FF    0776*  	dl 0xFFFF6D ; 324.844 E7, -0.576
042B21 72 FF FF    0777*  	dl 0xFFFF72 ; 326.250 E8, -0.556
042B24 78 FF FF    0778*  	dl 0xFFFF78 ; 327.656 E9, -0.535
042B27 7D FF FF    0779*  	dl 0xFFFF7D ; 329.063 EA, -0.514
042B2A 82 FF FF    0780*  	dl 0xFFFF82 ; 330.469 EB, -0.493
042B2D 88 FF FF    0781*  	dl 0xFFFF88 ; 331.875 EC, -0.471
042B30 8D FF FF    0782*  	dl 0xFFFF8D ; 333.281 ED, -0.450
042B33 93 FF FF    0783*  	dl 0xFFFF93 ; 334.688 EE, -0.428
042B36 99 FF FF    0784*  	dl 0xFFFF99 ; 336.094 EF, -0.405
042B39 9F FF FF    0785*  	dl 0xFFFF9F ; 337.500 F0, -0.383
042B3C A4 FF FF    0786*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
042B3F AA FF FF    0787*  	dl 0xFFFFAA ; 340.313 F2, -0.337
042B42 B0 FF FF    0788*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
042B45 B6 FF FF    0789*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
042B48 BC FF FF    0790*  	dl 0xFFFFBC ; 344.531 F5, -0.267
042B4B C2 FF FF    0791*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
042B4E C8 FF FF    0792*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
042B51 CF FF FF    0793*  	dl 0xFFFFCF ; 348.750 F8, -0.195
042B54 D5 FF FF    0794*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
042B57 DB FF FF    0795*  	dl 0xFFFFDB ; 351.563 FA, -0.147
042B5A E1 FF FF    0796*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
042B5D E7 FF FF    0797*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
042B60 EE FF FF    0798*  	dl 0xFFFFEE ; 355.781 FD, -0.074
042B63 F4 FF FF    0799*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042B66 FA FF FF    0800*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042B69 00 00 00    0801*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042B6C             0802*  
042B6C             0803*  atan_lut_168:
042B6C 00 00 00    0804*  	dl 0x000000 ; 000000, 0.000
042B6F 28 00 00    0805*  	dl 0x000028 ; 000001, 0.224
042B72 51 00 00    0806*  	dl 0x000051 ; 000002, 0.448
042B75 7A 00 00    0807*  	dl 0x00007A ; 000003, 0.671
042B78 A2 00 00    0808*  	dl 0x0000A2 ; 000004, 0.895
042B7B CB 00 00    0809*  	dl 0x0000CB ; 000005, 1.119
042B7E F4 00 00    0810*  	dl 0x0000F4 ; 000006, 1.343
042B81 1D 01 00    0811*  	dl 0x00011D ; 000007, 1.566
042B84 45 01 00    0812*  	dl 0x000145 ; 000008, 1.790
042B87 6E 01 00    0813*  	dl 0x00016E ; 000009, 2.013
042B8A 97 01 00    0814*  	dl 0x000197 ; 00000A, 2.237
042B8D BF 01 00    0815*  	dl 0x0001BF ; 00000B, 2.460
042B90 E8 01 00    0816*  	dl 0x0001E8 ; 00000C, 2.684
042B93 11 02 00    0817*  	dl 0x000211 ; 00000D, 2.907
042B96 39 02 00    0818*  	dl 0x000239 ; 00000E, 3.130
042B99 62 02 00    0819*  	dl 0x000262 ; 00000F, 3.353
042B9C 8B 02 00    0820*  	dl 0x00028B ; 000010, 3.576
042B9F B3 02 00    0821*  	dl 0x0002B3 ; 000011, 3.799
042BA2 DC 02 00    0822*  	dl 0x0002DC ; 000012, 4.022
042BA5 04 03 00    0823*  	dl 0x000304 ; 000013, 4.245
042BA8 2D 03 00    0824*  	dl 0x00032D ; 000014, 4.467
042BAB 55 03 00    0825*  	dl 0x000355 ; 000015, 4.690
042BAE 7E 03 00    0826*  	dl 0x00037E ; 000016, 4.912
042BB1 A6 03 00    0827*  	dl 0x0003A6 ; 000017, 5.134
042BB4 CE 03 00    0828*  	dl 0x0003CE ; 000018, 5.356
042BB7 F7 03 00    0829*  	dl 0x0003F7 ; 000019, 5.578
042BBA 1F 04 00    0830*  	dl 0x00041F ; 00001A, 5.799
042BBD 48 04 00    0831*  	dl 0x000448 ; 00001B, 6.021
042BC0 70 04 00    0832*  	dl 0x000470 ; 00001C, 6.242
042BC3 98 04 00    0833*  	dl 0x000498 ; 00001D, 6.463
042BC6 C0 04 00    0834*  	dl 0x0004C0 ; 00001E, 6.684
042BC9 E8 04 00    0835*  	dl 0x0004E8 ; 00001F, 6.905
042BCC 11 05 00    0836*  	dl 0x000511 ; 000020, 7.125
042BCF 39 05 00    0837*  	dl 0x000539 ; 000021, 7.345
042BD2 61 05 00    0838*  	dl 0x000561 ; 000022, 7.565
042BD5 89 05 00    0839*  	dl 0x000589 ; 000023, 7.785
042BD8 B1 05 00    0840*  	dl 0x0005B1 ; 000024, 8.005
042BDB D9 05 00    0841*  	dl 0x0005D9 ; 000025, 8.224
042BDE 01 06 00    0842*  	dl 0x000601 ; 000026, 8.443
042BE1 28 06 00    0843*  	dl 0x000628 ; 000027, 8.662
042BE4 50 06 00    0844*  	dl 0x000650 ; 000028, 8.881
042BE7 78 06 00    0845*  	dl 0x000678 ; 000029, 9.099
042BEA A0 06 00    0846*  	dl 0x0006A0 ; 00002A, 9.317
042BED C7 06 00    0847*  	dl 0x0006C7 ; 00002B, 9.535
042BF0 EF 06 00    0848*  	dl 0x0006EF ; 00002C, 9.752
042BF3 16 07 00    0849*  	dl 0x000716 ; 00002D, 9.970
042BF6 3E 07 00    0850*  	dl 0x00073E ; 00002E, 10.187
042BF9 65 07 00    0851*  	dl 0x000765 ; 00002F, 10.403
042BFC 8D 07 00    0852*  	dl 0x00078D ; 000030, 10.620
042BFF B4 07 00    0853*  	dl 0x0007B4 ; 000031, 10.836
042C02 DB 07 00    0854*  	dl 0x0007DB ; 000032, 11.051
042C05 03 08 00    0855*  	dl 0x000803 ; 000033, 11.267
042C08 2A 08 00    0856*  	dl 0x00082A ; 000034, 11.482
042C0B 51 08 00    0857*  	dl 0x000851 ; 000035, 11.697
042C0E 78 08 00    0858*  	dl 0x000878 ; 000036, 11.911
042C11 9F 08 00    0859*  	dl 0x00089F ; 000037, 12.125
042C14 C6 08 00    0860*  	dl 0x0008C6 ; 000038, 12.339
042C17 ED 08 00    0861*  	dl 0x0008ED ; 000039, 12.553
042C1A 13 09 00    0862*  	dl 0x000913 ; 00003A, 12.766
042C1D 3A 09 00    0863*  	dl 0x00093A ; 00003B, 12.978
042C20 61 09 00    0864*  	dl 0x000961 ; 00003C, 13.191
042C23 87 09 00    0865*  	dl 0x000987 ; 00003D, 13.403
042C26 AE 09 00    0866*  	dl 0x0009AE ; 00003E, 13.614
042C29 D4 09 00    0867*  	dl 0x0009D4 ; 00003F, 13.825
042C2C FB 09 00    0868*  	dl 0x0009FB ; 000040, 14.036
042C2F 21 0A 00    0869*  	dl 0x000A21 ; 000041, 14.247
042C32 47 0A 00    0870*  	dl 0x000A47 ; 000042, 14.457
042C35 6D 0A 00    0871*  	dl 0x000A6D ; 000043, 14.666
042C38 94 0A 00    0872*  	dl 0x000A94 ; 000044, 14.876
042C3B BA 0A 00    0873*  	dl 0x000ABA ; 000045, 15.085
042C3E E0 0A 00    0874*  	dl 0x000AE0 ; 000046, 15.293
042C41 05 0B 00    0875*  	dl 0x000B05 ; 000047, 15.501
042C44 2B 0B 00    0876*  	dl 0x000B2B ; 000048, 15.709
042C47 51 0B 00    0877*  	dl 0x000B51 ; 000049, 15.916
042C4A 77 0B 00    0878*  	dl 0x000B77 ; 00004A, 16.123
042C4D 9C 0B 00    0879*  	dl 0x000B9C ; 00004B, 16.329
042C50 C2 0B 00    0880*  	dl 0x000BC2 ; 00004C, 16.535
042C53 E7 0B 00    0881*  	dl 0x000BE7 ; 00004D, 16.740
042C56 0C 0C 00    0882*  	dl 0x000C0C ; 00004E, 16.945
042C59 32 0C 00    0883*  	dl 0x000C32 ; 00004F, 17.150
042C5C 57 0C 00    0884*  	dl 0x000C57 ; 000050, 17.354
042C5F 7C 0C 00    0885*  	dl 0x000C7C ; 000051, 17.558
042C62 A1 0C 00    0886*  	dl 0x000CA1 ; 000052, 17.761
042C65 C6 0C 00    0887*  	dl 0x000CC6 ; 000053, 17.964
042C68 EB 0C 00    0888*  	dl 0x000CEB ; 000054, 18.166
042C6B 0F 0D 00    0889*  	dl 0x000D0F ; 000055, 18.368
042C6E 34 0D 00    0890*  	dl 0x000D34 ; 000056, 18.569
042C71 58 0D 00    0891*  	dl 0x000D58 ; 000057, 18.770
042C74 7D 0D 00    0892*  	dl 0x000D7D ; 000058, 18.970
042C77 A1 0D 00    0893*  	dl 0x000DA1 ; 000059, 19.170
042C7A C6 0D 00    0894*  	dl 0x000DC6 ; 00005A, 19.370
042C7D EA 0D 00    0895*  	dl 0x000DEA ; 00005B, 19.569
042C80 0E 0E 00    0896*  	dl 0x000E0E ; 00005C, 19.767
042C83 32 0E 00    0897*  	dl 0x000E32 ; 00005D, 19.965
042C86 56 0E 00    0898*  	dl 0x000E56 ; 00005E, 20.163
042C89 7A 0E 00    0899*  	dl 0x000E7A ; 00005F, 20.360
042C8C 9E 0E 00    0900*  	dl 0x000E9E ; 000060, 20.556
042C8F C1 0E 00    0901*  	dl 0x000EC1 ; 000061, 20.752
042C92 E5 0E 00    0902*  	dl 0x000EE5 ; 000062, 20.947
042C95 08 0F 00    0903*  	dl 0x000F08 ; 000063, 21.142
042C98 2C 0F 00    0904*  	dl 0x000F2C ; 000064, 21.337
042C9B 4F 0F 00    0905*  	dl 0x000F4F ; 000065, 21.531
042C9E 72 0F 00    0906*  	dl 0x000F72 ; 000066, 21.724
042CA1 95 0F 00    0907*  	dl 0x000F95 ; 000067, 21.917
042CA4 B8 0F 00    0908*  	dl 0x000FB8 ; 000068, 22.109
042CA7 DB 0F 00    0909*  	dl 0x000FDB ; 000069, 22.301
042CAA FE 0F 00    0910*  	dl 0x000FFE ; 00006A, 22.493
042CAD 21 10 00    0911*  	dl 0x001021 ; 00006B, 22.683
042CB0 44 10 00    0912*  	dl 0x001044 ; 00006C, 22.874
042CB3 66 10 00    0913*  	dl 0x001066 ; 00006D, 23.063
042CB6 89 10 00    0914*  	dl 0x001089 ; 00006E, 23.253
042CB9 AB 10 00    0915*  	dl 0x0010AB ; 00006F, 23.441
042CBC CD 10 00    0916*  	dl 0x0010CD ; 000070, 23.629
042CBF EF 10 00    0917*  	dl 0x0010EF ; 000071, 23.817
042CC2 11 11 00    0918*  	dl 0x001111 ; 000072, 24.004
042CC5 33 11 00    0919*  	dl 0x001133 ; 000073, 24.191
042CC8 55 11 00    0920*  	dl 0x001155 ; 000074, 24.376
042CCB 77 11 00    0921*  	dl 0x001177 ; 000075, 24.562
042CCE 99 11 00    0922*  	dl 0x001199 ; 000076, 24.747
042CD1 BA 11 00    0923*  	dl 0x0011BA ; 000077, 24.931
042CD4 DC 11 00    0924*  	dl 0x0011DC ; 000078, 25.115
042CD7 FD 11 00    0925*  	dl 0x0011FD ; 000079, 25.298
042CDA 1E 12 00    0926*  	dl 0x00121E ; 00007A, 25.481
042CDD 3F 12 00    0927*  	dl 0x00123F ; 00007B, 25.663
042CE0 60 12 00    0928*  	dl 0x001260 ; 00007C, 25.844
042CE3 81 12 00    0929*  	dl 0x001281 ; 00007D, 26.025
042CE6 A2 12 00    0930*  	dl 0x0012A2 ; 00007E, 26.206
042CE9 C3 12 00    0931*  	dl 0x0012C3 ; 00007F, 26.386
042CEC E4 12 00    0932*  	dl 0x0012E4 ; 000080, 26.565
042CEF 04 13 00    0933*  	dl 0x001304 ; 000081, 26.744
042CF2 25 13 00    0934*  	dl 0x001325 ; 000082, 26.922
042CF5 45 13 00    0935*  	dl 0x001345 ; 000083, 27.100
042CF8 65 13 00    0936*  	dl 0x001365 ; 000084, 27.277
042CFB 85 13 00    0937*  	dl 0x001385 ; 000085, 27.453
042CFE A5 13 00    0938*  	dl 0x0013A5 ; 000086, 27.629
042D01 C5 13 00    0939*  	dl 0x0013C5 ; 000087, 27.805
042D04 E5 13 00    0940*  	dl 0x0013E5 ; 000088, 27.979
042D07 05 14 00    0941*  	dl 0x001405 ; 000089, 28.154
042D0A 24 14 00    0942*  	dl 0x001424 ; 00008A, 28.327
042D0D 44 14 00    0943*  	dl 0x001444 ; 00008B, 28.501
042D10 63 14 00    0944*  	dl 0x001463 ; 00008C, 28.673
042D13 83 14 00    0945*  	dl 0x001483 ; 00008D, 28.845
042D16 A2 14 00    0946*  	dl 0x0014A2 ; 00008E, 29.017
042D19 C1 14 00    0947*  	dl 0x0014C1 ; 00008F, 29.187
042D1C E0 14 00    0948*  	dl 0x0014E0 ; 000090, 29.358
042D1F FF 14 00    0949*  	dl 0x0014FF ; 000091, 29.527
042D22 1E 15 00    0950*  	dl 0x00151E ; 000092, 29.697
042D25 3C 15 00    0951*  	dl 0x00153C ; 000093, 29.865
042D28 5B 15 00    0952*  	dl 0x00155B ; 000094, 30.033
042D2B 79 15 00    0953*  	dl 0x001579 ; 000095, 30.201
042D2E 98 15 00    0954*  	dl 0x001598 ; 000096, 30.368
042D31 B6 15 00    0955*  	dl 0x0015B6 ; 000097, 30.534
042D34 D4 15 00    0956*  	dl 0x0015D4 ; 000098, 30.700
042D37 F2 15 00    0957*  	dl 0x0015F2 ; 000099, 30.865
042D3A 10 16 00    0958*  	dl 0x001610 ; 00009A, 31.030
042D3D 2E 16 00    0959*  	dl 0x00162E ; 00009B, 31.194
042D40 4C 16 00    0960*  	dl 0x00164C ; 00009C, 31.357
042D43 6A 16 00    0961*  	dl 0x00166A ; 00009D, 31.520
042D46 87 16 00    0962*  	dl 0x001687 ; 00009E, 31.682
042D49 A5 16 00    0963*  	dl 0x0016A5 ; 00009F, 31.844
042D4C C2 16 00    0964*  	dl 0x0016C2 ; 0000A0, 32.005
042D4F DF 16 00    0965*  	dl 0x0016DF ; 0000A1, 32.166
042D52 FC 16 00    0966*  	dl 0x0016FC ; 0000A2, 32.326
042D55 19 17 00    0967*  	dl 0x001719 ; 0000A3, 32.486
042D58 36 17 00    0968*  	dl 0x001736 ; 0000A4, 32.645
042D5B 53 17 00    0969*  	dl 0x001753 ; 0000A5, 32.803
042D5E 70 17 00    0970*  	dl 0x001770 ; 0000A6, 32.961
042D61 8C 17 00    0971*  	dl 0x00178C ; 0000A7, 33.118
042D64 A9 17 00    0972*  	dl 0x0017A9 ; 0000A8, 33.275
042D67 C5 17 00    0973*  	dl 0x0017C5 ; 0000A9, 33.431
042D6A E2 17 00    0974*  	dl 0x0017E2 ; 0000AA, 33.587
042D6D FE 17 00    0975*  	dl 0x0017FE ; 0000AB, 33.742
042D70 1A 18 00    0976*  	dl 0x00181A ; 0000AC, 33.896
042D73 36 18 00    0977*  	dl 0x001836 ; 0000AD, 34.050
042D76 52 18 00    0978*  	dl 0x001852 ; 0000AE, 34.203
042D79 6E 18 00    0979*  	dl 0x00186E ; 0000AF, 34.356
042D7C 8A 18 00    0980*  	dl 0x00188A ; 0000B0, 34.509
042D7F A5 18 00    0981*  	dl 0x0018A5 ; 0000B1, 34.660
042D82 C1 18 00    0982*  	dl 0x0018C1 ; 0000B2, 34.811
042D85 DC 18 00    0983*  	dl 0x0018DC ; 0000B3, 34.962
042D88 F7 18 00    0984*  	dl 0x0018F7 ; 0000B4, 35.112
042D8B 13 19 00    0985*  	dl 0x001913 ; 0000B5, 35.262
042D8E 2E 19 00    0986*  	dl 0x00192E ; 0000B6, 35.410
042D91 49 19 00    0987*  	dl 0x001949 ; 0000B7, 35.559
042D94 64 19 00    0988*  	dl 0x001964 ; 0000B8, 35.707
042D97 7F 19 00    0989*  	dl 0x00197F ; 0000B9, 35.854
042D9A 99 19 00    0990*  	dl 0x001999 ; 0000BA, 36.001
042D9D B4 19 00    0991*  	dl 0x0019B4 ; 0000BB, 36.147
042DA0 CE 19 00    0992*  	dl 0x0019CE ; 0000BC, 36.293
042DA3 E9 19 00    0993*  	dl 0x0019E9 ; 0000BD, 36.438
042DA6 03 1A 00    0994*  	dl 0x001A03 ; 0000BE, 36.582
042DA9 1D 1A 00    0995*  	dl 0x001A1D ; 0000BF, 36.726
042DAC 37 1A 00    0996*  	dl 0x001A37 ; 0000C0, 36.870
042DAF 51 1A 00    0997*  	dl 0x001A51 ; 0000C1, 37.013
042DB2 6B 1A 00    0998*  	dl 0x001A6B ; 0000C2, 37.155
042DB5 85 1A 00    0999*  	dl 0x001A85 ; 0000C3, 37.297
042DB8 9F 1A 00    1000*  	dl 0x001A9F ; 0000C4, 37.439
042DBB B9 1A 00    1001*  	dl 0x001AB9 ; 0000C5, 37.579
042DBE D2 1A 00    1002*  	dl 0x001AD2 ; 0000C6, 37.720
042DC1 EC 1A 00    1003*  	dl 0x001AEC ; 0000C7, 37.859
042DC4 05 1B 00    1004*  	dl 0x001B05 ; 0000C8, 37.999
042DC7 1E 1B 00    1005*  	dl 0x001B1E ; 0000C9, 38.137
042DCA 37 1B 00    1006*  	dl 0x001B37 ; 0000CA, 38.276
042DCD 50 1B 00    1007*  	dl 0x001B50 ; 0000CB, 38.413
042DD0 69 1B 00    1008*  	dl 0x001B69 ; 0000CC, 38.550
042DD3 82 1B 00    1009*  	dl 0x001B82 ; 0000CD, 38.687
042DD6 9B 1B 00    1010*  	dl 0x001B9B ; 0000CE, 38.823
042DD9 B4 1B 00    1011*  	dl 0x001BB4 ; 0000CF, 38.959
042DDC CC 1B 00    1012*  	dl 0x001BCC ; 0000D0, 39.094
042DDF E5 1B 00    1013*  	dl 0x001BE5 ; 0000D1, 39.228
042DE2 FD 1B 00    1014*  	dl 0x001BFD ; 0000D2, 39.362
042DE5 16 1C 00    1015*  	dl 0x001C16 ; 0000D3, 39.496
042DE8 2E 1C 00    1016*  	dl 0x001C2E ; 0000D4, 39.629
042DEB 46 1C 00    1017*  	dl 0x001C46 ; 0000D5, 39.762
042DEE 5E 1C 00    1018*  	dl 0x001C5E ; 0000D6, 39.894
042DF1 76 1C 00    1019*  	dl 0x001C76 ; 0000D7, 40.025
042DF4 8E 1C 00    1020*  	dl 0x001C8E ; 0000D8, 40.156
042DF7 A5 1C 00    1021*  	dl 0x001CA5 ; 0000D9, 40.286
042DFA BD 1C 00    1022*  	dl 0x001CBD ; 0000DA, 40.416
042DFD D5 1C 00    1023*  	dl 0x001CD5 ; 0000DB, 40.546
042E00 EC 1C 00    1024*  	dl 0x001CEC ; 0000DC, 40.675
042E03 04 1D 00    1025*  	dl 0x001D04 ; 0000DD, 40.803
042E06 1B 1D 00    1026*  	dl 0x001D1B ; 0000DE, 40.931
042E09 32 1D 00    1027*  	dl 0x001D32 ; 0000DF, 41.059
042E0C 49 1D 00    1028*  	dl 0x001D49 ; 0000E0, 41.186
042E0F 60 1D 00    1029*  	dl 0x001D60 ; 0000E1, 41.312
042E12 77 1D 00    1030*  	dl 0x001D77 ; 0000E2, 41.438
042E15 8E 1D 00    1031*  	dl 0x001D8E ; 0000E3, 41.564
042E18 A5 1D 00    1032*  	dl 0x001DA5 ; 0000E4, 41.689
042E1B BB 1D 00    1033*  	dl 0x001DBB ; 0000E5, 41.814
042E1E D2 1D 00    1034*  	dl 0x001DD2 ; 0000E6, 41.938
042E21 E9 1D 00    1035*  	dl 0x001DE9 ; 0000E7, 42.061
042E24 FF 1D 00    1036*  	dl 0x001DFF ; 0000E8, 42.184
042E27 15 1E 00    1037*  	dl 0x001E15 ; 0000E9, 42.307
042E2A 2C 1E 00    1038*  	dl 0x001E2C ; 0000EA, 42.429
042E2D 42 1E 00    1039*  	dl 0x001E42 ; 0000EB, 42.551
042E30 58 1E 00    1040*  	dl 0x001E58 ; 0000EC, 42.672
042E33 6E 1E 00    1041*  	dl 0x001E6E ; 0000ED, 42.793
042E36 84 1E 00    1042*  	dl 0x001E84 ; 0000EE, 42.913
042E39 99 1E 00    1043*  	dl 0x001E99 ; 0000EF, 43.033
042E3C AF 1E 00    1044*  	dl 0x001EAF ; 0000F0, 43.152
042E3F C5 1E 00    1045*  	dl 0x001EC5 ; 0000F1, 43.271
042E42 DA 1E 00    1046*  	dl 0x001EDA ; 0000F2, 43.390
042E45 F0 1E 00    1047*  	dl 0x001EF0 ; 0000F3, 43.508
042E48 05 1F 00    1048*  	dl 0x001F05 ; 0000F4, 43.625
042E4B 1B 1F 00    1049*  	dl 0x001F1B ; 0000F5, 43.742
042E4E 30 1F 00    1050*  	dl 0x001F30 ; 0000F6, 43.859
042E51 45 1F 00    1051*  	dl 0x001F45 ; 0000F7, 43.975
042E54 5A 1F 00    1052*  	dl 0x001F5A ; 0000F8, 44.091
042E57 6F 1F 00    1053*  	dl 0x001F6F ; 0000F9, 44.206
042E5A 84 1F 00    1054*  	dl 0x001F84 ; 0000FA, 44.321
042E5D 99 1F 00    1055*  	dl 0x001F99 ; 0000FB, 44.435
042E60 AD 1F 00    1056*  	dl 0x001FAD ; 0000FC, 44.549
042E63 C2 1F 00    1057*  	dl 0x001FC2 ; 0000FD, 44.662
042E66 D7 1F 00    1058*  	dl 0x001FD7 ; 0000FE, 44.775
042E69 EB 1F 00    1059*  	dl 0x001FEB ; 0000FF, 44.888
042E6C 00 20 00    1060*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042E6F             0060   	include "fixed24.inc"
042E6F             0001*  arith24uaf: ds 6
042E75             0002*  arith24uhl: ds 6
042E7B             0003*  arith24ubc: ds 6
042E81             0004*  arith24ude: ds 6
042E87             0005*  arith24uix: ds 6
042E8D             0006*  arith24uiy: ds 6
042E93             0007*  arith24usp: ds 6
042E99             0008*  arith24upc: ds 6
042E9F             0009*  
042E9F             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042E9F             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042E9F             0012*  ; inputs: hlu = 24-bit number to shift
042E9F             0013*  ;         a = signed number of bits to shift
042E9F             0014*  ;         ix = output buffer address
042E9F             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042E9F             0016*  shift_hlu:
042E9F C5          0017*      push bc ; preserve
042EA0 47          0018*      ld b,a            ; store shift value in b for later
042EA1             0019*  
042EA1             0020*  ; Initialize DE to zero and clear output buffer
042EA1 11 00 00 00 0021*      ld de, 0
042EA5 DD 1F FD    0022*      ld (ix-3), de
042EA8 DD 1F 03    0023*      ld (ix+3), de
042EAB             0024*  
042EAB             0025*  ; Get absolute value of a and save its original sign
042EAB B7          0026*      or a
042EAC F5          0027*      push af ; save sign flag
042EAD F2 B3 2E 04 0028*      jp p,@F ; If a is positive do nothing
042EB1 ED 44       0029*      neg ; If a is negative, negate it
042EB3             0030*  @@:
042EB3             0031*  
042EB3             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042EB3 CD 2E 25 04 0033*      call hlu_abs
042EB7 F5          0034*      push af ; save sign of HLU
042EB8 DD 2F 00    0035*      ld (ix), hl
042EBB             0036*  
042EBB             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042EBB 78          0038*      ld a,b            ; Restore original shift value into 'a'
042EBC CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042EBE CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042EC0 CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042EC2 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042EC3             0043*  
042EC3             0044*  ; Calculate remainder of a (original shift) mod 8
042EC3 E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042EC5 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042EC6 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042ECA             0048*  
042ECA             0049*  ; Get back the original sign of the byte shift
042ECA F1          0050*      pop af            ; Restore sign flag
042ECB F2 D9 2E 04 0051*      jp p,@F           ; If a was positive, we're done
042ECF 79          0052*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042ED0 ED 44       0053*      neg               ; Negate the number of whole bytes to shift
042ED2 3D          0054*      dec a             ; Subtract 1 because that's just how this works
042ED3 4F          0055*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042ED4 1B          0056*      dec de            ; DE = -1 to make the signed addition below work
042ED5 3E 08       0057*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042ED7 90          0058*      sub b
042ED8 47          0059*      ld b,a            ; b is the number of bits to shift back up
042ED9             0060*  
042ED9             0061*  @@:
042ED9             0062*  
042ED9             0063*  ; Add the byte offset to the base address of output buffer
042ED9 59          0064*      ld e,c            ; DEU and D were properly signed above
042EDA DD 19       0065*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042EDC             0066*  
042EDC             0067*  ; Read the byte-aligned result into HL and shift in the required number of bits
042EDC DD 27 00    0068*      ld hl,(ix)        ; Byte-aligned result
042EDF             0069*  
042EDF             0070*  ; Check whether we're already byte-aligned
042EDF AF          0071*      xor a
042EE0 B0          0072*      or b
042EE1 28 08       0073*      jr z,@end         ; If no bits to shift, we're done
042EE3             0074*  
042EE3             0075*  ; Otherwise shiften zee bitzen
042EE3 DD 7E FF    0076*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042EE6             0077*  @loop:
042EE6 07          0078*      rlca              ; One bit to carry
042EE7             0079*  
042EE7 ED 6A       0080*      adc hl,hl         ; Shift the carry into the result
042EE9             0081*  
042EE9 10 FB       0082*      djnz @loop        ; Loop until all bits are shifted up
042EEB             0083*  
042EEB             0084*  @end:
042EEB             0085*  
042EEB             0086*  ; get back HLU's original sign and negate if necessary
042EEB F1          0087*      pop af
042EEC F2 F4 2E 04 0088*      jp p,@F
042EF0 CD 3E 25 04 0089*      call neg_hlu
042EF4             0090*  @@:
042EF4             0091*  ; return the result
042EF4 DD 2F 00    0092*      ld (ix),hl        ; Store the shifted result
042EF7 C1          0093*      pop bc              ; Restore BC
042EF8 C9          0094*      ret
042EF9             0095*  
042EF9             0096*  ; operation: UHL * UDE --> UHL
042EF9             0097*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042EF9             0098*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042EF9             0099*  ; inputs: hl = 24-bit number, de = 24-bit number,
042EF9             0100*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042EF9             0101*  ; outputs: umulfxout = 48-bit intermediate
042EF9             0102*  ; destroys: af, hl, bc, de
042EF9             0103*  umulfx:
042EF9 DD E5       0104*      push ix ; preserve
042EFB F5          0105*      push af ; need later
042EFC             0106*  
042EFC             0107*  ; do the multiplication
042EFC CD B3 2F 04 0108*      call umul24x24
042F00             0109*  
042F00             0110*  ; shift the result to the required output precision
042F00 78          0111*      ld a,b
042F01 81          0112*      add a,c ; a is left shift from the multiplication
042F02 C1          0113*      pop bc ; b is the output precision (was a)
042F03 90          0114*      sub b ; a is the net shift of the output
042F04             0115*  
042F04             0116*  ; Get absolute value of a and save its original sign
042F04 B7          0117*      or a
042F05 F5          0118*      push af ; save sign flag
042F06 F2 0C 2F 04 0119*      jp p,@F ; If a is positive do nothing
042F0A ED 44       0120*      neg ; If a is negative, negate it
042F0C             0121*  @@:
042F0C             0122*  
042F0C             0123*  ; Divide a by 8 to get the whole byte shift and bit remainder
042F0C 47          0124*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042F0D CB 3F       0125*      srl a             ; a = a / 2 (shift right 1 bit)
042F0F CB 3F       0126*      srl a             ; a = a / 4 (shift right another bit)
042F11 CB 3F       0127*      srl a             ; a = a / 8 (final shift for division by 8)
042F13 4F          0128*      ld c,a            ; c holds the number of whole bytes to shift
042F14             0129*  
042F14             0130*  ; Calculate remainder of a (original shift) mod 8
042F14 78          0131*      ld a,b            ; Restore original shift value into 'a'
042F15 E6 07       0132*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042F17 47          0133*      ld b,a            ; 'b' now holds the number of bits to shift back up
042F18 11 00 00 00 0134*      ld de,0           ; Clear deu for computing the offset address later
042F1C             0135*  
042F1C             0136*  ; Get back the original sign of the byte shift
042F1C F1          0137*      pop af            ; Restore sign flag
042F1D F2 2B 2F 04 0138*      jp p,@F           ; If a was positive, we're done
042F21 79          0139*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042F22 ED 44       0140*      neg               ; Negate the number of whole bytes to shift
042F24 3D          0141*      dec a             ; Subtract 1 because that's just how this works
042F25 4F          0142*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042F26 1B          0143*      dec de            ; DE = -1 to make the signed addition below work
042F27 3E 08       0144*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042F29 90          0145*      sub b
042F2A 47          0146*      ld b,a            ; b is the number of bits to shift back up
042F2B             0147*  
042F2B             0148*  @@:
042F2B             0149*  
042F2B             0150*  ; Add the byte offset to the base address of umulfxout
042F2B 59          0151*      ld e,c            ; DEU and D were properly signed above
042F2C DD 21 48 2F 0152*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042F31 DD 19       0153*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042F33             0154*  
042F33             0155*  ; Read the byte-aligned result into HL and shift in the required number of bits
042F33 DD 27 00    0156*      ld hl,(ix)        ; Byte-aligned result
042F36 DD 7E FF    0157*      ld a,(ix-1)       ; One byte below
042F39             0158*  
042F39             0159*  ; Check whether we're already byte-aligned
042F39 AF          0160*      xor a
042F3A B0          0161*      or b
042F3B 28 05       0162*      jr z,@end         ; If no bits to shift, we're done
042F3D             0163*  
042F3D             0164*  ; Otherwise shiften zee bitzen
042F3D             0165*  @loop:
042F3D             0166*  
042F3D 07          0167*      rlca              ; One bit to carry
042F3E ED 6A       0168*      adc hl,hl         ; Shift the carry into the result
042F40             0169*  
042F40 10 FB       0170*      djnz @loop        ; Loop until all bits are shifted up
042F42             0171*  
042F42             0172*  @end:
042F42             0173*  ; return the result
042F42 DD E1       0174*      pop ix ; restore
042F44 C9          0175*      ret
042F45             0176*  
042F45 00 00 00    0177*      dl 0 ; padding
042F48 00 00 00 00 0178*  umulfxout: blkb 6,0
       00 00       
042F4E 00 00 00    0179*      dl 0 ; padding
042F51             0180*  
042F51             0181*  ; operation: UHL * UDE --> UHL
042F51             0182*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042F51             0183*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042F51             0184*  ; inputs: hl = 24-bit number, de = 24-bit number,
042F51             0185*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042F51             0186*  ; outputs: umulfxout = 48-bit intermediate
042F51             0187*  ; destroys: af, hl, bc, de
042F51             0188*  smulfx:
042F51             0189*  ; make everything positive and store sign flags
042F51 CD 2E 25 04 0190*  	call hlu_abs
042F55 F5          0191*  	push af
042F56 EB          0192*  	ex de,hl
042F57 CD 2E 25 04 0193*  	call hlu_abs
042F5B EB          0194*  	ex de,hl
042F5C F5          0195*  	push af
042F5D             0196*  ; do the division
042F5D CD F9 2E 04 0197*      call umulfx ; hl = product
042F61             0198*  ; adjust sign of result
042F61 F1          0199*  	pop af ; sign de
042F62 FA 6D 2F 04 0200*  	jp m,@de_neg
042F66 F1          0201*  	pop af ; sign hl
042F67 F0          0202*  	ret p ; both positive, nothing to do
042F68             0203*  @hl_neg:
042F68 CD 3E 25 04 0204*      call neg_hlu ; de pos, hl neg, result is negative
042F6C C9          0205*      ret
042F6D             0206*  @de_neg:
042F6D F1          0207*  	pop af
042F6E F8          0208*  	ret m ; both negative, nothing to do
042F6F CD 3E 25 04 0209*  	call neg_hlu ; result is negative
042F73 C9          0210*  	ret
042F74             0211*  
042F74             0212*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042F74             0213*  ; uses EZ80 MLT instruction for speed
042F74             0214*  ; operation: UHL * A --> UHL
042F74             0215*  ; destroys: AF, HL
042F74             0216*  smul24x8:
042F74             0217*  ; make hl positive and store sign flag
042F74 CD 2E 25 04 0218*  	call hlu_abs
042F78 F5          0219*  	push af
042F79             0220*  ; do the division
042F79 CD 84 2F 04 0221*      call umul24x8 ; hl = product
042F7D             0222*  ; adjust sign of result
042F7D F1          0223*  	pop af ; sign de
042F7E F0          0224*  	ret p ; hl was positive, nothing to do
042F7F CD 3E 25 04 0225*  	call neg_hlu ; result is negative
042F83 C9          0226*  	ret
042F84             0227*  
042F84             0228*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042F84             0229*  ; uses EZ80 MLT instruction for speed
042F84             0230*  ; operation: UHL * A --> AUHL
042F84             0231*  ; destroys: AF, HL
042F84             0232*  umul24x8:
042F84 D5          0233*  	push de ; preserve de
042F85             0234*  ; low byte
042F85 5D          0235*  	ld e,l
042F86 57          0236*  	ld d,a
042F87 ED 5C       0237*  	mlt de
042F89 6B          0238*  	ld l,e ; product low byte
042F8A 08          0239*  	ex af,af' ; save multiplier
042F8B 7A          0240*  	ld a,d ; carry
042F8C 08          0241*  	ex af,af' ; save carry, restore multiplier
042F8D             0242*  ; high byte
042F8D 5C          0243*  	ld e,h
042F8E 57          0244*  	ld d,a
042F8F ED 5C       0245*  	mlt de
042F91 08          0246*  	ex af,af' ; save multiplier, restore carry
042F92 83          0247*  	add a,e ; add carry
042F93 67          0248*  	ld h,a ; product middle byte
042F94 7A          0249*  	ld a,d ; carry
042F95 08          0250*  	ex af,af' ; save carry, restore multiplier
042F96             0251*  ; upper byte
042F96 E5          0252*  	push hl
042F97 33          0253*  	inc sp
042F98 D1          0254*  	pop de ; d = hlu
042F99 3B          0255*  	dec sp
042F9A 5F          0256*  	ld e,a
042F9B ED 5C       0257*  	mlt de
042F9D 08          0258*  	ex af,af' ; restore carry
042F9E 8B          0259*  	adc a,e ; add carry
042F9F 22 B0 2F 04 0260*      ld (@scratch),hl ; 7 cycles
042FA3 32 B2 2F 04 0261*      ld (@scratch+2),a ; 5 cycles
042FA7 2A B0 2F 04 0262*      ld hl,(@scratch) ; 7 cycles
042FAB             0263*  ; highest byte
042FAB 3E 00       0264*  	ld a,0 ; preserve carry flag
042FAD 8A          0265*  	adc a,d ; product highest byte
042FAE D1          0266*  	pop de ; restore de
042FAF C9          0267*  	ret
042FB0             0268*  @scratch: ds 3
042FB3             0269*  
042FB3             0270*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042FB3             0271*  ; operation: UHL * UDE --> umulfxout
042FB3             0272*  umul24x24:
042FB3 FD 21 48 2F 0273*  	ld iy,umulfxout ; point to output buffer
       04          
042FB8 C5          0274*  	push bc
042FB9 01 00 00 00 0275*  	ld bc,0
042FBD FD 0F 00    0276*  	ld (iy),bc
042FC0 FD 0F 03    0277*  	ld (iy+3),bc
042FC3 C1          0278*  	pop bc
042FC4             0279*  
042FC4             0280*  ; STEP 1: UHL * E
042FC4 7B          0281*  	ld a,e
042FC5 E5          0282*  	push hl
042FC6 CD 84 2F 04 0283*  	call umul24x8
042FCA FD 2F 00    0284*  	ld (iy+0),hl
042FCD FD 77 03    0285*  	ld (iy+3),a
042FD0             0286*  
042FD0             0287*  ; STEP 2: UHL * D
042FD0 E1          0288*  	pop hl
042FD1 E5          0289*  	push hl
042FD2 7A          0290*  	ld a,d
042FD3 CD 84 2F 04 0291*  	call umul24x8
042FD7 CD E4 2F 04 0292*  	call @accumulate
042FDB             0293*  
042FDB             0294*  ; STEP 3: UHL * DEU
042FDB E1          0295*  	pop hl
042FDC D5          0296*  	push de
042FDD 33          0297*  	inc sp
042FDE F1          0298*  	pop af
042FDF 3B          0299*  	dec sp
042FE0 CD 84 2F 04 0300*  	call umul24x8
042FE4             0301*  
042FE4             0302*  @accumulate:
042FE4 FD 23       0303*  	inc iy
042FE6             0304*  ; highest byte of product to carry
042FE6 FD 77 03    0305*  	ld (iy+3),a
042FE9             0306*  ; low byte of product
042FE9 7D          0307*  	ld a,l
042FEA FD 86 00    0308*  	add a,(iy+0)
042FED FD 77 00    0309*  	ld (iy+0),a
042FF0             0310*  ; high byte of product
042FF0 7C          0311*  	ld a,h
042FF1 FD 8E 01    0312*  	adc a,(iy+1)
042FF4 FD 77 01    0313*  	ld (iy+1),a
042FF7             0314*  ; uppper byte of product
042FF7 E5          0315*  	push hl
042FF8 33          0316*  	inc sp
042FF9 E1          0317*  	pop hl
042FFA 3B          0318*  	dec sp
042FFB 7C          0319*  	ld a,h
042FFC FD 8E 02    0320*  	adc a,(iy+2)
042FFF FD 77 02    0321*  	ld (iy+2),a
043002             0322*  ; carry
043002 3E 00       0323*  	ld a,0 ; preserve flags
043004 FD 8E 03    0324*  	adc a,(iy+3)
043007 FD 77 03    0325*  	ld (iy+3),a
04300A C9          0326*  	ret
04300B             0327*  
04300B             0328*  ; UH.L = UH.L*UD.E (unsigned)
04300B             0329*  umul168:
04300B CD B3 2F 04 0330*  	call umul24x24
04300F FD 27 FF    0331*  	ld hl,(iy-1)
043012 C9          0332*  	ret
043013             0333*  
043013             0334*  ; UH.L * UD.E --> UH.L (signed)
043013             0335*  smul168:
043013             0336*  ; make everything positive and store sign flags
043013 CD 2E 25 04 0337*  	call hlu_abs
043017 F5          0338*  	push af
043018 EB          0339*  	ex de,hl
043019 CD 2E 25 04 0340*  	call hlu_abs
04301D EB          0341*  	ex de,hl
04301E F5          0342*  	push af
04301F             0343*  ; do the division
04301F CD 0B 30 04 0344*      call umul168 ; hl = product
043023             0345*  ; adjust sign of result
043023 F1          0346*  	pop af ; sign de
043024 FA 2F 30 04 0347*  	jp m,@de_neg
043028 F1          0348*  	pop af ; sign hl
043029 F0          0349*  	ret p ; both positive, nothing to do
04302A             0350*  @hl_neg:
04302A CD 3E 25 04 0351*      call neg_hlu ; de pos, hl neg, result is negative
04302E C9          0352*      ret
04302F             0353*  @de_neg:
04302F F1          0354*  	pop af
043030 F8          0355*  	ret m ; both negative, nothing to do
043031 CD 3E 25 04 0356*  	call neg_hlu ; result is negative
043035 C9          0357*  	ret
043036             0358*  
043036             0359*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
043036             0360*  ; perform unsigned division of 16.8 fixed place values
043036             0361*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
043036             0362*  udiv168:
043036             0363*  ; back up divisor
043036 ED 53 6D 30 0364*  	ld (@ude),de
       04          
04303B             0365*  ; get the 16-bit integer part of the quotient
04303B CD 9E 30 04 0366*      call udiv24 ; de = quotient, hl = remainder
04303F             0367*  ; load quotient to upper three bytes of output
04303F ED 53 74 30 0368*      ld (div168_out+1),de
       04          
043044             0369*  @div256:
043044             0370*  ; multiply remainder by 256
043044             0371*  	hlu_mul256
043044 29          0001*M         add hl,hl ; * 2
043045 29          0002*M         add hl,hl ; * 4
043046 29          0003*M         add hl,hl ; * 8
043047 29          0004*M         add hl,hl ; * 16
043048 29          0005*M         add hl,hl ; * 32
043049 29          0006*M         add hl,hl ; * 64
04304A 29          0007*M         add hl,hl ; * 128
04304B 29          0008*M         add hl,hl ; * 256
04304C             0372*  ; skip fractional computation if remainder is zero
04304C             0373*      sign_hlu
04304C 19          0001*M         add hl,de
04304D B7          0002*M         or a
04304E ED 52       0003*M         sbc hl,de
043050 20 03       0374*      jr nz,@div_frac
043052 AF          0375*      xor a
043053 18 0A       0376*      jr @write_frac
043055             0377*  ; now divide the shifted remainder by the divisor
043055             0378*  @div_frac:
043055 ED 5B 6D 30 0379*  	ld de,(@ude) ; get back divisor
       04          
04305A CD 9E 30 04 0380*      call udiv24 ; de = quotient, hl = remainder
04305E             0381*  ; load low byte of quotient to low byte of output
04305E 7B          0382*      ld a,e
04305F             0383*  @write_frac:
04305F 32 73 30 04 0384*      ld (div168_out),a
043063             0385*  ; load de with return value
043063 ED 5B 73 30 0386*      ld de,(div168_out)
       04          
043068             0387*  ; load a with any overflow
043068 3A 76 30 04 0388*      ld a,(div168_out+3)
04306C C9          0389*      ret ; ud.e is the 16.8 result
04306D             0390*  @ude: ds 6
043073             0391*  div168_out: ds 4 ; the extra byte is for overflow
043077             0392*  
043077             0393*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
043077             0394*  ; perform signed division of 16.8 fixed place values
043077             0395*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
043077             0396*  sdiv168:
043077             0397*  ; make everything positive and store sign flags
043077 CD 2E 25 04 0398*  	call hlu_abs
04307B F5          0399*  	push af
04307C EB          0400*  	ex de,hl
04307D CD 2E 25 04 0401*  	call hlu_abs
043081 EB          0402*  	ex de,hl
043082 F5          0403*  	push af
043083             0404*  ; do the division
043083 CD 36 30 04 0405*      call udiv168 ; de = quotient, hl = remainder
043087             0406*  ; adjust sign of result
043087 F1          0407*  	pop af ; sign de
043088 FA 95 30 04 0408*  	jp m,@de_neg
04308C F1          0409*  	pop af ; sign hl
04308D F0          0410*  	ret p ; both positive, nothing to do
04308E             0411*  @hl_neg:
04308E EB          0412*      ex de,hl ; hl = quotient, de = remainder
04308F CD 3E 25 04 0413*      call neg_hlu ; de pos, hl neg, result is negative
043093 EB          0414*      ex de,hl ; de = negated quotient, hl = remainder
043094 C9          0415*      ret
043095             0416*  @de_neg:
043095 F1          0417*  	pop af
043096 F8          0418*  	ret m ; both negative, nothing to do
043097 EB          0419*      ex de,hl ; hl = quotient, de = remainder
043098 CD 3E 25 04 0420*  	call neg_hlu ; result is negative
04309C EB          0421*      ex de,hl ; de = negated quotient, hl = remainder
04309D C9          0422*  	ret
04309E             0423*  
04309E             0424*  ;------------------------------------------------------------------------
04309E             0425*  ;  arith24.asm
04309E             0426*  ;  24-bit ez80 arithmetic routines
04309E             0427*  ;  Copyright (c) Shawn Sijnstra 2024
04309E             0428*  ;  MIT license
04309E             0429*  ;
04309E             0430*  ;  This library was created as a tool to help make ez80
04309E             0431*  ;  24-bit native assembly routines for simple mathematical problems
04309E             0432*  ;  more widely available.
04309E             0433*  ;
04309E             0434*  ;------------------------------------------------------------------------
04309E             0435*  ;
04309E             0436*  ;------------------------------------------------------------------------
04309E             0437*  ; udiv24
04309E             0438*  ; Unsigned 24-bit division
04309E             0439*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04309E             0440*  ;
04309E             0441*  ; Uses AF BC DE HL
04309E             0442*  ; Uses Restoring Division algorithm
04309E             0443*  ;------------------------------------------------------------------------
04309E             0444*  
04309E             0445*  udiv24:
04309E E5          0446*  	push	hl
04309F C1          0447*  	pop		bc	;move dividend to BCU
0430A0 21 00 00 00 0448*  	ld		hl,0	;result
0430A4 A7          0449*  	and		a
0430A5 ED 52       0450*  	sbc		hl,de	;test for div by 0
0430A7 C8          0451*  	ret		z		;it's zero, carry flag is clear
0430A8 19          0452*  	add		hl,de	;HL is 0 again
0430A9 3E 18       0453*  	ld		a,24	;number of loops through.
0430AB             0454*  udiv1:
0430AB C5          0455*  	push	bc	;complicated way of doing this because of lack of access to top bits
0430AC E3          0456*  	ex		(sp),hl
0430AD 37          0457*  	scf
0430AE ED 6A       0458*  	adc	hl,hl
0430B0 E3          0459*  	ex	(sp),hl
0430B1 C1          0460*  	pop	bc		;we now have bc = (bc * 2) + 1
0430B2             0461*  
0430B2 ED 6A       0462*  	adc	hl,hl
0430B4 A7          0463*  	and	a		;is this the bug
0430B5 ED 52       0464*  	sbc	hl,de
0430B7 30 02       0465*  	jr	nc,udiv2
0430B9 19          0466*  	add	hl,de
0430BA             0467*  ;	dec	c
0430BA 0B          0468*  	dec	bc
0430BB             0469*  udiv2:
0430BB 3D          0470*  	dec	a
0430BC 20 ED       0471*  	jr	nz,udiv1
0430BE 37          0472*  	scf		;flag used for div0 error
0430BF C5          0473*  	push	bc
0430C0 D1          0474*  	pop		de	;remainder
0430C1 C9          0475*  	ret
0430C2             0061   ; App-specific includes
0430C2             0062   	include "player.inc"
0430C2             0001*  ; ######## GAME STATE VARIABLES #######
0430C2             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
0430C2 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
0430C5             0004*  ; player current shields,binary
0430C5             0005*  ; when < 0 player splodes
0430C5             0006*  ; restores to player_max_shields when new ship spawns
0430C5 10          0007*  player_shields: db 16 ; binary
0430C6             0008*  ; max player shields,binary
0430C6             0009*  ; can increase with power-ups (todo)
0430C6 10          0010*  player_max_shields: db 16 ; binary
0430C7             0011*  ; when reaches zero,game ends
0430C7             0012*  ; can increase based on TODO
0430C7 03          0013*  player_ships: db 0x03 ; binary
0430C8             0014*  
0430C8             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
0430C8             0016*  ; uses the same offsets from its table base as the main sprite table:
0430C8             0017*  player_start_variables: ; label marking beginning of table
0430C8 10          0018*  player_id:               db table_max_records
0430C9 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
0430CA 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
0430CD 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0430D0 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0430D1 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0430D2 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0430D3 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0430D6 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0430D9 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0430DC 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0430DF 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0430E2 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0430E5 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
0430E8 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
0430E9 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
0430EA 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
0430EB 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
0430EC 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
0430ED 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
0430EE             0038*  player_end_variables: ; for when we want to traverse this table in reverse
0430EE             0039*  
0430EE             0040*  ; set initial player position
0430EE             0041*  ; inputs: none,everything is hardcoded
0430EE             0042*  ; outputs: player_x/y set to bottom-left corner of screen
0430EE             0043*  ; destroys: a
0430EE             0044*  player_init:
0430EE 3A C8 30 04 0045*  	ld a,(player_id)
0430F2 CD C6 23 04 0046*  	call vdu_sprite_select
0430F6 CD D9 23 04 0047*      call vdu_sprite_clear_frames
0430FA 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
0430FE CD 13 25 04 0049*      call vdu_sprite_add_buff
043102 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
043106 CD 13 25 04 0051*      call vdu_sprite_add_buff
04310A 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
04310E CD 13 25 04 0053*      call vdu_sprite_add_buff
043112 01 00 00 00 0054*      ld bc,0
043116 ED 43 D3 30 0055*      ld (player_x),bc
       04          
04311B 11 00 DF 00 0056*      ld de,0x00DF00
04311F ED 53 D6 30 0057*      ld (player_y),de
       04          
043124 CD 92 24 04 0058*      call vdu_sprite_move_abs168
043128 CD 3C 24 04 0059*      call vdu_sprite_show
04312C C9          0060*      ret
04312D             0061*  
04312D             0062*  ; process player keyboard input, set player bitmap
04312D             0063*  ; velocities and draw player bitmap at updated coordinates
04312D             0064*  ; Inputs: player_x/y set at desired position
04312D             0065*  ; Returns: player bitmap drawn at updated position
04312D             0066*  ; Destroys: probably everything except maybe iy
04312D             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04312D             0068*  ; TODO: requires sprite implementation
04312D             0069*  player_input:
04312D             0070*  ; reset player component velocities to zero as the default
04312D 21 00 00 00 0071*  	ld hl,0
043131 22 D9 30 04 0072*  	ld (player_xvel),hl
043135 22 DC 30 04 0073*  	ld (player_yvel),hl
043139             0074*  ; make ship the active sprite
043139 3A C8 30 04 0075*      ld a,(player_id)
04313D CD C6 23 04 0076*      call vdu_sprite_select
043141             0077*  ; check for keypresses and branch accordingly
043141             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043141             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043141 3E 1E       0001*M 			LD	A, function
043143 5B CF       0002*M 			RST.LIL	08h
043145             0080*  ; we test all four arrow keys and add/subract velocities accordingly
043145             0081*  ; this handles the case where two opposing movement keys
043145             0082*  ; are down simultaneously (velocities will net to zero)
043145             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
043145             0084*  ; it also allows movement and action keys to be detected simultaneously
043145             0085*  ; so we can walk and chew gum at the same time
043145 3E 01       0086*      ld a,1 ; set ship's default animation to center
043147             0087*          ; if left and right are both down a will net to
043147             0088*  
043147             0089*  @left:
043147 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
04314B 28 0E       0091*      jr z,@right
04314D 2A D9 30 04 0092*      ld hl,(player_xvel)
043151 01 00 FD FF 0093*      ld bc,-speed_player
043155 09          0094*      add hl,bc
043156 22 D9 30 04 0095*      ld (player_xvel),hl
04315A 3D          0096*      dec a ; set ship's animation to left
04315B             0097*  @right:
04315B DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
04315F 28 0E       0099*  	jr z,@up
043161 2A D9 30 04 0100*      ld hl,(player_xvel)
043165 01 00 03 00 0101*      ld bc,speed_player
043169 09          0102*      add hl,bc
04316A 22 D9 30 04 0103*      ld (player_xvel),hl
04316E 3C          0104*      inc a ; set ship's animation to right
04316F             0105*  @up:
04316F DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
043173 28 0D       0107*  	jr z,@down
043175 2A DC 30 04 0108*      ld hl,(player_yvel)
043179 01 00 FD FF 0109*      ld bc,-speed_player
04317D 09          0110*      add hl,bc
04317E 22 DC 30 04 0111*      ld (player_yvel),hl
043182             0112*  @down:
043182 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
043186 28 0D       0114*  	jr z,@done_keyboard
043188 2A DC 30 04 0115*      ld hl,(player_yvel)
04318C 01 00 03 00 0116*      ld bc,speed_player
043190 09          0117*      add hl,bc
043191 22 DC 30 04 0118*      ld (player_yvel),hl
043195             0119*  @done_keyboard:
043195             0120*  ; move player sprite according to velocities set by keypresses
043195 2A D9 30 04 0121*      ld hl,(player_xvel)
043199             0122*  ; compute new x position
043199 ED 5B D3 30 0123*      ld de,(player_x)
       04          
04319E 19          0124*      add hl,de ; hl = player_x + player_xvel
04319F             0125*      ; check for horizontal screen edge collisions
04319F             0126*      ; and adjust coordinate as necessary
04319F             0127*  ; TODO: make this work using 24-bit registers
04319F             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
04319F             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
04319F             0130*      ; ld a,8 ; set x to leftmost allowable position
04319F             0131*  ; @check_right:
04319F             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
04319F             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
04319F             0134*  ;     ld a,248 ; set x to rightmost allowable position
04319F             0135*  @x_ok:
04319F             0136*  ; save the updated drawing coordinate
04319F 22 D3 30 04 0137*      ld (player_x),hl
0431A3             0138*  ;compute new y position
0431A3 2A D6 30 04 0139*      ld hl,(player_y)
0431A7 ED 5B DC 30 0140*      ld de,(player_yvel)
       04          
0431AC 19          0141*      add hl,de ; hl = player_y + player_yvel
0431AD             0142*  ; TODO: make this work using 24-bit registers
0431AD             0143*  ;     ; check for vertical screen edge collisions
0431AD             0144*  ;     ; and adjust coordinate as necessary
0431AD             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
0431AD             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0431AD             0147*  ;     ld a,8 ; set y to topmost allowable position
0431AD             0148*  ; @check_top:
0431AD             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
0431AD             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
0431AD             0151*  ;     ld a,232 ; set y to bottommost allowable position
0431AD             0152*  @y_ok:
0431AD 22 D6 30 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
0431B1             0154*  ; a should land here loaded with the correct frame
0431B1 CD 29 24 04 0155*      call vdu_sprite_select_frame
0431B5             0156*  ; draw player at updated position
0431B5 ED 4B D3 30 0157*      ld bc,(player_x)
       04          
0431BA ED 5B D6 30 0158*  	ld de,(player_y)
       04          
0431BF             0159*  
0431BF             0160*      ; call dumpRegistersHex
0431BF             0161*  
0431BF CD 92 24 04 0162*  	call vdu_sprite_move_abs168
0431C3             0163*  
0431C3             0164*  ; end player_input
0431C3 C9          0165*  	ret
0431C4             0166*  
0431C4             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
0431C4             0168*  ; ; INSTEAD OF FRACTIONAL
0431C4             0169*  ; ; ----------------------------------------------------------------
0431C4             0170*  ; ; process player keyboard input, set player bitmap
0431C4             0171*  ; ; velocities and draw player bitmap at updated coordinates
0431C4             0172*  ; ; Inputs: player_x/y set at desired position
0431C4             0173*  ; ; Returns: player bitmap drawn at updated position
0431C4             0174*  ; ; Destroys: probably everything except maybe iy
0431C4             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
0431C4             0176*  ; ; TODO: requires sprite implementation
0431C4             0177*  ; player_input:
0431C4             0178*  ; ; reset player component velocities to zero as the default
0431C4             0179*  ; 	ld hl,0
0431C4             0180*  ; 	ld (player_xvel),hl
0431C4             0181*  ; 	ld (player_yvel),hl
0431C4             0182*  ; ; check for keypresses and branch accordingly
0431C4             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0431C4             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0431C4             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
0431C4             0186*  ; ; this handles the case where two opposing movement keys
0431C4             0187*  ; ; are down simultaneously (velocities will net to zero)
0431C4             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
0431C4             0189*  ; ; it also allows movement and action keys to be detected simultaneously
0431C4             0190*  ; ; so we can walk and chew gum at the same time
0431C4             0191*  ; @left:
0431C4             0192*  ;     bit 1,(ix+3) ; keycode 26
0431C4             0193*  ;     jr z,@right
0431C4             0194*  ;     ld hl,(player_xvel)
0431C4             0195*  ;     ld bc,-3
0431C4             0196*  ;     add hl,bc
0431C4             0197*  ;     ld (player_xvel),hl
0431C4             0198*  ; @right:
0431C4             0199*  ;     bit 1,(ix+15) ; keycode 122
0431C4             0200*  ; 	jr z,@up
0431C4             0201*  ;     ld hl,(player_xvel)
0431C4             0202*  ;     ld bc,3
0431C4             0203*  ;     add hl,bc
0431C4             0204*  ;     ld (player_xvel),hl
0431C4             0205*  ; @up:
0431C4             0206*  ;     bit 1,(ix+7) ; keycode 58
0431C4             0207*  ; 	jr z,@down
0431C4             0208*  ;     ld hl,(player_yvel)
0431C4             0209*  ;     ld bc,-3
0431C4             0210*  ;     add hl,bc
0431C4             0211*  ;     ld (player_yvel),hl
0431C4             0212*  ; @down:
0431C4             0213*  ;     bit 1,(ix+5) ; keycode 42
0431C4             0214*  ; 	jr z,@done_keyboard
0431C4             0215*  ;     ld hl,(player_yvel)
0431C4             0216*  ;     ld bc,3
0431C4             0217*  ;     add hl,bc
0431C4             0218*  ;     ld (player_yvel),hl
0431C4             0219*  ; @done_keyboard:
0431C4             0220*  ; ; move player sprite according to velocities set by keypresses
0431C4             0221*  ;     ld hl,(player_xvel)
0431C4             0222*  ; ; compute new x position
0431C4             0223*  ;     ld de,(player_x)
0431C4             0224*  ;     add hl,de ; hl = player_x + player_xvel
0431C4             0225*  ;     ; check for horizontal screen edge collisions
0431C4             0226*  ;     ; and adjust coordinate as necessary
0431C4             0227*  ; ; TODO: make this work using 24-bit registers
0431C4             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
0431C4             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
0431C4             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
0431C4             0231*  ; ; @check_right:
0431C4             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
0431C4             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
0431C4             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
0431C4             0235*  ; @x_ok:
0431C4             0236*  ;     ; save the updated drawing coordinate
0431C4             0237*  ;     ld (player_x),hl
0431C4             0238*  ; ;compute new y position
0431C4             0239*  ;     ld hl,(player_y)
0431C4             0240*  ;     ld de,(player_yvel)
0431C4             0241*  ;     add hl,de ; hl = player_y + player_yvel
0431C4             0242*  ; ; TODO: make this work using 24-bit registers
0431C4             0243*  ; ;     ; check for vertical screen edge collisions
0431C4             0244*  ; ;     ; and adjust coordinate as necessary
0431C4             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
0431C4             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
0431C4             0247*  ; ;     ld a,8 ; set y to topmost allowable position
0431C4             0248*  ; ; @check_top:
0431C4             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
0431C4             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
0431C4             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
0431C4             0252*  ; @y_ok:
0431C4             0253*  ;     ld (player_y),hl
0431C4             0254*  ; ; draw player at updated position
0431C4             0255*  ;     ld a,(player_id)
0431C4             0256*  ;     call vdu_sprite_select
0431C4             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
0431C4             0258*  ;     call get_sign_hlu ; to set the proper animation
0431C4             0259*  ;     add a,1 ; ...
0431C4             0260*  ;     call vdu_sprite_select_frame
0431C4             0261*  ;     ld bc,(player_x)
0431C4             0262*  ; 	ld de,(player_y)
0431C4             0263*  ; 	call vdu_sprite_move_abs
0431C4             0264*  ; ; end player_input
0431C4             0265*  ; 	ret
0431C4             0266*  
0431C4             0267*  
0431C4             0268*  ; ###################################################################
0431C4             0269*  ; TODO: the below is all stuff from the original code we need to port
0431C4             0270*  ; ###################################################################
0431C4             0271*  
0431C4             0272*  ; kill_player:
0431C4             0273*  ; ; set player status to dead
0431C4             0274*  ;     xor a; sets all player flags to zero
0431C4             0275*  ;     ld (player_collisions),a
0431C4             0276*  ; ; deduct a ship from the inventory
0431C4             0277*  ;     ld a,(player_ships)
0431C4             0278*  ;     dec a
0431C4             0279*  ;     ld (player_ships),a
0431C4             0280*  ; ; are we out of ships?
0431C4             0281*  ;     jp z,game_over
0431C4             0282*  ; ; wait a few ticks
0431C4             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
0431C4             0284*  ;     ld (player_move_timer),a
0431C4             0285*  ; kill_player_loop:
0431C4             0286*  ;     call vdu_vblank
0431C4             0287*  ;     ld a,(player_move_timer)
0431C4             0288*  ;     dec a
0431C4             0289*  ;     ld (player_move_timer),a
0431C4             0290*  ;     jr nz,kill_player_loop
0431C4             0291*  ;     call player_init ; player respawn if timer zero
0431C4             0292*  ;     ret ; and out
0431C4             0293*  
0431C4             0294*  
0431C4             0295*  ; player_move:
0431C4             0296*  ; ; begin setting player to active sprite
0431C4             0297*  ;     ld hl,player
0431C4             0298*  ;     ld (sprite_base_bufferId),hl
0431C4             0299*  ;     ld hl,0 ; north
0431C4             0300*  ;     ld (sprite_heading),hl
0431C4             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
0431C4             0302*  ;     ld (sprite_animation),a
0431C4             0303*  ;     ; we set position here for the time being as a default
0431C4             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
0431C4             0305*  ;     ld hl,(player_x)
0431C4             0306*  ;     ld (sprite_x),hl
0431C4             0307*  ;     ld hl,(player_y)
0431C4             0308*  ;     ld (sprite_y),hl
0431C4             0309*  ; ; did we just die?
0431C4             0310*  ;     ld a,(player_collisions)
0431C4             0311*  ;     and %00000010 ; zero flag will be set if not dead
0431C4             0312*  ;     jr z,player_not_dead
0431C4             0313*  ; ; yes we died
0431C4             0314*  ;     call kill_player
0431C4             0315*  ;     ret ; done
0431C4             0316*  ; ; yay we didn't die
0431C4             0317*  ; player_not_dead:
0431C4             0318*  ; ; set player movements to zero by default
0431C4             0319*  ;     ld hl,0
0431C4             0320*  ;     ld (player_xvel),hl
0431C4             0321*  ;     ld (player_yvel),hl
0431C4             0322*  ; ; do we move it?
0431C4             0323*  ;     in a,(#82) ; keyboard
0431C4             0324*  ;     or a ; if zero,don't move
0431C4             0325*  ;     jr z,player_draw
0431C4             0326*  ; ; move it
0431C4             0327*  ;     call player_move_calc
0431C4             0328*  ; player_draw:
0431C4             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0431C4             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0431C4             0331*  ; player_move_done:
0431C4             0332*  ;     ; write updated x,y coordinates back to player table
0431C4             0333*  ;     ld hl,(sprite_x)
0431C4             0334*  ;     ld (player_x),hl
0431C4             0335*  ;     ld hl,(sprite_y)
0431C4             0336*  ;     ld (player_y),hl
0431C4             0337*  ;     ret
0431C4             0063   	include "tiles.inc"
0431C4             0001*  ; ######### TILES #########
0431C4             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
0431C4             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
0431C4 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
0431C7 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
0431C8             0006*                          ; initialize to zero for a maximum of 256 rows in a level
0431C8 00          0007*  cur_level: db 0
0431C9             0008*  num_levels: equ 2 ; number of levels,duh
0431C9             0009*  
0431C9             0010*  ; lookup table for level definitions
0431C9 E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
0431CF             0012*  
0431CF             0013*  ; tiles_bufferId: dl 0
0431CF 00 00 00    0014*  tiles_x_plot: dl 0
0431D2 F1 FF FF    0015*  tiles_y_plot: dl -15
0431D5             0016*  
0431D5             0017*  
0431D5             0018*  tiles_plot:
0431D5             0019*  ; set gfx viewport to playing field window
0431D5 01 00 00 00 0020*  	ld bc,field_left
0431D9 11 00 00 00 0021*  	ld de,field_top
0431DD DD 21 FF 00 0022*  	ld ix,field_right
       00          
0431E2 FD 21 7F 01 0023*  	ld iy,field_bottom
       00          
0431E7 CD 0F 20 04 0024*  	call vdu_set_gfx_viewport
0431EB             0025*  ; move the background down one pixel
0431EB 3E 02       0026*  	ld a,2 ; current gfx viewport
0431ED 2E 02       0027*  	ld l,2 ; direction=down
0431EF 26 01       0028*  	ld h,1 ; speed=1 px
0431F1 CD 87 1F 04 0029*  	call vdu_scroll_down
0431F5             0030*  ; draw a line for the bg color
0431F5 3E 44       0031*      ld a,plot_pt+mv_abs
0431F7 01 00 00 00 0032*      ld bc,0 ; leftmost x-coord
0431FB 11 00 00 00 0033*      ld de,0 ; topmost y-coord
0431FF CD 05 23 04 0034*      call vdu_plot
043203 3E 07       0035*      ld a,plot_sl_both+dr_abs_bg
043205 01 FF 00 00 0036*      ld bc,255 ; rightmost x-coord
043209 11 00 00 00 0037*      ld de,0 ; bottommost y-coord
04320D CD 05 23 04 0038*      call vdu_plot
043211             0039*  ; set gfx viewport to one scanline to optimise plotting tiles
043211 01 00 00 00 0040*  	ld bc,0 ; leftmost x-coord
043215 11 00 00 00 0041*  	ld de,0 ; topmost y-coord
043219 DD 21 FF 00 0042*  	ld ix,255 ; rightmost x-coord
       00          
04321E FD 21 00 00 0043*  	ld iy,0 ; bottommost y-coord
       00          
043223 CD 0F 20 04 0044*  	call vdu_set_gfx_viewport
043227             0045*  ; initialize loop
043227 21 00 00 00 0046*      ld hl,0 ; init plotting x-coordinate
04322B 22 CF 31 04 0047*      ld (tiles_x_plot),hl
04322F 2A C4 31 04 0048*      ld hl,(tiles_row_defs)
043233 06 10       0049*  	ld b,16 ; loop counter
043235             0050*  @loop:
043235 C5          0051*  	push bc ; save the loop counter
043236             0052*  ; read the tile defintion for the current column
043236 7E          0053*      ld a,(hl) ; a has tile definition
043237 E5          0054*      push hl  ; save pointer to tile definition
043238 21 00 00 00 0055*      ld hl,0 ; hlu is non-zero
04323C 6F          0056*      ld l,a ; l is tile defintion
04323D 26 01       0057*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
04323F CD 5C 20 04 0058*      call vdu_buff_select ; tile bitmap buffer is now active
043243             0059*  
043243             0060*  ; plot the active bitmap
043243 ED 4B CF 31 0061*      ld bc,(tiles_x_plot)
       04          
043248 ED 5B D2 31 0062*      ld de,(tiles_y_plot)
       04          
04324D CD 25 23 04 0063*      call vdu_plot_bmp
043251             0064*  
043251             0065*  ; bump x-coords the width of one tile and save it
043251 2A CF 31 04 0066*      ld hl,(tiles_x_plot)
043255 01 10 00 00 0067*      ld bc,16
043259 09          0068*      add hl,bc
04325A 22 CF 31 04 0069*      ld (tiles_x_plot),hl
04325E             0070*  
04325E             0071*  ; prepare to loop to next column
04325E E1          0072*      pop hl ; get back pointer to tile def
04325F 23          0073*      inc hl ; bump it to the next column
043260 C1          0074*  	pop bc ; snag our loop counter
043261 10 D2       0075*      djnz @loop
043263             0076*  
043263             0077*  ; increment tiles plotting y-coordinate
043263             0078*  ; when it hits zero, we go to next row of tiles in the map
043263             0079*  ; (we use ix b/c we want to preserve hl for the next step)
043263 DD 21 D2 31 0080*  	ld ix,tiles_y_plot
       04          
043268 DD 34 00    0081*  	inc (ix)
04326B C0          0082*  	ret nz
04326C             0083*  
04326C             0084*  ; time to bump tiles_row_defs to next row
04326C             0085*  ; (hl was already there at the end of the loop)
04326C 22 C4 31 04 0086*      ld (tiles_row_defs),hl
043270             0087*  
043270             0088*  ; reset coords to plot next row of tiles
043270 21 00 00 00 0089*      ld hl,0
043274 22 CF 31 04 0090*      ld (tiles_x_plot),hl
043278 21 F1 FF FF 0091*      ld hl,-15
04327C 22 D2 31 04 0092*      ld (tiles_y_plot),hl
043280             0093*  
043280             0094*  ; decrement tiles row counter
043280 21 C7 31 04 0095*      ld hl,tiles_row
043284 35          0096*      dec (hl)
043285 C0          0097*      ret nz
043286             0098*  
043286             0099*  ; queue up next level
043286 3A C8 31 04 0100*      ld a,(cur_level)
04328A FE 01       0101*      cp num_levels-1
04328C 20 02       0102*      jr nz,@inc_level
04328E 3E FF       0103*      ld a,-1 ; will wrap around to zero when we fall through
043290             0104*  
043290             0105*  @inc_level:
043290 3C          0106*      inc a
043291 32 C8 31 04 0107*      ld (cur_level),a
043295             0108*  
043295             0109*  ; increase the number of enemy sprites
043295 3A DC 32 04 0110*      ld a,(max_enemy_sprites)
043299 3C          0111*      inc a
04329A FE 10       0112*      cp table_max_records ; if we're at the global limit,skip ahead at max level
04329C 28 04       0113*      jr z,init_level
04329E 32 DC 32 04 0114*      ld (max_enemy_sprites),a ; otherwise save the updated number
0432A2             0115*  ; fall through to init_level
0432A2             0116*  
0432A2             0117*  init_level:
0432A2             0118*  ; look up address of level's tile defintion
0432A2 21 C9 31 04 0119*      ld hl,tiles_levels
0432A6 3A C8 31 04 0120*      ld a,(cur_level)
0432AA 11 00 00 00 0121*      ld de,0 ; just in case deu is non-zero
0432AE 57          0122*      ld d,a
0432AF 1E 03       0123*      ld e,3
0432B1 ED 5C       0124*      mlt de
0432B3 19          0125*      add hl,de
0432B4 ED 37       0126*      ld ix,(hl)
0432B6 DD 22 C4 31 0127*      ld (tiles_row_defs),ix
       04          
0432BB             0128*  
0432BB             0129*  ; set tiles_row counter
0432BB DD 7E 00    0130*      ld a,(ix)
0432BE 32 C7 31 04 0131*      ld (tiles_row),a
0432C2 DD 23       0132*      inc ix ; now ix points first element of first row tile def
0432C4 DD 22 C4 31 0133*      ld (tiles_row_defs),ix ; ... so we save it
       04          
0432C9 C9          0134*      ret
0432CA             0135*  
0432CA             0136*  
0432CA             0137*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
0432CA             0138*  ; dt_is_active:
0432CA             0139*  ; ; a lands here containing a tile index in the low nibble
0432CA             0140*  ; ; we test the values for the tiles which are active
0432CA             0141*  ;     cp #07
0432CA             0142*  ;     call z,ld_act_landing_pad
0432CA             0143*  ;     cp #08
0432CA             0144*  ;     call z,ld_act_laser_turret
0432CA             0145*  ;     ; fall through
0432CA             0146*  ;     ret
0432CA             0147*  
0432CA             0148*  ; ; some tiles become active sprites,so we load those here
0432CA             0149*  ; ; sprite_x/y have already been loaded
0432CA             0150*  ; ; sprite_dim_x/y are loaded by table_add_record
0432CA             0151*  ; ; we don't want sprite drawn to background like other tiles
0432CA             0152*  ; ; so this routine only adds them to the sprite table
0432CA             0153*  ; dt_ld_act:
0432CA             0154*  ;     ld a,#48 ; top of screen + 1/2 tile height
0432CA             0155*  ;     ld (sprite_y+1),a ; just the integer part
0432CA             0156*  ;     ld (sprite_base_bufferId),hl
0432CA             0157*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0432CA             0158*  ;     call table_add_record
0432CA             0159*  ;     call sprite_variables_from_stack
0432CA             0160*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
0432CA             0161*  ;     ret ; and back
0432CA             0162*  
0432CA             0163*  ; ld_act_landing_pad:
0432CA             0164*  ;     call sprite_variables_to_stack
0432CA             0165*  
0432CA             0166*  ;     ld hl,move_landing_pad
0432CA             0167*  ;     ld (sprite_move_program),hl
0432CA             0168*  
0432CA             0169*  ;     xor a
0432CA             0170*  ;     ld (sprite_animation),a ; animation 0
0432CA             0171*  
0432CA             0172*  ;     call rand_8     ; snag a random number
0432CA             0173*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0432CA             0174*  ;     add a,64 ; range is now 64-127
0432CA             0175*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0432CA             0176*  
0432CA             0177*  ;     ld a,%10 ; collides with laser but not player
0432CA             0178*  ;     ld (iy+sprite_collisions),a
0432CA             0179*  
0432CA             0180*  ;     ld a,#05 ; BCD
0432CA             0181*  ;     ld (sprite_points),a
0432CA             0182*  ;     ld a,0 ; binary
0432CA             0183*  ;     ld (sprite_shield_damage),a
0432CA             0184*  
0432CA             0185*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
0432CA             0186*  ;     jr dt_ld_act
0432CA             0187*  
0432CA             0188*  ; ld_act_laser_turret:
0432CA             0189*  ;     call sprite_variables_to_stack
0432CA             0190*  
0432CA             0191*  ;     ld hl,move_laser_turret
0432CA             0192*  ;     ld (sprite_move_program),hl
0432CA             0193*  
0432CA             0194*  ;     xor a
0432CA             0195*  ;     ld (sprite_animation),a
0432CA             0196*  ;     ld (sprite_move_step),a
0432CA             0197*  
0432CA             0198*  ;     call rand_8     ; snag a random number
0432CA             0199*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0432CA             0200*  ;     add a,64 ; range is now 64-127
0432CA             0201*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0432CA             0202*  
0432CA             0203*  ;     ld a,%10 ; collides with laser but not player
0432CA             0204*  ;     ld (iy+sprite_collisions),a
0432CA             0205*  
0432CA             0206*  ;     ld a,#10 ; BCD
0432CA             0207*  ;     ld (sprite_points),a
0432CA             0208*  ;     ld a,0 ; binary
0432CA             0209*  ;     ld (sprite_shield_damage),a
0432CA             0210*  
0432CA             0211*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
0432CA             0212*  ;     jp dt_ld_act
0432CA             0213*  
0432CA             0214*  
0432CA             0215*  ; moves active tile sprites down one pixel in sync with tiles movement
0432CA             0216*  ; deletes sprites from table when they wrap around to top of screen
0432CA             0217*  move_active_tiles:
0432CA             0218*  ; get current position
0432CA 3A 0F 00 00 0219*      ld a,(sprite_y+1) ; we only need the integer part
0432CE 3C          0220*      inc a
0432CF             0221*  ; are we at the bottom of the screen?
0432CF 20 06       0222*      jr nz,move_active_tiles_draw_sprite ; nope
0432D1             0223*  ; otherwise kill sprite
0432D1 3E 80       0224*      ld a,%10000000 ; any bit set in high nibble means sprite will die
0432D3 FD 77 08    0225*      ld (iy+sprite_collisions),a
0432D6 C9          0226*      ret ; debug
0432D7             0227*  move_active_tiles_draw_sprite:
0432D7 32 0F 00 00 0228*      ld (sprite_y+1),a ; update tile y position integer part
0432DB             0229*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0432DB             0230*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
0432DB C9          0231*      ret ; and done
0432DC             0064   	include "enemies.inc"
0432DC 10          0001*  max_enemy_sprites: db 16
0432DD             0002*  
0432DD             0003*  ; sprite_type
0432DD             0004*  enemy_dead: equ 0
0432DD             0005*  enemy_small: equ 1
0432DD             0006*  enemy_medium: equ 2
0432DD             0007*  enemy_large: equ 3
0432DD             0008*  landing_pad: equ 4
0432DD             0009*  laser_turret: equ 5
0432DD             0010*  fireballs: equ 6
0432DD             0011*  explosion: equ 7
0432DD             0012*  
0432DD             0013*  
0432DD             0014*  respawn_countdown:
0432DD 2A FE 32 04 0015*      ld hl,(respawn_timer)
0432E1 2B          0016*      dec hl
0432E2 22 FE 32 04 0017*      ld (respawn_timer),hl
0432E6             0018*  ; check hl for zero
0432E6 19          0019*      add hl,de
0432E7 B7          0020*      or a
0432E8 ED 52       0021*      sbc hl,de
0432EA C0          0022*      ret nz
0432EB 06 10       0023*      ld b,table_max_records
0432ED             0024*  @respawn_loop:
0432ED C5          0025*      push bc
0432EE CD F9 33 04 0026*      call enemy_init_from_landing_pad
0432F2 C1          0027*      pop bc
0432F3 10 F8       0028*      djnz @respawn_loop
0432F5 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
0432F9 22 FE 32 04 0030*      ld (respawn_timer),hl
0432FD C9          0031*      ret
0432FE 3C 00 00    0032*  respawn_timer: dl 1*60
043301             0033*  
043301             0034*  move_enemies:
043301             0035*  ; are there any active enemies or explosions?
043301 21 00 00 00 0036*      ld hl,0
043305 3A 45 18 04 0037*      ld a,(table_active_sprites)
043309 6F          0038*      ld l,a
04330A             0039*      ; call dumpRegistersHex
04330A A7          0040*      and a ; will be zero if no alive enemies or explosions
04330B             0041*      ; ret z ; so nothing to do but go back
04330B             0042*      ; ld hl,(respawn_timer)
04330B             0043*      ; call dumpRegistersHex
04330B 20 05       0044*      jr nz,move_enemies_do
04330D CD DD 32 04 0045*      call respawn_countdown
043311 C9          0046*      ret
043312             0047*  move_enemies_do:
043312             0048*  ; initialize pointers and loop counter
043312 FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
043317 06 10       0050*      ld b,table_max_records ; loop counter
043319             0051*  move_enemies_loop:
043319 FD 22 42 18 0052*      ld (table_pointer),iy ; update table pointer
       04          
04331E C5          0053*      push bc ; backup loop counter
04331F             0054*  ; check sprite_type to see if sprite is active
04331F FD 7E 01    0055*      ld a,(iy+sprite_type)
043322 A7          0056*      and a ; if zero, sprite is dead
043323 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
043325             0058*  ; otherwise we prepare to move the sprite
043325 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
043328 CD C6 23 04 0060*      call vdu_sprite_select ; select sprite
04332C FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
04332F E9          0062*      jp (hl)  ; ... and jump to it
043330             0063*  ; we always jp back here from behavior subroutines
043330             0064*  move_enemies_loop_return:
043330 FD 2A 42 18 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
043335             0066*  ; now we check results of all the moves
043335 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
043338 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
04333A FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
04333D 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
04333F CD 8E 18 04 0071*      call table_deactivate_sprite ; otherwise we ded
043343 AF          0072*      xor a ; zero a so that we can ...
043344 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
043347 18 0A       0074*      jr move_enemies_next_record ; and to the next record
043349             0075*  move_enemies_draw_sprite:
043349             0076*  ; if we got here sprite will have already been activated
043349             0077*  ; so all we need to do is set its coordinates and draw it
043349 FD 07 0B    0078*      ld bc,(iy+sprite_x)
04334C FD 17 0E    0079*      ld de,(iy+sprite_y)
04334F CD 92 24 04 0080*      call vdu_sprite_move_abs168
043353             0081*  ; fall through to next record
043353             0082*  move_enemies_next_record:
043353 11 26 00 00 0083*      ld de,table_bytes_per_record
043357 FD 19       0084*      add iy,de ; point to next record
043359 AF          0085*      xor a ; clears carry flag
04335A 32 46 18 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
04335E C1          0087*      pop bc ; get back our loop counter
04335F 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
043361 C9          0089*      ret ; and we're out
043362             0090*  
043362             0091*  en_nav_zigzag_start:
043362 FD 2A 42 18 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043367 CD E3 25 04 0093*      call rand_8
04336B E6 3F       0094*      and %00111111 ; limit it to 64
04336D CB DF       0095*      set 3,a ; make sure it's at least 8
04336F FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
043372             0097*      ; fall through to en_nav_zigzag
043372             0098*  en_nav_zigzag:
043372 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
043375 3D          0100*      dec a
043376 FD 77 22    0101*      ld (iy+sprite_move_timer),a
043379 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
04337B             0103*      ; otherwise flip direction and restart timer
04337B FD 7E 23    0104*      ld a,(iy+sprite_move_step)
04337E EE 01       0105*      xor %1 ; flips bit one
043380 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
043383 20 09       0107*      jr nz,en_nav_zigzag_right
043385             0108*  ;otherwise zag left
043385 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
043389 FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
04338C 18 D4       0111*      jr en_nav_zigzag_start
04338E             0112*  en_nav_zigzag_right:
04338E 21 00 60 00 0113*      ld hl,0x006000; southeast heading
043392 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
043395 18 CB       0115*      jr en_nav_zigzag_start
043397             0116*  en_nav_zigzag_no_switch:
043397             0117*      ; ld a,(sprite_orientation)
043397 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
04339A 18 13       0119*      jr en_nav_computevelocities
04339C             0120*  
04339C             0121*  ; contains the logic for how to move the enemy
04339C             0122*  ; and then does the moving
04339C             0123*  ; inputs: a fully-populated active sprite table
04339C             0124*  ;         player position variables
04339C             0125*  ; destroys: everything except index registers
04339C             0126*  ; outputs: moving enemies
04339C             0127*  en_nav:
04339C             0128*  ; set velocity and orientation by player's relative location
04339C             0129*  ; move enemies y-axis
04339C             0130*  ; where is player relative to us?
04339C CD 7C 34 04 0131*      call orientation_to_player ; uh.l angle to player, ub.c, ud.e = dx, dy
0433A0             0132*  ; is player above or below us?
0433A0 ED 53 3B 1E 0133*      ld (ude),de ; dy
       04          
0433A5 3A 3D 1E 04 0134*      ld a,(ude+2) ; deu
0433A9 17          0135*      rla ; shift sign bit into carry
0433AA 30 C6       0136*      jr nc,en_nav_zigzag ; player is below,evade
0433AC             0137*  ; player is even or above,so home in on current heading
0433AC FD 2F 1A    0138*      ld (iy+sprite_heading),hl ; save sprite heading
0433AF             0139*  
0433AF             0140*  ; we land here from zig-zag program so as not to
0433AF             0141*  ; redundantly save orientation and heading
0433AF             0142*  en_nav_computevelocities:
0433AF             0143*  ; set x/y component velocities based on bearing to player
0433AF FD 2A 42 18 0144*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0433B4 E5          0145*      push hl ; we need it back to set rotation frame
0433B5 FD 17 17    0146*      ld de,(iy+sprite_vel)
0433B8 CD 3C 26 04 0147*      call polar_to_cartesian
0433BC FD 2A 42 18 0148*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0433C1 FD 0F 11    0149*      ld (iy+sprite_xvel),bc ; save x-velocity component
0433C4 FD 1F 14    0150*      ld (iy+sprite_yvel),de ; save y-velocity component
0433C7             0151*  ; change the animation frame to match heading
0433C7             0152*  ; by dividng the heading by 8
0433C7 E1          0153*      pop hl ; get back Heading
0433C8 7C          0154*      ld a,h
0433C9 CB 3F       0155*      srl a
0433CB CB 3F       0156*      srl a
0433CD CB 3F       0157*      srl a
0433CF CD 29 24 04 0158*      call vdu_sprite_select_frame
0433D3             0159*  
0433D3             0160*  move_enemy_sprite:
0433D3 FD 2A 42 18 0161*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0433D8 FD 27 0B    0162*      ld hl,(iy+sprite_x)
0433DB FD 17 11    0163*      ld de,(iy+sprite_xvel)
0433DE 19          0164*      add hl,de
0433DF FD 2F 0B    0165*      ld (iy+sprite_x),hl
0433E2 FD 27 0E    0166*      ld hl,(iy+sprite_y)
0433E5 FD 17 14    0167*      ld de,(iy+sprite_yvel)
0433E8 19          0168*      add hl,de
0433E9 FD 2F 0E    0169*      ld (iy+sprite_y),hl
0433EC C9          0170*      ret
0433ED             0171*  
0433ED             0172*  ; ; TODO: IMPLEMENT THIS PROPERLY
0433ED             0173*  ; move_enemy_sprite:
0433ED             0174*  ; ; x-axis movement first
0433ED             0175*  ;     ld hl,(iy+sprite_x)
0433ED             0176*  ;     push hl ; save pre-move position
0433ED             0177*  ;     pop bc ; to detect screen edge collision
0433ED             0178*  ;     ld de,(iy+sprite_xvel)
0433ED             0179*  ;     add hl,de ;compute new x position
0433ED             0180*  ;     ld (iy+sprite_x),hl ; store it
0433ED             0181*  ;     and a ; clear the carry flag
0433ED             0182*  ;     sbc hl,bc ; test which direction was our movement
0433ED             0183*  ;     jr z,@move_y ; zero flag means no horizontal movement
0433ED             0184*  ;     jp p,@move_right ; sign positive means moved right
0433ED             0185*  ; @move_left: ; otherwise we moved left
0433ED             0186*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
0433ED             0187*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
0433ED             0188*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
0433ED             0189*  ;     ld a,#20 ; west
0433ED             0190*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
0433ED             0191*  ;     jr @move_y
0433ED             0192*  ; @move_right:
0433ED             0193*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
0433ED             0194*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
0433ED             0195*  ;     ld l,0x00
0433ED             0196*  ;     ld a,(iy+sprite_dim_x)
0433ED             0197*  ;     ld h,a
0433ED             0198*  ;     ld a,0x00
0433ED             0199*  ;     sub h
0433ED             0200*  ;     ld h,a
0433ED             0201*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
0433ED             0202*  ;     ld a,0x02 ; east
0433ED             0203*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
0433ED             0204*  ; @move_y:
0433ED             0205*  ;     ld hl,(iy+sprite_y)
0433ED             0206*  ;     ld b,h ; save pre-move position
0433ED             0207*  ;     ld c,l ; to detect screen edge collision
0433ED             0208*  ;     ld de,(iy+sprite_yvel)
0433ED             0209*  ;     add hl,de ;compute new y position
0433ED             0210*  ;     ld (iy+sprite_y),hl ; store it
0433ED             0211*  ;     and a ; clear the carry flag
0433ED             0212*  ;     sbc hl,bc ; test which direction was our movement
0433ED             0213*  ;     jr z,@move_ret ; zero flag means no vertical movement
0433ED             0214*  ;     jp p,@move_dn ; sign positive means moved down
0433ED             0215*  ; @move_up:
0433ED             0216*  ;     add hl,bc ; get back new y position
0433ED             0217*  ;     ld de,0x5000 ; top edge of visible screen
0433ED             0218*  ;     and a ; clear the carry flag
0433ED             0219*  ;     sbc hl,de
0433ED             0220*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
0433ED             0221*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
0433ED             0222*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
0433ED             0223*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
0433ED             0224*  ;     or 0x80 ; north
0433ED             0225*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
0433ED             0226*  ;     jr @move_ret
0433ED             0227*  ; @move_dn:
0433ED             0228*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
0433ED             0229*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
0433ED             0230*  ;     ld l,0x00
0433ED             0231*  ;     ld a,(iy+sprite_dim_y)
0433ED             0232*  ;     ld h,a
0433ED             0233*  ;     ld a,0x00
0433ED             0234*  ;     sub h
0433ED             0235*  ;     ld h,a
0433ED             0236*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
0433ED             0237*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
0433ED             0238*  ;     or 0x08 ; south
0433ED             0239*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
0433ED             0240*  ; @move_ret:
0433ED             0241*  ;     ret
0433ED             0242*  
0433ED             0243*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
0433ED             0244*  ; ; each sprite in the table must have one of these defined
0433ED             0245*  ; ; but they need not be unique to a particular sprite
0433ED             0246*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
0433ED             0247*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
0433ED             0248*  ; ; but they can call anything they want between those two endpoints
0433ED             0249*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
0433ED             0250*  
0433ED             0251*  ; move_nop: ; does nothing but burn a few cycles changing the PC
0433ED             0252*  ;     jp move_enemies_loop_return
0433ED             0253*  
0433ED             0254*  ; move_explosion:
0433ED             0255*  ;     call animate_explosion
0433ED             0256*  ;     jp move_enemies_loop_return
0433ED             0257*  
0433ED             0258*  move_enemy_small:
0433ED CD 9C 33 04 0259*      call en_nav
0433F1 CD 14 35 04 0260*      call check_collisions
0433F5 C3 30 33 04 0261*      jp move_enemies_loop_return
0433F9             0262*  
0433F9             0263*  ; move_enemy_medium:
0433F9             0264*  ;     call en_nav
0433F9             0265*  ;     call check_collisions
0433F9             0266*  ;     jp move_enemies_loop_return
0433F9             0267*  
0433F9             0268*  ; move_enemy_large:
0433F9             0269*  ;     call en_nav
0433F9             0270*  ;     call check_collisions
0433F9             0271*  ;     jp move_enemies_loop_return
0433F9             0272*  
0433F9             0273*  ; move_landing_pad:
0433F9             0274*  ;     call move_active_tiles
0433F9             0275*  ;     call check_collisions
0433F9             0276*  ; ; is it time to launch an enemy?
0433F9             0277*  ;     ld hl,sprite_move_timer
0433F9             0278*  ;     dec (hl)
0433F9             0279*  ;     jp nz,move_enemies_loop_return
0433F9             0280*  ;     call enemy_init_from_landing_pad
0433F9             0281*  ;     ; reset move timer so can spawn again if player doesn't take us out
0433F9             0282*  ;     call rand_8     ; snag a random number
0433F9             0283*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0433F9             0284*  ;     add a,64 ; range is now 64-127
0433F9             0285*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
0433F9             0286*  ;     jp move_enemies_loop_return
0433F9             0287*  
0433F9             0288*  enemy_init_from_landing_pad:
0433F9             0289*  ; get next available spriteId
0433F9 CD 69 18 04 0290*      call table_get_next_id
0433FD D0          0291*      ret nc ; no carry means no free sprite slots, so we go home
0433FE             0292*  ; ix comes back with the pointer to the new sprite variables
0433FE DD E5       0293*      push ix ; de picks it up when we're ready for the copy to the table
043400             0294*  ; a comes back with the spriteId of the new sprite
043400 32 56 34 04 0295*      ld (@id),a
043404             0296*  ; initialize the new sprite
043404 CD C6 23 04 0297*      call vdu_sprite_select
043408 CD D9 23 04 0298*      call vdu_sprite_clear_frames
04340C 21 14 01 00 0299*      ld hl,BUF_SEEKER_000
043410 06 20       0300*      ld b,32
043412             0301*  @load_frames:
043412 C5          0302*      push bc
043413 E5          0303*      push hl
043414 CD 13 25 04 0304*      call vdu_sprite_add_buff
043418 E1          0305*      pop hl
043419 23          0306*      inc hl
04341A C1          0307*      pop bc
04341B 10 F5       0308*      djnz @load_frames
04341D             0309*  ; copy coordinates of active sprite to new sprite
04341D FD 2A 42 18 0310*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043422             0311*      ; ld hl,(iy+sprite_x)
043422             0312*  	; ld hl,0x008000 ; debug
043422             0313*  
043422 CD E3 25 04 0314*      call rand_8
043426 21 00 00 00 0315*      ld hl,0
04342A 67          0316*      ld h,a
04342B             0317*  
04342B 22 61 34 04 0318*      ld (@x),hl
04342F             0319*      ; ld hl,(iy+sprite_y)
04342F             0320*      ; ld hl,0x002000 ; debug
04342F             0321*  
04342F CD E3 25 04 0322*      call rand_8
043433 21 00 00 00 0323*      ld hl,0
043437 67          0324*      ld h,a
043438             0325*  
043438 22 64 34 04 0326*      ld (@y),hl
04343C CD E3 25 04 0327*      call rand_8
043440 E6 01       0328*      and %00000001 ; 50/50 chance of moving left or right on spanw
043442 32 79 34 04 0329*      ld (@move_step),a
043446             0330*  ; now copy to the table
043446 21 56 34 04 0331*      ld hl,@id ; address to copy from
04344A D1          0332*      pop de ; address to copy to (was ix)
04344B 01 26 00 00 0333*      ld bc,table_bytes_per_record ; number of bytes to copy
04344F ED B0       0334*      ldir ; copy the records from local scratch to sprite table
043451             0335*  ; finally, make the new sprite visible
043451 CD 3C 24 04 0336*      call vdu_sprite_show
043455 C9          0337*      ret
043456 00          0338*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
043457 01          0339*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
043458 14 01 00    0340*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
04345B ED 33 04    0341*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
04345E 03          0342*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
04345F 10          0343*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
043460 10          0344*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
043461 00 00 00    0345*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
043464 00 00 00    0346*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043467 00 00 00    0347*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
04346A 00 00 00    0348*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04346D 80 02 00    0349*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
043470 00 80 00    0350*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043473 00 80 00    0351*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
043476 00          0352*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
043477 00          0353*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
043478 01          0354*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
043479 00          0355*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
04347A 20          0356*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
04347B 02          0357*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
04347C             0358*  
04347C             0359*  ; move_laser_turret:
04347C             0360*  ; ; compute orientation to player
04347C             0361*  ;     call orientation_to_player
04347C             0362*  ; ; h.l 8.8 fixed angle256 to player
04347C             0363*  ; ; bc and de as signed 16-bit integers
04347C             0364*  ; ; representing delta-x/y *to* target respectively
04347C             0365*  ;     ld (Bearing_t),hl
04347C             0366*  ;     ld hl,0x0400
04347C             0367*  ;     ld (Vp),hl
04347C             0368*  ;     call targeting_computer
04347C             0369*  ;     ld (sprite_heading),hl ; store bearing to player
04347C             0370*  ; ; is it time to launch a fireball?
04347C             0371*  ;     ld hl,sprite_move_timer
04347C             0372*  ;     dec (hl)
04347C             0373*  ;     jp nz,move_laser_turret_boilerplate
04347C             0374*  ;     call fireballs_init
04347C             0375*  ;     ; reset move timer so can fire again if player doesn't take us out
04347C             0376*  ;     call rand_8     ; snag a random number
04347C             0377*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04347C             0378*  ;     add a,64 ; range is now 64-127
04347C             0379*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04347C             0380*  ; move_laser_turret_boilerplate:
04347C             0381*  ;     call move_active_tiles
04347C             0382*  ;     call check_collisions
04347C             0383*  ;     jp move_enemies_loop_return
04347C             0384*  
04347C             0385*  ; fireballs_init:
04347C             0386*  ;     call sprite_variables_to_stack
04347C             0387*  
04347C             0388*  ;     ld hl,fireballs
04347C             0389*  ;     ld (sprite_base_bufferId),hl
04347C             0390*  
04347C             0391*  ;     ld hl,move_fireballs
04347C             0392*  ;     ld (sprite_move_program),hl
04347C             0393*  
04347C             0394*  ;     ld a,%11 ; collides with laser and player
04347C             0395*  ;     ; ld a,%10 ; collides with laser DEBUG
04347C             0396*  ;     ld (iy+sprite_collisions),a
04347C             0397*  
04347C             0398*  ;     ld hl,(Vp)
04347C             0399*  ;     ld (sprite_vel),hl
04347C             0400*  ;     ld hl,(Vp_x)
04347C             0401*  ;     ld (sprite_xvel),hl
04347C             0402*  ;     ld hl,(Vp_y)
04347C             0403*  ;     inc h ; account for ground movement
04347C             0404*  ;     ld (sprite_yvel),hl
04347C             0405*  
04347C             0406*  ;     xor a ; zero a
04347C             0407*  ;     ld (sprite_animation),a
04347C             0408*  ;     ld (sprite_move_step),a
04347C             0409*  ;     ld (sprite_move_timer),a
04347C             0410*  
04347C             0411*  ;     ld a,6 ; 1/10th of a second timer
04347C             0412*  ;     ld (sprite_animation_timer),a
04347C             0413*  
04347C             0414*  ;     ld a,0x00 ; BCD
04347C             0415*  ;     ld (sprite_points),a
04347C             0416*  ;     ld a,1 ; binary
04347C             0417*  ;     ld (sprite_shield_damage),a
04347C             0418*  
04347C             0419*  ;     call table_add_record ; plops that on the sprite stack for later
04347C             0420*  ;     call sprite_variables_from_stack ; come back to where we started
04347C             0421*  ;     ret
04347C             0422*  
04347C             0423*  ; move_fireballs:
04347C             0424*  ;     call move_enemy_sprite ; move sprite
04347C             0425*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
04347C             0426*  ;     and a ; if zero we're still within screen bounds
04347C             0427*  ;     jr z,move_fireballs_alive
04347C             0428*  ; ; otherwise kill sprite
04347C             0429*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
04347C             0430*  ;     ld (iy+sprite_collisions),a
04347C             0431*  ;     jp move_enemies_loop_return
04347C             0432*  ; move_fireballs_alive:
04347C             0433*  ;     ld a,(sprite_animation_timer)
04347C             0434*  ;     dec a
04347C             0435*  ;     ld (sprite_animation_timer),a
04347C             0436*  ;     jr nz,move_fireballs_draw
04347C             0437*  ;     ld a,(sprite_animation)
04347C             0438*  ;     xor %1
04347C             0439*  ;     ld (sprite_animation),a
04347C             0440*  ;     ld a,6 ; 1/10th of a second timer
04347C             0441*  ;     ld (sprite_animation_timer),a
04347C             0442*  ;     ; fall through
04347C             0443*  
04347C             0444*  ; move_fireballs_draw:
04347C             0445*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
04347C             0446*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
04347C             0447*  ;     call check_collisions
04347C             0448*  ;     jp move_enemies_loop_return
04347C             0449*  
04347C             0450*  ; compute orientation to player
04347C             0451*  ; based on relative positions
04347C             0452*  ; returns: h.l 16.8 fixed angle256 to player
04347C             0453*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
04347C             0454*  ;    representing delta-x/y *to* target respectively
04347C             0455*  orientation_to_player:
04347C FD 2A 42 18 0456*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043481 FD E5       0457*      push iy ; so we can send it back intact
043483 FD 07 0B    0458*      ld bc,(iy+sprite_x)
043486 FD 17 0E    0459*      ld de,(iy+sprite_y)
043489 DD 2A D3 30 0460*      ld ix,(player_x)
       04          
04348E FD 2A D6 30 0461*      ld iy,(player_y)
       04          
043493 CD 71 26 04 0462*      call dxy168
043497 C5          0463*      push bc
043498 D5          0464*      push de
043499 CD BD 26 04 0465*      call atan2_168fast
04349D D1          0466*      pop de
04349E C1          0467*      pop bc
04349F FD E1       0468*      pop iy ; restore table pointer
0434A1 C9          0469*      ret
0434A2             0470*  
0434A2             0471*  
0434A2             0472*  ; targeting_computer scratch variables
0434A2 00 00       0473*  Bearing_t: dw #0000 ; 8.8 fixed
0434A4 00 00       0474*  Heading_t: dw #0000 ; 8.8 fixed
0434A6 00 00       0475*  Vp: dw #0000 ; 8.8 fixed
0434A8 00 00       0476*  Vp_x: dw #0000 ; 8.8 fixed
0434AA 00 00       0477*  Vp_y: dw #0000 ; 8.8 fixed
0434AC 00 00       0478*  Vt: dw #0000 ; 8.8 fixed
0434AE 00 00       0479*  Vt_x: dw #0000 ; 8.8 fixed
0434B0 00 00       0480*  Vt_y: dw #0000 ; 8.8 fixed
0434B2             0481*  
0434B2             0482*  
0434B2             0483*  ; ; Inputs:   see scratch variables
0434B2             0484*  ; ; Note:     a call to orientation_to_player provides these inputs
0434B2             0485*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
0434B2             0486*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
0434B2             0487*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
0434B2             0488*  ; targeting_computer:
0434B2             0489*  ; ; compute target velocity from x,y component velocities
0434B2             0490*  ;     ld bc,(player_xvel)
0434B2             0491*  ;     ld de,(player_yvel)
0434B2             0492*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
0434B2             0493*  
0434B2             0494*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
0434B2             0495*  ;     ld (Heading_t),bc
0434B2             0496*  ;     ld (Vt),de
0434B2             0497*  
0434B2             0498*  ; ; compute Heading_t-Bearing_t
0434B2             0499*  ;     ld h,b
0434B2             0500*  ;     ld l,c
0434B2             0501*  ;     ld bc,(Bearing_t)
0434B2             0502*  ;     and a ; clear carry
0434B2             0503*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
0434B2             0504*  
0434B2             0505*  ; ; compute sin(Heading_t-Bearing_t)
0434B2             0506*  ;     ld b,h
0434B2             0507*  ;     ld c,l
0434B2             0508*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
0434B2             0509*  
0434B2             0510*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
0434B2             0511*  ;     ex de,hl
0434B2             0512*  ;     ld bc,(Vt)
0434B2             0513*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
0434B2             0514*  
0434B2             0515*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
0434B2             0516*  ;     ld b,h
0434B2             0517*  ;     ld c,l
0434B2             0518*  ;     ld de,(Vp)
0434B2             0519*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
0434B2             0520*  ; ; answer is in radians, convert to degrees256
0434B2             0521*  ;     ex de,hl
0434B2             0522*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
0434B2             0523*  ;     call BC_Mul_DE_88
0434B2             0524*  
0434B2             0525*  ; ; add lead angle to target bearing
0434B2             0526*  ;     ld de,(Bearing_t)
0434B2             0527*  ;     add hl,de ; h.l=lead angle+target bearing
0434B2             0528*  ;     push hl
0434B2             0529*  
0434B2             0530*  ; ; compute component projectile velocities
0434B2             0531*  ;     ld b,h
0434B2             0532*  ;     ld c,l
0434B2             0533*  ;     ld de,(Vp)
0434B2             0534*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
0434B2             0535*  
0434B2             0536*  ;     ld (Vp_x),bc
0434B2             0537*  ;     ld (Vp_y),de
0434B2             0538*  ;     pop hl ; h.l=lead angle+target bearing
0434B2             0539*  ;     ret
0434B2             0540*  
0434B2             0541*  ; this routine vanquishes the enemy sprite
0434B2             0542*  ; and replaces it with an animated explosion
0434B2             0543*  ; we jump here instead of call because
0434B2             0544*  ; we want to return to differing locations in the loop
0434B2             0545*  ; depending on whether we're still sploding
0434B2             0546*  ; destroys: everything except index registers
0434B2             0547*  ; returns: an incandescent ball of debris and gas
0434B2             0548*  kill_nurple:
0434B2             0549*  ; ; tally up points
0434B2             0550*  ;     ld bc,0
0434B2             0551*  ;     ld a,(sprite_points)
0434B2             0552*  ;     ld e,a
0434B2             0553*  ;     ld d,0
0434B2             0554*  ;     ld hl,add_bcd_arg2
0434B2             0555*  ;     call set_bcd
0434B2             0556*  ;     ld hl,player_score
0434B2             0557*  ;     ld de,add_bcd_arg2
0434B2             0558*  ;     ld a,3 ; number of bytes to add
0434B2             0559*  ;     call add_bcd
0434B2             0560*  ; ; initialize explosion
0434B2             0561*  ; init_explosion:
0434B2             0562*  ;     ld hl,explosion
0434B2             0563*  ;     ld (sprite_base_bufferId),hl
0434B2             0564*  ;     ld hl,move_explosion
0434B2             0565*  ;     ld (sprite_move_program),hl
0434B2             0566*  ;     ld a,%00000000 ; collides with nothing
0434B2             0567*  ;     ld (iy+sprite_collisions),a
0434B2             0568*  ;     ld hl,0 ; north
0434B2             0569*  ;     ld (sprite_heading),hl
0434B2             0570*  ;     ld a,0x04 ; will decrement to 03
0434B2             0571*  ;     ld (sprite_animation),a
0434B2             0572*  ;     ld a,0x07 ; 7/60th of a second timer
0434B2             0573*  ;     ld (sprite_animation_timer),a
0434B2             0574*  ;     xor a
0434B2             0575*  ;     ld (sprite_move_timer),a
0434B2             0576*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0434B2             0577*  ; ; fall through to next_explosion
0434B2             0578*  ; next_explosion:
0434B2             0579*  ;     ld a,(sprite_animation)
0434B2             0580*  ;     dec a ; if rolled negative from zero,we're done sploding
0434B2             0581*  ;     jp m,done_explosion
0434B2             0582*  ;     ld (sprite_animation),a
0434B2             0583*  ;     ld a,0x7 ; 7/60th of a second timer
0434B2             0584*  ;     ld (sprite_animation_timer),a
0434B2             0585*  ; ; fall through to animate_explosion
0434B2             0586*  ; animate_explosion:
0434B2             0587*  ;     ld hl,sprite_y+1
0434B2             0588*  ;     inc (hl) ; move explosion down 1 pixel
0434B2             0589*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
0434B2             0590*  ;     ld hl,sprite_animation_timer
0434B2             0591*  ;     dec (hl) ; if timer is zero,we do next animation
0434B2             0592*  ;     jr z,next_explosion
0434B2             0593*  ;     ;otherwise we fall through to draw the current one
0434B2             0594*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0434B2             0595*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0434B2             0596*  ;     ret ; now we go back to caller
0434B2             0597*  ; done_explosion:
0434B2 3E 80       0598*      ld a,%10000000 ; high bit set is non-specific kill-me flag
0434B4 FD 2A 42 18 0599*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
0434B9 FD 77 08    0600*      ld (iy+sprite_collisions),a
0434BC C9          0601*      ret ; now we go back to caller
0434BD             0602*  
0434BD             0603*  ; game_over:
0434BD             0604*  ;     jp new_game
0434BD             0605*  
0434BD             0606*  ; it's presumed we've already checked that laser is alive
0434BD             0607*  collision_enemy_with_laser:
0434BD DD 2A 4C 35 0608*      ld ix,(laser_x)
       04          
0434C2 FD 2A 4F 35 0609*      ld iy,(laser_y)
       04          
0434C7 3A 4A 35 04 0610*      ld a,(laser_dim_x)
0434CB CB 2F       0611*      sra a ; divide by 2
0434CD F5          0612*      push af ; we need this later
0434CE C3 E3 34 04 0613*      jp collision_enemy
0434D2             0614*  
0434D2             0615*  ; it's presumed we've already checked that player is alive
0434D2             0616*  collision_enemy_with_player:
0434D2 DD 2A D3 30 0617*      ld ix,(player_x)
       04          
0434D7 FD 2A D6 30 0618*      ld iy,(player_y)
       04          
0434DC 3A D1 30 04 0619*      ld a,(player_dim_x)
0434E0 CB 2F       0620*      sra a ; divide by 2
0434E2 F5          0621*      push af ; we need this later
0434E3             0622*      ; fall through to collision_enemy
0434E3             0623*  
0434E3             0624*  ; compute the distance between the two sprites' centers
0434E3             0625*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
0434E3             0626*  collision_enemy:
0434E3             0627*  ; back up iy because we need it as the sprite table pointer
0434E3 FD E5       0628*      push iy
0434E5 FD 2A 42 18 0629*      ld iy,(table_pointer)
       04          
0434EA FD 27 0B    0630*      ld hl,(iy+sprite_x)
0434ED FD 7E 09    0631*      ld a,(iy+sprite_dim_x)
0434F0 CB 2F       0632*      sra a
0434F2 F5          0633*      push af ; we need this later
0434F3 E5          0634*      push hl
0434F4 C1          0635*      pop bc ; bc = x0
0434F5 FD 27 0E    0636*      ld hl,(iy+sprite_y)
0434F8 FD 7E 0A    0637*      ld a,(iy+sprite_dim_y)
0434FB EB          0638*      ex de,hl ; de = y0
0434FC F1          0639*      pop af ; TODO: srsly, this is the best way to do this?
0434FD FD E1       0640*      pop iy
0434FF F5          0641*      push af
043500 CD 98 26 04 0642*      call distance168
043504             0643*  
043504             0644*  ; ; subtract sum of radii from distance between centers
043504             0645*  ;     ld de,0
043504             0646*  ;     pop af ; radius of enemy sprite
043504             0647*  ;     ld e,a
043504             0648*  ;     pop af ; radius of player or laser sprite
043504             0649*  ;     add a,e
043504             0650*  ;     ld e,a
043504             0651*  ;     and a ; clear carry
043504             0652*  ;     sbc hl,de
043504             0653*  ;     jr c,collision_enemy_is
043504             0654*  ;     xor a
043504             0655*  ;     ret
043504             0656*  ; temp fix TODO: remove this
043504 F1          0657*      pop af
043505 F1          0658*      pop af
043506 11 00 10 00 0659*      ld de,16*256
04350A A7          0660*      and a
04350B ED 52       0661*      sbc hl,de
04350D 38 02       0662*      jr c,collision_enemy_is
04350F AF          0663*      xor a
043510 C9          0664*      ret
043511             0665*  collision_enemy_is:
043511 AF          0666*      xor a
043512 3C          0667*      inc a
043513 C9          0668*      ret
043514             0669*  
043514             0670*  ; ; looks up what enemy sprite collides with
043514             0671*  ; ; detects collisions
043514             0672*  ; ; and sets things to sploding accordingly
043514             0673*  ; check_collisions:
043514             0674*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
043514             0675*  ;     and a ; if this is zero,
043514             0676*  ;     ret z ; there's nothing to do
043514             0677*  ;     and %01 ; do we collide with player?
043514             0678*  ;     jr z,move_enemies_laser ; if not,check laser collision
043514             0679*  ;     call collision_enemy_with_player ; otherwise see if we hit player
043514             0680*  ;     and a ; was there a collision?
043514             0681*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
043514             0682*  ; ; yes collision with player
043514             0683*  ;     ; deduct shield damage
043514             0684*  ;     ld hl,sprite_shield_damage
043514             0685*  ;     ld a,(player_shields)
043514             0686*  ;     sub (hl)
043514             0687*  ;     ld (player_shields),a
043514             0688*  ; ; if shields >= 0,player survives
043514             0689*  ;     jp p,check_collisions_kill_nurple
043514             0690*  ; ; otherwise update player status so it will die
043514             0691*  ;     ld a,(player_collisions)
043514             0692*  ;     or %10 ; sets bit 1,meaning player just died
043514             0693*  ;     ld (player_collisions),a
043514             0694*  ;     ; fall through
043514             0695*  ; check_collisions_kill_nurple:
043514             0696*  ; ; kill enemy and replace with explosion
043514             0697*  ;     call kill_nurple
043514             0698*  ;     ret ; and out
043514             0699*  
043514             0700*  check_collisions:
043514 CD D2 34 04 0701*      call collision_enemy_with_player ; did we hit the player?
043518 A7          0702*      and a ; was there a collision?
043519 C8          0703*      ret z ; if not,we're done
04351A CD B2 34 04 0704*      call kill_nurple ; otherwise kill enemy
04351E C9          0705*      ret
04351F             0706*  
04351F             0707*  ; did we hit the laser?
04351F             0708*  move_enemies_laser:
04351F FD 7E 08    0709*      ld a,(iy+sprite_collisions) ; snag what we collide with again
043522 E6 02       0710*      and %10 ; do we even collide with laser?
043524 C8          0711*      ret z ; if not,we're out
043525 3A 49 35 04 0712*      ld a,(laser_collisions) ; is laser alive?
043529 E6 01       0713*      and %1 ; if bit 0 is not set laser is dead
04352B C8          0714*      ret z ; so we're out
04352C CD BD 34 04 0715*      call collision_enemy_with_laser ; otherwise check for collision
043530 A7          0716*      and a ; was there a collision?
043531 C8          0717*      ret z ; if not,we're done
043532             0718*  ; otherwise we mark laser for termination and kill enemy
043532             0719*  ; update laser status so it will die
043532 3A 49 35 04 0720*      ld a,(laser_collisions)
043536 F6 02       0721*      or %10 ; bit 1 set means laser just died
043538 32 49 35 04 0722*      ld (laser_collisions),a
04353C CD B2 34 04 0723*      call kill_nurple ; yes there was a collision,so kill enemy
043540 C9          0724*      ret ; we're outta' here
043541             0065   	include "laser.inc"
043541             0001*  ; ##### LASER SPRITE PARAMETERS #####
043541             0002*  ; uses the same offsets from its table base as the main sprite table:
043541             0003*  laser_start_variables: ; label marking beginning of table
043541 11          0004*  laser_id:               db table_max_records+1
043542 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
043543 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
043546 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
043549 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
04354A 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
04354B 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
04354C 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
04354F 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
043552 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043555 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043558 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
04355B 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
04355E 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
043561 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
043562 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
043563 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
043564 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
043565 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
043566 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
043567             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
043567             0025*  
043567             0026*  ; laser_control:
043567             0027*  ; ; is laser already active?
043567             0028*  ;     ld a,(laser_collisions)
043567             0029*  ;     and %00000001 ; bit zero is lit if laser is active
043567             0030*  ;     jr nz,laser_move ; move laser if not zero
043567             0031*  ; ; otherwise check if laser fired
043567             0032*  ;     in a,(#82) ; keyboard
043567             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
043567             0034*  ;     ret z ; go back if laser not fired
043567             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
043567             0036*  ; ; set laser status to active (set bit 0)
043567             0037*  ;     ld a,%1
043567             0038*  ;     ld (laser_collisions),a
043567             0039*  ; ; initialize laser position
043567             0040*  ;     ld a,(player_x+1) ; we only need the integer part
043567             0041*  ;     ; add a,6 ; horizontal center with player sprite
043567             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
043567             0043*  ;     ld a,(player_y+1) ; we only need the integer part
043567             0044*  ;     add a,-6 ; set laser y a few pixels above player
043567             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
043567             0046*  ;     ; fall through to laser_move
043567             0047*  
043567             0048*  ; laser_move:
043567             0049*  ; ; begin setting laser to active sprite
043567             0050*  ;     ld hl,lasers
043567             0051*  ;     ld (sprite_base_bufferId),hl
043567             0052*  ;     ld hl,0 ; north
043567             0053*  ;     ld (sprite_heading),hl
043567             0054*  ;     xor a ; laser has no animations yet :-(
043567             0055*  ;     ld (sprite_animation),a
043567             0056*  ;     ; we set position here for the time being as a default
043567             0057*  ;     ; in case the laser is flagged for deletion
043567             0058*  ;     ; load sprite_x with laser x position (we do y further down)
043567             0059*  ;     ld hl,(laser_x)
043567             0060*  ;     ld (sprite_x),hl
043567             0061*  ; ; did laser just die?
043567             0062*  ;     ld a,(laser_collisions)
043567             0063*  ;     bit 1,a ; z if laser didn't just die
043567             0064*  ;     jr z,laser_not_dead_yet
043567             0065*  ; ; yes laser died
043567             0066*  ;     call kill_laser
043567             0067*  ;     ret ; done
043567             0068*  ; laser_not_dead_yet:
043567             0069*  ; ; draw it
043567             0070*  ; ; update laser y position
043567             0071*  ;     ld hl,(laser_y) ; grab laser y position
043567             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
043567             0073*  ;     add hl,de ; add y velocity to y pos
043567             0074*  ;     ld (sprite_y),hl ; update laser y position
043567             0075*  ;     ld (laser_y),hl ; update laser y position
043567             0076*  ; ; are we at top of screen?
043567             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
043567             0078*  ;     sub h ; no carry if above threshold
043567             0079*  ;     jr c,finally_draw_the_frikken_laser
043567             0080*  ;     ; if at top of screen,laser dies
043567             0081*  ;     call kill_laser
043567             0082*  ;     ret
043567             0083*  ; ; otherwise,finally draw the frikken laser
043567             0084*  ; finally_draw_the_frikken_laser:
043567             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043567             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043567             0087*  ; ; all done
043567             0088*  ;     ret
043567             0089*  
043567             0090*  ; kill_laser:
043567             0091*  ; ; update status to inactive
043567             0092*  ;     xor a ; zero out a
043567             0093*  ;     ld (laser_collisions),a
043567             0094*  ;     ret
043567             0066   	include "timer.inc"
043567             0001*  ; Table 32. Timer Control Registers
043567             0002*  ; this constant is the base address of the timer control registers
043567             0003*  ; each timer takes three bytes:
043567             0004*  ;   0: control register
043567             0005*  ;   1: low byte of timer reset value
043567             0006*  ;   2: high byte of timer reset value
043567             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
043567             0008*  ; which correctly force the high and upper bytes of the address bus to zero
043567             0009*  TMR_CTL:     equ 80h
043567             0010*  
043567             0011*  ; Timer Control Register Bit Definitions
043567             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
043567             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
043567             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
043567             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
043567             0016*                              ; the TMRx_CTL register is read.
043567             0017*  
043567             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
043567             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
043567             0020*  
043567             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
043567             0022*                              ;  0,and counting stops when the end-of-count value is reached.
043567             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
043567             0024*                              ; written to the counter when the end-of-count value is reached.
043567             0025*  
043567             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
043567             0027*  CLK_DIV_256:  equ %00001100 ;
043567             0028*  CLK_DIV_64:   equ %00001000 ;
043567             0029*  CLK_DIV_16:   equ %00000100 ;
043567             0030*  CLK_DIV_4:    equ %00000000 ;
043567             0031*  
043567             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
043567             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
043567             0034*                              ; When a 1 is written to this bit,the values in the reload registers
043567             0035*                              ;  are loaded into the downcounter when the timer restarts. The
043567             0036*                              ; programmer must ensure that this bit is set to 1 each time
043567             0037*                              ; SINGLE-PASS mode is used.
043567             0038*  
043567             0039*  ; disable/enable the programmable reload timer
043567             0040*  PRT_EN_0:     equ %00000000 ;
043567             0041*  PRT_EN_1:     equ %00000001 ;
043567             0042*  
043567             0043*  ; Table 37. Timer Input Source Select Register
043567             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
043567             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
043567             0046*  ;   00: System clock / CLK_DIV
043567             0047*  ;   01: RTC / CLK_DIV
043567             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
043567             0049*  ;   10: GPIO port B pin 1.
043567             0050*  ;   11: GPIO port B pin 1.
043567             0051*  TMR_ISS:   equ 92h ; register address
043567             0052*  
043567             0053*  ; Table 51. Real-Time Clock Control Register
043567             0054*  RTC_CTRL: equ EDh ; register address
043567             0055*  
043567             0056*  ; alarm interrupt disable/enable
043567             0057*  RTC_ALARM_0:    equ %00000000
043567             0058*  RTC_ALARM_1:    equ %10000000
043567             0059*  
043567             0060*  ; interrupt on alarm disable/enable
043567             0061*  RTC_INT_ENT_0:  equ %00000000
043567             0062*  RTC_INT_ENT_1:  equ %01000000
043567             0063*  
043567             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
043567             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
043567             0066*  
043567             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
043567             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
043567             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
043567             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
043567             0071*  
043567             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
043567             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
043567             0074*  
043567             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
043567             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
043567             0077*  
043567             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
043567             0079*                                  ; RTC counter is enabled.
043567             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
043567             0081*                                  ; RTC counter is disabled.
043567             0082*  
043567             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
043567             0084*  
043567             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
043567             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
043567 00 00 00    0087*  prt_reload: dl 0x000000
04356A             0088*  
04356A             0089*  ; set PRT timer
04356A             0090*  prt_set:
04356A 21 00 00 00 0091*      ld hl,0
04356E 22 B8 35 04 0092*      ld (prt_irq_counter),hl
043572 2A 67 35 04 0093*      ld hl,(prt_reload)
043576 ED 29 84    0094*      out0 ($84),l
043579 ED 21 85    0095*  	out0 ($85),h
04357C             0096*  ; disable timer
04357C 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04357E ED 39 83    0098*  	out0 ($83),a
043581             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
043581 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
043583 ED 39 83    0101*  	out0 ($83),a
043586 C9          0102*      ret
043587             0103*  
043587             0104*  ; ===============================================
043587             0105*  ; PRT Timer Interrupt Handling
043587             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
043587             0107*  ; -----------------------------------------------
043587             0108*  prt_irq_init:
043587             0109*      ; set up interrupt vector table 2
043587 21 00 00 00 0110*  	ld hl,0
04358B 3A 0C 01 00 0111*  	ld a,($10c)
04358F 6F          0112*  	ld l,a
043590 3A 0D 01 00 0113*  	ld a,($10d)
043594 67          0114*  	ld h,a
043595             0115*  
043595             0116*  	; skip over CALL ($c3)
043595 23          0117*  	inc hl
043596             0118*  	; load address of jump into vector table 2 (in ram)
043596 ED 27       0119*  	ld hl,(hl)
043598             0120*  
043598             0121*  	; write CALL prt_irq_handler to vector table 2
043598 3E C3       0122*  	ld a,$c3
04359A 77          0123*  	ld (hl),a
04359B 23          0124*  	inc hl
04359C 11 A3 35 04 0125*  	ld de,prt_irq_handler
0435A0 ED 1F       0126*  	ld (hl),de
0435A2             0127*  
0435A2 C9          0128*      ret
0435A3             0129*  
0435A3             0130*  prt_irq_handler:
0435A3 F3          0131*  	di
0435A4 F5          0132*  	push af
0435A5 E5          0133*      push hl
0435A6 ED 38 83    0134*  	in0 a,($83)
0435A9 2A B8 35 04 0135*  	ld hl,(prt_irq_counter)
0435AD 23          0136*  	inc hl
0435AE 22 B8 35 04 0137*  	ld (prt_irq_counter),hl
0435B2 E1          0138*      pop hl
0435B3 F1          0139*  	pop af
0435B4 FB          0140*  	ei
0435B5 5B ED 4D    0141*  	reti.l
0435B8             0142*  
0435B8             0143*  prt_irq_counter:
0435B8 00 00 00    0144*  	.dl 0
0435BB             0145*  prt_irq_counter_saved:
0435BB 00 00 00    0146*      .dl 0
0435BE             0147*  
0435BE             0148*  prt_loop_reset:
0435BE E5          0149*      push hl
0435BF 21 00 00 00 0150*  	ld hl,0
0435C3 22 B8 35 04 0151*  	ld (prt_irq_counter),hl
0435C7 22 29 36 04 0152*      ld (prt_loop_counter),hl
0435CB 22 2C 36 04 0153*      ld (prt_loops),hl
0435CF CD 6A 35 04 0154*      call prt_set
0435D3 E1          0155*      pop hl
0435D4 C9          0156*      ret
0435D5             0157*  
0435D5             0158*  prt_loop_start:
0435D5 E5          0159*      push hl
0435D6 21 00 00 00 0160*  	ld hl,0
0435DA 22 B8 35 04 0161*  	ld (prt_irq_counter),hl
0435DE E1          0162*      pop hl
0435DF C9          0163*      ret
0435E0             0164*  
0435E0             0165*  prt_loop_stop:
0435E0 E5          0166*      push hl
0435E1 D5          0167*      push de
0435E2 2A B8 35 04 0168*      ld hl,(prt_irq_counter)
0435E6 ED 5B 29 36 0169*      ld de,(prt_loop_counter)
       04          
0435EB 19          0170*      add hl,de
0435EC 22 29 36 04 0171*      ld (prt_loop_counter),hl
0435F0 21 00 00 00 0172*      ld hl,0
0435F4 22 B8 35 04 0173*      ld (prt_irq_counter),hl
0435F8 2A 2C 36 04 0174*      ld hl,(prt_loops)
0435FC 23          0175*      inc hl
0435FD 22 2C 36 04 0176*      ld (prt_loops),hl
043601 D1          0177*      pop de
043602 E1          0178*      pop hl
043603 C9          0179*      ret
043604             0180*  
043604             0181*  ; inputs: bc = y,x text coordinates to print
043604             0182*  prt_loop_print:
043604 F5          0183*      push af
043605 E5          0184*      push hl
043606 C5          0185*      push bc
043607 D5          0186*      push de
043608 DD E5       0187*      push ix
04360A FD E5       0188*      push iy
04360C CD 5B 1F 04 0189*      call vdu_move_cursor
043610             0190*  
043610 2A 29 36 04 0191*      ld hl,(prt_loop_counter)
043614 CD 0C 1A 04 0192*      call printDec
043618             0193*  
043618 2A 2C 36 04 0194*      ld hl,(prt_loops)
04361C CD 0C 1A 04 0195*      call printDec
043620             0196*  
043620 FD E1       0197*      pop iy
043622 DD E1       0198*      pop ix
043624 D1          0199*      pop de
043625 C1          0200*      pop bc
043626 E1          0201*      pop hl
043627 F1          0202*      pop af
043628 C9          0203*      ret
043629             0204*  
043629             0205*  prt_loop_counter:
043629 00 00 00    0206*      .dl 0
04362C             0207*  prt_loops:
04362C 00 00 00    0208*      .dl 0
04362F             0209*  
04362F             0210*  ; ===============================================
04362F             0211*  ; Timer functions
04362F             0212*  ; -----------------------------------------------
04362F             0213*  ; set a countdown timer
04362F             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04362F             0215*  ; returns: hl = current time
04362F             0216*  tmr_set:
04362F FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
043632             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
043632 3E 08       0001*M 			LD	A, function
043634 5B CF       0002*M 			RST.LIL	08h
043636 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043639 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
04363C C9          0221*      ret
04363D             0222*  
04363D             0223*  ; gets time remaining on a countdown timer
04363D             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04363D             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04363D             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
04363D             0227*  tmr_get:
04363D             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
04363D 3E 08       0001*M 			LD	A, function
04363F 5B CF       0002*M 			RST.LIL	08h
043641 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
043644 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
043647 AF          0231*      xor a                   ; clear carry
043648 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04364A FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
04364D AF          0234*      xor a                   ; clear carry
04364E ED 5A       0235*      adc hl,de               ; hl = time remaining
043650             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043650 C9          0237*      ret
043651             0238*  
043651             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
043657             0240*  
043657 00 00 00    0241*  timestamp_now: dl 0
04365A 00 00 00    0242*  timestamp_old: dl 0
04365D 00 00 00    0243*  timestamp_chg: dl 0
043660             0244*  
043660             0245*  ; update the global timestamp from the system clock
043660             0246*  ; inputs: none
043660             0247*  ; returns: hl = time elapsed in 1/120ths of a second
043660             0248*  ;          de = current time
043660             0249*  ;          ix = pointer to syvars table
043660             0250*  ; destroys: af,hl,de,ix
043660             0251*  timestamp_tick:
043660 ED 5B 57 36 0252*      ld de,(timestamp_now)   ; get previous time
       04          
043665 ED 53 5A 36 0253*      ld (timestamp_old),de   ; save previous time
       04          
04366A             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
04366A 3E 08       0001*M 			LD	A, function
04366C 5B CF       0002*M 			RST.LIL	08h
04366E DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
043671 22 57 36 04 0256*      ld (timestamp_now),hl   ; save current time
043675 AF          0257*      xor a                   ; clear carry
043676 ED 52       0258*      sbc hl,de               ; hl = time elapsed
043678 22 5D 36 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
04367C C9          0260*      ret
04367D             0261*  
04367D             0262*  ; set a countdown timer
04367D             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04367D             0264*  ; requires: timestamp_tick to be called at least once before this function
04367D             0265*  ; returns: hl = current time
04367D             0266*  ; destroys: hl
04367D             0267*  timestamp_tmr_set:
04367D FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
043680 2A 57 36 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
043684 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
043687 C9          0271*      ret
043688             0272*  
043688             0273*  ; gets time remaining on a countdown timer following the global timestamp
043688             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
043688             0275*  ; requires: timestamp_tick to be called at least once before this function
043688             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
043688             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
043688             0278*  ; destroys: af,hl,de
043688             0279*  timestamp_tmr_get:
043688 ED 5B 57 36 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
04368D FD 27 00    0281*      ld hl,(iy+0)            ; get start time
043690 AF          0282*      xor a                   ; clear carry
043691 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
043693 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
043696 AF          0285*      xor a                   ; clear carry
043697 ED 5A       0286*      adc hl,de               ; hl = time remaining
043699             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
043699 C9          0288*      ret
04369A             0289*  
04369A             0290*  ; set a stopwatch
04369A             0291*  ; returns: hl = start time
04369A             0292*  ; destroys: hl,ix
04369A             0293*  stopwatch_set:
04369A             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
04369A 3E 08       0001*M 			LD	A, function
04369C 5B CF       0002*M 			RST.LIL	08h
04369E DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
0436A1 22 B6 36 04 0296*      ld (stopwatch_started),hl            ; set start time
0436A5 C9          0297*      ret
0436A6             0298*  
0436A6             0299*  ; gets time elapsed on a stopwatch
0436A6             0300*  ; returns: hl = time elapsed in 1/120ths of a second
0436A6             0301*  ; destroys: af,hl,de,ix
0436A6             0302*  stopwatch_get:
0436A6             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
0436A6 3E 08       0001*M 			LD	A, function
0436A8 5B CF       0002*M 			RST.LIL	08h
0436AA DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
0436AD ED 5B B6 36 0305*      ld de,(stopwatch_started)            ; get start time
       04          
0436B2 AF          0306*      xor a                   ; clear carry
0436B3 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0436B5 C9          0308*      ret
0436B6             0309*  
0436B6             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0436B9             0311*  
0436B9             0312*  ; ------------------
0436B9             0313*  ; delay routine
0436B9             0314*  ; Author: Richard Turrnidge
0436B9             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0436B9             0316*  ; routine waits a fixed time,then returns
0436B9             0317*  ; arrive with A =  the delay byte. One bit to be set only.
0436B9             0318*  ; eg. ld A,00000100b
0436B9             0319*  
0436B9             0320*  multiPurposeDelay:
0436B9 F5          0321*      push af
0436BA C5          0322*      push bc
0436BB DD E5       0323*      push ix
0436BD 47          0324*      ld b,a
0436BE 3E 08       0325*      ld a,$08
0436C0 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
0436C2             0327*  
0436C2             0328*  waitLoop:
0436C2             0329*  
0436C2 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0436C5             0331*  
0436C5             0332*                                  ;   we check if bit set is same as last time we checked.
0436C5             0333*                                  ;   bit 0 - don't use
0436C5             0334*                                  ;   bit 1 - changes 64 times per second
0436C5             0335*                                  ;   bit 2 - changes 32 times per second
0436C5             0336*                                  ;   bit 3 - changes 16 times per second
0436C5             0337*  
0436C5             0338*                                  ;   bit 4 - changes 8 times per second
0436C5             0339*                                  ;   bit 5 - changes 4 times per second
0436C5             0340*                                  ;   bit 6 - changes 2 times per second
0436C5             0341*                                  ;   bit 7 - changes 1 times per second
0436C5 A0          0342*      and b
0436C6 4F          0343*      ld c,a
0436C7 3A D8 36 04 0344*      ld a,(oldTimeStamp)
0436CB B9          0345*      cp c                        ; is A same as last value?
0436CC 28 F4       0346*      jr z,waitLoop              ; loop here if it is
0436CE 79          0347*      ld a,c
0436CF 32 D8 36 04 0348*      ld (oldTimeStamp),a        ; set new value
0436D3             0349*  
0436D3 DD E1       0350*      pop ix
0436D5 C1          0351*      pop bc
0436D6 F1          0352*      pop af
0436D7 C9          0353*      ret
0436D8             0354*  
0436D8 00          0355*  oldTimeStamp:   .db 00h
0436D9             0067   
0436D9             0068   ; new includes
0436D9             0069   	include "images.inc"
0436D9             0001*  image_type: equ 0
0436D9             0002*  image_width: equ image_type+3
0436D9             0003*  image_height: equ image_width+3
0436D9             0004*  image_filesize: equ image_height+3
0436D9             0005*  image_filename: equ image_filesize+3
0436D9             0006*  image_bufferId: equ image_filename+3
0436D9             0007*  image_record_size: equ image_bufferId+3
0436D9             0008*  
0436D9 00 00 00    0009*  cur_image_list: dl 0
0436DC 00 00 00    0010*  cur_file_idx: dl 0
0436DF 00 00 00    0011*  cur_filename: dl 0
0436E2 00 00 00    0012*  cur_buffer_id: dl 0
0436E5             0013*  
0436E5             0014*  load_ui_images:
0436E5             0015*  ; initialize image loading variables
0436E5 21 00 00 00 0016*  	ld hl,0
0436E9 22 DC 36 04 0017*  	ld (cur_file_idx),hl
0436ED 21 DB 47 04 0018*  	ld hl,ui_image_list
0436F1 22 D9 36 04 0019*  	ld (cur_image_list),hl
0436F5             0020*  ; load images
0436F5 06 04       0021*  	ld b,ui_num_images
0436F7             0022*  @loop:
0436F7 C5          0023*  	push bc
0436F8 CD 5A 37 04 0024*  	call load_next_image
0436FC C1          0025*  	pop bc
0436FD 10 F8       0026*  	djnz @loop
0436FF C9          0027*  	ret
043700             0028*  
043700             0029*  load_sprite_images:
043700             0030*  ; initialize image loading variables
043700 21 00 00 00 0031*  	ld hl,0
043704 22 DC 36 04 0032*  	ld (cur_file_idx),hl
043708 21 EB 37 04 0033*  	ld hl,sprites_image_list
04370C 22 D9 36 04 0034*  	ld (cur_image_list),hl
043710 01 5F 00 00 0035*  	ld bc,sprites_num_images
043714             0036*  ; load images
043714 CD 19 37 04 0037*  	call img_load_main
043718 C9          0038*  	ret
043719             0039*  
043719             0040*  ; inputs: bc is the number of images to load, cur_image_list set
043719             0041*  img_load_main:
043719 AF          0042*  	xor a
04371A 32 DC 36 04 0043*      ld (cur_file_idx),a
04371E             0044*  
04371E             0045*  img_load_main_loop:
04371E             0046*  ; back up loop counter
04371E C5          0047*      push bc
04371F             0048*  
04371F             0049*  ; load the next image
04371F CD 5A 37 04 0050*      call load_next_image
043723             0051*  
043723             0052*  ; plot the background
043723 CD 6F 1F 04 0053*  	call vdu_cls
043727 21 02 00 00 0054*      ld hl,BUF_SPLASH_BG
04372B CD 5C 20 04 0055*      call vdu_buff_select
04372F 01 00 00 00 0056*      ld bc,0
043733 11 00 00 00 0057*      ld de,0
043737 CD 25 23 04 0058*      call vdu_plot_bmp
04373B             0059*  
04373B             0060*  ; ; draw the most recently loaded image
04373B             0061*  ; 	ld hl,(cur_buffer_id)
04373B             0062*  ; 	call vdu_buff_select
04373B             0063*  ; 	ld bc,0
04373B             0064*  ; 	ld de,0
04373B             0065*  ; 	call vdu_plot_bmp
04373B             0066*  
04373B             0067*  ; move logo
04373B CD BA 37 04 0068*  	call move_logo
04373F             0069*  
04373F             0070*  ; print current filename
04373F 2A DF 36 04 0071*  	ld hl,(cur_filename)
043743 CD 0D 19 04 0072*  	call printString
043747             0073*  
043747             0074*  ; flip the framebuffer
043747 CD 74 1F 04 0075*  	call vdu_flip
04374B             0076*  
04374B             0077*  ; decrement loop counter
04374B C1          0078*      pop bc
04374C 0B          0079*  	dec bc
04374D 79          0080*      ld a,c
04374E B7          0081*      or a
04374F C2 1E 37 04 0082*      jp nz,img_load_main_loop
043753 78          0083*      ld a,b
043754 B7          0084*      or a
043755 C2 1E 37 04 0085*      jp nz,img_load_main_loop
043759 C9          0086*      ret
04375A             0087*  
04375A             0088*  load_next_image:
04375A 16 12       0089*      ld d,image_record_size
04375C 3A DC 36 04 0090*  	ld a,(cur_file_idx)
043760 5F          0091*  	ld e,a
043761 ED 5C       0092*      mlt de
043763 FD 2A D9 36 0093*      ld iy,(cur_image_list)
       04          
043768 FD 19       0094*      add iy,de
04376A             0095*  
04376A FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
04376D FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
043770 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
043773 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
043776 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
043779 22 E2 36 04 0101*  	ld (cur_buffer_id),hl
04377D FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
043780 FD 22 DF 36 0103*  	ld (cur_filename),iy
       04          
043785 CD 7A 21 04 0104*      call vdu_load_img
043789 FD 21 DC 36 0105*      ld iy,cur_file_idx
       04          
04378E FD 34 00    0106*  	inc (iy)
043791 C9          0107*  	ret
043792             0108*  
043792             0109*  img_load_init:
043792             0110*  ; initialize logo's position parameters
043792 21 00 00 00 0111*  	ld hl,0
043796 22 DF 37 04 0112*  	ld (logo_xvel),hl
04379A 22 E2 37 04 0113*  	ld (logo_xpos),hl
04379E             0114*  ; begin 16.8 maths to determine logo's y position and velocity
04379E 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
0437A2 22 E8 37 04 0116*  	ld (logo_ypos),hl
0437A6 EB          0117*  	ex de,hl
0437A7 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
0437AB 19          0119*  	add hl,de ; distance for logo to travel
0437AC 11 00 A1 FF 0120*  	ld de,-sprites_num_images*256
0437B0 CD 77 30 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
0437B4 ED 53 E5 37 0122*  	ld (logo_yvel),de
       04          
0437B9             0123*  ; all done
0437B9 C9          0124*      ret
0437BA             0125*  
0437BA             0126*  move_logo:
0437BA             0127*  ; activate logo bitmap
0437BA 21 03 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
0437BE CD 5C 20 04 0129*  	call vdu_buff_select
0437C2             0130*  ; update position based on velocity parameters
0437C2 2A E8 37 04 0131*  	ld hl,(logo_ypos)
0437C6 ED 5B E5 37 0132*  	ld de,(logo_yvel)
       04          
0437CB 19          0133*  	add hl,de
0437CC 22 E8 37 04 0134*  	ld (logo_ypos),hl
0437D0             0135*  ; draw logo
0437D0 ED 4B E2 37 0136*  	ld bc,(logo_xpos)
       04          
0437D5 ED 5B E8 37 0137*  	ld de,(logo_ypos)
       04          
0437DA CD 41 23 04 0138*  	call vdu_plot_bmp168
0437DE C9          0139*  	ret
0437DF             0140*  
0437DF 00 00 00    0141*  logo_xvel: dl 0
0437E2 00 00 00    0142*  logo_xpos: dl 0
0437E5             0143*  
0437E5 00 00 00    0144*  logo_yvel: dl 0
0437E8 00 00 00    0145*  logo_ypos: dl 0
0437EB             0070   	include "images_sprites.inc"
0437EB             0001*  ; Generated by make_images.py
0437EB             0002*  
0437EB             0003*  sprites_num_images: equ 95
0437EB             0004*  
0437EB             0005*  ; buffer_ids:
0437EB             0006*  BUF_0TILE_EMPTY: equ 256
0437EB             0007*  BUF_1TILE_CROSS: equ 257
0437EB             0008*  BUF_2TILE_HORIZ: equ 258
0437EB             0009*  BUF_3TILE_VERT: equ 259
0437EB             0010*  BUF_4TILE_SQUARE: equ 260
0437EB             0011*  BUF_5TILE_CIRCLE: equ 261
0437EB             0012*  BUF_6TILE_PAD: equ 262
0437EB             0013*  BUF_7TILE_TURRET: equ 263
0437EB             0014*  BUF_CIRCLE: equ 264
0437EB             0015*  BUF_CRATER: equ 265
0437EB             0016*  BUF_EXPLOSION_A: equ 266
0437EB             0017*  BUF_EXPLOSION_B: equ 267
0437EB             0018*  BUF_EXPLOSION_C: equ 268
0437EB             0019*  BUF_EXPLOSION_D: equ 269
0437EB             0020*  BUF_EXPLOSION_E: equ 270
0437EB             0021*  BUF_FIREBALL_A: equ 271
0437EB             0022*  BUF_FIREBALL_B: equ 272
0437EB             0023*  BUF_LASER_A: equ 273
0437EB             0024*  BUF_LASER_B: equ 274
0437EB             0025*  BUF_PAD: equ 275
0437EB             0026*  BUF_SEEKER_000: equ 276
0437EB             0027*  BUF_SEEKER_008: equ 277
0437EB             0028*  BUF_SEEKER_016: equ 278
0437EB             0029*  BUF_SEEKER_024: equ 279
0437EB             0030*  BUF_SEEKER_032: equ 280
0437EB             0031*  BUF_SEEKER_040: equ 281
0437EB             0032*  BUF_SEEKER_048: equ 282
0437EB             0033*  BUF_SEEKER_056: equ 283
0437EB             0034*  BUF_SEEKER_064: equ 284
0437EB             0035*  BUF_SEEKER_072: equ 285
0437EB             0036*  BUF_SEEKER_080: equ 286
0437EB             0037*  BUF_SEEKER_088: equ 287
0437EB             0038*  BUF_SEEKER_096: equ 288
0437EB             0039*  BUF_SEEKER_104: equ 289
0437EB             0040*  BUF_SEEKER_112: equ 290
0437EB             0041*  BUF_SEEKER_120: equ 291
0437EB             0042*  BUF_SEEKER_128: equ 292
0437EB             0043*  BUF_SEEKER_136: equ 293
0437EB             0044*  BUF_SEEKER_144: equ 294
0437EB             0045*  BUF_SEEKER_152: equ 295
0437EB             0046*  BUF_SEEKER_160: equ 296
0437EB             0047*  BUF_SEEKER_168: equ 297
0437EB             0048*  BUF_SEEKER_176: equ 298
0437EB             0049*  BUF_SEEKER_184: equ 299
0437EB             0050*  BUF_SEEKER_192: equ 300
0437EB             0051*  BUF_SEEKER_200: equ 301
0437EB             0052*  BUF_SEEKER_208: equ 302
0437EB             0053*  BUF_SEEKER_216: equ 303
0437EB             0054*  BUF_SEEKER_224: equ 304
0437EB             0055*  BUF_SEEKER_232: equ 305
0437EB             0056*  BUF_SEEKER_240: equ 306
0437EB             0057*  BUF_SEEKER_248: equ 307
0437EB             0058*  BUF_SHIP_0L: equ 308
0437EB             0059*  BUF_SHIP_1C: equ 309
0437EB             0060*  BUF_SHIP_2R: equ 310
0437EB             0061*  BUF_SHIP_SMALL: equ 311
0437EB             0062*  BUF_STAR: equ 312
0437EB             0063*  BUF_STATION_BG_00: equ 313
0437EB             0064*  BUF_STATION_BG_01: equ 314
0437EB             0065*  BUF_STATION_BG_02: equ 315
0437EB             0066*  BUF_STATION_BG_03: equ 316
0437EB             0067*  BUF_STATION_BG_04: equ 317
0437EB             0068*  BUF_STATION_BG_05: equ 318
0437EB             0069*  BUF_TURRET_000: equ 319
0437EB             0070*  BUF_TURRET_008: equ 320
0437EB             0071*  BUF_TURRET_016: equ 321
0437EB             0072*  BUF_TURRET_024: equ 322
0437EB             0073*  BUF_TURRET_032: equ 323
0437EB             0074*  BUF_TURRET_040: equ 324
0437EB             0075*  BUF_TURRET_048: equ 325
0437EB             0076*  BUF_TURRET_056: equ 326
0437EB             0077*  BUF_TURRET_064: equ 327
0437EB             0078*  BUF_TURRET_072: equ 328
0437EB             0079*  BUF_TURRET_080: equ 329
0437EB             0080*  BUF_TURRET_088: equ 330
0437EB             0081*  BUF_TURRET_096: equ 331
0437EB             0082*  BUF_TURRET_104: equ 332
0437EB             0083*  BUF_TURRET_112: equ 333
0437EB             0084*  BUF_TURRET_120: equ 334
0437EB             0085*  BUF_TURRET_128: equ 335
0437EB             0086*  BUF_TURRET_136: equ 336
0437EB             0087*  BUF_TURRET_144: equ 337
0437EB             0088*  BUF_TURRET_152: equ 338
0437EB             0089*  BUF_TURRET_160: equ 339
0437EB             0090*  BUF_TURRET_168: equ 340
0437EB             0091*  BUF_TURRET_176: equ 341
0437EB             0092*  BUF_TURRET_184: equ 342
0437EB             0093*  BUF_TURRET_192: equ 343
0437EB             0094*  BUF_TURRET_200: equ 344
0437EB             0095*  BUF_TURRET_208: equ 345
0437EB             0096*  BUF_TURRET_216: equ 346
0437EB             0097*  BUF_TURRET_224: equ 347
0437EB             0098*  BUF_TURRET_232: equ 348
0437EB             0099*  BUF_TURRET_240: equ 349
0437EB             0100*  BUF_TURRET_248: equ 350
0437EB             0101*  
0437EB             0102*  sprites_image_list: ; type; width; height; filename; bufferId:
0437EB 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       99 3E 04 00 
       01 00       
0437FD 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       B3 3E 04 01 
       01 00       
04380F 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       CD 3E 04 02 
       01 00       
043821 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       E7 3E 04 03 
       01 00       
043833 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       00 3F 04 04 
       01 00       
043845 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       1B 3F 04 05 
       01 00       
043857 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       36 3F 04 06 
       01 00       
043869 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       4E 3F 04 07 
       01 00       
04387B 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       69 3F 04 08 
       01 00       
04388D 01 00 00 10 0112*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       7E 3F 04 09 
       01 00       
04389F 01 00 00 10 0113*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       93 3F 04 0A 
       01 00       
0438B1 01 00 00 10 0114*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       AD 3F 04 0B 
       01 00       
0438C3 01 00 00 10 0115*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       C7 3F 04 0C 
       01 00       
0438D5 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       E1 3F 04 0D 
       01 00       
0438E7 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       FB 3F 04 0E 
       01 00       
0438F9 01 00 00 07 0118*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       15 40 04 0F 
       01 00       
04390B 01 00 00 07 0119*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       2E 40 04 10 
       01 00       
04391D 01 00 00 05 0120*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       47 40 04 11 
       01 00       
04392F 01 00 00 05 0121*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       5D 40 04 12 
       01 00       
043941 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       73 40 04 13 
       01 00       
043953 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       85 40 04 14 
       01 00       
043965 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       9E 40 04 15 
       01 00       
043977 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       B7 40 04 16 
       01 00       
043989 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       D0 40 04 17 
       01 00       
04399B 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       E9 40 04 18 
       01 00       
0439AD 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       02 41 04 19 
       01 00       
0439BF 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       1B 41 04 1A 
       01 00       
0439D1 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       34 41 04 1B 
       01 00       
0439E3 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       4D 41 04 1C 
       01 00       
0439F5 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       66 41 04 1D 
       01 00       
043A07 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       7F 41 04 1E 
       01 00       
043A19 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       98 41 04 1F 
       01 00       
043A2B 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       B1 41 04 20 
       01 00       
043A3D 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       CA 41 04 21 
       01 00       
043A4F 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       E3 41 04 22 
       01 00       
043A61 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       FC 41 04 23 
       01 00       
043A73 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       15 42 04 24 
       01 00       
043A85 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       2E 42 04 25 
       01 00       
043A97 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       47 42 04 26 
       01 00       
043AA9 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       60 42 04 27 
       01 00       
043ABB 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       79 42 04 28 
       01 00       
043ACD 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       92 42 04 29 
       01 00       
043ADF 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       AB 42 04 2A 
       01 00       
043AF1 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       C4 42 04 2B 
       01 00       
043B03 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       DD 42 04 2C 
       01 00       
043B15 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       F6 42 04 2D 
       01 00       
043B27 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       0F 43 04 2E 
       01 00       
043B39 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       28 43 04 2F 
       01 00       
043B4B 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       41 43 04 30 
       01 00       
043B5D 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       5A 43 04 31 
       01 00       
043B6F 01 00 00 10 0153*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       73 43 04 32 
       01 00       
043B81 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       8C 43 04 33 
       01 00       
043B93 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       A5 43 04 34 
       01 00       
043BA5 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       BB 43 04 35 
       01 00       
043BB7 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       D1 43 04 36 
       01 00       
043BC9 01 00 00 08 0158*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       E7 43 04 37 
       01 00       
043BDB 01 00 00 05 0159*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       00 44 04 38 
       01 00       
043BED 01 00 00 00 0160*  	dl 1, 256, 256, 65536, fn_station_bg_00, 313
       01 00 00 01 
       00 00 00 01 
       13 44 04 39 
       01 00       
043BFF 01 00 00 00 0161*  	dl 1, 256, 256, 65536, fn_station_bg_01, 314
       01 00 00 01 
       00 00 00 01 
       2F 44 04 3A 
       01 00       
043C11 01 00 00 00 0162*  	dl 1, 256, 256, 65536, fn_station_bg_02, 315
       01 00 00 01 
       00 00 00 01 
       4B 44 04 3B 
       01 00       
043C23 01 00 00 00 0163*  	dl 1, 256, 256, 65536, fn_station_bg_03, 316
       01 00 00 01 
       00 00 00 01 
       67 44 04 3C 
       01 00       
043C35 01 00 00 00 0164*  	dl 1, 256, 256, 65536, fn_station_bg_04, 317
       01 00 00 01 
       00 00 00 01 
       83 44 04 3D 
       01 00       
043C47 01 00 00 00 0165*  	dl 1, 256, 256, 65536, fn_station_bg_05, 318
       01 00 00 01 
       00 00 00 01 
       9F 44 04 3E 
       01 00       
043C59 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_000, 319
       00 00 10 00 
       00 00 01 00 
       BB 44 04 3F 
       01 00       
043C6B 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_008, 320
       00 00 10 00 
       00 00 01 00 
       D4 44 04 40 
       01 00       
043C7D 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_016, 321
       00 00 10 00 
       00 00 01 00 
       ED 44 04 41 
       01 00       
043C8F 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_024, 322
       00 00 10 00 
       00 00 01 00 
       06 45 04 42 
       01 00       
043CA1 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_032, 323
       00 00 10 00 
       00 00 01 00 
       1F 45 04 43 
       01 00       
043CB3 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_040, 324
       00 00 10 00 
       00 00 01 00 
       38 45 04 44 
       01 00       
043CC5 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_048, 325
       00 00 10 00 
       00 00 01 00 
       51 45 04 45 
       01 00       
043CD7 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_056, 326
       00 00 10 00 
       00 00 01 00 
       6A 45 04 46 
       01 00       
043CE9 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_064, 327
       00 00 10 00 
       00 00 01 00 
       83 45 04 47 
       01 00       
043CFB 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_072, 328
       00 00 10 00 
       00 00 01 00 
       9C 45 04 48 
       01 00       
043D0D 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_080, 329
       00 00 10 00 
       00 00 01 00 
       B5 45 04 49 
       01 00       
043D1F 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_088, 330
       00 00 10 00 
       00 00 01 00 
       CE 45 04 4A 
       01 00       
043D31 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_096, 331
       00 00 10 00 
       00 00 01 00 
       E7 45 04 4B 
       01 00       
043D43 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_104, 332
       00 00 10 00 
       00 00 01 00 
       00 46 04 4C 
       01 00       
043D55 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_112, 333
       00 00 10 00 
       00 00 01 00 
       19 46 04 4D 
       01 00       
043D67 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_120, 334
       00 00 10 00 
       00 00 01 00 
       32 46 04 4E 
       01 00       
043D79 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_128, 335
       00 00 10 00 
       00 00 01 00 
       4B 46 04 4F 
       01 00       
043D8B 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_136, 336
       00 00 10 00 
       00 00 01 00 
       64 46 04 50 
       01 00       
043D9D 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_144, 337
       00 00 10 00 
       00 00 01 00 
       7D 46 04 51 
       01 00       
043DAF 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_152, 338
       00 00 10 00 
       00 00 01 00 
       96 46 04 52 
       01 00       
043DC1 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_turret_160, 339
       00 00 10 00 
       00 00 01 00 
       AF 46 04 53 
       01 00       
043DD3 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_turret_168, 340
       00 00 10 00 
       00 00 01 00 
       C8 46 04 54 
       01 00       
043DE5 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_turret_176, 341
       00 00 10 00 
       00 00 01 00 
       E1 46 04 55 
       01 00       
043DF7 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_turret_184, 342
       00 00 10 00 
       00 00 01 00 
       FA 46 04 56 
       01 00       
043E09 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_turret_192, 343
       00 00 10 00 
       00 00 01 00 
       13 47 04 57 
       01 00       
043E1B 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_turret_200, 344
       00 00 10 00 
       00 00 01 00 
       2C 47 04 58 
       01 00       
043E2D 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_turret_208, 345
       00 00 10 00 
       00 00 01 00 
       45 47 04 59 
       01 00       
043E3F 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_turret_216, 346
       00 00 10 00 
       00 00 01 00 
       5E 47 04 5A 
       01 00       
043E51 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_turret_224, 347
       00 00 10 00 
       00 00 01 00 
       77 47 04 5B 
       01 00       
043E63 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_turret_232, 348
       00 00 10 00 
       00 00 01 00 
       90 47 04 5C 
       01 00       
043E75 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_turret_240, 349
       00 00 10 00 
       00 00 01 00 
       A9 47 04 5D 
       01 00       
043E87 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_turret_248, 350
       00 00 10 00 
       00 00 01 00 
       C2 47 04 5E 
       01 00       
043E99             0198*  
043E99             0199*  ; files_list: ; filename:
043E99 73 70 72 69 0200*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
043EB3 73 70 72 69 0201*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
043ECD 73 70 72 69 0202*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
043EE7 73 70 72 69 0203*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
043F00 73 70 72 69 0204*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043F1B 73 70 72 69 0205*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043F36 73 70 72 69 0206*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043F4E 73 70 72 69 0207*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043F69 73 70 72 69 0208*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043F7E 73 70 72 69 0209*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043F93 73 70 72 69 0210*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043FAD 73 70 72 69 0211*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043FC7 73 70 72 69 0212*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043FE1 73 70 72 69 0213*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043FFB 73 70 72 69 0214*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
044015 73 70 72 69 0215*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
04402E 73 70 72 69 0216*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
044047 73 70 72 69 0217*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
04405D 73 70 72 69 0218*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
044073 73 70 72 69 0219*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
044085 73 70 72 69 0220*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
04409E 73 70 72 69 0221*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0440B7 73 70 72 69 0222*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
0440D0 73 70 72 69 0223*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
0440E9 73 70 72 69 0224*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
044102 73 70 72 69 0225*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
04411B 73 70 72 69 0226*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
044134 73 70 72 69 0227*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
04414D 73 70 72 69 0228*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
044166 73 70 72 69 0229*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
04417F 73 70 72 69 0230*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
044198 73 70 72 69 0231*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0441B1 73 70 72 69 0232*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
0441CA 73 70 72 69 0233*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
0441E3 73 70 72 69 0234*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
0441FC 73 70 72 69 0235*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044215 73 70 72 69 0236*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
04422E 73 70 72 69 0237*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
044247 73 70 72 69 0238*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044260 73 70 72 69 0239*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
044279 73 70 72 69 0240*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
044292 73 70 72 69 0241*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0442AB 73 70 72 69 0242*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0442C4 73 70 72 69 0243*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
0442DD 73 70 72 69 0244*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
0442F6 73 70 72 69 0245*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04430F 73 70 72 69 0246*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
044328 73 70 72 69 0247*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044341 73 70 72 69 0248*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
04435A 73 70 72 69 0249*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
044373 73 70 72 69 0250*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04438C 73 70 72 69 0251*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0443A5 73 70 72 69 0252*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
0443BB 73 70 72 69 0253*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
0443D1 73 70 72 69 0254*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
0443E7 73 70 72 69 0255*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
044400 73 70 72 69 0256*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
044413 73 70 72 69 0257*  fn_station_bg_00: db "sprites/station_bg_00.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       30 2E 72 67 
       62 61 32 00 
04442F 73 70 72 69 0258*  fn_station_bg_01: db "sprites/station_bg_01.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       31 2E 72 67 
       62 61 32 00 
04444B 73 70 72 69 0259*  fn_station_bg_02: db "sprites/station_bg_02.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       32 2E 72 67 
       62 61 32 00 
044467 73 70 72 69 0260*  fn_station_bg_03: db "sprites/station_bg_03.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       33 2E 72 67 
       62 61 32 00 
044483 73 70 72 69 0261*  fn_station_bg_04: db "sprites/station_bg_04.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       34 2E 72 67 
       62 61 32 00 
04449F 73 70 72 69 0262*  fn_station_bg_05: db "sprites/station_bg_05.rgba2",0
       74 65 73 2F 
       73 74 61 74 
       69 6F 6E 5F 
       62 67 5F 30 
       35 2E 72 67 
       62 61 32 00 
0444BB 73 70 72 69 0263*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
0444D4 73 70 72 69 0264*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
0444ED 73 70 72 69 0265*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
044506 73 70 72 69 0266*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
04451F 73 70 72 69 0267*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
044538 73 70 72 69 0268*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
044551 73 70 72 69 0269*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
04456A 73 70 72 69 0270*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
044583 73 70 72 69 0271*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
04459C 73 70 72 69 0272*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
0445B5 73 70 72 69 0273*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
0445CE 73 70 72 69 0274*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
0445E7 73 70 72 69 0275*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
044600 73 70 72 69 0276*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044619 73 70 72 69 0277*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
044632 73 70 72 69 0278*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
04464B 73 70 72 69 0279*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
044664 73 70 72 69 0280*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
04467D 73 70 72 69 0281*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
044696 73 70 72 69 0282*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0446AF 73 70 72 69 0283*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
0446C8 73 70 72 69 0284*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
0446E1 73 70 72 69 0285*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
0446FA 73 70 72 69 0286*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
044713 73 70 72 69 0287*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
04472C 73 70 72 69 0288*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
044745 73 70 72 69 0289*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
04475E 73 70 72 69 0290*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
044777 73 70 72 69 0291*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
044790 73 70 72 69 0292*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0447A9 73 70 72 69 0293*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
0447C2 73 70 72 69 0294*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
0447DB             0071   	include "images_ui.inc"
0447DB             0001*  ; Generated by make_images.py
0447DB             0002*  
0447DB             0003*  ui_num_images: equ 4
0447DB             0004*  
0447DB             0005*  ; buffer_ids:
0447DB             0006*  BUF_BEZEL_L: equ 0
0447DB             0007*  BUF_BEZEL_R: equ 1
0447DB             0008*  BUF_SPLASH_BG: equ 2
0447DB             0009*  BUF_SPLASH_LOGO: equ 3
0447DB             0010*  
0447DB             0011*  ui_image_list: ; type; width; height; filename; bufferId:
0447DB 01 00 00 80 0012*  	dl 1, 128, 384, 49152, fn_bezel_l, 0
       00 00 80 01 
       00 00 C0 00 
       23 48 04 00 
       00 00       
0447ED 01 00 00 80 0013*  	dl 1, 128, 384, 49152, fn_bezel_r, 1
       00 00 80 01 
       00 00 C0 00 
       34 48 04 01 
       00 00       
0447FF 01 00 00 40 0014*  	dl 1, 320, 240, 76800, fn_splash_bg, 2
       01 00 F0 00 
       00 00 2C 01 
       45 48 04 02 
       00 00       
044811 01 00 00 40 0015*  	dl 1, 320, 240, 76800, fn_splash_logo, 3
       01 00 F0 00 
       00 00 2C 01 
       58 48 04 03 
       00 00       
044823             0016*  
044823             0017*  ; files_list: ; filename:
044823 75 69 2F 62 0018*  fn_bezel_l: db "ui/bezel_l.rgba2",0
       65 7A 65 6C 
       5F 6C 2E 72 
       67 62 61 32 
       00          
044834 75 69 2F 62 0019*  fn_bezel_r: db "ui/bezel_r.rgba2",0
       65 7A 65 6C 
       5F 72 2E 72 
       67 62 61 32 
       00          
044845 75 69 2F 73 0020*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
044858 75 69 2F 73 0021*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
04486D             0072   	include "files.inc"
04486D             0001*  ; load to onboard 8k sram
04486D             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04486D             0073   
04486D 57 65 6C 63 0074   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
044888 4C 6F 61 64 0075   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044893 4C 6F 61 64 0076   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0448A1 50 72 65 73 0077   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0448BC             0078   
0448BC             0079   init:
0448BC             0080   ; clear all buffers
0448BC CD 4E 21 04 0081       call vdu_clear_all_buffers
0448C0             0082   
0448C0             0083   ; set up the display
0448C0 3E 88       0084       ld a,8+128 ; 136   320   240   64    60hz double-buffered
0448C2 CD 38 20 04 0085       call vdu_set_screen_mode
0448C6 AF          0086       xor a
0448C7 CD 49 20 04 0087       call vdu_set_scaling
0448CB             0088   
0448CB             0089   ; ; enable additional audio channels
0448CB             0090   ; 	call vdu_enable_channels
0448CB             0091   
0448CB             0092   ; set text background color
0448CB 3E 84       0093   	ld a,4 + 128
0448CD CD A0 1F 04 0094   	call vdu_colour_text
0448D1             0095   
0448D1             0096   ; set text foreground color
0448D1 3E 2F       0097   	ld a,47 ; aaaaff lavenderish
0448D3 CD A0 1F 04 0098   	call vdu_colour_text
0448D7             0099   
0448D7             0100   ; set gfx bg color
0448D7 AF          0101   	xor a ; plotting mode 0
0448D8 0E 84       0102   	ld c,4+128 ; dark blue bg
0448DA CD B1 1F 04 0103   	call vdu_gcol
0448DE CD 82 1F 04 0104   	call vdu_clg
0448E2             0105   
0448E2             0106   ; set the cursor off
0448E2 CD 37 1F 04 0107   	call vdu_cursor_off
0448E6             0108   
0448E6             0109   ; VDU 28, left, bottom, right, top: Set text viewport **
0448E6             0110   ; MIND THE LITTLE-ENDIANESS
0448E6             0111   ; inputs: c=left,b=bottom,e=right,d=top
0448E6 0E 00       0112   	ld c,0 ; left
0448E8 16 1D       0113   	ld d,29 ; top
0448EA 1E 27       0114   	ld e,39 ; right
0448EC 06 1D       0115   	ld b,29; bottom
0448EE CD C8 1F 04 0116   	call vdu_set_txt_viewport
0448F2             0117   
0448F2             0118   ; print loading ui message
0448F2 21 88 48 04 0119   	ld hl,loading_ui
0448F6 CD 0D 19 04 0120   	call printString
0448FA CD 74 1F 04 0121   	call vdu_flip
0448FE             0122   
0448FE             0123   ; load UI images
0448FE CD E5 36 04 0124   	call load_ui_images
044902             0125   
044902             0126   ; ; load fonts ; TODO
044902             0127   ; 	call load_font_rc
044902             0128   
044902             0129   ; load sprites
044902 CD 92 37 04 0130   	call img_load_init ; sets up the animated load screen
044906 CD 00 37 04 0131   	call load_sprite_images
04490A             0132   
04490A             0133   ; ; load sound effects ; TODO
04490A             0134   ; 	ld bc,SFX_num_buffers
04490A             0135   ; 	ld hl,SFX_buffer_id_lut
04490A             0136   ; 	ld (cur_buffer_id_lut),hl
04490A             0137   ; 	ld hl,SFX_load_routines_table
04490A             0138   ; 	ld (cur_load_jump_table),hl
04490A             0139   ; 	call sfx_load_main
04490A             0140   
04490A             0141   ; print loading complete message and wait for user keypress
04490A CD 6F 1F 04 0142   	call vdu_cls
04490E 21 A1 48 04 0143   	ld hl,loading_complete
044912 CD 0D 19 04 0144   	call printString
044916 CD 74 1F 04 0145   	call vdu_flip
04491A CD AB 1E 04 0146   	call waitKeypress
04491E             0147   
04491E             0148   ; set up display for gameplay
04491E             0149       ; ld a,8
04491E 3E 14       0150   	ld a,20
044920 CD 38 20 04 0151       call vdu_set_screen_mode
044924 AF          0152       xor a
044925 CD 49 20 04 0153       call vdu_set_scaling
044929 CD 37 1F 04 0154   	call vdu_cursor_off
04492D             0155   ; plot bezel art
04492D 21 00 00 00 0156   	ld hl,BUF_BEZEL_L
044931 CD 5C 20 04 0157   	call vdu_buff_select
044935 01 00 00 00 0158   	ld bc,0
044939 11 00 00 00 0159   	ld de,0
04493D CD 25 23 04 0160   	call vdu_plot_bmp
044941 21 01 00 00 0161   	ld hl,BUF_BEZEL_R
044945 CD 5C 20 04 0162   	call vdu_buff_select
044949 01 80 01 00 0163   	ld bc,384
04494D 11 00 00 00 0164   	ld de,0
044951 CD 25 23 04 0165   	call vdu_plot_bmp
044955             0166   ; set gfx origin and viewport to playing field window
044955 01 80 00 00 0167   	ld bc,128
044959 11 00 00 00 0168   	ld de,0
04495D CD F4 1F 04 0169   	call vdu_set_gfx_origin
044961 01 00 00 00 0170   	ld bc,field_left
044965 11 00 00 00 0171   	ld de,field_top
044969 DD 21 FF 00 0172   	ld ix,field_right
       00          
04496E FD 21 7F 01 0173   	ld iy,field_bottom
       00          
044973 CD 0F 20 04 0174   	call vdu_set_gfx_viewport
044977             0175   ; set background color
044977 0E 9B       0176   	ld c,27+128 ; darkest purple in the palette
044979 CD B1 1F 04 0177   	call vdu_gcol
04497D CD 82 1F 04 0178   	call vdu_clg
044981             0179   
044981 C9          0180   	ret
044982             0181   
044982             0182   field_top: equ 0
044982             0183   field_bottom: equ 383
044982             0184   field_left: equ 0
044982             0185   field_right: equ 255
044982             0186   
044982             0187   new_game:
044982             0188   ; initialize sprites
044982 CD B5 18 04 0189   	call sprites_init
044986             0190   
044986             0191   ; initialize the first level
044986 AF          0192   	xor a
044987 32 C8 31 04 0193   	ld (cur_level),a
04498B CD A2 32 04 0194   	call init_level
04498F             0195   
04498F             0196   ; initialize player
04498F CD EE 30 04 0197   	call player_init
044993             0198   
044993             0199   ; spawn an enemy sprite
044993 06 10       0200   	ld b,table_max_records
044995             0201   @spawn_enemy_loop:
044995 C5          0202   	push bc
044996 CD F9 33 04 0203   	call enemy_init_from_landing_pad
04499A C1          0204   	pop bc
04499B 10 F8       0205   	djnz @spawn_enemy_loop
04499D             0206   
04499D C9          0207   	ret
04499E             0208   
04499E             0209   ; ; ###### INITIALIZE GAME #######
04499E             0210   ; ; clear the screen
04499E             0211   ;     ld a,3
04499E             0212   ;     out (81h),a
04499E             0213   
04499E             0214   ; ; reset the sprite table
04499E             0215   ;     xor a
04499E             0216   ;     ld (table_active_sprites),a
04499E             0217   ;     ld hl,table_limit
04499E             0218   ;     ld (table_base),hl
04499E             0219   ;     ld (table_pointer),hl
04499E             0220   
04499E             0221   ; ; draw a starfield over the entire screen
04499E             0222   ;     ld b,#50 ; first row of visible screen
04499E             0223   ; new_game_draw_stars_loop:
04499E             0224   ;     push bc
04499E             0225   ;     call draw_stars
04499E             0226   ;     pop bc
04499E             0227   ;     ld a,#10
04499E             0228   ;     add a,b
04499E             0229   ;     ld b,a
04499E             0230   ;     jr nz,new_game_draw_stars_loop
04499E             0231   
04499E             0232   ; ; ; print a welcome message
04499E             0233   ; ;     ld de,msg_welcome
04499E             0234   ; ;     ld hl,#581C
04499E             0235   ; ;     ld c,218 ; a bright pastel purple d677e3
04499E             0236   ; ;     call print_string
04499E             0237   
04499E             0238   ; ; push all that to frame buffer
04499E             0239   ;     ld a,#01 ; send video to frame buffer
04499E             0240   ;     out (81h),a
04499E             0241   
04499E             0242   ; ; reset score, lives, shields
04499E             0243   ;     xor a
04499E             0244   ;     ld hl,player_score
04499E             0245   ;     ld (hl),a ; player_score 0
04499E             0246   ;     inc hl
04499E             0247   ;     ld (hl),a ; player_score 1
04499E             0248   ;     inc hl
04499E             0249   ;     ld (hl),a ; player_score 3
04499E             0250   ;     inc hl
04499E             0251   ;     ld a,16
04499E             0252   ;     ld (hl),a ; player_shields
04499E             0253   ;     inc hl
04499E             0254   ;     ld (hl),a ; player_max_shields
04499E             0255   ;     inc hl
04499E             0256   ;     ld a,3
04499E             0257   ;     ld (hl),a ; player_ships
04499E             0258   ;     inc hl
04499E             0259   
04499E             0260   ; ; initialize first level
04499E             0261   ;     ld a,1 ; levels are zero-based, so this will wrap around
04499E             0262   ;     ld (cur_level),a
04499E             0263   ;     ld a,3 ; set max enemy sprites to easy street
04499E             0264   ;     ld (max_enemy_sprites),a
04499E             0265   ;     call dt_next_level
04499E             0266   ;     call dt
04499E             0267   
04499E             0268   ; ; spawn our intrepid hero
04499E             0269   ;     call player_init
04499E             0270   
04499E             0271   ; ; #### BEGIN GAME VARIABLES ####
04499E             0272   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
04499E             0273   speed_player: equ 0x000300 ; 3 pixels per frame
04499E             0274   
04499E             0275   main:
04499E             0276   ; start a new game
04499E CD 82 49 04 0277   	call new_game
0449A2             0278   
0449A2             0279   main_loop:
0449A2             0280   ; scroll tiles
0449A2 CD D5 31 04 0281   	call tiles_plot
0449A6             0282   
0449A6             0283   ; get player input and update sprite position
0449A6 CD 2D 31 04 0284   	call player_input
0449AA             0285   
0449AA             0286   ; move enemies
0449AA CD 01 33 04 0287   	call move_enemies
0449AE             0288   
0449AE             0289   ; wait for the next vblank mitigate flicker and for loop timing
0449AE CD E3 1F 04 0290   	call vdu_vblank
0449B2             0291   
0449B2             0292   ; poll keyboard
0449B2 3E 08       0293       ld a, $08                           ; code to send to MOS
0449B4 5B CF       0294       rst.lil $08                         ; get IX pointer to System Variables
0449B6             0295   
0449B6 DD 7E 05    0296       ld a, (ix + $05)                    ; get ASCII code of key pressed
0449B9 FE 1B       0297       cp 27                               ; check if 27 (ascii code for ESC)
0449BB CA C3 49 04 0298       jp z, main_end                     ; if pressed, jump to exit
0449BF             0299   
0449BF C3 A2 49 04 0300       jp main_loop
0449C3             0301   
0449C3             0302   main_end:
0449C3 CD 29 1F 04 0303       call vdu_cursor_on
0449C7 C9          0304   	ret
0449C8             0305   
0449C8             0306   
0449C8             0307   ; ; #### BEGIN GAME MAIN LOOP ####
0449C8             0308   ; main_loop:
0449C8             0309   ; ; ; debug: start execution counter
0449C8             0310   ; ;     ld a,1
0449C8             0311   ; ;     out (#e0),a ; start counting instructions
0449C8             0312   
0449C8             0313   ; ; refresh background from frame buffer
0449C8             0314   ;     ld a,#02
0449C8             0315   ;     out (81h),a
0449C8             0316   ;     call move_background ; now move it
0449C8             0317   ;     ld a,#01
0449C8             0318   ;     out (81h),a ; save it back to buffer
0449C8             0319   ; ; do all the things
0449C8             0320   ;     call move_enemies
0449C8             0321   ;     call player_move
0449C8             0322   ;     call laser_control
0449C8             0323   ;     call print_score
0449C8             0324   ;     call draw_shields
0449C8             0325   ;     call draw_lives
0449C8             0326   ; ; ; debug: stop execution counter and print results
0449C8             0327   ; ;     ld a,0
0449C8             0328   ; ;     out (#e0),a ; stop counting instructions
0449C8             0329   
0449C8             0330   ; ; ; debug: start execution counter
0449C8             0331   ; ;     ld a,1
0449C8             0332   ; ;     out (#e0),a ; start counting instructions
0449C8             0333   
0449C8             0334   ;     call vdu_vblank
0449C8             0335   ; ; ; debug: stop execution counter and print results
0449C8             0336   ; ;     ld a,0
0449C8             0337   ; ;     out (#e0),a ; stop counting instructions
0449C8             0338   
0449C8             0339   ;     jr main_loop
0449C8             0340   ; #### END GAME MAIN LOOP ####
0449C8             0341   
0449C8             0342   ; draws the player's shields level
0449C8             0343   ; draw_shields:
0449C8             0344   ; TODO: Agonize this routine
0449C8             0345   ; ; prep the loop to draw the bars
0449C8             0346   ;     ld a,(player_shields) ; snag shields
0449C8             0347   ;     and a
0449C8             0348   ;     ret z ; don't draw if zero shields
0449C8             0349   ; ; set loop counter and drawing position
0449C8             0350   ;     ld b,a ; loop counter
0449C8             0351   ;     ld hl,#5300+48+12
0449C8             0352   ; ; set color based on bars remaining
0449C8             0353   ;     ld c,103 ; bright green 28fe0a
0449C8             0354   ;     cp 9
0449C8             0355   ;     jp p,draw_shields_loop
0449C8             0356   ;     ld c,74 ; bright yellow eafe5b
0449C8             0357   ;     cp 3
0449C8             0358   ;     jp p,draw_shields_loop
0449C8             0359   ;     ld c,28 ; bright red fe0a0a
0449C8             0360   ; draw_shields_loop:
0449C8             0361   ;     push bc ; yup,outta
0449C8             0362   ;     push hl ; registers again
0449C8             0363   ;     ; ld a,#A8 ; ▀,168
0449C8             0364   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
0449C8             0365   ;     ; call draw_char
0449C8             0366   ;     call draw_num ; we nuked draw_char for the time being
0449C8             0367   ;     pop hl
0449C8             0368   ;     ld a,8
0449C8             0369   ;     add a,l
0449C8             0370   ;     ld l,a
0449C8             0371   ;     pop bc
0449C8             0372   ;     djnz draw_shields_loop
0449C8             0373       ; ret
0449C8             0374   
0449C8             0375   ; prints the player's score
0449C8             0376   ; print_score:
0449C8             0377   ; TODO: Agonize this
0449C8             0378   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0449C8             0379   ;     ld c,42 ; dark orange b74400
0449C8             0380   ;     ld hl,#5200+1+8+6*6
0449C8             0381   ;     ld a,3 ; print 6 bdc digits
0449C8             0382   ;     ld de,player_score
0449C8             0383   ;     call print_num
0449C8             0384   
0449C8             0385   ;     ld c,58 ; golden yellow fec10a
0449C8             0386   ;     ld hl,#5100+8+6*6
0449C8             0387   ;     ld a,3 ; print 6 bdc digits
0449C8             0388   ;     ld de,player_score
0449C8             0389   ;     call print_num
0449C8             0390       ; ret
0449C8             0391   
0449C8             0392   ; draw_lives:
0449C8             0393   ;     ld hl,player_small ; make small yellow ship the active sprite
0449C8             0394   ;     ld (sprite_base_bufferId),hl
0449C8             0395   ;     ; ld a,#80 ; northern orientation
0449C8             0396   ;     ; ld (sprite_orientation),a
0449C8             0397   ;     ld hl,0 ; north
0449C8             0398   ;     ld (sprite_heading),hl
0449C8             0399   ;     xor a
0449C8             0400   ;     ld (sprite_animation),a
0449C8             0401   ;     ld a,#56 ; top of visible screen
0449C8             0402   ;     ld (sprite_y+1),a
0449C8             0403   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0449C8             0404   ;     ld a,(player_ships)
0449C8             0405   ;     dec a ; we draw one fewer ships than lives
0449C8             0406   ;     ret z ; nothing to draw here, move along
0449C8             0407   ;     ld b,a ; loop counter
0449C8             0408   ;     ld a,256-16 ; initial x position
0449C8             0409   ; draw_lives_loop:
0449C8             0410   ;     ld (sprite_x+1),a
0449C8             0411   ;     push af
0449C8             0412   ;     push bc
0449C8             0413   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0449C8             0414   ;     pop bc
0449C8             0415   ;     pop af
0449C8             0416   ;     sub 10
0449C8             0417   ;     djnz draw_lives_loop
0449C8             0418   ;     ret
